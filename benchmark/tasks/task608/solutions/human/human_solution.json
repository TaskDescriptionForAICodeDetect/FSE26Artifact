[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <algorithm>\nusing namespace std;\nstruct Fast {\n    Fast() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} fast;\n\nlong long mod = 1000000007;\n\nlong long modpow(long long m, long long n) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        long long t = modpow(m, n / 2);\n        return (t * t) % mod;\n    } else {\n        return (modpow(m, n - 1) * m) % mod;\n    }\n}\nint power(long long x, long long y, long long p) {\n    long long res = 1;  // Initialize result\n\n    x = x % p;  // Update x if it is more than or\n                // equal to p\n\n    while (y > 0) {\n        // If y is odd, multiply x with result\n        if (y & 1) res = (res * x) % p;\n\n        // y must be even now\n        y = y >> 1;  // y = y/2\n        x = (x * x) % p;\n    }\n    return res;\n}\n\nlong long modInverse(long long n, long long p) { return power(n, p - 2, p); }\n\nlong long nCrModPFermat(long long n, long long r, long long p) {\n    if (r == 0) return 1;\n    long long fac[n + 1];\n    fac[0] = 1;\n    for (long long i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % p;\n\n    return (fac[n] * modInverse(fac[r], p) % p * modInverse(fac[n - r], p) % p) % p;\n}\n\nvoid yes() {\n    cout << \"Yes\" << endl;\n    exit(0);\n}\nvoid no() {\n    cout << \"No\" << endl;\n    exit(0);\n}\n#define REP(i, n) for (long long i = 0; i < (n); i++)\n\nsigned main() {\n    long long n, k, ans = 0;\n    cin >> n >> k;\n    cout << nCrModPFermat(n + k - 1, k - 1, mod) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n#include <utility>\n#include <tuple>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\n\n// clang-format off\n#ifdef _DEBUG_\n#define dump(...) do{ cerr << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; PPPPP(__VA_ARGS__); cerr << endl; } while(false)\ntemplate<typename T> void PPPPP(T t) { cerr << t; }\ntemplate<typename T, typename... S> void PPPPP(T t, S... s) { cerr << t << \", \"; PPPPP(s...); }\n#else\n#define dump(...) do{ } while(false)\n#endif\ntemplate<typename T> vector<T> make_v(size_t a, T b) { return vector<T>(a, b); }\ntemplate<typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v(ts...))>(a, make_v(ts...)); }\ntemplate<typename T> bool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false; }\ntemplate<typename T> bool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false; }\ntemplate<typename T> void print(T a) { cout << a << endl; }\ntemplate<typename T, typename... Ts> void print(T a, Ts... ts) { cout << a << ' '; print(ts...); }\ntemplate<typename T> istream &operator,(istream &in, T &t) { return in >> t; }\n// clang-format on\n\ntemplate<ll MOD = 1000000007>\nclass ModInt {\n    ll n;\n    ModInt constexpr inverse() const {\n        return ModInt::pow(*this, MOD - 2);\n    }\n\npublic:\n    ModInt()\n        : n(0) {}\n    ModInt(ll _n)\n        : n(((_n % MOD) + MOD) % MOD) {}\n    ModInt operator+=(const ModInt &m) {\n        n += m.n;\n        if (n >= MOD) n -= MOD;\n        return *this;\n    }\n    ModInt operator-=(const ModInt &m) {\n        n -= m.n;\n        if (n < 0) n += MOD;\n        return *this;\n    }\n    ModInt operator*=(const ModInt &m) {\n        n *= m.n;\n        if (n >= MOD) n %= MOD;\n        return *this;\n    }\n    ModInt operator/=(const ModInt &m) {\n        (*this) *= m.inverse();\n        return *this;\n    }\n    friend ModInt operator+(ModInt t, const ModInt &m) {\n        return t += m;\n    }\n    friend ModInt operator-(ModInt t, const ModInt &m) {\n        return t -= m;\n    }\n    friend ModInt operator*(ModInt t, const ModInt &m) {\n        return t *= m;\n    }\n    friend ModInt operator/(ModInt t, const ModInt &m) {\n        return t /= m;\n    }\n    ModInt operator=(const ll l) {\n        n = l % MOD;\n        if (n < 0) n += MOD;\n        return *this;\n    }\n    friend ostream &operator<<(ostream &out, const ModInt &m) {\n        out << m.n;\n        return out;\n    }\n    friend istream &operator>>(istream &in, ModInt &m) {\n        ll l;\n        in >> l;\n        m = l;\n        return in;\n    }\n    static constexpr ModInt pow(const ModInt x, ll p) {\n        ModInt<MOD> ans = 1;\n        for (ModInt<MOD> m = x; p > 0; p /= 2, m *= m) {\n            if (p % 2) ans *= m;\n        }\n        return ans;\n    }\n};\nusing mint = ModInt<>;\nmint operator\"\" _m(unsigned long long m) {\n    return mint(m);\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, k;\n    cin, n, k;\n    int SZ = 2020;\n    vector<mint> fact(SZ + 1, 1);\n    REP(i, 1, SZ) {\n        fact[i + 1] = fact[i] * (i + 1);\n    }\n    auto nCr = [&](int a, int b) {\n        if (a < b)\n            return 0_m;\n        else\n            return fact[a] / fact[b] / fact[a - b];\n    };\n    cout << nCr(n + k - 1, k - 1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int mod> struct ModInt {\n    int x;\n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) { if((x += p.x) >= mod) x -= mod; return *this; }\n    ModInt &operator-=(const ModInt &p) { if((x += mod-p.x) >= mod) x -= mod; return *this; }\n    ModInt &operator*=(const ModInt &p) { x = (int)(1LL*x*p.x%mod); return *this; }\n    ModInt &operator/=(const ModInt &p) { *this *= p.inverse(); return *this; }\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) { t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n        return ModInt(u);\n    }\n    ModInt pow(long long e){\n        long long a = 1, p = x;\n        while(e > 0) {\n            if (e & 1) {a = (a * p) % mod; e--;}\n            else {p = (p * p) % mod; e /= 2;}\n        }\n        return ModInt(a);\n    }\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\ntemplate<int mod> struct Combination {\n    vector<ModInt<mod>> fact, ifact;\n    Combination(int n) : fact(n+1), ifact(n+1) {\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++) fact[i] = (fact[i - 1] * i);\n        ifact[n] = fact[n].inverse();\n        for (int i = n; i > 0; i--) ifact[i - 1] = ifact[i] * i;\n    }\n    ModInt<mod> operator() (int n, int r) {\n        if (r < 0 or r > n) return 0;\n        return fact[n] * ifact[n-r] * ifact[r];\n    }\n    const ModInt<mod> &operator[] (int i) const {\n        return fact[i];\n    }\n};\n\nconstexpr int MOD = 1000000007;\nconstexpr int MAX = 1000100;\n\nint main() {\n\tCombination<MOD> binom(MAX);\n\tint n, k;\n\tcin >> n >> k;\n\t\n\tcout << binom(n + k - 1, n) << '\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; std::swap(a, m);\n    u -= t * v; std::swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\ntemplate <typename T>\nclass modular {\n  private:\n    int value;\n  public:\n    constexpr modular() = default;\n    constexpr modular(const modular&) = default;\n    constexpr modular(modular&&) = default;\n    modular& operator=(const modular&) = default;\n    modular& operator=(modular&&) = default;\n\n    template <typename U>\n    modular (const U& x) {value = normalize(x);}\n\n    template <typename U>\n    static auto normalize(const U& x) {\n      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());\n      if (v < 0) v += mod();\n      return v;\n    }\n\n    auto const& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static auto mod() { return T::value; }\n\n    auto& operator+=(const modular& other) {\n      if ((value += other.value) >= mod()) value -= mod();\n      return *this;\n    }\n    auto& operator-=(const modular& other) {\n      if ((value -= other.value) < 0) value += mod();\n      return *this;\n    }\n    template <typename U>\n    auto& operator+=(const U& other) {return *this += modular(other); }\n    template <typename U>\n    auto& operator-=(const U& other) {return *this -= modular(other); }\n    auto operator-() const { return modular(-value); }\n    auto& operator++() {return *this += 1;}\n    auto& operator--() {return *this -= 1;}\n    auto  operator++(int) {modular result(*this); operator++(); return result;}\n    auto  operator--(int) {modular result(*this); operator--(); return result;}\n\n    template <typename U = T>\n    auto& operator*=(const modular& rhs) {\n      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n      return *this;\n    }\n    auto& operator/=(const modular& other) {\n      return *this *= modular(inverse(other.value, mod()));\n    }\n};\ntemplate <typename T> struct is_modular : std::false_type {};\ntemplate <typename T> struct is_modular <modular<T>> : std::true_type{};\ntemplate <typename T> constexpr bool is_modular_v = is_modular<T>::value;\n\ntemplate <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs() == rhs(); }\ntemplate <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }\n\ntemplate <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nmodular<T> power (const modular<T>& a, U b) {\n  assert(b >= 0);\n  modular<T> x = a, ret = 1;\n  for (; b > 0; b /= 2) {\n    if (b % 2 == 1) ret *= x;\n    x *= x;\n  }\n  return ret;\n}\n\ntemplate <typename T>\nstd::string to_string(const modular<T>& a) {\n  return std::to_string(a());\n}\ntemplate <typename T>\nauto operator<<(std::ostream& os, const T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a();\n  }\ntemplate <typename T>\nauto operator>>(std::istream& is, T& a)\n  -> std::enable_if_t<is_modular_v<T>, std::istream&> {\n  long long x; is >> x;\n  a = T(x);\n  return is;\n}\n\n// using mod_type = int;\n\n// struct variable_mod { static mod_type value; };\n// mod_type variable_mod::value;\n// mod_type& mod = variable_mod::value;\n// using mint = modular< variable_mod >;\n\nconstexpr int mod = 1'000'000'007;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;\n\ntemplate < typename Value >\nclass factorials {\n    std::vector< Value > fact, finv;\n\n  public:\n    factorials()=default;\n\n    void build(int n) {\n      fact.resize(n), finv.resize(n);\n      fact.at(0) = 1;\n      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * Value(i);\n      finv.at(n - 1) = Value(1) / fact.at(n - 1);\n      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * Value(i + 1);\n    }\n    auto operator()  (int i) const {return fact.at(i);}\n    auto inv         (int i) const {return finv.at(i);}\n    auto binom(int i, int j) const {\n      assert(0 <= i);\n      if (j < 0 ||i < j) return Value(0);\n      return fact.at(i) * finv.at(j) * finv.at(i - j);\n    }\n    auto deal(int i, int j) const\n      { return binom(i + j - 1, j - 1); }\n};\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, k; std::cin >> n >> k;\n  factorials<mint> fact;\n  fact.build(n+k+1);\n  mint ans = fact.deal(n,k);\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <limits>\n#include <time.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<ll> vec;\ntypedef vector<vec> vec2;\ntypedef map<ll,ll> MPll;\ntypedef set<ll> setl;\n\nconst ll INF = 1ll << 60;\nconst ld EPS = 1e-10;\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\nconst ll MOD = 1000000007;\n\n//for文\n#define FOR(i,a,b) for(ll i = (ll)a;i < (ll)b;i++)\n#define FORE(i,a,b) for(ll i = (ll) a;i <= (ll) b;i++ )\n#define REP(i,size)  for(ll i =(ll)0;i<size;i++)\n#define REPE(i,size)  for(ll i =(ll)0;i<=size;i++)\n#define REPR(i,size)  for(ll i =(ll)size;i>=0;i--)\n#define FOREACH(it, vec) for (auto it = vec.begin(); it != vec.end(); it++)\n\n//ソート\n#define ALL(vec) (vec).begin(),(vec).end()\n#define SORT(vec) sort(ALL(vec))\n#define SORTA(arr) sort(arr,arr + (sizeof(arr) / sizeof(ll)))\n#define INVSORT(vec) sort((vec).rbegin(),(vec).rend())\n#define REV(vec) reverse(ALL(vec))\n#define REVA(arr) reverse(arr,arr + (sizeof(arr) / sizeof(ll)))\n#define INVSORTA(arr) sort(arr,arr + (sizeof(arr) / sizeof(ll))),REVA(arr)\n\n//最大値最小値\n#define MAX(vec) *max_element(ALL(vec))\n#define UNIQ(vec) SORT(vec);vec.erase(unique(ALL(vec)),vec.end())\n#define MIN(vec) *min_element(ALL(vec))\n\n//出力\n#define printl(a) cout << a << \"\\n\"\n#define print(a) cout << a\n#define OUT(a) printf(\"%lld\\n\",a)\n#define OUTA(array) REP(i,sizeof(array)/sizeof(ll)) printf(\"%lld\\n\",array[i])\n#define OUTV(vec) REP(i,vec.size()) printf(\"%lld\\n\",vec[i])\n#define SP printf(\" \")\n\n//入力\n#define IN(x) scanf(\"%lld\",&x)\n#define INV(vec) REP(i,vec.size()) scanf(\"%lld\",&vec[i])\n#define INA(array) REP(i,sizeof(array)/sizeof(ll)) scanf(\"%lld\",array + i)\n#define INS(x) cin >> x\n#define INCH(x) scanf(\" %c\",&x)\n\n//型\n#define P pair\n#define vp vector<P>\n#define F first\n#define S second\n\n//その他\n#define PB push_back\n#define MP make_pair\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define INFI(a) memset(a,INF,sizeof(a))\n#define MEM(a,b) memset(a,(b),sizeof(a))\n\n//関数\ntemplate<class T> inline void amax(T &a,const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void amin(T &a, const T &b) { if(a > b) a = b; }\n/*\nstruct structure{\n    ll num1,num2,string s;\n    bool operator<(const rest &another) const{\n        return this->s < another.s;\n    }\n    structure(ll a,ll b,string s){\n        this->num1 = a,this->num2=b,this->s=s;\n    }\n};a\n*/\n//特殊\n//#define int ll\n#define _CRT_SECURE_NO_WARNINGS\n\n#define DEBUG\n\n#ifdef DEBUG\n#define debugl(x) cerr << #x << \":\" << x<<\"\\n\"\n#define debug(x)  cerr << x<<endl;\n#define  debugV(V) REP(i,V.size()){cerr << i << \":\" << V[i]<<endl;}\n#define  debugA(A) REP(i,sizeof(A)/sizeof(ll)){cerr << i << \":\" << V[i]<<endl;}\n#else\n#define debug(x)\n#define debugV(x)\n#define debugA(x)\n#define debugl(x)\n#endif\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define ALL(vec) (vec).begin(),(vec).end()\n#define SORT(vec) sort(ALL(vec))\n\n#include <cstdint>\n\n\n\n\nstruct Edge{\n    ll from,to,cost;\n    Edge(ll to,ll from, ll cost)/*: from(from),to(to),cost(cost)*/{\n        this->to = to;\n        this->from = from;\n        this ->cost = cost;\n    }\n\n    bool operator <(const Edge &another) const{\n        if (this->cost != another.cost) return this->cost < another.cost;\n        if (this->to != another.to) return this->to < another.to;\n        return this ->from < another.from;\n    }\n\n};\n\n\nll rep_pow(ll x,ll n){\n    if (n == 0) return 1;\n    if (n%2 == 0){\n        ll ans = rep_pow(x,n/2);\n        return ans * ans % MOD;\n    }\n\n    return x * rep_pow(x,n/2);\n}\n\n\nll rep_pow2(ll x,ll n){\n    ll ans = 1;\n    while(n >0){\n        if (n & 1){\n            ans = ans * x % MOD;\n        }\n\n        x = x * x % MOD;\n        n = n >> 1;\n    }\n\n    return ans;\n\n}\n\n\ntemplate <typename T>\nstruct UnionFindTree{\n\n    vector<T> par;\n\n    UnionFindTree(T n) : par(n+1){\n        for (int i = 1; i <= n; ++i) {\n            par[i] = i;\n        }\n    }\n\n    T root(T x){\n        if(par[x] == x) return x;\n        else  return par[x] = root(par[x]);\n    }\n\n    void unite(T x,T y){\n        if(!same(x,y)) par[root(x)] = root(par[y]);\n    }\n\n    T same(T x,T y){\n        return root(x) == root(y);\n    }\n\n};\n\nint const inf = INT_MAX;\ntemplate <typename T>\nstruct SegmentTree {\n    T n;\n    vector<T> node;\n\n    SegmentTree(T k)  {\n        n = 0; while(n < k) n *= 2;\n        node.resize(n, inf);\n    }\n\n    void update(T i, T val) {\n        i += n-1;\n        node[i] = val;\n        while(i > 0) {\n            i = (i - 1) / 2;\n            node[i] = min(node[2*i+1], node[2*i+2]);\n        }\n    }\n\n    T find(T a, T b, T k, T l, T r) {\n        if(r == -1) r = n;\n        if(r <= a or b <= l) return inf;\n        if(a <= l and r <= b) return node[k];\n        T h = (l + r) /2 ;\n        return min(find(a, b, 2*k+1, l, h),find(a, b, 2*k+2, h, r));\n    }\n};\n\n\nll fermat_combination(ll n,ll k,vec fac,vec inv){\n    ll ans = fac[n] * inv[k] % MOD * inv[n-k] % MOD;\n    return  ans;\n}\n\n\n\n\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\n\n\nint main() {\n    ll n,k;\n    cin >> n>>k;\n\n\n\n    vec f(2021);\n    vec inv(2021);\n    f[0] = 1;\n    f[1] = 1;\n    inv[0] =1;\n    inv[1] = 1;\n\n\n    FOR(i,2,2010){\n        f[i] = f[i-1] * i % MOD;\n        inv[i] = modinv(f[i],MOD);\n    }\n\n    ll ans = fermat_combination(n+k-1,n,f,inv);\n\n    cout << ans<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <limits>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\n\nconst int INF = 1<<30;\nconst int MOD = (int)1e9 + 7;\nconst int MAX_N = (int)1e5 + 5;\n#define debug(x) cout << #x << \": \" << x << endl\n\ntemplate<typename T> struct Combination\n{\n    vector<T> fact, rfact, inv;\n    Combination(int n) : fact(n + 1), rfact(n + 1), inv(n + 1)\n    {\n        fact[0] = fact[1] = 1;\n        rfact[0] = rfact[1] = 1;\n        inv[1] = 1;\n        for(int i = 2; i < n + 1; i++)\n        {\n            fact[i] = fact[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            rfact[i] = rfact[i - 1] * inv[i] % MOD;\n        }\n    }\n    T C(int n, int k)\n    {\n        if(n < k) return 0;\n        if(n < 0 or k < 0) return 0;\n        return fact[n] * (rfact[k] * rfact[n - k] % MOD) % MOD;\n    }\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, k; cin >> n >> k;\n    Combination<ll> cmd(n + k);\n    cout << cmd.C(n + k - 1, k - 1) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\ntypedef long long ll;\nusing namespace std;\n\nll modpow(ll a, ll b, ll m) {\n  if (b==0) return 1;\n  ll tmp = modpow(a*a%m,b/2,m);\n  if (b&1) tmp = tmp*a%m;\n  return tmp;\n}\n\nll mperm(ll a, ll b, ll m) {\n  if (a < b) {\n    return 0;\n  }\n  ll ret=1;\n  while(b--) {\n    ret = (ret*(a--)) % m;\n  }\n  return ret;\n}\n\nll pminv(ll a, ll p) {\n  return modpow(a,p-2,p);\n}\n\nll mcomb(ll a, ll b, ll m) {\n  return (mperm(a,b,m)*pminv(mperm(b,b,m),m))%m;\n}\n\nint main() {\n  ll n,k,mod=1e9+7;\n  cin>>n>>k;\n  cout<<mcomb(n+k-1,k-1,mod)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)((ll)res * curr % mod);\n    }\n    curr = (T)((ll)curr * curr % mod);\n    tmp >>= 1;\n  }\n  return res;\n}\n\nstruct Factorial{\n  int n;\n  const int MOD = 1e9 + 7;\n  vector<long long> fac;\n  vector<long long> inv_;\n  Factorial(int n): n(n){\n    fac.resize(n + 1);\n    inv_.resize(n + 1);\n    calc_factorial();\n    calc_inv();\n  }\n  void calc_factorial(){\n    fac[0] = 1;\n    for(int i = 1; i <= n; i++){\n      fac[i] = i * fac[i-1] % MOD;\n    }\n  }\n  void calc_inv(){\n    inv_[n] = power<long long>(fac[n], MOD - 2, MOD);\n    for(int i = n - 1; i >= 0; i--){\n      inv_[i] = (i + 1) * inv_[i+1] % MOD;\n    }\n  }\n  long long& operator[](size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return fac[i];\n  }\n  long long inv(size_t i){\n    if(i < 0 || i > n){\n      cerr << \"list index out of range\" << endl;\n      abort();\n    }\n    return inv_[i];\n  }\n  long long comb(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    res = res * inv_[k] % MOD;\n    return res;\n  }\n  long long perm(int n, int k){\n    if(n < k)return 0;\n    long long res = fac[n];\n    res = res * inv_[n-k] % MOD;\n    return res;\n  }\n  long long h(int n, int k){\n    if(n == 0 && k == 0)return 1;\n    return comb(n + k - 1, k);\n  }\n};\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  LL(n); LL(k);\n  Factorial fac(k + n + 1);\n  cout << fac.h(k, n) << endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream> \n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>  \nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000000000000000000000001\n#define LONG_INF 10000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\nlong long power(long long a,long long now) {\n\tlong long ans = 1;\n\twhile (now != 0) {\n\t\tif (now % 2 == 1) {\n\t\t\tans *= a;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\tnow /= 2;\n\t\ta *= a;\n\t\ta %= MAX_MOD;\n\t}\n\treturn ans;\n}\nlong long inv(long long a) {\n\treturn power(a, MAX_MOD - 2);\n}\nlong long Permutation(long long a, long long b) {\n\tlong long ans = 1;\n\tfor (long long i = 0; i < b; ++i) {\n\t\tans *= (a - i);\n\t\tans %= MAX_MOD;\n\t}\n\treturn ans;\n}\nlong long Combination(long long a, long long b) {\n\tlong long ans = 1;\n\tfor (long long i = 0; i < b; ++i) {\n\t\tans *= (a - i);\n\t\tans %= MAX_MOD;\n\t\tans *= inv(i + 1);\n\t\tans %= MAX_MOD;\n\t}\n\treturn ans;\n}\nint main() {\n\tlong long n, k;\n\tcin >> n >> k;\n\tcout << Combination(n + k - 1, n) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nconst int MAX = 510000;\nconst int MOD = 1000000007;\nlong long fac[MAX], finv[MAX], inv[MAX];\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n/*\n    Ball and Boxes 4\n    女、男、制限なし(自由分捕り形式)\n*/\n\nint main() {\n    ll n, k;\n    cin >> n >> k;\n    COMinit();\n\n    ll ans = COM(n+k-1,k-1);\n\n    cout << ans << endl;\n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconstexpr long long MOD = 1'000'000'007;\n\nclass binomial_coefficients {\n\tlong long MAX_VAL;\n\tvector<long long> fac, mmi;\n\npublic:\n\n\tbinomial_coefficients(){\n\t}\n\t\n\tbinomial_coefficients(long long num){\n\t\tinit(num);\n\t}\n\t\n\t~binomial_coefficients(){\n\t\t\n\t}\n\t\n\tvoid init(long long num){\n\t\tMAX_VAL = num+1; \n\t\tfac.resize(MAX_VAL);\n\t\tmmi.resize(MAX_VAL);\n\t\t\n\t\tfactorial_mod();\n\t\tmodular_multiplicatibe_inverse();\n\t}\n\t\n\tvoid factorial_mod(){\n\t\t fac[0] = 1;\n\t\tfor(long long i = 1; i < MAX_VAL; fac[i] %= MOD, i++)\n\t\t\tfac[i] = fac[i - 1] * (i % MOD);\n\t}\n\t\n\tlong long power(long long x, long long n){\n\t\tlong long ans = 1;\n\t\tfor(;n;n >>= 1, x *= x, ans %= MOD, x %= MOD)\n\t\t\tif(n&1)ans*=x;\n\t\treturn ans % MOD;\n\t}\n\t\n\tvoid exgcd(long long a, long long b, long long &x, long long &y){\n\t\tif(b == 0){\n\t\t\tx = 1;\n\t\t\ty = 0;\n\t\t\treturn ;\n\t\t}\n\t\texgcd(b, a % b, y, x);\n\t\ty -= a / b * x;\n\t}\n\t\n\tvoid modular_multiplicatibe_inverse(){\n\t\tlong long x, y;  \n\t\texgcd(fac[MAX_VAL - 1], MOD, x, y);\n\t\tmmi[MAX_VAL-1] = (x % MOD + MOD) % MOD;\n\t\t// mmi[MAX_VAL-1] = power(fac[MAX_VAL-1], MOD-2);\n\t\tfor(long long i = MAX_VAL - 2; i >= 0; mmi[i]%=MOD, i--)\n\t\t\tmmi[i] = mmi[i + 1] * ((i + 1) % MOD);\n\t}\n\t\n\tlong long combination(long long n, long long r){\n\t\treturn n < r ? 0 :fac[n] * (mmi[r] * mmi[n-r] % MOD) % MOD;\n\t}\n};\n\n\nint main(){\n\t\n\tlong long n, k;\n\tlong long ans = 0;\n\tbinomial_coefficients bc;\n\t\n\tcin>>n>>k;\n\t\n\tbc.init(n+k);\n\t\n\t\n\tans = bc.combination(n + k - 1, n);\n\t\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = int64_t;\n\nconstexpr ll COM_MAX = (ll)1e5;\nconstexpr long long MOD = (1e9+7);\nvector<ll> fac(COM_MAX),finv(COM_MAX),inv(COM_MAX);\n// 前処理\nvoid comb_init(){\n  fac[0]=fac[1]=1;\n  finv[0]=finv[1]=1;\n  inv[1]=1;\n  for(int i=2;i<COM_MAX;++i){\n    fac[i]=fac[i-1]*i%MOD;\n    inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n    finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n}\n// 二項係数計算\nll comb(ll n,ll k){\n  if(n<k)return 0;\n  if(n<0||k<0)return 0;\n  return fac[n]*(finv[k]*finv[n-k]%MOD)%MOD;\n}\n// 重複組み合わせ\nll nHk(ll n,ll k){\n  return comb(n+k-1,n-1);\n}\n\ntemplate<ll MOD=ll(1e9+7)>\nll mod_pow(ll n,ll p){\n  ll ans=1LL;\n  while(p){\n    if(p&1)ans*=n;\n    n*=n;\n    p>>=1;\n    ans%=MOD;\n    n%=MOD;\n  }\n  return ans;\n}\n\nsigned main(){\n\n  comb_init();\n  ll n,k;\n  cin>>n>>k;\n  cout<<comb(n+k-1,n)<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing Graph = vector<vector<ll>>;\n#define rep(i, n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i, m, n) for(ll i=m;i<(ll)(n);i++)\n#define rrep(i, n, m) for(ll i=n;i>=(ll)(m);i--)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000000L;\n#ifdef __DEBUG\n\n/**\n * For DEBUG\n * https://github.com/ta7uw/cpp-pyprint\n */\n#include \"cpp-pyprint/pyprint.h\"\n\n#endif\n\nclass mint {\npublic:\n    long long x;\n\n    mint(long long x = 0) : x((x % MOD + MOD) % MOD) {}\n\n    mint operator-() const {\n        return mint(-x);\n    }\n\n    mint &operator+=(const mint &rhs) {\n        if ((x += rhs.x) >= MOD) x -= MOD;\n        return *this;\n    }\n\n    mint &operator-=(const mint &rhs) {\n        if ((x += MOD - rhs.x) >= MOD) x -= MOD;\n        return *this;\n    }\n\n    mint &operator*=(const mint &rhs) {\n        (x *= rhs.x) %= MOD;\n        return *this;\n    }\n\n    mint operator+(const mint &rhs) const {\n        mint res(*this);\n        return res += rhs;\n    }\n\n    mint operator-(const mint &rhs) const {\n        mint res(*this);\n        return res -= rhs;\n    }\n\n    mint operator*(const mint &rhs) const {\n        mint res(*this);\n        return res *= rhs;\n    }\n\n    mint pow(long long t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    mint inv() const {\n        return pow(MOD - 2);\n    }\n\n    mint &operator/=(mint rhs) {\n        return *this *= rhs.inv();\n    }\n\n    mint operator/(const mint rhs) const {\n        return mint(*this) /= rhs;\n    }\n\n    bool operator==(const mint &rhs) const noexcept {\n        return this->x == rhs.x;\n    }\n\n    bool operator!=(const mint &rhs) const noexcept {\n        return this->x != rhs.x;\n    }\n\n    bool operator<(const mint &rhs) const noexcept {\n        return this->x < rhs.x;\n    }\n\n    bool operator>(const mint &rhs) const noexcept {\n        return this->x > rhs.x;\n    }\n\n    bool operator<=(const mint &rhs) const noexcept {\n        return this->x <= rhs.x;\n    }\n\n    bool operator>=(const mint &rhs) const noexcept {\n        return this->x >= rhs.x;\n    }\n\n    friend istream &operator>>(istream &is, mint &a) {\n        long long t;\n        is >> t;\n        a = mint(t);\n        return is;\n    }\n\n    friend ostream &operator<<(ostream &os, const mint &a) {\n        return os << a.x;\n    }\n};\n\nconst int MAX = 510000;\nlong long fac[MAX], finv[MAX], inv[MAX];\nbool initialized = false;\n\n/**\n * @fn\n * This function must be called at first.\n */\nvoid combination_init() {\n    initialized = true;\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n/**\n * @fn\n * Calculates the combination  ( nCK % p: N choose K mod p).\n *\n * @brief constraint: 1 ≤ k ≤ n ≤ 10^7\n * @return nCK % MOD\n */\nlong long combination(int n, int k) {\n    assert(initialized);\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n/**\n * @fn\n * Calculates the factorial of the number.\n *\n * @return N! % MOD\n */\nlong long factorial(int n) {\n    assert(initialized);\n    if (n < 0) return 0;\n    return fac[n] % MOD;\n}\n\n/**\n * @fn\n * Calculates the combination ( nCK % p: N choose K mod p).\n *\n * @brief constraint: 1 ≤ k ≤ 10^7 and 1 ≤ n ≤ 10^9\n * @return nCK % MOD\n */\nlong long combination2(int n, int k) {\n    assert(initialized);\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    ll res = 1;\n    k = min(k, n - k);\n    for (long long x = 1; x <= k; x++) {\n        res *= (n - x + 1);\n        res %= MOD;\n        res *= inv[x];\n        res %= MOD;\n    }\n    return res;\n}\n\n\nvoid solve() {\n    ll N, K;\n    cin >> N >> K;\n    combination_init();\n    mint ans = combination(N + K - 1, N);\n    cout << ans << '\\n';\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <complex>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <bitset>\n#include <cstdint>\n#include <cassert>\n#include <random>\n#include <iterator>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\n\nconst i64 mod = 1e9 + 7;\ni64 ipow(i64 a, i64 b) {\n    i64 x = a, y = 1;\n    for (; b > 0; b >>= 1) {\n        if (b & 1) (y *= x) %= mod;\n        (x *= x) %= mod;\n    }\n    return y;\n}\ni64 inv(i64 x) {\n    return ipow(x, mod - 2);\n}\ni64 fact(i64 x) {\n    static vector<i64> f;\n    i64 i = f.size();\n    if (x >= i) {\n        f.resize(x + 1);\n        for (; i <= x; ++i) {\n            f[i] = i == 0 ? 1 : i * f[i - 1] % mod;\n        }\n    }\n    return f[x];\n}\ni64 perm(i64 n, i64 k) {\n    return k <= n ? fact(n) * inv(fact(n - k)) % mod : 0;\n}\ni64 comb(i64 n, i64 k) {\n    return k <= n ? fact(n) * inv(fact(k) * fact(n - k) % mod) % mod : 0;\n}\nint main() {\n    i64 n, k;\n    cin >> n >> k;\n    cout << comb(n + k - 1, n) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\nconstexpr i64 MOD = 1e9 + 7;\n\ni64 modpow(i64 a, i64 n, i64 mod) {\n    if (n == 0) return 1;\n    if (n % 2 == 0) {\n        i64 t = modpow(a, n / 2, mod);\n        return t * t % mod;\n    }\n    return a * modpow(a, n - 1, mod) % mod;\n}\n\ni64 modinv(i64 a, i64 mod) {\n    // mod is prime\n    return modpow(a, mod - 2, mod);\n}\n\nstruct Combination {\n    const int MAX_N = 1 << 21;\n    vi fact = vi(MAX_N);\n    vi factinv = vi(MAX_N);\n\n    Combination() {\n        fact[0] = 1;\n        for (int i = 1; i < MAX_N; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n        factinv[MAX_N - 1] = modinv(fact[MAX_N - 1], MOD);\n        for (int i = MAX_N - 2; i >= 0; i--) {\n            factinv[i] = factinv[i + 1] * (i + 1) % MOD;\n        }\n    }\n\n    i64 ncr(i64 n, i64 r) {\n        if (r < 0 || r > n) return 0;\n        return fact[n] * factinv[r] % MOD * factinv[n - r] % MOD;\n    }\n\n    i64 npr(i64 n, i64 r) {\n        if (r < 0 || r > n) return 0;\n        return fact[n] * factinv[n - r] % MOD;\n    }\n\n    i64 nhr(i64 n, i64 r) {\n        if (n == 0 && r == 0) return 1;\n        return ncr(n + r - 1, r);\n    }\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    Combination comb;\n    cout << comb.nhr(k, n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntemplate <typename NumType, int LIMIT = 2000010>\nstruct Combination {\n    vector<NumType> fact_, finv_;\n\n    Combination() : fact_(LIMIT+1), finv_(LIMIT+1) {\n        fact_[0] = finv_[LIMIT] = NumType(1);\n        for(int i=1; i<=LIMIT; i++) {\n            fact_[i] = fact_[i-1] * NumType(i);\n        }\n        \n        finv_[LIMIT] /= fact_[LIMIT];\n        for(int i=LIMIT-1; i>=0; i--) {\n            finv_[i] = finv_[i+1] * NumType(i+1);\n        }\n    }\n\n    inline NumType fact(int k) const { return fact_[k]; }\n    inline NumType finv(int k) const { return finv_[k]; }\n    NumType P(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r];\n    }\n    NumType C(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r] * finv_[r];\n    }\n    // 重複組み合わせ\n    NumType H(int n, int r) const {\n        if(n < 0 or r < 0) return NumType(0);\n        return r == 0 ? NumType(0) : C(n + r - 1, r);\n    }\n    // ベル数 (区別できる n 個のボールを区別できない k 個以下の箱に分割)\n    // B(n, n) := n 個のボールを任意個のグループに分割する場合の数\n    NumType B(int n, int k) const {\n        if(n == 0) return NumType(1);\n        k = min(n, k);\n        NumType ret(0);\n        vector<NumType> pref(k + 1); pref[0] = NumType(1);\n        for(int i=1; i<=k; i++) {\n            if(i & 1) pref[i] = pref[i-1] - finv_[i];\n            else pref[i] = pref[i-1] + finv_[i];\n        }\n        for(int i=1; i<=k; i++) {\n            // 累乗が必要なので適宜書き換える？\n            // ModInt 使うならこれでいい\n            ret += NumType(i).pow(n) * finv_[i] * pref[k-i];\n        }\n        return ret;\n    }\n    // スターリング数 (区別できる n 個のボールを区別できない k 個の箱に分割)\n    NumType S(int n, int k) const {\n        if(n < k) return NumType(0);\n        NumType ans(0);\n        for(int i=0; i<=k; i++) {\n            NumType val = C(k, i) * NumType(i).pow(n);\n            if((k - i) % 2) ans -= val;\n            else ans += val;\n        }\n        return ans * finv_[k];\n    }\n};\n\n// P(n, k) := n の k 分割 (k 個の 0 以上の整数の和)\ntemplate <typename NumType, int LIMIT = 3010>\nstruct Partition {\n    vector< vector<NumType> > dp;\n    Partition() : dp(LIMIT, vector<NumType>(LIMIT)) {\n        for(int k=0; k<LIMIT; k++) dp[0][k] = NumType(1);\n        for(int i=1; i<LIMIT; i++) {\n            for(int j=1; j<LIMIT; j++) {\n                dp[i][j] += dp[i][j-1];\n                if(i-j >= 0) dp[i][j] += dp[i-j][j];\n            }\n        }\n    }\n    inline NumType get(int n, int k) {\n        if(n < 0 or k < 0) return NumType(0);\n        return dp[n][k];\n    }\n};\n\n// ModInt begin\n\nusing ll = long long;\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v() {\n        if(a >= mod) v = a % mod;\n        else if(a < 0) v = mod - (-a % mod);\n        else v = a;\n    }\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    operator int() const { return int(v); }\n    operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod> a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\nusing mint = ModInt<1000000007>;\n\nvoid DPL_5_A() {\n    int N, K; cin >> N >> K;\n    mint ans(K);\n    cout << ans.pow(N) << endl;\n}\n\nvoid DPL_5_B() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.P(K, N) << endl;\n}\n\nvoid DPL_5_C() {\n    int N, K; cin >> N >> K;\n\n    Combination<mint> comb;\n    mint ans = comb.S(N, K) * comb.fact(K);\n    cout << ans << endl;\n}\n\nvoid DPL_5_D() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.H(K, N) << endl;\n}\n\nvoid DPL_5_E() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.C(K, N) << endl;\n}\n\nvoid DPL_5_F() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.C(N-1, K-1) << endl;\n}\n\nvoid DPL_5_G() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.B(N, K) << endl;\n}\n\nvoid DPL_5_I() {\n    int N, K; cin >> N >> K;\n    Combination<mint> comb;\n    cout << comb.S(N, K) << endl;\n}\n\nvoid DPL_5_J() {\n    int N, K; cin >> N >> K;\n    Partition<mint> part;\n    cout << part.get(N, K) << endl;\n}\n\nvoid DPL_5_L() {\n    int N, K; cin >> N >> K;\n    Partition<mint> part;\n    cout << part.get(N-K, K) << endl;\n}\n\nint main() {\n    // DPL_5_A();\n    // DPL_5_B();\n    // DPL_5_C();\n    DPL_5_D();\n    // DPL_5_E();\n    // DPL_5_F();\n    // DPL_5_G();\n    // DPL_5_I();\n    // DPL_5_J();\n    // DPL_5_L();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// a quote from http://www.igaris.com/math/c.pdf\n\n#define MOD (1000000000+7)\n\nlong long C[1001*2][1001*2];\n\nint main()\n{\n\tint n, k;\n\tcin >> n >> k;\n\n\t// Pascal's triangle for combination\n\tC[0][0] = 1;\n\tfor( int i = 1; i < 1001*2; i++ ) {\n\t\tfor( int j = 0; j <= i; j++ ) {\n\t\t\tif( j == 0 || j == i ) {\n\t\t\t\tC[i][j] = C[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tC[i][j] = ( C[i - 1][j - 1] + C[i - 1][j] ) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = C[n + k - 1][n];\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_D\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long MOD = 1e9 + 7;\n\nlong long powMod(long long x, long long k, long long m) {\n    if (k == 0) return 1;\n    if (k % 2 == 0) return (powMod((x * x + m) % m, k / 2, m) + m) % m;\n    else return (x * powMod(x, k - 1, m) + m) % m;\n}\n\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n    long long g = a;\n    x = 1;\n    y = 0;\n    if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n    return g;\n}\n\nlong long invMod(long long a, long long m) {\n    long long x, y;\n    if (extgcd(a, m, x, y) == 1) return (x + m) % m;\n    else return 0;\n}\n\nlong long factorial(long long n, long long m) {\n    if (n == 0) {\n        return 1;\n    } else {\n        return (n * factorial(n - 1, m) + m) % m;\n    }\n}\n\nlong long binomial(long long n, long long k, long long m) {\n    long long tmp = (factorial(n, m) * invMod(factorial(k, m), m) + m) % m;\n    return (tmp * invMod(factorial(n - k, m), m) + m) % m;\n}\n\nint main() {\n    long long n;//ボール\n    long long k;//箱\n    cin >> n >> k;\n\n    cout << binomial(n + k - 1, k - 1, MOD) << endl;\n    return 0;\n}\n\n/*\n * ボールは区別しないので，各箱に入るボールの個数のみ考える。\n * a1+a2+...+ak=n\n * をみたす非負整数の組の個数が答え。\n * 空箱があってもいいので，\n * 「ボール（n個）と仕切り（k-1個）を並べる」で処理できる。\n * B(n+k-1,k-1)\n *\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define rrep(i, n) for (int i = (int)n-1; i >= 0; --i)\nusing namespace std;\nusing ll = long long;\ntemplate<typename T>\ninline bool chmax(T& a, const T& b) {\n    if (a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T>\ninline bool chmin(T& a, const T& b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T> auto make_vec(const size_t n, const T &value) {\n    return std::vector<T>(n, value);\n}\ntemplate<typename... Args> auto make_vec(const size_t n, Args... args) {\n    return std::vector<decltype(make_vec(args...))>(n, make_vec(args...));\n}\n\ntemplate<uint_fast64_t Modulus>\nstruct modint {\n    using u64 = uint_fast64_t;\n    u64 a;\n    constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n    constexpr u64& value() noexcept { return a; }\n    constexpr const u64& value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) a -= Modulus;\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) a += Modulus;\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) noexcept {\n        return *this *= rhs.inv();\n    }\n    constexpr modint& operator++() noexcept {\n        a++;\n        if (a = Modulus) a = 0;\n        return *this;\n    }\n    constexpr modint operator++(int) noexcept {\n        modint tmp(*this);\n        operator++();\n        return tmp;\n    }\n    constexpr modint& operator--() noexcept {\n        if (a == 0) a = Modulus;\n        a--;\n        return *this;\n    }\n    constexpr modint operator--(int) noexcept {\n        modint tmp(*this);\n        operator--();\n        return tmp;\n    }\n    constexpr modint pow(u64 exp) const noexcept {\n        modint res(1), mul(*this);\n        for (; exp; mul *= mul, exp >>= 1) if (exp & 1) res *= mul;\n        return res;\n    }\n    constexpr modint inv() const noexcept {\n        return modint(*this).pow(Modulus - 2);\n    }\n};\n\nusing mint = modint<1000000007>;\n\nostream& operator<<(ostream&os, const mint& obj) { return os << obj.a; }\nbool operator==(const mint& lhs, const mint& rhs) { return lhs.a == rhs.a; }\nbool operator!=(const mint& lhs, const mint& rhs) { return !(lhs == rhs); }\n\nvector<mint> fact, ifact;\nvoid init(int n) {\n    fact.resize(n+1);\n    ifact.resize(n+1);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1] * i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i] * i;\n}\nmint comb(int n, int k) { return fact[n] * ifact[k] * ifact[n-k]; }\nmint perm(int n, int k) { return fact[n] * ifact[n-k]; }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, k;\n    cin >> n >> k;\n    init(n+k-1);\n    cout << comb(n+k-1, n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nclass Mint{\n    public:\n    int v;\n    const long long MOD = 1000000007;\n    Mint():v(0){}\n    Mint(signed v):v(v){}\n    Mint(long long t){v=t%MOD; if(v<0)v+=MOD;}\n\n    Mint pow(long long k){\n        Mint res(1), tmp(v);\n        while(k){\n            if(k&1)res*=tmp;\n            tmp*=tmp;\n            k>>=1;\n        }\n        return res;\n    }\n    Mint inv(){return pow(MOD-2);}\n\n    Mint& operator+=(Mint a){v+=a.v; if(v>=MOD)v-=MOD; return *this;}\n    Mint& operator-=(Mint a){v+=MOD-a.v; if(v>=MOD)v-=MOD; return *this;}\n    Mint& operator*=(Mint a){v=1LL*v*a.v%MOD; return *this;}\n    Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n    Mint operator+(Mint a) const{return Mint(v)+=a;};\n    Mint operator-(Mint a) const{return Mint(v)-=a;};\n    Mint operator*(Mint a) const{return Mint(v)*=a;};\n    Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n    Mint operator-(){return v ? MOD-v : v;}\n    bool operator==(Mint a)const{return v==a.v;}\n    bool operator!=(Mint a)const{return v!=a.v;}\n\n    Mint operator=(Mint a) {v=a.v;return a;}\n\n    friend ostream& operator<<(ostream& os, const Mint& mint){\n        os << mint.v;\n        return os;\n    }\n};\n\nclass cmbs{\n    public:\n    vector<Mint> fact, finv, inv;\n    cmbs(){\n        fact.clear(); finv.clear(); inv.clear();\n    }\n    void init(int n){\n        if(n+1 <= (signed)fact.size())return;\n        fact.assign(n+1,1);\n        finv.assign(n+1,1);\n        inv.assign(n+1,1);\n\n        for(int i=1; i<=n; i++) fact[i] = fact[i-1]*Mint(i);\n        finv[n] = Mint(1)/fact[n];\n        for(int i=n; i>=1;i--) finv[i-1] = finv[i]*Mint(i);\n        for(int i=1; i<=n; i++) inv[i] = finv[i]*fact[i-1];\n    }\n    Mint comb(long long n, int k){\n        if(n<k||k<0)return Mint(0);\n        Mint res(1);\n        for(int i=0; i<k; i++){\n            res *= Mint(n-i);\n            res /= Mint(i+1);\n        }\n        return res;\n    }\n    Mint C(int n,int k){\n        if(n<k||k<0)return Mint(0);\n        init(n);\n        return fact[n]*finv[n-k]*finv[k];\n    }\n    Mint P(int n, int k){\n        if(n<k || k<0)return Mint(0);\n        init(n);\n        return fact[n]*finv[n-k];\n    }\n    Mint H(int n, int k){\n        if(n<0||k<0)return Mint(0);\n        if(!n&&!k)return Mint(1);\n        init(n+k-1);\n        return C(n+k-1,k);\n    }\n};\n\nint main(){\n    ll n,k;\n    cin>>n>>k;\n    cmbs cmb;\n    cout<<cmb.H(k,n)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ボール: 区別なし, 箱：区別あり, 入れ方: 制限なし\n#include <iostream>\nusing namespace std;\nconst int MOD = 1000000007;\nconst long long MAXN = 1001024;\nlong long fac[MAXN], finv[MAXN], inv[MAXN];\n\n// 前処理 O(n)\nvoid comb_init(){\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for(long long i = 2; i < MAXN; i++){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算 O(1)\nlong long COM(long long n, long long k){\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n\n\nint main() {\n  \n  int n, k; cin >> n >> k;\n  comb_init();\n  cout << COM(n + k - 1, k - 1) << endl; \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \nll m=1e9+7;\n\nll dp[2002][1002];\n\n\nll dfs(ll a,ll b){\n  if(dp[a][b])return dp[a][b];\n  ll res=0;\n  if(a)res+=dp[a-1][b];\n  if(a&&b)res+=dp[a-1][b-1];\n  res%=m;\n  return dp[a][b]=res;\n}\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  dp[0][0]=1;\n  cout<<dfs(n+k-1,k-1)<<endl;\n  return 0;\n}\n\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \nll m=1e9+7;\n\nll dp[2002][1002];\n\n\nll dfs(ll a,ll b){\n  if(dp[a][b])return dp[a][b];\n  ll res=0;\n  if(a)res+=dp[a-1][b];\n  if(a&&b)res+=dp[a-1][b-1];\n  return dp[a][b]=res;\n}\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  dp[0][0]=1;\n  cout<<dfs(n+k-1,k-1)<<endl;\n  return 0;\n}\n\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconst int MOD = (int)1e9 + 7;\n\n\n//---------------------------------------------------------------\ntemplate<int MOD> struct ModInt { int x;\n    explicit operator bool() const { return !!x; }\n    ModInt(int v = 0) : x(v % MOD) { if (x < 0) x += MOD; }\n    ModInt(long long v) : x(v % MOD) { if (x < 0) x += MOD; }\n    ModInt &operator+=(const ModInt &r) { if ((x += r.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt &r) { if ((x += MOD - r.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator*=(const ModInt &r) { x = 1LL * x * r.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt &r) { return *this *= r.inv(); }\n    ModInt operator-() const { return x ? ModInt(MOD - x) : ModInt(x); }\n    ModInt operator+(const ModInt &r) const { return ModInt(*this) += r; }\n    ModInt operator-(const ModInt &r) const { return ModInt(*this) -= r; }\n    ModInt operator*(const ModInt &r) const { return ModInt(*this) *= r; }\n    ModInt operator/(const ModInt &r) const { return ModInt(*this) /= r; }\n    ModInt inv() const { long long a = x, b = MOD, u = 1, v = 0;\n        while (b) { long long t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n        return ModInt(u); } // x.pow(MOD-2)\n    ModInt pow(long long k) const { ModInt r(1), a(x);\n        while (k) { if (k & 1) r *= a; a *= a; k >>= 1; } return r; }\n    bool operator==(const ModInt r) const { return x == r.x; }\n    bool operator!=(const ModInt r) const { return x != r.x; }\n    bool operator< (const ModInt r) const { return x <  r.x; }\n    friend ostream& operator<<(ostream &os, const ModInt<MOD>& a) { return os << a.x; }\n    friend istream& operator>>(istream &is, ModInt<MOD>& a) { return is >> a.x; }\n};\ntemplate<typename T, int SZ> struct Comb { vector<T> _fac, _ifac, _inv;\n    Comb() : _fac(SZ + 1), _ifac(SZ + 1), _inv(SZ + 1) {\n        _fac[0] = _ifac[SZ] = _inv[0] = 1;\n        for (int i = 1; i <= SZ; i++) _fac[i] = _fac[i - 1] * i;\n        _ifac[SZ] /= _fac[SZ];\n        for (int i = SZ - 1; i >= 0; i--) _ifac[i] = _ifac[i + 1] * (i + 1);\n        for (int i = 1; i <= SZ; i++) _inv[i] = _ifac[i] * _fac[i - 1]; }\n    T inv(int n) { return n < 0 ? T(0) : _inv[n]; }\n    T fac(int n) { return n < 0 ? T(0) : _fac[n]; }\n    T ifac(int n) { return n < 0 ? T(0) : _ifac[n]; }\n    T P(int a, int b) { return (b < 0 || a < b) ? T(0) : _fac[a] * _ifac[a - b]; }\n    T C(int a, int b) { return b < 0 ? T(0) : P(a, b) * _ifac[b]; }\n    T H(int n, int k) { if (n < 0 || k < 0) return T(0);\n        return k == 0 ? T(0) : C(n + k - 1, k); }\n};\ntypedef ModInt<MOD> mint;\n//---------------------------------------------------------------\n\n\nint main() {\n    Comb<mint, 250000> com;\n    int n, k; cin >> n >> k;\n    cout << com.H(k, n) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n\nconstexpr intmax_t mod = 1e9+7;\n\ntemplate <typename Tp>\nTp gcd(Tp a, Tp b, Tp& x, Tp& y) {\n  x = Tp(0);\n  y = Tp(1);\n  for (Tp u = y, v = x; a;) {\n    Tp q = b/a;\n    std::swap(x -= q*u, u);\n    std::swap(y -= q*v, v);\n    std::swap(b -= q*a, a);\n  }\n  return b;\n}\n\ntemplate <typename Tp>\nTp modinv(Tp a, Tp mod) {\n  Tp x, y;\n  gcd(a, mod, x, y);\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\ntemplate <typename Tp>\nTp modadd(Tp a, Tp b, Tp mod) {\n  a += b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modadd(std::initializer_list<Tp> const& adds, Tp mod) {\n  Tp res = 0;\n  for (auto const& add: adds) {\n    res += add % mod;\n    if (res < 0) res += mod;\n    if (res >= mod) res -= mod;\n  }\n  return res;\n}\n\ntemplate <typename Tp>\nTp modsub(Tp a, Tp b, Tp mod) {\n  a -= b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <typename Tp>\nTp modmul(std::initializer_list<Tp> const& muls, Tp mod) {\n  Tp res = 1;\n  for (auto const& mul: muls) (res *= mul) %= mod;\n  return res;\n}\n\ntemplate <typename Tp>\nTp modpow(Tp base, intmax_t iexp, Tp mod) {\n  Tp res = 1;\n  for (Tp dbl = base; iexp; iexp >>= 1) {\n    if (iexp & 1) res = res * dbl % mod;\n    dbl = dbl * dbl % mod;\n  }\n  return res;\n}\n\nclass modchoose {\n  std::vector<intmax_t> fact, fact_inv;\n  const intmax_t mod;\n\npublic:\n  modchoose(intmax_t N, intmax_t mod): mod(mod) {\n    fact.resize(N+1);\n    fact_inv.resize(N+1);\n    fact[0] = 1;\n    for (intmax_t i = 1; i <= N; ++i)\n      fact[i] = fact[i-1] * i % mod;\n\n    fact_inv[N] = modinv(fact[N], mod);\n    for (intmax_t i = N; i--;)\n      fact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n  }\n\n  intmax_t operator ()(intmax_t n, intmax_t r) const {\n    if (!(0 <= r && r <= n)) return 0;\n    intmax_t res = fact[n] * fact_inv[r] % mod;\n    (res *= fact_inv[n-r]) %= mod;\n    return res;\n  }\n};\n\nint main() {\n  intmax_t n, k;\n  scanf(\"%jd %jd\", &n, &k);\n\n  modchoose mc(n+k, mod);\n  intmax_t res = mc(n+k-1, k-1);\n  printf(\"%jd\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include    <bits/stdc++.h>\nusing   namespace   std;\ntypedef long long ll;\n\nconst int MAX = 2001;\nconst int MOD = 1000000007;\n\nvoid    ComInit(vector<long> &fac, vector<long> &finv, vector<long> &inv) {\n    fac.at(0) = 1;\n    fac.at(1) = 1;\n    finv.at(0) = 1;\n    finv.at(1) = 1;\n    inv.at(1) = 1;\n    for (int i=2; i<MAX; i++) {\n        fac.at(i) = (fac.at(i-1)*i) %MOD;\n        inv.at(i) = MOD - (inv.at(MOD%i)*(MOD/i)) %MOD;\n        finv.at(i) = (finv.at(i-1)*inv.at(i)) %MOD;\n    }\n}\n\nlong    COM(int N, int K, vector<long> &fac, vector<long> &finv) {\n    if (N<K)\n        return 0;\n    if ((N<0)||(K<0))\n        return 0;\n    return (fac.at(N) * ((finv.at(K)*finv.at(N-K)) %MOD)) %MOD;\n}\n\nint main() {\n    // Array\n    vector<long> fac(MAX);\n    vector<long> finv(MAX);\n    vector<long> inv(MAX);\n    // Initialize\n    ComInit(fac, finv, inv);\n    int n, k;\n    cin >>n >>k;\n    cout <<COM(n+k-1, k-1, fac, finv) <<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <fstream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\n// #define DEBUG\n\nconst ll mod = 1e9 + 7;\nll mypow(ll x, ll y, ll m = mod)\n{\n    ll ans = 1;\n    ll q = x;\n    while (y > 0)\n    {\n        if (y % 2 == 1)\n        {\n            ans *= q;\n            ans %= m;\n        }\n        q = q * q;\n        q %= m;\n        y = y / 2;\n    }\n    return ans % m;\n}\n\nll permulation(ll x, ll y, ll m = mod)\n{\n    ll ans = 0;\n    if (x >= y)\n    {\n\n        ans = 1;\n        for (ll i = x - y + 1; i <= x; i++)\n        {\n            ans = (ans * i) % m;\n        }\n    }\n    return ans;\n}\n\nll combination(ll x, ll y, ll m = mod)\n{\n    ll ans = 0;\n    if (y == 0 || y == x)\n        ans = 1;\n    else\n    {\n        ans = 1;\n        for (ll i = x - y + 1; i <= x; i++)\n        {\n            ans = (ans * i) % m;\n        }\n        for (ll i = 1; i <= y; i++)\n        {\n            ans = (ans * mypow(i, m - 2, m)) % m;\n        }\n    }\n    return ans;\n}\n\nll fractual(ll x, ll m = mod)\n{\n    if (x == 0)\n        return 0;\n    else\n        return permulation(x, x, m);\n}\n\nll multi_choose(ll x, ll y, ll m = mod)\n{\n    return combination(x + y - 1, y - 1, m);\n}\n\nint main()\n{\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    ll n, k;\n    cin >> n >> k;\n    cout << multi_choose(n, k) << endl;\n    return 0;\n}\n\n// getline(cin,s);\n// a = strtok(s, \",\");  \",\"で分解\n// for (int i = 0; i < n; i++)\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \nll m=1e9+7;\nll dp[2002][1002];\n\n\nll dfs(ll a,ll b){\n  if(a==b)return 1;\n  if(dp[a][b])return dp[a][b];\n  ll res=0;\n  if(a)res+=dfs(a-1,b);\n  if(a&&b)res+=dfs(a-1,b-1);\n  res%=m;\n  return dp[a][b]=res;\n}\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  dp[0][0]=1;\n  cout<<dfs(n+k-1,k-1)<<endl;\n  return 0;\n}\n\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\nll modpow(ll a, ll n, ll mod_) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod_;\n        a = a * a % mod_;\n        n >>= 1;\n    }\n    return res;\n}\n\nconst ll MAX_SIZE = 200005;\narray<ll, MAX_SIZE> fac, inv, finv;\nvoid finit() {\n    // combination init\n    fac[0] = 1;\n    for (ll i = 1; i < MAX_SIZE; i++) fac[i] = fac[i - 1] * i % MOD;\n    finv[MAX_SIZE - 1] = modpow(fac[MAX_SIZE - 1], MOD - 2, MOD);\n    for(ll i = MAX_SIZE - 1; i > 0; i--) finv[i - 1] = finv[i] * i % MOD;\n    \n    //inv init\n    repe(i, 1, MAX_SIZE) inv[i] = modpow(i, MOD - 2, MOD);\n}\n\nll perm(ll a, ll b) { return fac[a] * finv[a - b] % MOD; }\n\nll comb(ll a, ll b) { return fac[a] * finv[b] % MOD * finv[a - b] % MOD; }\n\nint main() {\n    init();\n    finit();\n    ll N, K;\n    cin >> N >> K;\n\n    cout << comb(N + K - 1, N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i = (int)j;i <= (int)k;i ++)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\nconst int maxn=(int)1e6+5;\ntypedef long long ll;\nll MOD=(ll)1e9+7;\nll qpow(ll a,ll b){return b?((b&1)?a*qpow(a*a%MOD,b>>1)%MOD:qpow(a*a%MOD,b>>1))%MOD:1;}\nll c(ll n,ll m){\n    ll ret=1;\n    if(n<m)return 0;\n    rep(i,1,m){\n        ret*=qpow(i,MOD-2);\n        ret%=MOD;\n        ret*=n-i+1;\n        ret%=MOD;\n    }\n    return ret;\n}\nll p(ll n,ll m){\n    ll ret=1;\n    if(n<m)return 0;\n    rep(i,1,m){\n        /* ret*=qpow(i,MOD-2);\n        ret%=MOD; */\n        ret*=n-i+1;\n        ret%=MOD;\n    }\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n,k;\n    cin>>n>>k;\n    cout<<c(n+k-1,k-1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nusing ll =  long long;\n\nconstexpr int N_MAX = 1000;\nconstexpr int K_MAX = 1000;\nconstexpr ll MOD = 1000000007;\n\nll fact[N_MAX+K_MAX+1], rfact[N_MAX+K_MAX+1];\n\nll perm(ll n, ll k) {\n    if(n-k < 0LL) return 0LL;\n    return (fact[n] * rfact[n-k]) % MOD;\n}\n\nll comb(ll n, ll k) {\n    if(n-k < 0LL) return 0LL;\n    return (perm(n, k) * rfact[k]) % MOD;\n}\n\nll modpow(ll a, ll p) {\n    ll ret = 1LL;\n    while(p) {\n        if(p & 1) {\n            ret = (ret * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        p >>= 1;\n    }\n    return ret;\n}\n\nvoid init_fact(ll n) {\n    fact[0] = fact[1] = 1;\n    rfact[0] = rfact[1] = 1;\n    for(ll i=2;i<=n;++i) {\n        fact[i] = (fact[i-1] * i) % MOD;\n        rfact[i] = modpow(fact[i], MOD-2);\n    }\n}\n\nint main() {\n    ll n, k;\n    cin >> n >> k;\n    init_fact(N_MAX+K_MAX);\n    cout << comb(n+k-1, n) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, k, ans=1;\n\nint main() {\n    cin >> n >> k;\n    for (int i=k; i<n+k; i++) {\n        ans = (ans * i) % 1000000007;\n    }\n    for (int i=2; i<n+1; i++) {\n        int u = 1000000005;\n        long long f[31];\n        f[0] = i;\n        for (int j=0; u>0; j++){\n            if (u%2 == 1) ans = (ans * f[j])%1000000007;\n            u/=2;\n            f[j+1] = (f[j]*f[j])%1000000007;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<climits>\n#include<bitset>\n#include<stack>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef tuple<ll, ll, ll> lltpl;\n\nint dy8[8] = { 2,2,-2,-2,1,1,-1,-1 };\nint dx8[8] = { 1,-1,1,-1,2,-2,2,-2 };\nint dx4[4] = { 1,0,0,-1 };\nint dy4[4] = { 0,1,-1,0 };\n\n\n/******************************************************************************************/\n\n\nconst int IINF = 1e9 + 7;\nconst ll LINF = LLONG_MAX;\nconstexpr ll MOD = 1e9 + 7;\n\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n\treturn vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type\nfill_v(T& t, const V& v) { t = v; }\ntemplate<typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type\nfill_v(T& t, const V& v) {\n\tfor (auto& e : t) fill_v(e, v);\n}\n\n// vector\ntemplate <typename T>\nistream& operator>>(istream & is, vector<T> & vec) { for (T& x : vec) is >> x; return is; }\n// pair\ntemplate <typename T, typename U>ostream& operator<<(ostream & os, pair<T, U> & pair_var) { os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\"; return os; }\n// vector\ntemplate <typename T>ostream& operator<<(ostream & os, const vector<T> & vec) { os << \"{\";\tfor (int i = 0; i < vec.size(); i++) { os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \"); }os << \"}\"; return os; }\n// map\ntemplate <typename T, typename U>ostream& operator<<(ostream & os, map<T, U> & map_var) { os << \"{\";\trepi(itr, map_var) { os << *itr; itr++; if (itr != map_var.end()) os << \", \"; itr--; }os << \"}\"; return os; }\n// set\ntemplate <typename T>ostream& operator<<(ostream & os, set<T> & set_var) { os << \"{\"; repi(itr, set_var) { os << *itr; itr++; if (itr != set_var.end()) os << \", \"; itr--; }os << \"}\"; return os; }\n\n\nstruct Combination {\n\n\tvector<ll> fact, rfact;\n\n\tCombination(ll sz) : fact(sz + 1), rfact(sz + 1) {\n\n\t\tfact[0] = 1;\n\t\tfor (ll i = 1; i < fact.size(); i++) {\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t}\n\t\t//逆元\n\t\trfact[sz] = inv(fact[sz]);\n\t\tfor (ll i = sz - 1; i >= 0; i--) {\n\t\t\trfact[i] = rfact[i + 1] * (i + 1) % MOD;\n\t\t}\n\t}\n\n\tll inv(ll x) {\n\t\treturn pow(x, MOD - 2);\n\t}\n\tll pow(ll x, ll n) {\n\t\tll ret = 1;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) (ret *= x) %= MOD;\n\t\t\t(x *= x) %= MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn (ret);\n\t}\n\tll P(ll n, ll r) {\n\t\tif (r < 0 || n < r) return (0);\n\t\treturn (fact[n] * rfact[n - r] % MOD);\n\t}\n\n\tll C(ll p, ll q) {\n\t\tif (q < 0 || p < q) return (0);\n\t\treturn (fact[p] * rfact[q] % MOD * rfact[p - q] % MOD);\n\t}\n\n\tll H(ll n, ll r) {\n\t\tif (n < 0 || r < 0) return (0);\n\t\treturn (r == 0 ? 1 : C(n + r - 1, r));\n\t}\n};\n\n\nint main() {\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, k;\n\tcin >> n >> k;\n\tCombination hoge(n + k + 10);\n\n\tcout << hoge.C(n+k-1,k-1) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nclass ModInt {\n    using ll = long long;\n\npublic:\n    int value;\n    static int MOD;\n\n    ModInt(ll value = 0) {\n        this->value = (-MOD < value && value < MOD ? value : value % MOD);\n        if (this->value < 0) this->value += MOD;\n    }\n\n    operator int() const noexcept { return this->value; }\n    operator ll() const noexcept { return this->value; }\n\n    ModInt& operator=(const ModInt& x) {\n        if (this != &x) { this->value = x.value; }\n        return *this;\n    }\n\n    bool operator==(const ModInt& x) const { return this->value == x.value; }\n    bool operator!=(const ModInt& x) const { return !(*this == x); }\n\n    ModInt operator+() const { return value; }\n    ModInt operator-() const { return MOD - value; }\n    ModInt operator~() const { return (*this) ^ ModInt(MOD - 2); }\n\n    ModInt operator++() { return *this += 1; }\n    ModInt operator--() { return *this -= 1; }\n\n    ModInt operator++(int) {\n        ModInt before = *this;\n        ++(*this);\n        return before;\n    }\n    ModInt operator--(int) {\n        ModInt before = *this;\n        --(*this);\n        return before;\n    }\n\n    ModInt& operator+=(const ModInt& x) {\n        int sum = this->value + x.value;\n        return *this = (sum < MOD ? sum : sum - MOD);\n    }\n    ModInt& operator-=(const ModInt& x) {\n        int diff = this->value - x.value;\n        return *this = (diff >= 0 ? diff : diff + MOD);\n    }\n    ModInt& operator+=(int x) { return *this += ModInt(x); }\n    ModInt& operator-=(int x) { return *this -= ModInt(x); }\n\n    template <class T>\n    ModInt& operator*=(const T& x) { return *this = ll(this->value) * ll(x) % MOD; }\n    template <class T>\n    ModInt& operator/=(const T& x) { return *this = (this->value % int(x) == 0 ? ModInt(this->value / int(x)) : *this * ~ModInt(x)); }\n    template <class T>\n    ModInt& operator^=(const T& x) {\n        int n = int(x);\n        ModInt b = *this;\n        *this = 1;\n        while (n > 0) {\n            if (n & 1) *this *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    template <class T>\n    ModInt operator+(const T& b) const { return ModInt(*this) += b; }\n    template <class T>\n    ModInt operator-(const T& b) const { return ModInt(*this) -= b; }\n    template <class T>\n    ModInt operator*(const T& b) const { return ModInt(*this) *= b; }\n    template <class T>\n    ModInt operator/(const T& b) const { return ModInt(*this) /= b; }\n    template <class T>\n    ModInt operator^(const T& b) const { return ModInt(*this) ^= b; }\n};\n\nstd::ostream& operator<<(std::ostream& os, const ModInt& x) { return os << x.value; }\nstd::istream& operator>>(std::istream& is, ModInt& x) { return is >> x.value; }\n\nint ModInt::MOD = 1000000007;\n\nclass Combination {\npublic:\n    int MAX_V;\n    std::vector<ModInt> fact, invfact;\n\n    explicit Combination(int N)\n        : MAX_V(N), fact(MAX_V + 1), invfact(MAX_V + 1) {\n        fact[0] = 1;\n        for (int i = 1; i <= MAX_V; ++i) {\n            fact[i] = fact[i - 1] * i;\n        }\n\n        invfact[MAX_V] = ~fact[MAX_V];\n        for (int i = MAX_V - 1; i >= 0; --i) {\n            invfact[i] = invfact[i + 1] * (i + 1);\n        }\n    }\n\n    ModInt comb(int a, int b) const {\n        if (a < b) return 0;\n        if (a == 0) return 1;  // a = b = 0\n        return fact[a] * invfact[a - b] * invfact[b];\n    }\n};\n\nint main() {\n    int N, K;\n    std::cin >> N >> K;\n\n    Combination C(K + N);\n    std::cout << C.comb(N + K - 1, N) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma GCC optimize(\"Ofast\")\n\n// Begin Header {{{\nusing namespace std;\n\n#ifndef DEBUG\n#define dump(...)\n#endif\n\n#define all(x) x.begin(), x.end()\n#define rep(i, b, e) for (intmax_t i = (b), i##_limit = (e); i < i##_limit; ++i)\n#define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i)\n#define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i)\n#define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__)\n\nconstexpr size_t    operator\"\"_zu(unsigned long long value) { return value; };\nconstexpr intmax_t  operator\"\"_jd(unsigned long long value) { return value; };\nconstexpr uintmax_t operator\"\"_ju(unsigned long long value) { return value; };\n\nconstexpr int INF = 0x3f3f3f3f;\nconstexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f_jd;\n\ntemplate <class T, class Compare = less<>>\nusing MaxHeap = priority_queue<T, vector<T>, Compare>;\ntemplate <class T, class Compare = greater<>>\nusing MinHeap = priority_queue<T, vector<T>, Compare>;\n\ninline void input() {}\ntemplate <class Head, class... Tail>\ninline void input(Head&& head, Tail&&... tail) {\n    cin >> head;\n    input(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline istream& operator>>(istream &is, vector<T> &vec) {\n    for (auto &e: vec) {\n        is >> e;\n    }\n    return is;\n}\n\ninline void output() { cout << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void output(Head&& head, Tail&&... tail) {\n    cout << head;\n    if (sizeof...(tail)) {\n        cout << \" \";\n    }\n    output(forward<Tail>(tail)...);\n}\n\ntemplate <class T>\ninline ostream& operator<<(ostream &os, const vector<T> &vec) {\n    static constexpr const char *delim[] = {\" \", \"\"};\n    for (const auto &e: vec) {\n        os << e << delim[&e == &vec.back()];\n    }\n    return os;\n}\n\ntemplate <class T>\ninline vector<T> makeVector(const T &initValue, size_t sz) {\n    return vector<T>(sz, initValue);\n}\n\ntemplate <class T, class... Args>\ninline auto makeVector(const T &initValue, size_t sz, Args... args) {\n    return vector<decltype(makeVector<T>(initValue, args...))>(sz, makeVector<T>(initValue, args...));\n}\n\ntemplate <class Func>\nclass FixPoint : Func {\npublic:\n    explicit constexpr FixPoint(Func&& f) noexcept : Func(forward<Func>(f)) {}\n\n    template <class... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return Func::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n\ntemplate <class Func>\nstatic inline constexpr decltype(auto) makeFixPoint(Func&& f) noexcept {\n    return FixPoint<Func>{forward<Func>(f)};\n}\n\ntemplate <class Container>\nstruct reverse_t {\n    Container &c;\n    reverse_t(Container &c) : c(c) {}\n    auto begin() { return c.rbegin(); }\n    auto end() { return c.rend(); }\n};\n\ntemplate <class Container>\nauto reversed(Container &c) {\n    return reverse_t<Container>(c);\n}\n\ntemplate <class T>\ninline bool chmax(T &a, const T &b) noexcept {\n    return b > a && (a = b, true);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, const T &b) noexcept {\n    return b < a && (a = b, true);\n}\n\ntemplate <class T>\ninline T diff(const T &a, const T &b) noexcept {\n    return a < b ? b - a : a - b;\n}\n// End Header }}}\n\nconst intmax_t MOD = intmax_t(1e9) + 7;\n// ModInt {{{\ntemplate <intmax_t MOD>\nclass ModInt {\n    intmax_t value;\n\npublic:\n    inline ModInt(const ModInt& other) :\n        value(other.value)\n    {}\n\n    inline ModInt(intmax_t value = 0) {\n        if (value >= MOD) {\n            this->value = value % MOD;\n        } else if (value < 0) {\n            this->value = (value + MOD) % MOD;\n        } else {\n            this->value = value;\n        }\n    }\n\n    template <class T>\n        explicit inline operator T() const {\n            return static_cast<T>(value);\n        }\n\n    inline ModInt inverse() const {\n        return ModInt::pow(value, MOD - 2);\n    }\n\n    inline ModInt& operator+=(const ModInt other) {\n        value = (value + other.value) % MOD;\n        return *this;\n    }\n\n    inline ModInt& operator-=(const ModInt other) {\n        value = (MOD + value - other.value) % MOD;\n        return *this;\n    }\n\n    inline ModInt& operator*=(const ModInt other) {\n        value = (value * other.value) % MOD;\n        return *this;\n    }\n\n    inline ModInt& operator/=(const ModInt other) {\n        value = (value * other.inverse().value) % MOD;\n        return *this;\n    }\n\n    inline ModInt operator+(const ModInt other) {\n        return ModInt(*this) += other;\n    }\n\n    inline ModInt operator-(const ModInt other) {\n        return ModInt(*this) -= other;\n    }\n\n    inline ModInt operator*(const ModInt other) {\n        return ModInt(*this) *= other;\n    }\n\n    inline ModInt operator/(const ModInt other) {\n        return ModInt(*this) /= other;\n    }\n\n    inline bool operator==(const ModInt other) {\n        return value == other.value;\n    }\n\n    inline bool operator!=(const ModInt other) {\n        return value != other.value;\n    }\n\n    friend ostream& operator<<(ostream &os, const ModInt other) {\n        os << other.value;\n        return os;\n    }\n\n    friend istream& operator>>(istream &is, ModInt& other) {\n        is >> other.value;\n        return is;\n    }\n\n    static constexpr inline ModInt pow(intmax_t n, intmax_t p) {\n        intmax_t ret = 1;\n        for (; p > 0; p >>= 1) {\n            if (p & 1) ret = (ret * n) % MOD;\n            n = (n * n) % MOD;\n        }\n        return ret;\n    }\n};\n\nusing Mint = ModInt<MOD>;\n// }}}\n\n// Factorial {{{\n#ifdef DEBUG\n#define constexpr\n#endif\n\ntemplate <size_t N, size_t MOD>\nstruct Factorial {\n    vector<uint_fast64_t> fact_;\n\n    constexpr inline Factorial() : fact_(N + 1) {\n        fact_[0] = 1;\n        for (intmax_t i = 1; i <= N; ++i) {\n            fact_[i] = (fact_[i - 1] * i) % MOD;\n        }\n    }\n\n    constexpr inline Mint operator[](size_t pos) const {\n        return fact_[pos];\n    }\n};\n\ntemplate <size_t N, size_t MOD>\nstruct InvFact {\n    vector<uint_fast64_t> inv_;\n    vector<uint_fast64_t> finv_;\n\n    constexpr inline InvFact() : inv_(N + 1), finv_(N + 1) {\n        inv_[1] = 1;\n        finv_[0] = finv_[1] = 1;\n        for (intmax_t i = 2; i <= N; ++i) {\n            inv_[i] = (MOD - MOD / i) * inv_[MOD % i] % MOD;\n            finv_[i] = finv_[i - 1] * inv_[i] % MOD;\n        }\n    }\n\n    constexpr inline Mint operator[](size_t pos) const {\n        return finv_[pos];\n    }\n};\n\n#ifdef constexpr\n#undef constexpr\n#endif\n\nFactorial<510000, MOD> fact;\nInvFact<510000, MOD> finv;\n\ninline Mint nCr(int n, int r) {\n    if (r < 0 || n < r) {\n        return 0;\n    }\n    return fact[n] * (finv[r] * finv[n - r]);\n}\n\ninline Mint nPr(int n, int r) {\n    if (r < 0 || n < r) {\n        return 0;\n    }\n    return fact[n] * finv[n - r];\n}\n\ninline Mint nHr(int n, int r) {\n    return nCr(n + r - 1, r);\n}\n// }}}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.setf(ios_base::fixed);\n    cout.precision(10);\n\n    var(intmax_t, n, k);\n    output(nCr(n + k - 1, k - 1));\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"DPL_5_D.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_D\"\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n#define rep(i, n) for(ll i = 0;i < n;i++)\n#define all(i) i.begin(), i.end()\ntemplate<class T, class U> bool cmax(T& a, U b) { if (a<b) {a = b; return true;} else return false; }\ntemplate<class T, class U> bool cmin(T& a, U b) { if (a>b) {a = b; return true;} else return false; }\n\n#line 1 \"../modint.cpp\"\ntemplate <ll Mod>\nstruct ModInt {\n  ll n;\n  ModInt(const ll x = 0) : n(x) { while (n < 0) n += Mod; n %= Mod; }\n  ModInt operator+(const ModInt r) const { return ModInt(*this) += r; }\n  ModInt operator-(const ModInt r) const { return ModInt(*this) -= r; }\n  ModInt operator*(const ModInt r) const { return ModInt(*this) *= r; }\n  ModInt operator/(const ModInt r) const { return ModInt(*this) /= r; }\n  ModInt &operator+=(const ModInt r) { n += r.n; if (n >= Mod) n -= Mod; return *this; }\n  ModInt &operator-=(const ModInt r) { if (n < r.n) n += Mod; n -= r.n; return *this; }\n  ModInt &operator*=(const ModInt r) { n = n * r.n % Mod; return *this; }\n  ModInt &operator/=(const ModInt r) { return *this *= r.inv(); }\n  ModInt pow(ll x) const { ModInt<Mod> ret(1), tmp(*this); while (x) { if (x&1) ret *= tmp; tmp *= tmp; x >>= 1; } return ret; }\n  ModInt inv() const { return pow(Mod-2); }\n  friend ostream& operator<<(ostream& os, const ModInt& obj) { return os << obj.n; }\n  friend istream& operator>>(istream& is, ModInt& obj) { ll t; is >> t; obj = ModInt(t); return is; }\n};\nconstexpr ll mod = 1000000007;\nusing mint = ModInt<mod>;\nmint operator\"\" _mi(unsigned long long n) { return mint(n); }\n#line 1 \"../combination.cpp\"\n// T modint\ntemplate<class T>\nstruct Combination {\n  vector<T> fact, inv_fact;\n  Combination(ll n) : fact(n+1), inv_fact(n+1) {\n    fact[0] = T(1);\n    for (ll i = 1; i <= n; i++) fact[i] = fact[i-1] * static_cast<T>(i);\n    inv_fact[n] = fact[n].inv();\n    for (ll i = n; i > 0; i--) inv_fact[i-1] = inv_fact[i] * static_cast<T>(i);\n  }\n\n  T P(ll n, ll k) const {\n    if (n < k or k < 0) return T(0);\n    return fact[n] * inv_fact[n-k];\n  }\n\n  T C(ll n, ll k) const {\n    if (n < k or k < 0) return T(0);\n    return fact[n] * inv_fact[n-k] * inv_fact[k];\n  }\n\n  T H(ll n, ll k) const {\n    if (n < 0 or k < 0) return T(0);\n    if (n == 0 and k == 0) return T(1);\n    return C(n+k-1, n-1);\n  }\n};\n#line 16 \"DPL_5_D.test.cpp\"\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n\n  ll n, k;\n  cin >> n >> k;\n  Combination<mint> c(n+k);\n  cout << c.H(k, n) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 2000\n\nll N,K;\nll nCm[NUM][NUM];\n\nint main(){\n\n\tscanf(\"%lld %lld\",&N,&K);\n\n\t//コンビネーションを求める\n\tnCm[0][0] = 1;\n\tfor(ll n = 1; n <= N+K-1; n++) {\n\t\tfor (int m = 0; m <= N; m++) {\n\t\t\tif(m > 0){\n\t\t\t\tnCm[n][m] = nCm[n-1][m]+nCm[n-1][m-1];\n\t\t\t}else{ //m == 0\n\t\t\t\tnCm[n][m] = 1;\n\t\t\t}\n\t\t\tnCm[n][m] %= MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",nCm[N+K-1][N]);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define int long long\nusing namespace std;\n\n\ntypedef long long ll;\nstruct NT{\n  ll m;  // mod\n  vector<bool>ismrime;\n  vector<ll> euler;\n  vector<ll> fact;\n\n  NT(ll MOD){\n    m=MOD;\n    fact.resize(500005);\n    fact[0]=1;\n    for(ll i=1;i<500005;i++){\n      fact[i]=(fact[i-1]*i)%MOD;\n    }\n  }\n\n  void eratos(int n){\n    ismrime.resize(n+1);\n    for(int i=0;i<=n;i++) ismrime[i]=true;\n    ismrime[0]=0;\n    ismrime[1]=0;\n    for(int i=2;i<=n;i++){\n      if(ismrime[i]){\n        for(int j=i+i;j<=n;j+=i) ismrime[j]=false;\n      }\n    }\n  }\n\n  // 因数分解 √N\n  vector<int> mrime_decommosition(ll x){\n    vector<int>res;\n    for(int i=2;i*i<=x;i++){\n      while(x%i==0){\n        x/=i;\n        res.push_back(i);\n      }\n    }\n    if(x!=1) res.push_back(x);\n    return res;\n  }\n\n  // 約数列挙 √N\n  vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  // a*b>LONG_MAX ? \n  bool overflow(ll a,ll b,ll LONGMAX){return a > LONGMAX/b;}\n\n  ll extgcd(ll a,ll b,ll& x,ll& y){\n    ll d = a ;\n    if ( b != 0 ) {\n      d = extgcd( b , a%b , y , x ) ;\n      y -= ( a / b ) * x ;\n    }else{\n      x = 1 ; y = 0 ;\n    }\n    return d;\n  }\n  ll mod_inverse(ll a){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n\n  // オイラー関数√N\n  ll euler_mhi(ll n){\n    ll res = n;\n    for(ll i=2; i*i <= n ; i++){\n      if( n%i == 0 ){\n        res = res/i*(i-1);\n        for(;n%i==0;n/=i);\n      }\n    }\n    if(n!=1)res=res/n*(n-1);\n    return res;\n  }\n\n  void make_euler_table(int n){\n    euler.resize(n+1);\n    for(int i=0;i<n;i++) euler[i]=i;\n    for(int i=2;i<n;i++){\n      if(euler[i]==i){\n        for(int j=i;j<n;j+=i){\n          euler[j]=euler[j]/i*(i-1);\n        }\n      }\n    }\n  }\n\n  // n! と nCr \n  // mはmod\n  ll mod_fact(ll n,ll& e){\n    e=0;\n    if(n==0)return 1;\n\n    int res = mod_fact(n/m,e);\n    e+=n/m;\n\n    if(n/m%2 != 0)return res*(m-fact[n%m])%m;\n    return res*fact[n%m]%m;\n  }\n\n  ll combination(ll n,ll k){\n    if(n==k||k==0)return 1;\n    if(n<0 || k<0 || n<k)return 0;\n    ll e1,e2,e3;\n    ll a1 = mod_fact(n,e1);\n    ll a2 = mod_fact(k,e2);\n    ll a3 = mod_fact(n-k,e3);\n    return a1*mod_inverse(a2*a3%m)%m;\n  }\n\n  ll stupid_combination(ll n,ll k){\n    if(n==k||k==0)return 1;\n    if(n<0 || k<0 || n<k)return 0;\n    ll res=1;\n    for(ll i=0;i<k;i++){\n      res*=(n-i);\n      res%=m;\n      res*=mod_inverse(i+1);\n      res%=m;\n    }\n    return res;\n  }\n\n  ll mod_mult(ll a, ll b,ll m) {\n    ll res = 0;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) {\n        res += exm;\n        if (res > m) res -= m;\n      }\n      exm <<= 1;\n      if (exm > m) exm -= m;\n      b >>= 1;\n    }\n    return res;\n  }\n\n  ll mod_exm(ll a, ll b,ll m) {\n    ll res = 1;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) res = mod_mult(res, exm,m);\n      exm = mod_mult(exm, exm,m);\n      b >>= 1;\n    }\n    return res;\n  }\n\n  // 確率的高速素数判定　\n  bool miller_rabin(ll n, ll times=10) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (!(n & 1)) return false;\n    ll q = n-1;\n    int k = 0;\n    while (q % 2 == 0) {\n      k++;\n      q >>= 1;\n    }\n    for (int i = 0; i < times; i++) {\n      ll a = rand() % (n-1) + 1;\n      ll x = mod_exm(a, q, n);\n      if (x == 1) continue;\n      bool found = false;\n      for (int j = 0; j < k; j++) {\n        if (x == n-1) {\n          found = true;\n          break;\n        }\n        x = mod_mult(x, x, n);\n      }\n      if (found) continue;\n      return false;\n    }\n    return true;\n  }\n\n  ll pollard_rho(ll n, int c) {\n    ll x = 2;\n    ll y = 2;\n    ll d = 1;\n    while (d == 1) {\n      x = mod_mult(x, x, n) + c;\n      y = mod_mult(y, y, n) + c;\n      y = mod_mult(y, y, n) + c;\n      d = __gcd((x-y >= 0 ? x-y : y-x), n);\n    }\n    if (d == n) return pollard_rho(n, c+1);\n    return d;\n  }\n};\n\n\nsigned main(){\n    NT N(1000000007);\n    int n,k;\n    cin>>n>>k;\n    cout<<N.combination(n+k-1,n)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll MOD = 1e9+7;\n\nconst ll N = 1e5;\nll mod_pow(ll x,ll n,ll mod){\n\n  if(n==0)return 1;\n\n  ll res=mod_pow( x*x%mod , n/2 , mod );\n\n  if( n & 1 )res = res*x%mod;\n\n  return res;\n\n}\n\n\n\nll fact[N];\n\nll infact[N];\n\n\n\nvoid make_factorial(void){\n\n  fact[0] = 1;\n\n  for( ll i = 1 ; i < N ; i++ ){\n\n    fact[i] = fact[i-1] * i;\n\n    fact[i] %= MOD;\n\n  }\n\n  for( ll i = 0 ; i < N ; i++ ){\n\n    infact[i] = mod_pow( fact[i] , MOD-2 , MOD );\n\n  }\n\n}\n\n\n\nll comb(ll a,ll b){\n\n  if(a == 0 && b == 0)return 1;\n\n  if(a < b || a < 0)return 0;\n\n  ll tmp = infact[a-b]* infact[b] % MOD;\n\n  return tmp * fact[a] % MOD; \n\n}\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  make_factorial();\n  cout<<comb(n+k-1,n)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/* typedef */\ntypedef long long ll;\n/* constant */\nconst int INF = 1 << 30;\nconst int NIL = -1;\nconst int MAX = 10000;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\nstruct mint {\n    ll x;\n    mint(ll x = 0):x((x % mod + mod) % mod) {}\n    mint operator-() const { return mint(-x); }\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\nstruct combination {\n    // vector size : n + 1\n    vector<mint> fact, ifact;\n    // precaliculation O(n)\n    combination(int n):fact(n+1), ifact(n+1) {\n        assert(n < mod);\n        // 0! = 1;\n        fact[0] = 1;\n        // 1! = 0! * 1 ... n! = (n-1)! * n\n        for (int i = 1; i <= n; i++) fact[i] = fact[i-1] * i;\n        // 1/n! = n!^(-1)\n        ifact[n] = fact[n].inv();\n        // (n-1)!^(-1) = n!^(-1) * n ... 0!^(-1) = 1!^(-1) * 1\n        for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i] * i;\n    }\n    // combination O(1)\n    // nCk = n! / (k! * (n-k)!)\n    //     = n! * k!^(-1) * (n-k)!^(-1)\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n-k];\n    }\n};\n/* global variables */\n/* function */\n/* main */\nint main() {\n    int n, k;\n    cin >> n >> k;\n    mint ans = 1;\n    combination c = combination(2000);\n    ans = c(n + k - 1, k - 1);\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { -1,0,1,0 }, dy[4] = { 0,-1,0,1 };\nconst char dir[4] = { 'u','l','d','r' };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        (wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nLL n, k;\nconst LL MOD = 1000000007;\nLL combi(LL N_, LL C_) {\n\tconst int NUM_ = 400001;\n\tstatic LL fact[NUM_ + 1], factr[NUM_ + 1], inv[NUM_ + 1];\n\tif (fact[0] == 0) {\n\t\tinv[1] = fact[0] = factr[0] = 1;\n\t\tfor (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n\t\tfor (int i = 1; i <= NUM_; ++i) fact[i] = fact[i - 1] * i%MOD, factr[i] = factr[i - 1] * inv[i] % MOD;\n\t}\n\tif (C_<0 || C_>N_) return 0;\n\treturn factr[C_] * fact[N_] % MOD*factr[N_ - C_] % MOD;\n}\n\nLL hcomb(int P_, int Q_) { return (P_ == 0 && Q_ == 0) ? 1 : combi(P_ + Q_ - 1, Q_); }\n\nLL modpow(LL a, LL n = MOD - 2) {\n\tLL r = 1;\n\twhile (n) r = r*((n % 2) ? a : 1) % MOD, a = a*a%MOD, n >>= 1;\n\treturn r;\n}\n\nint main() {\n\tcin >> n >> k;\n\tcout << hcomb(k, n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\nconst ll MAX_N = 3e6 + 10;\nconst ll MOD = 1e9+7;\nll Inv[MAX_N];\nll fact[MAX_N];\nll factInv[MAX_N];\nvoid Inv_init(){\n    Inv[1] = 1;\n    for(int i = 2; i < MAX_N; i++) {\n        Inv[i] = Inv[MOD%i] * (MOD - MOD/i) % MOD;\n    }\n}\nvoid fact_init(){\n    fact[0] = fact[1] = factInv[0] = factInv[1] = 1;\n    for(int i = 2; i < MAX_N; i++){\n        fact[i] = (fact[i-1] * i) % MOD;\n        factInv[i] = (factInv[i-1] * Inv[i])%MOD;\n    }\n}\n\n// a^b % MOD;\nll powmod(ll a,ll b) {ll res=1;a%=MOD; for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\n// 逆元 1/a % MOD\nll inversemod(ll a) { return powmod(a,MOD - 2);}\n\n// 1 以上 N 以下の N 個の整数の中から，相異なる K 個の整数を選ぶパターンの数\nll nCr(int n,int r) {\n    if(n < r) return 0;\n    return (fact[n] * (factInv[r] * factInv[n-r] % MOD)) % MOD;\n}\n// 1 以上 N 以下の N 個の整数の中から，相異なる K 個の整数を選び，順番に並べるパターンの数\nll nPr(int n,int r){\n    if(n < r) return 0;\n    return (fact[n]*factInv[n-r])%MOD;\n}\n// 1 以上 N 以下の N 個の整数の中から，重複を許して K 個の整数を選ぶパターンの数\nll nHr(int n,int r){\n    if(n == 0 && r == 0) return 1;\n    return nCr(n+r-1,r);\n}\n\nvoid init(){\n    Inv_init();\n    fact_init();\n}\n\nll solve(){\n    init();\n    ll res = 0;\n    ll n,k; cin >> n >> k;\n    res = nCr(n+k-1,k-1);\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n                                            #include<iostream>\n                                            #include<cstdio>\n                                            #include<vector>\n                                            #include<queue>\n                                            #include<map>\n                                            #include<cstring>\n                                            #include<string>\n                                            #include <math.h>\n                                            #include<algorithm>\n                                        //    #include <boost/multiprecision/cpp_int.hpp>\n                                            #include<functional>\n                                   #define int long long\n                                            #define inf  1000000007\n                                            #define pa pair<int,int>\n                                            #define ll long long\n                                            #define pal pair<double,double>\n                                            #define ppap pair<pa,int>\n                                    //  #define PI 3.14159265358979323846\n                                            #define paa pair<int,char>\n                                            #define  mp make_pair\n                                            #define  pb push_back\n                                            #define EPS (1e-10)\n                                            #define equals(a,b) (fabs((a)-(b))<EPS)\n    int dx[8]={0,-1,0,1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n                                                   #define ppa pair<int,pas>\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                 \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                \tint zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\n\nvector<int> ve;\n\n    signed main(){\n     \n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint n,k;\n    \tcin>>n>>k;\n    \t\n    \tmod=inf;\n    \tgya(10000);\n    \t\n    \tcout<<comb(n+k-1,k-1)<<endl;\n    \t\n  \treturn 0;\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define repp(i, n) rep(i, n)\n#define reppp(i, n) repp(i, n)\n#define rrepp(i, n) rrep(i, n)\n#define repss(i, n) reps(i, n)\n#define repcc(i, n) repc(i, n)\n#define repii(i, a, b) repi(i, a, b)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n  ModInt(): x(0) {}\n  ModInt(i64 a) { x = a % mod; if (x < 0) x += mod; }\n  ModInt &operator+=(ModInt that) { x = (x + that.x) % mod; return *this; }\n  ModInt &operator-=(ModInt that) { x = (x + mod - that.x) % mod; return *this; }\n  ModInt &operator*=(ModInt that) { x = (i64) x * that.x % mod; return *this; }\n  ModInt &operator/=(ModInt that) { return *this *= that.inverse(); }\n  ModInt operator-() { return ModInt(-this->x); }\n  friend ostream& operator<<(ostream &os, ModInt m) { return os << m.x; }\n  ModInt inverse() {\n    int a = x, b = mod, u = 1, v = 0;\n    while (b) { int t = a / b; a -= t * b; u -= t * v; swap(a, b); swap(u, v); }\n    return ModInt(u);\n  }\n  #define op(o, p) ModInt operator o(ModInt that) { return ModInt(*this) p that; }\n    op(+, +=) op(-, -=) op(*, *=) op(/, /=)\n  #undef op\n  #define op(o) bool operator o(ModInt that) const { return x o that.x; }\n    op(==) op(!=) op(<) op(<=) op(>) op(>=)\n  #undef op\n};\n\nusing mint = ModInt<1000000007>;\n\ntemplate <typename T>\nstruct ModCalc {\n  vector<T> fac, finv;\n  ModCalc(int max) {\n    fac = vector<T>(max + 1);\n    finv = vector<T>(max + 1);\n    fac[0] = 1;\n    reps(i, max) fac[i] = fac[i - 1] * i;\n    finv[max] = (T) 1 / fac[max];\n    rreps(i, max) finv[i - 1] = finv[i] * i;\n  }\n  T com(int a, int b) {\n    if (a < 0 || b < 0 || b > a) return 0;\n    return fac[a] * finv[a - b] * finv[b];\n  }\n};\n\nusing mcalc = ModCalc<mint>;\nauto mc = mcalc(2010);\n\nvoid solve() {\n  mint ans = 1;\n  int n, k; cin >> n >> k;\n  cout << mc.com(n + k - 1, n) << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconstexpr int64 P = 1000000007;\n\n// Verified: ABC133E, ABC132D, ABC130E\nstruct FiniteField {\n private:\n  int64 x;\n public:\n  FiniteField(int64 x) : x(x) {}\n  FiniteField() : x(0) {}\n  int64 Value() { return x; }\n  inline FiniteField operator+(FiniteField o) {\n    FiniteField r(*this); r += o; return r;\n  }\n  inline FiniteField operator-(FiniteField o) {\n    FiniteField r(*this); r -= o; return r;\n  }\n  inline FiniteField operator* (FiniteField o) {\n    FiniteField r(*this); r *= o; return r;\n  }\n  inline FiniteField operator/ (FiniteField o) {\n    FiniteField r(*this); r /= o; return r;\n  }\n  inline void operator+= (FiniteField o) { x = (x + o.x) % P; }\n  inline void operator-= (FiniteField o) { x = (x + P - o.x) % P; }\n  inline void operator*= (FiniteField o) { x = (x * o.x) % P; }\n  void operator/=(FiniteField o) {\n    int64 p = P - 2; while (p) { if (p % 2) { *this *= o; } o *= o; p /= 2; }\n  }\n};\n\nvector<FiniteField> MakeFactorialTable(int n) {\n  vector<FiniteField> values(n + 1);\n  values[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    values[i] = values[i - 1] * i;\n  }\n  return values;\n}\n\nFiniteField Power(FiniteField x, int p) {\n  if (p < 0) return FiniteField(1) / Power(x, -p);\n  FiniteField value = 1;\n  while (p) {\n    if (p % 2) value *= x;\n    x *= x;\n    p /= 2;\n  }\n  return value;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, k;\n  cin >> n >> k;\n\n  auto factorials = MakeFactorialTable(n + k + 1);\n  auto c_fn = [&factorials](int x, int y) {\n    return factorials[x] / factorials[y] / factorials[x - y];\n  };\n  FiniteField value = c_fn(n + k - 1, k - 1);\n  cout << value.Value() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long; \nusing pii =  pair<int, int>;\nusing pll =  pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007LL;\n//constexpr long long MOD = 998244353LL;\ntemplate<class T, class U> inline bool chmax(T &a, U b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T, class U> inline bool chmin(T &a, U b) { if (a > b) { a = b; return true;} return false; }\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\ntemplate <std::uint_fast64_t Modulus> \nstruct ModInt {\n    using u64 = std::uint_fast64_t;\n\n    u64 a;\n\n    constexpr ModInt(const long long x = 0) noexcept : a(x >= 0 ? x % Modulus : (Modulus - (-x) % Modulus) % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr ModInt operator+(const ModInt rhs) const noexcept {return ModInt(*this) += rhs;}\n    constexpr ModInt operator-(const ModInt rhs) const noexcept {return ModInt(*this) -= rhs;}\n    constexpr ModInt operator*(const ModInt rhs) const noexcept {return ModInt(*this) *= rhs;}\n    constexpr ModInt operator/(const ModInt rhs) const noexcept {return ModInt(*this) /= rhs;}\n    constexpr ModInt operator^(const long long rhs) const noexcept {return ModInt(*this) ^= rhs;}\n    constexpr ModInt &operator+=(const ModInt rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n    constexpr ModInt &operator^=(long long exp) noexcept {\n        ModInt rhs = a;\n        a = 1;\n        while (exp) {\n            if (exp&1) *this *= rhs;\n            exp >>= 1;\n            rhs *= rhs;\n        }\n        return *this;\n    }\n\n    bool operator==(const ModInt &p) const {return a == p.a;}\n    bool operator!=(const ModInt &p) const {return a != p.a;}\n\n};\n\nusing mint = ModInt<MOD>;\n\nstruct ModCombination {\n    vector<mint> Fac;\n    vector<mint> Facinv;\n\n    ModCombination(int x) {\n        Fac.resize(x+1);\n        Facinv.resize(x+1);\n        Fac[0] = 1;\n        for (int i = 0; i < x; ++i) Fac[i+1] = Fac[i]*(i+1);\n        Facinv[x] = Fac[0]/Fac[x];\n        for (int i = x; i > 0; --i) Facinv[i-1] = Facinv[i]*i;\n    }\n\n    mint get(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return Fac[n]*Facinv[k]*Facinv[n-k];\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,K; cin >> N >> K;\n    ModCombination MC(N+K);\n    cout << MC.get(N+K-1,N).a << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\nll fac[200007],finv[200007],inv[200007];\nvoid cominit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    for(int i=2;i<200007;i++){\n        fac[i]=fac[i-1]*i%mod;\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n}\nll com(ll n,ll k){\n    if(n<k)return 0;\n    if(n<0 || k<0)return 0;\n    return fac[n]*(finv[k]*finv[n-k]%mod)%mod;\n}\nlong long modpow(long long a, long long n) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    cominit();\n    ll n,k;\n    cin>>n>>k;\n    cout << com(n+k-1,n) <<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Compute C(N+K-1,K-1) (stars and bars)\n#include <iostream>\nusing namespace std;\nint C[2002][1002];\nint M = 1e9 + 7;\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  for (int n = 0; n <= N; ++n)\n    C[n][0] = 1;\n  for (int k = 1; k <= K; ++k)\n    for (int n = k; n <= N + K - 1; ++n)\n      C[n][k] = (C[n - 1][k - 1] + C[n - 1][k]) % M;\n  cout << C[N + K - 1][K - 1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"DPL_5_D.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_D\"\n\n#include <bits/stdc++.h>  // clang-format off\nusing Int = long long;\n#define REP_(i, a_, b_, a, b, ...) for (Int i = (a), lim##i = (b); i < lim##i; i++)\n#define REP(i, ...) REP_(i, __VA_ARGS__, __VA_ARGS__, 0, __VA_ARGS__)\nstruct SetupIO { SetupIO() { std::cin.tie(nullptr), std::ios::sync_with_stdio(false), std::cout << std::fixed << std::setprecision(13); } } setup_io;\n#ifndef _MY_DEBUG\n#define dump(...)\n#endif  // clang-format on\n\n/**\n *    author:  knshnb\n *    created: Sun Apr 12 17:47:21 JST 2020\n **/\n\n#define CALL_FROM_TEST\n#line 1 \"/Users/knshnb/competitive_programming/competitive_library/src/Math/ModInt.hpp\"\ntemplate <class T> T pow(T x, int n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\n/// @docs src/Math/ModInt.md\ntemplate <int Mod> struct ModInt {\n    int x;\n    static int runtime_mod;\n    static std::unordered_map<int, int> to_inv;\n    // テンプレート引数が負のときは実行時ModInt\n    static int mod() { return Mod < 0 ? runtime_mod : Mod; }\n    static void set_runtime_mod(int mod) {\n        static_assert(Mod < 0, \"template parameter Mod must be negative for runtime ModInt\");\n        runtime_mod = mod;\n        to_inv.clear();\n    }\n    ModInt() : x(0) {}\n    ModInt(long long x_) {\n        if ((x = x_ % mod() + mod()) >= mod()) x -= mod();\n    }\n\n    ModInt& operator+=(ModInt rhs) {\n        if ((x += rhs.x) >= mod()) x -= mod();\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (unsigned long long)x * rhs.x % mod();\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        if ((x -= rhs.x) < 0) x += mod();\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        x = (unsigned long long)x * rhs.inv().x % mod();\n        return *this;\n    }\n    ModInt operator-() const { return -x < 0 ? mod() - x : -x; }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, mod() - 2).x); }\n\n    friend std::ostream& operator<<(std::ostream& s, ModInt<Mod> a) {\n        s << a.x;\n        return s;\n    }\n    friend std::istream& operator>>(std::istream& s, ModInt<Mod>& a) {\n        long long tmp;\n        s >> tmp;\n        a = ModInt<Mod>(tmp);\n        return s;\n    }\n    friend std::string to_string(ModInt<Mod> a) { return std::to_string(a.x); }\n};\ntemplate <int Mod> std::unordered_map<int, int> ModInt<Mod>::to_inv;\ntemplate <int Mod> int ModInt<Mod>::runtime_mod;\n\n#ifndef CALL_FROM_TEST\nusing mint = ModInt<1000000007>;\n#endif\n#line 1 \"/Users/knshnb/competitive_programming/competitive_library/src/Math/Combination.hpp\"\ntemplate <class T> struct Combination {\n    std::vector<T> fact, fact_inv;\n    Combination(int n = 1000003) : fact(n + 1, 1), fact_inv(n + 1) {\n        for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n        fact_inv[n] = (T)1 / fact[n];\n        for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n        // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n    }\n    T operator()(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n};\n#line 20 \"DPL_5_D.test.cpp\"\n#undef CALL_FROM_TEST\n\nusing mint = ModInt<1000000007>;\nsigned main() {\n    Combination<mint> comb;\n    Int n, k;\n    std::cin >> n >> k;\n    std::cout << comb(n + k - 1, n) << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<Int MOD = 1000000007>\nstruct Mod{\n  Int prev=0;\n  vector<Int> fact,inv,finv;\n  Mod(){}\n  Mod(Int n){init(n);}\n  \n  Int pow(Int x,Int n){\n    Int res=1;\n    while(n){\n      if(n&1) (res*=x)%=MOD;\n      (x*=x)%=MOD;\n      n>>=1;\n    }\n    return res;\n  }\n  \n  Int inverse(Int a){\n    return pow(a,MOD-2);\n  }\n  \n  void init(Int n){\n    if(prev>=n) return;\n    prev=n;\n    fact=inv=finv=vector<Int>(n);\n    \n    fact[0]=1;\n    for(Int i=1;i<n;i++)\n      fact[i]=(fact[i-1]*i)%MOD;\n    \n    inv[1]=1;\n    for(Int i=2;i<n;i++)\n      inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    \n    finv[0]=1;\n    for(Int i=1;i<n;i++)\n      finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n  \n  Int comb(Int n,Int k){\n    Int res=1;\n    for(Int i=0;i<k;i++){\n      res*=(n-i)%MOD;\n      res%=MOD;\n      res*=inverse(i+1);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  //only for prime MOD\n  Int C(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[k]%MOD*finv[n-k]%MOD;\n  }\n\n  Int H(Int n,Int k){\n    return C(n+k-1,n);\n  }\n  \n  Int montmort(Int n){\n    Int res=0,rinv=1;\n    for(Int k=2;k<=n;k++){\n      (rinv*=inverse(k))%=MOD;\n      if(k%2) (res+=MOD-rinv)%=MOD;\n      else (res+=rinv)%=MOD;\n    }\n    for(Int i=1;i<=n;i++)\n      (res*=i)%=MOD;\n    return res;\n  }\n  \n  // calculate P(t) from given points in [0,N]\n  Int LagrangePolynomial(vector<Int> &y,Int t){\n    Int n=y.size()-1;\n    init(n+1);\n    Int num=1;\n    for(Int i=0;i<=n;i++)\n      num=num*((t-i)%MOD)%MOD;\n    Int res=0;\n    for(Int i=0;i<=n;i++){\n      Int tmp=(y[i]*num%MOD)*inverse((t-i)%MOD)%MOD;\n      tmp=tmp*finv[i]%MOD;\n      tmp=tmp*finv[n-i]%MOD;\n      if((n-i)&1) tmp=MOD-tmp;\n      res=(res+tmp)%MOD;\n    }\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MOD = 1e9+7;\n  Mod<MOD> mod(2e5);\n  Int n,k;\n  cin>>n>>k;\n  cout<<mod.H(n,k)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tv.clear(); char c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define INT input(int)\n#define LL input(ll)\n#define STR input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(ll, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto map(const F& f)const {\n\t\tvector<U> res; res.reserve(count()); each([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const { int res = 0; each([&](T i) {if (f(i))++res; }); return res; }\n\ttemplate<class F>T find_if(const F& f)const { for (T i : *this)if (f(i))return i; return 0; }\n\ttemplate<class F>auto max_by(const F& f)const { auto v = map(f); return *max_element(v.begin(), v.end()); }\n\ttemplate<class F>auto min_by(const F& f)const { auto v = map(f); return *min_element(v.begin(), v.end()); }\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\ntemplate<int MOD>struct modint {\n\tusing T = long long;\n\tT n;\n\tconstexpr modint(const T x = 0) :n(x% MOD) { if (n < 0)n += MOD; }\n\tconstexpr int get_mod()const { return MOD; }\n\tconstexpr modint operator+()const { return *this; }\n\tconstexpr modint operator-()const { return n ? MOD - n : 0; }\n\tconstexpr modint& operator++() { if (MOD <= ++n)n = 0; return *this; }\n\tconstexpr modint& operator--() { if (n <= 0)n = MOD; n--; return *this; }\n\tconstexpr modint operator++(int) { modint t = *this; ++* this; return t; }\n\tconstexpr modint operator--(int) { modint t = *this; --* this; return t; }\n\tconstexpr modint next()const { return ++modint(*this); }\n\tconstexpr modint pred()const { return --modint(*this); }\n\tconstexpr modint operator+(const modint& m)const { return modint(*this) += m; }\n\tconstexpr modint operator-(const modint& m)const { return modint(*this) -= m; }\n\tconstexpr modint operator*(const modint& m)const { return modint(*this) *= m; }\n\tconstexpr modint operator/(const modint& m)const { return modint(*this) /= m; }\n\tconstexpr modint& operator+=(const modint& m) { n += m.n; if (n >= MOD)n -= MOD; return *this; }\n\tconstexpr modint& operator-=(const modint& m) { n -= m.n; if (n < 0)n += MOD; return *this; }\n\tconstexpr modint& operator*=(const modint& m) { n = n * m.n % MOD; return *this; }\n\tconstexpr modint& operator/=(const modint& m) {\n\t\tT a = m.n, b = MOD, u = 1, v = 0;\n\t\twhile (b) {\n\t\t\tT t = a / b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tn = n * u % MOD;\n\t\tif (n < 0)n += MOD;\n\t\treturn *this;\n\t}\n\tconstexpr bool operator==(const modint& m)const { return n == m.n; }\n\tconstexpr bool operator!=(const modint& m)const { return n != m.n; }\n\tconstexpr modint pow(modint m)const {\n\t\tmodint t = n, res = 1; while (m.n > 0) { if (m.n & 1)res *= t; t *= t; m.n >>= 1; } return res;\n\t}\n\tconstexpr modint operator^(modint m)const { return pow(m); }\n};\nusing mint = modint<1000000007>;\nusing VM = vector<mint>;\ntemplate<int MOD>inline ostream& operator<<(ostream& os, const modint<MOD>& m) { return os << m.n; }\ntemplate<int MOD>inline istream& operator>>(istream& is, modint<MOD>& m) { return is >> m.n; }\ninline mint operator\"\"_m(unsigned long long n) { return n; }\n\ntemplate<int MOD>class Combi {\n\tusing T = modint<MOD>;\n\tint Max;\n\tvector<T> fac, finv, inv;\npublic:\n\tCombi(int _Max = 300009) : Max(_Max), fac(_Max), finv(_Max), inv(_Max) {\n\t\tfac[0] = fac[1] = 1;\n\t\tfinv[0] = finv[1] = 1;\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < Max; ++i) {\n\t\t\tfac[i] = fac[i - 1] * i;\n\t\t\tinv[i] = T(MOD) - inv[MOD % i] * (MOD / i);\n\t\t\tfinv[i] = finv[i - 1] * inv[i];\n\t\t}\n\t}\n\tT P(int n, int r) {\n\t\treturn (n < r || n < 0 || r < 0) ? 0 : fac[n] * finv[n - r];\n\t}\n\tT C(int n, int r) {\n\t\treturn (n < r || n < 0 || r < 0) ? 0 : fac[n] * finv[r] * finv[n - r];\n\t}\n\tT H(int n, int r) {\n\t\treturn (n < 0 || r < 0) ? 0 : r == 0 ? 1 : C(n + r - 1, r);\n\t}\n};\n\nint main() {\n\tCombi<MOD> C;\n\n\tini(n, k);\n\tout(C.C(n + k - 1, k - 1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\n\nconst int MAX = 510000;\nconst ll mod = 1e9+7;\n\nll fac[MAX], finv[MAX], inv[MAX];\n\nvoid COMinit() {\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++){\n    fac[i] = fac[i-1] * (ll)i % mod;\n    inv[i] = mod - inv[mod%i] * (mod/(ll)i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll COM(int n, int k){\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nint main(){\n  ll n, k;\n  cin >> n >> k;\n  COMinit();\n  cout << COM(n+k-1,n) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define PRINT(x)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl;\n#define PRINTA(a,first,last)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#a<<\"[\"<<(first)<<\", \"<<(last)<<\")\"<<endl;\\\n    for (int _i=(first);_i<(last);++_i){cout<<#a<<\"[\"<<_i<<\"] = \"<<(a)[_i]<<endl;}\n#define PRINTP(p)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#p<<\" = (\"<<(p.first)<<\", \"<<(p.second)<<\")\"<<endl;\n#define PRINTI(a,i)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#a<<\"[\"<<#i<<\"] = \"<<#a<<\"[\"<<(i)<<\"] = \"<<(a)[i]<<endl;\n#else\n#define PRINT(x)\n#define PRINTA(a,first,last)\n#define PRINTP(p)\n#define PRINTI(a,i)\n#endif\n\n#define FOR(i,a,b) for (int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);--i)\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define MOD 1000000007\n\nusing namespace std;\n\nusing ull = unsigned long long;\n\ntemplate <class T, T M>\nclass modulo {\npublic:\n    T data;\n\n    modulo(T data = 0) : data(data % M) {\n    }\n\n    modulo operator+(const modulo &x) const {\n        return modulo(data + x.data);\n    }\n\n    modulo operator-(const modulo &x) const {\n        return modulo(data + (M - x.data));\n    }\n\n    modulo operator*(const modulo &x) const {\n        return modulo(data * x.data);\n    }\n\n    modulo operator/(const modulo &x) const {\n        return modulo(data * x.inv().data);\n    }\n\n    modulo operator+=(const modulo &x) {\n        return data = (data + x.data) % M;\n    }\n\n    modulo operator-=(const modulo &x) {\n        return data = (data + (M - x.data)) % M;\n    }\n\n    modulo operator*=(const modulo &x) {\n        return data = (data * x.data) % M;\n    }\n\n    modulo operator/=(const modulo &x) {\n        return data = (data * x.inv().data) % M;\n    }\n\n    modulo inv() const {\n        return _pow(M - 2);\n    }\n\n    template <class Integer>\n    modulo operator^(Integer n) const {\n        if (n >= 0) {\n            return _pow(n);\n        } else {\n            return _pow(M - 1 - (-n) % (M - 1));\n        }\n    }\n\n    friend std::ostream& operator<<(std::ostream &os, const modulo &x) {\n        os << x.data;\n        return os;\n    }\n\nprivate:\n    template <class NonNegativeInteger>\n    modulo _pow(NonNegativeInteger n) const {\n        modulo result(1);\n        modulo x(*this);\n        while (n) {\n            if (n & 1) {\n                result *= x;\n            }\n            x *= x;\n            n >>= 1;\n        }\n        return result;\n    }\n};\n\ntemplate <class T, T M>\nstruct combinatorics {\n\n    using Mod = modulo<T, M>;\n\n    T N;\n    std::vector<Mod> factorial;\n    std::vector<Mod> inv_factorial;\n\n    combinatorics(T N) : N(N), factorial(N + 1), inv_factorial(N + 1) {\n        factorial[0] = 1;\n        for (T i = 1; i <= N; ++i) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n        inv_factorial[N] = factorial[N].inv();\n        for (T i = N; i >= 1; --i) {\n            inv_factorial[i - 1] = inv_factorial[i] * i;\n        }\n    }\n\n    Mod P(T n, T k) {\n        if (0 <= k && k <= n) {\n            return factorial[n] * inv_factorial[k];\n        } else {\n            return 0;\n        }\n    }\n\n    Mod C(T n, T k) {\n        if (0 <= k && k <= n) {\n            return factorial[n] * inv_factorial[k] * inv_factorial[n - k];\n        } else {\n            return 0;\n        }\n    }\n\n    Mod H(T n, T k) {\n        if (n == 0 && k == 0) {\n            return 1;\n        } else {\n            return C(n + k - 1, k);\n        }\n    }\n};\n\nenum map_condition {\n    NONE,\n    INJECTIVE,\n    SURJECTIVE,\n};\n\nusing Mod = modulo<ull, MOD>;\n\nMod twelvefold(ull n, ull m, map_condition condition, bool up_to_permutation_of_n, bool up_to_permutation_of_m) {\n    if (!up_to_permutation_of_n && !up_to_permutation_of_m) {\n        if (condition == NONE) {\n            // O(log(n))\n            return Mod(m) ^ n;\n        } else if (condition == INJECTIVE) {\n            // pre O(m)\n            // O(1)\n            combinatorics<ull, MOD> c(m);\n            return c.P(m, m - n);\n        } else if (condition == SURJECTIVE) {\n        }\n    } else if (up_to_permutation_of_n && !up_to_permutation_of_m) {\n        if (condition == NONE) {\n            // pre O(n + m)\n            // O(1)\n            combinatorics<ull, MOD> c(n + m - 1);\n            return c.C(n + m - 1, n); // H(m, n)\n        } else if (condition == INJECTIVE) {\n        } else if (condition == SURJECTIVE) {\n        }\n    } else if (!up_to_permutation_of_n && up_to_permutation_of_m) {\n        if (condition == NONE) {\n\n        } else if (condition == INJECTIVE) {\n        } else if (condition == SURJECTIVE) {\n        }\n    } else if (up_to_permutation_of_n && up_to_permutation_of_m) {\n        if (condition == NONE) {\n        } else if (condition == INJECTIVE) {\n        } else if (condition == SURJECTIVE) {\n        }\n    }\n    assert(0);\n}\n\nint main() {\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ull n, m;\n    cin >> n >> m;\n    cout << twelvefold(n, m, NONE, true, false) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\n#define MOD 1000000007\ntemplate<int mod>\nstruct ModInt{\n   int x;\n   ModInt():x(0){}\n   ModInt(long long y):x(y>=0?y%mod:(mod-(-y)%mod)%mod){}\n   ModInt &operator+=(const ModInt &p){\n       if((x+=p.x)>=mod)x-=mod;\n       return *this;\n   }\n   ModInt &operator-=(const ModInt &p){\n       if((x+=mod-p.x)>=mod)x-=mod;\n       return *this;\n   }\n   ModInt &operator*=(const ModInt &p){\n       x=(int)(1LL*x*p.x%mod);\n       return *this;\n   }\n   ModInt &operator/=(const ModInt &p){\n       *this*=p.inverse();\n       return *this;\n   }\n   ModInt &operator^=(long long p){\n       ModInt res = 1;\n       for (; p; p >>= 1) {\n           if (p & 1) res *= *this;\n           *this *= *this;\n       }\n       return *this = res;\n   }\n   ModInt operator-()const{return ModInt(-x);}\n   ModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n   ModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n   ModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n   ModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n   ModInt operator^(long long p)const{return ModInt(*this)^=p;}\n   bool operator==(const ModInt &p)const{return x==p.x;}\n   bool operator!=(const ModInt &p)const{return x!=p.x;}\n   explicit operator int() const { return x; }\n   ModInt operator=(const int p) {x = p; return ModInt(*this);}\n   ModInt inverse()const{\n       int a=x,b=mod,u=1,v=0,t;\n       while(b>0){\n           t=a/b;\n           a-=t*b;\n           std::swap(a,b);\n           u-=t*v;\n           std::swap(u,v);\n       }\n       return ModInt(u);\n   }\n   friend std::ostream &operator<<(std::ostream &os,const ModInt<mod> &p){\n       return os<<p.x;\n   }\n   friend std::istream &operator>>(std::istream &is,ModInt<mod> &a){\n       long long x;\n       is>>x;\n       a=ModInt<mod>(x);\n       return (is);\n   }\n};\ntypedef ModInt<MOD> mint;\n \nstruct MComb {\n   std::vector<mint> fact;\n   std::vector<mint> inversed;\n   MComb(int n) { // O(n+log(mod))\n       fact = std::vector<mint>(n+1,1);\n       for (int i = 1; i <= n; i++) fact[i] = fact[i-1]*mint(i);\n       inversed = std::vector<mint>(n+1);\n       inversed[n] = fact[n] ^ (MOD-2);\n       for (int i = n - 1; i >= 0; i--) inversed[i]=inversed[i+1]*mint(i+1);\n   }\n   mint ncr(int n, int r) {\n        if (n < r) return 0;\n        if (n < 0 || r < 0) return 0;\n       return (fact[n] * inversed[r] * inversed[n-r]);\n   }\n   mint npr(int n, int r) {\n        if (n < r) return 0;\n        if (n < 0 || r < 0) return 0;\n       return (fact[n] * inversed[n-r]);\n   }\n   mint nhr(int n, int r) {\n       assert(n+r-1 < (int)fact.size());\n       return ncr(n+r-1, r);\n   }\n   mint fac(int n) {\n       if(n < 0)return 0;\n       return fact[n];\n   }\n};\nMComb comb(200000);\n \nmint ncr(int n, int r) {\n   mint res = 1;\n   for (int i = n - r + 1; i <= n; i++) res *= i;\n   for (int i = 1; i <= r; i++) res /= i;\n   return res;\n}\n\n\nint main()\n{\n    int n, k; cin >> n >> k;\n    cout << ncr(n + k - 1, k - 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1e9+7;\nconst int N=2e3+10;\n\nll myPow(ll a,ll n)\n{\n    ll ans=1;\n    while(n>0)\n    {\n        if(n&1)\n        {\n            ans=ans*a%M;\n        }\n        a=a*a%M;\n        n>>=1;\n    }\n    return ans;\n}\n\nll fac[N],inv[N];\n\nvoid init()\n{\n    fac[0]=1;\n    for(int i=1;i<N;i++)\n    {\n        fac[i]=fac[i-1]*i%M;\n    }\n    inv[N-1]=myPow(fac[N-1],M-2);\n    for(int i=N-2;i>=0;i--)\n    {\n        inv[i]=inv[i+1]*(i+1)%M;\n    }\n}\n\nint main()\n{\n    init();\n    int n,k;\n    while(cin>>n>>k)\n    {\n        cout<<fac[n+k-1]*inv[k-1]%M*inv[n]%M<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\") //コンパイラ最適化用\n\n#define _GLIBCXX_DEBUG //配列に[]でアクセス時のエラー表示\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n// forループ関係\n#define REP(i, n) for (ll i = 0; i < ll(n); i++)\n#define REPD(i, n) for (ll i = n - 1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = a; i < ll(b); i++)\n#define FORD(i, a, b) for (ll i = a; i > ll(b); i--)\n// xにはvectorなどのコンテナ\n#define ALL(x) x.begin(), x.end() // sortなどの引数を省略したい\n#define SIZE(x) ll(x.size())      // sizeをsize_tからllに直しておく\n//定数\n#define INF 1000000000000 // 10^12:極めて大きい値,∞\nconst int MOD = 1000000007;\n#define MAXR 100000 // 10^5:配列の最大のrange(素数列挙などで使用)\n//略記\n#define PB push_back // vectorヘの挿入\n#define MP make_pair // pairのコンストラクタ\n#define F first      // pairの一つ目の要素\n#define S second     // pairの二つ目の要素\n#define Umap unordered_map\n#define Uset unordered_set\n#define P pair<ll, ll>\nconst unsigned int BIT_FLAG_0 = (1 << 0); // 0000 0000 0000 0001\nconst unsigned int BIT_FLAG_1 = (1 << 1); // 0000 0000 0000 0010\nconst unsigned int BIT_FLAG_2 = (1 << 2); // 0000 0000 0000 0100\nconst unsigned int BIT_FLAG_3 = (1 << 3); // 0000 0000 0000 1000\nconst unsigned int BIT_FLAG_4 = (1 << 4); // 0000 0000 0001 0000\nconst unsigned int BIT_FLAG_5 = (1 << 5); // 0000 0000 0010 0000\nconst unsigned int BIT_FLAG_6 = (1 << 6); // 0000 0000 0100 0000\nconst unsigned int BIT_FLAG_7 = (1 << 7); // 0000 0000 1000 0000\nvoid add(long long &a, long long b) {\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n// modint: mod 計算を int を扱うように扱える構造体\n// https://github.com/drken1215/algorithm/blob/master/MathCombinatorics/mod.cpp\n// https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a\n\ntemplate <int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0)\n            val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept { return val ? MOD - val : 0; }\n    constexpr Fp operator+(const Fp &r) const noexcept {\n        return Fp(*this) += r;\n    }\n    constexpr Fp operator-(const Fp &r) const noexcept {\n        return Fp(*this) -= r;\n    }\n    constexpr Fp operator*(const Fp &r) const noexcept {\n        return Fp(*this) *= r;\n    }\n    constexpr Fp operator/(const Fp &r) const noexcept {\n        return Fp(*this) /= r;\n    }\n    constexpr Fp &operator+=(const Fp &r) noexcept {\n        val += r.val;\n        if (val >= MOD)\n            val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept {\n        val -= r.val;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os,\n                                         const Fp<MOD> &x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0)\n            return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1)\n            t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate <class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for (int i = 2; i < n; i++) {\n            fact_[i] = fact_[i - 1] * i;\n            inv_[i] = -inv_[MOD % i] * (MOD / i);\n            finv_[i] = finv_[i - 1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0)\n            return 0;\n        return fact_[n] * finv_[k] * finv_[n - k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0)\n            return 0;\n        return fact_[n];\n    }\n    // 追加\n    constexpr T perm(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0)\n            return 0;\n        return fact_[n] * finv_[k] * finv_[n - k] * fact_[k];\n    }\n\n    constexpr T inv(int n) const noexcept {\n        if (n < 0)\n            return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0)\n            return 0;\n        return finv_[n];\n    }\n};\n// a^n mod を計算する\nlong long modpower(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n// mint(modpower(i, N, MOD))\n\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n/*\nint main() {\n    long long N, M, K; cin >> N >> M >> K;\n    mint sum = 0;\n    for (int i = 0; i <= N-1; ++i) {\n        for (int j = 0; j <= M-1; ++j) {\n            mint tmp = mint(N - i) * mint(M - j) * mint(i + j);\n            if (i != 0 && j != 0) tmp *= 2;\n            sum += tmp;\n        }\n    }\n    cout << sum * bc.com(N*M-2, K-2) << endl;\n}\n*/\n\nint main() {\n    bc.init(510000);\n\n    int n, k;\n    cin >> n >> k;\n    mint ans;\n    ans = bc.com(n + k - 1, n);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reprrev(i,a,b) for(int i=b-1;i>=a;i--) // [a, b)\n#define reprev(i,n) reprrev(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst ll mod = 1e9+7;\n\n\nvoid chmod(ll &M){\n    if(M >= mod) M %= mod;\n    else if(M < 0){\n        M += (abs(M)/mod + 1)*mod;\n        M %= mod;\n    }\n}\n\nll modpow(ll x, ll n){\n    if(n==0) return 1;\n    ll res=modpow(x, n/2);\n\n    if(n%2==0) return res*res%mod;\n    else return res*res%mod*x%mod;\n}\n\nint getl(int i, int N) { return i==0? N-1:i-1; };\nint getr(int i, int N) { return i==N-1? 0:i+1; };\n\n// 線分 ab の偏角 返り値は[-π, π]\ntemplate<typename T>\nT argument(const pair<T, T> &a, const pair<T, T> &b){\n    double ax=a.first, ay=a.second, bx=b.first, by=b.second;\n    return atan2(by-ay, bx-ax);\n}\n\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n\n/* 注意 \n\n    1LL<<60 * N とかのオーバーフローに気を付けろ\n    制約がヒントになる、ちゃんと全ての制約を見ろ\n\n*/\n\nint const MAX = 2000000;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAX; i++){\n        fac[i] = fac[i-1] * i % mod;\n        inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n        finv[i] = finv[i-1] * inv[i] % mod;\n    }\n}\nlong long COM(int n, int k){\n    if(n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nint main(void) {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    COMinit();\n    int n, k; std::cin >> n >> k;\n    std::cout << COM(n+k-1, k-1) << std::endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(I,X,Y) for(long long (I)=(X);(I)<(Y);(I)++)\n#define REP(I,X,Y) for(long long (I)=(Y)-1;(I)>=(X);(I)--)\n#define ALL(X) (X).begin(),(X).end()\n#define pb push_back\n#define COUNT(V,X) upper_bound((V).begin(),(V).end(),X)-lower_bound((V).begin(),(V).end(),X)\n#define debug(x) cerr<<#x<<':'<<x<<endl;\n#define DEBUG(v) cerr<<#v<<':';for(auto x:v)cerr<<x<<' ';cerr<<endl;\n#define INF 1000000007\n#define LINF 1000000000000000007\n#define EPS 1e-9\ntypedef long long ll;\n\nlong long POW(long long x,long long n,long long mod){\n  long long ans = 1;\n  while(n){\n    if(n%2)ans *= x;\n    x *= x;\n    x %= mod;\n    ans %= mod;\n    n >>= 1;\n  }\n  return ans;\n}\nvector<long long> factorial(2,1);\nlong long nckmodp(long long n,long long k,long long p){\n  if(n < k || n <= 0 || k < 0)return 0;\n  while(factorial.size() <= n){\n    long long i = factorial.size();\n    factorial.push_back(i*factorial[i-1]%p);\n  }\n  return ((factorial[n]*POW(factorial[k],p-2,p))%p)*POW(factorial[n-k],p-2,p)%p;\n}\nlong long TwelvefoldWay4(long long n,long long k,long long MOD){\n  return nckmodp(n+k-1,n,MOD);\n}\n\nsigned main(){\n  ll n,k;\n  cin >> n >> k;\n  cout << TwelvefoldWay4(n,k,INF) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nconst int S = 2020;\nint comb[S+10][S+10];\nsigned main() {\n    int N, K; cin >> N >> K;\n    for(int i=0; i<S; i++) {\n        comb[i][0] = 1;\n        for(int j=1; j<=i; j++) {\n            (comb[i][j] += comb[i-1][j-1] + comb[i-1][j]) %= MOD;\n        }\n    }\n\n    int n = N+K-1;\n    int r = N;\n    cout << comb[n][r] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<long long> VL;\ntypedef vector<vector<long long>> VVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define EXIST(m,v) (m).find((v)) != (m).end()\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconstexpr double EPS = 1e-9;\nconstexpr double PI  = 3.1415926535897932;\nconstexpr int INF = 2147483647;\nconstexpr long long LINF = 1LL<<60;\nconstexpr long long MOD = 1000000007; // 998244353;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nstruct mint {\n    long long x;\n    mint(long long x=0):x((x%MOD+MOD)%MOD){}\n    mint operator-() const { return mint(-x);}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n    \treturn *this;\n    }\n    mint& operator*=(const mint a) {\n    \t(x *= a.x) %= MOD;\n    \treturn *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(long long t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n    \tif (t&1) a *= *this;\n        return a;\n    }\n    // for prime MOD\n    mint inv() const {\n        return pow(MOD-2);\n    }\n    mint& operator/=(const mint a) {\n    \treturn (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n    combination(long long n):fact(n+1),ifact(n+1) {\n        assert(n < MOD);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n    }\n    mint operator()(long long n, long long k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n]*ifact[k]*ifact[n-k];\n    }\n};\n\nvoid Main(){\n    int n,k; cin >> n >> k;\n    combination C(n+k);\n    vector<mint> kai(n+k+1,1); REP(i,n+k) kai[i+1] = kai[i]*(i+1);\n    cout << C(n+k-1,n).x << en;\n    return;\n}\n\nint main(void){\n    cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(0);cout<<fixed<<setprecision(15);\n    int t=1; //cin>>t;\n    REP(_,t) Main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define REP(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<endl\n#define p2(s, t) cout << (s) << \" \" << (t) << endl\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << endl\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\nconst int N_MAX = 5000;\nll Per[N_MAX] = {}; // n!\nll Per_inv[N_MAX] = {}; //(n!)^-1\n\nll nCr(ll n, ll r){\n    if(n<r) return 0;\n \n    if (n == r || r == 0)\n        return 1;\n    else\n        return Per[n] * Per_inv[n-r] % mod * Per_inv[r] % mod;  \n}\n \n// a^b mod p\nll mod_pow(ll a, ll b){\n    if(b==0) return 1;\n \n    // 肩が奇数\n    if(b%2==1){\n        return a * mod_pow(a, b-1) % mod;\n    }\n    else{\n        return mod_pow(a*a % mod, b/2) % mod;\n    }\n}\n\nvoid prepare_nCr(){\n    Per[0] = 1;\n    Per_inv[0] = 1;\n\n    // nCr高速化準備\n    Per[1] = 1;\n    FOR(i, 2, N_MAX){\n        Per[i] = i * Per[i-1] % mod;\n    }\n    Per_inv[1] = 1;\n    FOR(i, 2, N_MAX){\n        Per_inv[i] = mod_pow(Per[i], 1000000005);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N, K;\n    cin >> N >> K;\n\n    prepare_nCr();\n    \n    ll ans = Per[N+K-1] * Per_inv[N] % mod * Per_inv[K-1] % mod;\n    p(ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PI pair<P,int>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\nint Madd(int x,int y) {return (x+y)%M;}\nint Msub(int x,int y) {return (x-y+M)%M;}\nint Mmul(int x,int y) {return (x*y)%M;}\n\n\n\nstruct Combinations {\n  static int num;\n  vi fact,factr,inv;\n\n  Combinations(int num) {\n\n    fact.assign(num+1,0);\n    factr.assign(num+1,0);\n    inv.assign(num+1,0);\n    inv[1]=fact[0]=factr[0]=1;\n    FOR(i,2,num+1) inv[i]=inv[M%i]*(M-M/i)%M;\n    FOR(i,1,num+1) fact[i]=fact[i-1]*i%M,factr[i]=factr[i-1]*inv[i]%M;\n  }\n\n\n  int comb(int n,int c){\n    if(c<0||c>n) return 0;\n    return factr[c]*fact[n]%M*factr[n-c]%M;\n  }\n\n  int per(int n,int c){\n    if(c<0||c>n) return 0;\n    return fact[n]*factr[n-c]%M;\n  }\n\n  int hcomb(int n,int c){\n    if(n==0&&c==0) return 1;\n    return comb(n+c-1,c-1);\n  }\n\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  int n,k;\n  cin>>n>>k;\n  Combinations comb(n+k);\n  cout<<comb.hcomb(n,k)<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ninline int64 modPow(int64 x, int64 n) {\n  if(n == 0) return (1);\n  int64 ret = modPow(x, n / 2);\n  (ret *= ret) %= mod;\n  if(n & 1) (ret *= x) %= mod;\n  return (ret);\n}\n\ninline int64 modInv(int64 a) {\n  return (modPow(a, mod - 2));\n}\n\ninline int64 modCombination(int p, int q) {\n  static int64 fact[202020], rfact[202020];\n  if(fact[0] == 0) {\n    fact[0] = rfact[0] = 1;\n    for(int i = 1; i < 102020; i++) {\n      fact[i] = fact[i - 1] * i % mod;\n      rfact[i] = modInv(fact[i]);\n    }\n  }\n  if(q < 0 || p < q) return (0);\n  return (fact[p] * rfact[q] % mod * rfact[p - q] % mod);\n}\n\ninline int64 count2_1(int n, int k) {\n  return (modCombination(n + k - 1, k - 1));\n}\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  cout << count2_1(N, K) << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nconstexpr lint mod = 1e9 + 7;\ninline lint emod(lint a, lint p = mod) { return (a % p + p) % p; }\ninline lint invm(lint a, lint p = mod) { a %= p; return a == 1 ? 1 : -p / a * invm(p % a) % p; }\n\nV<lint> fact, ifact;\nvoid init_table(int n) {\n  fact.assign(n + 1, 1), ifact.assign(n + 1, 1);\n  for (int i = 2; i < n + 1; ++i) fact[i] = i * fact[i - 1] % mod;\n  ifact[n] = invm(fact[n]);\n  for (int i = n; i > 2; --i) ifact[i - 1] = i * ifact[i] % mod;\n}\n\nlint comb(lint n, lint r) {\n  if (r < 0 or r > n) return 0;\n  return fact[n] * ifact[r] % mod * ifact[n - r] % mod;\n}\n\nlint mulcomb(lint n, lint r) {\n  if (n < 1 or r < 0) return 0;\n  return fact[r + n - 1] * ifact[r] % mod * ifact[n - 1] % mod;\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  lint n, k; cin >> n >> k;\n  init_table(n + k);\n  cout << emod(mulcomb(k, n)) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// n の k 乗を mod で割った余りを計算\nlong long power_mod(long long n, long long k, long long mod) {\n    long long result = 1;\n    // k を右シフトしつつ n を 2 乗していく\n    while (k > 0) {\n        // k の最下ビットが 1 なら、今の n を答えに掛ける\n        if ((k & 1) == 1) result = (result * n) % mod;\n        n = n * n % mod;\n        k >>= 1;\n    }\n    return result;\n}\n\n// 階乗・組み合わせの mod 逆数\nclass FactorialMod {\n    // 逆元を計算\n    void calc_inverse() {\n        inverse[0] = 0;\n        inverse[1] = 1;\n        for (int i = 2; i <= max_num; i++) {\n            inverse[i] = mod - ((mod / i) * inverse[mod % i] % mod);\n        }\n    }\n\n    // i! を mod で割った余りと逆元を計算\n    void calc_factorial_inverse() {\n        factorial[0] = factorial_inverse[0] = 1;\n        for (int i = 1; i <= max_num; i++) {\n            factorial[i] = (factorial[i - 1] * i) % mod;\n            factorial_inverse[i] = (factorial_inverse[i - 1] * inverse[i]) % mod;\n        }\n    }\n\n  public:\n    int max_num;                         // 扱う最大の値\n    int mod;                             // mod の法（素数）\n    vector<long long> inverse;           // 逆元\n    vector<long long> factorial;         // 階乗\n    vector<long long> factorial_inverse; // 階乗の逆元\n\n    FactorialMod(int _max_num, int _mod) {\n        max_num = _max_num;\n        mod = _mod;\n        inverse = vector<long long>(max_num + 1);\n        factorial = vector<long long>(max_num + 1);\n        factorial_inverse = vector<long long>(max_num + 1);\n        calc_inverse();\n        calc_factorial_inverse();\n    }\n\n    // nCk を mod で割った余りを計算\n    long long combination_mod(int n, int k) {\n        if (n < 0 || k < 0 || n > max_num || k > max_num || k > n) return 0;\n        return (((factorial[n] * factorial_inverse[k]) % mod) * factorial_inverse[n - k]) % mod;\n    }\n\n    // nHk を mod で割った余りを計算\n    long long multi_choose_mod(int n, int k) {\n        return combination_mod(n + k - 1, k);\n    }\n};\n\nconst int MOD = 1000000007;\n\nint main(void) {\n    int n, k;\n    cin >> n >> k;\n    FactorialMod factorial_mod(1999, MOD);\n    cout << factorial_mod.multi_choose_mod(k, n) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define VSORT(v) sort(v.begin(), v.end())\n#define VRSORT(v) sort(v.rbegin(), v.rend())\n#define ll long long\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<int, P> PP;\ntypedef pair<ll, LP> LPP;\n//typedef vector<unsigned int>vec;\n//typedef vector<ll>vec;\n//typedef vector<vec> mat;\ntypedef vector<vector<int>> Graph;\n\n//const int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n//const int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\n\nconst int MAX = 1110000;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid comb_init() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long comb(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll mod_pow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, k;\n    cin >> n >> k;\n    comb_init();\n\n    cout << comb(n+k-1, n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \nll m=1e9+7;\nll dp[2002][1002];\n\n\nll dfs(ll a,ll b){\n  dp[0][0]=1;\n  if(dp[a][b])return dp[a][b];\n  ll res=0;\n  if(a)res+=dfs(a-1,b);\n  if(a&&b)res+=dfs(a-1,b-1);\n  res%=m;\n  return dp[a][b]=res;\n}\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  cout<<dfs(n+k-1,k-1)<<endl;\n  return 0;\n}\n\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 2000\n\nll N,K;\nll nCm[NUM][NUM];\n\nint main(){\n\n\tscanf(\"%lld %lld\",&N,&K);\n\n\t//コンビネーションを求める\n\tnCm[0][0] = 1;\n\tfor(ll n = 1; n <= N+K-1; n++) {\n\t\tfor (int m = 0; m <= N; m++) {\n\t\t\tif(m > 0){\n\t\t\t\tnCm[n][m] = nCm[n-1][m]+nCm[n-1][m-1];\n\t\t\t}else{ //m == 0\n\t\t\t\tnCm[n][m] = 1;\n\t\t\t}\n\t\t\tnCm[n][m] %= MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",nCm[N+K-1][N]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\n\nll mod = 1e9+7;  // 1e9+9\n\nll add(ll x,ll y){return (x+y)%mod;}\nll mul(ll x,ll y){return (x*y)%mod;}\n\nll mpow(ll x,ll y){\n  ll v=1;\n  for(;y;x=mul(x,x),y>>=1)\n    if(y&1)v=mul(v,x);\n  return v;\n}\n\nll ncr[5000][5000];\n\nll nCr(ll n,ll r){\n  if(n==r)return 1;\n  if(r==0)return 1;\n  if(ncr[n][r])return ncr[n][r];\n  ncr[n][r]=(nCr(n-1,r-1)+nCr(n-1,r))%mod;\n  return ncr[n][r];\n}\n\nll nHr(ll n,ll r){\n  return nCr( n+r-1 , n );\n}\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  cout<<nHr(n,k)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define NEXTP(x) next_permutation(x.begin(),x.end())\n#define FOR(I,A,B) for(ll I = (A); I < (B); ++I)\n#define FORR(I,A,B) for(ll I = (B-1); I >= (A); --I)\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\nclass comb{\n\tvector<ll> f,fr;\n\tll MOD;\n\tpublic:\n\t//a^(p-1) = 1 (mod p)(p->Prime numbers)\n\t//a^(p-2) = a^(-1)\n\tll calc(ll a,ll b,ll p){//a^(b) mod p   \n\t\tif(b==0)return 1;\n\t\tll y = calc(a,b/2,p);y=(y*y)%p;\n\t\tif(b & 1) y = (y * a) % p;\n\t\treturn y;\n\t}\n\tvoid init(ll n,ll mod){//input max_n\n\t\tMOD = mod;\n\t\tf.resize(n+1);\n\t\tfr.resize(n+1);\n\t\tf[0]=fr[0]=1;\n\t\tfor(ll i=1;i<n+1;i++){\n\t\t\tf[i] = (f[i-1] * i) % mod;\n\t\t\tfr[i] = calc(f[i],mod-2,mod);\n\t\t}\n\t}\n\tll nCr(ll n,ll r){\n\t\treturn f[n] * fr[r] % MOD * fr[n-r] % MOD;\n\t}\n};\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tll n,k;\n\tll ans = 0;\n\tcin >> n >> k;\n\tcomb co;\n\tco.init(n+k-1,MOD);\n\tcout << co.nCr(n+k-1,k-1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v, x) (std::find(v.begin(), v.end(), x) != v.end())\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nconst int INF = 1e9;\nconst long long INFLL = 1LL<<60;\n\nconst int mod = 1000000007;\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const {\n    return pow(mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n};\n\nstruct combination {\n  vector<mint> fact, ifact;  // 階乗と階乗の逆元\n  combination(int n):fact(n+1),ifact(n+1) {  // 階乗と階乗の逆元を n まで求める\n    assert(n < mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  ll n, k;\n  cin >> n >> k;\n\n  combination comb(n+k-1);\n  mint ans = comb(n+k-1, n);\n\n  cout << ans.x << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\nconst ll MOD = 1000000007LL;\n\ntemplate <ll mod> class ModInt {\n    ll a;\npublic:\n    constexpr ModInt(const ll a = 0) noexcept : a((a % mod + mod) % mod) {}\n    constexpr ll &value() noexcept { return a; }\n    constexpr ModInt operator + (const ModInt &rhs) const noexcept { return ModInt(*this) += rhs; }\n    constexpr ModInt operator - (const ModInt &rhs) const noexcept { return ModInt(*this) -= rhs; }\n    constexpr ModInt operator * (const ModInt &rhs) const noexcept { return ModInt(*this) *= rhs; }\n    constexpr ModInt operator / (const ModInt &rhs) const noexcept { return ModInt(*this) /= rhs; }\n    constexpr ModInt &operator += (const ModInt &rhs) noexcept {\n        a += rhs.a;\n        if (a >= mod) a -= mod;\n        return *this;\n    }\n    constexpr ModInt &operator -= (const ModInt &rhs) noexcept {\n        a += mod - rhs.a;\n        if (a >= mod) a -= mod;\n        return *this;\n    }\n    constexpr ModInt &operator *= (const ModInt &rhs) noexcept {\n        a = a * rhs.a % mod;\n        return *this;\n    }\n    constexpr ModInt pow(ll t) const noexcept {\n        if (t == 0) return 1;\n        auto ret = pow(t >> 1);\n        ret *= ret;\n        if (t & 1) ret *= *this;\n        return ret;\n    }\n    constexpr ModInt inv() const noexcept { return pow(mod - 2); }\n    constexpr ModInt operator /=(const ModInt &rhs) { return (*this) *= rhs.inv(); }\n    constexpr bool operator == (const ModInt &rhs) const noexcept { return this->a == rhs.a; }\n    constexpr bool operator != (const ModInt &rhs) const noexcept { return this->a != rhs.a; }\n    friend constexpr ostream &operator << (ostream &os, const ModInt &rhs) noexcept { return os << rhs.a; }\n    friend constexpr istream &operator >> (istream &is, ModInt &rhs) {\n        is >> rhs.a;\n        return is;\n    }\n};\nusing mint = ModInt<MOD>;\n\nclass Combination {\npublic:\n    vector <mint> fac, inv, fiv;\n    Combination(int N) : fac(N + 1), inv(N + 1), fiv(N + 1) {\n        fac[0] = inv[0] = fiv[0] = fac[1] = inv[1] = fiv[1] = 1;\n        for (ll i = 2; i <= N; i++) {\n            fac[i] = fac[i - 1] * i; // n!\n            inv[i] = inv[MOD % i] * (MOD - MOD / i); // n^-1\n            fiv[i] = fiv[i - 1] * inv[i]; // (n!)^-1\n        }\n    }\n    mint C(ll n, ll k) {\n        if (k < 0 || n < k) return 0;\n        return fac[n] * fiv[k] * fiv[n - k];\n    }\n    mint P(ll n, ll k) {\n        if (k < 0 || n < k) return 0;\n        return fac[n] * fiv[n - k];\n    }\n    mint H(ll n, ll k) {\n        if (n == 0 && k == 0) return 1;\n        return C(n + k - 1, k - 1);\n    }\n};\n\nint main() {\n    ll n, k;\n    cin >> n >> k;\n    Combination com(2005);\n    cout << com.C(n + k - 1, n) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool bit(const T n,const U k){return (n>>k)&1;}\n\n//デバッグ\ntemplate<class T>\nvoid Vout(vector<T> &V){\n    cout<<\"start\"<<endl;\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i]<<'\\n';\n    }\n    cout<<\"end\"<<endl;\n}\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr int MOD=1e9+7;\n//__builtin_popcount(S);\n//#define int ll\n\n\nstruct ModInt{\n    ll a;\n    constexpr ModInt() :a(0){}\n    constexpr ModInt(ll x) :a((x>=0)?(x%MOD):(x%MOD+MOD) ) {}\n\n    constexpr ModInt operator+(const ModInt rhs)const noexcept{\n        return ModInt(*this)+=rhs;\n    }\n    constexpr ModInt operator-(const ModInt rhs)const noexcept{\n        return ModInt(*this)-=rhs;\n    }\n    constexpr ModInt operator*(const ModInt rhs)const noexcept{\n        return ModInt(*this)*=rhs;\n    }\n    constexpr ModInt operator/(const ModInt rhs)const noexcept{\n        return ModInt(*this)/=rhs;\n    }\n    constexpr ModInt operator+(const ll rhs) const noexcept{\n        return ModInt(*this)+=rhs;\n    }\n    constexpr ModInt operator-(const ll rhs)const noexcept{\n        return ModInt(*this)-=rhs;\n    }\n    constexpr ModInt operator*(const ll rhs)const noexcept{\n        return ModInt(*this)*=rhs;\n    }\n    constexpr ModInt operator/(const ll rhs)const noexcept{\n        return ModInt(*this)/=rhs;\n    }\n\n    constexpr ModInt &operator+=(const ModInt rhs)noexcept{\n        a+=rhs.a;\n        if(a>=MOD) a-=MOD;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt rhs)noexcept{\n        a-=rhs.a;\n        if(a<0) a+=MOD;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt rhs)noexcept{\n        a=(a*rhs.a)%MOD;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ModInt rhs)noexcept{\n        a=(a*rhs.inverse().a)%MOD;\n        return *this;\n    }\n    constexpr ModInt &operator+=(const ll rhs)noexcept{\n        a+=rhs;\n        if(a>=MOD) a-=MOD;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ll rhs)noexcept{\n        a-=rhs;\n        if(a<0) a+=MOD;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ll rhs)noexcept{\n        a=(a*rhs)%MOD;\n        return *this;\n    }\n    constexpr ModInt &operator/=(ll rhs)noexcept{\n        a=(a*ModInt(rhs).inverse().a)%MOD;\n        return *this;\n    }\n\n    constexpr ModInt operator=(ll x)noexcept{\n        x%=MOD;\n        if(x<0) x+=MOD;\n        a=x;\n        return *this;\n    }\n\n    constexpr bool operator==(const ModInt p)const noexcept{\n        return a==p.a;\n    }\n\n    constexpr bool operator!=(const ModInt p)const noexcept{\n        return a!=p.a;\n    }\n\n    constexpr ModInt pow(ll N) const noexcept{\n        ModInt ans(1LL),p(a);\n        while(N>0){\n            if(bit(N,0)){\n                ans*=p;\n            }\n            p*=p;\n            N>>=1;\n        }\n        return ans;\n    }\n    constexpr ModInt inverse() const noexcept{\n        return pow(MOD-2);\n    }\n\n};\ninline constexpr ModInt operator+(const ll &a,const ModInt &b)noexcept{\n    return ModInt(a)+=b;\n}\ninline constexpr ModInt operator-(const ll &a,const ModInt &b)noexcept{\n    return ModInt(a)-=b;\n}\ninline constexpr ModInt operator*(const ll &a,const ModInt &b)noexcept{\n    return ModInt(a)*=b;\n}\ninline constexpr ModInt operator/(const ll &a,const ModInt &b)noexcept{\n    return ModInt(a)/=b;\n}\n\n\nconstexpr ModInt Mr(ll p){\n    p%=MOD;\n    if(p<0) p+=MOD;\n    return ModInt(p);\n}\n\nstruct Binominal{\n    vector<ModInt> fac,finv,inv; //fac[n]:n! finv:(n!)の逆元\n\n    Binominal(int n){\n        fac.resize(n+1,1);\n        finv.resize(n+1,1);\n        inv.resize(n+1,1);\n        for(int i=2;i<=n;i++){\n            fac[i]=fac[i-1]*i;\n            inv[i]=MOD-inv[MOD%i]*(MOD/i);\n            finv[i]=finv[i-1]*inv[i];\n        }\n    }\n    //nCk(n,k<=N) をO(1)で求める\n    ModInt com(int n,int k){\n        if(n<k) return ModInt(0);\n        if(n<0 || k<0) return ModInt(0);\n        return fac[n]*finv[k]*finv[n-k];\n    }\n    //nCk(k<=N) をO(k)　で求める \n    ModInt rcom(ll n,int k){\n        if(n<k) return ModInt(0);\n        if(n<0 || k<0) return ModInt(0);\n        ModInt ret(1);\n        for(int i=0;i<k;i++){\n            ret*=(n-i);\n        }\n        ret*=finv[k];\n        return ret;\n    }\n\n    //重複組み合わせ n種類のものから重複を許してk個を選ぶ\n    //〇がn個,|がk個\n    ModInt h(int n,int k){\n        return com(n+k-1,k);\n    }\n};\n\nsigned main(void){\n    int n,k;\n    cin>>n>>k;\n\n    Binominal b(2100);\n    cout<<b.h(k,n).a<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\ntypedef long long int ll;\nconst int MOD=1e9+7;\nconst int N=2e3+10;\nll fac[N];\nll pow(ll a,ll t){\n    if(t==0)return 1;\n    ll temp=pow(a,t/2);\n    temp*=temp;\n    temp%=MOD;\n    if(t&1){\n        temp*=a;\n        temp%=MOD;\n    }\n    return temp;\n}\nll rev(ll n){return pow(n,MOD-2);}\nll C(int n,int k){return (fac[n]*((rev(fac[k])*rev(fac[n-k]))%MOD))%MOD;}\nll H(int n,int k){return C(n+k-1,k);}\nvoid init(){\n    fac[0]=fac[1]=1;\n    for(int i=2;i<N;i++)fac[i]=(fac[i-1]*i)%MOD;\n    return ;\n}\nint main(){\n    int n,k,now=1;\n    ll ans=0;\n    scanf(\"%d%d\",&n,&k);\n    init();\n    printf(\"%lld\\n\",H(k,n));\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define rep(i,a,b) for(int i=a;i<(b);++i)\ntemplate<class T> inline bool chmin(T &a, T b){ if(a > b) { a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T &a, T b){ if(a < b) { a = b; return true;} return false;}\nusing ll = long long;\nconstexpr long long INF = 1LL << 62;\nconstexpr int MOD = 1e9 + 7;\n\nconstexpr int MAX = 2001;\nlong long fac[MAX], inv[MAX], finv[MAX];\nvoid CombInit(){\n    fac[0] = inv[0] = finv[0] = 1;\n    fac[1] = inv[1] = finv[1] = 1;\n    for(int i=2; i<MAX; ++i){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\n\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int n, k; cin >> n >> k;\n    CombInit();\n\n    cout << fac[n+k-1] * finv[k-1]%MOD * finv[n]%MOD << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(i, n) for(int i=0; i<=n; i++)\n#define repr(i, n) for(int i=n; i>0; i--)\n#define REPR(i, n) for(int i=n; i>=0; i--)\n#define FOR(i, a, b) for(int i=a; i<b; i++)\n#define ALL(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LLINF = 1e18;\nconst ll MOD = 1e9+7;\ntemplate<class T> void puts(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst int NMAX = 2005;\nll dp[NMAX][NMAX]; // = nCk\n\nint main() {\n    int n, k; cin >> n >> k;\n\n    rep(i, NMAX) dp[i][0] = dp[i][i] = 1;\n    for (int i = 2; i < NMAX; i++) {\n        for (int j = 1; j <= i-1; j++) {\n            dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n            // cout << dp[i][j] << endl;\n            dp[i][j] %= MOD;\n        }\n    }\n    cout << dp[n+k-1][k-1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\nstruct mint {\n    ll x; // typedef long long ll;\n    mint(ll x = 0) : x((x % mod + mod) % mod) {}\n\n    mint &operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator-=(const mint a) {\n        if ((x += mod - a.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    mint &operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res += a;\n    }\n\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res -= a;\n    }\n\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res *= a;\n    }\n\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t >> 1);\n        a *= a;\n        if (t & 1) a *= *this;\n        return a;\n    }\n\n    // for prime mod\n    mint inv() const {\n        return pow(mod - 2);\n    }\n\n    mint &operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res /= a;\n    }\n};\n\nstruct combination {\n    vector<mint> fact, ifact;\n\n    combination(int n) : fact(n + 1), ifact(n + 1) {\n        assert(n < mod);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;\n    }\n\n    mint operator()(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n\n    mint nPk(int n, int k) {\n        if (n < k) return 0;\n        if (n < 0 || k < 0) return 0;\n        return fact[n] * ifact[n - k];\n    }\n\n} combination(10000);\n\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n\n    mint ans = combination(n + k - 1, n);\n\n    cout << ans.x << endl;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * aoj/dpl_5_d/main.cpp\n */\n\n// C++ 14\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstring> // memset\n#include <cassert>\nusing namespace std;\n#define ll long long\n#define loop(__x, __start, __end) for(int __x = __start; __x < __end; __x++)\ntemplate <class T> ostream & operator << (ostream & out, vector<T> const & v) {\n  for (auto &&a: v) out << a << \" \"; out << endl; return out;\n}\ntemplate <class T> void dump(T &a) { cout << a << endl; }\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) {a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) {a = b; return true; } return false; }\n\n/* Mod */\n#define MOD 1000000007\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%MOD+MOD)%MOD){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%MOD+MOD)%MOD; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n  mint& operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nostream & operator << (ostream & out, mint const & v) {\n  out << v.x;\n  return out;\n}\n\n/* nCk */\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n// n+k-1Cn\nint N, K;\nvoid solve() {\n  cin >> N >> K;\n  BiCoef<mint> bc;\n  bc.init(2001);\n  cout << bc.com(N+K-1, N) << endl;\n}\nint main() {\n  // cout.precision(15); cout << fixed;\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#if __has_include(<boost/multiprecision/cpp_int.hpp>)\n\t#include <boost/multiprecision/cpp_int.hpp>\n\t#include <boost/multiprecision/cpp_dec_float.hpp>\n\tusing bll = boost::multiprecision::cpp_int;\n\tusing bdouble = boost::multiprecision::cpp_dec_float_100;\n\tusing namespace boost::multiprecision;\n#endif\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::reverse_iterator first, const typename std::vector<T>::reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_iterator first, const typename std::vector<T>::const_iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const typename std::vector<T>::const_reverse_iterator first, const typename std::vector<T>::const_reverse_iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\t\t\n\t\tdbool(const dbool&) = default;\n\t\tdbool(dbool&&) = default;\n\t\tdbool& operator=(const dbool&) = default;\n\t\tdbool& operator=(dbool&&) = default;\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\\\\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::deque<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception(); }\n\tvoid catch_SIGSEGV([[maybe_unused]] int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\ninline constexpr ll extgcd(ll a, ll b, ll &x, ll &y){ ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\ninline constexpr ll invmod(ll a, ll m = MOD){ ll x = 0, y = 0; extgcd(a, m, x, y); return (x + m) % m; }\nclass Modint{\npublic:\n\tll _num;\n\tconstexpr Modint() : _num() { _num = 0; }\n\tconstexpr Modint(ll x) : _num() { _num = x % MOD; if(_num < 0) _num += MOD; }\n\tinline constexpr Modint operator= (int x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\tinline constexpr Modint operator= (ll x){ _num = x % MOD; if(_num<0) _num += MOD; return *this; }\n\t//inline constexpr Modint operator= (Modint x){ _num = x._num; return *this; }\n\tinline constexpr Modint operator+ (int x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (ll x){ return Modint(_num + x); }\n\tinline constexpr Modint operator+ (Modint x){ ll a = _num + x._num; if(a >= MOD) a -= MOD; return Modint{a}; }\n\tinline constexpr Modint operator+=(int x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(ll x){ _num += x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator+=(Modint x){ _num += x._num; if(_num >= MOD) _num -= MOD; return *this; }\n\tinline constexpr Modint operator++(){ _num++; if(_num == MOD) _num = 0; return *this; }\n\tinline constexpr Modint operator- (int x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (ll x){ return Modint(_num - x); }\n\tinline constexpr Modint operator- (Modint x){ ll a = _num - x._num; if(a < 0) a += MOD; return Modint{a}; }\n\tinline constexpr Modint operator-=(int x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(ll x){ _num -= x; _num %= MOD; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator-=(Modint x){ _num -= x._num; if(_num < 0) _num += MOD; return *this; }\n\tinline constexpr Modint operator--(){ _num--; if(_num == -1) _num = MOD - 1; return *this; }\n\tinline constexpr Modint operator* (int x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (ll x){ return Modint(_num * (x % MOD)); }\n\tinline constexpr Modint operator* (Modint x){ return Modint{_num * x._num % MOD}; }\n\tinline constexpr Modint operator*=(int x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(ll x){ _num *= Modint(x); _num %= MOD; return *this; }\n\tinline constexpr Modint operator*=(Modint x){ _num *= x._num; _num %= MOD; return *this; }\n\tinline constexpr Modint operator/ (int x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (ll x){ return Modint(_num * invmod(Modint(x), MOD)); }\n\tinline constexpr Modint operator/ (Modint x){ return Modint{_num * invmod(x._num, MOD) % MOD}; }\n\tinline constexpr Modint operator/=(int x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(ll x){ _num *= invmod(Modint(x), MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint operator/=(Modint x){ _num *= invmod(x._num, MOD); _num %= MOD; return *this; }\n\tinline constexpr Modint pow(ll n){ ll i = 1, x = n>=0 ? n : -n; Modint ans = 1, cnt = n>=0 ? *this : Modint(1) / *this; while(i <= x){ if(x & i){ ans *= cnt; x ^= i; } cnt *= cnt; i *= 2; } return ans; }\n\tinline constexpr operator ll() const { return _num; }\n};\ninline std::istream& operator>>(std::istream &s, Modint &x){ ll t; s>>t; x=t; return s; }\nvector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(size_t a){\n\tif(fac.size() >= a) return;\n\tif(a < fac.size() * 2) a = fac.size() * 2;\n\tif(a >= MOD) a = MOD;\n\twhile(fac.size() < a) fac.push_back(fac.back() * ll(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = Modint(1) / fac.back();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint factorial(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint nPk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); for(ll i=n;i>(n-k);i--)val*=i; return val; }\ninline Modint nCk_loop(ll n, ll k){ if(n<k) return 0; Modint val(1); k=min(k,n-k); for(ll i=n;i>(n-k);i--)val*=i; for(ll i=k;i>1;i--)val/=i; return val; };\ninline Modint nPk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nPk_loop(n, k); reserve(n + 1); return fac[n] * inv[n - k]; }\ninline Modint nCk(ll n, ll k){ if(k < 0 || n < k) return 0; if(n>=(ll)1e7) return nCk_loop(n, k); reserve(n + 1); return fac[n] * inv[k] * inv[n - k]; }\ninline Modint nHk(ll n, ll k){ return nCk(n + k - 1, k); } //n種類のものから重複を許してk個選ぶ=玉k個と仕切りn-1個\n\n/*\nnCk：n!が間に合わないくらい巨大でkが小さいとき、素直に計算すると間に合う のは1e7以上に組み込んであります\n\tauto f = [](ll n, ll k){\n\t\tif(n<k)return Modint(0);\n\t\tModint val(1);\n\t\tk=min(k,n-k);\n\t\tfor(ll i=n;i>(n-k);i--)val*=i;\n\t\tfor(ll i=k;i>1;i--)val/=i;\n\t\treturn val;\n\t};\n*/\n\n////\n\nModint ball1box1(ll N,ll K){\n\treturn Modint(K).pow(N);\n}\nModint ball1box1injection(ll N,ll K){\n\treturn nPk(K,N);\n}\nModint ball1box1surjection(ll N,ll K){\n\tModint ans=0;\n\tfor(ll i=0; i<=K; i++){\n\t\tModint t=nCk(K,i)*Modint(i).pow(N);\n\t\tif((K-i)%2==0)ans+=t;\n\t\telse ans-=t;\n\t}\n\treturn ans;\n}\nModint ball0box1(ll N,ll K){\n\treturn nCk(N+K-1,N);\n}\n\n/*-----8<-----library-----8<-----*/\n \nvoid solve() {\n\t//N個のボール K個の箱\n\tll N,K;\n\tcin>>N>>K;\n\tModint ans;\n\t//ボール区別あり 箱区別あり 制限なし\n\t//ans=ball1box1(N,K);\n\t//ボール区別あり 箱区別あり 箱の中身は1つ以下\n\t//ans=ball1box1injection(N,K);\n\t//ボール区別あり 箱区別あり 箱の中身は1つ以上\n\t//ans=ball1box1surjection(N,K);\n\t//ボール区別あり 箱区別あり 制限なし\n\tans=ball0box1(N,K);\n\t//ボール区別なし 箱区別あり 箱の中身は1つ以下\n\n\t//ボール区別なし 箱区別あり 箱の中身は1つ以上\n\n\t//ボール区別なし 箱区別あり 制限なし\n\n\t//ボール区別なし 箱区別あり 箱の中身は1つ以下\n\n\t//ボール区別あり 箱区別なし 箱の中身は1つ以上\n\n\t//ボール区別あり 箱区別なし 制限なし\n\n\t//ボール区別あり 箱区別なし 箱の中身は1つ以下\n\n\t//ボール区別あり 箱区別なし 箱の中身は1つ以上\n\n\t//ボール区別なし 箱区別なし 制限なし\n\n\t//ボール区別なし 箱区別なし 箱の中身は1つ以下\n\n\t//ボール区別なし 箱区別なし 箱の中身は1つ以上\n\n\tp(ans);\n}\n\n//http://judge.u-aizu.ac.jp/onlinejudge/finder.jsp?course=DPL\n//https://qiita.com/drken/items/f2ea4b58b0d21621bd51\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\n\ntemplate <class T> inline T chmax(T &a, const T b) {return a = (a < b) ? b : a;}\ntemplate <class T> inline T chmin(T &a, const T b) {return a = (a > b) ? b : a;}\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int inf = 1e9;\nconstexpr long long INF = 1e18;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nll modpow(ll a, ll b){\n    if(b == 0) return 1;\n    else if(b % 2 == 0){\n        ll d = modpow(a, b / 2) % MOD;\n        return (d * d) % MOD;\n    }\n    else{\n        return (a * modpow(a, b - 1)) % MOD;\n    }\n}\n\nconst int MAX_N = 2010;\n\nll fact[MAX_N], finv[MAX_N];\nll comb(int n, int r){\n    if(n < r || r < 0) return 0;\n    return fact[n] * finv[n-r] % MOD * finv[r] % MOD;\n}\n\nvoid calc(int n){\n    fact[0] = finv[0] = 1;\n    for(int i=1; i<=n; i++){\n        fact[i] = (fact[i-1] * i) % MOD;\n        finv[i] = modpow(fact[i], MOD - 2);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, k; cin>>n>>k;\n    calc(2005);\n\n    cout << comb(n + k - 1, k - 1) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {0,1,0,-1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nvector<ll> fac(MAX), finv(MAX), inv(MAX);\n\nvoid comInit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(ll i=2; i<MAX; i++){\n        fac[i] = fac[i-1]*i % mod;\n        inv[i] = mod - inv[mod%i] * (mod/i) % mod;\n        finv[i] = finv[i-1] * inv[i] % mod;\n    }\n}\n\n\nll com(ll n, ll k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nll modpow(ll x, ll n, ll mod){\n    ll res = 1;\n    while(n > 0){\n        if(n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\n\nint main(){\n    ll n,k; cin >> n >> k;\n    comInit();\n    cout << com(n+k-1,n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long int ll;\nconst ll MOD=1000000007;\n\nll n,k;\nll C[2001][2001]={};\n\nint main(){\n\tscanf(\"%lld %lld\",&n,&k);\n\tfor(int i=0;i<2001;i++){\n\t\tC[i][0]=1;\n\t\tC[i][i]=1;\n\t\tfor(int j=1;j<i;j++){\n\t\t\tC[i][j]=(C[i-1][j-1]+C[i-1][j])%MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",C[n+k-1][n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nconst ULL M = 1000000007;\n\nULL powm(ULL a, ULL i) {\n    if (!i) return 1;\n    if (i & 1) return powm(a * a % M, i >> 1) * a % M;\n    return powm(a * a % M, i >> 1);\n}\n\nULL F[10001], I[10001], iF[10001];\n\nULL C(ULL n, ULL r) { return F[n] * iF[r] % M * iF[n - r] % M; }\nULL P(ULL n, ULL r) { return F[n] * iF[n - r] % M; }\nULL H(ULL n, ULL r) { return C(r + n - 1, n - 1); }\n\nstruct Problem {\n\n    void Solve() {\n        F[0] = 1; for (UL i = 1; i <= 10000; i++) F[i] = F[i - 1] * i % M;\n        I[1] = 1; for (UL i = 2; i <= 10000; i++) I[i] = M - M / i * I[M % i] % M;\n        iF[0] = 1; for (UL i = 1; i <= 10000; i++) iF[i] = iF[i - 1] * I[i] % M;\n        ULL N, K; cin >> N >> K;\n        cout << H(K, N) << endl;\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    p->Solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n\n// modint\n// 1000000007 で割ったあまりに関する四則演算を直感的に行える\ntemplate<int MODULO> struct Fp {\n    long long val;\n\n    constexpr Fp(long long v = 0) noexcept : val(v % MODULO) {\n        if (val < 0) v += MODULO;\n    }\n    constexpr Fp operator - () const noexcept {\n        return val ? MODULO - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MODULO) val -= MODULO;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MODULO;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MODULO;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MODULO, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MODULO;\n        if (val < 0) val += MODULO;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n};\n\ntemplate<int MODULO> constexpr ostream& operator <<\n(ostream &os, const Fp<MODULO>& x) noexcept {\n    return os << x.val;\n}\ntemplate<int MODULO> constexpr istream& operator >>\n(istream &is, Fp<MODULO>& x) noexcept {\n    return is >> x.val;\n}\n\ntemplate<int MODULO> constexpr Fp<MODULO> modpow\n(const Fp<MODULO> &a, long long n) noexcept {\n    if (n == 0) return 1;\n    auto t = modpow(a, n / 2);\n    t = t * t;\n    if (n & 1) t = t * a;\n    return t;\n}\n\n\n// 二項係数ライブラリ\ntemplate<int MODULO> struct BiCoef {\n    vector<Fp<MODULO> > fac, inv, finv;\n    constexpr BiCoef(int n) noexcept : fac(n, 1), inv(n, 1), finv(n, 1) {\n        for(int i = 2; i < n; i++){\n            fac[i] = fac[i-1] * i;\n            inv[i] = -inv[MODULO%i] * (MODULO/i);\n            finv[i] = finv[i-1] * inv[i];\n        }\n    }\n    constexpr Fp<MODULO> com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fac[n] * finv[k] * finv[n-k];\n    }\n};\n\n\n\n// ここから解答\nconst int MAX = 201010;\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>; // mod 計算を直感的に\n\nint main() {\n    BiCoef<MOD> bc(MAX); // 二項係数計算の前処理\n\n    long long N, K;\n    cin >> N >> K;\n    cout << bc.com(N+K-1, N) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nstruct Combination\n{\n  int mod;\n  vector<int> mfact;\n  vector<int> rfact;\n\n  /*\n    constructor : O(sz+log(mod))    \n   */\n  Combination(int sz, int mod) : mfact(sz+1), rfact(sz+1), mod(mod) {\n    mfact[0] = 1;\n    for ( int i = 1; i < (int)mfact.size(); i++ ) {\n      mfact[i] = mfact[i-1]*i % mod;\n    }\n    rfact[sz] = inv(mfact[sz]);\n    for ( int i = sz-1; i >= 0; i-- ) {\n      rfact[i] = rfact[i+1]*(i+1) % mod;\n    }\n  }\n\n  int fact(int k) const {\n    return (mfact[k]);\n  }\n\n  int pow(int x, int n) const {\n    int ret = 1;\n    while ( n > 0 ) {\n      if ( n & 1 ) (ret *= x) %= mod;\n      (x *= x) %= mod;\n      n >>= 1;\n    }\n    return (ret);\n  }\n\n  int inv(int x) const {\n    return (pow(x, mod - 2));\n  }\n\n  /*\n    permutation\n   */\n  int P(int n, int r) const {\n    if ( r < 0 || n < r ) return (0);\n    return (mfact[n]*rfact[n-r] % mod);\n  }\n\n  /*\n    combination\n   */\n  int C(int n, int r) const {\n    if ( r < 0 || n < r ) return (0);    \n    return (mfact[n]*rfact[r]%mod * rfact[n-r] % mod);    \n  }  \n\n  /*\n    combination with repetition\n   */\n  int H(int n, int r) const {\n    if ( n < 0 || r < 0 ) return 0;\n    if ( n == 0 && r == 0 ) return 1;\n    return C(n+r-1, n);    \n  }\n\n  /*\n    stirling number\n   */\n  int S(int n, int r) const {\n    int ret;\n    for ( int i = 1; i <= r; i++ ) {\n      \n    }\n  }\n\n  /*\n    bell number\n   */\n  int B(int n, int r) const {\n\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, k;\n  cin >> n >> k;\n\n  int MOD = 1e9+7;  \n  Combination c(2000, MOD);\n  cout << c.C(n+k-1, n) << endl;  \n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long int ll;\nstatic const ll MOD = 1000000007;\n\nll mod_pow(ll n, ll x){\n\tif(n == 0) return 1;\n\tll ret = mod_pow(n / 2, x * x % MOD) % MOD;\n\tif(n % 2) return ret * x % MOD;\n\treturn ret;\n}\n\nll comb(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\tvector<ll> memo(n + 1);\n\tmemo[0] = 1; memo[1] = 1;\n\tfor(int i = 2; i <= n; i++){\n\t\tmemo[i] = memo[i - 1] * (ll)i;\n\t\tmemo[i] %= MOD;\n\t}\n\treturn ((memo[n] * mod_pow(MOD - 2, memo[k])) % MOD) * mod_pow(MOD - 2, memo[n - k]) % MOD;\n}\n\nint main(){\n\tint n, k;\n\tcin >> n >> k;\n\tcout << comb(n + k - 1, k - 1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define MOD 1000000007\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong pow(long a, long b) {\n\tif (b == 0) return 1;\n\tlong c = pow(a, b / 2);\n\tif (b % 2) c = a * c % MOD * c % MOD;\n\telse c = c * c % MOD;\n\treturn c;\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tvector<long> a(n + k, 1), b(n + k, 1);\n\tfor (int i = 1; i < n + k; i++) {\n\t\ta[i] = a[i - 1] * i % MOD;\n\t\tb[i] = pow(a[i], MOD - 2);\n\t}\n\tcout << a[n + k - 1] * b[n] % MOD * b[k - 1] % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// {{{ header\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\nconstexpr i64 INF = 1'010'000'000'000'000'000LL;\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// {{{ util\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(begin(cccc), end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? begin(cccc)+llll : end(cccc);\\\n    auto jjjj = llll <= rrrr ? begin(cccc)+rrrr : end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(forward<decltype(args)>(args)...); })\n\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    const F f_;\n};\n\ntemplate<typename F>\ndecltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\ntemplate<typename T>\nvoid FROM_STRING(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STRING(const T& x) {\n    ostringstream out;\n    out << x;\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    while(first != last) {\n        out << *first++;\n        if(first != last)\n            out << sep;\n    }\n    return out.str();\n}\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& out, const vector<T>& v) {\n    for(auto first = begin(v), it = first; it != end(v); ++it) {\n        if(it != first)\n            out << ' ';\n        out << *it;\n    }\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& out, const pair<T1,T2>& p) {\n    return out << '(' << p.first << ',' << p.second << ')';\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    cout << x;\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \" << value << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n// }}}\n\n// {{{ init\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n// {{{ num\n\n// 事前条件: a >= 0, b >= 0\ni64 gcd_impl(i64 a, i64 b) {\n    if(b == 0) return a;\n    return gcd_impl(b, a%b);\n}\n\n// gcd(0,0) = 0\ni64 gcd(i64 a, i64 b) {\n    return gcd_impl(abs(a), abs(b));\n}\n\n// lcm(0,x) は未定義\ni64 lcm(i64 a, i64 b) {\n    assert(a != 0 && b != 0);\n    a = abs(a);\n    b = abs(b);\n    return a / gcd_impl(a,b) * b;\n}\n\n// 事前条件: a >= 0, b >= 0\ni64 extgcd_impl(i64 a, i64 b, i64& x, i64& y) {\n    if(b == 0) {\n        x = 1; y = 0;\n        return a;\n    }\n    i64 g = extgcd_impl(b, a%b, y, x);\n    y -= a/b * x;\n    return g;\n}\n\n// g=gcd(a,b), および ax+by=g の整数解 (x0,y0) を求める\n// (g,x0,y0) を返す\n// g!=0 のとき、一般解は (x,y) = (x0+m*b/g, y0-m*a/g) で与えられる(mは整数)\ntuple<i64,i64,i64> extgcd(i64 a, i64 b) {\n    i64 x, y;\n    i64 g = extgcd_impl(abs(a), abs(b), x, y);\n    x *= sgn(a);\n    y *= sgn(b);\n    return make_tuple(g, x, y);\n}\n\n// 素因数分解\n// (素因数,指数) のリストを返す\n// n >= 1 でなければならない\n// n == 1 の場合、空リストを返す\nvector<pair<i64,i64>> factorize(i64 n) {\n    assert(n >= 1);\n\n    vector<pair<i64,i64>> res;\n\n    i64 m = n;\n    for(i64 i = 2; i*i <= n; ++i) {\n        if(m == 1) break;\n        i64 e = 0;\n        while(m % i == 0) {\n            ++e;\n            m /= i;\n        }\n        if(e) res.emplace_back(i, e);\n    }\n    if(m > 1) res.emplace_back(m, 1);\n\n    return res;\n}\n\n// 二分累乗\ntemplate<typename Monoid>\nMonoid pow_binary(Monoid x, i64 e) {\n    assert(e >= 0);\n\n    Monoid res(1);  // 行列などの場合はここを適当に変える\n    Monoid cur = x;\n    while(e > 0) {\n        if(e & 1)\n            res *= cur;\n        cur *= cur;\n        e >>= 1;\n    }\n    return res;\n}\n\n// mod m での a の逆元\n// a ⊥ m でなければならない\ni64 inv_mod(i64 a, i64 m) {\n    i64 g,x0; tie(g,x0,ignore) = extgcd(a, m);\n    assert(g == 1);\n    return modulo(x0, m);\n}\n\ntemplate<i64 P>\nstruct ModPT {\n    static_assert(P >= 2, \"P must be a prime\");\n    i64 v_;  // [0,P)\n\n    ModPT() : v_(0) {}\n    ModPT(i64 v) : v_(modulo(v,P)) {}\n\n    ModPT operator-() const {\n        return ModPT(-v_);\n    }\n    ModPT& operator+=(ModPT rhs) {\n        v_ += rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator-=(ModPT rhs) {\n        v_ += P;\n        v_ -= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator*=(ModPT rhs) {\n        v_ *= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n\n    ModPT inv() const {\n        return ModPT(inv_mod(v_,P));\n    }\n};\n\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) += lhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) -= lhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) *= lhs; }\n\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, ModPT<P> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, i64 rhs) { return lhs == ModPT<P>(rhs); }\ntemplate<i64 P>\nbool operator==(i64 lhs, ModPT<P> rhs) { return ModPT<P>(lhs) == rhs; }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, ModPT<P> rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(i64 lhs, ModPT<P> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 P>\nistream& operator>>(istream& in, ModPT<P>& x) {\n    return in >> x.v_;\n}\n\ntemplate<i64 P>\nostream& operator<<(ostream& out, ModPT<P> x) {\n    return out << x.v_;\n}\n\nusing ModP = ModPT<MOD>;\n\n// F(0) = 0\n// F(1) = 1\n// F(n) = F(n-1) + F(n-2)\n//\n// // decltype(auto) で受けると SIZE() が使える (auto だとポインタになってしまう)\n// decltype(auto) fib = fibonacci<1000>();\ntemplate<size_t N>\nModP (&fibonacci())[N] {\n    static_assert(N >= 2, \"\");\n    static ModP fib[N] {};\n\n    if(fib[1] != 1) {\n        fib[0] = 0;\n        fib[1] = 1;\n        FOR(i, 2, N) {\n            fib[i] = fib[i-1] + fib[i-2];\n        }\n    }\n    return fib;\n}\n\ntemplate<size_t N>\nModP (&factorial())[N] {\n    static_assert(N >= 1, \"\");\n    static ModP fac[N] {};\n\n    if(fac[0] != 1) {\n        fac[0] = 1;\n        FOR(i, 1, N) {\n            fac[i] = i * fac[i-1];\n        }\n    }\n    return fac;\n}\n\ntemplate<size_t N>\nModP (&ifactorial())[N] {\n    static_assert(N >= 1, \"\");\n    static ModP ifac[N] {};\n\n    if(ifac[0] != 1) {\n        decltype(auto) fac = factorial<N>();\n        ifac[N-1] = fac[N-1].inv();\n        for(i64 i = N-2; i >= 0; --i) {\n            ifac[i] = (i+1) * ifac[i+1];\n        }\n    }\n    return ifac;\n}\n\ntemplate<size_t N>\nModP permutation_count(i64 n, i64 r, const ModP (&fac)[N], const ModP (&ifac)[N]) {\n    if(n < r) return 0;\n    return fac[n] * ifac[n-r];\n}\n\ntemplate<size_t N>\nModP combination_count(i64 n, i64 r, const ModP (&fac)[N], const ModP (&ifac)[N]) {\n    if(n < r) return 0;\n    return fac[n] * ifac[r] * ifac[n-r];\n}\n\n// }}}\n\n//--------------------------------------------------------------------\n\n\n\nvoid solve() {\n    i64 N,K; RD(N); RD(K);\n\n    decltype(auto) fac = factorial<2000>();\n    decltype(auto) ifac = ifactorial<2000>();\n\n    ModP ans = combination_count(N+K-1, N, fac, ifac);\n\n    // * MOD はとった?\n    // * 違うやつ提出してない?\n    // * 違うやつテストしてない?\n    PRINTLN(ans);\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<long long, long long>;\nconst long long INF = 1001001001;\nconst long long MOD = 1000000007;\nconst double EPS = 1e-10;\nstruct Edge { int from, to; long long cost; };\nusing Graph = vector<vector<Edge>>;\n\nstruct Combination {\n    vector<long long> fac, inv, finv;\n    long long md = 0;\n    Combination(int n, long long m): fac(n + 1), inv(n + 1), finv(n + 1) {\n        md = m;\n        fac[0] = fac[1] = 1;\n        inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for(int i = 2; i <= n; i++) {\n            fac[i] = fac[i - 1] * i % md;\n            inv[i] = md - inv[md % i] * (md / i) % md;\n            finv[i] = finv[i - 1] * inv[i] % md;\n        }\n    }\n    long long P(int n, int r) {\n        if(r < 0 || n < r) return 0;\n        return fac[n] * finv[n - r] % md;\n    }\n    long long C(int n, int r) {\n        if(r < 0 || n < r) return 0;\n        return fac[n] * (finv[r] * finv[n - r] % md) % md;\n    }\n    long long H(int n, int r) {\n        if(n < 0 || r < 0) return 0;\n        return (r == 0 ? 1 : C(n + r - 1, r));\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,k;\n    cin>>n>>k;\n    Combination c(2020,MOD);\n    cout<<c.H(k,n)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\nconst int MAX = 2010;\nlong long inv[MAX];\nlong long fac[MAX];\nlong long finv[MAX];\n\nvoid init() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (long long i = 2; i < MAX; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 組み合わせ nCk = n! / (k! * (n - k)!)\nlong long nCk(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n - k] % MOD;\n}\n\n// 重複組み合わせ\nlong long nHk(int n, int k) {\n    if (n < 0 || k < 0) return 0;\n    return nCk(n + k - 1, k);\n}\n\nvoid _main() {\n    int n, k;\n    cin >> n >> k;\n    init();\n    cout << nHk(k, n) << endl;\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        freopen(\"input.txt\", \"r\", stdin);\n        freopen(\"output.txt\", \"w\", stdout);\n    }\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass Combination{\n\tvector<ll> fac,finv,inv;\npublic:\n\tCombination(ll N){\n\t\tfac.resize(N+1);\n\t\tfinv.resize(N+1);\n\t\tinv.resize(N+1);\n\t\tfac[0] = fac[1] = 1;\n\t\tfinv[0] = finv[1] = 1;\n\t\tinv[1] = 1;\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tfac[i] = fac[i-1] * i % atcoder_mod;\n\t\t\tinv[i] = atcoder_mod - inv[atcoder_mod%i] * (atcoder_mod/i) % atcoder_mod;\n\t\t\tfinv[i] = finv[i-1] * inv[i] % atcoder_mod;\n\t\t}\n\t}\n\tll Caluclation(ll n,ll r){\n\t\tif(n < r) return 0;\n\t\tif (n < 0 || r < 0) return 0;\n\t\treturn fac[n] * (finv[r] * finv[n-r] % atcoder_mod) % atcoder_mod;\n\t}\n\n};\nll BallBoxCombination4(ll n,ll k){\n\tCombination comb(n+k-1);\n\treturn comb.Caluclation(n+k-1,n);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tll N=in<ll>(),K=in<ll>();\n\t\n\tll ans = BallBoxCombination4(N,K);\n\tout(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n  \n  static Mint comb(long long n,int k){\n    Mint res(1);\n    for(int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n//BEGIN CUT HERE\ntemplate<typename M>\nstruct Enumeration{\n  static vector<M> fact,finv,invs;\n  \n  static void init(int n){\n    int m=fact.size();\n    if(n<m) return;\n    \n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n    \n    if(m==0) m=1;\n    for(int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n  \n  static M C(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(int n,int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n  \n  static M H(int n,int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static M S(int n,int k){\n    M res;\n    init(k);\n    for(int i=1;i<=k;i++){\n      M tmp=C(k,i)*M(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }    \n    return res*=finv[k];\n  }\n\n  static vector<vector<M> > D(int n,int m){\n    vector<vector<M> > dp(n+1,vector<M>(m+1,0));\n    dp[0][0]=M(1);\n    for(int i=0;i<=n;i++){\n      for(int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static M B(int n,int k){\n    if(n==0) return M(1);\n    k=min(k,n);\n    init(k);    \n    vector<M> dp(k+1);\n    dp[0]=M(1);\n    for(int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);    \n    M res;\n    for(int i=1;i<=k;i++)\n      res+=M(i).pow(n)*finv[i]*dp[k-i];    \n    return res;\n  }\n\n  static M montmort(int n){\n    M res;\n    init(n);\n    for(int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static M LagrangePolynomial(vector<M> &y,M t){\n    int n=y.size()-1;    \n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    M num(1);\n    for(int i=0;i<=n;i++) num*=t-M(i);\n    M res;\n    for(int i=0;i<=n;i++){\n      M tmp=y[i]*num/(t-M(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs = vector<M>();\n//END CUT HERE\n\ntemplate<typename T> \nmap<T, int> factorize(T x){\n  map<T, int> res;\n  for(int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n//INSERT ABOVE HERE\n\nsigned DPL_5_A(){\n  int n;\n  Mint<int> k;\n  scanf(\"%d %d\",&n,&k.v);\n  printf(\"%d\\n\",k.pow(n).v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_A&lang=jp\n*/\n\nsigned DPL_5_B(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::P(k,n).v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_B&lang=jp\n*/\n\nsigned DPL_5_C(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  Enumeration<Mint<int>>::init(k);  \n  printf(\"%d\\n\",(Enumeration<Mint<int>>::S(n,k)*Enumeration<Mint<int>>::fact[k]).v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_C&lang=jp\n*/\n\nsigned DPL_5_D(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::H(k,n).v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_D&lang=jp\n*/\n\nsigned DPL_5_E(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::C(k,n).v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_E&lang=jp\n*/\n\nsigned DPL_5_F(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::C(n-1,k-1).v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_F&lang=jp\n*/\n\nsigned DPL_5_G(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::B(n,k).v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_G&lang=jp\n*/\n\nsigned DPL_5_H(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",(n<=k));\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_H&lang=jp\n*/\n\nsigned DPL_5_I(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::S(n,k).v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_I&lang=jp\n*/\n\nsigned DPL_5_J(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",Enumeration<Mint<int>>::D(n,k)[n][k].v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_J&lang=jp\n*/\n\nsigned DPL_5_K(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",(n<=k));\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_K&lang=jp\n*/\n\nsigned DPL_5_L(){\n  int n,k;\n  scanf(\"%d %d\",&n,&k);\n  printf(\"%d\\n\",n>=k?Enumeration<Mint<int>>::D(n,k)[n-k][k].v:0);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_5_L&lang=jp\n*/\n\nsigned ABC110_D(){\n  int n;\n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  M m;\n  scanf(\"%d %d\",&n,&m.v);\n\n  E::init(n+100);\n  \n  Mint<int> ans(1);\n  auto x=factorize(m.v);\n  for(auto p:x) ans*=E::H(n,p.second);\n\n  printf(\"%d\\n\",ans.v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  https://beta.atcoder.jp/contests/abc110/tasks/abc110_d\n*/\n\n//montmort\nsigned ARC009_C(){\n  Int n,k;\n  scanf(\"%lld %lld\",&n,&k);\n  const int MOD = 1777777777;\n  using M = Mint<long long, MOD>;  \n  using E = Enumeration<M>;\n  M a=E::montmort(k)*M::comb(n,k);\n  printf(\"%lld\\n\",a.v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  https://beta.atcoder.jp/contests/arc009/tasks/arc009_3\n*/\n\nsigned ARC033_D(){\n  int n;\n  scanf(\"%d\",&n);\n  using M = Mint<int>;  \n  using E = Enumeration<M>;\n  vector<M> y(n+1);\n  for(Int i=0;i<=n;i++) scanf(\"%d\",&y[i].v);\n  int t;\n  scanf(\"%d\",&t);\n  printf(\"%d\\n\",(t<=n?y[t]:E::LagrangePolynomial(y,M(t))).v);\n  return 0;\n}\n/*\n  verified on 2018/09/24\n  https://beta.atcoder.jp/contests/arc033/tasks/arc033_4\n*/\n\nsigned YUKI_117(){\n  int T;\n  scanf(\"%d\\n\",&T);\n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  E::init(2e6+100);\n  while(T--){\n    char c;\n    int n,k;\n    scanf(\"%c(%d,%d)\\n\",&c,&n,&k);\n    if(c=='C') printf(\"%d\\n\",E::C(n,k).v);\n    if(c=='P') printf(\"%d\\n\",E::P(n,k).v);\n    if(c=='H') printf(\"%d\\n\",E::H(n,k).v);\n  }\n  return 0;\n}\n/*\n  verified on 2018/11/10\n  https://yukicoder.me/problems/no/117\n*/\n\nsigned YUKI_042(){\n  using M = Mint<int, int(1e9+9)>;  \n  using E = Enumeration<M>;\n  const int MAX = 666 * 6 + 10;\n  M dp[MAX];\n  for(int j=0;j<MAX;j++) dp[j]=M(0);\n  dp[0]=M(1);\n  \n  vector<int> a({1,5,10,50,100,500});\n  for(int x:a)\n    for(int j=x;j<MAX;j++) dp[j]+=dp[j-x];\n  \n  int T;\n  scanf(\"%d\",&T);\n  while(T--){\n    Int m;\n    scanf(\"%lld\",&m);\n    vector<M> y(6);\n    for(int i=0;i<6;i++) y[i]=dp[(m%500)+(i*500)];\n    M ans=E::LagrangePolynomial(y,M(m/500));\n    printf(\"%d\\n\",ans.v);\n  }\n  return 0;\n}\n/*\n  verified on 2018/11/10\n  https://yukicoder.me/problems/no/42\n*/\n\nsigned CFR315_B(){\n  int n;\n  cin>>n;\n  using M = Mint<int>;\n  using E = Enumeration<M>;\n  E::init(n+1);\n  M res;\n  for(int i=0;i<n;i++)\n    res+=E::C(n,i)*E::B(i,i);  \n  cout<<res.v<<endl;\n  return 0;\n}\n/*\n  verified on 2019/04/15\n  https://codeforces.com/contest/568/problem/B\n*/\n\nsigned main(){\n  //DPL_5_A();\n  //DPL_5_B();\n  //DPL_5_C();\n  DPL_5_D();\n  //DPL_5_E();\n  //DPL_5_F();\n  //DPL_5_G();\n  //DPL_5_H();\n  //DPL_5_I();\n  //DPL_5_J();\n  //DPL_5_K();\n  //DPL_5_L();\n  \n  //ABC110_D();\n  //ARC009_C();\n  //ARC033_D();\n\n  //YUKI_117();\n  //YUKI_042();\n\n  //CFR315_B();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int mod>\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if ((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if ((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while (b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while (n > 0) {\n            if (n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt<mod>(t);\n        return is;\n    }\n\n    static int get_mod() { return mod; }\n};\n\n// TにはModIntを渡す\ntemplate <typename T>\nstruct Combination {\n    vector<T> _fact, _rfact, _inv;\n\n    Combination(int sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n        _fact[0] = _rfact[sz] = _inv[0] = 1;\n        for (int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n        _rfact[sz] /= _fact[sz];\n        for (int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n        for (int i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n    }\n    inline T fact(int k) const { return _fact[k]; }\n\n    inline T rfact(int k) const { return _rfact[k]; }\n\n    inline T inv(int k) const { return _inv[k]; }\n\n    T P(int n, int r) const {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * rfact(n - r);\n    }\n\n    T C(int p, int q) const {\n        if (q < 0 || p < q) return 0;\n        return fact(p) * rfact(q) * rfact(p - q);\n    }\n\n    T H(int n, int r) const {\n        if (n < 0 || r < 0) return 0;\n        return r == 0 ? 1 : C(n + r - 1, n);\n    }\n};\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    const int mod = 1000000007;\n    Combination<ModInt<mod>> comb(n + k);\n    cout << comb.H(n, k) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100001,INF=1<<30;\n\nll rui(ll a,ll b){\n    if(b==1) return a%mod;\n    else if(b==0) return 1;\n    else if(b%2==0) return (rui(a,b/2)*rui(a,b/2))%mod;\n    else return (rui(a,b-1)*a)%mod;\n}\n\nll inv[MAX],fac[MAX],finv[MAX];\n\nvoid make(){\n    \n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    \n    for(int i=2;i<MAX;i++){\n        inv[i]=mod-inv[mod%i]*(mod/i)%mod;\n        fac[i]=fac[i-1]*(ll)i%mod;\n        finv[i]=finv[i-1]*inv[i]%mod;\n    }\n    \n}\n\nll comb(ll a,ll b){\n    if(a<b) return 0;\n    return fac[a]*(finv[b]*finv[a-b]%mod)%mod;\n}\n\nint main(){\n\n    int N,K;cin>>N>>K;\n    make();\n    cout<<comb(N+K-1,K-1)<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region kyomukyomupurin\n\n/**\n *    author  : 𝒌𝒚𝒐𝒎𝒖𝒌𝒚𝒐𝒎𝒖𝒑𝒖𝒓𝒊𝒏\n *    created : 2020-05-01 15:26:42\n **/\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing int64 = long long;\n\ntemplate <class T>\nusing binary_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <class T, class U>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {\n  return os << '(' << p.first << \", \" << p.second << ')';\n}\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {\n  int flag = 0;\n  for (auto e : vec) os << (flag++ ? \", \" : \"{\") << e;\n  return os << (vec.empty() ? \"{}\" : \"}\");\n}\n\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, const std::set<T>& st) {\n  int flag = 0;\n  for (auto e : st) os << (flag++ ? \", \" : \"{\") << e;\n  return os << (st.empty() ? \"{}\" : \"}\");\n}\n\ntemplate <class T, class U>\nstd::ostream& operator<<(std::ostream& os, const std::map<T, U>& mp) {\n  int flag = 0;\n  for (auto e : mp) os << (flag++ ? \", \" : \"{\") << e;\n  return os << (mp.empty() ? \"{}\" : \"}\");\n}\n\ntemplate <class T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& vec) {\n  for (T& e : vec) is >> e;\n  return is;\n}\n\n#define all(_) begin(_), end(_)\n#define rall(_) rbegin(_), rend(_)\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nvoid debug_out() { std::cerr << '\\n'; }\n\ntemplate <class Head, class... Tail>\nvoid debug_out(Head&& head, Tail&&... tail) {\n  std::cerr << head;\n  if (sizeof...(Tail) != 0) std::cerr << \", \";\n  debug_out(std::forward<Tail>(tail)...);\n}\n\n#pragma endregion kyomukyomupurin\n\nclass Combination {\n public:\n  static constexpr int mod_ = 1000000007;\n  static constexpr int n_ = 2000 + 5;\n\n  Combination() { build(); }\n\n  std::array<int64, n_> fact_;\n  std::array<int64, n_> inv_;\n  std::array<int64, n_> finv_;\n\n  // return nCk\n  int64 get(int n, int k) const noexcept {\n    if (n < k || n < 0 || k < 0) return 0;\n    return fact_[n] * (finv_[k] * finv_[n - k] % mod_) % mod_;\n  }\n\n private:\n  void build() noexcept {\n    fact_[0] = 1;\n    fact_[1] = 1;\n    finv_[0] = 1;\n    finv_[1] = 1;\n    inv_[1] = 1;\n    for (int i = 2; i < n_; ++i) {\n      fact_[i] = fact_[i - 1] * i % mod_;\n      inv_[i] = mod_ - inv_[mod_ % i] * (mod_ / i) % mod_;\n      finv_[i] = finv_[i - 1] * inv_[i] % mod_;\n    }\n  }\n};\n\nCombination kyomu;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, k; cin >> n >> k;\n\n  cout << kyomu.get(n + k - 1, n) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_D\"\n// #include \"../../math/combination.hpp\"\n// #include \"../../math/modint.hpp\"\n#include <iostream>\nconstexpr const int MOD = (int)1e9 + 7;\n#include <vector>\n\n// template引数としてModIntをとることを想定\ntemplate <typename T>\nclass Combination {\n    std::vector<T> fac, finv;\n\npublic:\n    explicit Combination(int size)\n        : fac(size + 1)\n        , finv(size + 1)\n    {\n        fac[0] = 1;\n        finv[0] = 1;\n        for (int i = 0; i < size; i++) {\n            fac[i + 1] = fac[i] * T(i + 1);\n            finv[i + 1] = finv[i] * T(i + 1).inv();\n        }\n    }\n\n    // `nCr` を求める\n    T C(int n, int r) const\n    {\n        if (r < 0 || n < r)\n            return T(0);\n        return fac[n] * finv[r] * finv[n - r];\n    }\n\n    // `nPr` を求める\n    T P(int n, int r) const\n    {\n        if (r < 0 || n < r)\n            return T(0);\n        return fac[n] * finv[n - r];\n    }\n};\n#ifndef _MODINT_H_\n#define _MODINT_H_\n#include <iostream>\n#include <assert.h>\n\ntemplate<int Mod>\nstruct ModInt {\n    int v;\n    ModInt(): v(0){}\n    template<typename T>\n    explicit ModInt(T t) {\n        v = t % Mod;\n        if (v < 0) v += Mod;\n    }\n\n    ModInt pow(int k) {\n        ModInt res(1), x(v);\n        while(k) {\n            if (k % 2 == 1) res *= x;\n            x *= x;\n            k >>= 1;\n        }\n        return res;\n    }\n\n    template<typename T>\n    ModInt& operator=(T a) { v = a % Mod; if (v < 0) v += Mod; return *this; }\n    ModInt inv() { return pow(Mod - 2); }\n    ModInt& operator+=(ModInt a) { v += a.v; if (v >= Mod) v -= Mod; return *this; }\n    ModInt& operator-=(ModInt a) { v += Mod - a.v; if (v >= Mod) v -= Mod; return *this; }\n    ModInt& operator*=(ModInt a) { v = 1LL * v * a.v % Mod; return *this; }\n    ModInt& operator/=(ModInt a) { assert(a.v != 0); return (*this) *= a.inv(); }\n    ModInt operator+(ModInt a) const { return ModInt(v) += a; }\n    ModInt operator-(ModInt a) const { return ModInt(v) -= a; }\n    ModInt operator*(ModInt a) const { return ModInt(v) *= a; }\n    ModInt operator/(ModInt a) const { return ModInt(v) /= a; }\n    ModInt operator-() { return ModInt(-v); }\n    bool operator==(const ModInt a) const { return v == a.v; }\n    bool operator!=(const ModInt a) const { return v != a.v; }\n    bool operator<(const ModInt a) const { return v < a.v; }\n\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &a) { return os << a.v; }\n    friend std::istream &operator>>(std::istream &is, ModInt &a) {\n        int val;\n        is >> val;\n        a = ModInt(val);\n        return is;\n    }\n};\n\n#endif // #ifndef _MODINT_H_\n\nint main()\n{\n    int n, k;\n    std::cin >> n >> k;\n    Combination<ModInt<MOD>> com(2005);\n    auto ans = com.C(n + k - 1, k - 1);\n    std::cout << ans << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// a quote from http://www.igaris.com/math/c.pdf\n\n#define MOD (1000000000+7)\n\nlong long C[1001][1001];\n\nint main()\n{\n\tint n, k;\n\tcin >> n >> k;\n\n\t// Pascal's triangle for combination\n\tC[0][0] = 1;\n\tfor( int i = 1; i < 1001; i++ ) {\n\t\tfor( int j = 0; j <= i; j++ ) {\n\t\t\tif( j == 0 || j == i ) {\n\t\t\t\tC[i][j] = C[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tC[i][j] = ( C[i - 1][j - 1] + C[i - 1][j] ) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans = C[n + k - 1][n];\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1e9 + 7;\n\nll modpow(ll a, ll b, ll p = 1e9+7){\n    if(b == 0)  return 1;\n\n    if(b % 2 == 0){\n        ll d = modpow(a, b/2, p);\n        return (d*d) % p;\n    }else{\n        return (a%p * modpow(a, b-1, p)) % p;\n    }\n}\n\nstruct ModComb{\n    vector<ll> po, inv;\n    ll N;\n\n    ModComb(ll n) : N(n), po(n), inv(n) {\n        po[0] = 1;\n        for(int i = 1; i < N; i++)  po[i] = (po[i-1] * i) % mod;\n        inv[N-1] = modpow(po[N-1], mod-2, mod);\n        for(int i = N-2; i >= 0; i--)   inv[i] = (inv[i+1] * (i+1)) % mod;\n    }\n    \n    ll nCk(ll n, ll k){\n        if(n < k)   return 0;\n        return (((po[n]*inv[n-k])%mod)*inv[k])%mod;\n    }\n\n    ll nPk(ll n, ll k){\n        if(n < k)   return 0;\n        return (po[n]*inv[n-k])%mod;\n    }\n\n    ll nHk(ll n, ll k){\n        if(n == 0 && k == 0)    return 1;\n        return nCk(n+k-1, k-1);\n    }\n};\n\nint main(){\n    int n, k;\n    cin >> n >> k;\n    ModComb mc(2100);\n    cout << mc.nHk(n, k) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<Int MOD = 1000000007>\nstruct Mod{\n  Int prev=0;\n  vector<Int> fact,inv,finv;\n  Mod(){}\n  Mod(Int n){init(n);}\n  \n  Int pow(Int x,Int n){\n    Int res=1;\n    while(n){\n      if(n&1) (res*=x)%=MOD;\n      (x*=x)%=MOD;\n      n>>=1;\n    }\n    return res;\n  }\n  \n  Int inverse(Int a){\n    return pow(a,MOD-2);\n  }\n  \n  void init(Int n){\n    if(prev>=n) return;\n    prev=n;\n    fact=inv=finv=vector<Int>(n);\n    \n    fact[0]=1;\n    for(Int i=1;i<n;i++)\n      fact[i]=(fact[i-1]*i)%MOD;\n    \n    inv[1]=1;\n    for(Int i=2;i<n;i++)\n      inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    \n    finv[0]=1;\n    for(Int i=1;i<n;i++)\n      finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n  \n  Int comb(Int n,Int k){\n    Int res=1;\n    for(Int i=0;i<k;i++){\n      res*=(n-i)%MOD;\n      res%=MOD;\n      res*=inverse(i+1);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  //only for prime MOD\n  Int C(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[k]%MOD*finv[n-k]%MOD;\n  }\n\n  Int H(Int n,Int k){\n    return C(n+k-1,k);\n  }\n  \n  Int montmort(Int n){\n    Int res=0,rinv=1;\n    for(Int k=2;k<=n;k++){\n      (rinv*=inverse(k))%=MOD;\n      if(k%2) (res+=MOD-rinv)%=MOD;\n      else (res+=rinv)%=MOD;\n    }\n    for(Int i=1;i<=n;i++)\n      (res*=i)%=MOD;\n    return res;\n  }\n  \n  // calculate P(t) from given points in [0,N]\n  Int LagrangePolynomial(vector<Int> &y,Int t){\n    Int n=y.size()-1;\n    init(n+1);\n    Int num=1;\n    for(Int i=0;i<=n;i++)\n      num=num*((t-i)%MOD)%MOD;\n    Int res=0;\n    for(Int i=0;i<=n;i++){\n      Int tmp=(y[i]*num%MOD)*inverse((t-i)%MOD)%MOD;\n      tmp=tmp*finv[i]%MOD;\n      tmp=tmp*finv[n-i]%MOD;\n      if((n-i)&1) tmp=MOD-tmp;\n      res=(res+tmp)%MOD;\n    }\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MOD = 1e9+7;\n  Mod<MOD> mod(2e5);\n  Int n,k;\n  cin>>n>>k;\n  cout<<mod.H(n,k)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<Int MOD = 1000000007>\nstruct Mod{\n  Int prev=0;\n  vector<Int> fact,inv,finv;\n  Mod(){}\n  Mod(Int n){init(n);}\n  \n  Int pow(Int x,Int n){\n    Int res=1;\n    while(n){\n      if(n&1) (res*=x)%=MOD;\n      (x*=x)%=MOD;\n      n>>=1;\n    }\n    return res;\n  }\n  \n  Int inverse(Int a){\n    return pow(a,MOD-2);\n  }\n  \n  void init(Int n){\n    if(prev>=n) return;\n    prev=n;\n    fact=inv=finv=vector<Int>(n);\n    \n    fact[0]=1;\n    for(Int i=1;i<n;i++)\n      fact[i]=(fact[i-1]*i)%MOD;\n    \n    inv[1]=1;\n    for(Int i=2;i<n;i++)\n      inv[i]=inv[MOD%i]*(MOD-MOD/i)%MOD;\n    \n    finv[0]=1;\n    for(Int i=1;i<n;i++)\n      finv[i]=finv[i-1]*inv[i]%MOD;\n  }\n  \n  Int comb(Int n,Int k){\n    Int res=1;\n    for(Int i=0;i<k;i++){\n      res*=(n-i)%MOD;\n      res%=MOD;\n      res*=inverse(i+1);\n      res%=MOD;\n    }\n    return res;\n  }\n  \n  //only for prime MOD\n  Int C(Int n,Int k){\n    if(k<0||k>n) return 0;\n    return fact[n]*finv[k]%MOD*finv[n-k]%MOD;\n  }\n\n  Int H(Int n,Int k){\n    return C(n+k-1,n);\n  }\n  \n  Int montmort(Int n){\n    Int res=0,rinv=1;\n    for(Int k=2;k<=n;k++){\n      (rinv*=inverse(k))%=MOD;\n      if(k%2) (res+=MOD-rinv)%=MOD;\n      else (res+=rinv)%=MOD;\n    }\n    for(Int i=1;i<=n;i++)\n      (res*=i)%=MOD;\n    return res;\n  }\n  \n  // calculate P(t) from given points in [0,N]\n  Int LagrangePolynomial(vector<Int> &y,Int t){\n    Int n=y.size()-1;\n    init(n+1);\n    Int num=1;\n    for(Int i=0;i<=n;i++)\n      num=num*((t-i)%MOD)%MOD;\n    Int res=0;\n    for(Int i=0;i<=n;i++){\n      Int tmp=(y[i]*num%MOD)*inverse((t-i)%MOD)%MOD;\n      tmp=tmp*finv[i]%MOD;\n      tmp=tmp*finv[n-i]%MOD;\n      if((n-i)&1) tmp=MOD-tmp;\n      res=(res+tmp)%MOD;\n    }\n    return res;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  const Int MOD = 1e9+7;\n  Mod<MOD> mod(2e5);\n  Int n,k;\n  cin>>n>>k;\n  cout<<mod.H(n,k)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<math.h>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<deque>\n#include<chrono>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\nconst ll E=1e18+7;\n#define F first\n#define S second\n#define MK make_pair\nconst ll MOD=1000000007;\n\nvector<vector<ll>> c;\n\nvoid mk_c(){\n    c.resize(2100);\n    for(int i=1;i<2100;i++){\n        c[i].resize(2100);\n        c[i][0]=1;\n        c[i][i]=1;\n        for(int t=1;t<i;t++){\n            c[i][t]=(c[i-1][t-1]+c[i-1][t])%MOD;\n        }\n    }\n}\n\nint main(){\n    ll n,k;\n    cin>>n>>k;\n    mk_c();\n    cout<<c[n+k-1][k-1]<<endl;\n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vii vector<int>\n#define vll vector<ll>\n#define lb lower_bound\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n// #define int ll\nusing namespace std;\nconst int INF (1 << 30);\nconst ll LLINF (1LL << 55LL);\nconst int MOD = 1000000007;\nconst int MAX = 510000;\nconst double pi=3.14159265358979;\n\nll fac[MAX], finv[MAX], inv[MAX];\nll POW[MAX];\n\nvoid POWinit(){\n    POW[0]=0;\n    POW[1]=1;\n    for(ll i=2;i<MAX;i++){\n        POW[i]=POW[i-1]*i;\n        POW[i]%=MOD;\n    }\n}\n\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nll COM(ll n, ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,k;\n    cin>>n>>k;\n    COMinit();\n    POWinit();\n    cout<<COM(n+k-1,k-1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\ntemplate<long long mod>\nstruct modint {\n    using LL = long long;\n\n    LL val;\n    modint(LL val=0) : val(((val % mod) + mod) % mod) {}\n\n    const modint operator+() const { return *this; }\n    const modint operator-() const { return (-val + mod) % mod; }\n    const modint reciprocal() const { return power(mod-2); }\n\n    modint& operator+=(const modint& rhs) { (val += rhs.val) %= mod; return *this; }\n    modint& operator-=(const modint& rhs) { return *this += -rhs; }\n    modint& operator*=(const modint& rhs) { (val *= rhs.val) %= mod; return *this; }\n    modint& operator/=(const modint& rhs) { return *this *= rhs.reciprocal(); }\n\n    const modint operator+(const modint& rhs) const { return modint(*this) += rhs; }\n    const modint operator-(const modint& rhs) const { return modint(*this) -= rhs; }\n    const modint operator*(const modint& rhs) const { return modint(*this) *= rhs; }\n    const modint operator/(const modint& rhs) const { return modint(*this) /= rhs; }\n\n    const modint power(long long n) const {\n        modint ret = 1, tmp = val;\n        while (n > 0) {\n            if (n & 1) ret *= tmp;\n            tmp *= tmp; n >>= 1;\n        }\n        return ret;\n    }\n\n    bool operator==(const modint& rhs) const { return val == rhs.val; }\n    bool operator!=(const modint& rhs) const { return !(*this == rhs); }\n\n    friend const modint operator+(const LL& lhs, const modint& rhs) {\n        return modint(lhs) + rhs;\n    }\n    friend const modint operator-(const LL& lhs, const modint& rhs) {\n        return modint(lhs) - rhs;\n    }\n    friend const modint operator*(const LL& lhs, const modint& rhs) {\n        return modint(lhs) * rhs;\n    }\n    friend const modint operator/(const LL& lhs, const modint& rhs) {\n        return modint(lhs) / rhs;\n    }\n\n    friend bool operator==(const LL& lhs, const modint& rhs) {\n        return modint(lhs) == rhs;\n    }\n    friend bool operator!=(const LL& lhs, const modint& rhs) {\n        return modint(lhs) != rhs;\n    }\n\n    friend ostream& operator<<(ostream& os, const modint& a) { return os << a.val; }\n    friend istream& operator>>(istream& is, modint& a) {\n        LL tmp; is >> tmp;\n        a = tmp;\n        return is;\n    }\n};\n\ntemplate<typename Ring>\nstruct Fact {\n    vector<Ring> fact;\n    Fact(int n) {\n        fact.resize(n+1);\n        fact[0] = Ring{1};\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = fact[i-1] * Ring{i};\n        }\n    }\n    Ring operator[](int i) {\n        return fact[i];\n    }\n};\n\ntemplate<typename Field>\nstruct Comb {\n    Fact<Field> fact;\n    Comb(int n) : fact(n) {}\n    Field operator()(int n, int r) {\n        if (n < 0 || n-r < 0 || r < 0) {\n            return Field{0};\n        }\n        return fact[n] / (fact[n-r] * fact[r]);\n    }\n};\n\nint main()\n{\n    LL n, k;\n    cin >> n >> k;\n\n    Comb<modint<MOD>> comb(n+k);\n\n    cout << comb(n+k-1,k-1) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nconst ll mo = 1000000007;\nll mypow(ll a, ll b)\n{\n  ll res = 1;\n  a %= mo;\n  while (b)\n  {\n    if (b & 1)\n      res = res * a % mo;\n    a = a * a % mo;\n    b >>= 1;\n  }\n  return res;\n}\nconst ll MAX = 510000;\nconst ll MOD = 1000000007;\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\nlong long COM(ll n, ll k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\nvector<ll> factorial(ll n)\n{\n  vector<ll> fac;\n  fac.push_back(1);\n  for (ll i = 1; i < n + 10; i++)\n  {\n    fac.push_back((fac[i - 1] * i) % mo);\n  }\n  return fac;\n}\nint main()\n{\n/* \nhttps://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5\nボール      箱\t      入れ方に制限なし 箱の中身は1つ以下 箱の中身は1つ以上\n区別できる   区別できる  1            2             3\n区別できない  区別できる  4            5             6\n区別できる   区別できない 7            8             9\n区別できない  区別できない 10          11            12\n*/\nll n , k ;\ncin >> n >> k ;\nauto mod = [](ll modx) {modx%=mo;modx+=mo;modx%=mo;return modx; };\nCOMinit();\nvector<ll> fac = factorial(100000);\n/* \n//1\ncout << mypow(k,n) << endl;\n */\n/* \n//2\ncout << (COM(k,n)*fac[n])%mo << endl;\n */\n/* \n//3\nll t=0;\nrep(i,k+1){\n  t=mod(t+mypow(-1,k-i)*COM(k,i)*mypow(i,n));\n}\ncout << t << endl;\n */\n\n//4\ncout << COM(n+k-1,n) << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \nll m=1e9+7;\n\n\nll dfs(ll a,ll b){\n  static ll dp[2002][1002];\n  dp[0][0]=1;\n  if(dp[a][b])return dp[a][b];\n  ll res=0;\n  if(a)res+=dfs(a-1,b);\n  if(a&&b)res+=dfs(a-1,b-1);\n  res%=m;\n  return dp[a][b]=res;\n}\n\nint main(){\n  ll n,k;\n  cin>>n>>k;\n  cout<<dfs(n+k-1,k-1)<<endl;\n  return 0;\n}\n\n\n  \n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/DPL_5_D.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/5/DPL_5_D\"\n#line 1 \"macro/macros.hpp\"\n\n\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0;i<int(N);++i)\n#define rep1(i,N) for(int i=1;i<int(N);++i)\n#define all(a) (a).begin(),(a).end()\n#define print(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<_<<\", \"; cerr<<\"]\"<<endl; }\n#define printpair(v) { cerr<<#v<<\": [ \"; for(auto _ : v) cerr<<\"{\"<<_.first<<\",\"<<_.second<<\"}\"<<\", \"; cerr<<\"]\"<<endl; }\n#define dump(x) cerr<<#x<<\": \"<<x<<endl;\n#define bit(k) (1LL<<(k))\n#define Yes \"Yes\"\n#define No \"No\"\n#define YES \"YES\"\n#define NO \"NO\"\ntypedef long long ll;\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n  os << \"{\" <<p.first << \", \" << p.second << \"}\";\n  return os;\n}\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst int INF = (ll)1e9;\nconst ll INFLL = (ll)1e18+1;\nconst ll MOD = (ll)1e9+7;\n\nconst double PI = acos(-1.0);\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst string dir = \"DRUL\";\n\n\n#line 1 \"math/mint.hpp\"\n\n\n\n#line 5 \"math/mint.hpp\"\n\nstruct mint {\n    long long x;\n    mint(long long _x=0):x((_x%MOD+MOD)%MOD){}\n    mint operator-() const { return mint(-x);}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint modpow(long long t) const {\n        if (!t) return 1;\n        mint a = modpow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime MOD\n    mint inv() const {\n        return modpow(MOD-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const mint& a){\n        os << a.x;\n        return os;\n    }\n};\n\n#line 1 \"math/comb.hpp\"\n\n\n#line 5 \"math/comb.hpp\"\n\n/*\n@title 組み合わせ(Combination)\n*/\nstruct combination {\n    vector<mint> fact, ifact;\n    combination(int n):fact(n+1),ifact(n+1) {\n        assert(n < MOD);\n        fact[0] = 1;\n        for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n    }\n    mint Comb(int n, int k) {\n        if (k < 0 || k > n) return 0;\n        return fact[n]*ifact[k]*ifact[n-k];\n    }\n    mint H(int n, int m){\n        return Comb(n + m - 1, n);\n    }\n    //nPk\n    mint Perm(int n, int k){\n        if (k < 0 || n < k) return 0;\n        return fact[n]*ifact[n-k];\n    }\n};\n\n#line 5 \"test/DPL_5_D.test.cpp\"\n/*\n@title 玉区別しない、箱区別する、制限なし(${}_n H _k$)\n@category 写像12相\n*/\n\ncombination C(200100);\nint main(){\n    int n, k;\n    cin >> n >> k;\n    cout << C.H(n, k) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n#define IN(x, a, b) x >= a and x < b\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (b < a) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <typename T> constexpr T INF = numeric_limits<T>::max() / 2;\n#pragma endregion\n\ntemplate <int mod> struct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod)\n      x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while (n > 0) {\n      if (n & 1)\n        ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt<1000000007>;\n\ntemplate <typename T> struct Combination {\n  vector<T> _fact, _rfact, _inv;\n\n  Combination(int sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for (int i = 1; i <= sz; i++)\n      _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for (int i = sz - 1; i >= 0; i--)\n      _rfact[i] = _rfact[i + 1] * (i + 1);\n    for (int i = 1; i <= sz; i++)\n      _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(int k) const { return _fact[k]; }\n\n  inline T rfact(int k) const { return _rfact[k]; }\n\n  inline T inv(int k) const { return _inv[k]; }\n\n  T P(int n, int r) const {\n    if (r < 0 || n < r)\n      return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(int p, int q) const {\n    if (q < 0 || p < q)\n      return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(int n, int r) const {\n    if (n < 0 || r < 0)\n      return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, k;\n  cin >> n >> k;\n  Combination<modint> comb(n+k-1);\n  cout << comb.C(n+k-1, n) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n \n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n\n#define YES puts(\"YES\")\n#define Yes puts(\"Yes\")\n#define NO  puts(\"NO\")\n#define No  puts(\"No\")\n#define ALL(v) (v).begin(), (v).end()\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n \n \n\n//*\n#define mod 1000000007 /*/\n#define mod 998244353 //*/\n\ntypedef pair<int, int> P;\n#define INF (1LL<<60)\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T comb(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T perm(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nusing mint = Fp<mod>;\n\nvoid solve(){\n    BiCoef<mint> bc(3000);\n    int n, k;\n    cin >> n >> k;\n    cout << bc.comb(n+k-1, n) << endl;\n}\n\nsigned main(){\n    cout << fixed << setprecision(18);\n    cerr << fixed << setprecision(18);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nusing P = pair<ll, ll>;\ntypedef vector<int> vi;\nconst int MOD = (int)1e9 + 7;\nconst ll INF = 1LL << 60;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, pair<T,T> const&P){\n    os << P.first;\n    os << \" \";\n    os << P.second;\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\nll pow(int a,int b,int mod){\n    vector<bool> bit;\n    for(b=b;b>0;b>>=1){\n        bit.push_back(b&1);\n    }\n    vector<ll> fac(bit.size()); fac[0] = a;\n    ll res = 1;\n    for(int i=1;i<bit.size();i++){\n        fac[i] = (fac[i-1] * fac[i-1])%mod;\n    }\n    for(int i=0;i<bit.size();i++){\n        if(bit[i]) res*=fac[i];\n        res%=mod;\n    }\n    return res;\n}\n\n\n//mint\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x+2*MOD)%MOD){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += MOD-a.x) >= MOD) x -= MOD;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= MOD;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n\n    // for prime MOD\n    mint inv() const {\n        return pow(MOD-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\nostream& operator<<(ostream& os, mint a){\n    os << a.x;\n    return os;\n}\n\nclass BigCombination{\nprivate:\n    const int MAX = 510'000;\n    mint fac[510000], inv[510000];\npublic:\n    BigCombination(){\n        fac[0] = fac[1] = 1;\n        for(int i=2; i<MAX; i++){\n            fac[i] = fac[i-1] * i;\n        }\n        inv[MAX-1] = fac[MAX-1].inv();\n        for(int i=MAX-1;i>0;i--){\n            inv[i-1] = inv[i] * i;\n        }\n    }\n\n    mint combination(int n,int r){\n        if(n<r) return 0;\n        if(n==r) return 1;\n        return fac[n] * inv[r] * inv[n-r];\n    }\n};\n\n\n//写像12相\n//区別できるボール/区別できる箱/制限なし r^n\nmint ball_1(int n,int r){\n    return pow(n,r,MOD);\n}\n//区別できるボール/区別できる箱/1個以下 rCn * n!\nmint ball_2(int n,int r){\n    BigCombination B;\n    mint res = B.combination(r,n);\n    while (n>0){\n        res *= n;\n        n--;\n    }\n    return res;\n}\n//区別できるボール/区別できる箱/1個以上 包除原理\nmint ball_3(int n,int r){\n    BigCombination B;\n    mint res = 0;\n    for(int i=0;i<r;i++){\n        mint x = B.combination(r,i) * pow((r-i), n, MOD);\n        if (i&1) x *= -1;\n        res += x;\n    }\n    return res;\n}\n//区別できないボール/区別できる箱/制限なし 仕切りをどこに入れるか選ぶ (n+r-1)C(n)\nmint ball_4(int n,int r){\n    BigCombination B;\n    return B.combination(n+r-1,n);\n}\n\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,r;\n    cin >> n >> r;\n\n    mint ans=ball_4(n,r);\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mod 1000000007\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define for1(i, n) for(int i = 1; i <= (n);i++)\nusing namespace std;\nint f1(int a, int p) {\n\tif (p == 1)return a;\n\tif (p % 2)return f1(a, p - 1) * a % mod;\n\telse return f1(a * a % mod, p / 2) % mod;\n}\nint cbn(int n, int r) {\n\tint rt = 1;\n\tfor (int i = 1; i <= n; i++) { rt *= i; rt %= mod; }\n\tfor (int i = 1; i <= r; i++) { rt *= f1(i, mod - 2); rt %= mod; }\n\tfor (int i = 1; i <= n - r; i++) { rt *= f1(i, mod - 2); rt %= mod; }\n\treturn rt;\n}\nsigned main() {\n\tint n, k; cin >> n >> k; cout << cbn(n + k - 1, n) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\n#define rep2(i,a,b) for (ll i=(a);i<(b);++i)\n#define debug(x) cout << #x << '=' << x << endl\n#define all(v) (v).begin(),(v).end()\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\nconst ll INF=1e9;\nconst ll IINF=1e18;\nconst double EPS=1e-8;\nconst double pi=acos(-1);\n\ntemplate<class T> inline bool chmin(T &a,T b){\n    if (a>b){a=b; return true;} return false;\n}\ntemplate<class T> inline bool chmax(T &a,T b){\n    if (a<b){a=b; return true;} return false;\n}\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint &rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept {\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept {\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nconst int MAX=5e5+10;\nvector<mint> fac(MAX),finv(MAX),inv(MAX);\nvoid COMinit(){\n    fac[0]=fac[1]=1;\n    finv[0]=finv[1]=1;\n    inv[1]=1;\n    rep2(i,2,MAX){\n        fac[i]=fac[i-1]*i;\n        inv[i]=-inv[MOD%i]*(MOD/i);\n        finv[i]=finv[i-1]*inv[i];\n    }\n}\nmint COM(int n,int k){\n    if (n<k||n<0||k<0) return 0;\n    return fac[n]*finv[k]*finv[n-k];\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    COMinit();\n    int n,k; cin >> n >> k;\n    cout << COM(n+k-1,n) << endl;\n}\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\n\npowMod _ 0 _ = 1\npowMod base exponent modulus = ((if exponent `mod` 2 == 1 then base else 1) * powMod ((base * base) `mod` modulus) (exponent `div` 2) modulus) `mod` modulus\n\ninvMod x p = powMod x (p - 2) p\n\nf 0 = 1\n\nfallingFactorialMod _ 0 _ = 1\nfallingFactorialMod 0 _ _ = 1\nfallingFactorialMod x n p = (x * fallingFactorialMod (x - 1) (n - 1) p) `mod` p\n\ncombinationMod n k p = ((fallingFactorialMod n k p) * invMod (fallingFactorialMod k k p) p) `mod` p\n\nmain = do\n  let p = 10 ^ 9 + 7\n  [n, k] <- map read . words <$> getLine\n  print $ combinationMod (n + k - 1) n (10 ^ 9 + 7)\n\n"
  },
  {
    "language": "C",
    "code": "//Twelvefold way[syazou 12-sou]\n#include<stdio.h>\n#define mod 1000000007\n#define faclim 1048576\n#define partition_nlim 1024\n#define partition_klim 1024\n\nlong long power(long long a,long long b){\n  long long x=1,y=a;\n  while(b>0){\n    if(b&1ll){\n      x=(x*y)%mod;\n    }\n    y=(y*y)%mod;\n    b>>=1;\n  }\n  return x%mod;\n}\n\nlong long modular_inverse(long long n){\n  return power(n,mod-2);\n}\n\nlong long factorial[faclim];\nlong long invfact[faclim];\nlong long bce[faclim];\n\nvoid cfact(){\n  long long i;\n  factorial[0]=1;\n  factorial[1]=1;\n  for(i=2;i<faclim;i++){\n    factorial[i]=factorial[i-1]*i;\n    factorial[i]%=mod;\n  }\n  invfact[faclim-1]=modular_inverse(factorial[faclim-1]);\n  for(i=faclim-2;i>=0;i--){\n    invfact[i]=invfact[i+1]*(i+1);\n    invfact[i]%=mod;\n  }\n  for(i=0;i<faclim;i++){\n    if(i%2==1){bce[i]=mod-1;}\n    else{bce[i]=1;}\n    bce[i]*=invfact[i];\n    bce[i]%=mod;\n    if(i!=0){\n      bce[i]+=bce[i-1];\n      if(bce[i]>=mod){bce[i]-=mod;}\n    }\n  }\n}\n\nlong long calcnCr(long long n,long long k){\n  if(k<0 || n<k){return 0;}\n  return (factorial[n]*((invfact[k]*invfact[n-k])%mod))%mod;\n}\n\nlong long partition[partition_nlim][partition_klim];\nlong long partition_isinit=0;\n\nvoid partition_init(){\n  if(partition_isinit==1){return;}\n  partition_isinit=1;\n  long long i,j;\n  for(i=0;i<partition_nlim;i++){\n    for(j=0;j<partition_klim;j++){\n      partition[i][j]=-1;\n    }\n  }\n}\n\nlong long partition_rep(long long n,long long k){\n  if(n<0 || k<0){return 0;}\n  if(n==0){return 1;}\n  if(k==0){\n    if(n==0){return 1;}\n    else{return 0;}\n  }\n  if(partition[n][k]!=-1){return partition[n][k];}\n  partition[n][k]=(partition_rep(n,k-1)+partition_rep(n-k,k))%mod;\n  return partition[n][k];\n}\n\n// packing n balls using k boxes\n// |  distinguish  |  each boxes contains the balls limited  |\n// | balls | boxes |  no limits  |  at most 1  | at least 1  |\n// |  can  |  can  |      1      |      2      |      3      |\n// | can't |  can  |      4      |      5      |      6      |\n// |  can  | can't |      7      |      8      |      9      |\n// | can't | can't |     10      |     11      |     12      |\n\nlong long twelvefold_way(long long n,long long k,long long type){\n  long long i,r=0,dt;\n  switch(type){\n    case 1:\n      return power(k,n);\n      break;\n    case 2:\n      if(k<n){return 0;}\n      return (factorial[k]*invfact[k-n])%mod;\n      break;\n    case 3:\n      if(n<k){return 0;}\n      for(i=0;i<=k;i++){\n        dt=(calcnCr(k,i)*power(i,n))%mod;\n        if((k-i)%2==1){r+=(mod-dt);}\n        else{r+=dt;}\n        if(r>=mod){r-=mod;}\n      }\n      return r;\n      break;\n    case 4:\n      return calcnCr(n+k-1,n);\n      break;\n    case 5:\n      if(k<n){return 0;}\n      return calcnCr(k,n);\n      break;\n    case 6:\n      if(n<k){return 0;}\n      return calcnCr(n-1,k-1);\n      break;\n    case 7:\n      for(i=0;i<=k;i++){\n        dt=(power(i,n)*invfact[i])%mod;\n        r+=dt*bce[k-i];\n        r%=mod;\n      }\n      return r;\n    case 8:\n      if(k<n){return 0;}\n      return 1;\n      break;\n    case 9:\n      if(n<k){return 0;}\n      for(i=0;i<=k;i++){\n        dt=(calcnCr(k,i)*power(i,n))%mod;\n        if((k-i)%2==1){r+=(mod-dt);}\n        else{r+=dt;}\n        if(r>=mod){r-=mod;}\n      }\n      r*=invfact[k];r%=mod;\n      return r;\n      break;\n    case 10:\n      partition_init();\n      return partition_rep(n,k);\n      break;\n    case 11:\n      if(k<n){return 0;}\n      return 1;\n      break;\n    case 12:\n      if(n<k){return 0;}\n      partition_init();\n      return partition_rep(n-k,k);\n      break;\n  }\n}\n\nint main(){\n  cfact();\n  long long n,k;\n  scanf(\"%lld%lld\",&n,&k);\n  printf(\"%lld\\n\",twelvefold_way(n,k,4));\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h> // uint64_t\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\n#define BUF_SIZE 20\n#define DIVISOR 1000000007\n\nint get_int2(int *a1, int *a2) {\n#ifdef BUF_SIZE\n  char line[BUF_SIZE];\n  if(!fgets(line, BUF_SIZE, stdin)) return -1;\n  sscanf(line, \"%d %d\", a1, a2);\n#else\n#error\n#endif\n  return 0;\n}\n#define NUM_MAX 1000\n#define K_MAX 1000\n\nstatic uint64_t factorial[NUM_MAX+K_MAX+1];\nstatic uint64_t inv_factorial[NUM_MAX+K_MAX+1];\n\nstruct pair {\n    int x;\n    int y;\n};\n\nstruct pair gcdext(int a, int b) {\n    if(a == 0) { return (struct pair){0, 1}; }\n    struct pair p = gcdext(b%a, a);\n    return (struct pair){p.y - (b/a)*p.x, p.x};\n}\n\nvoid prep_combi(int n) {\n    // prep\n    int i;\n    factorial[0] = factorial[1] = 1;\n    for(i = 2; i <= n; i++) {\n        factorial[i] = (factorial[i-1] * i)%DIVISOR;\n    }\n\n    inv_factorial[0] = inv_factorial[1] = 1;\n    for(i = 2; i <= n; i++) {\n        struct pair p = gcdext(i, DIVISOR);\n        int inv = (p.x + DIVISOR)%DIVISOR;\n        inv_factorial[i] = (inv_factorial[i-1]*inv)%DIVISOR;\n    }\n}\n\nuint64_t calc_combi(int n, int k) {\n    uint64_t ans = 1;\n    ans = (ans * factorial[n])%DIVISOR;\n    ans = (ans * inv_factorial[k])%DIVISOR;\n    ans = (ans * inv_factorial[n-k])%DIVISOR;\n    return ans;\n}\n\nuint64_t calc_homo(int kinds, int num) {\n    return calc_combi(kinds+num-1, num);\n}\n\nvoid init() {\n    prep_combi(NUM_MAX+K_MAX);\n}\n\nint main(void) {\n    int n, k;\n    init();\n    get_int2(&n, &k);\n    uint64_t ans = calc_homo(k, n);\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\n//階乗,二項係数\n//*\nll fact[100010];\nll invfact[100010];\nvoid makefact(int n,ll m){\n\tfact[0]=1;\n\trep(i,0,n)fact[i+1]=fact[i]*(i+1)%m;\n\tinvfact[n]=invp(fact[n],m);\n\tfor(int i=n;i>0;i--)invfact[i-1]=invfact[i]*i%m;\n}\nll choose(int n,int r,int m){return n<0||r<0||n-r<0?0:fact[n]*invfact[r]%m*invfact[n-r]%m;}\n//*/\n\nint main(){\n\tmakefact(2000,MOD);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tprintf(\"%lld\\n\",choose(n+m-1,n,MOD));\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nconst i32 mod = 1000000007;\n\ni32 comb (i32 n, i32 k) {\n  if (!(0 <= k && k <= n)) return 0;\n  i32 a = 1;\n  i32 b = 1;\n  for (i32 i = 1; i <= k; ++i) {\n    a = (i64) a * (n + 1 - i) % mod;\n    b = (i64) b * i % mod;\n  }\n  while (b > 1) {\n    a = (i64) a * (mod - mod / b) % mod;\n    b = mod % b;\n  }\n  return a;\n}\n\nvoid run (void) {\n  i32 n, k;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &k);\n  i32 ans = comb (n + k - 1, k - 1);\n  printf (\"%\" PRIi32 \"\\n\", ans);\n}\n\nint main (void) {\n  run ();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_5_D Balls and Boxes 4\n// n 個の区別できないボールを k 個の区別できる箱に入れる\n// とき、可能な入れ方の総数を求めてください。\n// 答えは重複組み合わせ kHn = combi(k+n-1, n)\n// 2019.3.11 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\nint tbl[2001][1001];\n\nint combi(int n, int k)\n{\n\tint ans;\n\n\tif (tbl[n][k]) return tbl[n][k];\n\tif ((k << 1) > n) k = n - k;\n\tif (k == 0) ans = 1;\n\telse if (k == 1) ans = n;\n\telse ans = combi(n - 1, k) + combi(n - 1, k - 1);\n\treturn tbl[n][k] = ans % MOD;\n}\n\nint main()\n{\n\tint n, k;\n\n\tscanf(\"%d%d\", &n, &k);\n\tprintf(\"%d\\n\", combi(n + k - 1, n));\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n \npublic class Main implements Runnable {\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 16 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        FastScanner sc = new FastScanner();\n        \n        int n = sc.nextInt();\n        int k = sc.nextInt();\n        \n        Combinatrics c = new Combinatrics(n+k-1);\n\n    \tSystem.out.println(c.homogeneous(k, n));\n\n    }\n}\n\n\n\nclass Combinatrics {\n\t\n\tstatic long mod = 1000000007; //逆元を取るので素数前提\n\tstatic long[] fact; //階乗のテーブル\n\tstatic long[] inv;\t//逆元のテーブル\n\tstatic long[] finv; //階乗の逆元のテーブル\n\t\n\tpublic Combinatrics(int n){\n\t\tfact = new long[n+1];\n\t\tinv = new long[n+1];\n\t\tfinv = new long[n+1];\n\t    fact[0] = fact[1] = 1;\n\t    finv[0] = finv[1] = 1;\n\t    inv[1] = 1;\n\t    for(int i=2;i<n+1; i++){\n\t        fact[i] = fact[i-1] * i % mod;\n\t        inv[i] = mod - inv[(int)mod%i] * (mod / i) % mod;\n\t        finv[i] = finv[i-1] * inv[i] % mod;\n\t    }\n\t}\n\t\n\t//逆元\n\tint inv(int n){\n\t\treturn (int)inv[n];\n\t}\n\t\n\t//n!\n\tint factorial(int n){\n\t\treturn (int)fact[n];\n\t}\n\t\n\t//n!の逆元\n\tint factInv(int n){\n\t\treturn (int)finv[n];\n\t}\n\t\n\t//nCr（n個からr個選ぶ）\n    int combination(int n, int r) {\n        if(n<r|| r<0){\n        \treturn 0;\n        }\n        return (int)(fact[n]*finv[r]%mod*finv[n-r]%mod);\n    }\n\n    //nPr (=n*(n-1)*...*(n-r+1))（n個からr個選んで並べる）\n    int permutation(int n, int r) {\n        if(n<r || r<0){\n        \treturn 0;\n        }\n        return (int)(fact[n]*finv[n-r]%mod);\n    }\n\n    //nHr (=n+r-1Cr)（n個から重複を許してk個とる）\n    //（テーブルがn+r-1まで必要な事に注意！）\n    int homogeneous(int n, int r) {\n        if(n==0 && r==0){\n        \treturn 1;\n        }\n        return combination(n+r-1,r);\n    }\n\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextIntArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace CsharpSpiral {\n    partial class Program {\n        static void Main(string[] args) {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            new Program().Solve(new ConsoleInput(Console.In, ' '));\n            Console.Out.Flush();\n        }\n        public void Solve(ConsoleInput cin) {\n            var n = cin.ReadInt;\n            var k = cin.ReadInt;\n            const int modulo= 1000000007;\n            var F = new ResidueField(modulo);\n            Console.WriteLine(F.Combination(n + k - 1, k - 1));\n        }\n        class ResidueField {\n            public readonly long modulo;\n            public ResidueField(long mModulo) {\n                modulo = mModulo;\n            }\n            private long[] factorialTable = { 1 };\n            private int factorialTableLastIndex { get { return factorialTable.Length - 1; } }\n            public long mod(long x) => x < 0 ? x % modulo + modulo : x % modulo;\n            public long Add(long a, long b) => mod(a + b);\n            public long Sub(long a, long b) => mod(a - b);\n            public long Mul(long a, long b) => mod(a * b);\n            public long Pow(long a, long n) {\n                if(n == 0) return 1;\n                var R = 1L;\n                n = n < 0 ? n % (modulo - 1) + (modulo - 1) : n % (modulo - 1);\n                for(; n > 0; a = Mul(a, a), n >>= 1) {\n                    if((n & 1) != 0) R = Mul(R, a);\n                }\n                return R;\n            }\n            private static long extgcd(long a, long b, ref long x, ref long y) {\n                if(b == 0) {\n                    x = 1; y = 0; return a;\n                }\n                var q = a / b;\n                var g = extgcd(b, a - q * b, ref x, ref y);\n                var z = x - q * y;\n                x = y; y = z;\n                return g;\n            }\n            public long Inv(long a) {\n                if(a == 0) throw new DivideByZeroException();\n                long x = 0, y = 0;\n                extgcd(a, modulo, ref x, ref y);\n                return mod(x);\n            }\n            public long Div(long a, long b) => Mul(a, Inv(b));\n            public void ExpandFactorialTable(int N) {\n                var k = factorialTableLastIndex;\n                Array.Resize(ref factorialTable, N + 1);\n                for(int i = k + 1; i <= N; i++) {\n                    if(i == 0) { factorialTable[i] = 1; continue; }\n                    factorialTable[i] = Mul(factorialTable[i - 1], i);\n                }\n            }\n            public long Factorial(int n) {\n                if(n > factorialTableLastIndex)\n                    ExpandFactorialTable(n);\n                return factorialTable[n];\n            }\n            public long Permutation(int n, int k) {\n                if(k < 0 || k > n) throw new InvalidOperationException();\n                return Div(Factorial(n), Factorial(n - k));\n            }\n            public long Combination(int n, int k) {\n                if(k < 0 || k > n) throw new InvalidOperationException();\n                return Div(Factorial(n), Mul(Factorial(k), Factorial(n - k)));\n            }\n        }\n    }\n\n    static class ExtendClass {\n        public static string Join<T>(this T[] X, string separator = \" \") => string.Join(separator, X);\n    }\n\n    class ConsoleInput {\n        private readonly TextReader _stream;\n        private readonly char _separator = ' ';\n        private readonly Queue<string> inputStream;\n        public ConsoleInput(TextReader stream, char separator = ' ') {\n            this._separator = separator;\n            this._stream = stream;\n            inputStream = new Queue<string>();\n        }\n        public string Read {\n            get {\n                if(inputStream.Count != 0) return inputStream.Dequeue();\n                string[] tmp = _stream.ReadLine().Split(_separator);\n                for(int i = 0; i < tmp.Length; ++i)\n                    inputStream.Enqueue(tmp[i]);\n                return inputStream.Dequeue();\n            }\n        }\n        public string ReadLine { get { return _stream.ReadLine(); } }\n        public int ReadInt { get { return int.Parse(Read); } }\n        public long ReadLong { get { return long.Parse(Read); } }\n        public double ReadDouble { get { return double.Parse(Read); } }\n        public string[] ReadStrArray(long N) {\n            var ret = new string[N];\n            for(long i = 0; i < N; ++i)\n                ret[i] = Read;\n            return ret;\n        }\n        public int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i < N; ++i) ret[i] = ReadInt; return ret; }\n        public long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i < N; ++i) ret[i] = ReadLong; return ret; }\n        public double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i < N; ++i) ret[i] = ReadDouble; return ret; }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using static M;\nusing static System.Math;\nusing System;\n\nclass M\n{\n    private const int MOD = 1000000007;\n    private readonly int[] _f;\n    public int Mul(int a, int b) => (int)(BigMul(a, b) % MOD);\n    public M(int n)\n    {\n        _f = new int[n + 1];\n        _f[0] = 1;\n        for (int i = 1; i <= n; ++i)\n            _f[i] = Mul(_f[i - 1], i);\n    }\n    public int Fac(int n) => _f[n];\n    public int Pow(int a, int m)\n    {\n        if (m == 0) return 1;\n        else if (m == 1) return a;\n        var p1 = Pow(a, m / 2);\n        var p2 = Mul(p1, p1);\n        return ((m % 2) == 0) ? p2 : Mul(p2, a);\n    }\n    public int Div(int a, int b) => Mul(a, Pow(b, MOD - 2));\n    public int Ncr(int n, int r)\n    {\n        if (n < r) return 0;\n        if (n == r) return 1;\n        var res = Fac(n);\n        res = Div(res, Fac(r));\n        res = Div(res, Fac(n - r));\n        return res;\n    }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var n = int.Parse(line[0]);\n        var k = int.Parse(line[1]);\n        var md = new M(n + k);\n        if (k - 1 < 0) { Console.WriteLine(0); goto exit; }\n        var ans = md.Ncr(n + k - 1, n);\n        Console.WriteLine(ans);\n        exit:;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Math;\n \npublic class Solve{\n    static public int mod = 1000000007;\n    static public string al = \"abcdefghijklmnopqrstuvwxyz\";\n    public static void Main(){\n        // 方針\n        //\n        var n = inta();\n        WriteLine(ncr(n[1]+n[0]-1,n[0]));\n        \n\t\n\t\n    }\n    public static void swap(ref int a,ref int b){int temp = a;a= b;b = temp;}\n    static void charswap(ref char a,ref char b){char temp = a;a= b;b = temp;}\n    static int ncr(int n,int r){if(n<r)return 0;r = Min(r,n-r);long nn = 1;for(int i=n-r+1;i<=n;i++){nn = nn*i%mod;}long rr = 1;for(int i=1;i<=r;i++){rr = rr*i%mod;}rr = square((int)rr,mod-2);nn = nn * rr %mod;return (int)nn;}\n    // a^b mod\n    static int square(int a,int b){string binary = Convert.ToString(b,2);int bileng = binary.Length;long a_power = a;long value = 1;for(int i=bileng-1;i>=0;i--){if(binary[i] == '1'){value = value*a_power%mod;}a_power = a_power*a_power%mod;}return (int)value;}\n    static int square2(int a,int b){long output = 1;var list = new List<long>();int sh = 1;long n = a;list.Add(a);while(sh < b){sh *= 2;n = n*n%mod;list.Add(n);}for(int i=list.Count-1;i>=0;i--){if(b > sh){b -= sh;sh /= 2;output = output*list[i]%mod;}}return (int)output;}\n    //各種読取\n    static string rstr(){ return ReadLine(); }\n    static int rint(){ return int.Parse(ReadLine()); }\n    static long rlong(){ return long.Parse(ReadLine()); }\n    static string[] stra(){ return ReadLine().Split(' '); }\n    static char[] chara(){ string[] a=stra();string b=\"\";for(int i=0;i<a.Length;i++){b+=a[i];}return b.ToCharArray();}\n    static int[] inta(){ string[] read_str_array = ReadLine().Split(' '); int[] return_int_array = new int[read_str_array.Length]; for(int countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_int_array[countup_i] = int.Parse(read_str_array[countup_i]); } return return_int_array; }\n    static int[,] inta2(int num_array,int in_array){ int[,] int_array2 = new int[num_array,in_array]; for(int i=0;i<num_array;i++){ int[] temp_array = inta(); for(int j=0;j<in_array;j++){ int_array2[i,j] = temp_array[j]; } } return int_array2; }\n    static long[] longa(){ string[] read_str_array = ReadLine().Split(' '); long[] return_long_array = new long[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_long_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_long_array; }\n    static double[] doublea(){ string[] read_str_array = ReadLine().Split(' '); double[] return_double_array = new double[read_str_array.Length]; for(long countup_i=0;countup_i<read_str_array.Length;countup_i++){ return_double_array[countup_i] = long.Parse(read_str_array[countup_i]); } return return_double_array; }\n    // -----------------------------\n    static long divideup(long divided,long divid){ long temp_divide = divided/divid; if(divided % divid > 0){ temp_divide++; } return temp_divide; }\n    static long GCD(long a,long b){ if(a < b){ long temp = a; a = b; b = temp; } if(a % b == 0){ return b; } else{ long temp = b; b = a%b; a = temp; return GCD(a,b); } }\n    static long LCM(long a,long b){ return a * b / GCD(a,b); }\n    static void WriteArray(int[,] a,int b,int c){for(int i=0;i<b;i++){for(int j=0;j<c;j++){if(j!=0) Write(\" \");Write(a[i,j]);}WriteLine();}}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\n\tstatic void Main()\n\t{\n    string[] input = Console.ReadLine().Split(' ');//Splitで区切り文字を指定して複数個受け取る。\n    long n = long.Parse(input[0]);\n    long k = long.Parse(input[1]);\n    long p = 1000000007;\n    long answer = 1;\n    for(long i = 1; i <= n+k-1; i++)\n    {\n      answer *= i;\n      answer %= p;\n    }\n    answer *= DivideModFactorial(n,p);\n    answer %= p;\n    answer *= DivideModFactorial(k-1,p);\n    answer %= p;\n\t  Console.WriteLine(answer);//nCk(mod p),pは素数\n\t}\n\n  static long DivideMod(long x, long a, long p)//戻り値はx^a(mod p)\n  {\n    long num = 2;\n    long answer = 1;\n    long check = a;\n    long memo = x%p;\n    \n    while(check > 0)\n    {\n      if(check % num == num / 2)\n      {\n        check -= num / 2;\n        answer *= memo;\n        answer %= p;\n      }\n    memo *= memo;\n    memo %= p;\n    num *= 2;\n    }\n    return answer;\n  }\n\n  static long DivideModReverse(long x, long p)//戻り値はx^-1(mod p), pは素数\n  {\n    long answer = DivideMod(x, p-2, p);\n    return answer;\n  }\n\n  static long DivideModFactorial(long x, long p)//戻り値はx!^-1(mod p), pは素数\n  {\n    long answer = 1;\n    for(long i = x; i >= 2; i--)\n    {\n      answer *= DivideModReverse(i, p);\n      answer %= p;\n    }\n    return answer;\n  }\n\n  static long Comb(long a, long b, long p)//戻り値は組み合わせC(a,b)のmod p\n  {\n    long answer = 1;\n    for(long i = a; i > a-b; i--)\n    {\n      answer *= i;\n      answer %= p;\n    }\n    answer *= DivideModFactorial(b, p);\n    answer %= p;\n    return answer;\n  }\n  \n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\n//using Debug;\n//using static System.Globalization.CultureInfo;\nusing System.Text;\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Solve();\n        //WriteLine(Solve());\n    }\n    static void Solve()\n    {\n        var nk = Input.ar;\n        var comb = new Modulo.Combination(nk[0] + nk[1]);\n        WriteLine(comb.Comb(nk[0] + nk[1] - 1, nk[0]));\n    }\n}\n\npublic class Input\n{\n    public static string read => ReadLine();\n    public  static int[] ar => Array.ConvertAll(read.Split(' '), int.Parse);\n    public  static int num => ToInt32(read);\n    public static long[] arL => Array.ConvertAll(read.Split(' '), long.Parse);\n    public  static long numL => ToInt64(read);\n    public static char[][] gred(int h) \n        => Enumerable.Repeat(0, h).Select(v => read.ToCharArray()).ToArray();\n    public static int[][] ar2D(int num)\n        => Enumerable.Repeat(0, num).Select(v => ar).ToArray();\n    public static long[][] arL2D(int num)\n        => Enumerable.Repeat(0, num).Select(v => arL).ToArray();\n    public static T getValue<T>(string g)\n    {\n        var t = typeof(T);\n        if (t == typeof(int))\n            return (T)(object)int.Parse(g);\n        if (t == typeof(long))\n            return (T)(object)long.Parse(g);\n        if (t == typeof(string))\n            return (T)(object)g;\n        if (t == typeof(char))\n            return (T)(object)char.Parse(g);\n        if (t == typeof(double))\n            return (T)(object)double.Parse(g);\n        if (t == typeof(bool))\n            return (T)(object)bool.Parse(g);\n        return default(T);\n    }\n    public const long Inf = (long)1e18;\n    public const double eps = 1e-6;\n    public  const string alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    public  const int MOD = 1000000007;\n}\npublic class Modulo\n{\n    private static int Multiple(int num1, int num2)\n        => (int)(BigMul(num1, num2) % Input.MOD);\n\n    public static int Pow(int m, int n)\n    {\n        if (n == 0) return 1;\n        if (n % 2 == 0) return Pow(Multiple(m, m), n / 2);\n        else return Multiple(Pow(Multiple(m, m), n / 2), m);\n    }\n\n    public static int Div(int a, int b)\n        => Multiple(a, Pow(b, Input.MOD - 2));\n\n    public class Combination\n    {\n        private int[] _fac;\n        public Combination(int num)//階乗をメモ化\n        {\n            _fac = new int[num + 1];\n            _fac[0] = 1;\n            for (var i = 1; i <= num; i++)\n                _fac[i] = Multiple(_fac[i - 1], i);\n        }\n        public int Comb(int n, int r)\n        {\n            if (n < r) return 0;\n            if (n == r) return 1;\n            var calc = _fac[n];\n            calc = Div(calc, _fac[r]);\n            calc = Div(calc, _fac[n - r]);\n            return calc;\n        }\n        public int fac(int num)\n            => _fac[num];\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        //SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int K = cin.nextint;\n        var ncr = new BinomialCoefficient(N + K);\n        WriteLine(ncr[N + K - 1, N]);\n    }\n\n}\n\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\n/// <OriginalAuthor>camypaper</OriginalAuthor>\nstruct ModInt\n{\n    /// <summary>\n    /// 剰余を取る値．\n    /// </summary>\n    public const long Mod = (int)1e9 + 7;\n\n    /// <summary>\n    /// 実際の数値．\n    /// </summary>\n    public long num;\n    /// <summary>\n    /// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n    /// </summary>\n    /// <param name=\"n\">インスタンスが持つ値</param>\n    /// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n    public ModInt(long n) { num = n; }\n    /// <summary>\n    /// このインスタンスの数値を文字列に変換します．\n    /// </summary>\n    /// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n    public override string ToString() { return num.ToString(); }\n    public static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n    public static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n    public static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n    public static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n    /// <summary>\n    /// 与えられた 2 つの数値からべき剰余を計算します．\n    /// </summary>\n    /// <param name=\"v\">べき乗の底</param>\n    /// <param name=\"k\">べき指数</param>\n    /// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n    public static ModInt Pow(long v, long k)\n    {\n        long ret = 1;\n        for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n            if ((k & 1) == 1) ret = ret * v % Mod;\n        return new ModInt(ret);\n    }\n    /// <summary>\n    /// 与えられた数の逆元を計算します．\n    /// </summary>\n    /// <param name=\"v\">逆元を取る対象となる数</param>\n    /// <returns>逆元となるような値</returns>\n    /// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n    public static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n\nclass BinomialCoefficient\n{\n    public ModInt[] fact, ifact;\n    public BinomialCoefficient(int n)\n    {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n        ifact[0] = ifact[1];\n    }\n    public ModInt this[int n, int r]\n    {\n        get\n        {\n            if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n            return fact[n] * ifact[n - r] * ifact[r];\n        }\n    }\n    public ModInt RepeatedCombination(int n, int k)\n    {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "def comb(n,k)\n\tr=1\n\tk.times{|i|r=r*(n-i)/(i+1)}\n\tr\nend\na,b=gets.split.map &:to_i\np comb(b+a-1,a)%(10**9+7)\n"
  },
  {
    "language": "Ruby",
    "code": "n,k=gets.split.map &:to_i\nf=[1]\n(1..2000).map{|i|f<<f[-1]*i}\nc=->a,b{f[a]/f[b]/f[a-b]}\np c[n+k-1,n].%10**9+7\n\n"
  },
  {
    "language": "Ruby",
    "code": "MOD = 1_000_000_007\n\nFACT = [1]\n(1..2000).each do |k|\n  FACT << FACT[-1] * k % MOD\nend\n\ndef exp(n, k)\n  x = 1\n  r = n\n  while k > 0\n    x *= r if k & 1 == 1\n    r *= r\n    x %= MOD\n    r %= MOD\n    k >>= 1\n  end\n  x\nend\n\ndef inv(n)\n  exp(n, MOD - 2)\nend\n\ndef perm(n, k)\n  n >= k ? FACT[n] * inv(FACT[n - k]) % MOD : 0\nend\n\ndef comb(n, k)\n  perm(n, k) * inv(FACT[k]) % MOD\nend\n\nn, k = gets.split.map(&:to_i)\np comb(n + k - 1, n)\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\nfunc getCombinationTable(n, k, p int) [][]int {\n\ttable := make([][]int, n+1)\n\ttable[0] = make([]int, k+1)\n\ttable[0][0] = 1\n\tfor i := 1; i <= n; i++ {\n\t\ttable[i] = make([]int, k+1)\n\t\ttable[i][0] = 1\n\t\tfor j := 1; j <= k; j++ {\n\t\t\ttable[i][j] = (table[i-1][j] + table[i-1][j-1]) % p\n\t\t}\n\t}\n\treturn table\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tprime := 1000000000 + 7\n\n\tnBalls := nextInt()\n\tnBoxes := nextInt()\n\n\ttable := getCombinationTable(nBalls+nBoxes-1, nBalls, prime)\n\tfmt.Println(table[nBalls+nBoxes-1][nBalls])\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tn := getNextInt(scanner)\n\tk := getNextInt(scanner)\n\tmc := newModcom(n + k)\n\tfmt.Fprintln(writer, mc.choose(n+k-1, k-1))\n}\n\ntype mint int64\n\nfunc (mt mint) mod() mint {\n\tm := mint(1e9 + 7)\n\tmt %= m\n\tif mt < 0 {\n\t\treturn mt + m\n\t}\n\treturn mt\n}\nfunc (mt mint) inv() mint {\n\treturn mt.pow(mint(0).sub(2))\n}\nfunc (mt mint) pow(n mint) mint {\n\tp := mint(1)\n\tfor n > 0 {\n\t\tif n%2 == 1 {\n\t\t\tp.mulAs(mt)\n\t\t}\n\t\tmt.mulAs(mt)\n\t\tn >>= 1\n\t}\n\treturn p\n}\nfunc (mt mint) add(x mint) mint {\n\treturn (mt + x).mod()\n}\nfunc (mt mint) sub(x mint) mint {\n\treturn (mt - x).mod()\n}\nfunc (mt mint) mul(x mint) mint {\n\treturn (mt * x).mod()\n}\nfunc (mt mint) div(x mint) mint {\n\treturn mt.mul(x.inv())\n}\nfunc (mt *mint) addAs(x mint) *mint {\n\t*mt = mt.add(x)\n\treturn mt\n}\nfunc (mt *mint) subAs(x mint) *mint {\n\t*mt = mt.sub(x)\n\treturn mt\n}\nfunc (mt *mint) mulAs(x mint) *mint {\n\t*mt = mt.mul(x)\n\treturn mt\n}\nfunc (mt *mint) divAs(x mint) *mint {\n\t*mt = mt.div(x)\n\treturn mt\n}\n\ntype modcom struct {\n\tfacs, invs []mint\n}\n\nfunc newModcom(n int) modcom {\n\tfacs := make([]mint, n+1)\n\tinvs := make([]mint, n+1)\n\tfacs[0] = 1\n\tfor i := 0; i < n; i++ {\n\t\tfacs[i+1] = facs[i].mul(mint(i + 1))\n\t}\n\tinvs[n] = facs[n].inv()\n\tfor i := n - 1; i >= 0; i-- {\n\t\tinvs[i] = invs[i+1].mul(mint(i + 1))\n\t}\n\treturn modcom{\n\t\tfacs: facs,\n\t\tinvs: invs,\n\t}\n}\nfunc (mc *modcom) choose(n, k int) mint {\n\treturn mc.facs[n].mul(mc.invs[k]).mul(mc.invs[n-k])\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric, std.container;\n\nlong P = 10^^9+7;\nlong[10000] F, RF;\n\nlong pow(long x, long n) {\n    long y = 1;\n    while (n) {\n        if (n%2 == 1) y = (y * x) % P;\n        x = x^^2 % P;\n        n /= 2;\n    }\n    return y;\n}\n\nlong inv(long x)\n{\n    return pow(x, P-2);\n}\n\nvoid init()\n{\n    F[0] = F[1] = 1;\n    foreach (i, ref x; F[2..$]) x = (F[i+1] * (i+2)) % P;\n\n    {\n        RF[$-1] = 1;\n        auto x = F[$-1];\n        auto k = P-2;\n        while (k) {\n            if (k%2 == 1) RF[$-1] = (RF[$-1] * x) % P;\n            x = x^^2 % P;\n            k /= 2;\n        }\n    }\n    foreach_reverse(i, ref x; RF[0..$-1]) x = (RF[i+1] * (i+1)) % P;\n}\n\nlong comb(N)(N n, N k)\n{\n    if (k > n) return 0;\n    auto n_b = F[n];    // n!\n    auto nk_b = RF[n-k]; // 1 / (n-k)!\n    auto k_b = RF[k];    // 1 / k!\n\n    auto nk_b_k_b = (nk_b * k_b) % P; // 1 / (n-k)!k!\n\n    return (n_b * nk_b_k_b) % P;  // n! / (n-k)!k!\n}\n\nlong perm(N)(N n, N k)\n{\n    if (k > n) return 0;\n    auto n_b = F[n];\n    auto n_k_b = RF[n-k];\n    return (n_b * n_k_b) % P;\n}\n\nvoid main()\n{\n    init();\n    auto nk = readln.split.to!(long[]);\n    auto N = nk[0];\n    auto K = nk[1];\n    writeln(comb(N+K-1, K-1));\n}\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\nMOD = 10 ** 9 + 7\nn, k = map(int, raw_input().split())\n\ndef fact(N):\n    if N <= 1:\n        return 1\n    return fact(N - 1) * N\n\nprint (fact(n + k - 1) / fact(k - 1) / fact(n)) % MOD\n"
  },
  {
    "language": "Python",
    "code": "n,k = map(int, input().split())\nimport sys\nsys.setrecursionlimit(10000)\nmemo = [1,1]\ndef fact(a):\n    if len(memo) > a:\n        return memo[a]\n    b = a*fact(a-1)\n    memo.append(b)\n    return b\nans = fact(n+k-1)//(fact(n)*fact(k-1))%1000000007\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "MOD = 1000000007\nlim = 10 ** 4+1\nfac = [0] * lim\nfinv = [0] * lim\ninv = [0] * lim\n\nclass ModInt:\n    def __init__(self, x):\n        self.x = x % MOD\n\n    def __str__(self):\n        return str(self.x)\n    def __int__(self):\n        return self.x\n\n    __repr__ = __str__\n\n    def __add__(self, other):\n        return (\n            ModInt(self.x + other.x) if isinstance(other, ModInt) else\n            ModInt(self.x + other)\n        )\n\n    def __sub__(self, other):\n        return (\n            ModInt(self.x - other.x) if isinstance(other, ModInt) else\n            ModInt(self.x - other)\n        )\n\n    def __mul__(self, other):\n        return (\n            ModInt(self.x * other.x) if isinstance(other, ModInt) else\n            ModInt(self.x * other)\n        )\n\n    def __truediv__(self, other):\n        return (\n            ModInt(\n                self.x * pow(other.x, MOD - 2, MOD)\n            ) if isinstance(other, ModInt) else\n            ModInt(self.x * pow(other, MOD - 2, MOD))\n        )\n\n    def __mod__(self, other):\n        return (\n            ModInt(\n                other.x\n            ) if isinstance(other, ModInt) else\n            self.x\n        )\n\n    def __pow__(self, other):\n        return (\n            ModInt(pow(self.x, other.x, MOD)) if isinstance(other, ModInt) else\n            ModInt(pow(self.x, other, MOD))\n        )\n\n    __radd__ = __add__\n\n    def __rsub__(self, other):\n        return (\n            ModInt(other.x - self.x) if isinstance(other, ModInt) else\n            ModInt(other - self.x)\n        )\n\n    __rmul__ = __mul__\n\n    def __rtruediv__(self, other):\n        return (\n            ModInt(\n                other.x * pow(self.x, MOD - 2, MOD)\n            ) if isinstance(other, ModInt) else\n            ModInt(other * pow(self.x, MOD - 2, MOD))\n        )\n\n    def __rpow__(self, other):\n        return (\n            ModInt(pow(other.x, self.x, MOD)) if isinstance(other, ModInt) else\n            ModInt(pow(other, self.x, MOD))\n        )\n    \n    def __iadd__(self,other):\n        self.x += other.x if isinstance(other, ModInt) else other\n        self.x %= MOD\n        return self\n\n    def __isub__(self,other):\n        self.x += ModInt(MOD - other.x) if isinstance(other, ModInt) else ModInt(MOD - other)\n        return self\n\n    def __imul__(self, other):\n        self.x *= other.x if isinstance(other, ModInt) else other\n        self.x %= MOD\n        return self\n    \n    def __ifloordiv__(self, other):\n        self.x *= pow(int(other), MOD - 2, MOD)\n        return self\n    \n    def factorical(self,n):\n        tmp = ModInt(1)\n        for i in range(n):\n            tmp *= (i+1)\n        return tmp\n    \n    #m:int MOD\n    def modinv(self,a,m=MOD):\n        b = m\n        u = 1\n        v = 0\n        while(b):\n            t = a//b\n            a -= t * b\n            a,b = b,a\n            u -= t * v\n            u,v = v,u\n        return ModInt(u)\n\n    def comb(self,n,r):\n        n = int(n)\n        r = int(r)\n        if r > n or n < 0 or r < 0:\n            return 0\n        m = n+1\n        nterms = min(r, n-r)\n        numerator = ModInt(1)\n        denominator = ModInt(1)\n        for j in range(1, nterms + 1):\n            numerator *= m - j\n            denominator *= j\n        return numerator * self.modinv(denominator.x)\n\ndef COMinit():\n    fac[0] = ModInt(1)\n    fac[1] = ModInt(1)\n    finv[0] = ModInt(1)\n    finv[1] = ModInt(1)\n    inv[1] = ModInt(1)\n    for i in range(2,lim):\n        fac[i] = ModInt(fac[i - 1] * i)\n        inv[i] = ModInt(MOD - inv[MOD%i] * (MOD // i))\n        finv[i] = ModInt(finv[i - 1] * inv[i])\n\ndef cmb(n,k) -> ModInt:\n    if int(n) < int(k):\n        return ModInt(0)\n    if int(n) < 0 or int(k) < 0:\n        return ModInt(0)\n    if fac[0] == 0:\n        COMinit()\n    tmp = ModInt(finv[int(k)] * finv[int(n - k)])\n    tmp *= fac[int(n)]\n    return tmp\n\n\n        \nif __name__ == \"__main__\":\n    n,k = map(int,input().split())\n    k -= 1\n    print(cmb(n+k,k))\n"
  },
  {
    "language": "Python",
    "code": "#!python3\n\nfrom functools import lru_cache\n\niim = lambda: map(int, input().rstrip().split())\n\ndef cmb(a, b):\n    if a == b or b == 0: return 1\n    c = a - b\n    if b > c:\n        return cmb(a, c)\n\n    ans = 1\n    for i in range(a, a - b, -1):\n        ans *= i\n    from math import factorial\n    return ans // factorial(b)\n\ndef resolve():\n    N, K = iim()\n    mod = 10**9 + 7\n\n    print(cmb(N+K-1, N) % mod)\n\nif __name__ == \"__main__\":\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "n, k = map(int, input().split( ))\nmod = 10**9+7\n\ndef chs(s,t,mod):\n    nume =  1\n    for i in range(s-t+1,s+1):\n        nume *= i\n        nume %= mod\n    deno = 1\n    for i in range(1,t+1):\n        deno *= i\n        deno %= mod\n    deno = pow(deno,mod-2,mod)\n    \n    return (nume*deno%mod)\n\nans = chs(n+k-1,n,mod)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: map(int, sys.stdin.readline().split())\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\ndef prepare(n, MOD):\n    # 1! - n! の計算\n    f = 1\n    factorials = [1]  # 0!の分\n    for m in range(1, n + 1):\n        f *= m\n        f %= MOD\n        factorials.append(f)\n    # n!^-1 の計算\n    inv = pow(f, MOD - 2, MOD)\n    # n!^-1 - 1!^-1 の計算\n    invs = [1] * (n + 1)\n    invs[n] = inv\n    for m in range(n, 1, -1):\n        inv *= m\n        inv %= MOD\n        invs[m - 1] = inv\n\n    return factorials, invs\n\n\ndef main():\n    n, k = ns()\n\n    # 使い方\n    facts, invs = prepare(n + k - 1, MOD)\n\n    tmp = facts[n + k - 1] * invs[k - 1] * invs[n] % MOD\n    print(tmp)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "class Combination:\n    def __init__(self, n_max, mod=10**9+7):\n        # O(n_max + log(mod))\n        self.mod = mod\n        f = 1\n        self.fac = fac = [f]\n        for i in range(1, n_max+1):\n            f = f * i % mod\n            fac.append(f)\n        f = pow(f, mod-2, mod)\n        self.facinv = facinv = [f]\n        for i in range(n_max, 0, -1):\n            f = f * i % mod\n            facinv.append(f)\n        facinv.reverse()\n\n    def __call__(self, n, r):  # self.C と同じ\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def C(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def P(self, n, r):\n        if not 0 <= r <= n: return 0\n        return self.fac[n] * self.facinv[n-r] % self.mod\n\n    def H(self, n, r):\n        if n == 0 and r > 0: return 0\n        return self.fac[n+r-1] * self.facinv[r] % self.mod * self.facinv[n-1] % self.mod\n\n    def rising_factorial(self, n, r):  # 上昇階乗冪 n * (n+1) * ... * (n+r-1)\n        return self.fac[n+r-1] * self.facinv[n-1] % self.mod\n\n    def stirling_first(self, n, k):  # 第 1 種スターリング数  lru_cache を使うと O(nk)  # n 要素を k 個の巡回列に分割する場合の数\n        if n == k: return 1\n        if k == 0: return 0\n        return (self.stirling_first(n-1, k-1) + (n-1)*self.stirling_first(n-1, k)) % self.mod\n\n    def stirling_second(self, n, k):  # 第 2 種スターリング数 O(k + log(n))  # n 要素を区別のない k グループに分割する場合の数\n        if n == k: return 1  # n==k==0 のときのため\n        return self.facinv[k] * sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def balls_and_boxes_3(self, n, k):  # n 要素を区別のある k グループに分割する場合の数  O(k + log(n))\n        return sum((-1)**(k-m) * self.C(k, m) * pow(m, n, self.mod) for m in range(1, k+1)) % self.mod\n\n    def bernoulli(self, n):  # ベルヌーイ数  lru_cache を使うと O(n**2 * log(mod))\n        if n == 0: return 1\n        if n % 2 and n >= 3: return 0  # 高速化\n        return (- pow(n+1, self.mod-2, self.mod) * sum(self.C(n+1, k) * self.bernoulli(k) % self.mod for k in range(n))) % self.mod\n\n    def faulhaber(self, k, n):  # べき乗和 0^k + 1^k + ... + (n-1)^k\n        # bernoulli に lru_cache を使うと O(k**2 * log(mod))  bernoulli が計算済みなら O(k * log(mod))\n        return pow(k+1, self.mod-2, self.mod) * sum(self.C(k+1, j) * self.bernoulli(j) % self.mod * pow(n, k-j+1, self.mod) % self.mod for j in range(k+1)) % self.mod\n\n    def lah(self, n, k):  # n 要素を k 個の空でない順序付き集合に分割する場合の数  O(1)\n        return self.C(n-1, k-1) * self.fac[n] % self.mod * self.facinv[k] % self.mod\n\n    def bell(self, n, k):  # n 要素を k 個以下に分割する場合の数  O(k**2 + k*log(mod))\n        return sum(self.stirling_second(n, j) for j in range(1, k+1)) % self.mod\n\nmod = 10**9+7\ncomb = Combination(2000)\nn, k = map(int, input().split())\nprint(comb.H(k, n))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nEPS = 10 ** -10\n\nclass ModTools:\n    \"\"\" 階乗・逆元用のテーブルを構築する \"\"\"\n\n    def __init__(self, MAX, MOD):\n        \n        MAX += 1\n        self.MAX = MAX\n        self.MOD = MOD\n        factorial = [1] * MAX\n        factorial[0] = factorial[1] = 1\n        for i in range(2, MAX):\n            factorial[i] = factorial[i-1] * i % MOD\n        inverse = [1] * MAX\n        inverse[MAX-1] = pow(factorial[MAX-1], MOD-2, MOD)\n        for i in range(MAX-2, -1, -1):\n            inverse[i] = inverse[i+1] * (i+1) % MOD\n        self.fact = factorial\n        self.inv = inverse\n    \n    def nCr(self, n, r):\n        \"\"\" 組み合わせ \"\"\"\n\n        if n < r: return 0\n        r = min(r, n-r)\n        numerator = self.fact[n]\n        denominator = self.inv[r] * self.inv[n-r] % self.MOD\n        return numerator * denominator % self.MOD\n\n    def nHr(self, n, r):\n        \"\"\" 重複組み合わせ \"\"\"\n\n        return self.nCr(r+n-1, r)\n\n    def nPr(self, n, r):\n        \"\"\" 順列 \"\"\"\n\n        if n < r: return 0\n        return self.fact[n] * self.inv[n-r] % self.MOD\n\n    def div(self, x, y):\n        \"\"\" MOD除算 \"\"\"\n\n        return x * pow(y, self.MOD-2, self.MOD) % self.MOD\n\nN, K = MAP()\n\nmt = ModTools(N+K+1, MOD)\nans = mt.nHr(K, N)\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\n\nclass CombByFermat:\n    def __init__(self, size, mod):\n        self.size = size\n        self.mod = mod\n        self.factrial = [1]\n        self.inverse = [1]\n        pre_f = 1\n        for i in range(1, self.size+1):\n            pre_f = (pre_f * i) % self.mod\n            self.factrial.append(pre_f)\n            self.inverse.append(pow(pre_f, self.mod-2, self.mod))\n    def comb(self, n, r):\n        if n < r:\n            return 0\n        return (self.factrial[n] * self.inverse[r] * self.inverse[n-r]) % self.mod\n\nmod = 10**9 + 7\nn,k = map(int, input().split())\ncmb = CombByFermat(n+k, mod)\nprint(cmb.comb(n+k-1, n))\n"
  },
  {
    "language": "Python",
    "code": "class Combination:\n    \"\"\"階乗とその逆元のテーブルをO(N)で事前作成し、組み合わせの計算をO(1)で行う\"\"\"\n    def __init__(self, n, MOD):\n        self.fact = [1]\n        for i in range(1, n + 1):\n            self.fact.append(self.fact[-1] * i % MOD)\n        self.inv_fact = [0] * (n + 1)\n        self.inv_fact[n] = pow(self.fact[n], MOD - 2, MOD)\n        for i in reversed(range(n)):\n            self.inv_fact[i] = self.inv_fact[i + 1] * (i + 1) % MOD\n        self.MOD = MOD\n\n    def factorial(self, k):\n        \"\"\"k!を求める O(1)\"\"\"\n        return self.fact[k]\n\n    def inverse_factorial(self, k):\n        \"\"\"k!の逆元を求める O(1)\"\"\"\n        return self.inv_fact[k]\n\n    def permutation(self, k, r):\n        \"\"\"kPrを求める O(1)\"\"\"\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r]) % self.MOD\n\n    def combination(self, k, r):\n        \"\"\"kCrを求める O(1)\"\"\"\n        if k < r:\n            return 0\n        return (self.fact[k] * self.inv_fact[k - r] * self.inv_fact[r]) % self.MOD\n\n\ndef way4(ball, box):\n    \"\"\"ball: False / box: True / constraints: None\n    -> ans = combination(box + ball - 1, ball)\n    \"\"\"\n    return comb.combination(ball + box - 1, ball)\n\n\nn, k = map(int, input().split())\nMOD = 10 ** 9 + 7\ncomb = Combination(10 ** 4, MOD)\n\nprint(way4(n, k))\n"
  },
  {
    "language": "Python",
    "code": "\n# -*- coding: utf-8 -*-\n# 文字列の入力\nimport math\nk = input()\nk = k.split()\nN = int(k[0])\nK = int(k[1])\ndef combinations_count(n, r):\n    return math.factorial(n) // (math.factorial(n - r) * math.factorial(r))\nprint(combinations_count(N+K-1, N)%(10**9+7))\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import lru_cache\nimport sys\nmod=1000000007\n\nn,k=[int(i) for i in input().split(\" \")]\n\nfacts=[1 for i in range(n+k+1)]\n\nfor i in range(1,n+k+1):\n    facts[i]=i*facts[i-1]\n\n@lru_cache()\ndef combination(i,j):\n    return facts[i]//(facts[j]*facts[i-j])\n\n\nprint(combination(n+k-1,n)%mod)\n\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef permutations_count(n, r):\n    return math.factorial(n) // math.factorial(n - r)\nN,K = map(int, input().split())\nprint(permutations_count(N+K-1,K-1)//math.factorial(K-1)%1000000007)\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nMOD = 10**9 + 7\n \np = q = 1\nfor i in range(N):\n    p = p * (N+K-1-i) % MOD\n    q = q * (i+1) % MOD\n \nprint(p * pow(q, MOD-2, MOD) % MOD)\n"
  },
  {
    "language": "Python",
    "code": "import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\nMOD = 10**9 + 7\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef combMod(n, r, p):\n    numer = 1\n    denom = 1\n    for i in range(1, r+1):\n        numer = numer * (n-r+i) % p\n        denom = denom * i % p\n    return numer * pow(denom, p-2, p) % p\n\ndef resolve():\n    n, k = LI()\n\n    ans = combMod(n + k - 1, n, MOD)\n\n    print(ans)\n\nif __name__ == '__main__':\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "n,k=map(int,input().split(\" \"))\na=1\nfor i in range(k,n+k):\n    a*=i\nfor i in range(1,n+1):\n    a//=i\nprint(a%(10**9+7))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n    \nclass Combinatorics:\n    def __init__(self, N, mod):\n        '''\n        Preprocess for calculating binomial coefficients nCr (0 <= r <= n, 0 <= n <= N)\n        over the finite field Z/(mod)Z.\n        Input:\n            N (int): maximum n\n            mod (int): a prime number. The order of the field Z/(mod)Z over which nCr is calculated.\n        '''\n        self.mod = mod\n        self.fact = {i: None for i in range(N+1)}         # n!\n        self.inverse = {i: None for i in range(1, N+1)}   # inverse of n in the field Z/(MOD)Z\n        self.fact_inverse = {i: None for i in range(N+1)} # inverse of n! in the field Z/(MOD)Z\n        \n        # preprocess\n        self.fact[0] = self.fact[1] = 1\n        self.fact_inverse[0] = self.fact_inverse[1] = 1\n        self.inverse[1] = 1\n        for i in range(2, N+1):\n            self.fact[i] = i * self.fact[i-1] % self.mod\n            q, r = divmod(self.mod, i)\n            self.inverse[i] = (- (q % self.mod) * self.inverse[r]) % self.mod\n            self.fact_inverse[i] = self.inverse[i] * self.fact_inverse[i-1] % self.mod\n    \n    def perm(self, n, r):\n        '''\n        Calculate nPr = n! / (n-r)! % mod\n        '''\n        if n < r or n < 0 or r < 0:\n            return 0\n        else:\n            return (self.fact[n] * self.fact_inverse[n-r]) % self.mod\n    \n    def binom(self, n, r):\n        '''\n        Calculate nCr = n! /(r! (n-r)!) % mod\n        '''\n        if n < r or n < 0 or r < 0:\n            return 0\n        else:\n            return self.fact[n] * (self.fact_inverse[r] * self.fact_inverse[n-r] % self.mod) % self.mod\n        \n    def hom(self, n, r):\n        '''\n        Calculate nHr = {n+r-1}Cr % mod.\n        Assign r objects to one of n classes.\n        Arrangement of r circles and n-1 partitions:\n            o o o | o o | | | o | | | o o | | o\n        '''\n        if n == 0 and r > 0:\n            return 0\n        if n >= 0 and r == 0:\n            return 1\n        return self.binom(n + r - 1, r)\n    \nn, k = map(int, input().split())\nMOD = 10**9 + 7\ncom = Combinatorics(n+k, MOD)\nans = com.hom(k, n)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\nmemo = {0:1}\n\ndef fact(x):\n  if x in memo:\n    return memo[x]\n  memo[x] = x * fact(x - 1)\n  return memo[x]\n\ndef comb(x, y):\n  return fact(x) // fact(x - y) // fact(y)\n\nn, k = map(int, input().split())\nprint(comb(n + k - 1, k - 1) % 1000000007)\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef comb(n, k):\n    if n < 0 or k < 0 or n < k: return 0\n    return math.factorial(n) // math.factorial(n-k) // math.factorial(k)\n\nn,k = map(int, input().split())\nMOD = 10 ** 9 + 7\nprint(comb(n + k - 1, k - 1) % MOD)\n\n"
  },
  {
    "language": "Python",
    "code": "class Twelvefold(): #n <= 1000程度\n    def __init__(self, n, mod, build=True):\n        self.mod = mod\n        self.fct = [0 for _ in range(n + 1)]\n        self.inv = [0 for _ in range(n + 1)]\n        self.fct[0] = 1\n        self.inv[0] = 1\n        for i in range(n):\n            self.fct[i + 1] = self.fct[i] * (i + 1) % mod\n        self.inv[n] = pow(self.fct[n], mod - 2, mod)\n        for i in range(n)[::-1]:\n            self.inv[i] = self.inv[i + 1] * (i + 1) % mod\n        if build: self.build()\n\n    def build(self):\n        self.stl = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        self.bel = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        self.prt = [[0 for j in range(n + 1)] for i in range(n + 1)]\n        self.stl[0][0] = 1\n        self.bel[0][0] = 1\n        for i in range(n):\n            for j in range(n):\n                self.stl[i + 1][j + 1] = self.stl[i][j] + (j + 1) * self.stl[i][j + 1]\n                self.stl[i + 1][j + 1] %= self.mod\n        for i in range(n):\n            for j in range(n):\n                self.bel[i + 1][j + 1] = self.bel[i + 1][j] + self.stl[i + 1][j + 1] % mod\n                self.bel[i + 1][j + 1] %= self.mod\n        for j in range(n):\n            self.prt[0][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if i - j >= 0:\n                    self.prt[i + 1][j + 1] = self.prt[i + 1][j] + self.prt[i - j][j + 1]\n                else:\n                    self.prt[i + 1][j + 1] = self.prt[i + 1][j]\n                self.prt[i + 1][j + 1] %= self.mod\n\n    def solve(self, element, subset, equate_element=False, equate_subset=False, less_than_1=False, more_than_1=False):\n        assert not less_than_1 or not more_than_1\n        n = element\n        k = subset\n        a = equate_element\n        b = equate_subset\n        c = less_than_1\n        d = more_than_1\n        id = a * 3 + b * 6 + c + d * 2\n        tw = [self.tw1, self.tw2, self.tw3, self.tw4, self.tw5, self.tw6, self.tw7, self.tw8, self.tw9, self.tw10, self.tw11, self.tw12]\n        return tw[id](n, k)\n\n    def tw1(self, n, k):\n        return pow(k, n, self.mod)\n\n    def tw2(self, n, k):\n        if k - n < 0: return 0\n        return self.fct[k] * self.inv[k - n] % self.mod\n\n    def tw3(self, n, k):\n        return self.stl[n][k] * self.fct[k] % self.mod\n\n    def tw4(self, n, k):\n        if k == 0: return 0\n        return self.fct[n + k - 1] * self.inv[n] * self.inv[k - 1] % self.mod\n\n    def tw5(self, n, k):\n        if k - n < 0: return 0\n        return self.fct[k] * self.inv[n] * self.inv[k - n] % self.mod\n\n    def tw6(self, n, k):\n        if n - k < 0 or k == 0: return 0\n        return self.fct[n - 1] * self.inv[k - 1] * self.inv[n - k]\n\n    def tw7(self, n, k):\n        return self.bel[n][k]\n\n    def tw8(self, n, k):\n        if k - n < 0: return 0\n        return 1\n\n    def tw9(self, n, k):\n        return self.stl[n][k]\n\n    def tw10(self, n, k):\n        return self.prt[n][k]\n\n    def tw11(self, n, k):\n        if k - n < 0: return 0\n        return 1\n\n    def tw12(self, n, k):\n        if n - k < 0: return 0\n        return self.prt[n - k][k]\n\nn, k = map(int, input().split())\nt = Twelvefold(2000, 10**9 + 7, 0)\nprint(t.solve(n, k, 1, 0, 0, 0))\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nMOD = 10**9 + 7\n\np = q = 1\nfor i in range(N):\n    p = p * (N+K-1-i) % MOD\n    q = q * (i+1) % MOD\n\nprint(p * pow(q, MOD-2, MOD) % MOD)\n\n"
  },
  {
    "language": "Python",
    "code": "# ball and box 4\nMOD = pow(10,9)+7\nfrom math import factorial\ndef P(n,r):\n    return factorial(n)//factorial(n-r)\ndef C(n,r):\n    return P(n,r)//factorial(r)\ndef H(n,r):\n    return C(n+r-1,r)\nn, k = map(int, input().split())\n\nprint(H(k,n)%MOD)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport sys\nimport math\nimport itertools as it\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\nMOD = 10 ** 9 + 7\n\ndef fact(n):\n    if n <= 1:\n        return 1\n    return fact(n - 1) * n\n\nn, k = map(int, raw_input().split())\nk -= 1\n\nprint fact(n + k) / fact(k) / fact(n) % MOD\n"
  },
  {
    "language": "Python",
    "code": "from math import factorial\nN, K = map(int, input().split())\nMOD = 10 ** 9 + 7\nprint(factorial(N + K - 1) * pow(factorial(N), MOD - 2, MOD) * pow(factorial(K - 1), MOD - 2, MOD) % MOD)\n\n"
  },
  {
    "language": "Python",
    "code": "N, K = map(int, input().split())\nmod = 10 ** 9 + 7\ndef mod_cmb(n, r, mod=10 ** 9 + 7):\n\tassert n >= r >= 0\n\n\tdef ex_euclid(x, y):\n\t\ta, b = 1, 0\n\t\twhile y != 0:\n\t\t\ta, b = b, (a - x // y * b)\n\t\t\tx, y = y, x % y\n\t\treturn a\n\n\tp = q = 1\n\tfor i in range(n - r + 1, n + 1):\n\t\tp *= i\n\t\tp %= mod\n\tfor i in range(2, r + 1):\n\t\tq *= i\n\t\tq %= mod\n\tp *= ex_euclid(q, mod)\n\tp %= mod\n\treturn p\nprint(mod_cmb(N+K-1,N))\n"
  },
  {
    "language": "Python",
    "code": "mod = 10**9 + 7\nfac = []\npw = []\n\nfac.append(1 % mod)\npw.append(1 % mod)\nfor i in range(1, 2000):\n    fac.append(fac[i-1]*i % mod)\n\nfor i in range(1, 1001):\n    pw.append(pow(fac[i], mod-2, mod))\n\nn, k = [int(s) for s in input().split()]\n\nprint(fac[n+k-1]*pw[n]*pw[k-1] % mod)\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\n\nif __name__ == \"__main__\":\n    n, k = map(lambda x: int(x), input().split())\n    modulo = 10 ** 9 + 7\n    ans = math.factorial(n + k - 1) // math.factorial(n) // math.factorial(k - 1)\n    print(ans % modulo)\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\npub fn modpow(x: u64, n: u64, m: u64) -> u64 {\n    let mut res = 1;\n    let mut x = x % m;\n    let mut n = n;\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * x) % m;\n        }\n        x = (x * x) % m;\n        n >>= 1;\n    }\n    res\n}\nstruct ModComb {\n    po: Vec<u64>,\n    inv: Vec<u64>,\n    max_n: u64,\n    p: u64,\n}\nimpl ModComb {\n    fn initialize(ft: &mut Self) {\n        let n = ft.max_n as usize;\n\n        ft.po[0] = 1;\n        for i in 1..n {\n            ft.po[i] = (ft.po[i-1] * i as u64) % ft.p;\n        }\n        ft.inv[n-1] = modpow(ft.po[n-1], ft.p-2, ft.p);\n        for i in (0..n-1).rev() {\n            ft.inv[i] = (ft.inv[i+1] * (i as u64 +1)) % ft.p;\n        }\n    }\n    fn new(max_n: u64, p: u64) -> Self {\n        let mut ft = Self {\n            po: vec![0; max_n as usize],\n            inv: vec![0; max_n as usize],\n            max_n: max_n,\n            p: p,\n        };\n        Self::initialize(&mut ft);\n        ft\n    }\n    fn nCk(&self, n: u64, k: u64) -> u64 {\n        if n < k { return 0; }\n        (self.nPk(n,k) * self.inv[k as usize]) % self.p \n    }\n    fn nPk(&self, n: u64, k: u64) -> u64 {\n        if n < k { return 0; }\n        self.po[n as usize] * self.inv[(n-k) as usize] % self.p\n    }\n    fn nHk(&self, n: u64, k: u64) -> u64 {\n        if n==0 && k==0 { return 1 }\n        self.nCk(n+k-1,k)\n    }\n}\nfn solve() {\n    input! { n: u64, k: u64 }\n    let p = 1_000_000_007;\n    let comb = ModComb::new(2000, p);\n    println!(\"{}\", comb.nHk(n+1, k-1));\n}\n"
  }
]