[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "int waysToDistribute(int n, int k) {\n    const int MOD = 1000000007;\n    int dp[n + 1][k + 1];\n    memset(dp, 0, sizeof(dp));\n    \n    dp[0][0] = 1;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = (1LL * dp[i - 1][j - 1] + 1LL * j * dp[i - 1][j]) % MOD;\n        }\n    }\n    \n    return dp[n][k];\n}",
    "timestamp": "2025-08-05 22:18:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#define MOD 1000000007\n\nlong long power(long long a, long long b) {\n    long long result = 1;\n    a %= MOD;\n    while (b > 0) {\n        if (b % 2 == 1) {\n            result = (result * a) % MOD;\n        }\n        a = (a * a) % MOD;\n        b /= 2;\n    }\n    return result;\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    printf(\"%lld\\n\", power(k, n));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:18:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint comb(int n, int k, vector<vector<int>>& memo) {\n    if (k == 0 || k == n) return 1;\n    if (memo[n][k] != -1) return memo[n][k];\n    memo[n][k] = (comb(n - 1, k - 1, memo) + comb(n - 1, k, memo)) % MOD;\n    return memo[n][k];\n}\n\nint distributeBalls(int n, int k) {\n    int N = n + k - 1;\n    int K = k - 1;\n    vector<vector<int>> memo(N + 1, vector<int>(K + 1, -1));\n    return comb(N, K, memo);\n}",
    "timestamp": "2025-08-05 22:18:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class BallDistribution {\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n        System.out.println(calculateCombination(n + k - 1, k - 1));\n    }\n\n    private static long calculateCombination(int n, int k) {\n        if (k > n - k) {\n            k = n - k;\n        }\n        long res = 1;\n        for (int i = 1; i <= k; i++) {\n            res = res * (n - k + i) % MOD;\n            res = res * modInverse(i) % MOD;\n        }\n        return res;\n    }\n\n    private static long modInverse(int a) {\n        return power(a, MOD - 2);\n    }\n\n    private static long power(long a, long b) {\n        long res = 1;\n        a = a % MOD;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                res = res * a % MOD;\n            }\n            a = a * a % MOD;\n            b = b >> 1;\n        }\n        return res;\n    }\n}",
    "timestamp": "2025-08-05 22:18:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Solution {\n    public int waysToDivide(int n, int k) {\n        final int MOD = 1_000_000_007;\n        long[][] dp = new long[n + 1][k + 1];\n        \n        dp[0][0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= k; j++) {\n                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD;\n            }\n        }\n        \n        return (int)dp[n][k];\n    }\n}",
    "timestamp": "2025-08-05 22:19:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    int waysToDivide(int n, int k) {\n        const int MOD = 1e9 + 7;\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n        \n        dp[0][0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= k; j++) {\n                dp[i][j] = (dp[i][j-1] + dp[i-1][j]) % MOD;\n            }\n        }\n        \n        return dp[n][k];\n    }\n};",
    "timestamp": "2025-08-05 22:19:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ways(n, k):\n    MOD = 10**9 + 7\n    \n    def mod_inverse(x, mod):\n        return pow(x, mod - 2, mod)\n    \n    def binomial_coefficient(n, k, mod):\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        num = 1\n        denom = 1\n        for i in range(k):\n            num = num * (n - i) % mod\n            denom = denom * (i + 1) % mod\n        return num * mod_inverse(denom, mod) % mod\n\n    return binomial_coefficient(n + k - 1, k - 1, MOD)\n\n# Example usage:\nn = 5  # number of balls\nk = 3  # number of boxes\nresult = count_ways(n, k)\nprint(result)",
    "timestamp": "2025-08-13 09:55:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.math.BigInteger;\n\npublic class BallDistribution {\n\n    public static int countWays(int n, int k) {\n        final int MOD = 1_000_000_007;\n        return binomialCoefficient(n + k - 1, k - 1).mod(BigInteger.valueOf(MOD)).intValue();\n    }\n\n    private static BigInteger binomialCoefficient(int n, int k) {\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < k; i++) {\n            result = result.multiply(BigInteger.valueOf(n - i));\n            result = result.divide(BigInteger.valueOf(i + 1));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        int n = 5;\n        int k = 3;\n        System.out.println(countWays(n, k)); // Output the number of ways\n    }\n}",
    "timestamp": "2025-08-13 09:55:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\nlong long mod_pow(long long base, long long exp, long long mod) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nlong long mod_inv(long long x, long long mod) {\n    return mod_pow(x, mod - 2, mod);\n}\n\nlong long binomial_coefficient(int n, int k, long long mod) {\n    if (k > n) return 0;\n    long long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result = (result * (n - i + 1)) % mod;\n        result = (result * mod_inv(i, mod)) % mod;\n    }\n    return result;\n}\n\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    printf(\"%lld\\n\", binomial_coefficient(n + k - 1, k - 1, MOD));\n    return 0;\n}",
    "timestamp": "2025-08-13 09:55:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_distributions(n, k):\n    MOD = 10**9 + 7\n    \n    # Initialize DP table\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    # Base case: 1 way to distribute 0 balls into 1 box\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            # Place ball in an existing box\n            dp[i][j] = dp[i-1][j-1]\n            \n            # Place ball in an already filled box\n            dp[i][j] += dp[i-1][j] * j\n            \n            dp[i][j] %= MOD\n    \n    return dp[n][k]",
    "timestamp": "2025-08-13 09:55:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef distribute_balls(n, k):\n    # The problem is equivalent to combinations with repetition: C(n + k - 1, k - 1)\n    # We compute this using the multiplicative formula\n    if k == 0:\n        return 0\n    numerator = 1\n    denominator = 1\n    for i in range(1, k):\n        numerator *= (n + k - i)\n        denominator *= i\n        # To avoid large intermediate results, we can take modulo here, but division complicates things\n        # So we'll compute numerator and denominator separately and then divide\n    # Since MOD is prime, we can use Fermat's little theorem for division under modulo\n    # But first compute numerator and denominator modulo MOD, then multiply numerator by denominator^(MOD-2) mod MOD\n    numerator %= MOD\n    denominator %= MOD\n    inv_denominator = pow(denominator, MOD - 2, MOD)\n    return (numerator * inv_denominator) % MOD",
    "timestamp": "2025-08-13 09:55:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\n// Function to compute x^y % p in O(log y)\nlong long mod_exp(long long x, long long y, int p) {\n    long long result = 1;\n    x = x % p; // Update x if it is more than or equal to p\n    while (y > 0) {\n        if (y & 1) // If y is odd, multiply x with result\n            result = (result * x) % p;\n        y = y >> 1; // y = y/2\n        x = (x * x) % p; // Change x to x^2\n    }\n    return result;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    // Calculate k^n % MOD\n    long long result = mod_exp(k, n, MOD);\n    \n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:55:54"
  }
]