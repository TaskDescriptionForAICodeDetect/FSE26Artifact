[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 200\n#define MAX_M 200\n\nint N, M, Q;\nchar horizontal_roads[MAX_N][2];\nchar vertical_roads[MAX_M][2];\nint dist[MAX_N + 1][MAX_M + 1];\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid bfs(int start_x, int start_y) {\n    for (int i = 0; i <= N; i++) {\n        for (int j = 0; j <= M; j++) {\n            dist[i][j] = INT_MAX;\n        }\n    }\n    \n    dist[start_x][start_y] = 0;\n    \n    for (int step = 0; step < N + M; step++) {\n        for (int x = 0; x <= N; x++) {\n            for (int y = 0; y <= M; y++) {\n                if (dist[x][y] == step) {\n                    // Move east\n                    if (x < N && horizontal_roads[x][1] == '1') {\n                        dist[x+1][y] = min(dist[x+1][y], step + 1);\n                    }\n                    \n                    // Move west\n                    if (x > 0 && horizontal_roads[x-1][1] == '1') {\n                        dist[x-1][y] = min(dist[x-1][y], step + 1);\n                    }\n                    \n                    // Move north\n                    if (y < M && vertical_roads[y][1] == '1') {\n                        dist[x][y+1] = min(dist[x][y+1], step + 1);\n                    }\n                    \n                    // Move south\n                    if (y > 0 && vertical_roads[y-1][1] == '1') {\n                        dist[x][y-1] = min(dist[x][y-1], step + 1);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &Q);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", horizontal_roads[i]);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%s\", vertical_roads[i]);\n    }\n    \n    while (Q--) {\n        int sx, sy, gx, gy;\n        scanf(\"%d %d %d %d\", &sx, &sy, &gx, &gy);\n        \n        bfs(sx, sy);\n        \n        if (dist[gx][gy] == INT_MAX) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", dist[gx][gy]);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:53:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    char S[N+1], T[M+1];\n    scanf(\"%s %s\", S, T);\n\n    int Q;\n    scanf(\"%d\", &Q);\n    Point *queries = malloc(Q * sizeof(Point));\n    for (int i = 0; i < Q; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        queries[i].x = a;\n        queries[i].y = b;\n    }\n\n    // Precompute prefix sums for S and T\n    int *prefixS = malloc((N + 1) * sizeof(int));\n    int *prefixT = malloc((M + 1) * sizeof(int));\n    prefixS[0] = 0;\n    for (int i = 1; i <= N; i++) {\n        prefixS[i] = prefixS[i-1] + (S[i-1] == 'R' ? 1 : 0);\n    }\n    prefixT[0] = 0;\n    for (int i = 1; i <= M; i++) {\n        prefixT[i] = prefixT[i-1] + (T[i-1] == 'D' ? 1 : 0);\n    }\n\n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int a = queries[q].x;\n        int b = queries[q].y;\n\n        if (a == 1 && b == 1) {\n            printf(\"0\\n\");\n            continue;\n        }\n\n        int min_dist = INT_MAX;\n\n        // Check all possible intermediate points\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= M; j++) {\n                int dist1 = abs(i - a) + abs(j - 1);\n                int dist2 = abs(i - 1) + abs(j - b);\n                int total = dist1 + dist2;\n\n                if (S[i-1] == 'R' && T[j-1] == 'D') {\n                    if (total < min_dist) {\n                        min_dist = total;\n                    }\n                }\n            }\n        }\n\n        if (min_dist != INT_MAX) {\n            printf(\"%d\\n\", min_dist);\n        } else {\n            printf(\"-1\\n\");\n        }\n    }\n\n    free(queries);\n    free(prefixS);\n    free(prefixT);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:53:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nconst int INF = INT_MAX;\n\nint main() {\n    int N, M;\n    string S, T;\n    cin >> N >> M >> S >> T;\n\n    vector<vector<int>> east(N + 2, vector<int>(M + 2, INF));\n    vector<vector<int>> west(N + 2, vector<int>(M + 2, INF));\n    vector<vector<int>> north(N + 2, vector<int>(M + 2, INF));\n    vector<vector<int>> south(N + 2, vector<int>(M + 2, INF));\n\n    queue<pair<int, int>> q;\n\n    // Initialize east roads\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            if (S[i-1] == '>' && j < M) {\n                east[i][j] = 1;\n            } else if (S[i-1] == '<' && j > 1) {\n                west[i][j] = 1;\n            }\n        }\n    }\n\n    // Initialize north roads\n    for (int j = 1; j <= M; ++j) {\n        for (int i = 1; i <= N; ++i) {\n            if (T[j-1] == 'v' && i < N) {\n                south[i][j] = 1;\n            } else if (T[j-1] == '^' && i > 1) {\n                north[i][j] = 1;\n            }\n        }\n    }\n\n    vector<vector<int>> dist(N + 2, vector<int>(M + 2, INF));\n    dist[1][1] = 0;\n    q.push({1, 1});\n\n    while (!q.empty()) {\n        auto [i, j] = q.front(); q.pop();\n        if (i < N && south[i][j] == 1 && dist[i+1][j] > dist[i][j] + 1) {\n            dist[i+1][j] = dist[i][j] + 1;\n            q.push({i+1, j});\n        }\n        if (i > 1 && north[i][j] == 1 && dist[i-1][j] > dist[i][j] + 1) {\n            dist[i-1][j] = dist[i][j] + 1;\n            q.push({i-1, j});\n        }\n        if (j < M && east[i][j] == 1 && dist[i][j+1] > dist[i][j] + 1) {\n            dist[i][j+1] = dist[i][j] + 1;\n            q.push({i, j+1});\n        }\n        if (j > 1 && west[i][j] == 1 && dist[i][j-1] > dist[i][j] + 1) {\n            dist[i][j-1] = dist[i][j] + 1;\n            q.push({i, j-1});\n        }\n    }\n\n    int Q;\n    cin >> Q;\n    while (Q--) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        if (dist[a][b] == INF || dist[c][d] == INF) {\n            cout << -1 << endl;\n        } else {\n            cout << abs(dist[c][d] - dist[a][b]) << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:54:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static int N, M;\n    static int[] dx = {1, 0, -1, 0};\n    static int[] dy = {0, 1, 0, -1};\n    static int[][] dist;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        String S = br.readLine();\n        String T = br.readLine();\n        int totalNodes = N * M;\n        dist = new int[totalNodes][totalNodes];\n        for (int i = 0; i < totalNodes; i++) {\n            Arrays.fill(dist[i], -1);\n            dist[i][i] = 0;\n        }\n\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < M; y++) {\n                int u = x * M + y;\n                char c1 = S.charAt(x);\n                char c2 = T.charAt(y);\n                if (c1 == '>') {\n                    if (y + 1 < M) {\n                        int v = x * M + (y + 1);\n                        dist[u][v] = 1;\n                    }\n                } else if (c1 == '<') {\n                    if (y - 1 >= 0) {\n                        int v = x * M + (y - 1);\n                        dist[u][v] = 1;\n                    }\n                }\n                if (c2 == 'v') {\n                    if (x + 1 < N) {\n                        int v = (x + 1) * M + y;\n                        dist[u][v] = 1;\n                    }\n                } else if (c2 == '^') {\n                    if (x - 1 >= 0) {\n                        int v = (x - 1) * M + y;\n                        dist[u][v] = 1;\n                    }\n                }\n            }\n        }\n\n        // Floyd-Warshall\n        for (int k = 0; k < totalNodes; k++) {\n            for (int i = 0; i < totalNodes; i++) {\n                for (int j = 0; j < totalNodes; j++) {\n                    if (dist[i][k] != -1 && dist[k][j] != -1) {\n                        if (dist[i][j] == -1 || dist[i][j] > dist[i][k] + dist[k][j]) {\n                            dist[i][j] = dist[i][k] + dist[k][j];\n                        }\n                    }\n                }\n            }\n        }\n\n        int Q = Integer.parseInt(br.readLine());\n        StringBuilder sb = new StringBuilder();\n        for (int q = 0; q < Q; q++) {\n            st = new StringTokenizer(br.readLine());\n            int x1 = Integer.parseInt(st.nextToken()) - 1;\n            int y1 = Integer.parseInt(st.nextToken()) - 1;\n            int x2 = Integer.parseInt(st.nextToken()) - 1;\n            int y2 = Integer.parseInt(st.nextToken()) - 1;\n            int u = x1 * M + y1;\n            int v = x2 * M + y2;\n            sb.append(dist[u][v]).append(\"\\n\");\n        }\n        System.out.print(sb.toString());\n    }\n}",
    "timestamp": "2025-08-05 22:55:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RoadNetwork {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        \n        String S = sc.next();\n        String T = sc.next();\n        \n        int Q = sc.nextInt();\n        \n        Map<String, List<String>> graph = new HashMap<>();\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                String node = i + \",\" + j;\n                graph.put(node, new ArrayList<>());\n                \n                if (S.charAt(i) == 'E' && j + 1 < M) {\n                    graph.get(node).add(i + \",\" + (j + 1));\n                }\n                if (S.charAt(i) == 'W' && j > 0) {\n                    graph.get(node).add(i + \",\" + (j - 1));\n                }\n                if (T.charAt(j) == 'N' && i + 1 < N) {\n                    graph.get(node).add((i + 1) + \",\" + j);\n                }\n                if (T.charAt(j) == 'S' && i > 0) {\n                    graph.get(node).add((i - 1) + \",\" + j);\n                }\n            }\n        }\n        \n        for (int q = 0; q < Q; q++) {\n            int sx = sc.nextInt() - 1;\n            int sy = sc.nextInt() - 1;\n            int gx = sc.nextInt() - 1;\n            int gy = sc.nextInt() - 1;\n            \n            String start = sx + \",\" + sy;\n            String goal = gx + \",\" + gy;\n            \n            int distance = bfs(graph, start, goal);\n            System.out.println(distance);\n        }\n        \n        sc.close();\n    }\n    \n    private static int bfs(Map<String, List<String>> graph, String start, String goal) {\n        Queue<String> queue = new LinkedList<>();\n        Map<String, Integer> distances = new HashMap<>();\n        \n        queue.offer(start);\n        distances.put(start, 0);\n        \n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            \n            if (current.equals(goal)) {\n                return distances.get(current);\n            }\n            \n            for (String neighbor : graph.get(current)) {\n                if (!distances.containsKey(neighbor)) {\n                    queue.offer(neighbor);\n                    distances.put(neighbor, distances.get(current) + 1);\n                }\n            }\n        }\n        \n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 22:55:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2005;\nint N, M, Q;\nvector<pair<int, int>> east_roads[MAXN];\nvector<pair<int, int>> north_roads[MAXN];\nint dist[MAXN][MAXN];\n\nvoid bfs(int sx, int sy) {\n    memset(dist, -1, sizeof(dist));\n    dist[sx][sy] = 0;\n    queue<pair<int, int>> q;\n    q.push({sx, sy});\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n\n        for (auto [nx, cost] : east_roads[x]) {\n            if (nx > x && dist[nx][y] == -1) {\n                dist[nx][y] = dist[x][y] + cost;\n                q.push({nx, y});\n            }\n        }\n\n        for (auto [ny, cost] : north_roads[y]) {\n            if (ny > y && dist[x][ny] == -1) {\n                dist[x][ny] = dist[x][y] + cost;\n                q.push({x, ny});\n            }\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> N >> M >> Q;\n    string S, T;\n    cin >> S >> T;\n\n    for (int i = 0; i < N - 1; i++) {\n        if (S[i] == 'E') {\n            east_roads[i].push_back({i+1, 1});\n        }\n    }\n\n    for (int j = 0; j < M - 1; j++) {\n        if (T[j] == 'N') {\n            north_roads[j].push_back({j+1, 1});\n        }\n    }\n\n    while (Q--) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        sx--; sy--; gx--; gy--;\n\n        bfs(sx, sy);\n        cout << dist[gx][gy] << \"\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:55:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve(N, M, S, T, queries):\n    # Create maps for east-west and north-south roads\n    east_west_map = [set() for _ in range(N + 1)]\n    north_south_map = [set() for _ in range(M + 1)]\n    \n    for i in range(N - 1):\n        if S[i] == '>':\n            east_west_map[i + 1].add(i + 2)\n        if S[i] == '<':\n            east_west_map[i + 2].add(i + 1)\n    \n    for i in range(M - 1):\n        if T[i] == '^':\n            north_south_map[i + 2].add(i + 1)\n        if T[i] == 'v':\n            north_south_map[i + 1].add(i + 2)\n    \n    def bfs(start_x, start_y, end_x, end_y):\n        queue = deque([(start_x, start_y, 0)])\n        visited = set()\n        visited.add((start_x, start_y))\n        \n        while queue:\n            x, y, dist = queue.popleft()\n            \n            if (x, y) == (end_x, end_y):\n                return dist\n            \n            if x < N and (x + 1) not in east_west_map[x]:\n                if (x + 1, y) not in visited:\n                    visited.add((x + 1, y))\n                    queue.append((x + 1, y, dist + 1))\n            \n            if x > 1 and x in east_west_map[x - 1]:\n                if (x - 1, y) not in visited:\n                    visited.add((x - 1, y))\n                    queue.append((x - 1, y, dist + 1))\n            \n            if y < M and (y + 1) not in north_south_map[y]:\n                if (x, y + 1) not in visited:\n                    visited.add((x, y + 1))\n                    queue.append((x, y + 1, dist + 1))\n            \n            if y > 1 and y in north_south_map[y - 1]:\n                if (x, y - 1) not in visited:\n                    visited.add((x, y - 1))\n                    queue.append((x, y - 1, dist + 1))\n        \n        return -1\n    \n    results = []\n    for start_x, start_y, end_x, end_y in queries:\n        results.append(bfs(start_x, start_y, end_x, end_y))\n    \n    return results\n\n# Example on how to use the function:\nN = 5\nM = 5\nS = \">>>>>\"\nT = \"vv^^v\"\nqueries = [(1, 1, 5, 5), (2, 3, 4, 1), (1, 4, 5, 2)]\nprint(solve(N, M, S, T, queries))",
    "timestamp": "2025-08-13 12:53:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TakahaShiCity {\n\n    private static final int INF = Integer.MAX_VALUE;\n\n    public static int[] minDistances(int N, int M, String S, String T, List<int[]> queries) {\n        int[][] dist = new int[N][M];\n\n        // Initialize distances to INF\n        for (int i = 0; i < N; i++) {\n            Arrays.fill(dist[i], INF);\n        }\n\n        // Breadth-First Search (BFS) from each point\n        for (int y = 0; y < N; y++) {\n            for (int x = 0; x < M; x++) {\n                bfs(y, x, N, M, S, T, dist);\n            }\n        }\n\n        int numQueries = queries.size();\n        int[] results = new int[numQueries];\n        for (int i = 0; i < numQueries; i++) {\n            int[] query = queries.get(i);\n            int startX = query[0], startY = query[1], endX = query[2], endY = query[3];\n            results[i] = (dist[startY][startX] == INF) ? -1 : dist[startY][startX];\n        }\n        return results;\n    }\n\n    private static void bfs(int sy, int sx, int N, int M, String S, String T, int[][] dist) {\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{sy, sx});\n        dist[sy][sx] = 0;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int cy = current[0];\n            int cx = current[1];\n\n            int nextDist = dist[cy][cx] + 1;\n\n            // Possible transitions\n            if (S.charAt(cy) == '>') {\n                int nx = cx + 1;\n                if (0 <= nx && nx < M && nextDist < dist[cy][nx]) {\n                    dist[cy][nx] = nextDist;\n                    queue.offer(new int[]{cy, nx});\n                }\n            }\n            if (S.charAt(cy) == '<') {\n                int nx = cx - 1;\n                if (0 <= nx && nx < M && nextDist < dist[cy][nx]) {\n                    dist[cy][nx] = nextDist;\n                    queue.offer(new int[]{cy, nx});\n                }\n            }\n            if (T.charAt(cx) == 'v') {\n                int ny = cy + 1;\n                if (0 <= ny && ny < N && nextDist < dist[ny][cx]) {\n                    dist[ny][cx] = nextDist;\n                    queue.offer(new int[]{ny, cx});\n                }\n            }\n            if (T.charAt(cx) == '^') {\n                int ny = cy - 1;\n                if (0 <= ny && ny < N && nextDist < dist[ny][cx]) {\n                    dist[ny][cx] = nextDist;\n                    queue.offer(new int[]{ny, cx});\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage:\n        int N = 3, M = 3;\n        String S = \"><>\";\n        String T = \"v^v\";\n        List<int[]> queries = Arrays.asList(new int[]{0, 0, 2, 2}, new int[]{1, 1, 0, 0});\n\n        int[] result = minDistances(N, M, S, T, queries);\n        for (int res : result) {\n            System.out.println(res);\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:53:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 1000000000\n\nint main() {\n    int N, M, Q, i, j, x1, y1, x2, y2;\n    char S[1001], T[1001];\n    \n    scanf(\"%d %d %d\", &N, &M, &Q);\n    scanf(\"%s\", S);\n    scanf(\"%s\", T);\n    \n    while (Q--) {\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        \n        if (x1 == x2 && y1 == y2) {\n            printf(\"0\\n\");\n            continue;\n        }\n        \n        // Check east-west connectivity\n        int east_west_connected;\n        if (S[x1-1] == '>' && x1 < x2) {\n            east_west_connected = 1;\n        } else if (S[x1-1] == '<' && x1 > x2) {\n            east_west_connected = 1;\n        } else {\n            east_west_connected = 0;\n        }\n        \n        // Check north-south connectivity\n        int north_south_connected;\n        if (T[y1-1] == 'v' && y1 < y2) {\n            north_south_connected = 1;\n        } else if (T[y1-1] == '^' && y1 > y2) {\n            north_south_connected = 1;\n        } else {\n            north_south_connected = 0;\n        }\n        \n        if (east_west_connected && north_south_connected) {\n            printf(\"%d\\n\", abs(x2 - x1) + abs(y2 - y1));\n        } else {\n            printf(\"-1\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:54:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class TakahaShiRoads {\n    constructor(S, T) {\n        this.N = S.length;\n        this.M = T.length;\n        this.eastWest = S;\n        this.northSouth = T;\n    }\n\n    minTravelDistance(q, x1, y1, x2, y2) {\n        const distX = (x2 > x1 && this.eastWest[x1] === '>') || (x2 < x1 && this.eastWest[x2] === '<') ? Math.abs(x2 - x1) : Infinity;\n        const distY = (y2 > y1 && this.northSouth[y1] === 'v') || (y2 < y1 && this.northSouth[y2] === '^') ? Math.abs(y2 - y1) : Infinity;\n\n        const distance = (distX === Infinity || distY === Infinity) ? -1 : distX + distY;\n        return distance;\n    }\n}\n\nfunction solve(N, M, S, T, Q, queries) {\n    const roads = new TakahaShiRoads(S, T);\n\n    const results = [];\n    for (let i = 0; i < Q; i++) {\n        const [x1, y1, x2, y2] = queries[i];\n        results.push(roads.minTravelDistance(Q, x1, y1, x2, y2));\n    }\n    return results;\n}",
    "timestamp": "2025-08-13 12:54:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_road_navigation(N, M, S, T, Q, queries):\n    graph = defaultdict(list)\n    \n    # Build graph for east-west roads\n    for i in range(N):\n        for j in range(M):\n            if S[i] == '>':\n                graph[(i, j)].append((i, j+1))\n            else:\n                graph[(i, j+1)].append((i, j))\n    \n    # Build graph for north-south roads\n    for j in range(M):\n        for i in range(N):\n            if T[j] == 'v':\n                graph[(i, j)].append((i+1, j))\n            else:\n                graph[(i+1, j)].append((i, j))\n    \n    def bfs(start, end):\n        queue = deque([(start, 0)])\n        visited = set([start])\n        \n        while queue:\n            (x, y), dist = queue.popleft()\n            \n            if (x, y) == end:\n                return dist\n            \n            for nx, ny in graph[(x, y)]:\n                if (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), dist+1))\n        \n        return -1\n    \n    results = []\n    for start_x, start_y, end_x, end_y in queries:\n        results.append(bfs((start_x, start_y), (end_x, end_y)))\n    \n    return results\n\ndef main():\n    N, M = map(int, input().split())\n    S = input()\n    T = input()\n    Q = int(input())\n    \n    queries = []\n    for _ in range(Q):\n        queries.append(list(map(int, input().split())))\n    \n    results = solve_road_navigation(N, M, S, T, Q, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:54:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class Solution {\n    constructor(N, M, S, T) {\n        this.N = N;\n        this.M = M;\n        this.S = S;\n        this.T = T;\n        this.graph = Array.from({ length: (N + 1) * (M + 1) }, () => []);\n        this.buildGraph();\n    }\n\n    buildGraph() {\n        // Horizontal roads\n        for (let i = 1; i <= this.N; i++) {\n            for (let j = 1; j <= this.M; j++) {\n                const curr = this.getNodeIndex(i, j);\n                if (this.S[i - 1] === '>' && j < this.M) {\n                    const next = this.getNodeIndex(i, j + 1);\n                    this.graph[curr].push([next, 1]);\n                }\n                if (this.S[i - 1] === '<' && j > 1) {\n                    const next = this.getNodeIndex(i, j - 1);\n                    this.graph[curr].push([next, 1]);\n                }\n            }\n        }\n\n        // Vertical roads\n        for (let j = 1; j <= this.M; j++) {\n            for (let i = 1; i <= this.N; i++) {\n                const curr = this.getNodeIndex(i, j);\n                if (this.T[j - 1] === 'v' && i < this.N) {\n                    const next = this.getNodeIndex(i + 1, j);\n                    this.graph[curr].push([next, 1]);\n                }\n                if (this.T[j - 1] === '^' && i > 1) {\n                    const next = this.getNodeIndex(i - 1, j);\n                    this.graph[curr].push([next, 1]);\n                }\n            }\n        }\n    }\n\n    getNodeIndex(i, j) {\n        return (i - 1) * (this.M + 1) + j;\n    }\n\n    shortestPath(startX, startY, endX, endY) {\n        const start = this.getNodeIndex(startX, startY);\n        const end = this.getNodeIndex(endX, endY);\n        const dist = new Array((this.N + 1) * (this.M + 1)).fill(Infinity);\n        const pq = new MinPriorityQueue();\n\n        dist[start] = 0;\n        pq.push([0, start]);\n\n        while (!pq.isEmpty()) {\n            const [currDist, curr] = pq.pop();\n\n            if (currDist > dist[curr]) continue;\n            if (curr === end) return currDist;\n\n            for (const [next, weight] of this.graph[curr]) {\n                const newDist = currDist + weight;\n                if (newDist < dist[next]) {\n                    dist[next] = newDist;\n                    pq.push([newDist, next]);\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n\nclass MinPriorityQueue {\n    constructor() {\n        this.heap = [];\n    }\n\n    push(val) {\n        this.heap.push(val);\n        this.bubbleUp(this.heap.length - 1);\n    }\n\n    pop() {\n        const min = this.heap[0];\n        const last = this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heap[0] = last;\n            this.bubbleDown(0);\n        }\n        return min;\n    }\n\n    bubbleUp(index) {\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            if (this.heap[parentIndex][0] <= this.heap[index][0]) break;\n            this.swap(index, parentIndex);\n            index = parentIndex;\n        }\n    }\n\n    bubbleDown(index) {\n        const lastIndex = this.heap.length - 1;\n        while (true) {\n            const leftIndex = 2 * index + 1;\n            const rightIndex = 2 * index + 2;\n            let smallestIndex = index;\n\n            if (leftIndex <= lastIndex && this.heap[leftIndex][0] < this.heap[smallestIndex][0]) {\n                smallestIndex = leftIndex;\n            }\n\n            if (rightIndex <= lastIndex && this.heap[rightIndex][0] < this.heap[smallestIndex][0]) {\n                smallestIndex = rightIndex;\n            }\n\n            if (smallestIndex === index) break;\n            this.swap(index, smallestIndex);\n            index = smallestIndex;\n        }\n    }\n\n    swap(i, j) {\n        [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n    }\n\n    isEmpty() {\n        return this.heap.length === 0;\n    }\n}",
    "timestamp": "2025-08-13 12:54:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N, M = map(int, input[ptr:ptr+2])\n    ptr +=2\n    S = input[ptr]\n    ptr +=1\n    T = input[ptr]\n    ptr +=1\n    Q = int(input[ptr])\n    ptr +=1\n    \n    # Directions: N, S, E, W\n    # For each intersection (i,j), we can move in directions based on S[i] and T[j]\n    # S[i] is direction for east-west road (i-th row)\n    # T[j] is direction for north-south road (j-th column)\n    \n    # Precompute the adjacency list\n    # Each node is (i,j), 0-based\n    adj = {}\n    for i in range(N):\n        for j in range(M):\n            adj[(i,j)] = []\n            # Check east-west road\n            if S[i] == 'R':\n                if j +1 < M:\n                    adj[(i,j)].append( (i, j+1) )\n            elif S[i] == 'L':\n                if j -1 >=0:\n                    adj[(i,j)].append( (i, j-1) )\n            # Check north-south road\n            if T[j] == 'D':\n                if i +1 < N:\n                    adj[(i,j)].append( (i+1, j) )\n            elif T[j] == 'U':\n                if i -1 >=0:\n                    adj[(i,j)].append( (i-1, j) )\n    \n    # Process queries with BFS for each query (since N and M are up to 1000, Q up to 1e5, but BFS per query is O(N*M) which is 1e6 per query, total 1e11 operations is too slow)\n    # Hence, precompute all pairs shortest path using BFS from each node (O(N*M * N*M) = 1e12 is also too slow)\n    # So, the solution is to use BFS for each query, but with optimizations\n    \n    # However, given constraints, the below approach is not feasible for large N and M, but there's no better approach provided in the problem statement\n    # So, proceed with BFS per query\n    \n    output = []\n    for _ in range(Q):\n        a, b, c, d = map(int, input[ptr:ptr+4])\n        ptr +=4\n        start = (a-1, b-1)\n        end = (c-1, d-1)\n        \n        if start == end:\n            output.append(0)\n            continue\n        \n        visited = {}\n        q = deque()\n        q.append( (start[0], start[1], 0) )\n        visited[start] = True\n        found = -1\n        \n        while q:\n            i, j, dist = q.popleft()\n            for (ni, nj) in adj[(i,j)]:\n                if (ni, nj) == end:\n                    found = dist +1\n                    q = deque()  # To break out of the loop\n                    break\n                if (ni, nj) not in visited:\n                    visited[(ni, nj)] = True\n                    q.append( (ni, nj, dist +1) )\n            if found != -1:\n                break\n        output.append(found)\n    \n    print('\\n'.join(map(str, output)))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:54:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const main = (input) => {\n    const lines = input.trim().split('\\n');\n    const [N, M] = lines[0].split(' ').map(Number);\n    const S = lines[1].trim();\n    const T = lines[2].trim();\n    const Q = parseInt(lines[3], 10);\n    const queries = lines.slice(4, 4 + Q).map(line => line.split(' ').map(Number));\n\n    // Precompute prefix sums for S and T\n    const prefixS = new Array(N + 1).fill(0);\n    const prefixT = new Array(M + 1).fill(0);\n\n    for (let i = 0; i < N; i++) {\n        prefixS[i + 1] = prefixS[i] + (S[i] === 'E' ? 1 : 0);\n    }\n    for (let i = 0; i < M; i++) {\n        prefixT[i + 1] = prefixT[i] + (T[i] === 'S' ? 1 : 0);\n    }\n\n    const results = [];\n    for (const [a, b, c, d] of queries) {\n        const x1 = a - 1;\n        const x2 = c - 1;\n        const y1 = b - 1;\n        const y2 = d - 1;\n\n        if (x1 > x2 || y1 > y2) {\n            results.push(-1);\n            continue;\n        }\n\n        const eastCount = prefixS[x2 + 1] - prefixS[x1];\n        const southCount = prefixT[y2 + 1] - prefixT[y1];\n\n        if (eastCount === 0 && southCount === 0) {\n            results.push(0);\n        } else if (eastCount > 0 && southCount > 0) {\n            results.push(x2 - x1 + y2 - y1);\n        } else if (eastCount > 0) {\n            if (T[y1] === 'S' || T[y2] === 'N') {\n                results.push(x2 - x1 + y2 - y1);\n            } else {\n                results.push(-1);\n            }\n        } else if (southCount > 0) {\n            if (S[x1] === 'E' || S[x2] === 'W') {\n                results.push(x2 - x1 + y2 - y1);\n            } else {\n                results.push(-1);\n            }\n        } else {\n            results.push(-1);\n        }\n    }\n\n    console.log(results.join('\\n'));\n};\n\n// Example usage:\n// const input = `3 3\\nEWW\\nNSN\\n3\\n1 1 3 3\\n1 1 1 3\\n2 2 2 2`;\n// main(input);",
    "timestamp": "2025-08-13 12:55:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    string S, T;\n    cin >> S >> T;\n\n    vector<vector<int>> dist(N, vector<int>(M, numeric_limits<int>::max()));\n\n    // Direction vectors for [E, W, N, S]\n    vector<int> dx = {0, 0, -1, 1};\n    vector<int> dy = {1, -1, 0, 0};\n\n    // Maps direction chars to row and column direction indices\n    vector<pair<int, int>> EWSN = {{'E', 0}, {'W', 1}, {'N', 2}, {'S', 3}};\n\n    // BFS function to calculate minimum distance using allowed directions\n    auto bfs = [&](int startX, int startY) {\n        queue<pair<int, int>> q;\n        q.emplace(startX, startY);\n        dist[startX][startY] = 0;\n\n        while (!q.empty()) {\n            int x, y;\n            tie(x, y) = q.front();\n            q.pop();\n\n            for (auto &[dir, index] : EWSN) {\n                int nx = x + dx[index];\n                int ny = y + dy[index];\n                if (0 <= nx && nx < N && 0 <= ny && ny < M) {\n                    bool canMove = (index == 0 && S[x] == 'E') || \n                                   (index == 1 && S[x] == 'W') ||\n                                   (index == 2 && T[y] == 'N') ||\n                                   (index == 3 && T[y] == 'S');\n                    if (canMove && dist[nx][ny] == numeric_limits<int>::max()) {\n                        dist[nx][ny] = dist[x][y] + 1;\n                        q.emplace(nx, ny);\n                    }\n                }\n            }\n        }\n    };\n\n    // Process each query\n    while (Q--) {\n        int sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        sx--; sy--; ex--; ey--;  // Convert to zero-based index\n\n        // Initialize the distance matrix for each query\n        for (int i = 0; i < N; ++i) {\n            fill(dist[i].begin(), dist[i].end(), numeric_limits<int>::max());\n        }\n\n        // Perform BFS from the start intersection\n        bfs(sx, sy);\n\n        // Output the distance or -1 if unreachable\n        int result = dist[ex][ey];\n        cout << (result == numeric_limits<int>::max() ? -1 : result) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:36:54"
  }
]