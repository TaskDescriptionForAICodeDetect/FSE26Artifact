[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint h,w,q;\nstring s,t;\nvi a,b,c[4];\n\nint f(int x,int y,int X,int Y,bool fx=1,bool fy=1){\n\tint I=a[x],J=b[y];\n\tbool bx=0,by=0;\n\tif(I==1&&Y<=y||I==3&&y<=Y) bx=1;\n\tif(J==0&&X<=x||J==2&&x<=X) by=1;\n\tif(bx&&by){\n\t\tif(I==a[X]||J==b[Y]) return abs(x-X)+abs(y-Y);\n\t\tauto ix=lower_bound(c[I].begin(),c[I].end(),X);\n\t\tauto iy=lower_bound(c[J].begin(),c[J].end(),Y);\n\t\tif(J==0) ix--;\n\t\tif(I==1) iy--;\n\t\tint tx=(0<=*ix&&*ix<h?abs(*ix-x)+abs(*ix-X)+abs(y-Y):inf);\n\t\tint ty=(0<=*iy&&*iy<w?abs(*iy-y)+abs(*iy-Y)+abs(x-X):inf);\n\t\treturn min(tx,ty);\n\t}\n\tauto ix=lower_bound(c[(I+2)%4].begin(),c[(I+2)%4].end(),x);\n\tauto iy=lower_bound(c[(J+2)%4].begin(),c[(J+2)%4].end(),y);\n\tif(J==0) ix--;\n\tif(I==1) iy--;\n\tint tx=(fx&&0<=*ix&&*ix<h?f(*ix,y,X,Y,0,1)+abs(*ix-x):inf);\n\tint ty=(fy&&0<=*iy&&*iy<w?f(x,*iy,X,Y,1,0)+abs(*iy-y):inf);\n\treturn min(tx,ty);\n}\n\nint main(){\n\tcin>>h>>w>>q>>s>>t;\n\ta=vi(h,1);\n\tb=vi(w);\n\tfor(int i=0;i<4;i++) c[i].push_back(-1);\n\tfor(int i=0;i<h;i++){\n\t\tif(s[i]=='E') a[i]=3;\n\t\tc[a[i]].push_back(i);\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tif(t[i]=='S') b[i]=2;\n\t\tc[b[i]].push_back(i);\n\t}\n\tfor(int i=0;i<4;i++) c[i].push_back(inf);\n\tfor(int i=0;i<q;i++){\n\t\tint x,y,X,Y;\n\t\tcin>>x>>y>>X>>Y;\n\t\tint res=f(x-1,y-1,X-1,Y-1);\n\t\tcout<<(res==inf?-1:res)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    int ans=INF;\n    using T = tuple<int, int, int>;\n    map<T, int> dp;\n    using P = pair<int, T>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      T st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      tie(y,x,step)=st;\n\n      if(y==c&&x==d) chmin(ans,sum);\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if(y==c){\n        if(s[y]=='E'&&x<=d) chmin(ans,sum+abs(y-c)+abs(x-d));\n        if(s[y]=='W'&&x>=d) chmin(ans,sum+abs(y-c)+abs(x-d));\n      }\n      if(x==d){\n        if(t[x]=='S'&&y<=c) chmin(ans,sum+abs(y-c)+abs(x-d));\n        if(t[x]=='N'&&y>=c) chmin(ans,sum+abs(y-c)+abs(x-d));\n      }\n\n      if(step>=4) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(dp.count(T(ny,nx,ns))&&dp[T(ny,nx,ns)]<=nd) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        // N           \n        for(int xx:{x,d}){\n          auto it=--upper_bound(vn.begin(),vn.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=--upper_bound(vs.begin(),vs.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }else{\n        // N           \n        for(int xx:{x,d}){\n          auto it=lower_bound(vn.begin(),vn.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=lower_bound(vs.begin(),vs.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }\n      if(t[x]=='N'){            \n        // W         \n        for(int yy:{y,c}){\n          auto it=--upper_bound(vw.begin(),vw.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=--upper_bound(ve.begin(),ve.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      }else{\n        // W         \n        for(int yy:{y,c}){\n          auto it=lower_bound(vw.begin(),vw.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=lower_bound(ve.begin(),ve.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 100000000000000000\n\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[100005], prer[100005], nextl[100005], nextr[100005];\nllint preu[100005], pred[100005], nextu[100005], nextd[100005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i] == 'W') prel[i] = i;\n\t\tif(s[i] == 'E') prer[i] = i;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i] == 'W') nextl[i] = i;\n\t\tif(s[i] == 'E') nextr[i] = i;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i] == 'N') preu[i] = i;\n\t\tif(t[i] == 'S') pred[i] = i;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i] == 'N') nextu[i] = i;\n\t\tif(t[i] == 'S') nextd[i] = i;\n\t}\n\t\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define fi first\n#define se second\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n\nusing namespace std;\nusing ll = int64_t;\n\nint N, M, Q;\nstring S, T;\nmap<int, vector<int>> xPositions;\nmap<int, vector<int>> yPositions;\nvector<int> interestingX;\nvector<int> interestingY;\nqueue<pair<int,int>> q;\n\nint distances[10][10];\n\nvoid build() {\n  for (int i = 0; i < N; i++)\n    xPositions[S[i] == 'E' ? 1 : -1].pb(i);\n  for (int i = 0; i < M; i++)\n    yPositions[T[i] == 'S' ? 1 : -1].pb(i);\n}\n\nint Next(const vector<int>& v, int x) {\n  auto it = lower_bound(all(v), x);\n  if (it == v.end())\n    return -1;\n  return *it;\n}\n\nint Prev(const vector<int>& v, int x) {\n  auto it = upper_bound(all(v), x);\n  if (it == v.begin())\n    return -1;\n  --it;\n  return *it;\n}\n\nvoid filter(vector<int>& v) {\n  sort(all(v));\n  v.erase(unique(all(v)), v.end());\n  while (!v.empty() && v.front() == -1)\n    v.erase(v.begin());\n}\n\nint ans(int x0, int y0, int x1, int y1) {\n  interestingX.clear();\n  interestingY.clear();\n  \n  interestingX.pb(x0);\n  interestingX.pb(x1);\n  interestingY.pb(y0);\n  interestingY.pb(y1);\n  for (int d = -1; d <= 1; d++) {\n    interestingX.pb(Next(xPositions[d], x0));\n    interestingX.pb(Prev(xPositions[d], x0));\n    interestingX.pb(Next(xPositions[d], x1));\n    interestingX.pb(Prev(xPositions[d], x1));\n\n    interestingY.pb(Next(yPositions[d], y0));\n    interestingY.pb(Prev(yPositions[d], y0));\n    interestingY.pb(Next(yPositions[d], y1));\n    interestingY.pb(Prev(yPositions[d], y1));\n  }\n\n  filter(interestingX);\n  filter(interestingY);\n\n  auto getX = [&](int x) {\n    return lower_bound(all(interestingX), x) - interestingX.begin();\n  };\n\n  auto getY = [&](int y) {\n    return lower_bound(all(interestingY), y) - interestingY.begin();\n  };\n\n  memset(distances, -1, sizeof(distances));\n  x0 = getX(x0);\n  y0 = getY(y0);\n  x1 = getX(x1);\n  y1 = getY(y1);\n  distances[x0][y0] = 0;\n  q.push({x0, y0});\n\n  while (!q.empty()) {\n    auto p = q.front();\n    q.pop();\n    int d = distances[p.fi][p.se];\n    // cerr << \"debug: \" << p.fi << \" \" << p.se << \" \" << d << endl;\n\n    // go x\n    int lx = 0, rx = sz(interestingX) - 1;\n    if (T[interestingY[p.se]] == 'S') lx = p.fi + 1;\n    if (T[interestingY[p.se]] == 'N') rx = p.fi - 1;\n    for (int nx = lx; nx <= rx; nx++) {\n      int nd = d + abs(interestingX[nx] - interestingX[p.fi]);\n      if (distances[x1][y1] != -1 && distances[x1][y1] <= nd)\n        continue;\n      if (distances[nx][p.se] == -1 || distances[nx][p.se] > nd) {\n        distances[nx][p.se] = nd;\n        q.push({nx, p.se});\n      }\n    }\n\n    // go y\n    int ly = 0, ry = sz(interestingY) - 1;\n    if (S[interestingX[p.fi]] == 'E') ly = p.se + 1;\n    if (S[interestingX[p.fi]] == 'W') ry = p.se - 1;\n    for (int ny = ly; ny <= ry; ny++) {\n      int nd = d + abs(interestingY[ny] - interestingY[p.se]);\n      if (distances[x1][y1] != -1 && distances[x1][y1] <= nd)\n        continue;\n      if (distances[p.fi][ny] == -1 || distances[p.fi][ny] > nd) {\n        distances[p.fi][ny] = nd;\n        q.push({p.fi, ny});\n      }\n    }\n  }\n\n  return distances[x1][y1];\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> N >> M >> Q;\n  cin >> S >> T;\n\n  build();\n\n  for (int i = 0; i < Q; i++) {\n    int x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n    --x0, --y0, --x1, --y1;\n    cout << ans(x0, y0, x1, y1) << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint H, W;\nvector<int> ans;\nint P[100000];\nint Q[100000];\nint R[100000];\n\nint sub(PP a, PP b) {\n\treturn INF;\n}\n\nint main() {\n\tint N, M, Q;\n\tstring s, t;\n\tvector<PP> A;\n\tvector<PP> B;\n\n\tcin >> N >> M >> Q;\n\t--N; --M;\n\tcin >> s >> t;\n\n\tREP(i, 0, Q) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\t--a; --b; --c; --d;\n\t\tA.push_back(PP(a, b));\n\t\tB.push_back(PP(c, d));\n\t}\n\n\tans.assign(Q, INF);\n\tREP(rev, 0, 2) {\n\t\tREP(rot, 0, 4) {\n\t\t\tH = N;\n\t\t\tW = M;\n\n\n\t\t\tREP(j, 0, Q) {\n\t\t\t\tans[j] = min(ans[j], sub(A[j], B[j]));\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(j, 0, Q) {\n\t\tcout << ans[j] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(),x.end()\n#define all(x) x.begin(),x.end()\n#define fi first\n#define se second\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define erase_duplicates(x) sort(all(x)); (x).resize(distance((x).begin(), unique(all(x))));\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set = tree<\nT,\nnull_type,\nless<T>,\nrb_tree_tag,\ntree_order_statistics_node_update>;\n\n//X.find_by_order(k); - zwraca iterator na k-ty element (numeracja od zerowego)\n//X.order_of_key(k); - zwraca liczbę elementów ostro mniejszych niż k\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<char> VC;\ntypedef long double LD;\ntypedef pair<LD,LD> PLD;\ntypedef vector<LD> VLD;\ntypedef vector<PLD> VPLD;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\" = \"<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<\" = \"<<h<<\", \"; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#define cerr if(0)cout\n#endif\n\nconst int maxn = (1e6)+7;\nconst int maxk = 20;\nconst int inf = (1e9)+7;\nconst LL LLinf = ((LL)1e18)+7LL;\nconst LD eps = 1e-9;\nconst LL mod = 1e9+7;\n\n// ***************************** CODE ***************************** //\n\nset<int> gora, dol, lewo, prawo;\nconst int stala = 5;\n\nint odl(PII a, PII b)\n{\n  int xd = abs(a.fi - b.fi) + abs(a.se - b.se);\n  if(a.fi >= b.fi)\n  {\n    if(gora.count(a.se))\n    {\n    //  cerr<<\"HEJ\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.fi <= b.fi)\n  {\n    if(dol.count(a.se))\n    {\n      // cerr<<\"HEJ2\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.se <= b.se)\n  {\n    if(prawo.count(a.fi))\n    {\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  if(a.se >= b.se)\n  {\n    if(lewo.count(a.fi))\n    {\n      // cerr<<\"HEJ\"<<endl;\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  return inf;\n}\n\nvoid dorzuc(vector<pair<int, PII> > & a, vector<pair<int, PII> > b, int dlu)\n{\n  for(auto s : b)\n    a.pb({s.fi + dlu, s.se});\n}\n\nvector<pair<int, PII> > gen(PII cur, int k = stala)\n{\n//  cerr<<cur.fi<<\" \"<<cur.se<<endl;\n  vector<pair<int, PII> > res;\n  res.pb({0, cur});\n  if(k == 0)\n    return res;\n    if(gora.count(cur.se))\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n    else\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n\n    if(lewo.count(cur.fi))\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n    else\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n  return res;\n\n}\n\nvector<pair<int, PII> > gen2(PII cur, int k = stala)\n{\n\n    vector<pair<int, PII> > res;\n    res.pb({0, cur});\n    if(k == 0)\n      return res;\n      if(dol.count(cur.se))\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n      else\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n\n      if(prawo.count(cur.fi))\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.fi);\n          if(SZ(gora) > 0 && it != gora.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.fi);\n          if(SZ(dol) > 0 && it != dol.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n      else\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.se);\n          if(SZ(gora) > 0 && it != gora.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.se);\n          if(SZ(dol) > 0 && it != dol.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n    return res;\n\n}\n\nint main()\n{\n\t_upgrade\n  int n, m, q;\n  cin>>n>>m>>q;\n  string s;\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'E')\n      prawo.insert(i + 1);\n    else\n      lewo.insert(i + 1);\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'N')\n      gora.insert(i + 1);\n    else\n      dol.insert(i + 1);\n//  gen({4, 2});\n  // cerr<<odl({4, 2}, {3, 2})<<endl;\n // return 0;\n  while(q--)\n  {\n    PII start, meta;\n    cin>>start.fi>>start.se;\n    cin>>meta.fi>>meta.se;\n    auto it = gen(start);\n    auto it2 = gen2(meta);\n    for(auto s : it)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n    cerr<<endl;\n    for(auto s : it2)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n      cerr<<endl;\n      cerr<<endl;\n      cerr<<endl;\n\n    int res = inf;\n    for(auto s : it)\n      for(auto v : it2)\n      {\n  //      cerr<<s.fi<<\" \"<<v.fi<<\" \"<<odl(s.se, v.se)<<endl;\n        res = min(res, odl(s.se, v.se) + s.fi + v.fi);\n      }\n    if(res == inf)\n      cout<<\"-1\\n\";\n    else\n      cout<<res<<\"\\n\";\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using ll = long long;    \n    auto T=[&](int y,int x,int step){return ((ll)y<<40)|((ll)x<<20)|(ll)step;};\n    unordered_map<ll, int> dp;\n    using P = pair<int, ll>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      ll st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      y=(st>>40);\n      x=(st>>20)^((ll)y<<20);\n      step=st&((1<<20)-1);      \n      \n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(abs(ny)==INF||abs(nx)==INF) return;\n          if(dp.count(T(ny,nx,ns))&&dp[T(ny,nx,ns)]<=nd) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        // N           \n        for(int xx:{x,d}){\n          auto it=--upper_bound(vn.begin(),vn.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=--upper_bound(vs.begin(),vs.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }else{\n        // N           \n        for(int xx:{x,d}){\n          auto it=lower_bound(vn.begin(),vn.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=lower_bound(vs.begin(),vs.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }\n      if(t[x]=='N'){            \n        // W         \n        for(int yy:{y,c}){\n          auto it=--upper_bound(vw.begin(),vw.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=--upper_bound(ve.begin(),ve.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      }else{\n        // W         \n        for(int yy:{y,c}){\n          auto it=lower_bound(vw.begin(),vw.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=lower_bound(ve.begin(),ve.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 200008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\n\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\n\tfor(int i=1;i<=q;i++)\t\n\t{\n\t\tpii s=from[i],t=dest[i];\n\t\t\n\t\tif(s.first>t.first or s.second>t.second) continue;\n\t\t#define case0 case0\n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=ub(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][1]),z=ub(t.first,path[0][0]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n\t\tif(s.second==t.second) continue;\n\t\t#define case1 case1\n\t\tfor(;s.first<=t.first;)\n\t\t{\n\t\t\tint x=lb(s.first,path[0][1]);\n\t\t\tif(!x) break;int tmp=abs(s.first-x)+abs(t.first-x)+abs(s.second-t.second);\n\t\t\tif(x!=s.first) \n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][0]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;0;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t#define case2 case2\n\t\tfor(;s.first<t.first;)//middle\n\t\t{\n\t\t\tint x=ub(s.first,path[0][1]);\n\t\t\tif(x>=t.first or x<=s.first) break;int tmp=abs(s.second-t.second)+abs(s.first-t.first);\n\t\t\tint at=1e9,bt=1e9;int otmp=tmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(s.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t\tif(y!=s.second)\n\t\t\t\t{\n\t\t\t\t\tint z=lb(s.second,path[0][1]);\n\t\t\t\t\tif(!z) break;tmp+=abs(z-s.first)*2;\n\t\t\t\t}\t\n\t\t\t\tat=tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t\tbt=tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=min(at,bt);\n\t\t\t\n\t\t\t//copied from  line58\n\t\t\totmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;0;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//licensed\n\t\t}\n\t}\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\t\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) dir[0][i]^=1;for(int i=1;i<=m;i++) dir[1][i]^=1;\n\tfor(int i=1;i<=q;i++) swap(from[i],dest[i]);\n\t\n\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 100 * 1000 + 7;\nconst int INF = 1e9 + 7;\n\nbool rg[MX], up[MX];\nint n, m;\n\nvector<int> gl, gr, gu, gd;\n\nint d[107][107];\n\nbool can_go(int x1, int y1, int x2, int y2) {\n    if (x1 == x2) {\n        if (y1 < y2) {\n            return rg[x1];\n        } else {\n            return !rg[x1];\n        }\n    } else if (y1 == y2) {\n        if (x2 < x1) {\n            return up[y1];\n        } else {\n            return !up[y1];\n        }\n    }\n    return false;\n}\n\nvector<pair<int, int> > trace(int x, int y, int depth, bool rev) {\n    vector<pair<int, int> > ans;\n    queue<pair<int, int> > q;\n    set<pair<int, int> > was;\n\n    auto ad = [&](int x, int y) {\n        if (was.count(make_pair(x, y))) {\n            return;\n        }\n        was.emplace(x, y);\n        q.emplace(x, y);\n        ans.emplace_back(x, y);\n    };\n\n    ad(x, y);\n    while (!q.empty()) {\n        int x, y;\n        tie(x, y) = q.front();\n        if (ans.size() > depth) {\n            break;\n        }\n        q.pop();\n        if (rg[x] ^ rev) {\n            {\n                int yy = lower_bound(gu.begin(), gu.end(), y) - gu.begin();\n                if (yy != gu.size()) {\n                    yy = gu[yy];\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = lower_bound(gd.begin(), gd.end(), y) - gd.begin();\n                if (yy != gd.size()) {\n                    yy = gd[yy];\n                    ad(x, yy);\n                }\n            }\n        } else {\n            {\n                int yy = upper_bound(gu.begin(), gu.end(), y) - gu.begin() - 1;\n                if (yy >= 0) {\n                    yy = gu[yy];\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = upper_bound(gd.begin(), gd.end(), y) - gd.begin() - 1;\n                if (yy >= 0) {\n                    yy = gd[yy];\n                    ad(x, yy);\n                }\n            }\n        }\n\n        if ((!up[y]) ^ rev) {\n            {\n                int xx = lower_bound(gl.begin(), gl.end(), x) - gl.begin();\n                if (xx != gl.size()) {\n                    xx = gl[xx];\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = lower_bound(gr.begin(), gr.end(), x) - gr.begin();\n                if (xx != gr.size()) {\n                    xx = gr[xx];\n                    ad(xx, y);\n                }\n            }\n        } else {\n            {\n                int xx = upper_bound(gl.begin(), gl.end(), x) - gl.begin() - 1;\n                if (xx >= 0) {\n                    xx = gl[xx];\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = upper_bound(gr.begin(), gr.end(), x) - gr.begin() - 1;\n                if (xx >= 0) {\n                    xx = gr[xx];\n                    ad(xx, y);\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint dist(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int q;\n    cin >> n >> m >> q;\n    string s;\n    cin >> s;\n    for (int i = 1; i <= n; i++) {\n        if (s[i - 1] == 'E') {\n            rg[i] = true;\n            gl.push_back(i);\n        } else {\n            gr.push_back(i);\n        }\n    }\n    cin >> s;\n    for (int i = 1; i <= m; i++) {\n        if (s[i - 1] == 'N') {\n            up[i] = true;\n            gu.push_back(i);\n        } else {\n            gd.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        vector<pair<int, int> > t1 = trace(x1, y1, 10, false);\n        vector<pair<int, int> > t2 = trace(x2, y2, 10, true);\n        vector<int> xx, yy;\n        for (auto v : t1) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        for (auto v : t2) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        sort(xx.begin(), xx.end());\n        sort(yy.begin(), yy.end());\n        xx.resize(unique(xx.begin(), xx.end()) - xx.begin());\n        yy.resize(unique(yy.begin(), yy.end()) - yy.begin());\n        int n = xx.size(), m = yy.size();\n        set<tuple<int, int, int> > go;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                d[i][j] = INF;\n                if (xx[i] == x1 && yy[j] == y1) {\n                    d[i][j] = 0;\n                }\n                go.emplace(d[i][j], i, j);\n            }\n        }\n        /*\n        cerr << \"X: \";\n        for (int x : xx) {\n            cerr << x << \" \";\n        }\n        cerr << endl;\n        cerr << \"Y: \";\n        for (int y : yy) {\n            cerr << y << \" \";\n        }\n        cerr << endl;\n*/\n\n        while (!go.empty()) {\n            int D, x, y;\n            tie(D, x, y) = *go.begin();\n            go.erase(go.begin());\n            for (int gy = 0; gy < (int)yy.size(); gy++) {\n                if (can_go(xx[x], yy[y], xx[x], yy[gy]) && d[x][gy] > d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy])) {\n                    go.erase(make_tuple(d[x][gy], x, gy));\n                    d[x][gy] = d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy]);\n                    go.insert(make_tuple(d[x][gy], x, gy));\n                }\n            }\n            for (int gx = 0; gx < (int)xx.size(); gx++) {\n                if (can_go(xx[x], yy[y], xx[gx], yy[y]) && d[gx][y] > d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y])) {\n                    go.erase(make_tuple(d[gx][y], gx, y));\n                    d[gx][y] = d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y]);\n                    go.insert(make_tuple(d[gx][y], gx, y));\n                }\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (xx[i] == x2 && yy[j] == y2) {\n                    ans = d[i][j];\n                }\n            }\n        }\n\n        if (ans == INF) {\n            ans = -1;\n        }\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 100 * 1000 + 7;\nconst int INF = 1e9 + 7;\n\nbool rg[MX], up[MX];\nint n, m;\n\nvector<int> gl, gr, gu, gd;\n\nint d[107][107];\n\nbool can_go(int x1, int y1, int x2, int y2) {\n    if (x1 == x2) {\n        if (y1 < y2) {\n            return rg[x1];\n        } else {\n            return !rg[x1];\n        }\n    } else if (y1 == y2) {\n        if (x2 < x1) {\n            return up[y1];\n        } else {\n            return !up[y1];\n        }\n    }\n    return false;\n}\n\nvector<pair<int, int> > trace(int x, int y, int depth, bool rev) {\n    vector<pair<int, int> > ans;\n    queue<pair<int, int> > q;\n    set<pair<int, int> > was;\n\n    auto ad = [&](int x, int y) {\n        if (was.count(make_pair(x, y))) {\n            return;\n        }\n        was.emplace(x, y);\n        q.emplace(x, y);\n        if (ans.size() < depth) {\n            ans.emplace_back(x, y);\n        }\n    };\n\n    ad(x, y);\n    while (!q.empty()) {\n        int x, y;\n        tie(x, y) = q.front();\n        if (ans.size() > depth) {\n            break;\n        }\n        q.pop();\n        if (rg[x] ^ rev) {\n            {\n                int yy = lower_bound(gu.begin(), gu.end(), y) - gu.begin();\n                if (yy != gu.size()) {\n                    yy = gu[yy];\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = lower_bound(gd.begin(), gd.end(), y) - gd.begin();\n                if (yy != gd.size()) {\n                    yy = gd[yy];\n                    ad(x, yy);\n                }\n            }\n        } else {\n            {\n                int yy = upper_bound(gu.begin(), gu.end(), y) - gu.begin() - 1;\n                if (yy >= 0) {\n                    yy = gu[yy];\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = upper_bound(gd.begin(), gd.end(), y) - gd.begin() - 1;\n                if (yy >= 0) {\n                    yy = gd[yy];\n                    ad(x, yy);\n                }\n            }\n        }\n\n        if ((!up[y]) ^ rev) {\n            {\n                int xx = lower_bound(gl.begin(), gl.end(), x) - gl.begin();\n                if (xx != gl.size()) {\n                    xx = gl[xx];\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = lower_bound(gr.begin(), gr.end(), x) - gr.begin();\n                if (xx != gr.size()) {\n                    xx = gr[xx];\n                    ad(xx, y);\n                }\n            }\n        } else {\n            {\n                int xx = upper_bound(gl.begin(), gl.end(), x) - gl.begin() - 1;\n                if (xx >= 0) {\n                    xx = gl[xx];\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = upper_bound(gr.begin(), gr.end(), x) - gr.begin() - 1;\n                if (xx >= 0) {\n                    xx = gr[xx];\n                    ad(xx, y);\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint dist(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int q;\n    cin >> n >> m >> q;\n    string s;\n    cin >> s;\n    for (int i = 1; i <= n; i++) {\n        if (s[i - 1] == 'E') {\n            rg[i] = true;\n            gl.push_back(i);\n        } else {\n            gr.push_back(i);\n        }\n    }\n    cin >> s;\n    for (int i = 1; i <= m; i++) {\n        if (s[i - 1] == 'N') {\n            up[i] = true;\n            gu.push_back(i);\n        } else {\n            gd.push_back(i);\n        }\n    }\n\n    set<tuple<int, int, int> > go;\n    for (int i = 0; i < q; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        vector<pair<int, int> > t1 = trace(x1, y1, 5, false);\n        vector<pair<int, int> > t2 = trace(x2, y2, 5, true);\n        vector<int> xx, yy;\n        for (auto v : t1) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        for (auto v : t2) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        sort(xx.begin(), xx.end());\n        sort(yy.begin(), yy.end());\n        xx.resize(unique(xx.begin(), xx.end()) - xx.begin());\n        yy.resize(unique(yy.begin(), yy.end()) - yy.begin());\n        int n = xx.size(), m = yy.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                d[i][j] = INF;\n                if (xx[i] == x1 && yy[j] == y1) {\n                    d[i][j] = 0;\n                }\n                go.emplace(d[i][j], i, j);\n            }\n        }\n        /*\n        cerr << \"X: \";\n        for (int x : xx) {\n            cerr << x << \" \";\n        }\n        cerr << endl;\n        cerr << \"Y: \";\n        for (int y : yy) {\n            cerr << y << \" \";\n        }\n        cerr << endl;\n*/\n\n        while (!go.empty()) {\n            int D, x, y;\n            tie(D, x, y) = *go.begin();\n            go.erase(go.begin());\n            for (int gy = max(0, y - 1); gy < min(y + 1, (int)yy.size()); gy++) {\n                if (can_go(xx[x], yy[y], xx[x], yy[gy]) && d[x][gy] > d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy])) {\n                    go.erase(make_tuple(d[x][gy], x, gy));\n                    d[x][gy] = d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy]);\n                    go.insert(make_tuple(d[x][gy], x, gy));\n                }\n            }\n            for (int gx = max(0, x - 1); gx < min(x + 1, (int)xx.size()); gx++) {\n                if (can_go(xx[x], yy[y], xx[gx], yy[y]) && d[gx][y] > d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y])) {\n                    go.erase(make_tuple(d[gx][y], gx, y));\n                    d[gx][y] = d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y]);\n                    go.insert(make_tuple(d[gx][y], gx, y));\n                }\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (xx[i] == x2 && yy[j] == y2) {\n                    ans = d[i][j];\n                }\n            }\n        }\n\n        if (ans == INF) {\n            ans = -1;\n        }\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\n\nint main(){\n\tlong N,M,Q;\n\tcin>>N>>M>>Q;\n\tlong ansarr[Q];\n\tstring S,T;\n\tcin>>S>>T;\n\tlong a[Q],b[Q],c[Q],d[Q];\n\tfor(long i=0;i<Q;++i)cin>>a[i]>>b[i]>>c[i]>>d[i];\n\tfor(long i=0;i<Q;++i){\n\t\tchar map[N][M];\n\t\tfor(long j=0;j<N;++j){\n\t\t\tfor(long k=0;k<M;++k){\n\t\t\t\tmap[j][k]='.';\n\t\t\t}\n\t\t}\n\t\tmap[a[i]-1][b[i]-1]='s';\n\t\tqueue<long>x;\n\t\tqueue<long>y;\n\t\tqueue<long>ans;\n\t\tx.push(b[i]);\n\t\ty.push(a[i]);\n\t\tans.push(0);\n\t\tint pro=1;\n\t\twhile(true){\n\t\t\tif(map[y.front()][x.front()-1]=='.' && y.front()<N && T[x.front()-1]=='S'){\n\t\t\t\tx.push(x.front());\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()+1==c[i] && x.front()==d[i]) break;\n\t\t\t\tmap[y.front()][x.front()-1]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-2][x.front()-1]=='.' && y.front()>1 && T[x.front()-1]=='N'){\n\t\t\t\tx.push(x.front());\n\t\t\t\ty.push(y.front()-1);\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()-1==c[i] && x.front()==d[i]) break;\n\t\t\t\tmap[y.front()-2][x.front()-1]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-1][x.front()]=='.' && x.front()<M && S[y.front()-1]=='E'){\n\t\t\t\tx.push(x.front()+1);\n\t\t\t\ty.push(y.front());\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()==c[i] && x.front()+1==d[i]) break;\n\t\t\t\tmap[y.front()-1][x.front()]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-1][x.front()-2]=='.' && x.front()>1 && S[y.front()-1]=='W'){\n\t\t\t\tx.push(x.front()-1);\n\t\t\t\ty.push(y.front());\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()==c[i] && x.front()-1==d[i]) break;\n\t\t\t\tmap[y.front()-1][x.front()-2]='+';\n\t\t\t}\n\t\t\telse if(x.size()>1){\n\t\t\t\tx.pop();\n\t\t\t\ty.pop();\n\t\t\t\tans.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpro=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pro==0)ansarr[i]=-1;\n\t\telse{\n\t\t\twhile(ans.size()>1)ans.pop();\n\t\t\tansarr[i]=ans.front();\n\t\t}\n\t}\n\tfor(long i=0;i<Q;++i)cout<<ansarr[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int N=1e5+5;\nint n,m,q,tot,id[7][7],dis[50][50];\nvector<int>north,south,east,west;\nchar s1[N],s2[N];\nunordered_map<int,int>vis1,vis2;\nvector<int>v1,v2;\nvoid solve2(int a,int b)\n{\n    int pos;\n    if(s2[b]=='N')\n    {\n        pos=lower_bound(south.begin(),south.end(),b)-south.begin();\n        if(pos<south.size()&&!vis2[south[pos]])\n        {\n            v2.push_back(south[pos]);\n            vis2[south[pos]]=true;\n        }\n    }\n    else\n    {\n        pos=lower_bound(north.begin(),north.end(),b)-north.begin();\n        if(pos<north.size()&&!vis2[north[pos]])\n        {\n            v2.push_back(north[pos]);\n            vis2[north[pos]]=true;\n        }\n    }\n    if(s2[b]=='N')\n    {\n        pos=lower_bound(south.begin(),south.end(),b)-south.begin()-1;\n        if(pos<south.size()&&!vis2[south[pos]])\n        {\n            v2.push_back(south[pos]);\n            vis2[south[pos]]=true;\n        }\n    }\n    else\n    {\n        pos=lower_bound(north.begin(),north.end(),b)-north.begin()-1;\n        if(pos<north.size()&&!vis2[north[pos]])\n        {\n            v2.push_back(north[pos]);\n            vis2[north[pos]]=true;\n        }\n    }\n}\nvoid solve1(int a,int b)\n{\n    int pos;\n    if(s1[a]=='W')\n    {\n        pos=lower_bound(east.begin(),east.end(),a)-east.begin();\n        if(pos<east.size()&&!vis1[east[pos]])\n        {\n            v1.push_back(east[pos]);\n            vis1[east[pos]]=true;\n        }\n    }\n    else\n    {\n        pos=lower_bound(west.begin(),west.end(),a)-west.begin();\n        if(pos<west.size()&&!vis1[west[pos]])\n        {\n            v1.push_back(west[pos]);\n            vis1[west[pos]]=true;\n        }\n    }\n    if(s1[a]=='W')\n    {\n        pos=lower_bound(east.begin(),east.end(),a)-east.begin()-1;\n        if(pos>=0&&!vis1[east[pos]])\n        {\n            v1.push_back(east[pos]);\n            vis1[east[pos]]=true;\n        }\n    }\n    else\n    {\n        pos=lower_bound(west.begin(),west.end(),a)-west.begin()-1;\n        if(pos>=0&&!vis1[west[pos]])\n        {\n            v1.push_back(west[pos]);\n            vis1[west[pos]]=true;\n        }\n    }\n}\nstruct node\n{\n    int u,x;\n    node(int u=0,int x=0):u(u),x(x){}\n    bool operator<(const node&o)const\n    {\n        return x>o.x;\n    }\n};\nint d[50*50];\nbool vis[50*50];\nint dijkstra(int s,int t)\n{\n    memset(d,inf,sizeof(d));\n    memset(vis,false,sizeof(vis));\n    priority_queue<node>q;\n    d[s]=0;\n    q.push(node(s,0));\n    while(!q.empty())\n    {\n        int u=q.top().u;q.pop();\n        if(vis[u]) continue;\n        if(u==t) return d[t];\n        vis[u]=true;\n        for(int i=1;i<=tot;i++)\n            if(d[i]>d[u]+dis[u][i])\n        {\n            d[i]=d[u]+dis[u][i];\n            q.push(node(i,d[i]));\n        }\n    }\n    return d[t];\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&q);\n    scanf(\"%s\",s1+1);\n    for(int i=1;i<=n;i++)\n        if(s1[i]=='E')\n        east.push_back(i);\n    else west.push_back(i);\n    scanf(\"%s\",s2+1);\n    for(int i=1;i<=m;i++)\n        if(s2[i]=='N') north.push_back(i);\n    else south.push_back(i);\n    while(q--)\n    {\n        int a,b,c,d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        vis1.clear();vis2.clear();\n        v1.clear();v2.clear();\n        v1.push_back(a);v2.push_back(b);\n        vis1[a]=vis2[b]=true;\n        if(!vis1[c]) v1.push_back(c),vis1[c]=true;\n        if(!vis2[d]) v2.push_back(d),vis2[d]=true;\n        solve1(a,b);solve1(c,d);\n        solve2(a,b);solve2(c,d);\n        sort(v1.begin(),v1.end());\n        sort(v2.begin(),v2.end());\n        memset(dis,inf,sizeof(dis));\n        memset(id,0,sizeof(id));\n        tot=0;\n        int s,t;\n        for(int i=0;i<v1.size();i++)\n            for(int j=0;j<v2.size();j++)\n        {\n            id[i][j]=++tot;\n            if(v1[i]==a&&v2[j]==b) s=tot;\n            if(v1[i]==c&&v2[j]==d) t=tot;\n            if(j>0)\n            {\n                if(s1[v1[i]]=='W')\n                    dis[id[i][j]][id[i][j-1]]=v2[j]-v2[j-1];\n                else dis[id[i][j-1]][id[i][j]]=v2[j]-v2[j-1];\n            }\n            if(i>0)\n            {\n                if(s2[v2[j]]=='N')\n                    dis[id[i][j]][id[i-1][j]]=v1[i]-v1[i-1];\n                else dis[id[i-1][j]][id[i][j]]=v1[i]-v1[i-1];\n            }\n        }\n        for(int i=1;i<=tot;i++) dis[i][i]=0;\n        int dis=dijkstra(s,t);\n        if(dis==inf) printf(\"-1\\n\");\n        else printf(\"%d\\n\",dis);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nstruct handler{\n    typedef pii val_t;\n    typedef int opr_t;\n    handler(){}\n    val_t def_val(){ return pii(MOD, -MOD); }\n    static val_t update(const val_t &l, const opr_t &r){\n        return pii(r, r);\n    }\n    static val_t merge(const val_t &l, const val_t &r){\n        return pii(min(l.first, r.first), max(l.second, r.second));\n    }\n};\n\ntemplate<typename Handler>\nstruct SegTree{\n    typedef typename Handler::val_t val_t;\n    typedef typename Handler::opr_t opr_t;\n    vector<val_t> val;\n    Handler hdl;\n    int n;\n\n    SegTree(int size = 0):hdl(){\n        n=1;\n        while(n<size) n<<=1;\n        val=vector<val_t>(2*n, hdl.def_val());\n    }\n    SegTree(const vector<val_t> &in):hdl(){\n        n=1;\n        while(n<in.size()) n<<=1;\n        val=vector<val_t>(2*n, hdl.def_val());\n        for(int i=n-1 + in.size()-1;i>=0;i--){\n            if(n-1 <= i) val[i] = in[i - (n-1)];\n            else val[i] = hdl.merge(val[i*2+1],val[i*2+2]);\n        }\n    }\n    void update(int i, const opr_t& a){\n        i += n-1;\n        val[i] = hdl.update(val[i], a);\n        while(i > 0){\n            i = (i-1)/2;\n            val[i] = hdl.merge(val[i*2+1],val[i*2+2]);\n        }\n    }\n    val_t query(int a,int b,int k,int l,int r){\n        if(r<=a||b<=l) return hdl.def_val();\n        if(a<=l&&r<=b) return val[k];\n        return hdl.merge(query(a, b, k*2+1, l, (l+r)/2),\n                         query(a, b, k*2+2, (l+r)/2, r)\n        );\n    }\n    val_t query(int a, int b){return query(a, b, 0, 0, n);}\n    val_t operator[](size_t i){return query(i, i+1);}\n    friend ostream& operator<<(ostream &os, SegTree<Handler> &t){\n        REP(i, t.n) os << (i ? \", \" : \"[\") << t.query(i, i+1);\n        return os << \"]\";\n    }\n};\n\n\nint T, n, m, q;\nstring s, t;\nSegTree<handler> segE, segW, segN, segS;\n\nint solve2(int sy, int sx, int gy, int gx) {\n    int mi = MOD;\n    {\n        int ans = 0;\n        if (sx <= gx && s[sy] == 'E') ans += gx - sx;\n        else if (sx >= gx && s[sy] == 'W') ans += sx - gx;\n        else ans += MOD;\n        if (sy <= gy && t[gx] == 'S') ans += gy - sy;\n        else if (sy >= gy && t[gx] == 'N') ans += sy - gy;\n        else ans += MOD;\n        mi = min(mi, ans);\n    }\n    {\n        int ans = 0;\n        if (sx <= gx && s[gy] == 'E') ans += gx - sx;\n        else if (sx >= gx && s[gy] == 'W') ans += sx - gx;\n        else ans += MOD;\n        if (sy <= gy && t[sx] == 'S') ans += gy - sy;\n        else if (sy >= gy && t[sx] == 'N') ans += sy - gy;\n        else ans += MOD;\n        mi = min(mi, ans);\n    }\n\n    return mi;\n}\n\nint solve(int sy, int sx, int gy, int gx, int step);\n\nint solve3(int sy, int sx, int gy, int gx, int d1, int step) {\n    int p;\n    int ans = MOD;\n    if (d1 == 0) {\n        if (t[sx] != 'N') return MOD;\n        p = segE.query(0, min(sy, gy) + 1).second;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n        p = segW.query(0, min(sy, gy) + 1).second;\n        chmin(ans, solve(p, sx, gy, gx, step));\n    }\n    if (d1 == 2) {\n        if (t[sx] != 'S') return MOD;\n        p = segE.query(max(sy, gy), n).first;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n        p = segW.query(max(sy, gy), n).first;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n    }\n    if (d1 == 1) {\n        if (s[sy] != 'E') return MOD;\n        p = segN.query(max(sx, gx), m).first;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n        p = segS.query(max(sx, gx), m).first;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n    }\n    if (d1 == 3) {\n        if (s[sy] != 'W') return MOD;\n        p = segN.query(0, min(sx, gx)).second;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n        p = segS.query(0, min(sx, gx)).second;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n    }\n    return ans;\n}\n\nint solve(int sy, int sx, int gy, int gx, int step = 3) {\n    if (sx < 0 || sy < 0 || n <= sy || m <= sx) return MOD;\n    int ans = solve2(sy, sx, gy, gx);\n//    cout << \"solve \" << sy << \", \" << sx << \": \" << ans << endl;\n    if (step > 0) {\n        REP(i, 4) {\n            ans = min(ans, solve3(sy, sx, gy, gx, i, step - 1));\n        }\n    }\n    return ans;\n}\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> m >> q >> s >> t){\n        segE = SegTree<handler>(n);\n        segW = SegTree<handler>(n);\n        REP(i, n) {\n            if (s[i] == 'E') segE.update(i, i);\n            if (s[i] == 'W') segW.update(i, i);\n        }\n        segN = SegTree<handler>(m);\n        segS = SegTree<handler>(m);\n        REP(i, m) {\n            if (t[i] == 'N') segN.update(i, i);\n            if (t[i] == 'S') segS.update(i, i);\n        }\n        REP(i, q) {\n            int sy, sx, gy, gx;\n            cin >> sy >> sx >> gy >> gx; sx --; sy --; gx --; gy--;\n            int ans = solve(sy, sx, gy, gx);\n            cout << (ans >= MOD ? -1 : ans) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  vector<int> pnu(m),psu(m);\n  vector<int> pnl(m),psl(m);\n  for(int j=0;j<m;j++){    \n    pnu[j]=*--upper_bound(vn.begin(),vn.end(),j);\n    psu[j]=*--upper_bound(vs.begin(),vs.end(),j);    \n    pnl[j]=*lower_bound(vn.begin(),vn.end(),j);\n    psl[j]=*lower_bound(vs.begin(),vs.end(),j);\n  }\n  \n  vector<int> pwu(n),peu(n);\n  vector<int> pwl(n),pel(n);\n  for(int i=0;i<n;i++){    \n    pwu[i]=*--upper_bound(vw.begin(),vw.end(),i);\n    peu[i]=*--upper_bound(ve.begin(),ve.end(),i);    \n    pwl[i]=*lower_bound(vw.begin(),vw.end(),i);\n    pel[i]=*lower_bound(ve.begin(),ve.end(),i);\n  }      \n  \n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using ll = long long;    \n    auto T=[&](int y,int x,int step){return ((ll)y<<40)|((ll)x<<20)|(ll)step;};\n    map<ll, int> dp;\n    using P = pair<int, ll>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      ll st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      y=(st>>40);\n      x=(st>>20)^((ll)y<<20);\n      step=st&((1<<20)-1);      \n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(abs(ny)==INF||abs(nx)==INF) return;\n          if(ny==y&&nx==x) return;         \n          if(dp.find(T(ny,nx,ns))!=dp.end()&&dp[T(ny,nx,ns)]<=nd) return;\n          if(nd+abs(ny-c)+abs(nx-d)>=ans) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        for(int xx:{x,d})\n          for(int nx:{pnu[xx],psu[xx]})\n            if(nx<=x) push(y,nx,step+1,sum+abs(nx-x));      \n      }else{\n        for(int xx:{x,d})\n          for(int nx:{pnl[xx],psl[xx]})\n            if(nx>=x) push(y,nx,step+1,sum+abs(nx-x));      \n      }\n      if(t[x]=='N'){\n        for(int yy:{y,c})\n          for(int ny:{pwu[yy],peu[yy]})\n            if(ny<=y) push(ny,x,step+1,sum+abs(ny-y));\n      }else{        \n        for(int yy:{y,c})\n          for(int ny:{pwl[yy],pel[yy]})\n            if(ny>=y) push(ny,x,step+1,sum+abs(ny-y));\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\n#define MAX_N 100000\n#define MAX_M 100000\n\nusing namespace std;\n\nint N, M, Q;\nstring S, T;\n\nint lowerX[MAX_M];\nint upperX[MAX_M];\nint lowerY[MAX_N];\nint upperY[MAX_N];\n\nvoid initCompress()\n{\n    int le = N;\n    int lw = N;\n    for ( int i = 0; i < N; i++ )\n    {\n        if ( S[i] == 'E' ) le = i;\n        if ( S[i] == 'W' ) lw = i;\n\n        lowerY[i] = min( ( S[i] == 'E' ? lw : le ), i );\n    }\n\n    int ue = -1;\n    int uw = -1;\n    for ( int i = N - 1; i >= 0; i-- )\n    {\n        if ( S[i] == 'E' ) ue = i;\n        if ( S[i] == 'W' ) uw = i;\n\n        upperY[i] = max( ( S[i] == 'E' ? uw : ue ), i );\n    }\n\n    int ln = N;\n    int ls = N;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( T[i] == 'N' ) ln = i;\n        if ( T[i] == 'S' ) ls = i;\n\n        lowerX[i] = min( ( T[i] == 'N' ? ls : ln ), i );\n    }\n\n    int un = -1;\n    int us = -1;\n    for ( int i = M - 1; i >= 0; i-- )\n    {\n        if ( T[i] == 'N' ) un = i;\n        if ( T[i] == 'S' ) us = i;\n\n        upperX[i] = max( ( T[i] == 'N' ? us : un ), i );\n    }\n}\n\nbool visited[6][6];\n\ntypedef pair<int, int> P2;\ntypedef pair<int, P2> P3;\n\nint query( int y1, int x1, int y2, int x2 )\n{\n    vector<int> X;\n    vector<int> Y;\n\n    memset( visited, 0, sizeof( visited ) );\n\n    // initialize X\n    X.push_back( x1 );\n    X.push_back( lowerX[x1] );\n    X.push_back( upperX[x1] );\n    X.push_back( x2 );\n    X.push_back( lowerX[x2] );\n    X.push_back( upperX[x2] );\n\n    sort( X.begin(), X.end() );\n    X.erase( unique( X.begin(), X.end() ), X.end() );\n\n    // initialize Y\n    Y.push_back( y1 );\n    Y.push_back( lowerY[y1] );\n    Y.push_back( upperY[y1] );\n    Y.push_back( y2 );\n    Y.push_back( lowerY[y2] );\n    Y.push_back( upperY[y2] );\n\n    sort( Y.begin(), Y.end() );\n    Y.erase( unique( Y.begin(), Y.end() ), Y.end() );\n\n    int scx = find( X.begin(), X.end(), x1 ) - X.begin(); // index of start x\n    int scy = find( Y.begin(), Y.end(), y1 ) - Y.begin(); // index of start y\n    int gcx = find( X.begin(), X.end(), x2 ) - X.begin(); // index of goal x\n    int gcy = find( Y.begin(), Y.end(), y2 ) - Y.begin(); // index of goal y\n\n    priority_queue<P3> q;\n    q.push( P3( 0, P2( scx, scy ) ) );\n\n    while ( !q.empty() )\n    {\n        int d = q.top().first;\n        int cxi = q.top().second.first;\n        int cyi = q.top().second.second;\n\n        q.pop();\n\n        if ( visited[cxi][cyi] ) continue;\n        visited[cxi][cyi] = true;\n\n        if ( cxi == gcx && cyi == gcy ) return d;\n\n        int x = X[cxi];\n        int y = Y[cyi];\n\n        if ( T[x] == 'N' && 0 <= cyi - 1 )\n        {\n            int ny = Y[cyi - 1];\n            q.push( P3( d + abs( ny - y ), P2( cxi, cyi - 1 ) ) );\n        }\n        else if ( T[x] == 'S' && cyi + 1 < Y.size() )\n        {\n            int ny = Y[cyi + 1];\n            q.push( P3( d + abs( ny - y ), P2( cxi, cyi + 1 ) ) );\n        }\n\n        if ( S[y] == 'W' && 0 <= cxi - 1 )\n        {\n            int nx = X[cxi - 1];\n            q.push( P3( d + abs( nx - x ), P2( cxi - 1, cyi ) ) );\n        }\n        else if ( S[y] == 'E' && cxi + 1 < X.size() )\n        {\n            int nx = X[cxi + 1];\n            q.push( P3( d + abs( nx - x ), P2( cxi + 1, cyi ) ) );\n        }\n    }\n\n    return -1;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M >> Q;\n    cin >> S;\n    cin >> T;\n\n    initCompress();\n\n    for ( int q = 0; q < Q; q++ )\n    {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n\n        int ans = query( a - 1, b - 1, c - 1, d - 1 );\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 5;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\n\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\n\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n    // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (step == BUBEN) return INF;\n   // mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j - 1] == k) nxt[i][val][0][j] = j - 1;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j + 1] == k) nxt[i][val][1][j] = j + 1;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n//        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 6;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\n\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\n\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n    // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (step == BUBEN) return INF;\n   // mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j - 1] == k) nxt[i][val][0][j] = j - 1;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j + 1] == k) nxt[i][val][1][j] = j + 1;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n//        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 200008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\n\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\n\tfor(int i=1;i<=q;i++)\t\n\t{\n\t\tpii s=from[i],t=dest[i];\n\t\t\n\t\tif(s.first>t.first or s.second>t.second) continue;\n\t\t#define case0 case0\n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=ub(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][1]),z=ub(t.first,path[0][0]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n\t\tif(s.second==t.second) continue;\n\t\t#define case1 case1\n\t\tfor(;s.first<=t.first;)\n\t\t{\n\t\t\tint x=lb(s.first,path[0][1]);\n\t\t\tif(!x) break;int tmp=abs(s.first-x)+abs(t.first-x)+abs(s.second-t.second);\n\t\t\tif(x!=s.first) \n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][0]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or y<s.second) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t#define case2 case2\n\n\t\tfor(;s.first<t.first;)//middle\n\t\t{\n\t\t\tint x=ub(s.first,path[0][1]);\n\t\t\tif(x>=t.first or x<=s.first) break;int tmp=abs(s.second-t.second)+abs(s.first-t.first);\n\t\t\tint at=1e9,bt=1e9;\n\t\t\n\t\t\tif(1)\n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\t\n\t\t\t//copied from  line58\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or y<s.second) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//licensed\n\t\t}\n\t}\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\t\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) dir[0][i]^=1;for(int i=1;i<=m;i++) dir[1][i]^=1;\n\tfor(int i=1;i<=q;i++) swap(from[i],dest[i]);\n\t\n\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\nusing namespace std;\nconst int N=2e5+10,mod=1e9+7;\nint n,m,q,Ans,HH[N],ZZ[N],dis[N],vis[N];\nchar s[N],t[N];\nset<int> H[2],Z[2];\nqueue<int> Q;\nstruct Node{int x,y;}P[N];\nvoid GetAns(int x1,int y1,int x2,int y2)\n{\n\tint ch=0,cz=0,c=0;\n\tset<int>::iterator it;\n\tfor(int i=0;i<2;i++)\n\t{\n\t\tit=H[i].lower_bound(x1);\n\t\tif(it!=H[i].end()) HH[++ch]=*it;\n\t\tif(it!=H[i].begin()) HH[++ch]=*(--it);\n\t\tit=H[i].lower_bound(x2);\n\t\tif(it!=H[i].end()) HH[++ch]=*it;\n\t\tif(it!=H[i].begin()) HH[++ch]=*(--it);\n\n\t\tit=Z[i].lower_bound(y1);\n\t\tif(it!=Z[i].end()) ZZ[++cz]=*it;\n\t\tif(it!=Z[i].begin()) ZZ[++cz]=*(--it);\n\t\tit=Z[i].lower_bound(y2);\n\t\tif(it!=Z[i].end()) ZZ[++cz]=*it;\n\t\tif(it!=Z[i].begin()) ZZ[++cz]=*(--it);\n\t}\n\tsort(HH+1,HH+ch+1);\n\tch=unique(HH+1,HH+ch+1)-HH-1;\n\tsort(ZZ+1,ZZ+cz+1);\n\tcz=unique(ZZ+1,ZZ+cz+1)-ZZ-1;\n\t\n\tfor(int i=1;i<=ch;i++)\n\t\tfor(int j=1;j<=cz;j++)\n\t\t\tP[++c]=(Node){HH[i],ZZ[j]};\n\tfor(int i=1;i<=c;i++)\n\t\tif(P[i].x==x1&&P[i].y==y1)\n\t\t\tdis[i]=0,Q.push(i),vis[i]=1;\n\t\telse dis[i]=1e9;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();\n\t\tfor(int i=1;i<=c;i++)\n\t\t{\n\t\t\tif(P[i].x!=P[x].x&&P[i].y!=P[x].y) continue;\n\t\t\tif(P[i].x==P[x].x)\n\t\t\t{\n\t\t\t\tif(P[i].y>P[x].y&&s[P[i].x]=='W') continue;\n\t\t\t\tif(P[i].y<P[x].y&&s[P[i].x]=='E') continue;\n\t\t\t}\n\t\t\tif(P[i].y==P[x].y)\n\t\t\t{\n\t\t\t\tif(P[i].x>P[x].x&&t[P[i].y]=='N') continue;\n\t\t\t\tif(P[i].x<P[x].x&&t[P[i].y]=='S') continue;\n\t\t\t}\n\t\t\tint val=dis[x]+abs(P[i].x-P[x].x)+abs(P[i].y-P[x].y);\n\t\t\tif(dis[i]<=val) continue;\n\t\t\tdis[i]=val;\n\t\t\tif(!vis[i]) Q.push(i),vis[i]=1;\n\t\t}\n\t\tQ.pop(),vis[x]=0;\n\t}\n\tfor(int i=1;i<=c;i++)\n\t\tif(P[i].x==x2&&P[i].y==y2)\n\t\t\tAns=dis[i];\n}\nint main()\n{\n\tscanf(\"%d%d%d%s%s\",&n,&m,&q,s+1,t+1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(s[i]=='E') H[1].insert(i);\n\t\telse H[0].insert(i);\n\tfor(int i=1;i<=m;i++)\n\t\tif(t[i]=='N') Z[1].insert(i);\n\t\telse Z[0].insert(i);\n\tfor(int i=1,x1,y1,x2,y2;i<=q;i++)\n\t{\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tGetAns(x1,y1,x2,y2);\n\t\tif(Ans==1e9) puts(\"-1\");\n\t\telse printf(\"%d\\n\",Ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,q,all,dist[1111],a,b,c,d,it,R,C,aa,bb,cc,dd,ans;\nchar s[111111],t[111111];\nvector<int> h0,h1,v0,v1;\nbool h[111111],v[111111];\nvector<pair<int,int> > g[1111];\nvector<int> ho,ve;\nvoid dijkstra(int S)\n{\n\tpriority_queue<pair<int,int> > pq;\n\tfor (int i=1;i<=all;i++) dist[i]=1e9;\n\tdist[S]=0;\n\tpq.push(make_pair(0,S));\n\twhile(!pq.empty()) \n\t{\n\t\tint x=pq.top().second,y=-pq.top().first;pq.pop();\n\t\tif (dist[x]!=y) continue;\n\t\tfor (int i=0;i<g[x].size();i++)\n\t\t{\n\t\t\tint to=g[x][i].first,val=g[x][i].second;\n\t\t\tif (dist[to]>dist[x]+val)\n\t\t\t{\n\t\t\t\tdist[to]=dist[x]+val;\n\t\t\t\tpq.push(make_pair(-dist[to],to)); \n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s%s\",s,t);\n\tfor (int i=0;i<n;i++)\n\t{\n\t\th[i]=(s[i]=='W');\n\t}\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tv[i]=(t[i]=='N');\n\t}\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tif (h[i])\n\t\t{\n\t\t\th1.push_back(i); \n\t\t}\n\t\telse \n\t\t{\n\t\t\th0.push_back(i); \n\t\t}\n\t}\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tif (v[i])\n\t\t{\n\t\t\tv1.push_back(i); \n\t\t}\n\t\telse\n\t\t{\n\t\t\tv0.push_back(i); \n\t\t}\n\t}\n\twhile(q--)\n\t{\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--;b--;c--;d--;\n\t\tho.clear();ve.clear();\n\t\tho.push_back(a);\n\t\tho.push_back(c);\n\t\tve.push_back(b);\n\t\tve.push_back(d);    \n\t\tif (h[a])\n\t\t{\n\t\t\tit=lower_bound(h0.begin(),h0.end(),a)-h0.begin();\n\t\t\tif (it<(int)h0.size()) ho.push_back(h0[it]); \n\t\t\tit--;\n\t\t\tif (it>=0) ho.push_back(h0[it]); \n\t\t} \n\t\telse\n\t\t{\n\t\t\tit=lower_bound(h1.begin(),h1.end(),a)-h1.begin();\n\t\t\tif (it<(int)h1.size()) ho.push_back(h1[it]); \n\t\t\tit--;\n\t\t\tif (it>=0) ho.push_back(h1[it]); \n\t\t}\n\t\tif (h[c])\n\t\t{\n\t\t\tit=lower_bound(h0.begin(),h0.end(),c)-h0.begin();\n\t\t\tif (it<(int)h0.size()) ho.push_back(h0[it]); \n\t\t\tit--;\n\t\t\tif (it>=0) ho.push_back(h0[it]); \n\t\t} \n\t\telse\n\t\t{\n\t\t\tit=lower_bound(h1.begin(),h1.end(),c)-h1.begin();\n\t\t\tif (it<(int)h1.size()) ho.push_back(h1[it]); \n\t\t\tit--;\n\t\t\tif (it>=0) ho.push_back(h1[it]); \n\t\t}\n\t\tif (v[b])\n\t\t{\n\t\t\tit=lower_bound(v0.begin(),v0.end(),b)-v0.begin();\n\t\t\tif (it<(int)v0.size()) ve.push_back(v0[it]);\n\t\t\tit--;\n\t\t\tif (it>=0) ve.push_back(v0[it]);  \n\t\t}\n\t\telse\n\t\t{\n\t\t\tit=lower_bound(v1.begin(),v1.end(),b)-v1.begin();\n\t\t\tif (it<(int)v1.size()) ve.push_back(v1[it]);\n\t\t\tit--;\n\t\t\tif (it>=0) ve.push_back(v1[it]); \n\t\t}\n\t\tif (v[d])\n\t\t{\n\t\t\tit=lower_bound(v0.begin(),v0.end(),d)-v0.begin();\n\t\t\tif (it<(int)v0.size()) ve.push_back(v0[it]);\n\t\t\tit--;\n\t\t\tif (it>=0) ve.push_back(v0[it]);  \n\t\t}\n\t\telse\n\t\t{\n\t\t\tit=lower_bound(v1.begin(),v1.end(),d)-v1.begin();\n\t\t\tif (it<(int)v1.size()) ve.push_back(v1[it]);\n\t\t\tit--;\n\t\t\tif (it>=0) ve.push_back(v1[it]); \n\t\t}\n\t\tsort(ho.begin(),ho.end());\n\t\tsort(ve.begin(),ve.end());\n\t\tho.resize(unique(ho.begin(),ho.end())-ho.begin());\n\t\tve.resize(unique(ve.begin(),ve.end())-ve.begin());\n\t\tR=ho.size();C=ve.size();\n\t\t//for (int i=0;i<R;i++) cout<<ho[i]<<\" \";\n\t\t//cout<<endl;\n\t\t//for (int i=0;i<C;i++) cout<<ve[i]<<\" \";\n\t\t//cout<<endl;\n\t\tall=R*C;\n\t\tfor (int i=1;i<=all;i++) g[i].clear();\n\t\tfor (int i=0;i<R;i++)\n\t\t{\n\t\t\tfor (int j=0;j<C-1;j++)\n\t\t\t{\n\t\t\t\tif (h[ho[i]])\n\t\t\t\t{\n\t\t\t\t\tg[i*C+j+2].push_back(make_pair(i*C+j+1,ve[j+1]-ve[j])); \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tg[i*C+j+1].push_back(make_pair(i*C+j+2,ve[j+1]-ve[j])); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j=0;j<C;j++)\n\t\t{\n\t\t\tfor (int i=0;i<R-1;i++)\n\t\t\t{\n\t\t\t\tif (v[ve[j]]) \n\t\t\t\t{\n\t\t\t\t\tg[(i+1)*C+j+1].push_back(make_pair(i*C+j+1,ho[i+1]-ho[i])); \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tg[i*C+j+1].push_back(make_pair((i+1)*C+j+1,ho[i+1]-ho[i])); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<R;i++)\n\t\t{\n\t\t\tif (ho[i]==a) aa=i;\n\t\t\tif (ho[i]==c) cc=i;\n\t\t}\n\t\tfor (int i=0;i<C;i++)\n\t\t{\n\t\t\tif (ve[i]==b) bb=i;\n\t\t\tif (ve[i]==d) dd=i;\n\t\t}\n\t\tdijkstra(aa*C+bb+1);\n\t\tans=dist[cc*C+dd+1];\n\t\tif (ans>1e8) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nvector<P> nullvP;\n\nstruct Graph{\n\tint V;\n\tvector<vector<P>> G;\n\tvoid init(int _V){\n\t\tV = _V;\n\t\tG.clear();\n\t\trep(i,V+1){\n\t\t\tG.pb(nullvP);\n\t\t}\n\t}\n\tvoid add_edge(int a,int b,int w = 1){\n\t\t//cout << a << \" \" << b << \" \" << w << endl;\n\t\tG[a].pb(P(b,w));\n\t\t//G[b].pb(P(a,w));\n\t}\n\tint dijkstra(int s,int t){\n\t\t//cout << \"(s,t)=\" << s << \",\" << t << endl;\n\t\tbool used[52];\n\t\tint dist[52];\n\t\tpriority_queue<P,vector<P>,greater<P>> que;\n\t\trep(i,52){\n\t\t\tused[i] = false;\n\t\t\tdist[i] = INF;\n\t\t}\n\t\tdist[s] = 0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\t//cout << p.fr << \" \" << p.sc << endl;\n\t\t\tif(used[p.sc])continue;\n\t\t\tused[p.sc] = true;\n\t\t\tfor(P ed: G[p.sc]){\n\t\t\t\tif(dist[ed.fr] > dist[p.sc]+ed.sc){\n\t\t\t\t\tdist[ed.fr] = dist[p.sc]+ed.sc;\n\t\t\t\t\tque.push(P(dist[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist[t];\n\t}\n}G;\n\nint main(){\n\tstatic int n,m,q;\n\tstatic string s,t;\n\t//static int a[200010],b[200010],c[200010],d[200010];\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tcin >> s >> t;\n\t/*rep1(i,q){\n\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t}*/\n\t\n\tstatic int lw[100010],rw[100010],le[100010],re[100010];\n\tstatic int ln[100010],rn[100010],ls[100010],rs[100010];\n\tlw[0] = le[0] = 0;\n\trep1(i,n){\n\t\tlw[i] = lw[i-1];\n\t\tle[i] = le[i-1];\n\t\tif(s[i-1] == 'W')lw[i] = i;\n\t\telse le[i] = i;\n\t}\n\tln[0] = ls[0] = 0;\n\trep1(i,m){\n\t\tln[i] = ln[i-1];\n\t\tls[i] = ls[i-1];\n\t\tif(t[i-1] == 'N')ln[i] = i;\n\t\telse ls[i] = i;\n\t}\n\trw[n+1] = re[n+1] = n+1;\n\trrep1(i,n){\n\t\trw[i] = rw[i+1];\n\t\tre[i] = re[i+1];\n\t\tif(s[i-1] == 'W')rw[i] = i;\n\t\telse re[i] = i;\n\t}\n\trn[m+1] = rs[m+1] = m+1;\n\trrep1(i,m){\n\t\trn[i] = rn[i+1];\n\t\trs[i] = rs[i+1];\n\t\tif(t[i-1] == 'N')rn[i] = i;\n\t\telse rs[i] = i;\n\t}\n\t\n\t//rep1(i,n)cout << lw[i] << \" \" << rw[i] << \" \" << le[i] << \" \" << re[i] << endl;\n\t//rep1(i,m)cout << ln[i] << \" \" << rn[i] << \" \" << ls[i] << \" \" << rs[i] << endl;\n\t\n\trep1(loop,q){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tvector<int> X,Y;\n\t\tX.pb(a); X.pb(c);\n\t\tif(s[a-1] == 'E'){\n\t\t\tif(lw[a] != 0)X.pb(lw[a]);\n\t\t\tif(rw[a] != n+1)X.pb(rw[a]);\n\t\t}\n\t\telse {\n\t\t\tif(le[a] != 0)X.pb(le[a]);\n\t\t\tif(re[a] != n+1)X.pb(re[a]);\n\t\t}\n\t\tif(s[c-1] == 'E'){\n\t\t\tif(lw[c] != 0)X.pb(lw[c]);\n\t\t\tif(rw[c] != n+1)X.pb(rw[c]);\n\t\t}\n\t\telse {\n\t\t\tif(le[c] != 0)X.pb(le[c]);\n\t\t\tif(re[c] != n+1)X.pb(re[c]);\n\t\t}\n\t\tY.pb(b); Y.pb(d);\n\t\tif(t[b-1] == 'S'){\n\t\t\tif(ln[b] != 0)Y.pb(ln[b]);\n\t\t\tif(rn[b] != m+1)Y.pb(rn[b]);\n\t\t}\n\t\telse {\n\t\t\tif(ls[b] != 0)Y.pb(ls[b]);\n\t\t\tif(rs[b] != m+1)Y.pb(rs[b]);\n\t\t}\n\t\tif(t[d-1] == 'S'){\n\t\t\tif(ln[d] != 0)Y.pb(ln[d]);\n\t\t\tif(rn[d] != m+1)Y.pb(rn[d]);\n\t\t}\n\t\telse {\n\t\t\tif(ls[d] != 0)Y.pb(ls[d]);\n\t\t\tif(rs[d] != m+1)Y.pb(rs[d]);\n\t\t}\n\t\tsor(X); uniq(X);\n\t\tsor(Y); uniq(Y);\n\t\t\n\t\t/*cout << \"X:\";\n\t\tfor(int i: X)cout << i << \" \";\n\t\tcout << endl;\n\t\tcout << \"Y:\";\n\t\tfor(int i: Y)cout << i << \" \";\n\t\tcout << endl;*/\n\t\t\n\t\tint _a = lower_bound(X.begin(),X.end(),a)-X.begin();\n\t\tint _b = lower_bound(Y.begin(),Y.end(),b)-Y.begin();\n\t\tint _c = lower_bound(X.begin(),X.end(),c)-X.begin();\n\t\tint _d = lower_bound(Y.begin(),Y.end(),d)-Y.begin();\n\t\tG.init(X.size()*Y.size());\n\t\trep(i,X.size())rep(j,Y.size())for(int k = j+1 ; k < Y.size() ; k ++){\n\t\t\tif(s[X[i]-1] == 'W')G.add_edge(i*Y.size()+k,i*Y.size()+j,Y[k]-Y[j]);\n\t\t\telse G.add_edge(i*Y.size()+j,i*Y.size()+k,Y[k]-Y[j]);\n\t\t}\n\t\trep(i,X.size())for(int j = i+1 ; j < X.size() ; j ++)rep(k,Y.size()){\n\t\t\tif(t[Y[k]-1] == 'N')G.add_edge(j*Y.size()+k,i*Y.size()+k,X[j]-X[i]);\n\t\t\telse G.add_edge(i*Y.size()+k,j*Y.size()+k,X[j]-X[i]);\n\t\t}\n\t\tint ret = G.dijkstra(_a*Y.size()+_b,_c*Y.size()+_d);\n\t\tif(ret >= INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\",ret);\n\t\t//printf(\"%d\\n\",G.dijkstra(_a*Y.size()+_b,_c*Y.size()+_d));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x1 qwe\n#define y1 qwer\n#define x2 qwert\n#define y2 qwerty\n\nconst int max_n = 100111, inf = 1000111222;\nconst int max_v = 12;\n\nint n, m, qu, dist[max_v][max_v];\nchar s[max_n], t[max_n];\nvector<int> allx, ally;\nvector<int> all_w, all_e, all_n, all_s;\n\nvoid build(vector<int> &all, int x1, int x2, const vector<int> &a, const vector<int> &b) {\n    all.clear();\n    if (x1 > x2) {\n        swap(x1, x2);\n    }\n    vector<int> v{-inf, x1, x2, inf};\n    for (int i = 0; i + 1 < v.size(); ++i) {\n        auto it = lower_bound(a.begin(), a.end(), v[i]);\n        if (it != a.end()) {\n            all.push_back(*it);\n        }\n        it = lower_bound(a.begin(), a.end(), v[i + 1]);\n        if (it != a.begin()) {\n            --it;\n            all.push_back(*it);\n        }\n\n        it = lower_bound(b.begin(), b.end(), v[i]);\n        if (it != b.end()) {\n            all.push_back(*it);\n        }\n        it = lower_bound(b.begin(), b.end(), v[i + 1]);\n        if (it != b.begin()) {\n            --it;\n            all.push_back(*it);\n        }\n    }\n    sort(all.begin(), all.end());\n    all.erase(unique(all.begin(), all.end()), all.end());\n    assert(all.size() <= 12);\n}\n\nvoid build_graph(int x1, int y1, int x2, int y2) {\n    build(allx, x1, x2, all_w, all_e);\n    build(ally, y1, y2, all_n, all_s);\n}\n\npriority_queue<pair<int, pair<int, int>>> q;\n\nvoid upd(int nx, int ny, int x, int y) {\n    if (dist[nx][ny] > dist[x][y] + abs(allx[x] - allx[nx]) + abs(ally[y] - ally[ny])) {\n        dist[nx][ny] = dist[x][y] + abs(allx[x] - allx[nx]) + abs(ally[y] - ally[ny]);\n        q.push({-dist[nx][ny], {nx, ny}});\n    }\n}\n\nvoid dijkstra(int sx, int sy) {\n    for (int i = 0; i < allx.size(); ++i) {\n        for (int j = 0; j < ally.size(); ++j) {\n            dist[i][j] = inf;\n        }\n    }\n    dist[sx][sy] = 0;\n    q.push({0, {sx, sy}});\n    while (!q.empty()) {\n        auto p = q.top();\n        q.pop();\n        int x = p.second.first;\n        int y = p.second.second;\n        if (p.first != -dist[x][y]) {\n            continue;\n        }\n\n        if (x && t[ally[y]] == 'N') {\n            upd(x - 1, y, x, y);\n        }\n        if (x + 1 < allx.size() && t[ally[y]] == 'S') {\n            upd(x + 1, y, x, y);\n        }\n\n        if (y && s[allx[x]] == 'W') {\n            upd(x, y - 1, x, y);\n        }\n        if (y + 1 < ally.size() && s[allx[x]] == 'E') {\n            upd(x, y + 1, x, y);\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d%d%d%s%s\", &n, &m, &qu, s, t);\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == 'E') {\n            all_e.push_back(i);\n        } else {\n            all_w.push_back(i);\n        }\n    }\n    for (int i = 0; i < m; ++i) {\n        if (t[i] == 'N') {\n            all_n.push_back(i);\n        } else {\n            all_s.push_back(i);\n        }\n    }\n    while (qu--) {\n        int x1, y1, x2, y2;\n        scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n        --x1;\n        --y1;\n        --x2;\n        --y2;\n        build_graph(x1, y1, x2, y2);\n        int sx, sy, fx, fy;\n        for (int i = 0; i < allx.size(); ++i) {\n            if (allx[i] == x1) {\n                sx = i;\n            }\n            if (allx[i] == x2) {\n                fx = i;\n            }\n        }\n        for (int i = 0; i < ally.size(); ++i) {\n            if (ally[i] == y1) {\n                sy = i;\n            }\n            if (ally[i] == y2) {\n                fy = i;\n            }\n        }\n        dijkstra(sx, sy);\n        if (dist[fx][fy] == inf) {\n            puts(\"-1\");\n        } else {\n            printf(\"%d\\n\", dist[fx][fy]);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\nint selectSmall(const set<int>& s, int a)\n{\n    auto it = s.upper_bound(a);\n    if(it == s.begin())\n        return -INF;\n    -- it;\n    return *it;\n}\n\nint selectLarge(const set<int>& s, int a)\n{\n    auto it = s.lower_bound(a);\n    if(it == s.end())\n        return INF;\n    return *it;\n}\n\nint solve(\n    const set<int>& leftRoad,\n    const set<int>& rightRoad,\n    const set<int>& upRoad,\n    const set<int>& downRoad,\n    int sy, int sx, int gy, int gx, int depth\n)\n{\n    if(sy == gy){\n        if((leftRoad.find(sy) != leftRoad.end()) ^ (sx < gx))\n            return abs(sx - gx);\n    }\n\n    if(depth == 0)\n        return INF;\n\n    int ans = INF;\n    if(leftRoad.find(sy) != leftRoad.end()){\n        if(upRoad.find(sx) == upRoad.end()){\n            int x1 = selectSmall(upRoad, sx);\n            ans = min(ans, abs(sx - x1) + solve(upRoad, downRoad, leftRoad, rightRoad, x1, sy, gx, gy, depth - 1));\n        }\n        else{\n            int x2 = selectSmall(downRoad, sx);\n            ans = min(ans, abs(sx - x2) + solve(upRoad, downRoad, leftRoad, rightRoad, x2, sy, gx, gy, depth - 1));\n        }\n        if(gx < sx){\n            int x3 = selectSmall(upRoad, gx);\n            int x4 = selectSmall(downRoad, gx);\n            ans = min(ans, abs(sx - x3) + solve(upRoad, downRoad, leftRoad, rightRoad, x3, sy, gx, gy, depth - 1));\n            ans = min(ans, abs(sx - x4) + solve(upRoad, downRoad, leftRoad, rightRoad, x4, sy, gx, gy, depth - 1));\n        }\n    }\n    else{\n        if(upRoad.find(sx) == upRoad.end()){\n            int x1 = selectLarge(upRoad, sx);\n            ans = min(ans, abs(sx - x1) + solve(upRoad, downRoad, leftRoad, rightRoad, x1, sy, gx, gy, depth - 1));\n        }\n        else{\n            int x2 = selectLarge(downRoad, sx);\n            ans = min(ans, abs(sx - x2) + solve(upRoad, downRoad, leftRoad, rightRoad, x2, sy, gx, gy, depth - 1));\n        }\n        if(sx < gx){\n            int x3 = selectLarge(upRoad, gx);\n            int x4 = selectLarge(downRoad, gx);\n            ans = min(ans, abs(sx - x3) + solve(upRoad, downRoad, leftRoad, rightRoad, x3, sy, gx, gy, depth - 1));\n            ans = min(ans, abs(sx - x4) + solve(upRoad, downRoad, leftRoad, rightRoad, x4, sy, gx, gy, depth - 1));\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int h, w, q;\n    cin >> h >> w >> q;\n    string s, t;\n    cin >> s >> t;\n\n    set<int> leftRoad, rightRoad, upRoad, downRoad;\n    for(int y=0; y<h; ++y){\n        if(s[y] == 'W')\n            leftRoad.insert(y+1);\n        else\n            rightRoad.insert(y+1);\n    }\n    for(int x=0; x<w; ++x){\n        if(t[x] == 'N')\n            upRoad.insert(x+1);\n        else\n            downRoad.insert(x+1);\n    }\n\n    while(--q >= 0){\n        int sy, sx, gy, gx;\n        cin >> sy >> sx >> gy >> gx;\n        int ans = min(solve(leftRoad, rightRoad, upRoad, downRoad, sy, sx, gy, gx, 4),\n                      solve(upRoad, downRoad, leftRoad, rightRoad, sx, sy, gx, gy, 4));\n        if(ans < INF)\n            cout << ans << endl;\n        else\n            cout << -1 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n, m, q;\n  string S, T;\n  cin >> n >> m >> q >> S >> T;\n  auto init_pre = [&] (string str, vector<int> &pre_0, vector<int> &pre_1) {\n    for (int i = 0; i < str.size(); i++) {\n      if (!i) {\n        pre_0[i] = -1;\n        pre_1[i] = -1;\n      } else {\n        pre_0[i] = pre_0[i - 1];\n        pre_1[i] = pre_1[i - 1];\n      }\n      if (str[i] == 'W' || str[i] == 'N') {\n        pre_0[i] = i;\n      } else {\n        pre_1[i] = i;\n      }\n    }\n  };\n  vector<int> pre_W(n), pre_E(n), pre_N(m), pre_S(m);\n  init_pre(S, pre_W, pre_E);\n  init_pre(T, pre_N, pre_S);\n  auto init_nxt = [&] (string str, vector<int> &nxt_0, vector<int> &nxt_1) {\n    for (int i = str.size() - 1; i >= 0; i--) {\n      if (i == str.size() - 1) {\n        nxt_0[i] = str.size();\n        nxt_1[i] = str.size();\n      } else {\n        nxt_0[i] = nxt_0[i + 1];\n        nxt_1[i] = nxt_1[i + 1];\n      }\n      if (str[i] == 'W' || str[i] == 'N') {\n        nxt_0[i] = i;\n      } else {\n        nxt_1[i] = i;\n      }\n    }\n  };\n  vector<int> nxt_W(n), nxt_E(n), nxt_N(m), nxt_S(m);\n  init_nxt(S, nxt_W, nxt_E);\n  init_nxt(T, nxt_N, nxt_S);\n  vector<bool> vis_x(n), vis_y(m);\n  while (q--) {\n    std::vector<int> vec_x, vec_y;\n    auto add_x = [&] (int x) {\n      if (x >= 0 && x < n && !vis_x[x]) {\n        vis_x[x] = true;\n        vec_x.push_back(x);\n      }\n    };\n    auto add_point_x = [&] (int x) {\n      add_x(pre_W[x]);\n      add_x(pre_E[x]);\n      add_x(nxt_W[x]);\n      add_x(nxt_E[x]);\n    };\n    auto add_y = [&] (int y) {\n      if (y >= 0 && y < m && !vis_y[y]) {\n        vis_y[y] = true;\n        vec_y.push_back(y);\n      }\n    };\n    auto add_point_y = [&] (int y) {\n      add_y(pre_N[y]);\n      add_y(pre_S[y]);\n      add_y(nxt_N[y]);\n      add_y(nxt_S[y]);\n    };\n    int sx, sy, tx, ty;\n    cin >> sx >> sy >> tx >> ty;\n    add_point_x(--sx);\n    add_point_x(--tx);\n    add_point_y(--sy);\n    add_point_y(--ty);\n    sort(vec_x.begin(), vec_x.end());\n    sort(vec_y.begin(), vec_y.end());\n    int len_x = vec_x.size(), len_y = vec_y.size(), tot = 0;\n    vector<vector<int> > node(len_x, vector<int>(len_y));\n    for (int i = 0; i < len_x; i++) {\n      for (int j = 0; j < len_y; j++) {\n        node[i][j] = tot++;\n      }\n    }\n    vector<vector<pair<int, int> > > adj(tot);\n    for (int i = 0; i < len_x; i++) {\n      for (int j = 0; j < len_y; j++) {\n        if (S[vec_x[i]] == 'E' && j + 1 < len_y) {\n          adj[node[i][j]].emplace_back(node[i][j + 1], vec_y[j + 1] - vec_y[j]);\n        }\n        if (S[vec_x[i]] == 'W' && j) {\n          adj[node[i][j]].emplace_back(node[i][j - 1], vec_y[j] - vec_y[j - 1]);\n        }\n        if (T[vec_y[j]] == 'N' && i) {\n          adj[node[i][j]].emplace_back(node[i - 1][j], vec_x[i] - vec_x[i - 1]);\n        }\n        if (T[vec_y[j]] == 'S' && i + 1 < len_x) {\n          adj[node[i][j]].emplace_back(node[i + 1][j], vec_x[i + 1] - vec_x[i]);\n        }\n      }\n    }\n    vector<int> dis(tot, INT_MAX);\n    priority_queue<pair<int, int> > que;\n    int source = node[lower_bound(vec_x.begin(), vec_x.end(), sx) - vec_x.begin()][lower_bound(vec_y.begin(), vec_y.end(), sy) - vec_y.begin()];\n    dis[source] = 0;\n    que.emplace(0, source);\n    while (!que.empty()) {\n      auto it = que.top();\n      que.pop();\n      int u = it.second;\n      if (dis[u] != -it.first) {\n        continue;\n      }\n      for (auto e : adj[u]) {\n        int v = e.first, w = e.second;\n        if (dis[v] > dis[u] + w) {\n          dis[v] = dis[u] + w;\n          que.emplace(-dis[v], v);\n        }\n      }\n    }\n    int end = node[lower_bound(vec_x.begin(), vec_x.end(), tx) - vec_x.begin()][lower_bound(vec_y.begin(), vec_y.end(), ty) - vec_y.begin()];\n    if (dis[end] == INT_MAX) {\n      cout << -1 << \"\\n\";\n    } else {\n      cout << dis[end] << \"\\n\";\n    }\n    for (int x : vec_x) {\n      vis_x[x] = false;\n    }\n    for (int y : vec_y) {\n      vis_y[y] = false;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint h,w,q;\nstring s,t;\nvi a,b,c[4];\n\nint f(int x,int y,int X,int Y){\n\tint I=a[x],J=b[y];\n\tbool bx=0,by=0;\n\tif(I==1&&Y<=y||I==3&&y<=Y) bx=1;\n\tif(J==0&&X<=x||J==2&&x<=X) by=1;\n\tif(bx&&by){\n\t\tif(I==a[X]||J==b[Y]) return abs(x-X)+abs(y-Y);\n\t\tauto ix=lower_bound(c[I].begin(),c[I].end(),X);\n\t\tauto iy=lower_bound(c[J].begin(),c[J].end(),Y);\n\t\tif(J==0) ix--;\n\t\tif(I==1) iy--;\n\t\tint tx=(0<=*ix&&*ix<h?abs(*ix-x)+abs(*ix-X)+abs(y-Y):inf);\n\t\tint ty=(0<=*iy&&*iy<w?abs(*iy-y)+abs(*iy-Y)+abs(x-X):inf);\n\t\treturn min(tx,ty);\n\t}\n\tauto ix=lower_bound(c[(I+2)%4].begin(),c[(I+2)%4].end(),x);\n\tauto iy=lower_bound(c[(J+2)%4].begin(),c[(J+2)%4].end(),y);\n\tif(J==0) ix--;\n\tif(I==1) iy--;\n\tint tx=(0<=*ix&&*ix<h?f(*ix,y,X,Y)+abs(*ix-x):inf);\n\tint ty=(0<=*iy&&*iy<w?f(x,*iy,X,Y)+abs(*iy-y):inf);\n\treturn min(tx,ty);\n}\n\nint main(){\n\tcin>>h>>w>>q>>s>>t;\n\ta=vi(h,1);\n\tb=vi(w);\n\tfor(int i=0;i<4;i++) c[i].push_back(-1);\n\tfor(int i=0;i<h;i++){\n\t\tif(s[i]=='E') a[i]=3;\n\t\tc[a[i]].push_back(i);\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tif(t[i]=='S') b[i]=2;\n\t\tc[b[i]].push_back(i);\n\t}\n\tfor(int i=0;i<4;i++) c[i].push_back(inf);\n\tfor(int i=0;i<q;i++){\n\t\tint x,y,X,Y;\n\t\tcin>>x>>y>>X>>Y;\n\t\tint res=f(x-1,y-1,X-1,Y-1);\n\t\tcout<<(res==inf?-1:res)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q;\n    cin >> n >> m >> q;\n    string s,t;\n    cin >> s >> t;\n    vector<int> L,R;\n    vector<int> U,D;\n    rep(i,n){\n        if(s[i]=='W'){\n            L.push_back(i);\n        }else{\n            R.push_back(i);\n        }\n    }\n    rep(i,m){\n        if(t[i]=='N'){\n            U.push_back(i);\n        }else{\n            D.push_back(i);\n        }\n    }\n    rep(zz,q){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        a--;b--;c--;d--;\n        queue<pair<pair<pair<int,int>,pair<int,int> >,pair<int,int> > >q;\n        if(t[b]=='N'){\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(-1,1)));\n        }else{\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(1,1)));\n        }\n        if(s[a]=='W'){\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(-1,0)));\n        }else{\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(1,0)));\n        }\n        int mi = inf;\n        while(!q.empty()){\n            auto x = q.front();\n            q.pop();\n            int dist = x.first.first.first;\n            int cnt = x.first.first.second;\n            int na = x.first.second.first;\n            int nb = x.first.second.second;\n            int pl = x.second.first;\n            int dir = x.second.second;\n            // cerr << na << \" \" << nb << \" \" << dist << \" \" << cnt << \" \" << pl << \" \" << dir << endl;\n            if(na==c&&nb==d){\n                chmin(mi,dist);\n                continue;\n            }\n            if(cnt==6)continue;\n            if(dir==1){// UP DOWN\n                if(pl==-1){//UP\n                    if(c<na&&nb==d){\n                        chmin(mi,dist+na-c);\n                        continue;\n                    }        \n                    if(nb<=d){\n                        int tar = min(na,c);\n                        auto x = lower_bound(all(R),tar);\n                        if(x!=R.end()){\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                        if(x!=R.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                    }\n                    if(nb>=d){\n                        int tar = min(na,c);\n                        auto x = lower_bound(all(L),tar);\n                        if(x!=L.end()){\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                        if(x!=L.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                    }\n                }else{//DOWN\n                    if(c>na&&nb==d){\n                        chmin(mi,dist+abs(c-na));\n                        continue;\n                    }        \n                    if(nb<=d){\n                        int tar = max(na,c);\n                        auto x = lower_bound(all(R),tar);\n                        if(x!=R.end()){\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                        if(x!=R.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                    }\n                    if(nb>=d){\n                        int tar = max(na,c);\n                        auto x = lower_bound(all(L),tar);\n                        if(x!=L.end()){\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                        if(x!=L.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                    }\n                }\n\n            }else{// LEFT RIGHT\n                if(pl==-1){//LEFT\n                    if(d<nb&&na==c){\n                        chmin(mi,dist+abs(nb-d));\n                        continue;\n                    }        \n                    if(na<=c){\n                        int tar = min(nb,d);\n                        auto x = lower_bound(all(D),tar);\n                        if(x!=D.end()){\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                        if(x!=D.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                    }\n                    if(na>=c){\n                        int tar = min(nb,d);\n                        auto x = lower_bound(all(U),tar);\n                        if(x!=U.end()){\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                        if(x!=U.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                    }\n                }else{//RIGHT\n                    if(d>nb&&na==c){\n                        chmin(mi,dist+abs(d-nb));\n                        continue;\n                    }        \n                    if(na<=c){\n                        int tar = max(nb,d);\n                        auto x = lower_bound(all(D),tar);\n                        if(x!=D.end()){\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                        if(x!=D.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                    }\n                    if(na>=c){\n                        int tar = max(nb,d);\n                        auto x = lower_bound(all(U),tar);\n                        if(x!=U.end()){\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                        if(x!=U.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                    }\n                }\n            }\n        }\n        if(mi!=inf){\n            cout << mi << \"\\n\";\n        }else{\n            cout << -1 << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdint>\n#include <type_traits>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <initializer_list>\nnamespace loquat {\nnamespace bitmanip {\ntemplate <typename T>\ninline auto ctz(T x) noexcept ->\n\ttypename std::enable_if<sizeof(T) <= sizeof(int), unsigned int>::type\n{\n\treturn __builtin_ctz(x);\n}\ntemplate <typename T>\ninline auto ctz(T x) noexcept ->\n\ttypename std::enable_if<sizeof(int) < sizeof(T), unsigned int>::type\n{\n\treturn __builtin_ctzll(x);\n}\ntemplate <typename T>\ninline auto clz(T x) noexcept ->\n\ttypename std::enable_if<sizeof(int) < sizeof(T), unsigned int>::type\n{\n\treturn __builtin_clzll(x);\n}\ntemplate <typename T>\ninline T flp2(T x) noexcept {\n\tif(x == 0u){ return 0u; }\n\treturn T(1u) << (sizeof(T) * 8u - 1u - clz(x));\n}\n}\n}\nnamespace loquat {\ntemplate <typename Impl>\nclass range_query_behavior_wrapper {\npublic:\n\tusing value_type = typename Impl::value_type;\nprivate:\n\tImpl m_impl;\npublic:\n\trange_query_behavior_wrapper(Impl impl) : m_impl(std::move(impl)) { }\n\tvalue_type identity() const {\n\t\treturn m_impl.identity();\n\t}\n\tvalue_type merge(const value_type& a, const value_type& b) const {\n\t\treturn m_impl.merge(a, b);\n\t}\n};\n}\nnamespace loquat {\ntemplate <typename Behavior>\nclass nazo_table {\npublic:\n\tusing behavior_type = Behavior;\n\tusing value_type = typename behavior_type::value_type;\nprivate:\n\tstd::vector<std::vector<value_type>> m_table;\n\trange_query_behavior_wrapper<behavior_type> m_behavior;\n\ttemplate <typename Iterator>\n\tvoid forward_fill(Iterator it, int row, int first, int last){\n\t\tvalue_type acc = m_behavior.identity();\n\t\tm_table[row][first] = acc;\n\t\tfor(int i = first + 1; i < last; ++i, ++it){\n\t\t\tacc = m_behavior.merge(acc, *it);\n\t\t\tm_table[row][i] = acc;\n\t\t}\n\t}\n\ttemplate <typename Iterator>\n\tvoid backward_fill(Iterator it, int row, int first, int last){\n\t\tvalue_type acc = m_behavior.identity();\n\t\t--it;\n\t\tfor(int i = first - 1; i >= last; --i, --it){\n\t\t\tacc = m_behavior.merge(*it, acc);\n\t\t\tm_table[row][i] = acc;\n\t\t}\n\t}\n\ttemplate <typename Iterator>\n\tvoid fill_table(Iterator first, Iterator last){\n\t\tconst int n = std::distance(first, last);\n\t\tIterator it = std::next(first);\n\t\tfor(int i = 1; i <= n; ++i, ++it){\n\t\t\tconst int s = bitmanip::ctz(i);\n\t\t\twhile(m_table.size() <= static_cast<size_t>(s)){\n\t\t\t\tm_table.emplace_back(n + 1);\n\t\t\t}\n\t\t\tbackward_fill(it, s, i, i - (1 << s));\n\t\t\tforward_fill(it, s, i, std::min(n + 1, i + (1 << s)));\n\t\t}\n\t}\npublic:\n\ttemplate <typename Iterator>\n\tnazo_table(\n\t\tIterator first,\n\t\tIterator last,\n\t\tconst behavior_type& behavior = behavior_type())\n\t\t: m_table()\n\t\t, m_behavior(behavior)\n\t{\n\t\tfill_table(first, last);\n\t}\n\tvalue_type query(size_t l, size_t r) const {\n\t\tif(l == r){ return m_behavior.identity(); }\n\t\tconst int s = bitmanip::ctz(bitmanip::flp2(l ^ r));\n\t\treturn m_behavior.merge(m_table[s][l], m_table[s][r]);\n\t}\n};\n}\nusing namespace std;\nstatic const int INF = 1000000000;\nstruct min_behavior {\n\tusing value_type = int;\n\tvalue_type identity() const { return numeric_limits<int>::max(); }\n\tvalue_type merge(const value_type& a, const value_type& b) const { return min(a, b); }\n};\nstruct max_behavior {\n\tusing value_type = int;\n\tvalue_type identity() const { return numeric_limits<int>::min(); }\n\tvalue_type merge(const value_type& a, const value_type& b) const { return max(a, b); }\n};\nint solve(\n\tint depth, int a, int b, int c, int d,\n\tconst string& hor, const string& ver,\n\tconst loquat::nazo_table<min_behavior>& min_w,\n\tconst loquat::nazo_table<max_behavior>& max_w,\n\tconst loquat::nazo_table<min_behavior>& min_e,\n\tconst loquat::nazo_table<max_behavior>& max_e,\n\tconst loquat::nazo_table<min_behavior>& min_n,\n\tconst loquat::nazo_table<max_behavior>& max_n,\n\tconst loquat::nazo_table<min_behavior>& min_s,\n\tconst loquat::nazo_table<max_behavior>& max_s)\n{\n\tif(depth > 5){ return INF; }\n\tconst int n = hor.size(), m = ver.size();\n\tint answer = INF;\n\tif(hor[a] == 'W' || hor[a] == 'N'){\n\t\tif(d < b){\n\t\t\tif(a == c){ answer = min(answer, b - d); }\n\t\t\tconst int x1 = max_n.query(0, b + 1);\n\t\t\tif(x1 >= 0){ answer = min(answer, solve(depth + 1, x1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - x1)); }\n\t\t\tconst int y1 = max_s.query(0, b + 1);\n\t\t\tif(y1 >= 0){ answer = min(answer, solve(depth + 1, y1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - y1)); }\n\t\t\tconst int x2 = max_n.query(0, d + 1);\n\t\t\tif(x2 >= 0 && x1 != x2){ answer = min(answer, solve(depth + 1, x2, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - x2)); }\n\t\t\tconst int y2 = max_s.query(0, d + 1);\n\t\t\tif(y2 >= 0 && y1 != y2){ answer = min(answer, solve(depth + 1, y2, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - y2)); }\n\t\t}else{\n\t\t\tconst int x1 = max_n.query(0, b + 1);\n\t\t\tif(x1 >= 0){ answer = min(answer, solve(depth + 1, x1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - x1)); }\n\t\t\tconst int y1 = max_s.query(0, b + 1);\n\t\t\tif(y1 >= 0){ answer = min(answer, solve(depth + 1, y1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - y1)); }\n\t\t}\n\t}else{\n\t\tif(d > b){\n\t\t\tif(a == c){ answer = min(answer, d - b); }\n\t\t\tconst int x1 = min_n.query(b, m);\n\t\t\tif(x1 < m){ answer = min(answer, solve(depth + 1, x1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (x1 - b)); }\n\t\t\tconst int y1 = min_s.query(b, m);\n\t\t\tif(y1 < m){ answer = min(answer, solve(depth + 1, y1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (y1 - b)); }\n\t\t\tconst int x2 = min_n.query(d, m);\n\t\t\tif(x2 < m && x1 != x2){ answer = min(answer, solve(depth + 1, x2, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (x2 - b)); }\n\t\t\tconst int y2 = min_s.query(d, m);\n\t\t\tif(y2 < m && y1 != y2){ answer = min(answer, solve(depth + 1, y2, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (y2 - b)); }\n\t\t}else{\n\t\t\tconst int x1 = min_n.query(b, m);\n\t\t\tif(x1 < m){ answer = min(answer, solve(depth + 1, x1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (x1 - b)); }\n\t\t\tconst int y1 = min_s.query(b, m);\n\t\t\tif(y1 < m){ answer = min(answer, solve(depth + 1, y1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (y1 - b)); }\n\t\t}\n\t}\n\treturn answer;\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, q;\n\tstring hor, ver;\n\tcin >> n >> m >> q >> hor >> ver;\n\tvector<int> min_w_init(n, numeric_limits<int>::max());\n\tvector<int> max_w_init(n, numeric_limits<int>::min());\n\tvector<int> min_e_init(n, numeric_limits<int>::max());\n\tvector<int> max_e_init(n, numeric_limits<int>::min());\n\tvector<int> min_n_init(m, numeric_limits<int>::max());\n\tvector<int> max_n_init(m, numeric_limits<int>::min());\n\tvector<int> min_s_init(m, numeric_limits<int>::max());\n\tvector<int> max_s_init(m, numeric_limits<int>::min());\n\tfor(int i = 0; i < n; ++i){\n\t\tif(hor[i] == 'W'){\n\t\t\tmin_w_init[i] = i;\n\t\t\tmax_w_init[i] = i;\n\t\t}else{\n\t\t\tmin_e_init[i] = i;\n\t\t\tmax_e_init[i] = i;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++i){\n\t\tif(ver[i] == 'N'){\n\t\t\tmin_n_init[i] = i;\n\t\t\tmax_n_init[i] = i;\n\t\t}else{\n\t\t\tmin_s_init[i] = i;\n\t\t\tmax_s_init[i] = i;\n\t\t}\n\t}\n\tconst loquat::nazo_table<min_behavior> min_w(min_w_init.begin(), min_w_init.end());\n\tconst loquat::nazo_table<max_behavior> max_w(max_w_init.begin(), max_w_init.end());\n\tconst loquat::nazo_table<min_behavior> min_e(min_e_init.begin(), min_e_init.end());\n\tconst loquat::nazo_table<max_behavior> max_e(max_e_init.begin(), max_e_init.end());\n\tconst loquat::nazo_table<min_behavior> min_n(min_n_init.begin(), min_n_init.end());\n\tconst loquat::nazo_table<max_behavior> max_n(max_n_init.begin(), max_n_init.end());\n\tconst loquat::nazo_table<min_behavior> min_s(min_s_init.begin(), min_s_init.end());\n\tconst loquat::nazo_table<max_behavior> max_s(max_s_init.begin(), max_s_init.end());\n\twhile(q--){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\t--a; --b; --c; --d;\n\t\tconst int answer = min(\n\t\t \tsolve(0, a, b, c, d, hor, ver, min_w, max_w, min_e, max_e, min_n, max_n, min_s, max_s),\n\t\t \tsolve(0, b, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e));\n\t\tif(answer >= INF){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tcout << answer << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n\nstring u[2];\nint sx, sy, gx, gy;\nvector<int> vx[2][2];\nint d[36];\nstruct edge {\n\tint to, cost;\n};\nvector<edge> G[36];\npriority_queue<P, vector<P>, greater<P>> que;\nvoid calc(vector<int> x, vector<int> y) {\n\trep(i, 36)G[i].clear();\n\tfill(d, d + 36, mod);\n\tsort(x.begin(), x.end()); x.erase(unique(x.begin(), x.end()), x.end());\n\tsort(y.begin(), y.end()); y.erase(unique(y.begin(), y.end()), y.end());\n\tint lx = x.size(), ly = y.size();\n\tint s=0, g=0;\n\trep(i, x.size()) {\n\t\tif (sx == x[i]) {\n\t\t\ts += i * ly;\n\t\t}\n\t\tif (gx == x[i]) {\n\t\t\tg += i * ly;\n\t\t}\n\t}\n\trep(i, y.size()) {\n\t\tif (sy == y[i]) {\n\t\t\ts += i;\n\t\t}\n\t\tif (gy == y[i]) {\n\t\t\tg += i;\n\t\t}\n\t}\n\trep(i, lx - 1) {\n\t\tint dif = x[i + 1] - x[i];\n\t\trep(j, ly) {\n\t\t\tint id = i * ly + j;\n\t\t\tif (u[1][y[j]] == 'N') {\n\t\t\t\tG[id + ly].push_back({ id,dif });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG[id].push_back({ id + ly,dif });\n\t\t\t}\n\t\t}\n\t}\n\trep(i, lx) {\n\t\trep(j, ly - 1) {\n\t\t\tint dif = y[j + 1] - y[j];\n\t\t\tint id = i * ly + j;\n\t\t\tif (u[0][x[i]] == 'W') {\n\t\t\t\tG[id + 1].push_back({ id,dif });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tG[id].push_back({ id + 1,dif });\n\t\t\t}\n\t\t}\n\t}\n\td[s] = 0; que.push({ 0,s });\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\trep(j, G[v].size()) {\n\t\t\tint to = G[v][j].to;\n\t\t\tint nd = G[v][j].cost + p.first;\n\t\t\tif(nd < d[to]) {\n\t\t\t\td[to] = nd;\n\t\t\t\tque.push({ nd,to });\n\t\t\t}\n\t\t}\n\t}\n\tint ret = d[g];\n\tif (ret == mod)ret = -1;\n\tcout << ret << endl;\n}\nint trans(char t) {\n\tif (t == 'W' || t == 'N')return 0;\n\telse return 1;\n}\nvector<int> x[2];\nvoid add(int id,int loc) {\n\tx[id].push_back(loc);\n\tint t = trans(u[id][loc]);\n\tint idd= upper_bound(vx[id][t ^ 1].begin(), vx[id][t ^ 1].end(), loc) - vx[id][t ^ 1].begin();\n\tif (idd < vx[id][t ^ 1].size()) {\n\t\tx[id].push_back(vx[id][t ^ 1][idd]);\n\t}\n\tif (idd >= 1) {\n\t\tx[id].push_back(vx[id][t ^ 1][idd - 1]);\n\t}\n}\nvoid solve() {\n\tint n[2], q; cin >> n[0] >> n[1] >> q;\n\trep(i, 2) {\n\t\tcin >> u[i];\n\t\trep(j, n[i]) {\n\t\t\tif (u[i][j] == 'W') {\n\t\t\t\tvx[0][0].push_back(j);\n\t\t\t}\n\t\t\telse if (u[i][j] == 'E') {\n\t\t\t\tvx[0][1].push_back(j);\n\t\t\t}\n\t\t\telse if (u[i][j] == 'N') {\n\t\t\t\tvx[1][0].push_back(j);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvx[1][1].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, q) {\n\t\tx[0].clear(); x[1].clear();\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tsx--; sy--; gx--; gy--;\n\t\tadd(0, sx); add(1, sy);\n\t\tadd(0, gx); add(1, gy);\n\t\tcalc(x[0],x[1]);\n\t\t/*rep(j, x[0].size()) {\n\t\t\tcout << x[0][j] << endl;\n\t\t}\n\t\tcout << \"in\" << endl;\n\t\trep(j, x[1].size()) {\n\t\t\tcout << x[1][j] << endl;\n\t\t}\n\t\tcout << \"out\" << endl;*/\n\t}\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005,dir[2]={-1,1},inf=1e8;\nstruct node{int x,y,d;}; vector<node> R1,C1,R2,C2;\nint x[N][2],y[N][2],r[N],c[N];\nint n,m,Q,a,b,u,v;\nchar sr[N],sc[N];\n\nvoid dfs1R(int k,int a,int b,int d);\nvoid dfs1C(int k,int a,int b,int d);\nvoid dfs2R(int k,int a,int b,int d);\nvoid dfs2C(int k,int a,int b,int d);\n\nvoid dfs1R(int k,int a,int b,int d){\n\tif(a<1||a>n||b<1||b>m) return;\n\tR1.pb((node){a,b,d});\n\tif(!k) return;\n\tdfs1C(k-1,a,b,d);\n\tdfs1C(k-1,a,y[b][r[a]],d+abs(y[b][r[a]]-b));\n}\nvoid dfs1C(int k,int a,int b,int d){\n\tif(a<1||a>n||b<1||b>m) return;\n\tC1.pb((node){a,b,d});\n\tif(!k) return;\n\tdfs1R(k-1,a,b,d);\n\tdfs1R(k-1,x[a][c[b]],b,d+abs(x[a][c[b]]-a));\n}\nvoid dfs2R(int k,int a,int b,int d){\n\tif(a<1||a>n||b<1||b>m) return;\n\tR2.pb((node){a,b,d});\n\tif(!k) return;\n\tdfs2C(k-1,a,b,d);\n\tdfs2C(k-1,a,y[b][1-r[a]],d+abs(y[b][1-r[a]]-b));\n}\nvoid dfs2C(int k,int a,int b,int d){\n\tif(a<1||a>n||b<1||b>m) return;\n\tC2.pb((node){a,b,d});\n\tif(!k) return;\n\tdfs2R(k-1,a,b,d);\n\tdfs2R(k-1,x[a][1-c[b]],b,d+abs(x[a][1-c[b]]-a));\n}\n\nint main(){\n\tread(n),read(m),read(Q);\n\tscanf(\"%s%s\",sr+1,sc+1);\n\tr[0]=r[n+1]=c[0]=c[m+1]=-1;\n\trep(i,1,n) r[i]=(sr[i]=='E');\n\trep(i,1,m) c[i]=(sc[i]=='S');\n\trep(i,1,n) x[i][0]=(r[i]!=r[i-1]?i-1:x[i-1][0]);\n\tper(i,n,1) x[i][1]=(r[i]!=r[i+1]?i+1:x[i+1][1]);\n\trep(i,1,m) y[i][0]=(c[i]!=c[i-1]?i-1:y[i-1][0]);\n\tper(i,m,1) y[i][1]=(c[i]!=c[i+1]?i+1:y[i+1][1]);\n\twhile(Q--){\n\t\tread(a),read(b),read(u),read(v);\n\t\tR1.clear(),C1.clear(),R2.clear(),C2.clear();\n\t\tdfs1R(2,a,b,0),dfs1C(2,a,b,0);\n\t\tdfs2R(2,u,v,0),dfs2C(2,u,v,0);\n\t\tint ans=inf;\n\t\tfor(auto p:R1) for(auto q:C2){\n\t\t\tint R=(q.y-p.y)*dir[r[p.x]];\n\t\t\tint C=(q.x-p.x)*dir[c[q.y]];\n\t\t\tif(R>=0&&C>=0) ans=min(ans,R+C+p.d+q.d);\n\t\t}\n\t\tfor(auto p:C1) for(auto q:R2){\n\t\t\tint R=(q.y-p.y)*dir[r[q.x]];\n\t\t\tint C=(q.x-p.x)*dir[c[p.y]];\n\t\t\tif(R>=0&&C>=0) ans=min(ans,R+C+p.d+q.d);\n\t\t}\n\t\tprintf(\"%d\\n\",ans>=inf?-1:ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q;\n    cin >> n >> m >> q;\n    string s,t;\n    cin >> s >> t;\n    vector<int> L,R;\n    vector<int> U,D;\n    rep(i,n){\n        if(s[i]=='W'){\n            L.push_back(i);\n        }else{\n            R.push_back(i);\n        }\n    }\n    rep(i,m){\n        if(t[i]=='N'){\n            U.push_back(i);\n        }else{\n            D.push_back(i);\n        }\n    }\n    rep(zz,q){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        a--;b--;c--;d--;\n        queue<pair<pair<pair<int,int>,pair<int,int> >,pair<int,int> > >q;\n        if(t[b]=='N'){\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(-1,1)));\n        }else{\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(1,1)));\n        }\n        if(s[a]=='W'){\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(-1,0)));\n        }else{\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(1,0)));\n        }\n        int mi = inf;\n        while(!q.empty()){\n            auto x = q.front();\n            q.pop();\n            int dist = x.first.first.first;\n            int cnt = x.first.first.second;\n            int na = x.first.second.first;\n            int nb = x.first.second.second;\n            int pl = x.second.first;\n            int dir = x.second.second;\n            // cerr << na << \" \" << nb << \" \" << dist << \" \" << cnt << \" \" << pl << \" \" << dir << endl;\n            if(na==c&&nb==d){\n                chmin(mi,dist);\n                continue;\n            }\n            if(cnt==5)continue;\n            if(dir==1){// UP DOWN\n                if(pl==-1){//UP\n                    if(c<na&&nb==d){\n                        chmin(mi,dist+na-c);\n                        continue;\n                    }        \n                    if(nb<=d){\n                        int tar = min(na,c);\n                        auto x = lower_bound(all(R),tar);\n                        if(x!=R.end()){\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                        if(x!=R.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                    }\n                    if(nb>=d){\n                        int tar = min(na,c);\n                        auto x = lower_bound(all(L),tar);\n                        if(x!=L.end()){\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                        if(x!=L.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                    }\n                }else{//DOWN\n                    if(c>na&&nb==d){\n                        chmin(mi,dist+abs(c-na));\n                        continue;\n                    }        \n                    if(nb<=d){\n                        int tar = max(na,c);\n                        auto x = lower_bound(all(R),tar);\n                        if(x!=R.end()){\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                        if(x!=R.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                    }\n                    if(nb>=d){\n                        int tar = max(na,c);\n                        auto x = lower_bound(all(L),tar);\n                        if(x!=L.end()){\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                        if(x!=L.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                    }\n                }\n\n            }else{// LEFT RIGHT\n                if(pl==-1){//LEFT\n                    if(d<nb&&na==c){\n                        chmin(mi,dist+abs(nb-d));\n                        continue;\n                    }        \n                    if(na<=c){\n                        int tar = min(nb,d);\n                        auto x = lower_bound(all(D),tar);\n                        if(x!=D.end()){\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                        if(x!=D.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                    }\n                    if(na>=c){\n                        int tar = min(nb,d);\n                        auto x = lower_bound(all(U),tar);\n                        if(x!=U.end()){\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                        if(x!=U.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                    }\n                }else{//RIGHT\n                    if(d>nb&&na==c){\n                        chmin(mi,dist+abs(d-nb));\n                        continue;\n                    }        \n                    if(na<=c){\n                        int tar = max(nb,d);\n                        auto x = lower_bound(all(D),tar);\n                        if(x!=D.end()){\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                        if(x!=D.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                    }\n                    if(na>=c){\n                        int tar = max(nb,d);\n                        auto x = lower_bound(all(U),tar);\n                        if(x!=U.end()){\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                        if(x!=U.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                    }\n                }\n            }\n        }\n        if(mi!=inf){\n            cout << mi << \"\\n\";\n        }else{\n            cout << -1 << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint h,w,q;\nstring s,t;\nvi a,b,c[4];\n\nint f(int x,int y,int X,int Y,bool fx=1,bool fy=1){\n\tint I=a[x],J=b[y];\n\tbool bx=0,by=0;\n\tif(I==1&&Y<=y||I==3&&y<=Y) bx=1;\n\tif(J==0&&X<=x||J==2&&x<=X) by=1;\n\tif(bx&&by){\n\t\tif(I==a[X]||J==b[Y]) return abs(x-X)+abs(y-Y);\n\t\tauto ix=lower_bound(c[I].begin(),c[I].end(),X);\n\t\tauto iy=lower_bound(c[J].begin(),c[J].end(),Y);\n\t\tif(J==0) ix--;\n\t\tif(I==1) iy--;\n\t\tint tx=(0<=*ix&&*ix<h?abs(*ix-x)+abs(*ix-X)+abs(y-Y):inf);\n\t\tint ty=(0<=*iy&&*iy<w?abs(*iy-y)+abs(*iy-Y)+abs(x-X):inf);\n\t\treturn min(tx,ty);\n\t}\n\tauto ix=lower_bound(c[(I+2)%4].begin(),c[(I+2)%4].end(),x);\n\tauto iy=lower_bound(c[(J+2)%4].begin(),c[(J+2)%4].end(),y);\n\tif(J==0) ix--;\n\tif(I==1) iy--;\n\tint tx=(fx&&0<=*ix&&*ix<h?f(*ix,y,X,Y,0,1)+abs(*ix-x):inf);\n\tint ty=(fy&&0<=*iy&&*iy<w?f(x,*iy,X,Y,1,0)+abs(*iy-y):inf);\n\treturn min(tx,ty);\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>h>>w>>q>>s>>t;\n\ta=vi(h,1);\n\tb=vi(w);\n\tfor(int i=0;i<4;i++) c[i].push_back(-1);\n\tfor(int i=0;i<h;i++){\n\t\tif(s[i]=='E') a[i]=3;\n\t\tc[a[i]].push_back(i);\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tif(t[i]=='S') b[i]=2;\n\t\tc[b[i]].push_back(i);\n\t}\n\tfor(int i=0;i<4;i++) c[i].push_back(inf);\n\tfor(int i=0;i<q;i++){\n\t\tint x,y,X,Y;\n\t\tcin>>x>>y>>X>>Y;\n\t\tint res=f(x-1,y-1,X-1,Y-1);\n\t\tcout<<(res>=inf?-1:res)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(),x.end()\n#define all(x) x.begin(),x.end()\n#define fi first\n#define se second\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define erase_duplicates(x) sort(all(x)); (x).resize(distance((x).begin(), unique(all(x))));\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set = tree<\nT,\nnull_type,\nless<T>,\nrb_tree_tag,\ntree_order_statistics_node_update>;\n\n//X.find_by_order(k); - zwraca iterator na k-ty element (numeracja od zerowego)\n//X.order_of_key(k); - zwraca liczbę elementów ostro mniejszych niż k\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<char> VC;\ntypedef long double LD;\ntypedef pair<LD,LD> PLD;\ntypedef vector<LD> VLD;\ntypedef vector<PLD> VPLD;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\" = \"<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<\" = \"<<h<<\", \"; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#define cerr if(0)cout\n#endif\n\nconst int maxn = (1e6)+7;\nconst int maxk = 20;\nconst int inf = (1e9)+7;\nconst LL LLinf = ((LL)1e18)+7LL;\nconst LD eps = 1e-9;\nconst LL mod = 1e9+7;\n\n// ***************************** CODE ***************************** //\n\nset<int> gora, dol, lewo, prawo;\nconst int stala = 6;\n\nint odl(PII a, PII b)\n{\n  int xd = abs(a.fi - b.fi) + abs(a.se - b.se);\n  if(a.fi >= b.fi)\n  {\n    if(gora.count(a.se))\n    {\n    //  cerr<<\"HEJ\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.fi <= b.fi)\n  {\n    if(dol.count(a.se))\n    {\n      // cerr<<\"HEJ2\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.se <= b.se)\n  {\n    if(prawo.count(a.fi))\n    {\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  if(a.se >= b.se)\n  {\n    if(lewo.count(a.fi))\n    {\n      // cerr<<\"HEJ\"<<endl;\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  return inf;\n}\n\nvoid dorzuc(vector<pair<int, PII> > & a, vector<pair<int, PII> > b, int dlu)\n{\n  for(auto s : b)\n    a.pb({s.fi + dlu, s.se});\n}\n\nvector<pair<int, PII> > gen(PII cur, int k = stala)\n{\n//  cerr<<cur.fi<<\" \"<<cur.se<<endl;\n  vector<pair<int, PII> > res;\n  res.pb({0, cur});\n  if(k == 0)\n    return res;\n    if(gora.count(cur.se))\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n    else\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n\n    if(lewo.count(cur.fi))\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n    else\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n  return res;\n\n}\n\nvector<pair<int, PII> > gen2(PII cur, int k = stala)\n{\n\n    vector<pair<int, PII> > res;\n    res.pb({0, cur});\n    if(k == 0)\n      return res;\n\n      if(dol.count(cur.se))\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n      else\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n\n      if(prawo.count(cur.fi))\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.fi);\n          if(SZ(gora) > 0 && it != gora.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.fi);\n          if(SZ(dol) > 0 && it != dol.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n      else\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.se);\n          if(SZ(gora) > 0 && it != gora.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.se);\n          if(SZ(dol) > 0 && it != dol.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n    return res;\n\n}\n\nint main()\n{\n\t_upgrade\n  int n, m, q;\n  cin>>n>>m>>q;\n  string s;\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'E')\n      prawo.insert(i + 1);\n    else\n      lewo.insert(i + 1);\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'N')\n      gora.insert(i + 1);\n    else\n      dol.insert(i + 1);\n//  gen({4, 2});\n  // cerr<<odl({4, 2}, {3, 2})<<endl;\n // return 0;\n  while(q--)\n  {\n    PII start, meta;\n    cin>>start.fi>>start.se;\n    cin>>meta.fi>>meta.se;\n    auto it = gen(start);\n    auto it2 = gen2(meta);\n  /*\n    for(auto s : it)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n    cerr<<endl;\n    for(auto s : it2)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n      cerr<<endl;\n      cerr<<endl;\n      cerr<<endl;\n*/\nerase_duplicates(it);\nerase_duplicates(it2);\n    int res = inf;\n    for(auto s : it)\n      for(auto v : it2)\n      {\n  //      cerr<<s.fi<<\" \"<<v.fi<<\" \"<<odl(s.se, v.se)<<endl;\n        res = min(res, odl(s.se, v.se) + s.fi + v.fi);\n      }\n    if(res == inf)\n      cout<<\"-1\\n\";\n    else\n      cout<<res<<\"\\n\";\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define Abs(_A) (((_A) > 0) ? (_A) : (-(_A)))\n#define cmin(_A, _B) (_A > _B) ? (_A = _B) : 0\n\nstd::set<int> SE, SW, SN, SS;\nstd::set<int>::iterator it;\n\nint ans;\nint tx, ty;\nchar td;\n//td shexian\n\nvoid ck(int nx, int ny, int ns){\n\tcmin(ans, ns + Abs(nx - tx) + Abs(ny - ty));\n}\n\nvoid dfs(int nx, int ny, char nd, int ns){\n\tif(ns > ans) return;\n\t//check cross\n\tif(nx <= tx && ny <= ty && ((nd == 'S' && td == 'W') || (nd == 'E' && td == 'N'))){ck(nx, ny, ns); return;}\n\tif(nx <= tx && ny >= ty && ((nd == 'S' && td == 'E') || (nd == 'W' && td == 'N'))){ck(nx, ny, ns); return;}\n\tif(nx >= tx && ny <= ty && ((nd == 'N' && td == 'W') || (nd == 'E' && td == 'S'))){ck(nx, ny, ns); return;}\n\tif(nx >= tx && ny >= ty && ((nd == 'N' && td == 'E') || (nd == 'W' && td == 'S'))){ck(nx, ny, ns); return;}\n\t//else\n\tif(nd == 'E'){\n\t\tit = SN.lower_bound(nx);\n\t\tif(it != SN.end()) dfs(*it, ny, 'N', ns + Abs(*it - nx));\n\t\tit = SN.lower_bound(tx);\n\t\tif(it != SN.end() && *it >= nx) dfs(*it, ny, 'N', ns + Abs(*it - nx));\n\t\tit = SS.lower_bound(nx);\n\t\tif(it != SS.end()) dfs(*it, ny, 'S', ns + Abs(*it - nx));\n\t\tit = SS.lower_bound(tx);\n\t\tif(it != SS.end() && *it >= nx) dfs(*it, ny, 'S', ns + Abs(*it - nx));\n\t}\n\tif(nd == 'W'){\n\t\tit = SN.upper_bound(nx);\n\t\tif(it != SN.begin()) --it, dfs(*it, ny, 'N', ns + Abs(*it - nx));\n\t\tit = SN.upper_bound(tx);\n\t\tif(it != SN.begin()) {--it; if(*it <= nx) dfs(*it, ny, 'N', ns + Abs(*it - nx));}\n\t\tit = SS.upper_bound(nx);\n\t\tif(it != SS.begin()) --it, dfs(*it, ny, 'S', ns + Abs(*it - nx));\n\t\tit = SS.upper_bound(tx);\n\t\tif(it != SS.begin()) {--it; if(*it <= nx) dfs(*it, ny, 'S', ns + Abs(*it - nx));}\n\t}\n\tif(nd == 'S'){\n\t\tit = SE.lower_bound(ny);\n\t\tif(it != SE.end()) dfs(nx, *it, 'E', ns + Abs(*it - ny));\n\t\tit = SE.lower_bound(ty);\n\t\tif(it != SE.end() && *it >= ny) dfs(nx, *it, 'E', ns + Abs(*it - ny));\n\t\tit = SW.lower_bound(ny);\n\t\tif(it != SW.end()) dfs(nx, *it, 'W', ns + Abs(*it - ny));\n\t\tit = SW.lower_bound(ty);\n\t\tif(it != SW.end() && *it >= ny) dfs(nx, *it, 'W', ns + Abs(*it - ny));\n\t}\n\tif(nd == 'N'){\n\t\tit = SE.upper_bound(ny);\n\t\tif(it != SE.begin()) --it, dfs(nx, *it, 'E', ns + Abs(*it - ny));\n\t\tit = SE.upper_bound(ty);\n\t\tif(it != SE.begin()) {--it; if(*it <= ny) dfs(nx, *it, 'E', ns + Abs(*it - ny));}\n\t\tit = SW.upper_bound(ny);\n\t\tif(it != SW.begin()) --it, dfs(nx, *it, 'W', ns + Abs(*it - ny));\n\t\tit = SW.upper_bound(ty);\n\t\tif(it != SW.begin()) {--it; if(*it <= ny) dfs(nx, *it, 'W', ns + Abs(*it - ny));}\n\t}\n}\n\nint n, m, Q;\nchar s[111111];\nchar t[111111];\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &m, &Q);\n\tscanf(\"%s\", s + 1);\n\tfor(int i = 1; i <= n; i++){\n\t\tif(s[i] == 'W') SW.insert(i);\n\t\telse SE.insert(i);\n\t}\n\tscanf(\"%s\", t + 1);\n\tfor(int i = 1; i <= m; i++){\n\t\tif(t[i] == 'N') SN.insert(i);\n\t\telse SS.insert(i);\n\t}\n\tfor(int i = 1, a, b, c, d; i <= Q; i++){\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tans = 9999999;\n\t\tint kans = 89999999;\n\t\ttx = c, ty = d;\n\t\tif(s[tx] == 'W') td = 'E';\n\t\telse td = 'W';\n\t\tdfs(a, b, s[a], 0);\n\t\tcmin(kans, ans);\n\t\tans = 9999999;\n\t\tdfs(a, b, t[b], 0);\n\t\tans = 9999999;\n\t\t\n\t\tif(t[ty] == 'N') td = 'W';\n\t\telse td = 'N';\n\t\tdfs(a, b, s[a], 0);\n\t\tcmin(kans, ans);\n\t\tans = 9999999;\n\t\tdfs(a, b, t[b], 0);\n\t\tcmin(kans, ans);\n\t\tprintf(\"%d\\n\", kans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }  \n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n    int ans=INF;\n    \n    MFP([&](auto dfs,int y,int x,int sum,int step)->void{                 \n          if(y==c&&x==d) chmin(ans,sum);\n          if(sum+abs(y-c)+abs(x-d)>=ans) return;          \n          if(y==c){\n            if(s[y]=='E'&&x<=d) chmin(ans,sum+abs(y-c)+abs(x-d));\n            if(s[y]=='W'&&x>=d) chmin(ans,sum+abs(y-c)+abs(x-d));\n          }\n          if(x==d){\n            if(t[x]=='S'&&y<=c) chmin(ans,sum+abs(y-c)+abs(x-d));\n            if(t[x]=='N'&&y>=c) chmin(ans,sum+abs(y-c)+abs(x-d));\n          }          \n          if(step>=4) return;             \n          if(s[y]=='W'){\n            // N           \n            for(int xx:{x,d}){\n              auto it=--upper_bound(vn.begin(),vn.end(),xx);\n              if(*it<=x) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n            // S\n            for(int xx:{x,d}){\n              auto it=--upper_bound(vs.begin(),vs.end(),xx);\n              if(*it<=x) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n          }else{\n            // N           \n            for(int xx:{x,d}){\n              auto it=lower_bound(vn.begin(),vn.end(),xx);\n              if(x<=*it) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n            // S\n            for(int xx:{x,d}){\n              auto it=lower_bound(vs.begin(),vs.end(),xx);\n              if(x<=*it) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n          }\n          if(t[x]=='N'){            \n            // W         \n            for(int yy:{y,c}){\n              auto it=--upper_bound(vw.begin(),vw.end(),yy);\n              if(*it<=y) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n            // E\n            for(int yy:{y,c}){\n              auto it=--upper_bound(ve.begin(),ve.end(),yy);\n              if(*it<=y) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n          }else{\n            // W         \n            for(int yy:{y,c}){\n              auto it=lower_bound(vw.begin(),vw.end(),yy);\n              if(y<=*it) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n            // E\n            for(int yy:{y,c}){\n              auto it=lower_bound(ve.begin(),ve.end(),yy);\n              if(y<=*it) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n          }\n        })(a,b,0,0);\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nvoid bb(vector<int> &v)\n{\n\tsort(v.begin(),v.end());\n\tv.resize(unique(v.begin(),v.end())-v.begin());\n}\nint lb(int x,vector<int> &v) {if(v.size()==0 or v[0]>x) return x;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v.size()==0 or v[v.size()-1]<x) return x;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\nint trcyx(pii a,pii b) {return abs(a.first-b.first)+abs(a.second-b.second);}\n\nint tot;\nvector<int> v[nn],c[nn];\nvoid clear()\n{\n\tfor(int i=0;i<=tot;i++) v[i].clear(),c[i].clear();\n\ttot=0;\n}\nvoid link(int x,int y,int w)\n{\n\tv[x].push_back(y);c[x].push_back(w);\n}\n\n\nint dist[nn];\nint dj(int x,int y)\n{\n\tfor(int i=1;i<=tot;++i) dist[i]=1e9;\n\tdist[x]=0;priority_queue<pii> pq;pq.push(mp(-dist[x],x));\n\twhile(pq.size()) \n\t{\n\t\tint z=pq.top().second;//if(pq.top().first!=-dist[x]) {pq.pop();continue;}\n\t\tpq.pop();\n\t\tfor(int i=0;i<v[z].size();i++)\n\t\t{\n\t\t\tint w=v[z][i];\n\t\t\tif(dist[w]>dist[z]+c[z][i])\n\t\t\t{\n\t\t\t\tdist[w]=dist[z]+c[z][i];\n\t\t\t\tpq.push(mp(-dist[w],w));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[y];\n}\nvoid solve()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tclear();\n\t\tvector<int> allx,ally;int x,y;\n\t\t\n\t\tx=from[i].first,y=from[i].second;\n\t\tfor(int j=0;j<2;j++) allx.push_back(lb(x,path[0][j])),allx.push_back(ub(x,path[0][j]));\n\t\tfor(int j=0;j<2;j++) ally.push_back(lb(y,path[1][j])),ally.push_back(ub(y,path[1][j]));\n\t\t\n\t\t\n\t\tx=dest[i].first,y=dest[i].second;\n\t\tfor(int j=0;j<2;j++) allx.push_back(lb(x,path[0][j])),allx.push_back(ub(x,path[0][j]));\n\t\tfor(int j=0;j<2;j++) ally.push_back(lb(y,path[1][j])),ally.push_back(ub(y,path[1][j]));\n\t\t\n\t\t\n\t\tsort(allx.begin(),allx.end());allx.resize(unique(allx.begin(),allx.end())-allx.begin());\n\t\tsort(ally.begin(),ally.end());ally.resize(unique(ally.begin(),ally.end())-ally.begin());\n\t\t\n\t\t\n\t\tmap<pii,int> id;\n\t\tfor(int i=0;i<allx.size();i++)\n\t\t\tfor(int j=0;j<ally.size();j++)\n\t\t\t\tid[mp(allx[i],ally[j])]=++tot;\n\t\t\n\t\tfor(int i=0;i<allx.size();i++)\n\t\t\tfor(int j=1;j<ally.size();j++)\n\t\t\t{\n\t\t\t\tpii a=mp(allx[i],ally[j-1]),b=mp(allx[i],ally[j]);\n\t\t\t\tif(!dir[0][allx[i]]) swap(a,b);\n\t\t\t\tlink(id[a],id[b],trcyx(a,b));\n\t\t\t}\n\t\t\t\n\t\tfor(int j=0;j<ally.size();j++)\n\t\t\tfor(int i=1;i<allx.size();i++)\n\t\t\t{\n\t\t\t\tpii a=mp(allx[i-1],ally[j]),b=mp(allx[i],ally[j]);\n\t\t\t\tif(!dir[1][ally[j]]) swap(a,b);\n\t\t\t\tlink(id[a],id[b],trcyx(a,b));\n\t\t\t}\n\t\t\n\t\tans[i]=dj(id[from[i]],id[dest[i]]);\n\t}\n\t\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\tsolve();\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <cstdlib>\n#define llint long long\n#define inf 100000000000000000\n\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[200005], prer[200005], nextl[200005], nextr[200005];\nllint preu[200005], pred[200005], nextu[200005], nextd[200005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > PQ;\n\tPQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(PQ.size()){\n\t\td = PQ.top().first;\n\t\tv = PQ.top().second;\n\t\tPQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tPQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\"; t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i+1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i+1] == 'S') nextd[i] = i+1;\n\t}\n\t\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(s[a] == 'W'){\n\t\t//左\n\t\tint x = POSL(up,min(d,b));\n\t\tint xx = POSL(up,b);\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSL(up,b) > 0){\n\t\t    x = POSL(up,b); x--;\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSL(dw,min(d,b));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSL(dw,b) > 0){\n\t\t    y = POSL(dw,b); y--;\n\t\t    on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(up,max(d,b));\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSU(up,b) != up.size()){\n\t\t    x = POSU(up,b);\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSU(dw,max(d,b));\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSU(dw,b) != dw.size()){\n\t\t    y = POSU(dw,b);\n\t\t   on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(t[b] == 'N'){\n\t\t//上\n\t\tint x = POSL(le,min(a,c));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSL(le,a)){\n\t\t    x = POSL(le,a)-1;\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSL(ri,min(a,c));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSL(ri,a)){\n\t\t    y = POSL(ri,a)-1;\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(le,max(a,c));\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSU(le,a) != le.size()){\n\t\t    x = POSU(le,a);\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSU(ri,max(a,c));\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSU(ri,a) != ri.size()){\n\t\t    y = POSU(ri,a);\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,4,0);\n\t\ton_y(a,b,c,d,4,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld; \ntypedef double db; \ntypedef string str; \n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<ld,ld> pd; \n#define mp make_pair\n#define f first\n#define s second\n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<ld> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi; \ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back() \n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353; // = (119<<23)+1\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = 4*atan((ld)1); \nconst int xd[4] = {0,1,0,-1}, yd[4] = {1,0,-1,0}; \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; }\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, \n\trb_tree_tag, tree_order_statistics_node_update>; \n// change null_type for map\n#define ook order_of_key\n#define fbo find_by_order\n\nvoid treeExample() {\n\tTree<int> t, t2; t.insert(8);\n\tauto it = t.insert(10).f; assert(it == t.lb(9));\n\tassert(t.ook(10) == 1); assert(t.ook(11) == 2);\n\tassert(*t.fbo(0) == 8);\n\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t\n}\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) { \n\t\tre(t); re(ts...); \n\t}\n\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n\t}\n\t\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n\t}\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T;\n\tT val; \n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(ll v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.val < b.val; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend ostream& operator<<(ostream& os, const mi& a) { \n\t\treturn os << a.val; }\n   \n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) { \n\t\tif ((val += m.val) >= MOD) val -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((val -= m.val) < 0) val += MOD; \n\t\treturn *this; }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\n\tmi& operator*=(const mi& m) { \n\t\tval = (ll)val*m.val%MOD; return *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { \n\t\tassert(!(a == 0)); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,M,Q;\nstr S,T;\nvi wNorth, wSouth, eNorth, eSouth;\nvi nWest, nEast, sWest, sEast;\n\nint hor(pi a, pi b, int c);\nint ver(pi a, pi b, int c);\n\nint checkH(int x, pi a, pi b, int c) {\n\tif (abs(x) == MOD) return MOD;\n\tif (S[a.f] == 'W') {\n\t\tif (!(x <= a.s)) return MOD;\n\t} else {\n\t\tif (!(x >= a.s)) return MOD;\n\t}\n\treturn ver({a.f,x},b,c+1)+abs(x-a.s);\n}\n\nint hor(pi a, pi b, int c) {\n\tint res = MOD;\n\tif (S[a.f] == 'W') {\n\t\tif (a.f == b.f && b.s <= a.s) return a.s-b.s;\n\t\tif (c == 4) return res;\n\t\tif (b.s <= a.s) {\n\t\t\tif (b.f > a.f) {\n\t\t\t\tckmin(res,checkH(wSouth[b.s],a,b,c));\n\t\t\t\tckmin(res,checkH(eSouth[b.s],a,b,c));\n\t\t\t\tckmin(res,checkH(wNorth[a.s],a,b,c));\n\t\t\t} else {\n\t\t\t\tckmin(res,checkH(wNorth[b.s],a,b,c));\n\t\t\t\tckmin(res,checkH(eNorth[b.s],a,b,c));\n\t\t\t\tckmin(res,checkH(wSouth[a.s],a,b,c));\n\t\t\t}\n\t\t} else {\n\t\t\tckmin(res,checkH(wNorth[a.s],a,b,c));\n\t\t\tckmin(res,checkH(wSouth[a.s],a,b,c));\n\t\t}\n\t} else {\n\t\tif (a.f == b.f && a.s <= b.s) return b.s-a.s;\n\t\tif (c == 4) return res;\n\t\tint x = eSouth[a.s], y = eNorth[a.s];\n\t\tif (b.s >= a.s) {\n\t\t\tif (b.f > a.f) {\n\t\t\t\tckmin(res,checkH(wSouth[b.s],a,b,c));\n\t\t\t\tckmin(res,checkH(eSouth[b.s],a,b,c));\n\t\t\t\tckmin(res,checkH(eNorth[a.s],a,b,c));\n\t\t\t} else {\n\t\t\t\tckmin(res,checkH(wNorth[b.s],a,b,c));\n\t\t\t\tckmin(res,checkH(eNorth[b.s],a,b,c));\n\t\t\t\tckmin(res,checkH(eSouth[a.s],a,b,c));\n\t\t\t}\n\t\t} else {\n\t\t\tckmin(res,checkH(eNorth[a.s],a,b,c));\n\t\t\tckmin(res,checkH(eSouth[a.s],a,b,c));\n\t\t}\n\t}\n\treturn res;\n}\n\nint checkV(int y, pi a, pi b, int c) {\n\tif (abs(y) == MOD) return MOD;\n\tif (T[a.s] == 'N') {\n\t\tif (!(y <= a.f)) return MOD;\n\t} else {\n\t\tif (!(y >= a.f)) return MOD;\n\t}\n\treturn hor({y,a.s},b,c+1)+abs(y-a.f);\n}\n\nint ver(pi a, pi b, int c) {\n\tint res = MOD;\n\tif (T[a.s] == 'N') {\n\t\tif (a.s == b.s && b.f <= a.f) return a.f-b.f;\n\t\tif (c == 4) return res;\n\t\tif (b.f <= a.f) {\n\t\t\tif (b.s > a.s) {\n\t\t\t\tckmin(res,checkV(nEast[b.f],a,b,c));\n\t\t\t\tckmin(res,checkV(sEast[b.f],a,b,c));\n\t\t\t\tckmin(res,checkV(nWest[a.f],a,b,c));\n\t\t\t} else {\n\t\t\t\tckmin(res,checkV(nWest[b.f],a,b,c));\n\t\t\t\tckmin(res,checkV(sWest[b.f],a,b,c));\n\t\t\t\tckmin(res,checkV(nEast[a.f],a,b,c));\n\t\t\t}\n\t\t} else {\n\t\t\tckmin(res,checkV(nWest[a.f],a,b,c));\n\t\t\tckmin(res,checkV(nEast[a.f],a,b,c));\n\t\t}\n\t} else {\n\t\tif (a.s == b.s && b.f >= a.f) return b.f-a.f;\n\t\tif (c == 4) return res;\n\t\tif (b.f >= a.f) {\n\t\t\tif (b.s > a.s) {\n\t\t\t\tckmin(res,checkV(nEast[b.f],a,b,c));\n\t\t\t\tckmin(res,checkV(sEast[b.f],a,b,c));\n\t\t\t\tckmin(res,checkV(sWest[a.f],a,b,c));\n\t\t\t} else {\n\t\t\t\tckmin(res,checkV(nWest[b.f],a,b,c));\n\t\t\t\tckmin(res,checkV(sWest[b.f],a,b,c));\n\t\t\t\tckmin(res,checkV(sEast[a.f],a,b,c));\n\t\t\t}\n\t\t} else {\n\t\t\tckmin(res,checkV(sWest[a.f],a,b,c));\n\t\t\tckmin(res,checkV(sEast[a.f],a,b,c));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tre(N,M,Q,S,T);\n\twNorth.rsz(M), wSouth.rsz(M);\n\tF0R(i,M) {\n\t\tif (i == 0) wNorth[i] = wSouth[i] = -MOD;\n\t\telse wNorth[i] = wNorth[i-1], wSouth[i] = wSouth[i-1];\n\t\tif (T[i] == 'S') wSouth[i] = i;\n\t\telse wNorth[i] = i;\n\t}\n\teNorth.rsz(M), eSouth.rsz(M);\n\tR0F(i,M) {\n\t\tif (i == M-1) eNorth[i] = eSouth[i] = -MOD;\n\t\telse eNorth[i] = eNorth[i+1], eSouth[i] = eSouth[i+1];\n\t\tif (T[i] == 'S') eSouth[i] = i;\n\t\telse eNorth[i] = i;\n\t}\n\tnWest.rsz(N), nEast.rsz(N);\n\tF0R(i,N) {\n\t\tif (i == 0) nWest[i] = nEast[i] = -MOD;\n\t\telse nWest[i] = nWest[i-1], nEast[i] = nEast[i-1];\n\t\tif (S[i] == 'E') nEast[i] = i;\n\t\telse nWest[i] = i;\n\t}\n\tsWest.rsz(N), sEast.rsz(N);\n\tR0F(i,N) {\n\t\tif (i == N-1) sWest[i] = sEast[i] = -MOD;\n\t\telse sWest[i] = sWest[i+1], sEast[i] = sEast[i+1];\n\t\tif (S[i] == 'E') sEast[i] = i;\n\t\telse sWest[i] = i;\n\t}\n\tF0R(i,Q) {\n\t\tint a,b,c,d; re(a,b,c,d); a--,b--,c--,d--;\n\t\tint res = min(hor({a,b},{c,d},0),ver({a,b},{c,d},0));\n\t\tps(res == MOD ? -1 : res);\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), slow multiset operations\n\t* do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }  \n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n    int ans=INF;\n\n    using P = pair<int, int>;\n    map<P, int> dp;\n    MFP([&](auto dfs,int y,int x,int sum,int step)->void{      \n          if(y==c&&x==d) chmin(ans,sum);\n          if(sum+abs(y-c)+abs(x-d)>=ans) return;          \n          if(y==c){\n            if(s[y]=='E'&&x<=d) chmin(ans,sum+abs(y-c)+abs(x-d));\n            if(s[y]=='W'&&x>=d) chmin(ans,sum+abs(y-c)+abs(x-d));\n          }\n          if(x==d){\n            if(t[x]=='S'&&y<=c) chmin(ans,sum+abs(y-c)+abs(x-d));\n            if(t[x]=='N'&&y>=c) chmin(ans,sum+abs(y-c)+abs(x-d));\n          }          \n          if(step>=4) return;\n          if(dp.count(P(y,x))&&dp[P(y,x)]<=sum) return;\n          dp[P(y,x)]=sum;          \n          if(s[y]=='W'){\n            // N           \n            for(int xx:{x,d}){\n              auto it=--upper_bound(vn.begin(),vn.end(),xx);\n              if(*it<=x) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n            // S\n            for(int xx:{x,d}){\n              auto it=--upper_bound(vs.begin(),vs.end(),xx);\n              if(*it<=x) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n          }else{\n            // N           \n            for(int xx:{x,d}){\n              auto it=lower_bound(vn.begin(),vn.end(),xx);\n              if(x<=*it) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n            // S\n            for(int xx:{x,d}){\n              auto it=lower_bound(vs.begin(),vs.end(),xx);\n              if(x<=*it) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n          }\n          if(t[x]=='N'){            \n            // W         \n            for(int yy:{y,c}){\n              auto it=--upper_bound(vw.begin(),vw.end(),yy);\n              if(*it<=y) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n            // E\n            for(int yy:{y,c}){\n              auto it=--upper_bound(ve.begin(),ve.end(),yy);\n              if(*it<=y) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n          }else{\n            // W         \n            for(int yy:{y,c}){\n              auto it=lower_bound(vw.begin(),vw.end(),yy);\n              if(y<=*it) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n            // E\n            for(int yy:{y,c}){\n              auto it=lower_bound(ve.begin(),ve.end(),yy);\n              if(y<=*it) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n          }\n        })(a,b,0,0);\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <cstdlib>\n#define llint long long\n#define inf 100000000000000000\n\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[200005], prer[200005], nextl[200005], nextr[200005];\nllint preu[200005], pred[200005], nextu[200005], nextd[200005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > PQ;\n\tPQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(PQ.size()){\n\t\td = PQ.top().first;\n\t\tv = PQ.top().second;\n\t\tPQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tPQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\"; t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i+1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextu[W+1] = W+1, nextd[W+1] = W+1;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i+1] == 'S') nextd[i] = i+1;\n\t}\n\t\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nint U[100005][2],D[100005][2],L[100005][2],R[100005][2];\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(s[a] == 'W'){\n\t    \tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//左\n\t\tint x = U[min(d,b)][0];\n\t\tint xx = U[b][0];\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(U[b][0] > 0){\n\t\t    x = U[b][0]; x--;\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = D[min(d,b)][0];\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(D[b][0] > 0){\n\t\t    y = D[b][0]; y--;\n\t\t    on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\n\t}\n\telse{\n\t    if(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = U[max(d,b)][1];\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(U[b][1] != up.size()){\n\t\t    x = U[b][1];\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = D[max(d,b)][1];\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(D[b][1] != dw.size()){\n\t\t    y = D[b][1];\n\t\t   on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(t[b] == 'N'){\n\t    if(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//上\n\t\tint x = L[min(a,c)][0];\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(L[a][0]){\n\t\t    x = L[a][0]-1;\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = R[min(a,c)][0];\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(R[a][0]){\n\t\t    y = R[a][0]-1;\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\telse{\n\t    if(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = L[max(a,c)][1];\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(L[a][1] != le.size()){\n\t\t    x = L[a][1];\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = R[max(a,c)][1];\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(R[a][1] != ri.size()){\n\t\t    y = R[a][1];\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<100005;i++){\n\t    L[i][0] = POSL(le,i);\n\t    R[i][0] = POSL(ri,i);\n\t    U[i][0] = POSL(up,i);\n\t    D[i][0] = POSL(dw,i);\n\t     L[i][1] = POSU(le,i);\n\t    R[i][1] = POSU(ri,i);\n\t    U[i][1] = POSU(up,i);\n\t    D[i][1] = POSU(dw,i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,4,0);\n\t\ton_y(a,b,c,d,4,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define inf 0x3f3f3f3f\nusing namespace std;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\nint N, M, Q, S, T, tope = 0; char s[100005], t[100005];\nint UW[100005], UE[100005], DW[100005], DE[100005];\nint LN[100005], LS[100005], RN[100005], RS[100005];\nint R[10], C[10], topR, topC, id[10][10], cnt;\nint dis[40], q[40], fr, re, inq[40];\nstruct Edge {int np, val; Edge *nxt;} E[65], *V[40];\n#define tasu1(x) (x = x < 40 ? x + 1 : 0)\n\ninline void addedge(const int &u, const int &v, const int &w){\n\tE[++tope].np = v, E[tope].val = w;\n\tE[tope].nxt = V[u], V[u] = E + tope;\n\t\n//\tprintf(\"%d -> %d : %d\\n\", u, v, w);\n}\n\ninline int SPFA(){\n\tmemset(dis, 0x3f, sizeof(int) * (cnt + 1));\n\tmemset(inq, 0, sizeof(int) * (cnt + 1));\n\tdis[S] = 0, inq[q[0] = S] = 1, fr = 0, re = 1;\n\twhile(fr != re){\n\t\tconst int u = q[fr]; tasu1(fr), inq[u] = 0;\n\t\tfor(register Edge *ne = V[u]; ne; ne = ne->nxt)\n\t\t\tif(dis[u] + ne->val < dis[ne->np]){\n\t\t\t\tdis[ne->np] = dis[u] + ne->val;\n\t\t\t\tif(!inq[ne->np]) q[re] = ne->np, tasu1(re), inq[ne->np] = 1;\n\t\t\t}\n\t}\n\treturn dis[T] < inf ? dis[T] : -1;\n}\n\nint main(){\n\tgetint(N), getint(M), getint(Q), scanf(\"%s%s\", s + 1, t + 1);\n\tUW[0] = UE[0] = DW[N + 1] = DE[N + 1] = N + 1;\n\tLN[0] = LS[0] = RN[M + 1] = RS[M + 1] = M + 1;\n\tfor(register int i = 1; i <= N; i++){\n\t\tUW[i] = s[i] == 'W' ? i : UW[i - 1];\n\t\tUE[i] = s[i] == 'E' ? i : UE[i - 1];\n\t}\n\tfor(register int i = N; i >= 1; i--){\n\t\tDW[i] = s[i] == 'W' ? i : DW[i + 1];\n\t\tDE[i] = s[i] == 'E' ? i : DE[i + 1];\n\t}\n\tfor(register int i = 1; i <= M; i++){\n\t\tLN[i] = t[i] == 'N' ? i : LN[i - 1];\n\t\tLS[i] = t[i] == 'S' ? i : LS[i - 1];\n\t}\n\tfor(register int i = M; i >= 1; i--){\n\t\tRN[i] = t[i] == 'N' ? i : RN[i + 1];\n\t\tRS[i] = t[i] == 'S' ? i : RS[i + 1];\n\t}\n\twhile(Q--){\n\t\tint a, b, c, d; getint(a), getint(b), getint(c), getint(d);\n\t\tR[1] = UW[a], R[2] = DW[a], R[3] = UW[c], R[4] = DW[c];\n\t\tR[5] = UE[a], R[6] = DE[a], R[7] = UE[c], R[8] = DE[c];\n\t\tC[1] = LN[b], C[2] = RN[b], C[3] = LN[d], C[4] = RN[d];\n\t\tC[5] = LS[b], C[6] = RS[b], C[7] = LS[d], C[8] = RS[d];\n\t\tsort(R + 1, R + 9), topR = unique(R + 1, R + 9) - R - 1;\n\t\tsort(C + 1, C + 9), topC = unique(C + 1, C + 9) - C - 1, cnt = 0;\n\t\tif(R[topR] > N) topR--; if(C[topC] > M) topC--;\n\t\tfor(register int i = 1; i <= topR; i++)\n\t\t\tfor(register int j = 1; j <= topC; j++){\n\t\t\t\tid[i][j] = ++cnt;\n\t\t\t\tif(R[i] == a && C[j] == b) S = cnt;\n\t\t\t\tif(R[i] == c && C[j] == d) T = cnt;\n\t\t\t}\n\t\t\n//\t\tputs(\"\\n======= Intersect Debug hajimaru ======\");\n//\t\tfor(register int i = 1; i <= topR; i++) printf(\"(%d, %c) \", R[i], s[R[i]]); puts(\"\");\n//\t\tfor(register int i = 1; i <= topC; i++) printf(\"(%d, %c) \", C[i], t[C[i]]); puts(\"\");\n//\t\tputs(\"========= Intersect Debug owaru =======\\n\");\n//\t\t\n//\t\tputs(\"\\n========== ID Debug hajimaru ==========\");\n//\t\tfor(register int i = 1; i <= topR; i++, puts(\"\"))\n//\t\t\tfor(register int j = 1; j <= topC; j++)\n//\t\t\t\tprintf(\"[%d](%d, %d) \", id[i][j], R[i], C[j]);\n//\t\tputs(\"=========== ID Debug owaru ===========\\n\");\n//\t\t\n//\t\t\n//\t\tputs(\"\\n========== Edge Debug hajimaru =========\");\n\t\t\n\t\tmemset(V, 0, sizeof(Edge*) * (cnt + 1)), tope = 0;\n\t\tfor(register int i = 1; i <= topR; i++)\n\t\t\tfor(register int j = 1; j < topC; j++)\n\t\t\t\tif(s[R[i]] == 'W') addedge(id[i][j + 1], id[i][j], C[j + 1] - C[j]);\n\t\t\t\telse addedge(id[i][j], id[i][j + 1], C[j + 1] - C[j]);\n\t\tfor(register int j = 1; j <= topC; j++)\n\t\t\tfor(register int i = 1; i < topR; i++)\n\t\t\t\tif(t[C[j]] == 'N') addedge(id[i + 1][j], id[i][j], R[i + 1] - R[i]);\n\t\t\t\telse addedge(id[i][j], id[i + 1][j], R[i + 1] - R[i]);\n\t\t\n//\t\tputs(\"============ Edge Debug owaru ==========\\n\");\n\t\t\n\t\tprintf(\"%d\\n\", SPFA());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define ll long long\n#define inf 0x3f3f3f3f\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\nint read(){\n    R int res,f=1;R char ch;\n    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);\n    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');\n    return res*f;\n}\nint read(char *s){\n\tR int len=0;R char ch;while(((ch=getc())>'Z'||ch<'A'));\n\tfor(s[++len]=ch;(ch=getc())>='A'&&ch<='Z';s[++len]=ch);\n\treturn s[len+1]='\\0',len;\n}\nchar sr[1<<21],z[20];int C=-1,Z=0;\ninline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(R int x){\n    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\nvector<int>N,S,W,E;\nint Pre(vector<int> &A,int x){\n\tif(A.empty())return 1;\n\tint l=0,r=A.size()-1,res=0;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tA[mid]<=x?(res=mid,l=mid+1):r=mid-1;\n\t}\n\treturn A[res];\n}\nint suf(vector<int> &A,int x){\n\tif(A.empty())return 1;\n\tint l=0,r=A.size()-1,res=r;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tA[mid]>=x?(res=mid,r=mid-1):l=mid+1;\n\t}\n\treturn A[res];\n}\nstruct eg{int v,nx,w;}e[1005];int head[105],tot;\ninline void add(R int u,R int v,R int w){e[++tot]={v,head[u],w},head[u]=tot;}\nchar s[100005],t[100005];int n,m,Q,cnt,id[25][25],dis[205],vis[205];\nstruct node{\n\tint u,d;\n\tnode(){}\n\tnode(R int uu,R int dd):u(uu),d(dd){}\n\tinline bool operator <(const node &b)const{return d>b.d;}\n};priority_queue<node>q;\nint spfa(int S,int T){\n\tfp(i,1,cnt)dis[i]=inf,vis[i]=0;\n\tq.push(node(S,0)),dis[S]=0;\n\twhile(!q.empty()){\n\t\tint u=q.top().u;q.pop();if(vis[u])continue;vis[u]=1;\n\t\tgo(u)if(cmin(dis[v],dis[u]+e[i].w))q.push(node(v,dis[v]));\n\t}\n\treturn dis[T]<inf?dis[T]:-1;\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tn=read(),m=read(),Q=read(),read(s),read(t);\n\tfp(i,1,n)s[i]=='E'?E.push_back(i):W.push_back(i);\n\tfp(i,1,m)t[i]=='S'?S.push_back(i):N.push_back(i);\n\twhile(Q--){\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tvector<int>X,Y;\n\t\tX.push_back(Pre(E,a)),X.push_back(Pre(W,a)),\n\t\tX.push_back(suf(E,a)),X.push_back(suf(W,a)),\n\t\tX.push_back(Pre(E,c)),X.push_back(Pre(W,c)),\n\t\tX.push_back(suf(E,c)),X.push_back(suf(W,c)),\n\t\tY.push_back(Pre(S,b)),Y.push_back(Pre(N,b)),\n\t\tY.push_back(suf(S,b)),Y.push_back(suf(N,b)),\n\t\tY.push_back(Pre(S,d)),Y.push_back(Pre(N,d)),\n\t\tY.push_back(suf(S,d)),Y.push_back(suf(N,d));\n\t\tsort(X.begin(),X.end()),X.resize(unique(X.begin(),X.end())-X.begin());\n\t\tsort(Y.begin(),Y.end()),Y.resize(unique(Y.begin(),Y.end())-Y.begin());\n\t\tint lx=X.size(),ly=Y.size(),S,T;cnt=0;\n\t\tfp(i,0,lx-1)fp(j,0,ly-1){\n\t\t\tid[i][j]=++cnt;\n\t\t\tif(X[i]==a&&Y[j]==b)S=cnt;\n\t\t\tif(X[i]==c&&Y[j]==d)T=cnt;\n\t\t}\n\t\tfp(i,1,cnt)head[i]=0;tot=0;\n\t\tfp(i,0,lx-1)\n\t\t\tif(s[X[i]]=='E')fp(j,0,ly-2)add(id[i][j],id[i][j+1],Y[j+1]-Y[j]);\n\t\t\telse fp(j,1,ly-1)add(id[i][j],id[i][j-1],Y[j]-Y[j-1]);\n\t\tfp(j,0,ly-1)\n\t\t\tif(t[Y[j]]=='S')fp(i,0,lx-2)add(id[i][j],id[i+1][j],X[i+1]-X[i]);\n\t\t\telse fp(i,1,lx-1)add(id[i][j],id[i-1][j],X[i]-X[i-1]);\n\t\tprint(spfa(S,T));\n\t}\n\treturn Ot(),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <queue>\n#include <array>\n#include <cassert>\n#include <tuple>\n\nstruct node {\n\tint x;\n\tint y;\n};\n\nconstexpr bool operator==(const node& lhs, const node& rhs) {\n\treturn lhs.x == rhs.x && lhs.y == rhs.y;\n}\n\nconstexpr std::size_t no_answer = std::numeric_limits<std::size_t>::max();\n\nstruct nodes_with_cost {\n\tstd::vector<node> nodes;\n\tstd::size_t cost = no_answer;\n\n\tnodes_with_cost& operator=(nodes_with_cost&& other) noexcept {\n\t\tnodes = std::move(other.nodes);\n\t\tcost = other.cost;\n\t\tother.cost = no_answer;\n\t\treturn *this;\n\t}\n};\n\nusing queue_type = std::array<nodes_with_cost, 2>;\nbool empty(queue_type& q) {\n\treturn q[0].cost == no_answer;\n}\nnode peek(queue_type& q) {\n\tnode ret = q[0].nodes.back();\n\treturn ret;\n}\nvoid pop(queue_type& q) {\n\tq[0].nodes.pop_back();\n\n\tif (q[0].nodes.empty()) {\n\t\tq[0] = std::move(q[1]);\n\t}\n}\nconstexpr std::size_t flat_index(std::size_t x, std::size_t y, std::size_t width) {\n\treturn x * width + y;\n}\n\nstruct solver {\n\tint width, height, queries;\n\tstd::string horizontal;\n\tstd::string vertical;\n\n\tvoid init() {\n\t\tstd::cin >> height >> width >> queries;\n\n\t\thorizontal.reserve(height);\n\t\tvertical.reserve(width);\n\n\t\tstd::cin >> horizontal\n\t\t\t\t >> vertical;\n\t}\n\n\tvoid push(queue_type& q, std::size_t cost, node n) const {\n\t\tbool valid = 0 <= n.x && n.x < width\n\t\t\t\t\t && 0 <= n.y && n.y < height;\n\t\tif (!valid) {\n\t\t\treturn;\n\t\t}\n\t\tif (q[0].cost == no_answer) {\n\t\t\tq[0] = {{n}, cost};\n\t\t} else if (q[0].cost == cost) {\n\t\t\tq[0].nodes.emplace_back(n);\n\t\t} else if (q[1].cost == no_answer) {\n\t\t\tq[1] = {{n}, cost};\n\t\t} else {\n\t\t\tassert(q[1].cost == cost);\n\t\t\tq[1].nodes.emplace_back(n);\n\t\t}\n\t}\n\n\tvoid solve_loop() {\n\t\tfor (int i = 0; i < queries; ++i) {\n\t\t\tstd::size_t cost = solve();\n\t\t\tif (cost == no_answer) {\n\t\t\t\tstd::cout << \"-1\\n\";\n\t\t\t} else {\n\t\t\t\tstd::cout << cost << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n\tstd::size_t solve() const {\n\t\tstd::vector<bool> closed(width * height, false);\n\t\tqueue_type queue;\n\n\t\tint x1, y1, x2, y2;\n\t\tstd::cin >> y1 >> x1 >> y2 >> x2;\n\n\t\tpush(queue, 0, {x1 - 1, y1 - 1});\n\t\tnode end{x2 - 1, y2 - 1};\n\n\t\twhile (!empty(queue)) {\n\t\t\tnode n = peek(queue);\n\t\t\tsize_t cost = queue[0].cost;\n\t\t\tpop(queue);\n\n\t\t\tif (n == end) {\n\t\t\t\treturn cost;\n\t\t\t}\n\t\t\tsize_t flatten_index = flat_index(n.x, n.y, width);\n\t\t\tif (closed[flatten_index]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclosed[flatten_index] = true;\n\t\t\tif (horizontal[n.y] == 'E') {\n\t\t\t\tpush(queue, cost + 1, {n.x + 1, n.y});\n\t\t\t} else {\n\t\t\t\tpush(queue, cost + 1, {n.x - 1, n.y});\n\t\t\t}\n\t\t\tif (vertical[n.x] == 'N') {\n\t\t\t\tpush(queue, cost + 1, {n.x, n.y - 1});\n\t\t\t} else {\n\t\t\t\tpush(queue, cost + 1, {n.x, n.y + 1});\n\t\t\t}\n\t\t}\n\t\treturn no_answer;\n\t}\n};\n\nint main() {\n\tsolver s;\n\ts.init();\n\ts.solve_loop();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nstd::vector<bool> data[2];\nstd::vector<int> next[2][2], prev[2][2];\n\nstruct Info {\n\tint lower;\n\tint upper;\n\tint con;\n};\n\n#define INF 1000000000\n\nint res;\nint n[2];\nint goal[2];\nint goal_adj[2][2][2]; // axis, dir, what\nstd::vector<Info> used[2];\nint depth;\nvoid dfs(int x, int y, bool next_axis, int cost) {\n\tif (depth >= 6) return;\n\t// fprintf(stderr, \"(%d, %d) dir:%d cost:%d\\n\", x, y, next_axis, cost);\n\tint axis_pos = next_axis ? y : x;\n\tint axis_start = next_axis ? x : y;\n\tif (x == goal[0] && y == goal[1]) {\n\t\tres = std::min(res, cost);\n\t\treturn;\n\t} else if (!next_axis && x == goal[0] && (y < goal[1]) == data[next_axis][axis_pos]) {\n\t\tres = std::min(res, cost + std::abs(y - goal[1]));\n\t\treturn;\n\t} else if (next_axis && y == goal[1] && (x < goal[0]) == data[next_axis][axis_pos]) {\n\t\tres = std::min(res, cost + std::abs(x - goal[0]));\n\t\treturn;\n\t}\n\tauto trial = [&] (int next_pos) {\n\t\tfor (auto i : used[!next_axis]) {\n\t\t\tif ((i.con < axis_start) == (axis_start < next_pos) && axis_pos >= i.lower && axis_pos <= i.upper) return;\n\t\t\tif (i.con == next_pos && axis_pos >= i.lower && axis_pos <= i.upper) return;\n\t\t}\n\t\tdepth++;\n\t\tused[next_axis].push_back({axis_start, next_pos > axis_pos ? axis_pos : -INF, next_pos > axis_pos ? INF : next_pos});\n\t\tdfs(next_axis ? next_pos : x, next_axis ? y : next_pos, !next_axis, cost + std::abs(axis_start - next_pos));\n\t\tused[next_axis].pop_back();\n\t\tdepth--;\n\t};\n\tif (data[next_axis][axis_pos]) { // positive\n\t\tif (goal[!next_axis] > axis_start) {\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tint r0 = goal_adj[!next_axis][j][i];\n\t\t\t\t\tif (r0 != -1 && r0 > axis_start) trial(r0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else for (int i = 0; i < 2; i++)\n\t\t\tif (next[!next_axis][i][axis_start] != -1) trial(next[!next_axis][i][axis_start]);\n\t} else {\n\t\tif (goal[!next_axis] < axis_start) {\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tint r0 = goal_adj[!next_axis][j][i];\n\t\t\t\t\tif (r0 != -1 && r0 < axis_start) trial(r0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else for (int i = 0; i < 2; i++) if (prev[!next_axis][i][axis_start] != -1) trial(prev[!next_axis][i][axis_start]);\n\t}\n}\n\nint main() {\n\tn[0] = ri();\n\tn[1] = ri();\n\tint q = ri();\n\t{\n\t\tstd::string s, t;\n\t\tstd::cin >> s >> t;\n\t\tdata[0].resize(n[0]);\n\t\tdata[1].resize(n[1]);\n\t\tfor (int i = 0; i < n[0]; i++) data[0][i] = s[i] == 'E';\n\t\tfor (int i = 0; i < n[1]; i++) data[1][i] = t[i] == 'S';\n\t}\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) {\n\t\tint n = data[i].size();\n\t\tnext[i][j].resize(n);\n\t\tprev[i][j].resize(n);\n\t\tnext[i][j][n - 1] = -1;\n\t\tfor (int k = n; --k; ) {\n\t\t\tif (data[i][k] == j) next[i][j][k - 1] = k;\n\t\t\telse next[i][j][k - 1] = next[i][j][k];\n\t\t}\n\t\tprev[i][j][0] = -1;\n\t\tfor (int k = 0; k + 1 < n; k++) {\n\t\t\tif (data[i][k] == j) prev[i][j][k + 1] = k;\n\t\t\telse prev[i][j][k + 1] = prev[i][j][k];\n\t\t}\n\t}\n\t/*\n\tfor (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++) {\n\t\tstd::cerr << \"axis:\" << i << \" what:\" << j << \"  : \";\n\t\tfor (auto k : next[i][j]) std::cerr << k << \" \";\n\t\tstd::cerr << std::endl;\n\t}*/\n\t\n\tfor (int i = 0; i < q; i++) {\n\t\tint sx = ri() - 1;\n\t\tint sy = ri() - 1;\n\t\tgoal[0]\t= ri() - 1;\n\t\tgoal[1] = ri() - 1;\n\t\tfor (int j = 0; j < 2; j++) for (int k = 0; k < 2; k++) {\n\t\t\tgoal_adj[j][0][k] = data[j][goal[j]] == k ? goal[j] : prev[j][k][goal[j]];\n\t\t\tgoal_adj[j][1][k] = data[j][goal[j]] == k ? goal[j] : next[j][k][goal[j]];\n\t\t}\n\t\t// std::cerr << \"!\" << goal_adj[1][0][0] << \" \" << goal_adj[1][0][1] << std::endl;\n\t\tres = INF;\n\t\tdfs(sx, sy, false, 0);\n\t\tdfs(sx, sy, true, 0);\n\t\tprintf(\"%d\\n\", res == INF ? -1 : res);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v.size()==0  or v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v.size()==0 or v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\nint lb2(int x,vector<int> &v) {if(v.size()==0 or v[0]>x) return 1e8;return x-lb(x,v);}\nint ub2(int x,vector<int> &v) {if(v.size()==0 or v[v.size()-1]<x) return 1e8;return ub(x,v)-x;}\nint bet(int l,int r,vector<int> &v) {return (ub(l,v) and ub(l,v)<=r);}\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\tfor(int i=1;i<=n;i++) path[0][dir[0][i]].push_back(i);for(int i=1;i<=m;i++) path[1][dir[1][i]].push_back(i);\n \t\n\t\n\tfor(int i=1;i<=q;i++)\n\t{pii s=from[i],t=dest[i];\n\t\tif(s.first==t.first and dir[0][s.first]==s.second<t.second) ans[i]=0;\n\t\tif(s.second==t.second and dir[1][s.second]==s.first<t.first) ans[i]=0;\n\t\tif(s.first<=t.first and s.second<=t.second)\n\t\t{\n\t\t\tint me=0,me2=0,ms=0,ms2=0;\n\t\t\tif(!dir[0][s.first])me=lb2(s.first,path[0][1])+lb2(s.second,path[1][0]);\n\t\t\tif(!dir[1][s.second])ms=lb2(s.first,path[0][0])+lb2(s.second,path[1][1]);\n\t\t\t\n\t\t\tif(!dir[0][t.first])me2=ub2(t.first,path[0][1])+ub2(t.second,path[1][0]);\n\t\t\tif(!dir[1][t.second])ms2=ub2(t.first,path[0][0])+ub2(t.second,path[1][1]);\n\t\t\t\n\t\t\tans[i]=min(ans[i],me+ms2);ans[i]=min(ans[i],ms+me2);\n\t\t\tif(bet(s.first,t.first,path[0][1])) ans[i]=min(ans[i],ms+ms2);\n\t\t\tif(bet(s.second,t.second,path[1][1])) ans[i]=min(ans[i],me+me2);\n\t\t\t\n\t\t\tif(dir[1][s.second] and dir[1][t.second])\n\t\t\t\tif(bet(s.second,t.second,path[1][0]))\n\t\t\t\t\tans[i]=min(ans[i],lb2(s.first,path[0][1])+ub2(s.first,path[0][1]));\n\t\t\t\n\t\t\tif(dir[0][s.first] and dir[0][t.first])\n\t\t\t\tif(bet(s.first,t.first,path[0][0]))\n\t\t\t\t\tans[i]=min(ans[i],lb2(s.second,path[1][1])+ub2(s.second,path[1][1]));\n\t\t}\n\t} \n \t\n\t \t\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]*2+abs(from[i].first-dest[i].first)+abs(from[i].second-dest[i].second));else printf(\"%d\\n\",-1);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N,M,Q; cin >> N >> M >> Q;\n\tstring S,T; cin >> S; cin >> T;\n\tvector<int> ln(M+2,-1e9),rn(M+2,1e9),ls(M+2,-1e9),rs(M+2,1e9);\n\tvector<int> ue(N+2,-1e9),de(N+2,1e9),uw(N+2,-1e9),dw(N+2,1e9);\n\trepp(i,0,M){\n\t\tln[i+1] = ln[i]; ls[i+1] = ls[i];\n\t\tif(T[i] == 'N') ln[i+1] = i+1;\n\t\telse ls[i+1] = i+1;\n\t}\n\trepm(i,M,0){\n\t\trn[i] = rn[i+1]; rs[i] = rs[i+1];\n\t\tif(T[i-1] == 'N') rn[i] = i;\n\t\telse rs[i] = i;\n\t}\n\trepp(i,0,N){\n\t\tue[i+1] = ue[i]; uw[i+1] = uw[i];\n\t\tif(S[i] == 'E') ue[i+1] = i+1;\n\t\telse uw[i+1] = i+1;\n\t}\n\trepm(i,N,0){\n\t\tde[i] = de[i+1]; dw[i] = dw[i+1];\n\t\tif(S[i-1] == 'E') de[i] = i;\n\t\telse dw[i] = i;\n\t}\n\trepp(rep_q,0,Q){\n\t\tint a,b,c,d; cin >> a >> b >> c >> d;\n\t\tvector<int> v(6),h(6);\n\t\th[0] = a; v[0] = b; h[5] = c; v[5] = d;\n\t\tif(S[a-1] == 'E'){\n\t\t\th[1] = uw[a]; h[2] = dw[a];\n\t\t} else {\n\t\t\th[1] = ue[a]; h[2] = de[a];\n\t\t}\n\t\tif(S[c-1] == 'E'){\n\t\t\th[3] = uw[c]; h[4] = dw[c];\n\t\t} else {\n\t\t\th[3] = ue[c]; h[4] = de[c];\n\t\t}\n\t\tif(T[b-1] == 'N'){\n\t\t\tv[1] = ls[b]; v[2] = rs[b];\n\t\t} else {\n\t\t\tv[1] = ln[b]; v[2] = rn[b];\n\t\t}\n\t\tif(T[d-1] == 'N'){\n\t\t\tv[3] = ls[d]; v[4] = rs[d];\n\t\t} else {\n\t\t\tv[3] = ln[d]; v[4] = rn[d];\n\t\t}\n\t\tvector<vector<int>> ans(6,vector<int>(6,1e8)),p(6,vector<int>(6,0));\n\t\tans[0][0] = 0;\n\t\tint x = 0, y = 0;\n\t\twhile(x != -1){\n\t\t\tp[x][y] = 1;\n\t\t\tint xx = -1, yy = -1, zz = 1e8;\n\t\t\trepp(i,0,6) repp(j,0,6) if(!p[i][j]){\n\t\t\t\tif(h[x] == h[i] && h[x] > 0 && h[x] <= N && (((S[h[x]-1]=='W')^(v[y]<v[j])) || v[y] == v[j])) ans[i][j] = min(ans[i][j],ans[x][y]+abs(v[j]-v[y]));\n\t\t\t\tif(v[y] == v[j] && v[y] > 0 && v[y] <= M && (((T[v[y]-1]=='N')^(h[x]<h[i])) || h[x] == h[i])) ans[i][j] = min(ans[i][j],ans[x][y]+abs(h[i]-h[x]));\n\t\t\t\tif(zz > ans[i][j]){\n\t\t\t\t\txx = i; yy = j; zz = ans[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = xx; y = yy;\n\t\t}\n\t\tcout << (ans[5][5]==1e8?-1:ans[5][5]) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\n\nint main(){\n\tint N,M,Q;\n\tcin>>N>>M>>Q;\n\tint ansarr[Q];\n\tstring S,T;\n\tcin>>S>>T;\n\tint a[Q],b[Q],c[Q],d[Q];\n\tfor(int i=0;i<Q;++i)cin>>a[i]>>b[i]>>c[i]>>d[i];\n\tfor(int i=0;i<Q;++i){\n\t\tchar map[N][M];\n\t\tfor(int j=0;j<N;++j){\n\t\t\tfor(int k=0;k<M;++k){\n\t\t\t\tmap[j][k]='.';\n\t\t\t}\n\t\t}\n\t\tmap[a[i]-1][b[i]-1]='s';\n\t\tqueue<int>x;\n\t\tqueue<int>y;\n\t\tqueue<int>ans;\n\t\tx.push(b[i]);\n\t\ty.push(a[i]);\n\t\tans.push(0);\n\t\tint pro=1;\n\t\twhile(true){\n\t\t\tif(map[y.front()][x.front()-1]=='.' && y.front()<N && T[x.front()-1]=='S'){\n\t\t\t\tx.push(x.front());\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()+1==c[i] && x.front()==d[i]) break;\n\t\t\t\tmap[y.front()][x.front()-1]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-2][x.front()-1]=='.' && y.front()>1 && T[x.front()-1]=='N'){\n\t\t\t\tx.push(x.front());\n\t\t\t\ty.push(y.front()-1);\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()-1==c[i] && x.front()==d[i]) break;\n\t\t\t\tmap[y.front()-2][x.front()-1]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-1][x.front()]=='.' && x.front()<M && S[y.front()-1]=='E'){\n\t\t\t\tx.push(x.front()+1);\n\t\t\t\ty.push(y.front());\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()==c[i] && x.front()+1==d[i]) break;\n\t\t\t\tmap[y.front()-1][x.front()]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-1][x.front()-2]=='.' && x.front()>1 && S[y.front()-1]=='W'){\n\t\t\t\tx.push(x.front()-1);\n\t\t\t\ty.push(y.front());\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()==c[i] && x.front()-1==d[i]) break;\n\t\t\t\tmap[y.front()-1][x.front()-2]='+';\n\t\t\t}\n\t\t\telse if(x.size()>1){\n\t\t\t\tx.pop();\n\t\t\t\ty.pop();\n\t\t\t\tans.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpro=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pro==0)ansarr[i]=-1;\n\t\telse{\n\t\t\twhile(ans.size()>1)ans.pop();\n\t\t\tansarr[i]=ans.front();\n\t\t}\n\t}\n\tfor(int i=0;i<Q;++i)cout<<ansarr[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nint gi(){\n\tint x=0,w=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')w=0,ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\n#define mk make_pair\nint n,m,q,dis[8][8],inf;char s[100005],t[100005];\nvector<int>vec[4];queue<pair<int,int> >Q;\nvoid add(int i,int x,vector<int>&v){\n\tint sz=vec[i].size(),p=lower_bound(vec[i].begin(),vec[i].end(),x)-vec[i].begin();\n\tif(p)v.push_back(vec[i][p-1]);if(p<sz)v.push_back(vec[i][p]);\n}\nvoid upt(int x,int y,int z){\n\tif(dis[x][y]>z)dis[x][y]=z,Q.push(mk(x,y));\n}\nint main(){\n\tn=gi();m=gi();q=gi();scanf(\"%s%s\",s+1,t+1);\n\tfor(int i=1;i<=n;++i)vec[s[i]=='W'?0:1].push_back(i);\n\tfor(int i=1;i<=m;++i)vec[t[i]=='N'?2:3].push_back(i);\n\twhile(q--){\n\t\tint a=gi(),b=gi(),c=gi(),d=gi();vector<int>X,Y;\n\t\tfor(int i=0;i<2;++i)add(i,a,X),add(i,c,X);\n\t\tfor(int i=2;i<4;++i)add(i,b,Y),add(i,d,Y);\n\t\tsort(X.begin(),X.end());X.erase(unique(X.begin(),X.end()),X.end());\n\t\tsort(Y.begin(),Y.end());Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\t\tint lx=X.size(),ly=Y.size();\n\t\tint sx=lower_bound(X.begin(),X.end(),a)-X.begin();\n\t\tint sy=lower_bound(Y.begin(),Y.end(),b)-Y.begin();\n\t\tint tx=lower_bound(X.begin(),X.end(),c)-X.begin();\n\t\tint ty=lower_bound(Y.begin(),Y.end(),d)-Y.begin();\n\t\tmemset(dis,63,sizeof(dis));inf=dis[0][0];dis[sx][sy]=0;Q.push(mk(sx,sy));\n\t\twhile(!Q.empty()){\n\t\t\tint x=Q.front().first,y=Q.front().second;Q.pop();\n\t\t\tif(s[X[x]]=='W')for(int z=y-1;z>=0;--z)upt(x,z,dis[x][y]+Y[y]-Y[z]);\n\t\t\telse for(int z=y+1;z<ly;++z)upt(x,z,dis[x][y]+Y[z]-Y[y]);\n\t\t\tif(t[Y[y]]=='N')for(int z=x-1;z>=0;--z)upt(z,y,dis[x][y]+X[x]-X[z]);\n\t\t\telse for(int z=x+1;z<lx;++z)upt(z,y,dis[x][y]+X[z]-X[x]);\n\t\t}\n\t\tprintf(\"%d\\n\",dis[tx][ty]==inf?-1:dis[tx][ty]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 200002\n\nint n;\nint m;\n\nchar buf[MAX];\nstring s;\nstring t;\n\nint qq;\n\nvector<int> row[2];\nvector<int> col[2];\n\nvector<int> R;\nvector<int> C;\n\nvoid row_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(row[i].begin(), row[i].end(), y) - row[i].begin();\n\t\tif (id != row[i].size()) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != row[i].size() && row[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != row[i].size()) {\n\t\t\t\tR.push_back(row[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid col_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(col[i].begin(), col[i].end(), y) - col[i].begin();\n\t\tif (id != col[i].size()) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != col[i].size() && col[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != col[i].size()) {\n\t\t\t\tC.push_back(col[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dist[20][20];\npriority_queue<pair<int, pair<int, int> >, vector<pair<int, pair<int, int> > >, greater<pair<int, pair<int, int> > > > q;\n\nint main() {\n\tcin >> n>>m>>qq;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tscanf(\"%s\", buf);\n\tt = buf;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == 'W') {\n\t\t\trow[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\trow[1].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'N') {\n\t\t\tcol[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tcol[1].push_back(i);\n\t\t}\n\t}\n\twhile (qq--) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\ta--;\n\t\tb--;\n\t\tc--;\n\t\td--;\n\t\tR.clear();\n\t\tC.clear();\n\t\trow_ava(a);\n\t\trow_ava(c);\n\t\tcol_ava(b);\n\t\tcol_ava(d);\n\t\tsort(R.begin(), R.end());\n\t\tR.erase(unique(R.begin(), R.end()),R.end());\n\t\tsort(C.begin(), C.end());\n\t\tC.erase(unique(C.begin(), C.end()),C.end());\n\t\tpair<int, int> star = make_pair(-1, -1);\n\t\tpair<int, int> en = make_pair(-1, -1);\n\t\tfor (int i = 0; i < R.size(); i++) {\n\t\t\tfor (int j = 0; j < C.size(); j++) {\n\t\t\t\tdist[i][j] = -1;\n\t\t\t\tif (R[i] == a && C[j] == b) {\n\t\t\t\t\tstar = make_pair(i, j);\n\t\t\t\t}\n\t\t\t\tif (R[i] == c && C[j] == d) {\n\t\t\t\t\ten = make_pair(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist[star.first][star.second] = 0;\n\t\tq.push(make_pair(0,make_pair(star.first, star.second)));\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.top().second.first;\n\t\t\tint y = q.top().second.second;\n\t\t\tint est = q.top().first;\n\t\t\tq.pop();\n\t\t\tint ds = dist[x][y];\n\t\t\tif (ds != est)continue;\n\t\t\tif (s[R[x]] == 'W') {\n\t\t\t\tif (y) {\n\t\t\t\t\tint nex = (C[y] - C[y - 1]) + ds;\n\t\t\t\t\tif (dist[x][y-1]==-1||dist[x][y - 1] > nex) {\n\t\t\t\t\t\tdist[x][y - 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex,make_pair(x, y - 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[R[x]] == 'E') {\n\t\t\t\tif (y+1<C.size()) {\n\t\t\t\t\tint nex = (C[y+1] - C[y]) + ds;\n\t\t\t\t\tif (dist[x][y + 1] == -1 || dist[x][y +1] > nex) {\n\t\t\t\t\t\tdist[x][y + 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x, y + 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'N') {\n\t\t\t\tif (x) {\n\t\t\t\t\tint nex = (R[x] - R[x - 1]) + ds;\n\t\t\t\t\tif (dist[x - 1][y] == -1 || dist[x - 1][y] > nex) {\n\t\t\t\t\t\tdist[x - 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x - 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'S') {\n\t\t\t\tif (x+1<R.size()) {\n\t\t\t\t\tint nex = (R[x+1] - R[x]) + ds;\n\t\t\t\t\tif (dist[x + 1][y] == -1 || dist[x + 1][y] > nex) {\n\t\t\t\t\t\tdist[x + 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x + 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dist[en.first][en.second]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing nagai = long long;\n#define sz(x) int((x).size())\nconst int N=100100;\nconst int Q=200200;\nint n,m,q;\nstring s,t;\nint sgn(int x){\n\t return (x>0)-(x<0);\n}\nint dir1[N],dir2[N];\n\nvector<int>occ1[2],occ2[2];\nvector<int>inter1,inter2;\nconst int SZ=10;\nnagai d[SZ][SZ];\nconst nagai oo=0x3f3f3f3f3f3f3f3f;\n\nstruct cmp{\n\tbool operator()(pair<int,int>a,pair<int,int>b)const{\n\t\tif(d[a.first][a.second]!=d[b.first][b.second])\n\t\t\treturn d[a.first][a.second]<d[b.first][b.second];\n\t\treturn a<b;\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n>>m>>q;\n\tcin>>s>>t;\n\tfor(int i=0;i<n;++i)\n\t\tdir1[i]=s[i]=='E'?1:-1;\n\tfor(int i=0;i<m;++i)\n\t\tdir2[i]=t[i]=='S'?1:-1;\n\tfor(int i=0;i<n;++i)\n\t\tocc1[dir1[i]>0].push_back(i);\n\tfor(int i=0;i<m;++i)\n\t\tocc2[dir2[i]>0].push_back(i);\n\tfor(int i=0;i<q;++i){\n\t\t int a,b,c,D;\n\t\t cin>>a>>b>>c>>D;\n\t\t --a,--b,--c,--D;\n\t\t inter1.clear();\n\t\t inter2.clear();\n\t\t for(int d=0;d<2;++d){\n\t\t\t for(int pt:{a,c}){\n\t\t\t\t int kek=lower_bound(occ1[d].begin(),occ1[d].end(),pt)-occ1[d].begin();\n\t\t\t\t if(kek!=occ1[d].size())inter1.push_back(occ1[d][kek]);\n\t\t\t\t if(kek!=0)inter1.push_back(occ1[d][kek-1]);\n\t\t\t }\n\t\t\t for(int pt:{b,D}){\n\t\t\t\t int kek=lower_bound(occ2[d].begin(),occ2[d].end(),pt)-occ2[d].begin();\n\t\t\t\t if(kek!=occ2[d].size())inter2.push_back(occ2[d][kek]);\n\t\t\t\t if(kek!=0)inter2.push_back(occ2[d][kek-1]);\n\t\t\t }\n\t\t }\n\t\t sort(inter1.begin(),inter1.end());\n\t\t inter1.erase(unique(inter1.begin(),inter1.end()),inter1.end());\n\t\t sort(inter2.begin(),inter2.end());\n\t\t inter2.erase(unique(inter2.begin(),inter2.end()),inter2.end());\n\t\t memset(d,0x3f,sizeof d);\n\t\t auto find=[&](vector<int>&vec,int x){\n\t\t\t return lower_bound(vec.begin(),vec.end(),x)-vec.begin();\n\t\t };\n\t\t int sx=find(inter1,a);\n\t\t int sy=find(inter2,b);\n\t\t set<pair<int,int>,cmp>st;\n\t\t d[sx][sy]=0;\n\t\t int sz1=inter1.size();\n\t\t int sz2=inter2.size();\n\t\t st.insert({sx,sy});\n\t\t int tx=find(inter1,c);\n\t\t int ty=find(inter2,D);\n\t\t while(st.size()){\n\t\t\t int x,y;\n\t\t\t tie(x,y)=*st.begin();\n\t\t\t st.erase(st.begin());\n\t\t\t if(x==tx&&y==ty){\n\t\t\t\t break;\n\t\t\t }\n\t\t\t vector<pair<int,int>>inter;\n\t\t\t for(int x1=0;x1<sz1;++x1)\n\t\t\t\t if(sgn(x1-x)==dir2[inter2[y]])\n\t\t\t\t\t inter.emplace_back(x1,y);\n\t\t\t for(int y1=0;y1<sz2;++y1)\n\t\t\t\t if(sgn(y1-y)==dir1[inter1[x]])\n\t\t\t\t\t inter.emplace_back(x,y1);\n\t\t\t for(auto p:inter){\n\t\t\t\t int x1=p.first,y1=p.second;\n\t\t\t\t int d1=d[x][y]+abs(inter1[x]-inter1[x1])+abs(inter2[y]-inter2[y1]);\n\t\t\t\t if(d[x1][y1]>d1){\n\t\t\t\t\t st.erase(p);\n\t\t\t\t\t d[x1][y1]=d1;\n\t\t\t\t\t st.insert(p);\n\t\t\t\t }\n\t\t\t }\n\t\t }\n\t\t if(d[tx][ty]==oo)\n\t\t\t cout<<-1<<'\\n';\n\t\t else\n\t\t\t cout<<d[tx][ty]<<'\\n';\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q;\n    cin >> n >> m >> q;\n    string s,t;\n    cin >> s >> t;\n    vector<int> L,R;\n    vector<int> U,D;\n    rep(i,n){\n        if(s[i]=='W'){\n            L.push_back(i);\n        }else{\n            R.push_back(i);\n        }\n    }\n    rep(i,m){\n        if(t[i]=='N'){\n            U.push_back(i);\n        }else{\n            D.push_back(i);\n        }\n    }\n    rep(zz,q){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        a--;b--;c--;d--;\n        queue<pair<pair<pair<int,int>,pair<int,int> >,pair<int,int> > >q;\n        if(t[b]=='N'){\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(-1,1)));\n        }else{\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(1,1)));\n        }\n        if(s[a]=='W'){\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(-1,0)));\n        }else{\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(1,0)));\n        }\n        int mi = inf;\n        while(!q.empty()){\n            auto x = q.front();\n            q.pop();\n            int dist = x.first.first.first;\n            int cnt = x.first.first.second;\n            int na = x.first.second.first;\n            int nb = x.first.second.second;\n            int pl = x.second.first;\n            int dir = x.second.second;\n            // cerr << na << \" \" << nb << \" \" << dist << \" \" << cnt << \" \" << pl << \" \" << dir << endl;\n            if(na==c&&nb==d){\n                chmin(mi,dist);\n                continue;\n            }\n            if(cnt==5)continue;\n            if(dir==1){// UP DOWN\n                if(pl==-1){//UP\n                    if(c<na&&nb==d){\n                        chmin(mi,dist+na-c);\n                        continue;\n                    }        \n                    if(true||nb<=d){\n                        int tar = min(na,c);\n                        auto x = lower_bound(all(R),tar);\n                        if(x!=R.end()){\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                        if(x!=R.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                    }\n                    if(true||nb>=d){\n                        int tar = min(na,c);\n                        auto x = lower_bound(all(L),tar);\n                        if(x!=L.end()){\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                        if(x!=L.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                    }\n                }else{//DOWN\n                    if(c>na&&nb==d){\n                        chmin(mi,dist+abs(c-na));\n                        continue;\n                    }        \n                    if(true||nb<=d){\n                        int tar = max(na,c);\n                        auto x = lower_bound(all(R),tar);\n                        if(x!=R.end()){\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                        if(x!=R.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                    }\n                    if(true||nb>=d){\n                        int tar = max(na,c);\n                        auto x = lower_bound(all(L),tar);\n                        if(x!=L.end()){\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                        if(x!=L.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                    }\n                }\n\n            }else{// LEFT RIGHT\n                if(pl==-1){//LEFT\n                    if(d<nb&&na==c){\n                        chmin(mi,dist+abs(nb-d));\n                        continue;\n                    }        \n                    if(true||na<=c){\n                        int tar = min(nb,d);\n                        auto x = lower_bound(all(D),tar);\n                        if(x!=D.end()){\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                        if(x!=D.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                    }\n                    if(true||na>=c){\n                        int tar = min(nb,d);\n                        auto x = lower_bound(all(U),tar);\n                        if(x!=U.end()){\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                        if(x!=U.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                    }\n                }else{//RIGHT\n                    if(d>nb&&na==c){\n                        chmin(mi,dist+abs(d-nb));\n                        continue;\n                    }        \n                    if(true||na<=c){\n                        int tar = max(nb,d);\n                        auto x = lower_bound(all(D),tar);\n                        if(x!=D.end()){\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                        if(x!=D.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                    }\n                    if(true||na>=c){\n                        int tar = max(nb,d);\n                        auto x = lower_bound(all(U),tar);\n                        if(x!=U.end()){\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                        if(x!=U.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                    }\n                }\n            }\n        }\n        if(mi!=inf){\n            cout << mi << \"\\n\";\n        }else{\n            cout << -1 << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 5;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\nmap < pair < int, int >, int > mp;\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n   // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (can_simple(fromx, fromy, tox, toy)) return abs(fromx - tox) + abs(fromy - toy);\n    if (step == BUBEN) return INF;\n    if (mp.count(make_pair(fromx, fromy)) && mp[make_pair(fromx, fromy)] <= step) return INF;\n    mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][toy] == -1) continue;\n            int where = nxt[1][val][i][toy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][tox] == -1) continue;\n            int where = nxt[0][val][i][tox];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j] == k) nxt[i][val][0][j] = j;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j] == k) nxt[i][val][1][j] = j;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\nconst ll INF = TEN(18);\n\nint main() {\n    int N, M, Q;\n    string S, T;\n    cin >> N >> M >> Q >> S >> T;\n    debug(S, T);\n    V<int> vw, ve, vn, vs;\n    rep(i, N) {\n        if (S[i] == 'W') {\n            vw.pb(i);\n        } else {\n            ve.pb(i);\n        }\n    }\n    rep(i, M) {\n        if (T[i] == 'N') {\n            vn.pb(i);\n        } else {\n            vs.pb(i);\n        }\n    }\n    while (Q--) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        --a, --b, --c, --d;\n        V<int> xs{a, c}, ys{b, d};\n        for (int x : {a, c}) {\n            if (S[a] == 'E') {\n                auto it = lower_bound(ALL(vw), x);\n                if (it != vw.end()) {\n                    xs.pb(*it);\n                }\n                if (it != vw.begin()) {\n                    --it;\n                    xs.pb(*it);\n                }\n            } else {\n                auto it = lower_bound(ALL(ve), x);\n                if (it != ve.end()) {\n                    xs.pb(*it);\n                }\n                if (it != ve.begin()) {\n                    --it;\n                    xs.pb(*it);\n                }\n            }\n        }\n        for (int y : {b, d}) {\n            if (T[y] == 'N') {\n                auto it = lower_bound(ALL(vs), y);\n                if (it != vs.end()) {\n                    ys.pb(*it);\n                }\n                if (it != vs.begin()) {\n                    --it;\n                    vs.pb(*it);\n                }\n            } else {\n                auto it = lower_bound(ALL(vn), y);\n                if (it != vn.end()) {\n                    ys.pb(*it);\n                }\n                if (it != vn.begin()) {\n                    --it;\n                    ys.pb(*it);\n                }\n            }\n        }\n        sort(ALL(xs));\n        xs.erase(unique(ALL(xs)), xs.end());\n        sort(ALL(ys));\n        ys.erase(unique(ALL(ys)), ys.end());\n        debug(xs, ys);\n\n        a = lower_bound(ALL(xs), a) - xs.begin();\n        b = lower_bound(ALL(ys), b) - ys.begin();\n        c = lower_bound(ALL(xs), c) - xs.begin();\n        d = lower_bound(ALL(ys), d) - ys.begin();\n\n        using Data = pair<ll, pii>;\n        priority_queue<Data, V<Data>, greater<Data>> que;\n        VV<ll> ds(xs.size(), V<ll>(ys.size(), INF));\n        ds[a][b] = 0;\n        que.push(mp(0, mp(a, b)));\n        while (!que.empty()) {\n            auto t = que.top();\n            que.pop();\n            int x, y;\n            tie(x, y) = t.se;\n            if (ds[x][y] < t.fi) continue;\n\n            if (T[ys[y]] == 'S') {\n                for (int nx = x + 1; nx < xs.size(); ++nx) {\n                    ll nd = ds[x][y] + abs(xs[nx] - xs[x]);\n                    if (ds[nx][y] > nd) {\n                        ds[nx][y] = nd;\n                        que.push(mp(nd, mp(nx, y)));\n                    }\n                }\n            } else {\n                for (int nx = x - 1; nx >= 0; --nx) {\n                    ll nd = ds[x][y] + abs(xs[nx] - xs[x]);\n                    if (ds[nx][y] > nd) {\n                        ds[nx][y] = nd;\n                        que.push(mp(nd, mp(nx, y)));\n                    }\n                }\n            }\n            if (S[xs[x]] == 'E') {\n                for (int ny = y + 1; ny < ys.size(); ++ny) {\n                    ll nd = ds[x][y] + abs(ys[ny] - ys[y]);\n                    if (ds[x][ny] > nd) {\n                        ds[x][ny] = nd;\n                        que.push(mp(nd, mp(x, ny)));\n                    }\n                }\n            } else {\n                for (int ny = y - 1; ny >= 0; --ny) {\n                    ll nd = ds[x][y] + abs(ys[ny] - ys[y]);\n                    if (ds[x][ny] > nd) {\n                        ds[x][ny] = nd;\n                        que.push(mp(nd, mp(x, ny)));\n                    }\n                }\n            }\n        }\n        ll ans = ds[c][d];\n        if (ans == INF) ans = -1;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 7;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\n\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\n\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n    // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (step == BUBEN) return INF;\n   // mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j - 1] == k) nxt[i][val][0][j] = j - 1;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j + 1] == k) nxt[i][val][1][j] = j + 1;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n//        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 6;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\n//map < pair < int, int >, int > mp;\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n    // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (step == BUBEN) return INF;\n   // mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j] == k) nxt[i][val][0][j] = j;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j] == k) nxt[i][val][1][j] = j;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\nstruct Edge{\n    int u,v;\n    long long c;\n    Edge(int u,int v,long long c):u(u),v(v),c(c){}\n};\nstruct Element{\n    int start,end;\n    Element(int s,int e):start(s),end(e){}\n};\nstruct Node{\n    int u;\n    long long value;\n    Node(int u,long long value):u(u),value(value){}\n    bool operator <(const Node& other)const{\n        return value>other.value;\n    }\n};\nchar s[100005], t[100005];\n//0, 1: n,s/w,e\nint lx[100005][2], rx[100005][2];\nint ly[100005][2], ry[100005][2];\nint needX[100005], needY[100005];\nint row[10], col[10];\nstd::vector<Edge>g[105];\nint vis[105]; long long dis[105];\n\nvoid preWork(int n,int m){\n\tfor(int i = 1; i <= n; i++){\n\t\tif(i!=1) lx[i][0] = lx[i-1][0], lx[i][1] = lx[i-1][1];\n\t\telse lx[i][0] = lx[i][1] = -1;\n\t\tif(s[i]=='W') lx[i][0] = i;\n\t\telse lx[i][1] = i;\n\t}\n\tfor(int i = n; i >= 1; i--){\n\t\tif(i!=n) rx[i][0] = rx[i+1][0], rx[i][1] = rx[i+1][1];\n\t\telse rx[i][0] = rx[i][1] = -1;\n\t\tif(s[i]=='W') rx[i][0] = i;\n\t\telse rx[i][1] = i;\n\t}\n\tfor(int i = 1; i <= m; i++){\n\t\tif(i!=1) ly[i][0] = ly[i-1][0], ly[i][1] = ly[i-1][1];\n\t\telse ly[i][0] = ly[i][1] = -1;\n\t\tif(t[i]=='N') ly[i][0] = i;\n\t\telse ly[i][1] = i;\n\t}\n\tfor(int i = m; i >= 1; i--){\n\t\tif(i!=m) ry[i][0] = ry[i+1][0], ry[i][1] = ry[i+1][1];\n\t\telse ry[i][0] = ry[i][1] = -1;\n\t\tif(t[i]=='N') ry[i][0] = i;\n\t\telse ry[i][1] = i;\n\t}\n}\n\nlong long max(long long a,long long b){ return a>b?a:b; }\n\nlong long min(long long a,long long b){ return a>b?b:a; }\n\nElement buildGraph(int cntR,int cntC,int A,int B,int C,int D){\n    std::sort(row+1,row+1+cntR);\n    std::sort(col+1,col+1+cntC);\n    /*for(int i = 1; i <= cntR; i++) printf(\"%d \",row[i]);\n    printf(\"\\n\");\n    for(int i = 1; i <= cntC; i++) printf(\"%d \",col[i]);\n    printf(\"\\n\");*/\n    int start = -1, end = -1;\n    for(int i = 1; i <= cntR; i++){\n        for(int j = 1; j <= cntC; j++){\n            int id = (i-1)*cntC+j;\n            g[id].clear();\n            vis[id] = 0;\n            dis[id] = 1e18+7;\n            int r = row[i], c = col[j];\n            if(s[r]=='W' && j!=1) g[id].push_back(Edge(id,(i-1)*cntC+j-1,c-col[j-1]));\n            else if(s[r]=='E' && j!=cntC) g[id].push_back(Edge(id,(i-1)*cntC+j+1,col[j+1]-c));\n            if(t[c]=='N' && i!=1) g[id].push_back(Edge(id,(i-2)*cntC+j,row[i]-row[i-1]));\n            else if(t[c]=='S' && i!=cntR) g[id].push_back(Edge(id,(i)*cntC+j,row[i+1]-row[i]));\n            if(r==A && c==B) start = id;\n            else if(r==C && c==D) end = id;\n        }\n    }\n    return Element(start,end);\n}\n\nlong long dijkstra(int start,int end){\n    std::priority_queue<Node>Q;\n    dis[start] = 0;\n    Q.push(Node(start,dis[start]));\n    while(Q.size()!=0){\n        while(Q.size()!=0 && vis[Q.top().u]==1) Q.pop();\n        if(Q.size()==0) break;\n        Node cur = Q.top(); Q.pop();\n        int u = cur.u;\n        vis[u] = 1;\n        for(int i = 0; i < (int)g[u].size(); i++){\n            int v = g[u][i].v;\n            if(vis[v]==0 && dis[u]+g[u][i].c<dis[v]){\n                dis[v] = dis[u]+g[u][i].c;\n                Q.push(Node(v,dis[v]));\n            }\n        }\n    }\n    if(vis[end]) return dis[end];\n    else return -1;\n}\n\nint main(){\n\tint n,m,q;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s%s\",s+1,t+1);\n\tpreWork(n,m);\n    while(q--){\n        int a,b,c,d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        int cntR = 0, cntC = 0;\n        for(int i = 0; i < 2; i++){\n            if(lx[a][i]!=-1 && !needX[lx[a][i]]) row[++cntR] = lx[a][i], needX[lx[a][i]] = 1;\n            if(rx[a][i]!=-1 && !needX[rx[a][i]]) row[++cntR] = rx[a][i], needX[rx[a][i]] = 1;\n            if(lx[c][i]!=-1 && !needX[lx[c][i]]) row[++cntR] = lx[c][i], needX[lx[c][i]] = 1;\n            if(rx[c][i]!=-1 && !needX[rx[c][i]]) row[++cntR] = rx[c][i], needX[rx[c][i]] = 1;\n            if(ly[b][i]!=-1 && !needY[ly[b][i]]) col[++cntC] = ly[b][i], needY[ly[b][i]] = 1;\n            if(ry[b][i]!=-1 && !needY[ry[b][i]]) col[++cntC] = ry[b][i], needY[ry[b][i]] = 1;\n            if(ly[d][i]!=-1 && !needY[ly[d][i]]) col[++cntC] = ly[d][i], needY[ly[d][i]] = 1;\n            if(ry[d][i]!=-1 && !needY[ry[d][i]]) col[++cntC] = ry[d][i], needY[ry[d][i]] = 1;\n        }\n        Element graph = buildGraph(cntR,cntC,a,b,c,d);\n        printf(\"%lld\\n\",dijkstra(graph.start,graph.end));\n        for(int i = 1; i <= cntR; i++) needX[row[i]] = 0;\n        for(int i = 1; i <= cntC; i++) needY[col[i]] = 0;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n \n#define MAX 200002\n \nint n;\nint m;\n \nchar buf[MAX];\nstring s;\nstring t;\n \nint qq;\n \nvector<int> row[2];\nvector<int> col[2];\n \nvector<int> R;\nvector<int> C;\n \nvoid row_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(row[i].begin(), row[i].end(), y) - row[i].begin();\n\t\tif (id != row[i].size()) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != row[i].size() && row[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != row[i].size()) {\n\t\t\t\tR.push_back(row[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid col_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(col[i].begin(), col[i].end(), y) - col[i].begin();\n\t\tif (id != col[i].size()) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != col[i].size() && col[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != col[i].size()) {\n\t\t\t\tC.push_back(col[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\n \nint dist[8][8];\n priority_queue<pair<int,pair<int, int> >,vector<pair<int, pair<int, int> > > , greater<pair<int, pair<int, int> > > > q;\n \nint main() {\n\tcin >> n>>m>>qq;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tscanf(\"%s\", buf);\n\tt = buf;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == 'W') {\n\t\t\trow[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\trow[1].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'N') {\n\t\t\tcol[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tcol[1].push_back(i);\n\t\t}\n\t}\n\twhile (qq--) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\ta--;\n\t\tb--;\n\t\tc--;\n\t\td--;\n\t\tR.clear();\n\t\tC.clear();\n\t\trow_ava(a);\n\t\trow_ava(c);\n\t\tcol_ava(b);\n\t\tcol_ava(d);\n\t\tsort(R.begin(), R.end());\n\t\tR.erase(unique(R.begin(), R.end()),R.end());\n\t\tsort(C.begin(), C.end());\n\t\tC.erase(unique(C.begin(), C.end()),C.end());\n\t\tpair<int, int> star = make_pair(-1, -1);\n\t\tpair<int, int> en = make_pair(-1, -1);\n\t\tfor (int i = 0; i < R.size(); i++) {\n\t\t\tfor (int j = 0; j < C.size(); j++) {\n\t\t\t\tdist[i][j] = -1;\n\t\t\t\tif (R[i] == a && C[j] == b) {\n\t\t\t\t\tstar = make_pair(i, j);\n\t\t\t\t}\n\t\t\t\tif (R[i] == c && C[j] == d) {\n\t\t\t\t\ten = make_pair(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist[star.first][star.second] = 0;\n\t\t\n\t\tq.push(make_pair(0,make_pair(star.first, star.second)));\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.top().second.first;\n\t\t\tint y = q.top().second.second;\n\t\t\tint est = q.top().first;\n\t\t\tq.pop();\n\t\t\tint ds = dist[x][y];\n\t\t\tif (ds != est)continue;\n\t\t\tif (s[R[x]] == 'W') {\n\t\t\t\tif (y) {\n\t\t\t\t\tint nex = (C[y] - C[y - 1]) + ds;\n\t\t\t\t\tif (dist[x][y-1]==-1||dist[x][y - 1] > nex) {\n\t\t\t\t\t\tdist[x][y - 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex,make_pair(x, y - 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[R[x]] == 'E') {\n\t\t\t\tif (y+1<C.size()) {\n\t\t\t\t\tint nex = (C[y+1] - C[y]) + ds;\n\t\t\t\t\tif (dist[x][y + 1] == -1 || dist[x][y +1] > nex) {\n\t\t\t\t\t\tdist[x][y + 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x, y + 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'N') {\n\t\t\t\tif (x) {\n\t\t\t\t\tint nex = (R[x] - R[x - 1]) + ds;\n\t\t\t\t\tif (dist[x - 1][y] == -1 || dist[x - 1][y] > nex) {\n\t\t\t\t\t\tdist[x - 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x - 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'S') {\n\t\t\t\tif (x+1<R.size()) {\n\t\t\t\t\tint nex = (R[x+1] - R[x]) + ds;\n\t\t\t\t\tif (dist[x + 1][y] == -1 || dist[x + 1][y] > nex) {\n\t\t\t\t\t\tdist[x + 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x + 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dist[en.first][en.second]);\n\t}\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_set>\n# include <unordered_map>\nusing namespace std;\n\n\nint n, m, qq;\nstring s1, s2;\nint ans;\nint XX, YY;\nint pr1[100005][2];\nint sf1[100005][2];\nint pr2[100005][2];\nint sf2[100005][2];\n\nvoid upd(int x) {\n    if (x < ans) ans = x;\n    return;\n}\n\nvoid check(int x, int y, int len) {\n    if (XX == x && YY == y) { upd(len); return;}\n    len += abs(x - XX) + abs(y - YY);\n    if (XX == x) {\n        if ((YY < y && s1[x] == 'W') || (YY > y && s1[x] == 'E')) { upd(len);}\n        return;\n    }\n    if (YY == y) {\n        if ((XX < x && s2[y] == 'N') || (XX > x && s2[y] == 'S')) upd(len);\n        return;\n    }\n    char c1, c2;\n    if (XX > x) c1 = 'S';\n    else c1 = 'N';\n    if (YY > y) c2 = 'E';\n    else c2 = 'W';\n    if ((s1[x] == c2 && s2[YY] == c1) || (s2[y] == c1 && s1[XX] == c2)) upd(len);\n    return;\n}\n\nvoid recurs(int x, int y, int d, int len) {\n    check(x, y, len);\n    if (d == 8) return;\n    if (s1[x] == 'E' && s2[y] == 'N') {\n        if (sf2[y][1]) recurs(x, sf2[y][1], d + 1, len + sf2[y][1] - y);\n        if (pr1[x][1]) recurs(pr1[x][1], y, d + 1, len + x - pr1[x][1]);\n    } else if (s1[x] == 'E' && s2[y] == 'S') {\n        if (sf2[y][0]) recurs(x, sf2[y][0], d + 1, len + sf2[y][0] - y);\n        if (sf1[x][1]) recurs(sf1[x][1], y, d + 1, len + sf1[x][1] - x);\n    } else if (s1[x] == 'W' && s2[y] == 'N') {\n        if (pr2[y][1]) recurs(x, pr2[y][1], d + 1, len + y - pr2[y][1]);\n        if (pr1[x][0]) recurs(pr1[x][0], y, d + 1, len + x - pr1[x][0]);\n    } else {\n        if (pr2[y][0]) recurs(x, pr2[y][0], d + 1, len + y - pr2[y][0]);\n        if (sf1[x][0]) recurs(sf1[x][0], y, d + 1, len + sf1[x][0] - x);\n    }\n    return;\n}\n\nint main(int argc, const char * argv[]) {\n//    freopen(\"/Users/danya.smelskiy/Documents/Danya/Resources/input.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m >> qq;\n    cin >> s1 >> s2;\n    s1 = \"#\" + s1;\n    s2 = \"#\" + s2;\n    \n    for (int i = 1; i <= n; ++i) {\n        pr1[i][0] = pr1[i - 1][0];\n        pr1[i][1] = pr1[i - 1][1];\n        if (s1[i] == 'E') pr1[i][0] = i;\n        else pr1[i][1] = i;\n    }\n    for (int i = n; i > 0; --i) {\n        sf1[i][0] = sf1[i + 1][0];\n        sf1[i][1] = sf1[i + 1][1];\n        if (s1[i] == 'E') sf1[i][0] = i;\n        else sf1[i][1] = i;\n    }\n    \n    for (int i = 1; i <= m; ++i) {\n        pr2[i][0] = pr2[i - 1][0];\n        pr2[i][1] = pr2[i - 1][1];\n        if (s2[i] == 'N') pr2[i][0] = i;\n        else pr2[i][1] = i;\n    }\n    for (int i = m; i > 0; --i) {\n        sf2[i][0] = sf2[i + 1][0];\n        sf2[i][1] = sf2[i + 1][1];\n        if (s2[i] == 'N') sf2[i][0] = i;\n        else sf2[i][1] = i;\n    }\n    int x, y;\n    while (qq--) {\n        cin >> x >> y >> XX >> YY;\n        ans = 1e9;\n        recurs(x, y, 0, 0);\n        if (ans < 1e9) cout << ans << '\\n';\n        else cout << \"-1\\n\";\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 4;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\n\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\n\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n    // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (step == BUBEN) return INF;\n   // mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j - 1] == k) nxt[i][val][0][j] = j - 1;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j + 1] == k) nxt[i][val][1][j] = j + 1;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n//        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 6;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\nmap < pair < int, int >, int > mp;\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n   // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (can_simple(fromx, fromy, tox, toy)) return abs(fromx - tox) + abs(fromy - toy);\n    if (step == BUBEN) return INF;\n    if (mp.count(make_pair(fromx, fromy)) && mp[make_pair(fromx, fromy)] <= step) return INF;\n    mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][toy] == -1) continue;\n            int where = nxt[1][val][i][toy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][tox] == -1) continue;\n            int where = nxt[0][val][i][tox];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j] == k) nxt[i][val][0][j] = j;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j] == k) nxt[i][val][1][j] = j;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf (int)(1e9)\n\nstruct edge{\n\tint to;\n\tint cost;\n\n\tedge(int to, int cost) : to(to), cost(cost){}\n};\n\nvector<int> dijkstra(vector<vector<edge> > &g, int s){\n\tvector<int> ans(g.size(), inf);\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;//(距離, 頂点番号)\n\tq.push(pair<int, int>(0, s));\n\twhile(q.size() > 0){\n\t\tint dis = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tif(dis < ans[v]){\n\t\t\tans[v] = dis;\n\t\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\t\tq.push(pair<int, int>(dis + g[v][i].cost, g[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint align(int x, int y){\n\treturn 5 * x + y;\n}\n\nint main(){\n\tint N, M, Q, i, j;\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<char> S(N + 2);\n\tvector<int> nextW(N + 2), nextE(N + 2), prevW(N + 2), prevE(N + 2);\n\tscanf(\"%s\", &S[1]);\n\tnextW[N + 1] = N + 1;\n\tnextE[N + 1] = N + 1;\n\tfor(i = N; i > 0; i--){\n\t\tif(S[i] == 'W'){\n\t\t\tnextW[i] = i;\n\t\t\tnextE[i] = nextE[i + 1];\n\t\t}\n\t\telse{\n\t\t\tnextW[i] = nextW[i + 1];\n\t\t\tnextE[i] = i;\n\t\t}\n\t}\n\tprevW[0] = 0;\n\tprevE[0] = 0;\n\tfor(i = 1; i <= N; i++){\n\t\tif(S[i] == 'W'){\n\t\t\tprevW[i] = i;\n\t\t\tprevE[i] = prevE[i - 1];\n\t\t}\n\t\telse{\n\t\t\tprevW[i] = prevW[i - 1];\n\t\t\tprevE[i] = i;\n\t\t}\n\t}\n\n\tvector<char> T(M + 2);\n\tvector<int> nextN(M + 2), nextS(M + 2), prevN(M + 2), prevS(M + 2);\n\tscanf(\"%s\", &T[1]);\n\tnextN[M + 1] = M + 1;\n\tnextS[M + 1] = M + 1;\n\tfor(i = M; i > 0; i--){\n\t\tif(T[i] == 'N'){\n\t\t\tnextN[i] = i;\n\t\t\tnextS[i] = nextS[i + 1];\n\t\t}\n\t\telse{\n\t\t\tnextN[i] = nextN[i + 1];\n\t\t\tnextS[i] = i;\n\t\t}\n\t}\n\tprevN[0] = 0;\n\tprevS[0] = 0;\n\tfor(i = 1; i <= M; i++){\n\t\tif(T[i] == 'N'){\n\t\t\tprevN[i] = i;\n\t\t\tprevS[i] = prevS[i - 1];\n\t\t}\n\t\telse{\n\t\t\tprevN[i] = prevN[i - 1];\n\t\t\tprevS[i] = i;\n\t\t}\n\t}\n\tfor(int q = 0; q < Q; q++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x[5], y[5];\n\t\tx[1] = min(a, c);\n\t\tx[3] = max(a, c);\n\t\ty[1] = min(b, d);\n\t\ty[3] = max(b, d);\n\n\t\tif(S[x[1]] == 'W'){\n\t\t\tx[0] = prevE[x[1] - 1];\n\t\t\tx[2] = min(x[3], nextE[x[1] + 1]);\n\t\t}\n\t\telse{\n\t\t\tx[0] = prevW[x[1] - 1];\n\t\t\tx[2] = min(x[3], nextW[x[1] + 1]);\n\t\t}\n\t\tif(x[0] == 0){\n\t\t\tx[0] = x[1];\n\t\t}\n\t\tif(S[x[3]] == 'W'){\n\t\t\tx[4] = nextE[x[3] + 1];\n\t\t}\n\t\telse{\n\t\t\tx[4] = nextW[x[3] + 1];\n\t\t}\n\t\tif(x[4] == N + 1){\n\t\t\tx[4] = x[3];\n\t\t}\n\n\t\tif(T[y[1]] == 'N'){\n\t\t\ty[0] = prevS[y[1] - 1];\n\t\t\ty[2] = min(y[3], nextS[y[1] + 1]);\n\t\t}\n\t\telse{\n\t\t\ty[0] = prevN[y[1] - 1];\n\t\t\ty[2] = min(y[3], nextN[y[1] + 1]);\n\t\t}\n\t\tif(y[0] == 0){\n\t\t\ty[0] = y[1];\n\t\t}\n\t\tif(T[y[3]] == 'N'){\n\t\t\ty[4] = nextS[y[3] + 1];\n\t\t}\n\t\telse{\n\t\t\ty[4] = nextN[y[3] + 1];\n\t\t}\n\t\tif(y[4] == M + 1){\n\t\t\ty[4] = y[3];\n\t\t}\n\n/*\t\tprintf(\"x:\");\n\t\tfor(i = 0; i < 5; i++){\n\t\t\tprintf(\"%d \", x[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"y:\");\n\t\tfor(i = 0; i < 5; i++){\n\t\t\tprintf(\"%d \", y[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n*/\n\t\tvector<vector<edge> > g(25, vector<edge>());\n\t\tfor(i = 0; i < 5; i++){\n\t\t\tif(S[x[i]] == 'W'){\n\t\t\t\tfor(j = 1; j < 5; j++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i, j - 1), y[j] - y[j - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j = 0; j < 4; j++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i, j + 1), y[j + 1] - y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(j = 0; j < 5; j++){\n\t\t\tif(T[y[j]] == 'N'){\n\t\t\t\tfor(i = 1; i < 5; i++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i - 1, j), x[i] - x[i - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i = 0; i < 4; i++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i + 1, j), x[i + 1] - x[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s, t;\n\t\tfor(i = 0; i < 25; i++){\n\t\t\tif(x[i / 5] == a && y[i % 5] == b){\n\t\t\t\ts = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < 25; i++){\n\t\t\tif(x[i / 5] == c && y[i % 5] == d){\n\t\t\t\tt = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n/*\t\tfor(i = 0; i < 25; i++){\n\t\t\tprintf(\"edge[%d]:\", i);\n\t\t\tfor(j = 0; j < g[i].size(); j++){\n\t\t\t\tprintf(\"(%d, %d) \", g[i][j].to, g[i][j].cost);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"(s, t) = (%d, %d)\\n\", s, t);\n*/\t\tvector<int> res = dijkstra(g, s);\n\t\tif(res[t] == inf){\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\", res[t]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\nint m;\n\nchar buf[MAX];\nstring s;\nstring t;\n\nint q;\n\nvector<int> row[2];\nvector<int> col[2];\n\nvector<int> R;\nvector<int> C;\n\nvoid row_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(row[i].begin(), row[i].end(), y) - row[i].begin();\n\t\tif (id != row[i].size()) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != row[i].size() && row[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != row[i].size()) {\n\t\t\t\tR.push_back(row[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid col_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(col[i].begin(), col[i].end(), y) - col[i].begin();\n\t\tif (id != col[i].size()) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != col[i].size() && col[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != col[i].size()) {\n\t\t\t\tC.push_back(col[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dist[8][8];\n\n\nint main() {\n\tcin >> n>>m>>q;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tscanf(\"%s\", buf);\n\tt = buf;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == 'W') {\n\t\t\trow[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\trow[1].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'N') {\n\t\t\tcol[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tcol[1].push_back(i);\n\t\t}\n\t}\n\twhile (q--) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\ta--;\n\t\tb--;\n\t\tc--;\n\t\td--;\n\t\tR.clear();\n\t\tC.clear();\n\t\trow_ava(a);\n\t\trow_ava(c);\n\t\tcol_ava(b);\n\t\tcol_ava(d);\n\t\tsort(R.begin(), R.end());\n\t\tR.erase(unique(R.begin(), R.end()),R.end());\n\t\tsort(C.begin(), C.end());\n\t\tC.erase(unique(C.begin(), C.end()),C.end());\n\t\tpair<int, int> star = make_pair(-1, -1);\n\t\tpair<int, int> en = make_pair(-1, -1);\n\t\tfor (int i = 0; i < R.size(); i++) {\n\t\t\tfor (int j = 0; j < C.size(); j++) {\n\t\t\t\tdist[i][j] = -1;\n\t\t\t\tif (R[i] == a && C[j] == b) {\n\t\t\t\t\tstar = make_pair(i, j);\n\t\t\t\t}\n\t\t\t\tif (R[i] == c && C[j] == d) {\n\t\t\t\t\ten = make_pair(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist[star.first][star.second] = 0;\n\t\tpriority_queue<pair<int,pair<int, int> >,vector<pair<int, pair<int, int> > > , greater<pair<int, pair<int, int> > > > q;\n\t\tq.push(make_pair(0,make_pair(star.first, star.second)));\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.top().second.first;\n\t\t\tint y = q.top().second.second;\n\t\t\tint est = q.top().first;\n\t\t\tq.pop();\n\t\t\tint ds = dist[x][y];\n\t\t\tif (ds != est)continue;\n\t\t\tif (s[R[x]] == 'W') {\n\t\t\t\tif (y) {\n\t\t\t\t\tint nex = (C[y] - C[y - 1]) + ds;\n\t\t\t\t\tif (dist[x][y-1]==-1||dist[x][y - 1] > nex) {\n\t\t\t\t\t\tdist[x][y - 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex,make_pair(x, y - 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[R[x]] == 'E') {\n\t\t\t\tif (y+1<C.size()) {\n\t\t\t\t\tint nex = (C[y+1] - C[y]) + ds;\n\t\t\t\t\tif (dist[x][y + 1] == -1 || dist[x][y +1] > nex) {\n\t\t\t\t\t\tdist[x][y + 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x, y + 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'N') {\n\t\t\t\tif (x) {\n\t\t\t\t\tint nex = (R[x] - R[x - 1]) + ds;\n\t\t\t\t\tif (dist[x - 1][y] == -1 || dist[x - 1][y] > nex) {\n\t\t\t\t\t\tdist[x - 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x - 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'S') {\n\t\t\t\tif (x+1<R.size()) {\n\t\t\t\t\tint nex = (R[x+1] - R[x]) + ds;\n\t\t\t\t\tif (dist[x + 1][y] == -1 || dist[x + 1][y] > nex) {\n\t\t\t\t\t\tdist[x + 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x + 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dist[en.first][en.second]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nstruct handler{\n    typedef pii val_t;\n    typedef int opr_t;\n    handler(){}\n    val_t def_val(){ return pii(MOD, -MOD); }\n    static val_t update(const val_t &l, const opr_t &r){\n        return pii(r, r);\n    }\n    static val_t merge(const val_t &l, const val_t &r){\n        return pii(min(l.first, r.first), max(l.second, r.second));\n    }\n};\n\ntemplate<typename Handler>\nstruct SegTree{\n    typedef typename Handler::val_t val_t;\n    typedef typename Handler::opr_t opr_t;\n    vector<val_t> val;\n    Handler hdl;\n    int n;\n\n    SegTree(int size = 0):hdl(){\n        n=1;\n        while(n<size) n<<=1;\n        val=vector<val_t>(2*n, hdl.def_val());\n    }\n    SegTree(const vector<val_t> &in):hdl(){\n        n=1;\n        while(n<in.size()) n<<=1;\n        val=vector<val_t>(2*n, hdl.def_val());\n        for(int i=n-1 + in.size()-1;i>=0;i--){\n            if(n-1 <= i) val[i] = in[i - (n-1)];\n            else val[i] = hdl.merge(val[i*2+1],val[i*2+2]);\n        }\n    }\n    void update(int i, const opr_t& a){\n        i += n-1;\n        val[i] = hdl.update(val[i], a);\n        while(i > 0){\n            i = (i-1)/2;\n            val[i] = hdl.merge(val[i*2+1],val[i*2+2]);\n        }\n    }\n    val_t query(int a,int b,int k,int l,int r){\n        if(r<=a||b<=l) return hdl.def_val();\n        if(a<=l&&r<=b) return val[k];\n        return hdl.merge(query(a, b, k*2+1, l, (l+r)/2),\n                         query(a, b, k*2+2, (l+r)/2, r)\n        );\n    }\n    val_t query(int a, int b){return query(a, b, 0, 0, n);}\n    val_t operator[](size_t i){return query(i, i+1);}\n    friend ostream& operator<<(ostream &os, SegTree<Handler> &t){\n        REP(i, t.n) os << (i ? \", \" : \"[\") << t.query(i, i+1);\n        return os << \"]\";\n    }\n};\n\n\nint T, n, m, q;\nstring s, t;\nSegTree<handler> segE, segW, segN, segS;\n\nint solve2(int sy, int sx, int gy, int gx) {\n    int mi = MOD;\n    {\n        int ans = 0;\n        if (sx <= gx && s[sy] == 'E') ans += gx - sx;\n        else if (sx >= gx && s[sy] == 'W') ans += sx - gx;\n        else ans += MOD;\n        if (sy <= gy && t[gx] == 'S') ans += gy - sy;\n        else if (sy >= gy && t[gx] == 'N') ans += sy - gy;\n        else ans += MOD;\n        mi = min(mi, ans);\n    }\n    {\n        int ans = 0;\n        if (sx <= gx && s[gy] == 'E') ans += gx - sx;\n        else if (sx >= gx && s[gy] == 'W') ans += sx - gx;\n        else ans += MOD;\n        if (sy <= gy && t[sx] == 'S') ans += gy - sy;\n        else if (sy >= gy && t[sx] == 'N') ans += sy - gy;\n        else ans += MOD;\n        mi = min(mi, ans);\n    }\n\n    return mi;\n}\n\nint solve(int sy, int sx, int gy, int gx, int step);\n\nint solve3(int sy, int sx, int gy, int gx, int d1, int step) {\n    int p;\n    int ans = MOD;\n    if (d1 == 0) {\n        if (t[sx] != 'N') return MOD;\n        p = segE.query(0, min(sy, gy) + 1).second;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n        p = segW.query(0, min(sy, gy) + 1).second;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n    }\n    if (d1 == 2) {\n        if (t[sx] != 'S') return MOD;\n        p = segE.query(max(sy, gy), n).first;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n        p = segW.query(max(sy, gy), n).first;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n    }\n    if (d1 == 1) {\n        if (s[sy] != 'E') return MOD;\n        p = segN.query(max(sx, gx), m).first;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n        p = segS.query(max(sx, gx), m).first;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n    }\n    if (d1 == 3) {\n        if (s[sy] != 'W') return MOD;\n        p = segN.query(0, min(sx, gx)).second;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n        p = segS.query(0, min(sx, gx)).second;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n    }\n    return ans;\n}\n\nint solve(int sy, int sx, int gy, int gx, int step = 4) {\n    if (sx < 0 || sy < 0 || n <= sy || m <= sx) return MOD;\n    int ans = solve2(sy, sx, gy, gx);\n//    cout << \"solve \" << sy << \", \" << sx << \": \" << ans << endl;\n    if (step > 0) {\n        REP(i, 4) {\n            ans = min(ans, solve3(sy, sx, gy, gx, i, step - 1));\n        }\n    }\n    return ans;\n}\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> m >> q >> s >> t){\n        segE = SegTree<handler>(n);\n        segW = SegTree<handler>(n);\n        REP(i, n) {\n            if (s[i] == 'E') segE.update(i, i);\n            if (s[i] == 'W') segW.update(i, i);\n        }\n        segN = SegTree<handler>(m);\n        segS = SegTree<handler>(m);\n        REP(i, m) {\n            if (t[i] == 'N') segN.update(i, i);\n            if (t[i] == 'S') segS.update(i, i);\n        }\n        REP(i, q) {\n            int sy, sx, gy, gx;\n            cin >> sy >> sx >> gy >> gx; sx --; sy --; gx --; gy--;\n            int ans = solve(sy, sx, gy, gx);\n            cout << (ans >= MOD ? -1 : ans) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long long int exa = 1000000000000000000;\n//const int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, turn, dis;\n\tNode(int a, int b, int c = 0, int d = 0) {\n\t\ty = a, x = b;\n\t\tturn = c;\n\t\tdis = d;\n\t}\n};\n\nint border = 4;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int>ldif(W, -1);\n\tvector<int>rdif(W, -1);\n\tfor (int i = 1; i < W; i++) {\n\t\tif (t[i] == t[i - 1])ldif[i] = ldif[i - 1];\n\t\telse ldif[i] = i - 1;\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (t[i] == t[i + 1])rdif[i] = rdif[i + 1];\n\t\telse rdif[i] = i + 1;\n\t}\n\tvector<int>udif(H, -1);\n\tvector<int>ddif(H, -1);\n\tfor (int i = 1; i < H; i++) {\n\t\tif (s[i] == s[i - 1])udif[i] = udif[i - 1];\n\t\telse udif[i] = i - 1;\n\t}\n\tfor (int i = H - 2; i >= 0; i--) {\n\t\tif (s[i] == s[i + 1])ddif[i] = ddif[i + 1];\n\t\telse ddif[i] = i + 1;\n\t}\n\tvector<int>ret;\n\tfor (int i = 0; i < K; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\ta--, b--, c--, d--;\n\t\tqueue<Node>Q;\n\t\tQ.push(Node(a, b));\n\t\tint ans = MOD;\n\t\twhile (!Q.empty()) {\n\t\t\tauto cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (cn.y == c && cn.x == d) {\n\t\t\t\tans = min(ans, cn.dis);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cn.turn == border)break;\n\t\t\tif (t[cn.x] == 'N') {//(-,0)\n\t\t\t\tif (c <= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(c - cn.y) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (udif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push({ Node(udif[cn.y],cn.x,cn.turn + 1,cn.dis + cn.y - udif[cn.y]) });\n\t\t\t\t\t}\n\t\t\t\t\tif (udif[c] != -1&&udif[c]!=udif[cn.y]) {\n\t\t\t\t\t\tQ.push(Node(udif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - udif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c >= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(c - cn.y) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ddif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[cn.y], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[cn.y])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ddif[c] != -1 && ddif[c] != ddif[cn.y]) {\n\t\t\t\t\t\tQ.push(Node(ddif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[cn.y] == 'W') {\n\t\t\t\tif (d <= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(d - cn.x) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ldif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - ldif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ldif[d] != -1&&ldif[d]!=ldif[cn.x]) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[d], cn.turn + 1, cn.dis + abs(cn.x - ldif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d >= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(d - cn.x) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (rdif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - rdif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (rdif[d] != -1&&rdif[d]!=rdif[cn.x]) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[d], cn.turn + 1, cn.dis + abs(cn.x - rdif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == MOD)ans = -1;\n\t\tret.push_back(ans);\n\t}\n\tfor (auto i : ret)cout << i << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\nconst int inf=1<<30;\n\nint h,w,q;\nstring s,t;\nvi a,b,c[4];\n\nint f(int x,int y,int X,int Y,bool fx=1,bool fy=1){\n\tint I=a[x],J=b[y];\n\tbool bx=0,by=0;\n\tif(I==1&&Y<=y||I==3&&y<=Y) bx=1;\n\tif(J==0&&X<=x||J==2&&x<=X) by=1;\n\tif(bx&&by){\n\t\tif(I==a[X]||J==b[Y]) return abs(x-X)+abs(y-Y);\n\t\tauto ix=lower_bound(c[I].begin(),c[I].end(),X);\n\t\tauto iy=lower_bound(c[J].begin(),c[J].end(),Y);\n\t\tif(J==0) ix--;\n\t\tif(I==1) iy--;\n\t\tint tx=(0<=*ix&&*ix<h?abs(*ix-x)+abs(*ix-X)+abs(y-Y):inf);\n\t\tint ty=(0<=*iy&&*iy<w?abs(*iy-y)+abs(*iy-Y)+abs(x-X):inf);\n\t\treturn min(tx,ty);\n\t}\n\tauto ix=lower_bound(c[(I+2)%4].begin(),c[(I+2)%4].end(),x);\n\tauto iy=lower_bound(c[(J+2)%4].begin(),c[(J+2)%4].end(),y);\n\tif(J==0) ix--;\n\tif(I==1) iy--;\n\tint tx=(fx&&0<=*ix&&*ix<h?f(*ix,y,X,Y,0,1)+abs(*ix-x):inf);\n\tint ty=(fy&&0<=*iy&&*iy<w?f(x,*iy,X,Y,1,0)+abs(*iy-y):inf);\n\treturn min(tx,ty);\n}\n\nint main(){\n\tcin>>h>>w>>q>>s>>t;\n\ta=vi(h,1);\n\tb=vi(w);\n\tfor(int i=0;i<4;i++) c[i].push_back(-1);\n\tfor(int i=0;i<h;i++){\n\t\tif(s[i]=='E') a[i]=3;\n\t\tc[a[i]].push_back(i);\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tif(t[i]=='S') b[i]=2;\n\t\tc[b[i]].push_back(i);\n\t}\n\tfor(int i=0;i<4;i++) c[i].push_back(inf);\n\tfor(int i=0;i<q;i++){\n\t\tint x,y,X,Y;\n\t\tcin>>x>>y>>X>>Y;\n\t\tint res=f(x-1,y-1,X-1,Y-1);\n\t\tcout<<(res>=inf?-1:res)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nvector<P> nullvP;\n\nstruct Graph{\n\tint V;\n\tvector<vector<P>> G;\n\tvoid init(int _V){\n\t\tV = _V;\n\t\tG.clear();\n\t\trep(i,V+1){\n\t\t\tG.pb(nullvP);\n\t\t}\n\t}\n\tvoid add_edge(int a,int b,int w = 1){\n\t\tG[a].pb(P(b,w));\n\t\t//G[b].pb(P(a,w));\n\t}\n\tint dijkstra(int s,int t){\n\t\tvector<int> used;\n\t\tvector<int> dist;\n\t\tpriority_queue<P,vector<P>,greater<P>> que;\n\t\trep(i,V+1){\n\t\t\tused.pb(0);\n\t\t\tdist.pb(INF);\n\t\t}\n\t\tdist[s] = 0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif(used[p.sc])continue;\n\t\t\tused[p.sc] = true;\n\t\t\tfor(P ed: G[p.sc]){\n\t\t\t\tif(dist[ed.fr] > dist[p.sc]+ed.sc){\n\t\t\t\t\tdist[ed.fr] = dist[p.sc]+ed.sc;\n\t\t\t\t\tque.push(P(dist[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist[t];\n\t}\n}G;\n\nint main(){\n\tstatic int n,m,q;\n\tstatic string s,t;\n\t//static int a[200010],b[200010],c[200010],d[200010];\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tcin >> s >> t;\n\t/*rep1(i,q){\n\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t}*/\n\t\n\tstatic int lw[100010],rw[100010],le[100010],re[100010];\n\tstatic int ln[100010],rn[100010],ls[100010],rs[100010];\n\tlw[0] = le[0] = 0;\n\trep1(i,n){\n\t\tlw[i] = lw[i-1];\n\t\tle[i] = le[i-1];\n\t\tif(s[i-1] == 'W')lw[i] = i;\n\t\telse le[i] = i;\n\t}\n\tln[0] = ls[0] = 0;\n\trep1(i,m){\n\t\tln[i] = ln[i-1];\n\t\tls[i] = ls[i-1];\n\t\tif(t[i-1] == 'N')ln[i] = i;\n\t\telse ls[i] = i;\n\t}\n\trw[n+1] = re[n+1] = n+1;\n\trrep1(i,n){\n\t\trw[i] = rw[i+1];\n\t\tre[i] = re[i+1];\n\t\tif(s[i-1] == 'W')rw[i] = i;\n\t\telse re[i] = i;\n\t}\n\trn[m+1] = rs[m+1] = m+1;\n\trrep1(i,m){\n\t\trn[i] = rn[i+1];\n\t\trs[i] = rs[i+1];\n\t\tif(t[i-1] == 'N')rn[i] = i;\n\t\telse rs[i] = i;\n\t}\n\t\n\t//rep1(i,n)cout << lw[i] << \" \" << rw[i] << \" \" << le[i] << \" \" << re[i] << endl;\n\t//rep1(i,m)cout << ln[i] << \" \" << rn[i] << \" \" << ls[i] << \" \" << rs[i] << endl;\n\t\n\trep1(loop,q){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tvector<int> X,Y;\n\t\tX.pb(a); X.pb(c);\n\t\tif(s[a-1] == 'E'){\n\t\t\tif(lw[a] != 0)X.pb(lw[a]);\n\t\t\tif(rw[a] != n+1)X.pb(rw[a]);\n\t\t}\n\t\telse {\n\t\t\tif(le[a] != 0)X.pb(le[a]);\n\t\t\tif(re[a] != n+1)X.pb(re[a]);\n\t\t}\n\t\tif(s[c-1] == 'E'){\n\t\t\tif(lw[c] != 0)X.pb(lw[c]);\n\t\t\tif(rw[c] != n+1)X.pb(rw[c]);\n\t\t}\n\t\telse {\n\t\t\tif(le[c] != 0)X.pb(le[c]);\n\t\t\tif(re[c] != n+1)X.pb(re[c]);\n\t\t}\n\t\tY.pb(b); Y.pb(d);\n\t\tif(t[b-1] == 'S'){\n\t\t\tif(ln[b] != 0)Y.pb(ln[b]);\n\t\t\tif(rn[b] != m+1)Y.pb(rn[b]);\n\t\t}\n\t\telse {\n\t\t\tif(ls[b] != 0)Y.pb(ls[b]);\n\t\t\tif(rs[b] != m+1)Y.pb(rs[b]);\n\t\t}\n\t\tif(t[d-1] == 'S'){\n\t\t\tif(ln[d] != 0)Y.pb(ln[d]);\n\t\t\tif(rn[d] != m+1)Y.pb(rn[d]);\n\t\t}\n\t\telse {\n\t\t\tif(ls[d] != 0)Y.pb(ls[d]);\n\t\t\tif(rs[d] != m+1)Y.pb(rs[d]);\n\t\t}\n\t\tsor(X); uniq(X);\n\t\tsor(Y); uniq(Y);\n\t\t\n\t\t/*cout << \"X:\";\n\t\tfor(int i: X)cout << i << \" \";\n\t\tcout << endl;\n\t\tcout << \"Y:\";\n\t\tfor(int i: Y)cout << i << \" \";\n\t\tcout << endl;*/\n\t\t\n\t\tint _a = lower_bound(X.begin(),X.end(),a)-X.begin();\n\t\tint _b = lower_bound(Y.begin(),Y.end(),b)-Y.begin();\n\t\tint _c = lower_bound(X.begin(),X.end(),c)-X.begin();\n\t\tint _d = lower_bound(Y.begin(),Y.end(),d)-Y.begin();\n\t\tG.init(X.size()*Y.size());\n\t\trep(i,X.size())rep(j,Y.size())for(int k = j+1 ; k < Y.size() ; k ++){\n\t\t\tif(s[X[i]-1] == 'W')G.add_edge(i*Y.size()+k,i*Y.size()+j,Y[k]-Y[j]);\n\t\t\telse G.add_edge(i*Y.size()+j,i*Y.size()+k,Y[k]-Y[j]);\n\t\t}\n\t\trep(i,X.size())for(int j = i+1 ; j < X.size() ; j ++)rep(k,Y.size()){\n\t\t\tif(t[Y[k]-1] == 'N')G.add_edge(j*Y.size()+k,i*Y.size()+k,X[j]-X[i]);\n\t\t\telse G.add_edge(i*Y.size()+k,j*Y.size()+k,X[j]-X[i]);\n\t\t}\n\t\tint ret = G.dijkstra(_a*Y.size()+_b,_c*Y.size()+_d);\n\t\tif(ret >= INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\",ret);\n\t\t//printf(\"%d\\n\",G.dijkstra(_a*Y.size()+_b,_c*Y.size()+_d));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n \n#define MAX 100002\n \nint n;\nint m;\n \nchar buf[MAX];\nstring s;\nstring t;\n \nint qq;\n \nvector<int> row[2];\nvector<int> col[2];\n \nvector<int> R;\nvector<int> C;\n \nvoid row_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(row[i].begin(), row[i].end(), y) - row[i].begin();\n\t\tif (id != row[i].size()) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != row[i].size() && row[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != row[i].size()) {\n\t\t\t\tR.push_back(row[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid col_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(col[i].begin(), col[i].end(), y) - col[i].begin();\n\t\tif (id != col[i].size()) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != col[i].size() && col[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != col[i].size()) {\n\t\t\t\tC.push_back(col[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\n \nint dist[8][8];\n priority_queue<pair<int,pair<int, int> >,vector<pair<int, pair<int, int> > > , greater<pair<int, pair<int, int> > > > q;\n \nint main() {\n\tcin >> n>>m>>qq;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tscanf(\"%s\", buf);\n\tt = buf;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == 'W') {\n\t\t\trow[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\trow[1].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'N') {\n\t\t\tcol[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tcol[1].push_back(i);\n\t\t}\n\t}\n\twhile (qq--) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\ta--;\n\t\tb--;\n\t\tc--;\n\t\td--;\n\t\tR.clear();\n\t\tC.clear();\n\t\trow_ava(a);\n\t\trow_ava(c);\n\t\tcol_ava(b);\n\t\tcol_ava(d);\n\t\tsort(R.begin(), R.end());\n\t\tR.erase(unique(R.begin(), R.end()),R.end());\n\t\tsort(C.begin(), C.end());\n\t\tC.erase(unique(C.begin(), C.end()),C.end());\n\t\tpair<int, int> star = make_pair(-1, -1);\n\t\tpair<int, int> en = make_pair(-1, -1);\n\t\tfor (int i = 0; i < R.size(); i++) {\n\t\t\tfor (int j = 0; j < C.size(); j++) {\n\t\t\t\tdist[i][j] = -1;\n\t\t\t\tif (R[i] == a && C[j] == b) {\n\t\t\t\t\tstar = make_pair(i, j);\n\t\t\t\t}\n\t\t\t\tif (R[i] == c && C[j] == d) {\n\t\t\t\t\ten = make_pair(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist[star.first][star.second] = 0;\n\t\t\n\t\tq.push(make_pair(0,make_pair(star.first, star.second)));\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.top().second.first;\n\t\t\tint y = q.top().second.second;\n\t\t\tint est = q.top().first;\n\t\t\tq.pop();\n\t\t\tint ds = dist[x][y];\n\t\t\tif (ds != est)continue;\n\t\t\tif (s[R[x]] == 'W') {\n\t\t\t\tif (y) {\n\t\t\t\t\tint nex = (C[y] - C[y - 1]) + ds;\n\t\t\t\t\tif (dist[x][y-1]==-1||dist[x][y - 1] > nex) {\n\t\t\t\t\t\tdist[x][y - 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex,make_pair(x, y - 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[R[x]] == 'E') {\n\t\t\t\tif (y+1<C.size()) {\n\t\t\t\t\tint nex = (C[y+1] - C[y]) + ds;\n\t\t\t\t\tif (dist[x][y + 1] == -1 || dist[x][y +1] > nex) {\n\t\t\t\t\t\tdist[x][y + 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x, y + 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'N') {\n\t\t\t\tif (x) {\n\t\t\t\t\tint nex = (R[x] - R[x - 1]) + ds;\n\t\t\t\t\tif (dist[x - 1][y] == -1 || dist[x - 1][y] > nex) {\n\t\t\t\t\t\tdist[x - 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x - 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'S') {\n\t\t\t\tif (x+1<R.size()) {\n\t\t\t\t\tint nex = (R[x+1] - R[x]) + ds;\n\t\t\t\t\tif (dist[x + 1][y] == -1 || dist[x + 1][y] > nex) {\n\t\t\t\t\t\tdist[x + 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x + 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dist[en.first][en.second]);\n\t}\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 100000000000000000\n\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[100005], prer[100005], nextl[100005], nextr[100005];\nllint preu[100005], pred[100005], nextu[100005], nextd[100005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\t//if(vec.front() == 0) vec.erase(vec.begin());\n\t//if(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 1, prer[0] = 1;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i] == 'W') prel[i] = i;\n\t\tif(s[i] == 'E') prer[i] = i;\n\t}\n\tnextl[H+1] = H, nextr[H+1] = H;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i] == 'W') nextl[i] = i;\n\t\tif(s[i] == 'E') nextr[i] = i;\n\t}\n\t\n\tpreu[0] = 1, pred[0] = 1;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i] == 'N') preu[i] = i;\n\t\tif(t[i] == 'S') pred[i] = i;\n\t}\n\tnextl[W+1] = W, nextr[W+1] = W;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i] == 'N') nextu[i] = i;\n\t\tif(t[i] == 'S') nextd[i] = i;\n\t}\n\t\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, M, Q; string S, T;\nvector<int>X1, X2, Y1, Y2;\nvector<int>needX[100009], needY[100009];\n\nvoid get_x() {\n\tfor (int i = 0; i < N; i++) {\n\t\tif (S[i] == 'E') {\n\t\t\tneedX[i].push_back(i);\n\t\t\tint pos1 = lower_bound(X2.begin(), X2.end(), i) - X2.begin(); pos1--;\n\t\t\tint pos2 = pos1 + 1;\n\n\t\t\tif (pos1 >= 0 && pos1 < X2.size()) {\n\t\t\t\tneedX[i].push_back(X2[pos1]);\n\t\t\t\tint pos3 = lower_bound(X1.begin(), X1.end(), X2[pos1]) - X1.begin(); pos3--;\n\t\t\t\tif (pos3 >= 0) needX[i].push_back(X1[pos3]);\n\t\t\t}\n\t\t\tif (pos2 >= 0 && pos2 < X2.size()) {\n\t\t\t\tneedX[i].push_back(X2[pos2]);\n\t\t\t\tint pos3 = lower_bound(X1.begin(), X1.end(), X2[pos2]) - X1.begin();\n\t\t\t\tif (pos3 < X1.size()) needX[i].push_back(X1[pos3]);\n\t\t\t}\n\t\t}\n\t\tif (S[i] == 'W') {\n\t\t\tneedX[i].push_back(i);\n\t\t\tint pos1 = lower_bound(X1.begin(), X1.end(), i) - X1.begin(); pos1--;\n\t\t\tint pos2 = pos1 + 1;\n\n\t\t\tif (pos1 >= 0 && pos1 < X1.size()) {\n\t\t\t\tneedX[i].push_back(X1[pos1]);\n\t\t\t\tint pos3 = lower_bound(X2.begin(), X2.end(), X1[pos1]) - X2.begin(); pos3--;\n\t\t\t\tif (pos3 >= 0) needX[i].push_back(X2[pos3]);\n\t\t\t}\n\t\t\tif (pos2 >= 0 && pos2 < X1.size()) {\n\t\t\t\tneedX[i].push_back(X1[pos2]);\n\t\t\t\tint pos3 = lower_bound(X2.begin(), X2.end(), X1[pos2]) - X2.begin();\n\t\t\t\tif (pos3 < X2.size()) needX[i].push_back(X2[pos3]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid get_y() {\n\tfor (int i = 0; i < M; i++) {\n\t\tif (T[i] == 'N') {\n\t\t\tneedY[i].push_back(i);\n\t\t\tint pos1 = lower_bound(Y2.begin(), Y2.end(), i) - Y2.begin(); pos1--;\n\t\t\tint pos2 = pos1 + 1;\n\n\t\t\tif (pos1 >= 0 && pos1 < Y2.size()) {\n\t\t\t\tneedY[i].push_back(Y2[pos1]);\n\t\t\t\tint pos3 = lower_bound(Y1.begin(), Y1.end(), Y2[pos1]) - Y1.begin(); pos3--;\n\t\t\t\tif (pos3 >= 0) needY[i].push_back(Y1[pos3]);\n\t\t\t}\n\t\t\tif (pos2 >= 0 && pos2 < Y2.size()) {\n\t\t\t\tneedY[i].push_back(Y2[pos2]);\n\t\t\t\tint pos3 = lower_bound(Y1.begin(), Y1.end(), Y2[pos2]) - Y1.begin();\n\t\t\t\tif (pos3 < Y1.size()) needY[i].push_back(Y1[pos3]);\n\t\t\t}\n\t\t}\n\t\tif (T[i] == 'S') {\n\t\t\tneedY[i].push_back(i);\n\t\t\tint pos1 = lower_bound(Y1.begin(), Y1.end(), i) - Y1.begin(); pos1--;\n\t\t\tint pos2 = pos1 + 1;\n\n\t\t\tif (pos1 >= 0 && pos1 < Y1.size()) {\n\t\t\t\tneedY[i].push_back(Y1[pos1]);\n\t\t\t\tint pos3 = lower_bound(Y2.begin(), Y2.end(), Y1[pos1]) - Y2.begin(); pos3--;\n\t\t\t\tif (pos3 >= 0) needY[i].push_back(Y2[pos3]);\n\t\t\t}\n\t\t\tif (pos2 >= 0 && pos2 < Y1.size()) {\n\t\t\t\tneedY[i].push_back(Y1[pos2]);\n\t\t\t\tint pos3 = lower_bound(Y2.begin(), Y2.end(), Y1[pos2]) - Y2.begin();\n\t\t\t\tif (pos3 < Y2.size()) needY[i].push_back(Y2[pos3]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nchar u[10], v[10]; int dist[10][10];\n\nint solve(int ax, int ay, int bx, int by) {\n\tvector<int>X, Y;\n\tfor (int i : needX[ax]) X.push_back(i);\n\tfor (int i : needX[bx]) X.push_back(i);\n\tfor (int i : needY[ay]) Y.push_back(i);\n\tfor (int i : needY[by]) Y.push_back(i);\n\tsort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n\tsort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n\n\tfor (int i = 0; i < X.size(); i++) u[i] = S[X[i]];\n\tfor (int i = 0; i < Y.size(); i++) v[i] = T[Y[i]];\n\n\tfor (int i = 0; i < 10; i++) { for (int j = 0; j < 10; j++) dist[i][j] = (1 << 30); }\n\n\tint sx = lower_bound(X.begin(), X.end(), ax) - X.begin();\n\tint sy = lower_bound(Y.begin(), Y.end(), ay) - Y.begin();\n\tint gx = lower_bound(X.begin(), X.end(), bx) - X.begin();\n\tint gy = lower_bound(Y.begin(), Y.end(), by) - Y.begin();\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>que;\n\tdist[sx][sy] = 0; que.push(make_pair(0, sx * 16 + sy));\n\n\twhile (!que.empty()) {\n\t\tint G = que.top().second; que.pop();\n\t\tint lx = (G >> 4), ly = (G & 15);\n\n\t\t// EW 方面\n\t\tif (u[lx] == 'E') {\n\t\t\tif (ly + 1 < Y.size() && dist[lx][ly + 1] > dist[lx][ly] + (Y[ly + 1] - Y[ly])) {\n\t\t\t\tdist[lx][ly + 1] = dist[lx][ly] + (Y[ly + 1] - Y[ly]);\n\t\t\t\tque.push(make_pair(dist[lx][ly + 1], G + 1));\n\t\t\t}\n\t\t}\n\t\tif (u[lx] == 'W') {\n\t\t\tif (ly > 0 && dist[lx][ly - 1] > dist[lx][ly] + (Y[ly] - Y[ly - 1])) {\n\t\t\t\tdist[lx][ly - 1] = dist[lx][ly] + (Y[ly] - Y[ly - 1]);\n\t\t\t\tque.push(make_pair(dist[lx][ly - 1], G - 1));\n\t\t\t}\n\t\t}\n\n\t\t// NS 方面\n\t\tif (v[ly] == 'N') {\n\t\t\tif (lx > 0 && dist[lx - 1][ly] > dist[lx][ly] + (X[lx] - X[lx - 1])) {\n\t\t\t\tdist[lx - 1][ly] = dist[lx][ly] + (X[lx] - X[lx - 1]);\n\t\t\t\tque.push(make_pair(dist[lx - 1][ly], G - 16));\n\t\t\t}\n\t\t}\n\t\tif (v[ly] == 'S') {\n\t\t\tif (lx + 1 < X.size() && dist[lx + 1][ly] > dist[lx][ly] + (X[lx + 1] - X[lx])) {\n\t\t\t\tdist[lx + 1][ly] = dist[lx][ly] + (X[lx + 1] - X[lx]);\n\t\t\t\tque.push(make_pair(dist[lx + 1][ly], G + 16));\n\t\t\t}\n\t\t}\n\t}\n\tif (dist[gx][gy] == (1 << 30)) return -1;\n\treturn dist[gx][gy];\n}\n\nint main() {\n\tcin >> N >> M >> Q;\n\tcin >> S >> T;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == 'E') X1.push_back(i);\n\t\tif (S[i] == 'W') X2.push_back(i);\n\t}\n\tfor (int i = 0; i < T.size(); i++) {\n\t\tif (T[i] == 'N') Y1.push_back(i);\n\t\tif (T[i] == 'S') Y2.push_back(i);\n\t}\n\t\n\tget_x();\n\tget_y();\n\n\tfor (int i = 1; i <= Q; i++) {\n\t\tint ax, ay, bx, by;\n\t\tscanf(\"%d%d%d%d\", &ax, &ay, &bx, &by);\n\t\tax--; ay--; bx--; by--;\n\t\tprintf(\"%d\\n\", solve(ax, ay, bx, by));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint H, W;\nvector<int> S;\nvector<int> T;\nvector<int> ans;\nint P[100000];\nint Q[100000];\nint R[100000];\n\nconst int BIG = 10000000;\nint sub(PP a, PP b) {\n\tif (a.second > b.second) return BIG;\n\tint mni = min(a.first, b.first);\n\tint mnj = min(a.second, b.second);\n\tint mxj = max(a.second, b.second);\n\n\tint tmp_l = a.second - Q[mnj];\n\tint tmp_r = R[mxj] - b.second;\n\n\tint left = S[a.first] == 1 ? BIG : 2 * tmp_l;\n\tif (tmp_l == 0 || a.first == P[mni]) left = 0;\n\n\tint right = S[b.first] == 1 ? BIG : 2 * tmp_r;\n\tif (tmp_r == 0 || b.first == P[mni]) right = 0;\n\n\tint up = (a.first + b.first - 2 * P[mni]);\n\treturn left + up + right + (b.second - a.second);\n}\n\nvoid pre() {\n\t{\n\t\tint curr = -BIG;\n\t\tREP(i, 0, H + 1) {\n\t\t\tif (S[i]) curr = i;\n\t\t\tP[i] = curr;\n\t\t}\n\t}\n\t{\n\t\tint curr = -BIG;\n\t\tREP(j, 0, W + 1) {\n\t\t\tif (!T[j]) curr = j;\n\t\t\tQ[j] = curr;\n\t\t}\n\t}\n\t{\n\t\tint curr = BIG;\n\t\tREM(j, 0, W + 1) {\n\t\t\tif (T[j]) curr = j;\n\t\t\tR[j] = curr;\n\t\t}\n\t}\n}\n\nPP rotate(PP a) {\n\treturn PP(a.second, H - a.first);\n}\n\nPP flip(PP a) {\n\treturn PP(a.first, W - a.second);\n}\n\nint main() {\n\tint N, M, Q;\n\tstring s, t;\n\tvector<PP> A;\n\tvector<PP> B;\n\n\tcin >> N >> M >> Q;\n\t--N; --M;\n\tcin >> s >> t;\n\n\tREP(i, 0, Q) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\t--a; --b; --c; --d;\n\t\tA.push_back(PP(a, b));\n\t\tB.push_back(PP(c, d));\n\t}\n\n\tans.assign(Q, INF);\n\t\n\tH = N;\n\tW = M;\n\tREP(i, 0, N + 1) S.push_back(s[i] == 'E');\n\tREP(j, 0, M + 1) T.push_back(t[j] == 'S');\n\tREP(rev, 0, 2) {\n\t\tREP(rot, 0, 4) {\n\t\t\tpre();\n\t\t\tREP(j, 0, Q) {\n\t\t\t\tans[j] = min(ans[j], sub(A[j], B[j]));\n\t\t\t}\n\t\t\tREP(j, 0, Q) {\n\t\t\t\tA[j] = rotate(A[j]);\n\t\t\t\tB[j] = rotate(B[j]);\n\t\t\t}\n\t\t\tswap(H, W);\n\t\t\tswap(S, T);\n\t\t\tfor (int& i : S) i = !i;\n\t\t\treverse(T.begin(), T.end());\n\t\t}\n\t\tREP(j, 0, Q) {\n\t\t\tA[j] = flip(A[j]);\n\t\t\tB[j] = flip(B[j]);\n\t\t}\n\t\tfor (int& i : S) i = !i;\n\t\treverse(T.begin(), T.end());\n\t}\n\n\tREP(j, 0, Q) {\n\t\tcout << (ans[j] >= BIG ? -1 : ans[j]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(s[a] == 'W'){\n\t    \tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//左\n\t\tint x = POSL(up,min(d,b));\n\t\tint xx = POSL(up,b);\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSL(up,b) > 0){\n\t\t    x = POSL(up,b); x--;\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSL(dw,min(d,b));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSL(dw,b) > 0){\n\t\t    y = POSL(dw,b); y--;\n\t\t    on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\n\t}\n\telse{\n\t    if(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = POSU(up,max(d,b));\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSU(up,b) != up.size()){\n\t\t    x = POSU(up,b);\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSU(dw,max(d,b));\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSU(dw,b) != dw.size()){\n\t\t    y = POSU(dw,b);\n\t\t   on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(t[b] == 'N'){\n\t    if(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//上\n\t\tint x = POSL(le,min(a,c));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSL(le,a)){\n\t\t    x = POSL(le,a)-1;\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSL(ri,min(a,c));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSL(ri,a)){\n\t\t    y = POSL(ri,a)-1;\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\telse{\n\t    if(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = POSU(le,max(a,c));\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSU(le,a) != le.size()){\n\t\t    x = POSU(le,a);\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSU(ri,max(a,c));\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSU(ri,a) != ri.size()){\n\t\t    y = POSU(ri,a);\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,4,0);\n\t\ton_y(a,b,c,d,4,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using T = tuple<int, int, int>;\n    map<T, int> dp;\n    using P = pair<int, T>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      T st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      tie(y,x,step)=st;\n      \n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(abs(ny)==INF||abs(nx)==INF) return;\n          if(ny==y&&nx==x) return;        \n          if(dp.count(T(ny,nx,ns))&&dp[T(ny,nx,ns)]<=nd) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        // N           \n        for(int xx:{x,d}){\n          auto it=--upper_bound(vn.begin(),vn.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=--upper_bound(vs.begin(),vs.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }else{\n        // N           \n        for(int xx:{x,d}){\n          auto it=lower_bound(vn.begin(),vn.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=lower_bound(vs.begin(),vs.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }\n      if(t[x]=='N'){            \n        // W         \n        for(int yy:{y,c}){\n          auto it=--upper_bound(vw.begin(),vw.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=--upper_bound(ve.begin(),ve.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      }else{\n        // W         \n        for(int yy:{y,c}){\n          auto it=lower_bound(vw.begin(),vw.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=lower_bound(ve.begin(),ve.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 6;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\nmap < pair < int, int >, int > mp;\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n    // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (step == BUBEN) return INF;\n    if (mp.count(make_pair(fromx, fromy)) && mp[make_pair(fromx, fromy)] <= step) return INF;\n    mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j] == k) nxt[i][val][0][j] = j;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j] == k) nxt[i][val][1][j] = j;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int x,y,d,dir;};\nvector<state> st[7];\nchar s[110001],t[110001];\nint n,m,q,sl[110001][2],sr[110001][2],tl[110001][2],tr[110001][2],ex,ey,sx,sy,ans;\nvoid go(int id,int x,int y,int d,bool ns)\n{\n\tif(ns)\n\t\tif(t[y]=='S')\n\t\t{\n\t\t\tif(sr[x][0])st[id].push_back({sr[x][0],y,d+sr[x][0]-x,ns});\n\t\t\tif(sr[x][1])st[id].push_back({sr[x][1],y,d+sr[x][1]-x,ns});\n\t\t\tif(ex>x)\n\t\t\t{\n\t\t\t\tif(ey==y)ans=min(ans,d+ex-x);\n\t\t\t\tif(int z=sr[ex-1][ey>y])st[id].push_back({z,y,d+z-x,ns});\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sl[x][0])st[id].push_back({sl[x][0],y,d+x-sl[x][0],ns});\n\t\t\tif(sl[x][1])st[id].push_back({sl[x][1],y,d+x-sl[x][1],ns});\n\t\t\tif(ex<x)\n\t\t\t{\n\t\t\t\tif(ey==y)ans=min(ans,d+x-ex);\n\t\t\t\tif(int z=sl[ex+1][ey>y])st[id].push_back({z,y,d+x-z,ns});\n\t\t\t}\n\t\t}\n\telse if(s[x]=='E')\n\t{\n\t\tif(tr[y][0])st[id].push_back({x,tr[y][0],d+tr[y][0]-y,ns});\n\t\tif(tr[y][1])st[id].push_back({x,tr[y][1],d+tr[y][1]-y,ns});\n\t\tif(ey>y)\n\t\t{\n\t\t\tif(ex==x)ans=min(ans,d+ey-y);\n\t\t\tif(int z=tr[ey-1][ex>x])st[id].push_back({x,z,d+z-y,ns});\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(tl[y][0])st[id].push_back({x,tl[y][0],d+y-tl[y][0],ns});\n\t\tif(tl[y][1])st[id].push_back({x,tl[y][1],d+y-tl[y][1],ns});\n\t\tif(ey<y)\n\t\t{\n\t\t\tif(ex==x)ans=min(ans,d+y-ey);\n\t\t\tif(int z=tl[ey+1][ex>x])st[id].push_back({x,z,d+y-z,ns});\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m>>q>>(s+1)>>(t+1);\n\tfor(int i=2;i<=n;i++){sl[i][0]=sl[i-1][0];sl[i][1]=sl[i-1][1];sl[i][s[i-1]=='E']=i-1;}\n\tfor(int i=2;i<=m;i++){tl[i][0]=tl[i-1][0];tl[i][1]=tl[i-1][1];tl[i][t[i-1]=='S']=i-1;}\n\tfor(int i=n-1;i;i--){sr[i][0]=sr[i+1][0];sr[i][1]=sr[i+1][1];sr[i][s[i+1]=='E']=i+1;}\n\tfor(int i=m-1;i;i--){tr[i][0]=tr[i+1][0];tr[i][1]=tr[i+1][1];tr[i][t[i+1]=='S']=i+1;}\n\twhile(q--)\n\t{\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tans=1<<30;\n\t\tfor(int i=0;i<4;i++)st[i].clear();\n\t\tgo(0,sx,sy,0,0);\n\t\tgo(0,sx,sy,0,1);\n\t\tfor(int i=0;i<4;i++)\n\t\t\tfor(state x:st[i])go(i+1,x.x,x.y,x.d,x.dir^1);\n\t\tcout<<(ans==(1<<30)?-1:ans)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m,q;\n    cin >> n >> m >> q;\n    string s,t;\n    cin >> s >> t;\n    vector<int> L,R;\n    vector<int> U,D;\n    rep(i,n){\n        if(s[i]=='W'){\n            L.push_back(i);\n        }else{\n            R.push_back(i);\n        }\n    }\n    rep(i,m){\n        if(t[i]=='N'){\n            U.push_back(i);\n        }else{\n            D.push_back(i);\n        }\n    }\n    rep(zz,q){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        a--;b--;c--;d--;\n        queue<pair<pair<pair<int,int>,pair<int,int> >,pair<int,int> > >q;\n        if(t[b]=='N'){\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(-1,1)));\n        }else{\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(1,1)));\n        }\n        if(s[a]=='W'){\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(-1,0)));\n        }else{\n            q.push(MP(MP(MP(0,0),MP(a,b)),MP(1,0)));\n        }\n        int mi = inf;\n        while(!q.empty()){\n            auto x = q.front();\n            q.pop();\n            int dist = x.first.first.first;\n            int cnt = x.first.first.second;\n            int na = x.first.second.first;\n            int nb = x.first.second.second;\n            int pl = x.second.first;\n            int dir = x.second.second;\n            // cerr << na << \" \" << nb << \" \" << dist << \" \" << cnt << \" \" << pl << \" \" << dir << endl;\n            if(na==c&&nb==d){\n                chmin(mi,dist);\n                continue;\n            }\n            if(cnt==9)continue;\n            if(dir==1){// UP DOWN\n                if(pl==-1){//UP\n                    if(c<na&&nb==d){\n                        chmin(mi,dist+na-c);\n                        continue;\n                    }        \n                    if(nb<=d){\n                        int tar = min(na,c);\n                        auto x = lower_bound(all(R),tar);\n                        if(x!=R.end()){\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                        if(x!=R.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                    }\n                    if(nb>=d){\n                        int tar = min(na,c);\n                        auto x = lower_bound(all(L),tar);\n                        if(x!=L.end()){\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                        if(x!=L.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna<na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                    }\n                }else{//DOWN\n                    if(c>na&&nb==d){\n                        chmin(mi,dist+abs(c-na));\n                        continue;\n                    }        \n                    if(nb<=d){\n                        int tar = max(na,c);\n                        auto x = lower_bound(all(R),tar);\n                        if(x!=R.end()){\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                        if(x!=R.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(1,0)));\n                        }\n                    }\n                    if(nb>=d){\n                        int tar = max(na,c);\n                        auto x = lower_bound(all(L),tar);\n                        if(x!=L.end()){\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                        if(x!=L.begin()){\n                            x--;\n                            int nna = *x;\n                            if(nna>na)q.push(MP(MP(MP(dist+abs(nna-na),cnt+1),MP(nna,nb)),MP(-1,0)));\n                        }\n                    }\n                }\n\n            }else{// LEFT RIGHT\n                if(pl==-1){//LEFT\n                    if(d<nb&&na==c){\n                        chmin(mi,dist+abs(nb-d));\n                        continue;\n                    }        \n                    if(na<=c){\n                        int tar = min(nb,d);\n                        auto x = lower_bound(all(D),tar);\n                        if(x!=D.end()){\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                        if(x!=D.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                    }\n                    if(na>=c){\n                        int tar = min(nb,d);\n                        auto x = lower_bound(all(U),tar);\n                        if(x!=U.end()){\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                        if(x!=U.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb<nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                    }\n                }else{//RIGHT\n                    if(d>nb&&na==c){\n                        chmin(mi,dist+abs(d-nb));\n                        continue;\n                    }        \n                    if(na<=c){\n                        int tar = max(nb,d);\n                        auto x = lower_bound(all(D),tar);\n                        if(x!=D.end()){\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                        if(x!=D.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(1,1)));\n                        }\n                    }\n                    if(na>=c){\n                        int tar = max(nb,d);\n                        auto x = lower_bound(all(U),tar);\n                        if(x!=U.end()){\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                        if(x!=U.begin()){\n                            x--;\n                            int nnb = *x;\n                            if(nnb>nb)q.push(MP(MP(MP(dist+abs(nnb-nb),cnt+1),MP(na,nnb)),MP(-1,1)));\n                        }\n                    }\n                }\n            }\n        }\n        if(mi!=inf){\n            cout << mi << \"\\n\";\n        }else{\n            cout << -1 << \"\\n\";\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  vector<int> pnu(m),psu(m);\n  vector<int> pnl(m),psl(m);\n  for(int j=0;j<m;j++){    \n    pnu[j]=*--upper_bound(vn.begin(),vn.end(),j);\n    psu[j]=*--upper_bound(vs.begin(),vs.end(),j);    \n    pnl[j]=*lower_bound(vn.begin(),vn.end(),j);\n    psl[j]=*lower_bound(vs.begin(),vs.end(),j);\n  }\n  \n  vector<int> pwu(n),peu(n);\n  vector<int> pwl(n),pel(n);\n  for(int i=0;i<n;i++){    \n    pwu[i]=*--upper_bound(vw.begin(),vw.end(),i);\n    peu[i]=*--upper_bound(ve.begin(),ve.end(),i);    \n    pwl[i]=*lower_bound(vw.begin(),vw.end(),i);\n    pel[i]=*lower_bound(ve.begin(),ve.end(),i);\n  }      \n  \n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using ll = long long;    \n    auto T=[&](int y,int x,int step){return ((ll)y<<40)|((ll)x<<20)|(ll)step;};\n    unordered_map<ll, int> dp;\n    using P = pair<int, ll>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      ll st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      y=(st>>40);\n      x=(st>>20)^((ll)y<<20);\n      step=st&((1<<20)-1);\n      \n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(abs(ny)==INF||abs(nx)==INF) return;\n          if(ny==y&&nx==x) return;          \n          if(dp.count(T(ny,nx,ns))&&dp[T(ny,nx,ns)]<=nd) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        for(int xx:{x,d}){\n          // N           \n          if(pnu[xx]<=x)\n            push(y,pnu[xx],step+1,sum+abs(pnu[xx]-x));\n          // S\n          if(psu[xx]<=x)\n            push(y,psu[xx],step+1,sum+abs(psu[xx]-x));\n        }\n      }else{\n        for(int xx:{x,d}){\n          // N           \n          if(pnl[xx]>=x)\n            push(y,pnl[xx],step+1,sum+abs(pnl[xx]-x));\n          // S\n          if(psl[xx]>=x)\n            push(y,psl[xx],step+1,sum+abs(psl[xx]-x));\n        }\n      }\n      if(t[x]=='N'){\n        for(int yy:{y,c}){\n          // W\n          if(pwu[yy]<=y)\n            push(y,pwu[yy],step+1,sum+abs(pwu[yy]-x));\n          // E\n          if(peu[yy]<=y)\n            push(y,peu[yy],step+1,sum+abs(peu[yy]-x));\n        }\n      }else{        \n        for(int yy:{y,c}){\n          // W\n          if(pwl[yy]>=y)\n            push(y,pwl[yy],step+1,sum+abs(pwl[yy]-x));\n          // E\n          if(pel[yy]>=y)\n            push(y,pel[yy],step+1,sum+abs(pel[yy]-x));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\n\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\n\tfor(int i=1;i<=q;i++)\t\n\t{\n\t\tpii s=from[i],t=dest[i];\n\t\t\n\t\tif(s.first>t.first or s.second>t.second) continue;\n\t\t#define case0 case0\n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=ub(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][1]),z=ub(t.first,path[0][0]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n//\t\tif(s.second==t.second) continue;\n\t\t#define case1 case1\n\t\tfor(;s.first<=t.first;)\n\t\t{\n\t\t\tint x=lb(s.first,path[0][1]);\n\t\t\tif(!x) break;int tmp=abs(s.first-x)+abs(t.first-x)+abs(s.second-t.second);\n\t\t\tint zyz=s.second;\n\t\t\tif(x!=s.first) \n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][0]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\t\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or y<zyz) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t#define case2 case2\n\n\t\tfor(;s.first<t.first;)\n\t\t{\n\t\t\tint x=ub(s.first,path[0][1]);\n\t\t\tif(x>=t.first or x<=s.first) break;int tmp=abs(s.second-t.second)+abs(s.first-t.first);\n\t\t\tint at=1e9,bt=1e9;\n\t\t\tint zyz;\n\t\t\tif(1)\n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][1]);if(!y) break;\n\t\t\t\tzyz=y;tmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\t\n\t\t\t//copied from  line58\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or (y<zyz)) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//licensed\n\t\t}\n\t}\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\t\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) dir[0][i]^=1;for(int i=1;i<=m;i++) dir[1][i]^=1;\n\tfor(int i=1;i<=q;i++) swap(from[i],dest[i]);\n\t\n\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int x,y,d,dir;}st[5][11001];\nchar s[110001],t[110001];\nint n,m,q,sl[110001][2],sr[110001][2],tl[110001][2],tr[110001][2],ex,ey,sx,sy,ans,cnt[5];\nvoid go(int id,int x,int y,int d,bool ns)\n{\n\tif(ns)\n\t\tif(t[y]=='S')\n\t\t{\n\t\t\tif(sr[x][0])st[id][cnt[id]++]={sr[x][0],y,d+sr[x][0]-x,ns};\n\t\t\tif(sr[x][1])st[id][cnt[id]++]={sr[x][1],y,d+sr[x][1]-x,ns};\n\t\t\tif(ex>x)\n\t\t\t{\n\t\t\t\tif(ey==y)ans=min(ans,d+ex-x);\n\t\t\t\tif(int z=sr[ex-1][ey>y])st[id][cnt[id]++]={z,y,d+z-x,ns};\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sl[x][0])st[id][cnt[id]++]={sl[x][0],y,d+x-sl[x][0],ns};\n\t\t\tif(sl[x][1])st[id][cnt[id]++]={sl[x][1],y,d+x-sl[x][1],ns};\n\t\t\tif(ex<x)\n\t\t\t{\n\t\t\t\tif(ey==y)ans=min(ans,d+x-ex);\n\t\t\t\tif(int z=sl[ex+1][ey>y])st[id][cnt[id]++]={z,y,d+x-z,ns};\n\t\t\t}\n\t\t}\n\telse if(s[x]=='E')\n\t{\n\t\tif(tr[y][0])st[id][cnt[id]++]={x,tr[y][0],d+tr[y][0]-y,ns};\n\t\tif(tr[y][1])st[id][cnt[id]++]={x,tr[y][1],d+tr[y][1]-y,ns};\n\t\tif(ey>y)\n\t\t{\n\t\t\tif(ex==x)ans=min(ans,d+ey-y);\n\t\t\tif(int z=tr[ey-1][ex>x])st[id][cnt[id]++]={x,z,d+z-y,ns};\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(tl[y][0])st[id][cnt[id]++]={x,tl[y][0],d+y-tl[y][0],ns};\n\t\tif(tl[y][1])st[id][cnt[id]++]={x,tl[y][1],d+y-tl[y][1],ns};\n\t\tif(ey<y)\n\t\t{\n\t\t\tif(ex==x)ans=min(ans,d+y-ey);\n\t\t\tif(int z=tl[ey+1][ex>x])st[id][cnt[id]++]={x,z,d+y-z,ns};\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m>>q>>(s+1)>>(t+1);\n\tfor(int i=2;i<=n;i++){sl[i][0]=sl[i-1][0];sl[i][1]=sl[i-1][1];sl[i][s[i-1]=='E']=i-1;}\n\tfor(int i=2;i<=m;i++){tl[i][0]=tl[i-1][0];tl[i][1]=tl[i-1][1];tl[i][t[i-1]=='S']=i-1;}\n\tfor(int i=n-1;i;i--){sr[i][0]=sr[i+1][0];sr[i][1]=sr[i+1][1];sr[i][s[i+1]=='E']=i+1;}\n\tfor(int i=m-1;i;i--){tr[i][0]=tr[i+1][0];tr[i][1]=tr[i+1][1];tr[i][t[i+1]=='S']=i+1;}\n\twhile(q--)\n\t{\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tans=1<<30;\n\t\tmemset(cnt,0,sizeof cnt);\n\t\tgo(0,sx,sy,0,0);\n\t\tgo(0,sx,sy,0,1);\n\t\tfor(int i=0;i<4;i++)\n\t\t\tfor(int j=0;j<cnt[i];j++)go(i+1,st[i][j].x,st[i][j].y,st[i][j].d,st[i][j].dir^1);\n\t\tcout<<(ans==(1<<30)?-1:ans)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nstruct handler{\n    typedef pii val_t;\n    typedef int opr_t;\n    handler(){}\n    val_t def_val(){ return pii(MOD, -MOD); }\n    static val_t update(const val_t &l, const opr_t &r){\n        return pii(r, r);\n    }\n    static val_t merge(const val_t &l, const val_t &r){\n        return pii(min(l.first, r.first), max(l.second, r.second));\n    }\n};\n\ntemplate<typename Handler>\nstruct SegTree{\n    typedef typename Handler::val_t val_t;\n    typedef typename Handler::opr_t opr_t;\n    vector<val_t> val;\n    Handler hdl;\n    int n;\n\n    SegTree(int size = 0):hdl(){\n        n=1;\n        while(n<size) n<<=1;\n        val=vector<val_t>(2*n, hdl.def_val());\n    }\n    SegTree(const vector<val_t> &in):hdl(){\n        n=1;\n        while(n<in.size()) n<<=1;\n        val=vector<val_t>(2*n, hdl.def_val());\n        for(int i=n-1 + in.size()-1;i>=0;i--){\n            if(n-1 <= i) val[i] = in[i - (n-1)];\n            else val[i] = hdl.merge(val[i*2+1],val[i*2+2]);\n        }\n    }\n    void update(int i, const opr_t& a){\n        i += n-1;\n        val[i] = hdl.update(val[i], a);\n        while(i > 0){\n            i = (i-1)/2;\n            val[i] = hdl.merge(val[i*2+1],val[i*2+2]);\n        }\n    }\n    val_t query(int a,int b,int k,int l,int r){\n        if(r<=a||b<=l) return hdl.def_val();\n        if(a<=l&&r<=b) return val[k];\n        return hdl.merge(query(a, b, k*2+1, l, (l+r)/2),\n                         query(a, b, k*2+2, (l+r)/2, r)\n        );\n    }\n    val_t query(int a, int b){return query(a, b, 0, 0, n);}\n    val_t operator[](size_t i){return query(i, i+1);}\n    friend ostream& operator<<(ostream &os, SegTree<Handler> &t){\n        REP(i, t.n) os << (i ? \", \" : \"[\") << t.query(i, i+1);\n        return os << \"]\";\n    }\n};\n\n\nint T, n, m, q;\nstring s, t;\nSegTree<handler> segE, segW, segN, segS;\n\nint solve2(int sy, int sx, int gy, int gx) {\n    int mi = MOD;\n    {\n        int ans = 0;\n        if (sx <= gx && s[sy] == 'E') ans += gx - sx;\n        else if (sx >= gx && s[sy] == 'W') ans += sx - gx;\n        else ans += MOD;\n        if (sy <= gy && t[gx] == 'S') ans += gy - sy;\n        else if (sy >= gy && t[gx] == 'N') ans += sy - gy;\n        else ans += MOD;\n        mi = min(mi, ans);\n    }\n    {\n        int ans = 0;\n        if (sx <= gx && s[gy] == 'E') ans += gx - sx;\n        else if (sx >= gx && s[gy] == 'W') ans += sx - gx;\n        else ans += MOD;\n        if (sy <= gy && t[sx] == 'S') ans += gy - sy;\n        else if (sy >= gy && t[sx] == 'N') ans += sy - gy;\n        else ans += MOD;\n        mi = min(mi, ans);\n    }\n\n    return mi;\n}\n\nint solve(int sy, int sx, int gy, int gx, int step);\n\nint solve3(int sy, int sx, int gy, int gx, int d1, int step) {\n    int p;\n    int ans = MOD;\n    if (d1 == 0) {\n        if (t[sx] != 'N') return MOD;\n        p = segE.query(0, min(sy, gy) + 1).second;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n        p = segW.query(0, min(sy, gy) + 1).second;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n    }\n    if (d1 == 2) {\n        if (t[sx] != 'S') return MOD;\n        p = segE.query(max(sy, gy), n).first;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n        p = segW.query(max(sy, gy), n).first;\n        chmin(ans, solve(p, sx, gy, gx, step) + abs(sy - p));\n    }\n    if (d1 == 1) {\n        if (s[sy] != 'E') return MOD;\n        p = segN.query(max(sx, gx), m).first;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n        p = segS.query(max(sx, gx), m).first;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n    }\n    if (d1 == 3) {\n        if (s[sy] != 'W') return MOD;\n        p = segN.query(0, min(sx, gx)).second;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n        p = segS.query(0, min(sx, gx)).second;\n        chmin(ans, solve(sy, p, gy, gx, step) + abs(sx - p));\n    }\n    return ans;\n}\n\nint solve(int sy, int sx, int gy, int gx, int step = 3) {\n    if (sx < 0 || sy < 0 || n <= sy || m <= sx) return MOD;\n    int ans = solve2(sy, sx, gy, gx);\n//    cout << \"solve \" << sy << \", \" << sx << \": \" << ans << endl;\n    if (step > 0) {\n        REP(i, 4) {\n            ans = min(ans, solve3(sy, sx, gy, gx, i, step - 1));\n        }\n    }\n    return ans;\n}\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> m >> q >> s >> t){\n        segE = SegTree<handler>(n);\n        segW = SegTree<handler>(n);\n        REP(i, n) {\n            if (s[i] == 'E') segE.update(i, i);\n            if (s[i] == 'W') segW.update(i, i);\n        }\n        segN = SegTree<handler>(m);\n        segS = SegTree<handler>(m);\n        REP(i, m) {\n            if (t[i] == 'N') segN.update(i, i);\n            if (t[i] == 'S') segS.update(i, i);\n        }\n        REP(i, q) {\n            int sy, sx, gy, gx;\n            cin >> sy >> sx >> gy >> gx; sx --; sy --; gx --; gy--;\n            int ans = solve(sy, sx, gy, gx);\n            cout << (ans >= MOD ? -1 : ans) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nbool Hs[100000];\nbool Ws[100000];\nint HPT[100001];\nint HMT[100001];\nint HPF[100001];\nint HMF[100001];\nint WPT[100001];\nint WMT[100001];\nint WPF[100001];\nint WMF[100001];\npair<int,int> X[6];\nvoid Calc(){\n\tint H = rei();\n\tint W = rei();\n\tint Q = rei();\n\tstring S = res();\n\tstring T = res();\n\tfor(int i=0;i<H;i++){\n\t\tHs[i] = S[i] == 'E';\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tWs[i] = T[i] == 'S';\n\t}\t\n\tfor(int i=0;i<H;i++){\n\t\tif(Hs[i]){\n\t\t\tHMT[i+1] = i+1;\n\t\t\tHMF[i+1] = HMF[i];\n\t\t}\n\t\telse{\n\t\t\tHMF[i+1] = i+1;\n\t\t\tHMT[i+1] = HMT[i];\n\t\t}\n\t}\n\tHPF[H] = H;\n\tHPT[H] = H;\n\tfor(int i=H-1;i>=0;i--){\n\t\tif(Hs[i]){\n\t\t\tHPT[i] = i;\n\t\t\tHPF[i] = HPF[i+1];\n\t\t}\n\t\telse{\n\t\t\tHPF[i] = i;\n\t\t\tHPT[i] = HPT[i+1];\n\t\t}\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tif(Ws[i]){\n\t\t\tWMT[i+1] = i+1;\n\t\t\tWMF[i+1] = WMF[i];\n\t\t}\n\t\telse{\n\t\t\tWMF[i+1] = i+1;\n\t\t\tWMT[i+1] = WMT[i];\n\t\t}\n\t}\n\tWPF[W] = W;\n\tWPT[W] = W;\n\tfor(int i=W-1;i>=0;i--){\n\t\tif(Ws[i]){\n\t\t\tWPT[i] = i;\n\t\t\tWPF[i] = WPF[i+1];\n\t\t}\n\t\telse{\n\t\t\tWPF[i] = i;\n\t\t\tWPT[i] = WPT[i+1];\n\t\t}\n\t}\n\tfor(int query=0;query<Q;query++){\n\t\tint start = 0;\n\t\tstack<tuple<int,int,bool,int,int>> sp;\n\t\tint hb = rei()-1;\n\t\tint wb = rei()-1;\n\t\tint ha = rei()-1;\n\t\tint wa = rei()-1;\n\t\tsp.push(make_tuple(hb,wb,true,0,0));\n\t\tsp.push(make_tuple(hb,wb,false,0,0));\n\t\tint nextx,nexty;\n\t\tint ans = 1000000000;\n\t\twhile(!sp.empty()){\n\t\t\ttuple<int,int,bool,int,int> t = sp.top();\n\t\t\tsp.pop();\n\t\t\tint x = get<0>(t);\n\t\t\tint y = get<1>(t);\n\t\t\tint coun = get<3>(t);\n\t\t\tint cost = get<4>(t);\n\t\t\tint d = 0;\n\t\t\tif(get<2>(t)){\n\t\t\t\tif(Ws[y]){\n\t\t\t\t\tif(ha > x){\n\t\t\t\t\t\tif(HPF[ha] != H){\n\t\t\t\t\t\t\tnextx = HPF[ha];\n\t\t\t\t\t\t\tnexty = y;\n\t\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(HPT[ha] != H){\n\t\t\t\t\t\t\tnextx = HPT[ha];\n\t\t\t\t\t\t\tnexty = y;\n\t\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(HPF[x] != x && HPF[x] != H){\n\t\t\t\t\t\tnextx = HPF[x];\n\t\t\t\t\t\tnexty = y;\n\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t}\n\t\t\t\t\tif(HPT[x] != x && HPT[x] != H){\n\t\t\t\t\t\tnextx = HPT[x];\n\t\t\t\t\t\tnexty = y;\n\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(ha < x){\n\t\t\t\t\t\tif(HMF[ha+1] != 0){\n\t\t\t\t\t\t\tnextx = HMF[ha+1]-1;\n\t\t\t\t\t\t\tnexty = y;\n\t\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(HMT[ha+1] != 0){\n\t\t\t\t\t\t\tnextx = HMT[ha+1]-1;\n\t\t\t\t\t\t\tnexty = y;\n\t\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(HMF[x+1] != x+1 && HMF[x+1] != 0){\n\t\t\t\t\t\tnextx = HMF[x+1]-1;\n\t\t\t\t\t\tnexty = y;\n\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t}\n\t\t\t\t\tif(HMT[x+1] != x+1 && HMT[x+1] != 0){\n\t\t\t\t\t\tnextx = HMT[x+1]-1;\n\t\t\t\t\t\tnexty = y;\n\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(Hs[x]){\n\t\t\t\t\tif(wa > y){\n\t\t\t\t\t\tif(WPF[wa] != W){\n\t\t\t\t\t\t\tnexty = WPF[wa];\n\t\t\t\t\t\t\tnextx = x;\n\t\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(WPT[wa] != W){\n\t\t\t\t\t\t\tnexty = WPT[wa];\n\t\t\t\t\t\t\tnextx = x;\n\t\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(WPF[y] != y && WPF[y] != W){\n\t\t\t\t\t\tnexty = WPF[y];\n\t\t\t\t\t\tnextx = x;\n\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t}\n\t\t\t\t\tif(WPT[y] != y && WPT[y] != W){\n\t\t\t\t\t\tnexty = WPT[y];\n\t\t\t\t\t\tnextx = x;\n\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(wa < y){\n\t\t\t\t\t\tif(WMF[wa+1] != 0){\n\t\t\t\t\t\t\tnexty = WMF[wa+1]-1;\n\t\t\t\t\t\t\tnextx = x;\n\t\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(WMT[wa+1] != 0){\n\t\t\t\t\t\t\tnexty = WMT[wa+1]-1;\n\t\t\t\t\t\t\tnextx = x;\n\t\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(WMF[y+1] != y+1 && WMF[y+1] != 0){\n\t\t\t\t\t\tnexty = WMF[y+1]-1;\n\t\t\t\t\t\tnextx = x;\n\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t}\n\t\t\t\t\tif(WMT[y+1] != y+1 && WMT[y+1] != 0){\n\t\t\t\t\t\tnexty = WMT[y+1]-1;\n\t\t\t\t\t\tnextx = x;\n\t\t\t\t\t\tX[d++] = {nextx,nexty};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(coun == 4){\n\t\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\t\tif(X[i].first == ha && X[i].second == wa){\n\t\t\t\t\t\tans = min(ans,abs(X[i].first-x)+abs(X[i].second-y)+cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<d;i++){\n\t\t\t\t\tif(X[i].first == ha && X[i].second == wa){\n\t\t\t\t\t\tans = min(ans,abs(X[i].first-x)+abs(X[i].second-y)+cost);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tsp.push(make_tuple(X[i].first,X[i].second,!get<2>(t),coun+1,abs(X[i].first-x)+abs(X[i].second-y)+cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans == 1000000000){\n\t\t\tcout << \"-1\\n\"; \n\t\t}\n\t\telse{\n\t\t\tcout << ans << \"\\n\"; \n\t\t}\n\t}\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,1,-1,1,-1,-1,0};\nint dy[]={0,1,1,-1,-1,1,0,-1};\n\nvector<LL> fact;\nvector<LL> inver(2000001);\n \nLL combi(int n,int r){\n    if(n<r||n<0||r<0) return 0;\n    return fact[n]%mod*inver[n-r]%mod*inver[r]%mod;\n}\n \n \nLL fpow(LL a, LL n){\n    LL x = 1;\n    while(n > 0){\n        if(n&1){\n            x=x*a%mod;\n        }\n        a=a*a%mod;\n        n >>= 1;\n    }\n    return x;\n}\n \nvoid set_combi(){\n    LL s=1;\n    fact.push_back(1);\n    for(LL i=1;i<=2000000;i++){\n        s*=i;\n        s%=mod;\n        fact.push_back(s);\n    }\n    inver[2000000]=fpow(fact[2000000],mod-2);\n    for(LL i=1999999;i>=0;i--){\n        inver[i]=inver[i+1]*(i+1)%mod;\n    }\n}\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\nusing mint = modint<1000000007>;\n\nmint f(mint r, mint c){\n    return ((r + 2) * combi(r.value() + c.value() + 2, r.value() + 2) - c - 1) / (c + 1);\n\n}\n\nint main(){\n    set_combi();\n    mint r1,c1,r2,c2;cin >> r1.a >> c1.a >> r2.a >> c2.a;\n    cout << (f(r2,c2) + f(r1-1,c1-1) - f(r2,c1-1) + f(r1-1,c2)).value() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<ll,ll> P;\nclass RMQ{\npublic:\n  int n,dat[555555];\n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    fill(dat,dat+2*n-1,MAX);\n  }\n  void update(int k,int a){\n    k+=n-1;dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b){return query(a,b,0,0,n);}\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return MAX;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n\nclass RMQ2{\npublic:\n  int n,dat[555555];\n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    fill(dat,dat+2*n-1,-MAX);\n  }\n  void update(int k,int a){\n    k+=n-1;dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b){return query(a,b,0,0,n);}\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return -MAX;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\n\nRMQ tx[2],ty[2];\nRMQ2 rx[2],ry[2];\n\nvoid Main() {\n  ll n,m,T;\n  string s,t;\n  cin >> n >> m >> T >> s >> t;\n  rep(i,2) tx[i].init(n);\n  rep(i,2) ty[i].init(m);\n  rep(i,2) rx[i].init(n);\n  rep(i,2) ry[i].init(m);\n  rep(i,n) {\n    if(s[i]=='E') {\n      tx[0].update(i,i);\n      rx[0].update(i,i);\n    } else {\n      tx[1].update(i,i);\n      rx[1].update(i,i);\n    }\n  }\n  rep(i,m) {\n    if(t[i]=='N') {\n      ty[0].update(i,i);\n      ry[0].update(i,i);\n    } else {\n      ty[1].update(i,i);\n      ry[1].update(i,i);\n    }\n  }\n  while(T--) {\n    ll ans=MAX;\n    ll x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1--,y1--,x2--,y2--;\n    string w=\"ENSW\";\n    do {\n      int c1=w[0],c2=w[2];\n      if(c1>c2) swap(c1,c2);\n      if(c1=='E'&&c2=='W'||c1=='N'&&c2=='S') {\n        string r=w+w;\n        ll x=x1,y=y1,sum=0;\n        rep(i,r.size()) {\n          if(x==x2&&y<=y2&&s[x]=='E') {\n            sum+=abs(y-y2);\n            break;\n          }\n          if(x==x2&&y>=y2&&s[x]=='W') {\n            sum+=abs(y-y2);\n            break;\n          }\n          if(y==y2&&x<=x2&&t[y]=='S') {\n            sum+=abs(x-x2);\n            break;\n          }\n          if(y==y2&&x>=x2&&t[y]=='N') {\n            sum+=abs(x-x2);\n            break;\n          }\n          if(P(x,y)==P(x2,y2)) break;\n          ll z=0;\n          if(r[i]=='E') {\n            if(t[y]=='N') {\n              z=rx[0].query(0,min(x,x2)+1);\n              if(z==-MAX) goto next;\n            } else {\n              z=tx[0].query(max(x,x2),n);\n              if(z==MAX) goto next;\n            }\n            sum+=abs(x-z);\n            x=z;\n          } else if(r[i]=='W') {\n            if(t[y]=='N') {\n              z=rx[1].query(0,min(x,x2)+1);\n              if(z==-MAX) goto next;\n            } else {\n              z=tx[1].query(max(x,x2),n);\n              if(z==MAX) goto next;\n            }\n            sum+=abs(x-z);\n            x=z;\n          } else if(r[i]=='N') {\n            if(s[x]=='W') {\n              z=ry[0].query(0,min(y,y2)+1);\n              if(z==-MAX) goto next;\n            } else {\n              z=ty[0].query(max(y,y2),m);\n              if(z==MAX) goto next;\n            }\n            sum+=abs(y-z);\n            y=z;\n          } else {\n            if(s[x]=='W') {\n              z=ry[1].query(0,min(y,y2)+1);\n              if(z==-MAX) goto next;\n            } else {\n              z=ty[1].query(max(y,y2),m);\n              if(z==MAX) goto next;\n            }\n            sum+=abs(y-z);\n            y=z;\n          }\n        }\n        ans=min(ans,sum);\n      }\n    next:;\n    } while(next_permutation(all(w)));\n\n    {\n      w=\"ENSW\";\n      do {\n        int c1=w[0],c2=w[2];\n        if(c1>c2) swap(c1,c2);\n        if(c1=='E'&&c2=='W'||c1=='N'&&c2=='S') {\n          string r=w+w;\n          ll x=x1,y=y1,sum=0;\n          rep(i,r.size()) {\n            if(x==x2&&y<=y2&&s[x]=='E') {\n              sum+=abs(y-y2);\n              break;\n            }\n            if(x==x2&&y>=y2&&s[x]=='W') {\n              sum+=abs(y-y2);\n              break;\n            }\n            if(y==y2&&x<=x2&&t[y]=='S') {\n              sum+=abs(x-x2);\n              break;\n            }\n            if(y==y2&&x>=x2&&t[y]=='N') {\n              sum+=abs(x-x2);\n              break;\n            }\n            if(P(x,y)==P(x2,y2)) break;\n            ll z=0;\n            if(r[i]=='E') {\n              if(t[y]=='N') {\n                if(i<2) z=rx[0].query(0,x+1);\n                else z=rx[0].query(0,min(x,x2)+1);\n                if(z==-MAX) goto next2;\n              } else {\n                if(i<2) z=tx[0].query(x,n);\n                else z=tx[0].query(max(x,x2),n);\n                if(z==MAX) goto next2;\n              }\n              sum+=abs(x-z);\n              x=z;\n            } else if(r[i]=='W') {\n              if(t[y]=='N') {\n                if(i<2) z=rx[1].query(0,x+1);\n                else z=rx[1].query(0,min(x,x2)+1);\n                if(z==-MAX) goto next2;\n              } else {\n                if(i<2) z=tx[1].query(x,n);\n                else z=tx[1].query(max(x,x2),n);\n                if(z==MAX) goto next2;\n              }\n              sum+=abs(x-z);\n              x=z;\n            } else if(r[i]=='N') {\n              if(s[x]=='W') {\n                if(i<2) z=ry[0].query(0,y+1);\n                else z=ry[0].query(0,min(y,y2)+1);\n                if(z==-MAX) goto next2;\n              } else {\n                if(i<2) z=ty[0].query(y,m);\n                else z=ty[0].query(max(y,y2),m);\n                if(z==MAX) goto next2;\n              }\n              sum+=abs(y-z);\n              y=z;\n            } else {\n              if(s[x]=='W') {\n                if(i<2) z=ry[1].query(0,y+1);\n                else z=ry[1].query(0,min(y,y2)+1);\n                if(z==-MAX) goto next2;\n              } else {\n                if(i<2) z=ty[1].query(y,m);\n                else z=ty[1].query(max(y,y2),m);\n                if(z==MAX) goto next2;\n              }\n              sum+=abs(y-z);\n              y=z;\n            }\n          }\n          ans=min(ans,sum);\n        }\n      next2:;\n      } while(next_permutation(all(w)));\n    }\n    if(ans==MAX) ans=-1;\n    pr(ans);\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "// ===== 2019/03/30 23:11:17 =====\n\n// includes.hpp\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <climits>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\n// cin.cpp\n\ntemplate <typename T, int M, int N> struct tuple_getter {\n  static void get(std::istream &is, T &x) {\n    is >> std::get<M>(x);\n    tuple_getter<T, M + 1, N>::get(is, x);\n  }\n};\n\ntemplate <typename T, int N> struct tuple_getter<T, N, N> {\n  static void get(std::istream &is, T &x) { is >> std::get<N>(x); }\n};\n\ntemplate <typename... Args>\nstd::istream &operator>>(std::istream &is, std::tuple<Args...> &t) {\n  tuple_getter<std::tuple<Args...>, 0, sizeof...(Args) - 1>::get(is, t);\n  return is;\n}\n\ntemplate <typename T, typename U>\nstd::istream &operator>>(std::istream &is, std::pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate <typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &v) {\n  for (T &x : v) is >> x;\n  return is;\n}\n\n// const_value.hpp\n\nnamespace sub {\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_integral<T>::value, T>::type\ninf_sub() {\n  return std::numeric_limits<T>::max() / 2 - 1000;\n}\n\ntemplate <typename T>\nconstexpr typename std::enable_if<std::is_floating_point<T>::value, T>::type\ninf_sub() {\n  return std::min(std::numeric_limits<T>::max() / 2 - 1000, T(1e50));\n}\n}  // namespace sub\n\ntemplate <typename T> constexpr T inf() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return sub::inf_sub<T>();\n}\n\ntemplate <typename T> constexpr T zero() {\n  static_assert(std::is_arithmetic<T>::value, \"T must be arithmetic value\");\n  return T(0);\n}\n\nconst long double pi = acos(-1.0);\n\n// cout.cpp\n\ntemplate <typename T, int M, int N> struct tuple_printer {\n  static void print(std::ostream &os, const T &x) {\n    os << std::get<M>(x) << \" \";\n    tuple_printer<T, M + 1, N>::print(os, x);\n  }\n};\n\ntemplate <typename T, int N> struct tuple_printer<T, N, N> {\n  static void print(std::ostream &os, const T &x) { os << std::get<N>(x); }\n};\n\ntemplate <typename... Args>\nstd::ostream &operator<<(std::ostream &os, const std::tuple<Args...> &t) {\n  tuple_printer<std::tuple<Args...>, 0, sizeof...(Args) - 1>::print(os, t);\n  return os;\n}\n\ntemplate <typename T, typename U>\nstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \" \";\n    os << *it;\n  }\n  return os;\n}\n\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &os, const std::set<T> &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) os << \" \";\n    os << *it;\n  }\n  return os;\n}\n\n// macros.hpp\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\n// misc.hpp\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\n\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\n// range.hpp\n\nclass range {\n  class index_type {\n    int x;\n\n  public:\n    index_type(int x_) : x(x_) {}\n    int operator*() const { return x; }\n    bool operator!=(index_type &r) { return x < r.x; }\n    void operator++() { ++x; }\n  };\n  index_type i, n;\n\npublic:\n  range(int n_) : i(0), n(n_) {}\n  range(int i_, int n_) : i(i_), n(n_) {}\n  index_type &begin() { return i; }\n  index_type &end() { return n; }\n};\n\n// typedef.hpp\n\nusing ll = long long;\nusing ld = long double;\n\n// template.cpp\n\nusing namespace std;\n\n// main.cpp\n\ntemplate <typename T> vector<T> table(int n, T v) { return vector<T>(n, v); }\n\ntemplate <class... Args> auto table(int n, Args... args) {\n  auto val = table(args...);\n  return vector<decltype(val)>(n, move(val));\n}\n\nchar S[100100];\nchar T[100100];\n\nint subtask(int sy, int sx, int ty, int tx) {\n  if (sy == ty) {\n    if (sx == tx) return 0;\n    if (sx < tx && S[sy] == 'E') return 0;\n    if (sx > tx && S[sy] == 'W') return 0;\n  }\n  if ((sy < ty && T[sx] == 'S') || (sy > ty && T[sx] == 'N')) {\n    if (sx == tx) return 0;\n    if (sx < tx && S[ty] == 'E') return 0;\n    if (sx > tx && S[ty] == 'W') return 0;\n  }\n  if ((sy < ty && T[tx] == 'S') || (sy > ty && T[tx] == 'N')) {\n    if (sx == tx) return 0;\n    if (sx < tx && S[sy] == 'E') return 0;\n    if (sx > tx && S[sy] == 'W') return 0;\n  }\n  return 1e9;\n}\n\nset<int> n, s, e, w;\n\nvector<tuple<int,int,int>> next_point(int sy, int sx) {\n  vector<tuple<int,int,int>> res;\n  REP(sdir,2) {\n    int nsy = sy, nsx = sx, nsum = 0;\n    if (sdir == 0) {\n      if (S[sy] == 'E' && T[sx] == 'N') {\n        auto it = s.lower_bound(sx);\n        if (it == s.end()) continue;\n        nsx = *it;\n      }\n      if (S[sy] == 'W' && T[sx] == 'N') {\n        auto it = s.lower_bound(sx);\n        if (it == s.begin()) continue;\n        nsx = *prev(it);\n      }\n      if (S[sy] == 'E' && T[sx] == 'S') {\n        auto it = n.lower_bound(sx);\n        if (it == n.end()) continue;\n        nsx = *it;\n      }\n      if (S[sy] == 'W' && T[sx] == 'S') {\n        auto it = n.lower_bound(sx);\n        if (it == n.begin()) continue;\n        nsx = *prev(it);\n      }\n      nsum += abs(nsx - sx);\n    }\n    if (sdir == 1) {\n      if (S[sy] == 'E' && T[sx] == 'N') {\n        auto it = w.lower_bound(sy);\n        if (it == w.begin()) continue;\n        nsy = *prev(it);\n      }\n      if (S[sy] == 'E' && T[sx] == 'S') {\n        auto it = w.lower_bound(sy);\n        if (it == w.end()) continue;\n        nsy = *it;\n      }\n      if (S[sy] == 'W' && T[sx] == 'N') {\n        auto it = e.lower_bound(sy);\n        if (it == e.begin()) continue;\n        nsy = *prev(it);\n      }\n      if (S[sy] == 'W' && T[sx] == 'S') {\n        auto it = e.lower_bound(sy);\n        if (it == e.end()) continue;\n        nsy = *it;\n      }\n      nsum += abs(nsy - sy);\n    }\n    res.emplace_back(nsy, nsx, nsum);\n  }\n  return res;\n}\n\nvector<tuple<int,int,int>> prev_point(int sy, int sx) {\n  vector<tuple<int,int,int>> res;\n  REP(sdir,2) {\n    int nsy = sy, nsx = sx, nsum = 0;\n    if (sdir == 0) {\n      if (S[sy] == 'W' && T[sx] == 'N') {\n        auto it = s.lower_bound(sx + 1);\n        if (it == s.end()) continue;\n        nsx = *it;\n      }\n      if (S[sy] == 'E' && T[sx] == 'N') {\n        auto it = s.lower_bound(sx);\n        if (it == s.begin()) continue;\n        nsx = *prev(it);\n      }\n      if (S[sy] == 'W' && T[sx] == 'S') {\n        auto it = n.lower_bound(sx + 1);\n        if (it == n.end()) continue;\n        nsx = *it;\n      }\n      if (S[sy] == 'E' && T[sx] == 'S') {\n        auto it = n.lower_bound(sx);\n        if (it == n.begin()) continue;\n        nsx = *prev(it);\n      }\n      nsum += abs(nsx - sx);\n    }\n    if (sdir == 1) {\n      if (S[sy] == 'E' && T[sx] == 'S') {\n        auto it = w.lower_bound(sy);\n        if (it == w.begin()) continue;\n        nsy = *prev(it);\n      }\n      if (S[sy] == 'E' && T[sx] == 'N') {\n        auto it = w.lower_bound(sy + 1);\n        if (it == w.end()) continue;\n        nsy = *it;\n      }\n      if (S[sy] == 'W' && T[sx] == 'S') {\n        auto it = e.lower_bound(sy);\n        if (it == e.begin()) continue;\n        nsy = *prev(it);\n      }\n      if (S[sy] == 'W' && T[sx] == 'N') {\n        auto it = e.lower_bound(sy + 1);\n        if (it == e.end()) continue;\n        nsy = *it;\n      }\n      nsum += abs(nsy - sy);\n    }\n    res.emplace_back(nsy, nsx, nsum);\n  }\n  return res;\n}\n\nvoid solve(long long N, long long M, long long Q, std::string S, std::string T,\n           std::vector<long long> a, std::vector<long long> b,\n           std::vector<long long> c, std::vector<long long> d) {\n  // FILL IN HERE.\n  REP(i,N) {\n    if (S[i] == 'E') e.insert(i);\n    if (S[i] == 'W') w.insert(i);\n  }\n  REP(i,M) {\n    if (T[i] == 'N') n.insert(i);\n    if (T[i] == 'S') s.insert(i);\n  }\n  REP(i,Q) {\n    int sy = a[i];\n    int sx = b[i];\n    int ty = c[i];\n    int tx = d[i];\n    --sy; --sx; --ty; --tx;\n    int sum = abs(sy - ty) + abs(sx - tx);\n    if (subtask(sy, sx, ty, tx) == 0) {\n      cout << sum << endl;\n      continue;\n    }\n    int res = 1e9;\n    vector<tuple<int,int,int>> starts;\n    vector<tuple<int,int,int>> goals;\n\n    starts.emplace_back(sy, sx, 0);\n    for (auto t: next_point(sy, sx)) {\n      int y1, x1, sum1;\n      tie(y1, x1, sum1) = t;\n      // cout << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t) << endl;\n      starts.emplace_back(t);\n      for (auto t: next_point(y1, x1)) {\n        get<2>(t) += sum1;\n        // cout << \"  \" << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t) << endl;\n        starts.emplace_back(t);\n      }\n    }\n\n    goals.emplace_back(ty, tx, 0);\n    for (auto t: prev_point(ty, tx)) {\n      int y1, x1, sum1;\n      tie(y1, x1, sum1) = t;\n      // cout << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t) << endl;\n      goals.emplace_back(t);\n      for (auto t: prev_point(y1, x1)) {\n        get<2>(t) += sum1;\n        // cout << \"  \" << get<0>(t) << \" \" << get<1>(t) << \" \" << get<2>(t) << endl;\n        goals.emplace_back(t);\n      }\n    }\n\n    for (auto s: starts) {\n      for (auto t: goals) {\n        int sy, sx, sums;\n        int ty, tx, sumt;\n        tie(sy, sx, sums) = s;\n        tie(ty, tx, sumt) = t;\n        chmin(res, sums + sumt + subtask(sy, sx, ty, tx) + abs(sy - ty) + abs(sx - tx));\n      }\n    }\n\n    if (res >= 1e9) cout << -1 << endl;\n    else cout << res << endl;\n  }\n}\n\nint main() {\n  long long N;\n  scanf(\"%lld\", &N);\n  long long M;\n  scanf(\"%lld\", &M);\n  long long Q;\n  scanf(\"%lld\", &Q);\n  scanf(\"%s\", S);\n  scanf(\"%s\", T);\n  std::vector<long long> a(Q);\n  std::vector<long long> b(Q);\n  std::vector<long long> c(Q);\n  std::vector<long long> d(Q);\n  for (int i = 0; i < Q; i++) {\n    scanf(\"%lld\", &a[i]);\n    scanf(\"%lld\", &b[i]);\n    scanf(\"%lld\", &c[i]);\n    scanf(\"%lld\", &d[i]);\n  }\n  solve(N, M, Q, S, T, std::move(a), std::move(b), std::move(c), std::move(d));\n  return 0;\n}\n\n// ===== 2019/03/30 23:11:17 =====\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define ll long long\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nvector<int> N,W,E,S;\nint Findpre(vector<int> A,int x)\n{\n\tif(!A.size())return 1;\n\tint l=0,r=A.size()-1,ret=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(A[mid]<=x)ret=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn A[ret];\n}\nint Findsuf(vector<int> A,int x)\n{\n\tif(!A.size())return 1;\n\tint l=0,r=A.size()-1,ret=r;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(A[mid]>=x)ret=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn A[ret];\n}\nint n,m,Q;char dS[100100],dT[100100];\nstruct Line{int v,next,w;}e[1000];\nint bh[20][20],tot;\nint h[100],cnt;\ninline void Add(int u,int v,int w){e[cnt]=(Line){v,h[u],w};h[u]=cnt++;}\nint dis[200];bool vis[200];\nint SPFA(int S,int T)\n{\n\tfor(int i=1;i<=tot;++i)dis[i]=1e9,vis[i]=false;\n\tqueue<int> Q;Q.push(S);dis[S]=0;vis[S]=true;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=h[u];i;i=e[i].next)\n\t\t\tif(dis[e[i].v]>dis[u]+e[i].w)\n\t\t\t{\n\t\t\t\tdis[e[i].v]=dis[u]+e[i].w;\n\t\t\t\tif(!vis[e[i].v])vis[e[i].v]=true,Q.push(e[i].v);\n\t\t\t}\n\t\t//vis[u]=false;\n\t}\n\treturn dis[T]<1e9?dis[T]:-1;\n}\nint main()\n{\n\tn=read();m=read();Q=read();\n\tscanf(\"%s\",dS+1);scanf(\"%s\",dT+1);\n\tfor(int i=1;i<=n;++i)\n\t\tif(dS[i]=='E')E.push_back(i);\n\t\telse W.push_back(i);\n\tfor(int i=1;i<=m;++i)\n\t\tif(dT[i]=='N')N.push_back(i);\n\t\telse S.push_back(i);\n\twhile(Q--)\n\t{\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tvector<int> X,Y;\n\t\tX.push_back(Findpre(E,a));X.push_back(Findpre(W,a));\n\t\tX.push_back(Findsuf(E,a));X.push_back(Findsuf(W,a));\n\t\tX.push_back(Findpre(E,c));X.push_back(Findpre(W,c));\n\t\tX.push_back(Findsuf(E,c));X.push_back(Findsuf(W,c));\n\t\tY.push_back(Findpre(N,b));Y.push_back(Findpre(S,b));\n\t\tY.push_back(Findsuf(N,b));Y.push_back(Findsuf(S,b));\n\t\tY.push_back(Findpre(N,d));Y.push_back(Findpre(S,d));\n\t\tY.push_back(Findsuf(N,d));Y.push_back(Findsuf(S,d));\n\t\tsort(X.begin(),X.end());X.resize(unique(X.begin(),X.end())-X.begin());\n\t\tsort(Y.begin(),Y.end());Y.resize(unique(Y.begin(),Y.end())-Y.begin());\n\t\tint lx=X.size(),ly=Y.size(),S,T;tot=0;\n\t\tfor(int i=0;i<lx;++i)\n\t\t\tfor(int j=0;j<ly;++j)\n\t\t\t{\n\t\t\t\tbh[i][j]=++tot;\n\t\t\t\tif(X[i]==a&&Y[j]==b)S=tot;\n\t\t\t\tif(X[i]==c&&Y[j]==d)T=tot;\n\t\t\t}\n\t\tfor(int i=1;i<=tot;++i)h[i]=0;cnt=2;\n\t\tfor(int i=0;i<lx;++i)\n\t\t\tif(dS[X[i]]=='E')for(int j=0;j<ly-1;++j)Add(bh[i][j],bh[i][j+1],Y[j+1]-Y[j]);\n\t\t\telse for(int j=1;j<ly;++j)Add(bh[i][j],bh[i][j-1],Y[j]-Y[j-1]);\n\t\tfor(int i=0;i<ly;++i)\n\t\t\tif(dT[Y[i]]=='N')for(int j=1;j<lx;++j)Add(bh[j][i],bh[j-1][i],X[j]-X[j-1]);\n\t\t\telse for(int j=0;j<lx-1;++j)Add(bh[j][i],bh[j+1][i],X[j+1]-X[j]);\n\t\tprintf(\"%d\\n\",SPFA(S,T));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(s[a] == 'W'){\n\t\t//左\n\t\tint x = POSL(up,min(d,b));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSL(up,b) > 0){\n\t\t    x = POSL(up,b); x--;\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSL(dw,min(d,b));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSL(dw,b) > 0){\n\t\t    y = POSL(dw,b); y--;\n\t\t    on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(up,max(d,b));\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSU(up,b) != up.size()){\n\t\t    x = POSU(up,b);\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSU(dw,max(d,b));\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSU(dw,b) != dw.size()){\n\t\t    y = POSU(dw,b);\n\t\t   on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(t[b] == 'N'){\n\t\t//上\n\t\tint x = POSL(le,min(a,c));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSL(le,a)){\n\t\t    x = POSL(le,a)-1;\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSL(ri,min(a,c));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSL(ri,a)){\n\t\t    y = POSL(ri,a)-1;\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(le,max(a,c));\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSU(le,a) != le.size()){\n\t\t    x = POSU(le,a);\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSU(ri,max(a,c));\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSU(ri,a) != ri.size()){\n\t\t    y = POSU(ri,a);\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,4,0);\n\t\ton_y(a,b,c,d,4,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\n\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\n\tfor(int i=1;i<=q;i++)\t\n\t{\n\t\tpii s=from[i],t=dest[i];\n\t\t\n\t\tif(s.first>t.first or s.second>t.second) continue;\n\t\t#define case0 case0\n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=ub(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][1]),z=ub(t.first,path[0][0]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n//\t\tif(s.second==t.second) continue;\n\t\t#define case1 case1\n\t\tfor(;s.first<=t.first;)\n\t\t{\n\t\t\tint x=lb(s.first,path[0][1]);\n\t\t\tif(!x) break;int tmp=abs(s.first-x)+abs(t.first-x)+abs(s.second-t.second);\n\t\t\tint zyz;\n\t\t\tif(x!=s.first) \n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][0]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;zyz=y;\n\t\t\t}\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or y<zyz) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t#define case2 case2\n\n\t\tfor(;s.first<t.first;)\n\t\t{\n\t\t\tint x=ub(s.first,path[0][1]);\n\t\t\tif(x>=t.first or x<=s.first) break;int tmp=abs(s.second-t.second)+abs(s.first-t.first);\n\t\t\tint at=1e9,bt=1e9;\n\t\t\tint zyz;\n\t\t\tif(1)\n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][1]);if(!y) break;\n\t\t\t\tzyz=y;tmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\t\n\t\t\t//copied from  line58\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or (y<zyz)) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//licensed\n\t\t}\n\t}\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\t\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) dir[0][i]^=1;for(int i=1;i<=m;i++) dir[1][i]^=1;\n\tfor(int i=1;i<=q;i++) swap(from[i],dest[i]);\n\t\n\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 100 * 1000 + 7;\nconst int INF = 1e9 + 7;\n\nbool rg[MX], up[MX];\nint n, m;\n\nvector<int> gl, gr, gu, gd;\n\nint d[107][107];\n\nbool can_go(int x1, int y1, int x2, int y2) {\n    if (x1 == x2) {\n        if (y1 < y2) {\n            return rg[x1];\n        } else {\n            return !rg[x1];\n        }\n    } else if (y1 == y2) {\n        if (x2 < x1) {\n            return up[y1];\n        } else {\n            return !up[y1];\n        }\n    }\n    return false;\n}\n\nvector<pair<int, int> > trace(int x, int y, int depth, bool rev) {\n    vector<pair<int, int> > ans;\n    queue<pair<int, int> > q;\n    set<pair<int, int> > was;\n\n    auto ad = [&](int x, int y) {\n        if (was.count(make_pair(x, y))) {\n            return;\n        }\n        was.emplace(x, y);\n        q.emplace(x, y);\n        if (ans.size() < depth) {\n            ans.emplace_back(x, y);\n        }\n    };\n\n    ad(x, y);\n    while (!q.empty()) {\n        int x, y;\n        tie(x, y) = q.front();\n        if (ans.size() > depth) {\n            break;\n        }\n        q.pop();\n        if (rg[x] ^ rev) {\n            {\n                int yy = lower_bound(gu.begin(), gu.end(), y) - gu.begin();\n                if (yy != gu.size()) {\n                    yy = gu[yy];\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = lower_bound(gd.begin(), gd.end(), y) - gd.begin();\n                if (yy != gd.size()) {\n                    yy = gd[yy];\n                    ad(x, yy);\n                }\n            }\n        } else {\n            {\n                int yy = upper_bound(gu.begin(), gu.end(), y) - gu.begin() - 1;\n                if (yy >= 0) {\n                    yy = gu[yy];\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = upper_bound(gd.begin(), gd.end(), y) - gd.begin() - 1;\n                if (yy >= 0) {\n                    yy = gd[yy];\n                    ad(x, yy);\n                }\n            }\n        }\n\n        if ((!up[y]) ^ rev) {\n            {\n                int xx = lower_bound(gl.begin(), gl.end(), x) - gl.begin();\n                if (xx != gl.size()) {\n                    xx = gl[xx];\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = lower_bound(gr.begin(), gr.end(), x) - gr.begin();\n                if (xx != gr.size()) {\n                    xx = gr[xx];\n                    ad(xx, y);\n                }\n            }\n        } else {\n            {\n                int xx = upper_bound(gl.begin(), gl.end(), x) - gl.begin() - 1;\n                if (xx >= 0) {\n                    xx = gl[xx];\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = upper_bound(gr.begin(), gr.end(), x) - gr.begin() - 1;\n                if (xx >= 0) {\n                    xx = gr[xx];\n                    ad(xx, y);\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint dist(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int q;\n    cin >> n >> m >> q;\n    string s;\n    cin >> s;\n    for (int i = 1; i <= n; i++) {\n        if (s[i - 1] == 'E') {\n            rg[i] = true;\n            gl.push_back(i);\n        } else {\n            gr.push_back(i);\n        }\n    }\n    cin >> s;\n    for (int i = 1; i <= m; i++) {\n        if (s[i - 1] == 'N') {\n            up[i] = true;\n            gu.push_back(i);\n        } else {\n            gd.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        vector<pair<int, int> > t1 = trace(x1, y1, 5, false);\n        vector<pair<int, int> > t2 = trace(x2, y2, 5, true);\n        vector<int> xx, yy;\n        for (auto v : t1) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        for (auto v : t2) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        sort(xx.begin(), xx.end());\n        sort(yy.begin(), yy.end());\n        xx.resize(unique(xx.begin(), xx.end()) - xx.begin());\n        yy.resize(unique(yy.begin(), yy.end()) - yy.begin());\n        int n = xx.size(), m = yy.size();\n        set<tuple<int, int, int> > go;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                d[i][j] = INF;\n                if (xx[i] == x1 && yy[j] == y1) {\n                    d[i][j] = 0;\n                }\n                go.emplace(d[i][j], i, j);\n            }\n        }\n        /*\n        cerr << \"X: \";\n        for (int x : xx) {\n            cerr << x << \" \";\n        }\n        cerr << endl;\n        cerr << \"Y: \";\n        for (int y : yy) {\n            cerr << y << \" \";\n        }\n        cerr << endl;\n*/\n\n        while (!go.empty()) {\n            int D, x, y;\n            tie(D, x, y) = *go.begin();\n            go.erase(go.begin());\n            for (int gy = 0; gy < (int)yy.size(); gy++) {\n                if (can_go(xx[x], yy[y], xx[x], yy[gy]) && d[x][gy] > d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy])) {\n                    go.erase(make_tuple(d[x][gy], x, gy));\n                    d[x][gy] = d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy]);\n                    go.insert(make_tuple(d[x][gy], x, gy));\n                }\n            }\n            for (int gx = 0; gx < (int)xx.size(); gx++) {\n                if (can_go(xx[x], yy[y], xx[gx], yy[y]) && d[gx][y] > d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y])) {\n                    go.erase(make_tuple(d[gx][y], gx, y));\n                    d[gx][y] = d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y]);\n                    go.insert(make_tuple(d[gx][y], gx, y));\n                }\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (xx[i] == x2 && yy[j] == y2) {\n                    ans = d[i][j];\n                }\n            }\n        }\n\n        if (ans == INF) {\n            ans = -1;\n        }\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define inf 1000000000\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[100005], prer[100005], nextl[100005], nextr[100005];\nllint preu[100005], pred[100005], nextu[100005], nextd[100005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i+1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i+1] == 'S') nextd[i] = i+1;\n\t}\n\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_set>\n# include <unordered_map>\nusing namespace std;\n\n\nint n, m, qq;\nstring s1, s2;\nint ans;\nint XX, YY;\nint pr1[100005][2];\nint sf1[100005][2];\nint pr2[100005][2];\nint sf2[100005][2];\n\nvoid upd(int x) {\n    if (x < ans) ans = x;\n    return;\n}\n\nvoid check(int x, int y, int len) {\n    if (XX == x && YY == y) { upd(len); return;}\n    len += abs(x - XX) + abs(y - YY);\n    if (XX == x) {\n        if ((YY < y && s1[x] == 'W') || (YY > y && s1[x] == 'E')) { upd(len);}\n        return;\n    }\n    if (YY == y) {\n        if ((XX < x && s2[y] == 'N') || (XX > x && s2[y] == 'S')) upd(len);\n        return;\n    }\n    char c1, c2;\n    if (XX > x) c1 = 'S';\n    else c1 = 'N';\n    if (YY > y) c2 = 'E';\n    else c2 = 'W';\n    if ((s1[x] == c2 && s2[YY] == c1) || (s2[y] == c1 && s1[XX] == c2)) upd(len);\n    return;\n}\n\nvoid recurs(int x, int y, int d, int len) {\n    check(x, y, len);\n    if (d == 10) return;\n    if (s1[x] == 'E' && s2[y] == 'N') {\n        if (sf2[y][1]) recurs(x, sf2[y][1], d + 1, len + sf2[y][1] - y);\n        if (pr1[x][1]) recurs(pr1[x][1], y, d + 1, len + x - pr1[x][1]);\n    } else if (s1[x] == 'E' && s2[y] == 'S') {\n        if (sf2[y][0]) recurs(x, sf2[y][0], d + 1, len + sf2[y][0] - y);\n        if (sf1[x][1]) recurs(sf1[x][1], y, d + 1, len + sf1[x][1] - x);\n    } else if (s1[x] == 'W' && s2[y] == 'N') {\n        if (pr2[y][1]) recurs(x, pr2[y][1], d + 1, len + y - pr2[y][1]);\n        if (pr1[x][0]) recurs(pr1[x][0], y, d + 1, len + x - pr1[x][0]);\n    } else {\n        if (pr2[y][0]) recurs(x, pr2[y][0], d + 1, len + y - pr2[y][0]);\n        if (sf1[x][0]) recurs(sf1[x][0], y, d + 1, len + sf1[x][0] - x);\n    }\n    return;\n}\n\nint main(int argc, const char * argv[]) {\n//    freopen(\"/Users/danya.smelskiy/Documents/Danya/Resources/input.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m >> qq;\n    cin >> s1 >> s2;\n    s1 = \"#\" + s1;\n    s2 = \"#\" + s2;\n    \n    for (int i = 1; i <= n; ++i) {\n        pr1[i][0] = pr1[i - 1][0];\n        pr1[i][1] = pr1[i - 1][1];\n        if (s1[i] == 'E') pr1[i][0] = i;\n        else pr1[i][1] = i;\n    }\n    for (int i = n; i > 0; --i) {\n        sf1[i][0] = sf1[i + 1][0];\n        sf1[i][1] = sf1[i + 1][1];\n        if (s1[i] == 'E') sf1[i][0] = i;\n        else sf1[i][1] = i;\n    }\n    \n    for (int i = 1; i <= m; ++i) {\n        pr2[i][0] = pr2[i - 1][0];\n        pr2[i][1] = pr2[i - 1][1];\n        if (s2[i] == 'N') pr2[i][0] = i;\n        else pr2[i][1] = i;\n    }\n    for (int i = m; i > 0; --i) {\n        sf2[i][0] = sf2[i + 1][0];\n        sf2[i][1] = sf2[i + 1][1];\n        if (s2[i] == 'N') sf2[i][0] = i;\n        else sf2[i][1] = i;\n    }\n    int x, y;\n    while (qq--) {\n        cin >> x >> y >> XX >> YY;\n        ans = 1e9;\n        recurs(x, y, 0, 0);\n        if (ans < 1e9) cout << ans << '\\n';\n        else cout << \"-1\\n\";\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  vector<int> pnu(m),psu(m);\n  vector<int> pnl(m),psl(m);\n  for(int j=0;j<m;j++){    \n    pnu[j]=*--upper_bound(vn.begin(),vn.end(),j);\n    psu[j]=*--upper_bound(vs.begin(),vs.end(),j);    \n    pnl[j]=*lower_bound(vn.begin(),vn.end(),j);\n    psl[j]=*lower_bound(vs.begin(),vs.end(),j);\n  }\n  \n  vector<int> pwu(n),peu(n);\n  vector<int> pwl(n),pel(n);\n  for(int i=0;i<n;i++){    \n    pwu[i]=*--upper_bound(vw.begin(),vw.end(),i);\n    peu[i]=*--upper_bound(ve.begin(),ve.end(),i);    \n    pwl[i]=*lower_bound(vw.begin(),vw.end(),i);\n    pel[i]=*lower_bound(ve.begin(),ve.end(),i);\n  }      \n  \n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using ll = long long;    \n    auto T=[&](int y,int x,int step){return ((ll)y<<40)|((ll)x<<20)|(ll)step;};\n    unordered_map<ll, int> dp;\n    using P = pair<int, ll>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      ll st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      y=(st>>40);\n      x=(st>>20)^((ll)y<<20);\n      step=st&((1<<20)-1);\n      \n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(abs(ny)==INF||abs(nx)==INF) return;\n          if(ny==y&&nx==x) return;          \n          if(dp.count(T(ny,nx,ns))&&dp[T(ny,nx,ns)]<=nd) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        for(int xx:{x,d}){\n          // N           \n          if(pnu[xx]<=x)\n            push(y,pnu[xx],step+1,sum+abs(pnu[xx]-x));\n          // S\n          if(psu[xx]<=x)\n            push(y,psu[xx],step+1,sum+abs(psu[xx]-x));\n        }\n      }else{\n        for(int xx:{x,d}){\n          // N           \n          if(pnl[xx]>=x)\n            push(y,pnl[xx],step+1,sum+abs(pnl[xx]-x));\n          // S\n          if(psl[xx]>=x)\n            push(y,psl[xx],step+1,sum+abs(psl[xx]-x));\n        }\n      }\n      if(t[x]=='N'){\n        for(int yy:{y,c}){\n          // W\n          if(pwu[yy]<=y)\n            push(pwu[yy],x,step+1,sum+abs(pwu[yy]-y));\n          // E\n          if(peu[yy]<=y)\n            push(peu[yy],x,step+1,sum+abs(peu[yy]-y));\n        }\n      }else{        \n        for(int yy:{y,c}){\n          // W\n          if(pwl[yy]>=y)\n            push(pwl[yy],x,step+1,sum+abs(pwl[yy]-y));\n          // E\n          if(pel[yy]>=y)\n            push(pel[yy],x,step+1,sum+abs(pel[yy]-y));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing ll = long long;\nusing i_i = tuple<int, int>;\nusing ll_i = tuple<ll, int>;\nstruct edge { int v, w; };\n\nvector<ll> dijkstra(int N, vector<vector<edge> >& G, int s) {\n\tvector<ll> d(N, LLONG_MAX); d[s] = 0;\n\tpriority_queue<ll_i, vector<ll_i>, greater<ll_i> > pq;\n\tpq.push(ll_i(0, s));\n\twhile (pq.size()) {\n\t\tll_i p = pq.top(); pq.pop();\n\t\tint u = get<1>(p);\n\t\tif (get<0>(p) > d[u]) continue;\n\t\tfor (edge e: G[u])\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tpq.push(ll_i(d[e.v], e.v));\n\t\t\t}\n\t}\n\treturn d;\n}\n\nconst int e5 = 1e5;\n\nint a[e5], b[e5];\n\nvoid f(int l, int r, vector<int>& from, vector<int>& to, bool mi, bool ma) {\n    if (mi) {\n        auto it = lower_bound(all(from), l);\n        if (it != from.end()) {\n            int i = *it;\n            if (l <= i && i <= r) to.pb(i);\n        }\n    }\n    if (ma) {\n        auto it = upper_bound(all(from), r);\n        if (it != from.begin()) {\n            int i = *prev(it);\n            if (l <= i && i <= r) to.pb(i);\n        }\n    }\n}\n\nint main() {\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    string s, t;\n    cin >> s >> t;\n    vector<int> a(N), b(M);\n    rep(i, N) a[i] = (s[i] == 'E');\n    rep(j, M) b[j] = (t[j] == 'S');\n    vector<vector<int>> A(2), B(2);\n    rep(i, N) A[a[i]].pb(i);\n    rep(j, M) B[b[j]].pb(j);\n    while (Q--) {\n        int i_s, j_s, i_t, j_t;\n        scanf(\"%d%d%d%d\", &i_s, &j_s, &i_t, &j_t);\n        i_s--; j_s--; i_t--; j_t--;\n        vector<int> I = {-1, N, i_s, i_t};\n        vector<int> J = {-1, M, j_s, j_t};\n        sort(all(I)); sort(all(J));\n        I.erase(unique(all(I)), I.end());\n        J.erase(unique(all(J)), J.end());\n        vector<int> R, C;\n        for (int i: I) rep(z, 2) f(i, i, A[z], R, 0, 1);\n        for (int j: J) rep(z, 2) f(j, j, B[z], C, 0, 1);\n        rep(k, I.size() - 1) rep(z, 2) f(I[k] + 1, I[k + 1] - 1, A[z], R, k, !k);\n        rep(k, J.size() - 1) rep(z, 2) f(J[k] + 1, J[k + 1] - 1, B[z], C, k, !k);\n        sort(all(R)); sort(all(C));\n        R.erase(unique(all(R)), R.end());\n        C.erase(unique(all(C)), C.end());\n        /*\n        for (int y: R) cout << y << ' ';\n        cout << endl;\n        for (int x: C) cout << x << ' ';\n        cout << endl;\n        */\n        int H = R.size(), W = C.size();\n        vector<vector<edge>> G(H * W);\n        rep(i, H) rep(j, W - 1) {\n            int y = R[i];\n            if (a[y]) G[i * W + j].pb(edge{i * W + j + 1, C[j + 1] - C[j]});\n            if (!a[y]) G[i * W + j + 1].pb(edge{i * W + j, C[j + 1] - C[j]});\n        }\n        rep(j, W) rep(i, H - 1) {\n            int x = C[j];\n            if (b[x]) G[i * W + j].pb(edge{(i + 1) * W + j, R[i + 1] - R[i]});\n            if (!b[x]) G[(i + 1) * W + j].pb(edge{i * W + j, R[i + 1] - R[i]});\n        }\n        int y_s = lower_bound(all(R), i_s) - R.begin();\n        int x_s = lower_bound(all(C), j_s) - C.begin();\n        int y_t = lower_bound(all(R), i_t) - R.begin();\n        int x_t = lower_bound(all(C), j_t) - C.begin();\n        // cout << y_s << ' ' << x_s << ' ' << y_t << ' ' << x_t << endl;\n        auto d = dijkstra(H * W, G, y_s * W + x_s);\n        ll ans = d[y_t * W + x_t];\n        if (ans == LLONG_MAX) ans = -1;\n        printf(\"%lld\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 100000000000000000\n\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[200005], prer[200005], nextl[200005], nextr[200005];\nllint preu[200005], pred[200005], nextu[200005], nextd[200005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i+1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i+1] == 'S') nextd[i] = i+1;\n\t}\n\t\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = 205;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to, cost;\n\tedge(){}\n\tedge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint H, W, Q;\nstring s, t;\nint prel[100005], prer[100005], nextl[100005], nextr[100005];\nint preu[100005], pred[100005], nextu[100005], nextd[100005];\nvector<int> vecx, vecy;\nvector<edge> G[205];\nint dist[205];\nint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(int sx, int gx, vector<int> &vec, int N)\n{\n\tvec.clear();\n\tvec.push_back(sx);\n\tvec.push_back(preu[sx]);\n\tvec.push_back(pred[sx]);\n\tvec.push_back(nextu[sx]);\n\tvec.push_back(nextd[sx]);\n\tvec.push_back(gx);\n\tvec.push_back(preu[gx]);\n\tvec.push_back(pred[gx]);\n\tvec.push_back(nextu[gx]);\n\tvec.push_back(nextd[gx]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(int i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\telse prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(int i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\telse nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(int i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\telse pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(int i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\telse nextd[i] = i+1;\n\t}\n\n\tint sx, sy, gx, gy;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W);\n\t\tmake(sy, gy, vecy, H);\n\t\t\n\t\tint w = vecx.size(), h = vecy.size();\n\t\tfor(int i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\tint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint SX, GX, SY, GY;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << endl;\n\t\telse cout << dist[T] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nchar S[110000];\nchar T[110000];\nint zx[10];\nint zy[10];\nvector<int>W;\nvector<int>E;\nvector<int>N;\nvector<int>D;\nint ijk[10][10];\nint v[10][10];\nint calc(int X1,int Y1,int X2,int Y2,int n,int m){\n\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++){\n\t\tv[i][j]=0;\n\t\tijk[i][j]=mod;\n\t}\n\t//for(int i=0;i<n;i++)printf(\"%d \",zx[i]);printf(\"\\n\");\n\t//for(int i=0;i<m;i++)printf(\"%d \",zy[i]);printf(\"\\n\");\n\t\t\n\tint XX1=lower_bound(zx,zx+n,X1)-zx;\n\tint YY1=lower_bound(zy,zy+m,Y1)-zy;\n\tint XX2=lower_bound(zx,zx+n,X2)-zx;\n\tint YY2=lower_bound(zy,zy+m,Y2)-zy;\n\tijk[XX1][YY1]=0;\n\tpriority_queue<pair<int,pair<int,int> > >Q;\n\tQ.push(make_pair(0,make_pair(XX1,YY1)));\n\twhile(Q.size()){\n\t\tint cost=-Q.top().first;\n\t\tint row=Q.top().second.first;\n\t\tint col=Q.top().second.second;\n\t\tQ.pop();\n\t\tif(v[row][col])continue;\n\t\tv[row][col]=1;\n\t\tif(S[zx[row]]=='E'){\n\t\t\tif(col<m-1){\n\t\t\t\tint toc=cost+zy[col+1]-zy[col];\n\t\t\t\tif(v[row][col+1]==0&&ijk[row][col+1]>toc){\n\t\t\t\t\tijk[row][col+1]=toc;\n\t\t\t\t\tQ.push(make_pair(-toc,make_pair(row,col+1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(col){\n\t\t\t\tint toc=cost+zy[col]-zy[col-1];\n\t\t\t\tif(v[row][col-1]==0&&ijk[row][col-1]>toc){\n\t\t\t\t\tijk[row][col-1]=toc;\n\t\t\t\t\tQ.push(make_pair(-toc,make_pair(row,col-1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(T[zy[col]]=='S'){\n\t\t\tif(row<n-1){\n\t\t\t\tint toc=cost+zx[row+1]-zx[row];\n\t\t\t\tif(v[row+1][col]==0&&ijk[row+1][col]>toc){\n\t\t\t\t\tijk[row+1][col]=toc;\n\t\t\t\t\tQ.push(make_pair(-toc,make_pair(row+1,col)));\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tif(row){\n\t\t\t\tint toc=cost+zx[row]-zx[row-1];\n\t\t\t\tif(v[row-1][col]==0&&ijk[row-1][col]>toc){\n\t\t\t\t\tijk[row-1][col]=toc;\n\t\t\t\t\tQ.push(make_pair(-toc,make_pair(row-1,col)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ijk[XX2][YY2]==mod)return -1;\n\telse return ijk[XX2][YY2];\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tscanf(\"%s%s\",S,T);\n\tfor(int i=0;i<a;i++){\n\t\tif(S[i]=='W')W.push_back(i);\n\t\telse E.push_back(i);\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tif(T[i]=='N')N.push_back(i);\n\t\telse D.push_back(i);\n\t}\n\twhile(c--){\n\t\tint X1,Y1,X2,Y2;\n\t\tscanf(\"%d%d%d%d\",&X1,&Y1,&X2,&Y2);\n\t\tX1--;Y1--;X2--;Y2--;\n\t\tint xs=0;\n\t\tint ys=0;\n\t\tzx[xs++]=X1;\n\t\tzx[xs++]=X2;\n\t\t\n\t\tint at=lower_bound(W.begin(),W.end(),X1)-W.begin();\n\t\tif(at<W.size()&&W[at]==X1){\n\t\t\tat=lower_bound(E.begin(),E.end(),X1)-E.begin();\n\t\t\tif(at)zx[xs++]=E[at-1];\n\t\t\tif(at<E.size())zx[xs++]=E[at];\n\t\t}else{\n\t\t\tif(at)zx[xs++]=W[at-1];\n\t\t\tif(at<W.size())zx[xs++]=W[at];\n\t\t}\n\t\tat=lower_bound(W.begin(),W.end(),X2)-W.begin();\n\t\tif(at<W.size()&&W[at]==X2){\n\t\t\tat=lower_bound(E.begin(),E.end(),X2)-E.begin();\n\t\t\tif(at)zx[xs++]=E[at-1];\n\t\t\tif(at<E.size())zx[xs++]=E[at];\n\t\t}else{\n\t\t\tif(at)zx[xs++]=W[at-1];\n\t\t\tif(at<W.size())zx[xs++]=W[at];\n\t\t}\n\n\n\t\tzy[ys++]=Y1;\n\t\tzy[ys++]=Y2;\n\t\tat=lower_bound(N.begin(),N.end(),Y1)-N.begin();\n\t\tif(at<N.size()&&N[at]==Y1){\n\t\t\tat=lower_bound(D.begin(),D.end(),Y1)-D.begin();\n\t\t\tif(at)zy[ys++]=D[at-1];\n\t\t\tif(at<D.size())zy[ys++]=D[at];\n\t\t}else{\n\t\t\tif(at)zy[ys++]=N[at-1];\n\t\t\tif(at<N.size())zy[ys++]=N[at];\n\t\t}\n\t\tat=lower_bound(N.begin(),N.end(),Y2)-N.begin();\n\t\tif(at<N.size()&&N[at]==Y2){\n\t\t\tat=lower_bound(D.begin(),D.end(),Y2)-D.begin();\n\t\t\tif(at)zy[ys++]=D[at-1];\n\t\t\tif(at<D.size())zy[ys++]=D[at];\n\t\t}else{\n\t\t\tif(at)zy[ys++]=N[at-1];\n\t\t\tif(at<N.size())zy[ys++]=N[at];\n\t\t}\n\t\tstd::sort(zx,zx+xs);\n\t\tstd::sort(zy,zy+ys);\n\t\tprintf(\"%d\\n\",calc(X1,Y1,X2,Y2,xs,ys));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#define N 0\n#define S 1\n#define E 2\n#define W 3\n\nusing namespace std;\n\nint n , m , q;\nchar ch[10] = \"NSEW\";\nchar s[120000] , t[120000];\nint nxt[5][120000] , pre[5][120000];\nint x1 , y1 , x2 , y2;\nint ans;\nint check ( int x , int y , int to , int del ) {\n\tint ok = 0;\n\tif ( (x==x2&&(to==E||to==W)) || (y==y2&&(to==N||to==S)) ) {\n\t\tok = 1;\n\t}\n\telse {\n\t\tif ( to == N || to == S ) {\n\t\t\tif ( (y>y2&&s[x2]=='W') || (y<y2&&s[x2]=='E') ) ok = 1;\n\t\t}\n\t\tif ( to == E || to == W ) {\n\t\t\tif ( (x<x2&&t[y2]=='S') || (x>x2&&t[y2]=='N') ) ok = 1;\n\t\t}\n\t}\n\t//printf ( \"chk %d %d %c %d %d\\n\" , x , y , ch[to] , del , ok );\n\tif ( !ok ) return 0;\n\tans = min ( ans , del + abs(x-x2) + abs(y-y2) );\n\treturn 1;\n}\nvoid dfs ( int dep , int x , int y , int to , int del ) {\n\t//printf ( \"%d %d %d %c %d\\n\" , dep , x , y , ch[to] , del );\n\tif ( x == 0 || y == 0 ) return ;\n\tint face = 0;\n\tif ( to == N && x >= x2 ) face = 1;\n\tif ( to == S && x <= x2 ) face = 1;\n\tif ( to == E && y <= y2 ) face = 1;\n\tif ( to == W && y >= y2 ) face = 1;\n\tif ( face && check ( x , y , to , del ) ) return ;\n\tif ( dep > 4 ) return ;\n\tif ( to == N ) {\n\t\tdfs ( dep + 1 , pre[E][x] , y , E , del + abs(x-pre[E][x]) );\n\t\tdfs ( dep + 1 , pre[W][x] , y , W , del + abs(x-pre[W][x]) );\n\t}\n\tif ( to == S ) {\n\t\tdfs ( dep + 1 , nxt[E][x] , y , E , del + abs(x-nxt[E][x]) );\n\t\tdfs ( dep + 1 , nxt[W][x] , y , W , del + abs(x-nxt[W][x]) );\n\t}\n\tif ( to == E ) {\n\t\tdfs ( dep + 1 , x , nxt[N][y] , N , del + abs(y-nxt[N][y]) );\n\t\tdfs ( dep + 1 , x , nxt[S][y] , S , del + abs(y-nxt[S][y]) );\n\t}\n\tif ( to == W ) {\n\t\tdfs ( dep + 1 , x , pre[N][y] , N , del + abs(y-pre[N][y]) );\n\t\tdfs ( dep + 1 , x , pre[S][y] , S , del + abs(y-pre[S][y]) );\n\t}\n\tif ( face ) {\n\t\tif ( to == N ) {\n\t\t\tdfs ( dep + 1 , pre[E][x2] , y , E , del + abs(x-pre[E][x2]) );\n\t\t\tdfs ( dep + 1 , pre[W][x2] , y , W , del + abs(x-pre[W][x2]) );\n\t\t}\n\t\tif ( to == S ) {\n\t\t\tdfs ( dep + 1 , nxt[E][x2] , y , E , del + abs(x-nxt[E][x2]) );\n\t\t\tdfs ( dep + 1 , nxt[W][x2] , y , W , del + abs(x-nxt[W][x2]) );\n\t\t}\n\t\tif ( to == E ) {\n\t\t\tdfs ( dep + 1 , x , nxt[N][y2] , N , del + abs(y-nxt[N][y2]) );\n\t\t\tdfs ( dep + 1 , x , nxt[S][y2] , S , del + abs(y-nxt[S][y2]) );\n\t\t}\n\t\tif ( to == W ) {\n\t\t\tdfs ( dep + 1 , x , pre[N][y2] , N , del + abs(y-pre[N][y2]) );\n\t\t\tdfs ( dep + 1 , x , pre[S][y2] , S , del + abs(y-pre[S][y2]) );\n\t\t}\n\t}\n}\nvoid work () {\n\tint i , j;\n\tscanf ( \"%d%d%d\" , &n , &m , &q );\n\tscanf ( \"%s\" , s + 1 );\n\tscanf ( \"%s\" , t + 1 );\n\tfor ( i = 1 ; i <= n ; i++ ) {\n\t\tpre[E][i] = pre[E][i-1];\n\t\tpre[W][i] = pre[W][i-1];\n\t\tif ( s[i] == 'E' ) pre[E][i] = i;\n\t\telse pre[W][i] = i;\n\t}\n\tfor ( i = n ; i >= 1 ; i-- ) {\n\t\tnxt[E][i] = nxt[E][i+1];\n\t\tnxt[W][i] = nxt[W][i+1];\n\t\tif ( s[i] == 'E' ) nxt[E][i] = i;\n\t\telse nxt[W][i] = i;\n\t}\n\tfor ( i = 1 ; i <= m ; i++ ) {\n\t\tpre[S][i] = pre[S][i-1];\n\t\tpre[N][i] = pre[N][i-1];\n\t\tif ( t[i] == 'S' ) pre[S][i] = i;\n\t\telse pre[N][i] = i;\n\t}\n\tfor ( i = m ; i >= 1 ; i-- ) {\n\t\tnxt[S][i] = nxt[S][i+1];\n\t\tnxt[N][i] = nxt[N][i+1];\n\t\tif ( t[i] == 'S' ) nxt[S][i] = i;\n\t\telse nxt[N][i] = i;\n\t}\n\t//for ( i = 0 ; i <= 3 ; i++ )\n\t//\tfor ( j = 1 ; j <= m ; j++ )\n\t//\t\tprintf ( \"%d %d %d %d\\n\" , i , j , pre[i][j] , nxt[i][j] );\n\tfor ( i = 1 ; i <= q ; i++ ) {\n\t\tscanf ( \"%d%d%d%d\" , &x1 , &y1 , &x2 , &y2 );\n\t\tans = 21000000;\n\t\tdfs ( 0 , x1 , y1 , s[x1]=='E'?E:W , 0 );\n\t\tdfs ( 0 , x1 , y1 , t[y1]=='S'?S:N , 0 );\n\t\tif ( ans == 21000000 ) ans = -1;\n\t\tprintf ( \"%d\\n\" , ans );\n\t}\n}\nint main () {\n\twork ();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "4 5 4 EEWW NSNNS 4 1 1 4 1 3 1 2 4 2 3 2 3 3 3 5"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 100000000000000000\n\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[200005], prer[200005], nextl[200005], nextr[200005];\nllint preu[200005], pred[200005], nextu[200005], nextd[200005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i+1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i+1] == 'S') nextd[i] = i+1;\n\t}\n\t\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <deque>\n#include <cmath>\n#include <cassert>\n#define SIZE 200005\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nchar S[SIZE],T[SIZE];\nint A[SIZE],B[SIZE],C[SIZE],D[SIZE];\nint dw[SIZE],de[SIZE],dw2[SIZE],de2[SIZE];\nint ds[SIZE],dn[SIZE],ds2[SIZE],dn2[SIZE];\nint rs[SIZE],re[SIZE];\nint ans[SIZE];\nint n,m,q;\n\n//South : +1\n//East  : +1\nvoid solve()\n{\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tdw[i]=de[i]=-1;\n\t\tif(i>0)\n\t\t{\n\t\t\tif(dw[i-1]!=-1) dw[i]=dw[i-1]+1;\n\t\t\tif(de[i-1]!=-1) de[i]=de[i-1]+1;\n\t\t}\n\t\tif(T[i]=='E') de[i]=0;\n\t\telse dw[i]=0;\n\t}\n\tfor(int i=m-1;i>=0;i--)\n\t{\n\t\tdw2[i]=de2[i]=-1;\n\t\tif(i+1<m)\n\t\t{\n\t\t\tif(dw2[i+1]!=-1) dw2[i]=dw2[i+1]+1;\n\t\t\tif(de2[i+1]!=-1) de2[i]=de2[i+1]+1;\n\t\t}\n\t\tif(T[i]=='E') de2[i]=0;\n\t\telse dw2[i]=0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tds[i]=dn[i]=-1;\n\t\tif(i>0)\n\t\t{\n\t\t\tif(ds[i-1]!=-1) ds[i]=ds[i-1]+1;\n\t\t\tif(dn[i-1]!=-1) dn[i]=dn[i-1]+1;\n\t\t}\n\t\tif(S[i]=='S') ds[i]=0;\n\t\telse dn[i]=0;\n\t}\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tds2[i]=dn2[i]=-1;\n\t\tif(i+1<n)\n\t\t{\n\t\t\tif(ds2[i+1]!=-1) ds2[i]=ds2[i+1]+1;\n\t\t\tif(dn2[i+1]!=-1) dn2[i]=dn2[i+1]+1;\n\t\t}\n\t\tif(S[i]=='S') ds2[i]=0;\n\t\telse dn2[i]=0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trs[i]=(S[i]=='S');\n\t\tif(i>0) rs[i]+=rs[i-1];\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tre[i]=(T[i]=='E');\n\t\tif(i>0) re[i]+=re[i-1];\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tif(A[i]<=C[i]&&B[i]<=D[i])\n\t\t{\n\t\t\tans[i]=-1;\n\t\t\tif(A[i]==C[i]&&S[A[i]]=='S') ans[i]=D[i]-B[i];\n\t\t\telse if(B[i]==D[i]&&T[B[i]]=='E') ans[i]=C[i]-A[i];\n\t\t\telse\n\t\t\t{\n\t\t\t\tint ms=-1;\n\t\t\t\tif(S[A[i]]=='S') ms=0;\n\t\t\t\telse if(dw[B[i]]!=-1&&ds[A[i]]!=-1) ms=(dw[B[i]]+ds[A[i]])*2;\n\t\t\t\tint me=-1;\n\t\t\t\tif(T[B[i]]=='E') me=0;\n\t\t\t\telse if(de[B[i]]!=-1&&dn[A[i]]!=-1) me=(de[B[i]]+dn[A[i]])*2;\n\t\t\t\tint ms2=-1;\n\t\t\t\tif(S[C[i]]=='S') ms2=0;\n\t\t\t\telse if(dw2[D[i]]!=-1&&ds2[C[i]]!=-1) ms2=(dw2[D[i]]+ds2[C[i]])*2;\n\t\t\t\tint me2=-1;\n\t\t\t\tif(T[D[i]]=='E') me2=0;\n\t\t\t\telse if(de2[D[i]]!=-1&&dn2[C[i]]!=-1) me2=(de2[D[i]]+dn2[C[i]])*2;\n\t\t\t\tint now=INF;\n\t\t\t\tif(ms>=0&&me2>=0) now=min(now,ms+me2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tif(me>=0&&ms2>=0) now=min(now,me+ms2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tint cs=rs[C[i]]-(A[i]==0?0:rs[A[i]-1]);\n\t\t\t\tint ce=re[D[i]]-(B[i]==0?0:re[B[i]-1]);\n\t\t\t\tif(me>=0&&me2>=0&&cs>0) now=min(now,me+me2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tif(ms>=0&&ms2>=0&&ce>0) now=min(now,ms+ms2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tif(now!=INF) ans[i]=now;\n\t\t\t}\n\t\t\t//printf(\"* %d %d %d %d\\n\",A[i],B[i],C[i],D[i]);\n\t\t\t//printf(\"%s %s -> %d\\n\",S,T,ans[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&m,&q);\n\tscanf(\"%s\",&S);\n\tscanf(\"%s\",&T);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(S[i]=='E') S[i]='S';\n\t\telse S[i]='N';\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(T[i]=='S') T[i]='E';\n\t\telse T[i]='W';\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tA[i]--,B[i]--,C[i]--,D[i]--;\n\t}\n\tsolve();\n\tfor(int l=0,r=n-1;l<r;l++,r--) swap(S[l],S[r]);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(T[i]=='E') T[i]='W';\n\t\telse T[i]='E';\n\t}\n\tfor(int i=0;i<q;i++) A[i]=n-A[i]-1,C[i]=n-C[i]-1;\n\tsolve();\n\tfor(int l=0,r=m-1;l<r;l++,r--) swap(T[l],T[r]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(S[i]=='N') S[i]='S';\n\t\telse S[i]='N';\n\t}\n\tfor(int i=0;i<q;i++) B[i]=m-B[i]-1,D[i]=m-D[i]-1;\n\tsolve();\n\tfor(int l=0,r=n-1;l<r;l++,r--) swap(S[l],S[r]);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(T[i]=='E') T[i]='W';\n\t\telse T[i]='E';\n\t}\n\tfor(int i=0;i<q;i++) A[i]=n-A[i]-1,C[i]=n-C[i]-1;\n\tsolve();\n\tfor(int i=0;i<q;i++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\n#define MAX_N 100000\n#define MAX_M 100000\n\nusing namespace std;\n\nint N, M, Q;\nstring S, T;\n\nint lowerX[MAX_M];\nint upperX[MAX_M];\nint lowerY[MAX_N];\nint upperY[MAX_N];\n\nvoid initCompress()\n{\n    int le = N;\n    int lw = N;\n    for ( int i = 0; i < N; i++ )\n    {\n        if ( S[i] == 'E' ) le = i;\n        if ( S[i] == 'W' ) lw = i;\n\n        lowerY[i] = min( ( S[i] == 'E' ? lw : le ), i );\n    }\n\n    int ue = -1;\n    int uw = -1;\n    for ( int i = N - 1; i >= 0; i-- )\n    {\n        if ( S[i] == 'E' ) ue = i;\n        if ( S[i] == 'W' ) uw = i;\n\n        upperY[i] = max( ( S[i] == 'E' ? uw : ue ), i );\n    }\n\n    int ln = N;\n    int ls = N;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( T[i] == 'N' ) ln = i;\n        if ( T[i] == 'S' ) ls = i;\n\n        lowerX[i] = min( ( T[i] == 'N' ? ls : ln ), i );\n    }\n\n    int un = -1;\n    int us = -1;\n    for ( int i = M - 1; i >= 0; i-- )\n    {\n        if ( T[i] == 'N' ) un = i;\n        if ( T[i] == 'S' ) us = i;\n\n        upperX[i] = max( ( T[i] == 'N' ? us : un ), i );\n    }\n}\n\nbool visited[6][6];\n\ntypedef pair<int, int> P2;\ntypedef pair<long long, P2> P3;\n\nint query( int y1, int x1, int y2, int x2 )\n{\n    vector<int> X;\n    vector<int> Y;\n\n    memset( visited, 0, sizeof( visited ) );\n\n    // initialize X\n    X.push_back( x1 );\n    X.push_back( lowerX[x1] );\n    X.push_back( upperX[x1] );\n    X.push_back( x2 );\n    X.push_back( lowerX[x2] );\n    X.push_back( upperX[x2] );\n\n    sort( X.begin(), X.end() );\n    X.erase( unique( X.begin(), X.end() ), X.end() );\n\n    // initialize Y\n    Y.push_back( y1 );\n    Y.push_back( lowerY[y1] );\n    Y.push_back( upperY[y1] );\n    Y.push_back( y2 );\n    Y.push_back( lowerY[y2] );\n    Y.push_back( upperY[y2] );\n\n    sort( Y.begin(), Y.end() );\n    Y.erase( unique( Y.begin(), Y.end() ), Y.end() );\n\n    int scx = find( X.begin(), X.end(), x1 ) - X.begin(); // index of start x\n    int scy = find( Y.begin(), Y.end(), y1 ) - Y.begin(); // index of start y\n    int gcx = find( X.begin(), X.end(), x2 ) - X.begin(); // index of goal x\n    int gcy = find( Y.begin(), Y.end(), y2 ) - Y.begin(); // index of goal y\n\n    priority_queue<P3> q;\n    q.push( P3( 0LL, P2( scx, scy ) ) );\n\n    while ( !q.empty() )\n    {\n        long long d = q.top().first;\n        int cxi = q.top().second.first;\n        int cyi = q.top().second.second;\n\n        q.pop();\n\n        if ( visited[cxi][cyi] ) continue;\n        visited[cxi][cyi] = true;\n\n        if ( cxi == gcx && cyi == gcy ) return d;\n\n        int x = X[cxi];\n        int y = Y[cyi];\n\n        if ( T[x] == 'N' && 0 <= cyi - 1 )\n        {\n            int ny = Y[cyi - 1];\n            q.push( P3( d + abs( ny - y ), P2( cxi, cyi - 1 ) ) );\n        }\n        else if ( T[x] == 'S' && cyi + 1 < Y.size() )\n        {\n            int ny = Y[cyi + 1];\n            q.push( P3( d + abs( ny - y ), P2( cxi, cyi + 1 ) ) );\n        }\n\n        if ( S[y] == 'W' && 0 <= cxi - 1 )\n        {\n            int nx = X[cxi - 1];\n            q.push( P3( d + abs( nx - x ), P2( cxi - 1, cyi ) ) );\n        }\n        else if ( S[y] == 'E' && cxi + 1 < X.size() )\n        {\n            int nx = X[cxi + 1];\n            q.push( P3( d + abs( nx - x ), P2( cxi + 1, cyi ) ) );\n        }\n    }\n\n    return -1;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M >> Q;\n    cin >> S;\n    cin >> T;\n\n    initCompress();\n\n    for ( int q = 0; q < Q; q++ )\n    {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n\n        int ans = query( a - 1, b - 1, c - 1, d - 1 );\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <climits>\n#define rep(i, begin, end) for (__typeof(end) i = (begin) - ((begin) > (end)); i != (end) - ((begin) > (end)); i += 1 - 2 * ((begin) > (end)))\n#define srep(i, begin, end) for (__typeof(end) i = begin; i != end; i++)\n#define si(x) int x = scanInt();\n#define sll(x) LL x = scanLong();\n#define sci(x) int x; scanf(\"%d\", &x);\n#define scll(x) LL x; scanf(\"%lld\", &x);\n#define pi(x) printf(\"%d \", x)\n#define pll(x) printf(\"%lld \", x)\n#define nl printf(\"\\n\")\n#define clr(a) memset(a, 0, sizeof(a))\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef unsigned int UI; // 32 bit integer\ntypedef long int LI; // 32 bit integer\ntypedef unsigned long int ULI; // 32 bit unsigned integer\ntypedef long long int LL; // 64 bit integer\ntypedef unsigned long long int  ULL; // 64 bit unsigned integer\ntypedef long double LD;\ntypedef vector<int> VI;\ntypedef vector<LL> VLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\nconst LL MOD = 1e9+7;\n\n/* Fast I/O */\ninline int scanInt() {\n\tint n = 0;\n\tchar ch = getchar();\n\tint sign = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-')\tsign = -1;\n\t\tch = getchar();\n\t}\n\twhile(ch >= '0' && ch <= '9') {\n\t\tn = (n<<1)+(n<<3)+(int)(ch-'0');\n\t\tch = getchar();\n\t}\n\treturn n*sign;\n}\n\ninline LL scanLong() {\n\tLL n = 0;\n\tchar ch = getchar();\n\tLL sign = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-')\tsign = -1;\n\t\tch = getchar();\n\t}\n\twhile(ch >= '0' && ch <= '9') {\n\t\tn = (n<<1)+(n<<3)+(LL)(ch-'0');\n\t\tch = getchar();\n\t}\n\treturn n*sign;\n}\n\nint main() {\n\tsll(N); sll(M); sll(q);\n\tstring EW, NS; cin >> EW >> NS;\n\trep(_, 0, q) {\n\t\tsll(a); sll(b); sll(c); sll(d);\n\t\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t\tqueue<PLL> Q;\n\t\tmap<PLL, LL> dist;\n\t\tQ.push(MP(a, b));\n\t\tdist[MP(a, b)] = 1;\n\t\twhile(!Q.empty()) {\n\t\t\tLL i = Q.front().first, j = Q.front().second; Q.pop();\n\t\t\t//cout << i << \" \" << j << endl;\n\t\t\tLL ds = dist[MP(i, j)];\n\t\t\tif(i == c && j == d)\tbreak;\n\t\t\tif(i+1 <= N && NS[j-1] == 'S' && dist[MP(i+1, j)] == 0) {\n\t\t\t\tdist[MP(i+1, j)] = ds+1;\n\t\t\t\tQ.push(MP(i+1, j));\n\t\t\t}\n\t\t\tif(i-1 >= 1 && NS[j-1] == 'N' && dist[MP(i-1, j)] == 0) {\n\t\t\t\tdist[MP(i-1, j)] = ds+1;\n\t\t\t\tQ.push(MP(i-1, j));\n\t\t\t}\n\t\t\tif(j+1 <= M && EW[i-1] == 'E' && dist[MP(i, j+1)] == 0) {\n\t\t\t\tdist[MP(i, j+1)] = ds+1;\n\t\t\t\tQ.push(MP(i, j+1));\n\t\t\t}\n\t\t\tif(j-1 >= 1 && EW[i-1] == 'W' && dist[MP(i, j-1)] == 0) {\n\t\t\t\tdist[MP(i, j-1)] = ds+1;\n\t\t\t\tQ.push(MP(i, j-1));\n\t\t\t}\n\t\t}\n\t\tpll(dist[MP(c, d)]-1); nl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\nconst ll INF = TEN(18);\n\nint main() {\n    int N, M, Q;\n    string S, T;\n    cin >> N >> M >> Q >> S >> T;\n    debug(S, T);\n    V<int> vw, ve, vn, vs;\n    rep(i, N) {\n        if (S[i] == 'W') {\n            vw.pb(i);\n        } else {\n            ve.pb(i);\n        }\n    }\n    rep(i, M) {\n        if (T[i] == 'N') {\n            vn.pb(i);\n        } else {\n            vs.pb(i);\n        }\n    }\n    while (Q--) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        --a, --b, --c, --d;\n        V<int> xs{a, c}, ys{b, d};\n        for (int x : {a, c}) {\n            if (S[x] == 'E') {\n                auto it = lower_bound(ALL(vw), x);\n                if (it != vw.end()) {\n                    xs.pb(*it);\n                }\n                if (it != vw.begin()) {\n                    --it;\n                    xs.pb(*it);\n                }\n            } else {\n                auto it = lower_bound(ALL(ve), x);\n                if (it != ve.end()) {\n                    xs.pb(*it);\n                }\n                if (it != ve.begin()) {\n                    --it;\n                    xs.pb(*it);\n                }\n            }\n        }\n        for (int y : {b, d}) {\n            if (T[y] == 'N') {\n                auto it = lower_bound(ALL(vs), y);\n                if (it != vs.end()) {\n                    ys.pb(*it);\n                }\n                if (it != vs.begin()) {\n                    --it;\n                    ys.pb(*it);\n                }\n            } else {\n                auto it = lower_bound(ALL(vn), y);\n                if (it != vn.end()) {\n                    ys.pb(*it);\n                }\n                if (it != vn.begin()) {\n                    --it;\n                    ys.pb(*it);\n                }\n            }\n        }\n        sort(ALL(xs));\n        xs.erase(unique(ALL(xs)), xs.end());\n        sort(ALL(ys));\n        ys.erase(unique(ALL(ys)), ys.end());\n        debug(xs, ys);\n\n        a = lower_bound(ALL(xs), a) - xs.begin();\n        b = lower_bound(ALL(ys), b) - ys.begin();\n        c = lower_bound(ALL(xs), c) - xs.begin();\n        d = lower_bound(ALL(ys), d) - ys.begin();\n\n        using Data = pair<ll, pii>;\n        priority_queue<Data, V<Data>, greater<Data>> que;\n        VV<ll> ds(xs.size(), V<ll>(ys.size(), INF));\n        ds[a][b] = 0;\n        que.push(mp(0, mp(a, b)));\n        while (!que.empty()) {\n            auto t = que.top();\n            que.pop();\n            int x, y;\n            tie(x, y) = t.se;\n            if (ds[x][y] < t.fi) continue;\n\n            if (T[ys[y]] == 'S') {\n                for (int nx = x + 1; nx < xs.size(); ++nx) {\n                    ll nd = ds[x][y] + abs(xs[nx] - xs[x]);\n                    if (ds[nx][y] > nd) {\n                        ds[nx][y] = nd;\n                        que.push(mp(nd, mp(nx, y)));\n                    }\n                }\n            } else {\n                for (int nx = x - 1; nx >= 0; --nx) {\n                    ll nd = ds[x][y] + abs(xs[nx] - xs[x]);\n                    if (ds[nx][y] > nd) {\n                        ds[nx][y] = nd;\n                        que.push(mp(nd, mp(nx, y)));\n                    }\n                }\n            }\n            if (S[xs[x]] == 'E') {\n                for (int ny = y + 1; ny < ys.size(); ++ny) {\n                    ll nd = ds[x][y] + abs(ys[ny] - ys[y]);\n                    if (ds[x][ny] > nd) {\n                        ds[x][ny] = nd;\n                        que.push(mp(nd, mp(x, ny)));\n                    }\n                }\n            } else {\n                for (int ny = y - 1; ny >= 0; --ny) {\n                    ll nd = ds[x][y] + abs(ys[ny] - ys[y]);\n                    if (ds[x][ny] > nd) {\n                        ds[x][ny] = nd;\n                        que.push(mp(nd, mp(x, ny)));\n                    }\n                }\n            }\n        }\n        ll ans = ds[c][d];\n        if (ans == INF) ans = -1;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 5;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\n\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\n\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n    // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    // mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    if (step == BUBEN) return INF;\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j - 1] == k) nxt[i][val][0][j] = j - 1;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j + 1] == k) nxt[i][val][1][j] = j + 1;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n//        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  vector<int> pnu(m),psu(m);\n  vector<int> pnl(m),psl(m);\n  for(int j=0;j<m;j++){    \n    pnu[j]=*--upper_bound(vn.begin(),vn.end(),j);\n    psu[j]=*--upper_bound(vs.begin(),vs.end(),j);    \n    pnl[j]=*lower_bound(vn.begin(),vn.end(),j);\n    psl[j]=*lower_bound(vs.begin(),vs.end(),j);\n  }\n  \n  vector<int> pwu(n),peu(n);\n  vector<int> pwl(n),pel(n);\n  for(int i=0;i<n;i++){    \n    pwu[i]=*--upper_bound(vw.begin(),vw.end(),i);\n    peu[i]=*--upper_bound(ve.begin(),ve.end(),i);    \n    pwl[i]=*lower_bound(vw.begin(),vw.end(),i);\n    pel[i]=*lower_bound(ve.begin(),ve.end(),i);\n  }      \n  \n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using ll = long long;    \n    auto T=[&](int y,int x,int step){return ((ll)y<<40)|((ll)x<<20)|(ll)step;};\n    map<ll, int> dp;\n    using P = pair<int, ll>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      ll st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      y=(st>>40);\n      x=(st>>20)^((ll)y<<20);\n      step=st&((1<<20)-1);\n      \n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(abs(ny)==INF||abs(nx)==INF) return;\n          if(ny==y&&nx==x) return;         \n          if(dp.find(T(ny,nx,ns))!=dp.end()&&dp[T(ny,nx,ns)]<=nd) return;\n          if(nd+abs(ny-c)+abs(nx-d)>=ans) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        for(int xx:{x,d}){\n          // N           \n          if(pnu[xx]<=x)\n            push(y,pnu[xx],step+1,sum+abs(pnu[xx]-x));\n          // S\n          if(psu[xx]<=x)\n            push(y,psu[xx],step+1,sum+abs(psu[xx]-x));\n        }\n      }else{\n        for(int xx:{x,d}){\n          // N           \n          if(pnl[xx]>=x)\n            push(y,pnl[xx],step+1,sum+abs(pnl[xx]-x));\n          // S\n          if(psl[xx]>=x)\n            push(y,psl[xx],step+1,sum+abs(psl[xx]-x));\n        }\n      }\n      if(t[x]=='N'){\n        for(int yy:{y,c}){\n          // W\n          if(pwu[yy]<=y)\n            push(pwu[yy],x,step+1,sum+abs(pwu[yy]-y));\n          // E\n          if(peu[yy]<=y)\n            push(peu[yy],x,step+1,sum+abs(peu[yy]-y));\n        }\n      }else{        \n        for(int yy:{y,c}){\n          // W\n          if(pwl[yy]>=y)\n            push(pwl[yy],x,step+1,sum+abs(pwl[yy]-y));\n          // E\n          if(pel[yy]>=y)\n            push(pel[yy],x,step+1,sum+abs(pel[yy]-y));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nvector<P> nullvP;\n\nstruct Graph{\n\tint V;\n\tvector<vector<P>> G;\n\tvoid init(int _V){\n\t\tV = _V;\n\t\tG.clear();\n\t\trep(i,V+1){\n\t\t\tG.pb(nullvP);\n\t\t}\n\t}\n\tvoid add_edge(int a,int b,int w = 1){\n\t\t//cout << a << \" \" << b << \" \" << w << endl;\n\t\tG[a].pb(P(b,w));\n\t\t//G[b].pb(P(a,w));\n\t}\n\tint dijkstra(int s,int t){\n\t\t//cout << \"(s,t)=\" << s << \",\" << t << endl;\n\t\tbool used[52];\n\t\tint dist[52];\n\t\tpriority_queue<P,vector<P>,greater<P>> que;\n\t\trep(i,52){\n\t\t\tused[i] = false;\n\t\t\tdist[i] = INF;\n\t\t}\n\t\tdist[s] = 0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\t//cout << p.fr << \" \" << p.sc << endl;\n\t\t\tif(used[p.sc])continue;\n\t\t\tused[p.sc] = true;\n\t\t\tfor(P ed: G[p.sc]){\n\t\t\t\tif(dist[ed.fr] > dist[p.sc]+ed.sc){\n\t\t\t\t\tdist[ed.fr] = dist[p.sc]+ed.sc;\n\t\t\t\t\tque.push(P(dist[ed.fr],ed.fr));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist[t];\n\t}\n}G;\n\nint main(){\n\tstatic int n,m,q;\n\tstatic string s,t;\n\t//static int a[200010],b[200010],c[200010],d[200010];\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tcin >> s >> t;\n\t/*rep1(i,q){\n\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t}*/\n\t\n\tstatic int lw[100010],rw[100010],le[100010],re[100010];\n\tstatic int ln[100010],rn[100010],ls[100010],rs[100010];\n\tlw[0] = le[0] = 0;\n\trep1(i,n){\n\t\tlw[i] = lw[i-1];\n\t\tle[i] = le[i-1];\n\t\tif(s[i-1] == 'W')lw[i] = i;\n\t\telse le[i] = i;\n\t}\n\tln[0] = ls[0] = 0;\n\trep1(i,m){\n\t\tln[i] = ln[i-1];\n\t\tls[i] = ls[i-1];\n\t\tif(t[i-1] == 'N')ln[i] = i;\n\t\telse ls[i] = i;\n\t}\n\trw[n+1] = re[n+1] = n+1;\n\trrep1(i,n){\n\t\trw[i] = rw[i+1];\n\t\tre[i] = re[i+1];\n\t\tif(s[i-1] == 'W')rw[i] = i;\n\t\telse re[i] = i;\n\t}\n\trn[m+1] = rs[m+1] = m+1;\n\trrep1(i,m){\n\t\trn[i] = rn[i+1];\n\t\trs[i] = rs[i+1];\n\t\tif(t[i-1] == 'N')rn[i] = i;\n\t\telse rs[i] = i;\n\t}\n\t\n\t//rep1(i,n)cout << lw[i] << \" \" << rw[i] << \" \" << le[i] << \" \" << re[i] << endl;\n\t//rep1(i,m)cout << ln[i] << \" \" << rn[i] << \" \" << ls[i] << \" \" << rs[i] << endl;\n\t\n\trep1(loop,q){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tvector<int> X,Y;\n\t\tX.pb(a); X.pb(c);\n\t\tif(s[a-1] == 'E'){\n\t\t\tif(lw[a] != 0)X.pb(lw[a]);\n\t\t\tif(rw[a] != n+1)X.pb(rw[a]);\n\t\t}\n\t\telse {\n\t\t\tif(le[a] != 0)X.pb(le[a]);\n\t\t\tif(re[a] != n+1)X.pb(re[a]);\n\t\t}\n\t\tif(s[c-1] == 'E'){\n\t\t\tif(lw[c] != 0)X.pb(lw[c]);\n\t\t\tif(rw[c] != n+1)X.pb(rw[c]);\n\t\t}\n\t\telse {\n\t\t\tif(le[c] != 0)X.pb(le[c]);\n\t\t\tif(re[c] != n+1)X.pb(re[c]);\n\t\t}\n\t\tY.pb(b); Y.pb(d);\n\t\tif(s[b-1] == 'S'){\n\t\t\tif(ln[b] != 0)Y.pb(ln[b]);\n\t\t\tif(rn[b] != m+1)Y.pb(rn[b]);\n\t\t}\n\t\telse {\n\t\t\tif(ls[b] != 0)Y.pb(ls[b]);\n\t\t\tif(rs[b] != m+1)Y.pb(rs[b]);\n\t\t}\n\t\tif(s[d-1] == 'S'){\n\t\t\tif(ln[d] != 0)Y.pb(ln[d]);\n\t\t\tif(rn[d] != m+1)Y.pb(rn[d]);\n\t\t}\n\t\telse {\n\t\t\tif(ls[d] != 0)Y.pb(ls[d]);\n\t\t\tif(rs[d] != m+1)Y.pb(rs[d]);\n\t\t}\n\t\tsor(X); uniq(X);\n\t\tsor(Y); uniq(Y);\n\t\t\n\t\tcout << \"X:\";\n\t\tfor(int i: X)cout << i << \" \";\n\t\tcout << endl;\n\t\tcout << \"Y:\";\n\t\tfor(int i: Y)cout << i << \" \";\n\t\tcout << endl;\n\t\t\n\t\tint _a = lower_bound(X.begin(),X.end(),a)-X.begin();\n\t\tint _b = lower_bound(Y.begin(),Y.end(),b)-Y.begin();\n\t\tint _c = lower_bound(X.begin(),X.end(),c)-X.begin();\n\t\tint _d = lower_bound(Y.begin(),Y.end(),d)-Y.begin();\n\t\tG.init(X.size()*Y.size());\n\t\trep(i,X.size())rep(j,Y.size())for(int k = j+1 ; k < Y.size() ; k ++){\n\t\t\tif(s[X[i]-1] == 'W')G.add_edge(i*Y.size()+k,i*Y.size()+j,Y[k]-Y[j]);\n\t\t\telse G.add_edge(i*Y.size()+j,i*Y.size()+k,Y[k]-Y[j]);\n\t\t}\n\t\trep(i,X.size())for(int j = i+1 ; j < X.size() ; j ++)rep(k,Y.size()){\n\t\t\tif(t[Y[k]-1] == 'N')G.add_edge(j*Y.size()+k,i*Y.size()+k,X[j]-X[i]);\n\t\t\telse G.add_edge(i*Y.size()+k,j*Y.size()+k,X[j]-X[i]);\n\t\t}\n\t\tint ret = G.dijkstra(_a*Y.size()+_b,_c*Y.size()+_d);\n\t\tif(ret >= INF)puts(\"-1\");\n\t\telse printf(\"%d\\n\",ret);\n\t\t//printf(\"%d\\n\",G.dijkstra(_a*Y.size()+_b,_c*Y.size()+_d));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N,M,Q; cin >> N >> M >> Q;\n\tstring S,T; cin >> S; cin >> T;\n\tvector<int> ln(M+2,-1e9),rn(M+2,1e9),ls(M+2,-1e9),rs(M+2,1e9);\n\tvector<int> ue(N+2,-1e9),de(N+2,1e9),uw(N+2,-1e9),dw(N+2,1e9);\n\trepp(i,0,M){\n\t\tln[i+1] = ln[i]; ls[i+1] = ls[i];\n\t\tif(T[i] == 'N') ln[i+1] = i+1;\n\t\telse ls[i+1] = i+1;\n\t}\n\trepm(i,M,0){\n\t\trn[i] = rn[i+1]; rs[i] = rs[i+1];\n\t\tif(T[i-1] == 'N') rn[i] = i;\n\t\telse rs[i] = i;\n\t}\n\trepp(i,0,N){\n\t\tue[i+1] = ue[i]; uw[i+1] = uw[i];\n\t\tif(S[i] == 'E') ue[i+1] = i+1;\n\t\telse uw[i+1] = i+1;\n\t}\n\trepm(i,N,0){\n\t\tde[i] = de[i+1]; dw[i] = dw[i+1];\n\t\tif(S[i-1] == 'E') de[i] = i;\n\t\telse dw[i] = i;\n\t}\n\trepp(rep_q,0,Q){\n\t\tint a,b,c,d; cin >> a >> b >> c >> d;\n\t\tvector<int> v(6),h(6);\n\t\th[0] = a; v[0] = b; h[5] = c; v[5] = d;\n\t\tif(S[a-1] == 'E'){\n\t\t\th[1] = uw[a]; h[2] = dw[a];\n\t\t} else {\n\t\t\th[1] = ue[a]; h[2] = de[a];\n\t\t}\n\t\tif(S[c-1] == 'E'){\n\t\t\th[3] = uw[c]; h[4] = dw[c];\n\t\t} else {\n\t\t\th[3] = ue[c]; h[4] = de[c];\n\t\t}\n\t\tif(T[b-1] == 'N'){\n\t\t\tv[1] = ls[b]; v[2] = rs[b];\n\t\t} else {\n\t\t\tv[1] = ln[b]; v[2] = rn[b];\n\t\t}\n\t\tif(T[d-1] == 'N'){\n\t\t\tv[3] = ls[d]; v[4] = rs[d];\n\t\t} else {\n\t\t\tv[3] = ln[d]; v[4] = rn[d];\n\t\t}\n\t\tvector<vector<int>> ans(6,vector<int>(6,1e8)),p(6,vector<int>(6,0));\n\t\tans[0][0] = 0;\n\t\tint x = 0, y = 0;\n\t\twhile(x != -1){\n\t\t\tp[x][y] = 1;\n\t\t\tint xx = -1, yy = -1, zz = 1e8;\n\t\t\trepp(i,0,6) repp(j,0,6) if(!p[i][j]){\n\t\t\t\tif(x == i && h[x] > 0 && h[x] <= N && ((S[h[x]-1]=='W')^(v[y]<v[j]))) ans[i][j] = min(ans[i][j],ans[x][y]+abs(v[j]-v[y]));\n\t\t\t\tif(y == j && v[y] > 0 && v[y] <= M && ((T[v[y]-1]=='N')^(h[x]<h[i]))) ans[i][j] = min(ans[i][j],ans[x][y]+abs(h[i]-h[x]));\n\t\t\t\tif(zz > ans[i][j]){\n\t\t\t\t\txx = i; yy = j; zz = ans[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = xx; y = yy;\n\t\t}\n\t\tcout << (ans[5][5]==1e8?-1:ans[5][5]) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(s[a] == 'W'){\n\t    \tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//左\n\t\tint x = POSL(up,min(d,b));\n\t\tint xx = POSL(up,b);\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSL(up,b) > 0){\n\t\t    x = POSL(up,b); x--;\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSL(dw,min(d,b));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSL(dw,b) > 0){\n\t\t    y = POSL(dw,b); y--;\n\t\t    on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\n\t}\n\telse{\n\t    if(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = POSU(up,max(d,b));\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSU(up,b) != up.size()){\n\t\t    x = POSU(up,b);\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSU(dw,max(d,b));\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSU(dw,b) != dw.size()){\n\t\t    y = POSU(dw,b);\n\t\t   on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(t[b] == 'N'){\n\t    if(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//上\n\t\tint x = POSL(le,min(a,c));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSL(le,a)){\n\t\t    x = POSL(le,a)-1;\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSL(ri,min(a,c));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSL(ri,a)){\n\t\t    y = POSL(ri,a)-1;\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\telse{\n\t    if(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = POSU(le,max(a,c));\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSU(le,a) != le.size()){\n\t\t    x = POSU(le,a);\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSU(ri,max(a,c));\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSU(ri,a) != ri.size()){\n\t\t    y = POSU(ri,a);\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,3,0);\n\t\ton_y(a,b,c,d,3,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\ntypedef pair<int,pint> tint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nint ne[100100],nw[100100],se[100100],sw[100100];\nint en[100100],es[100100],wn[100100],Ws[100100];\nstring s,t;\nint h,w,inf=11451419;\nint dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nint gr[10][10][4];\nint dp[10][10];\nbool sumi[10][10];\npriority_queue<tint> q;\nvoid aedge(int x,int y,int z){\n\tif(dp[x][y]<=z) return;\n\tdp[x][y]=z;\n\tq.push(mp(-z,mp(x,y)));\n}\nint cal(int sx,int sy,int gx,int gy){\n\tvector<int> ta,yo,t2,y2;\n\tta.pb(en[gy]);ta.pb(es[gy]);ta.pb(wn[gy]);ta.pb(Ws[gy]);\n\tyo.pb(ne[gx]);yo.pb(nw[gx]);yo.pb(se[gx]);yo.pb(sw[gx]);\n\tta.pb(en[sy]);ta.pb(es[sy]);ta.pb(wn[sy]);ta.pb(Ws[sy]);\n\tyo.pb(ne[sx]);yo.pb(nw[sx]);yo.pb(se[sx]);yo.pb(sw[sx]);\n\tsort(All(ta));ta.erase(unique(All(ta)),ta.end());\n\tsort(All(yo));yo.erase(unique(All(yo)),yo.end());\n\trep(i,ta.size()){\n\t\tif(ta[i]>=0 && ta[i]<inf) t2.pb(ta[i]);\n\t}\n\trep(i,yo.size()){\n\t\tif(yo[i]>=0 && yo[i]<inf) y2.pb(yo[i]);\n\t}\n\trep(i,8) rep(j,8){\n\t\tdp[i][j]=inf;\n\t\trep(k,4) gr[i][j][k]=inf;\n\t}\n\tmemset(sumi,false,sizeof(sumi));\n\tint n=y2.size(),m=t2.size();\n\trep(i,n) rep(j,m){\n\t\tif(s[y2[i]]=='E' && j<m-1) gr[i][j][1]=t2[j+1]-t2[j];\n\t\tif(s[y2[i]]=='W' && j>0) gr[i][j][3]=t2[j]-t2[j-1];\n\t\tif(t[t2[j]]=='N' && i>0) gr[i][j][0]=y2[i]-y2[i-1];\n\t\tif(t[t2[j]]=='S' && i<n-1) gr[i][j][2]=y2[i+1]-y2[i];\n\t}\n\taedge(lower_bound(All(y2),sx)-y2.begin(),lower_bound(All(t2),sy)-t2.begin(),0);\n\twhile(!q.empty()){\n\t\ttint p=q.top();q.pop();int x=p.se.fi,y=p.se.se,z=-p.fi;\n\t\tif(sumi[x][y]) continue;sumi[x][y]=true;\n\t\t//cout<<y2[x]<<' '<<t2[y]<<' '<<dp[x][y]<<endl;\n\t\trep(i,4){\n\t\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\t\tif(nx>=0 && nx<n && ny>=0 && ny<m){\n\t\t\t\taedge(nx,ny,dp[x][y]+gr[x][y][i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[lower_bound(All(y2),gx)-y2.begin()][lower_bound(All(t2),gy)-t2.begin()];\n}\nint main()\n{\n\tint q,sx,sy,gx,gy;\n\tcin>>h>>w>>q;\n\tcin>>s;\n\tcin>>t;\n\tne[0]=nw[0]=-1;\n\trep(i,h){\n\t\tif(s[i]=='E') ne[i]=i;else nw[i]=i;\n\t\tne[i+1]=ne[i];nw[i+1]=nw[i];\n\t}\n\tse[h-1]=sw[h-1]=inf;\n\tfor(int i=h-1;i>=0;i--){\n\t\tif(s[i]=='E') se[i]=i;else sw[i]=i;\n\t\tif(i>0) se[i-1]=se[i],sw[i-1]=sw[i];\n\t}\n\twn[0]=Ws[0]=-1;\n\trep(i,w){\n\t\tif(t[i]=='N') wn[i]=i;else Ws[i]=i;\n\t\twn[i+1]=wn[i];Ws[i+1]=Ws[i];\n\t}\n\ten[w-1]=es[w-1]=inf;\n\tfor(int i=w-1;i>=0;i--){\n\t\tif(t[i]=='N') en[i]=i;else es[i]=i;\n\t\tif(i>0) en[i-1]=en[i],es[i-1]=es[i];\n\t}\n\trep(i,q){\n\t\tcin>>sx>>sy>>gx>>gy;\n\t\tsx--;sy--;gx--;gy--;\n\t\tint ret=cal(sx,sy,gx,gy);\n\t\tif(ret>=inf) cout<<-1<<endl;else cout<<ret<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int x,y,d,dir;};\nvector<state> st[4];\nchar s[110001],t[110001];\nint n,m,q,sl[110001][2],sr[110001][2],tl[110001][2],tr[110001][2],ex,ey,sx,sy,ans;\nvoid go(int id,int x,int y,int d,bool ns)\n{\n\tif(ns)\n\t\tif(t[y]=='S')\n\t\t{\n\t\t\tif(sr[x][0])st[id].push_back({sr[x][0],y,d+sr[x][0]-x,ns});\n\t\t\tif(sr[x][1])st[id].push_back({sr[x][1],y,d+sr[x][1]-x,ns});\n\t\t\tif(ex>x)\n\t\t\t{\n\t\t\t\tif(ey==y)ans=min(ans,d+ex-x);\n\t\t\t\tif(int z=sr[ex-1][ey>y])st[id].push_back({z,y,d+z-x,ns});\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sl[x][0])st[id].push_back({sl[x][0],y,d+x-sl[x][0],ns});\n\t\t\tif(sl[x][1])st[id].push_back({sl[x][1],y,d+x-sl[x][1],ns});\n\t\t\tif(ex<x)\n\t\t\t{\n\t\t\t\tif(ey==y)ans=min(ans,d+x-ex);\n\t\t\t\tif(int z=sl[ex+1][ey>y])st[id].push_back({z,y,d+x-z,ns});\n\t\t\t}\n\t\t}\n\telse if(s[x]=='E')\n\t{\n\t\tif(tr[y][0])st[id].push_back({x,tr[y][0],d+tr[y][0]-y,ns});\n\t\tif(tr[y][1])st[id].push_back({x,tr[y][1],d+tr[y][1]-y,ns});\n\t\tif(ey>y)\n\t\t{\n\t\t\tif(ex==x)ans=min(ans,d+ey-y);\n\t\t\tif(int z=tr[ey-1][ex>x])st[id].push_back({x,z,d+z-y,ns});\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(tl[y][0])st[id].push_back({x,tl[y][0],d+y-tl[y][0],ns});\n\t\tif(tl[y][1])st[id].push_back({x,tl[y][1],d+y-tl[y][1],ns});\n\t\tif(ey<y)\n\t\t{\n\t\t\tif(ex==x)ans=min(ans,d+y-ey);\n\t\t\tif(int z=tl[ey+1][ex>x])st[id].push_back({x,z,d+y-z,ns});\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m>>q>>(s+1)>>(t+1);\n\tfor(int i=2;i<=n;i++){sl[i][0]=sl[i-1][0];sl[i][1]=sl[i-1][1];sl[i][s[i-1]=='E']=i-1;}\n\tfor(int i=2;i<=m;i++){tl[i][0]=tl[i-1][0];tl[i][1]=tl[i-1][1];tl[i][t[i-1]=='S']=i-1;}\n\tfor(int i=n-1;i;i--){sr[i][0]=sr[i+1][0];sr[i][1]=sr[i+1][1];sr[i][s[i+1]=='E']=i+1;}\n\tfor(int i=m-1;i;i--){tr[i][0]=tr[i+1][0];tr[i][1]=tr[i+1][1];tr[i][t[i+1]=='S']=i+1;}\n\twhile(q--)\n\t{\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tans=1<<30;\n\t\tfor(int i=0;i<4;i++)st[i].clear();\n\t\tgo(0,sx,sy,0,0);\n\t\tgo(0,sx,sy,0,1);\n\t\tfor(int i=0;i<4;i++)\n\t\t\tfor(state x:st[i])go(i+1,x.x,x.y,x.d,x.dir^1),assert(st[i].size()<244);\n\t\tcout<<(ans==(1<<30)?-1:ans)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define fi first\n#define se second\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n\nusing namespace std;\nusing ll = int64_t;\n\nint N, M, Q;\nstring S, T;\nvector<int> xPositions[2];\nvector<int> yPositions[2];\nvector<int> interestingX;\nvector<int> interestingY;\nqueue<pair<int,int>> q;\n\nint distances[10][10];\n\nvoid build() {\n  for (int i = 0; i < N; i++)\n    xPositions[S[i] == 'E' ? 1 : 0].pb(i);\n  for (int i = 0; i < M; i++)\n    yPositions[T[i] == 'S' ? 1 : 0].pb(i);\n}\n\nint Next(const vector<int>& v, int x) {\n  auto it = lower_bound(all(v), x);\n  if (it == v.end())\n    return -1;\n  return *it;\n}\n\nint Prev(const vector<int>& v, int x) {\n  auto it = upper_bound(all(v), x);\n  if (it == v.begin())\n    return -1;\n  --it;\n  return *it;\n}\n\nvoid filter(vector<int>& v) {\n  sort(all(v));\n  v.erase(unique(all(v)), v.end());\n  while (!v.empty() && v.front() == -1)\n    v.erase(v.begin());\n}\n\nint ans(int x0, int y0, int x1, int y1) {\n  interestingX.clear();\n  interestingY.clear();\n  \n  interestingX.pb(x0);\n  interestingX.pb(x1);\n  interestingY.pb(y0);\n  interestingY.pb(y1);\n  for (int d = 0; d <= 1; d++) {\n    interestingX.pb(Next(xPositions[d], x0));\n    interestingX.pb(Prev(xPositions[d], x0));\n    interestingX.pb(Next(xPositions[d], x1));\n    interestingX.pb(Prev(xPositions[d], x1));\n\n    interestingY.pb(Next(yPositions[d], y0));\n    interestingY.pb(Prev(yPositions[d], y0));\n    interestingY.pb(Next(yPositions[d], y1));\n    interestingY.pb(Prev(yPositions[d], y1));\n  }\n\n  filter(interestingX);\n  filter(interestingY);\n\n  auto getX = [&](int x) {\n    return lower_bound(all(interestingX), x) - interestingX.begin();\n  };\n\n  auto getY = [&](int y) {\n    return lower_bound(all(interestingY), y) - interestingY.begin();\n  };\n\n  memset(distances, -1, sizeof(distances));\n  x0 = getX(x0);\n  y0 = getY(y0);\n  x1 = getX(x1);\n  y1 = getY(y1);\n  distances[x0][y0] = 0;\n  q.push({x0, y0});\n\n  while (!q.empty()) {\n    auto p = q.front();\n    q.pop();\n    int d = distances[p.fi][p.se];\n    // cerr << \"debug: \" << p.fi << \" \" << p.se << \" \" << d << endl;\n\n    // go x\n    int lx = 0, rx = sz(interestingX) - 1;\n    if (T[interestingY[p.se]] == 'S') lx = p.fi + 1;\n    if (T[interestingY[p.se]] == 'N') rx = p.fi - 1;\n    for (int nx = lx; nx <= rx; nx++) {\n      int nd = d + abs(interestingX[nx] - interestingX[p.fi]);\n      if (distances[x1][y1] != -1 && distances[x1][y1] <= nd)\n        continue;\n      if (distances[nx][p.se] == -1 || distances[nx][p.se] > nd) {\n        distances[nx][p.se] = nd;\n        q.push({nx, p.se});\n      }\n    }\n\n    // go y\n    int ly = 0, ry = sz(interestingY) - 1;\n    if (S[interestingX[p.fi]] == 'E') ly = p.se + 1;\n    if (S[interestingX[p.fi]] == 'W') ry = p.se - 1;\n    for (int ny = ly; ny <= ry; ny++) {\n      int nd = d + abs(interestingY[ny] - interestingY[p.se]);\n      if (distances[x1][y1] != -1 && distances[x1][y1] <= nd)\n        continue;\n      if (distances[p.fi][ny] == -1 || distances[p.fi][ny] > nd) {\n        distances[p.fi][ny] = nd;\n        q.push({p.fi, ny});\n      }\n    }\n  }\n\n  return distances[x1][y1];\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> N >> M >> Q;\n  cin >> S >> T;\n\n  build();\n\n  for (int i = 0; i < Q; i++) {\n    int x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n    --x0, --y0, --x1, --y1;\n    cout << ans(x0, y0, x1, y1) << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long long int exa = 1000000000000000000;\n//const int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, turn,dis;\n\tNode(int a, int b, int c = 0, int d = 0) {\n\t\ty = a, x = b;\n\t\tturn = c;\n\t\tdis = d;\n\t}\n};\n\nint border = 6;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int>ldif(W, -1);\n\tvector<int>rdif(W, -1);\n\tfor (int i = 1; i < W; i++) {\n\t\tif (t[i] == t[i - 1])ldif[i] = ldif[i - 1];\n\t\telse ldif[i] = i - 1;\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (t[i] == t[i + 1])rdif[i] = rdif[i + 1];\n\t\telse rdif[i] = i + 1;\n\t}\n\tvector<int>udif(H, -1);\n\tvector<int>ddif(H, -1);\n\tfor (int i = 1; i < H; i++) {\n\t\tif (s[i] == s[i - 1])udif[i] = udif[i - 1];\n\t\telse udif[i] = i - 1;\n\t}\n\tfor (int i = H - 2; i >= 0; i--) {\n\t\tif (s[i] == s[i + 1])ddif[i] = ddif[i + 1];\n\t\telse ddif[i] = i + 1;\n\t}\n\tvector<int>ret;\n\tfor (int i = 0; i < K; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\ta--, b--, c--, d--;\n\t\tqueue<Node>Q;\n\t\tQ.push(Node(a, b));\n\t\tunordered_map<long long int, int>m;\n\t\tm[(a*H + b)*W + 0] = 0;\n\t\tint ans = MOD;\n\t\twhile (!Q.empty()) {\n\t\t\tauto cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (cn.y == c && cn.x == d)ans = min(ans, cn.dis);\n\t\t\tauto it = m.find((cn.y*H + cn.x)*W + cn.turn);\n\t\t\tif (it != m.end()) {\n\t\t\t\tif (it->second < cn.dis)continue;\n\t\t\t}\n\t\t//\tcout << cn.y << \" \" << cn.x << endl;\n\t\t\tif (cn.turn == border)break;\n\t\t\tif (t[cn.x] == 'N') {//(-,0)\n\t\t\t\tif (c <= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tQ.push(Node(c, cn.x, cn.turn + 1, cn.dis + cn.y - c));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (udif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push({ Node(udif[cn.y],cn.x,cn.turn + 1,cn.dis + cn.y - udif[cn.y]) });\n\t\t\t\t\t}\n\t\t\t\t\tif (udif[c] != -1) {\n\t\t\t\t\t\tQ.push(Node(udif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y + udif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c >= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tQ.push(Node(c, cn.x, cn.turn + 1, cn.dis + c - cn.y));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ddif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[cn.y], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[cn.y])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ddif[c] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y + ddif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[cn.y] == 'W') {\n\t\t\t\tif (d <= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tQ.push(Node(cn.y, d, cn.turn + 1, cn.dis + abs(d - cn.x)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ldif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - ldif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ldif[d] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[d], cn.turn + 1, cn.dis + abs(cn.x - ldif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d >= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tQ.push(Node(cn.y, d, cn.turn + 1, cn.dis + abs(d - cn.x)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (rdif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - rdif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (rdif[d] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[d], cn.turn + 1, cn.dis + abs(cn.x - rdif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == MOD)ans = -1;\n\t\tret.push_back(ans);\n\t}\n\tfor (auto i : ret)cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nvoid bb(vector<int> &v)\n{\n\tsort(v.begin(),v.end());\n\tv.resize(unique(v.begin(),v.end())-v.begin());\n}\nint lb(int x,vector<int> &v) {if(v[0]>x) return x;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return x;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\nint trcyx(pii a,pii b) {return abs(a.first-b.first)+abs(a.second-b.second);}\n\nint tot;\nvector<int> v[nn],c[nn];\nvoid clear()\n{\n\tfor(int i=0;i<=tot;i++) v[i].clear(),c[i].clear();\n\ttot=0;\n}\nvoid link(int x,int y,int w)\n{\n\tv[x].push_back(y);c[x].push_back(w);\n}\n\n\nint dist[nn];\nint dj(int x,int y)\n{\n\tfor(int i=1;i<=tot;++i) dist[i]=1e9;\n\tdist[x]=0;priority_queue<pii> pq;pq.push(mp(-dist[x],x));\n\twhile(pq.size()) \n\t{\n\t\tint z=pq.top().second;//if(pq.top().first!=-dist[x]) {pq.pop();continue;}\n\t\tpq.pop();\n\t\tfor(int i=0;i<v[z].size();i++)\n\t\t{\n\t\t\tint w=v[z][i];\n\t\t\tif(dist[w]>dist[z]+c[z][i])\n\t\t\t{\n\t\t\t\tdist[w]=dist[z]+c[z][i];\n\t\t\t\tpq.push(mp(-dist[w],w));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[y];\n}\nvoid solve()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tclear();\n\t\tvector<int> allx,ally;int x,y;\n\t\t\n\t\tx=from[i].first,y=from[i].second;\n\t\tfor(int j=0;j<2;j++) allx.push_back(lb(x,path[0][j])),allx.push_back(ub(x,path[0][j]));\n\t\tfor(int j=0;j<2;j++) ally.push_back(lb(y,path[1][j])),ally.push_back(ub(y,path[1][j]));\n\t\t\n\t\t\n\t\tx=dest[i].first,y=dest[i].second;\n\t\tfor(int j=0;j<2;j++) allx.push_back(lb(x,path[0][j])),allx.push_back(ub(x,path[0][j]));\n\t\tfor(int j=0;j<2;j++) ally.push_back(lb(y,path[1][j])),ally.push_back(ub(y,path[1][j]));\n\t\t\n\t\t\n\t\tsort(allx.begin(),allx.end());allx.resize(unique(allx.begin(),allx.end())-allx.begin());\n\t\tsort(ally.begin(),ally.end());ally.resize(unique(ally.begin(),ally.end())-ally.begin());\n\t\t\n\t\t\n\t\tmap<pii,int> id;\n\t\tfor(int i=0;i<allx.size();i++)\n\t\t\tfor(int j=0;j<ally.size();j++)\n\t\t\t\tid[mp(allx[i],ally[j])]=++tot;\n\t\t\n\t\tfor(int i=0;i<allx.size();i++)\n\t\t\tfor(int j=1;j<ally.size();j++)\n\t\t\t{\n\t\t\t\tpii a=mp(allx[i],ally[j-1]),b=mp(allx[i],ally[j]);\n\t\t\t\tif(!dir[0][allx[i]]) swap(a,b);\n\t\t\t\tlink(id[a],id[b],trcyx(a,b));\n\t\t\t}\n\t\t\t\n\t\tfor(int j=0;j<ally.size();j++)\n\t\t\tfor(int i=1;i<allx.size();i++)\n\t\t\t{\n\t\t\t\tpii a=mp(allx[i-1],ally[j]),b=mp(allx[i],ally[j]);\n\t\t\t\tif(!dir[1][ally[j]]) swap(a,b);\n\t\t\t\tlink(id[a],id[b],trcyx(a,b));\n\t\t\t}\n\t\t\n\t\tans[i]=dj(id[from[i]],id[dest[i]]);\n\t}\n\t\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\tsolve();\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "//Δ_F\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 111111;\nconst int inf = 1e9;\nint ab(int x,int y){\n\tif(x>y)\n\t\treturn x-y;\n\treturn y-x;\n}\nint n,m,q,w,a[N][2],b[N][2][2][2];\nchar s[N];\nstruct node{\n\tint e[2],s;\n\tnode(int x=0,int y=0,int z=0){\n\t\te[0]=x,e[1]=y,s=z;\n\t}\n};\nvector<node> v1,v2;\nvoid dfs(int k,node p,int las,int rev,vector<node>&v){\n\tv.push_back(p);\n\tif(k>=2)\n\t\treturn;\n\tint i,x;\n\tnode q;\n\tfor(i=0;i<2;i=i+1){\n\t\tif(las==i)\n\t\t\tcontinue;\n\t\tx=p.e[i];\n\t\tx=b[x][i][a[p.e[i^1]][i^1]^rev][a[x][i]^1];\n\t\tif(!x)\n\t\t\tcontinue;\n\t\tq=p;\n\t\tq.e[i]=x;\n\t\tq.s+=ab(x,p.e[i]);\n\t\tdfs(k+1,q,i,rev,v);\n\t}\n}\nbool ok(int i,int u,int s,int t){\n\treturn (s==t)||((s>t)^a[u][i]);\n}\nvoid chk(node p,node q){\n\tint i,o=p.s+q.s+ab(p.e[0],q.e[0])+ab(p.e[1],q.e[1]);\n\tfor(i=0;i<2;i=i+1)\n\t\tif(ok(i,p.e[i],p.e[i^1],q.e[i^1])&&ok(i^1,q.e[i^1],p.e[i],q.e[i]))\n\t\t\tw=min(w,o);\n}\nint main()\n{\n\tint i,j,x,y;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=n;i=i+1)\n\t\ta[i][0]=s[i]=='E';\n\tfor(i=1;i<=n;i=i+1){\n\t\tfor(j=0;j<2;j=j+1)\n\t\t\tb[i][0][0][j]=b[i-1][0][0][j];\n\t\tb[i][0][0][a[i][0]]=i;\n\t}\n\tfor(i=n;i;i=i-1){\n\t\tfor(j=0;j<2;j=j+1)\n\t\t\tb[i][0][1][j]=b[i+1][0][1][j];\n\t\tb[i][0][1][a[i][0]]=i;\n\t}\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;i=i+1)\n\t\ta[i][1]=s[i]=='S';\n\tfor(i=1;i<=m;i=i+1){\n\t\tfor(j=0;j<2;j=j+1)\n\t\t\tb[i][1][0][j]=b[i-1][1][0][j];\n\t\tb[i][1][0][a[i][1]]=i;\n\t}\n\tfor(i=m;i;i=i-1){\n\t\tfor(j=0;j<2;j=j+1)\n\t\t\tb[i][1][1][j]=b[i+1][1][1][j];\n\t\tb[i][1][1][a[i][1]]=i;\n\t}\n\twhile(q--){\n\t\tscanf(\"%d%d%d%d\",&i,&j,&x,&y);\n\t\tv1.clear(),v2.clear();\n\t\tdfs(0,node(i,j),-1,0,v1);\n\t\tdfs(0,node(x,y),-1,1,v2);\n\t\tw=inf;\n\t\tfor(i=0;i<v1.size();i=i+1)\n\t\t\tfor(j=0;j<v2.size();j=j+1)\n\t\t\t\tchk(v1[i],v2[j]);\n\t\tif(w>=inf)\n\t\t\tw=-1;\n\t\tprintf(\"%d\\n\",w);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W,Q;\nstring LR,UD;\nint SY,SX,TY,TX;\n\nint LU[202020],LD[202020];\nint RU[202020],RD[202020];\nint UL[202020],UR[202020];\nint DL[202020],DR[202020];\n\nint revx[202020],revy[202020];\nll dist[10][10];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W>>Q;\n\tcin>>LR>>UD;\n\t\n\t\n\tint U=W-1,D=W-1;\n\tfor(i=W-1;i>=0;i--) {\n\t\tif(UD[i]=='N') U=i;\n\t\tif(UD[i]=='S') D=i;\n\t\tRU[i]=U;\n\t\tRD[i]=D;\n\t}\n\tU=D=0;\n\tFOR(i,W) {\n\t\tif(UD[i]=='N') U=i;\n\t\tif(UD[i]=='S') D=i;\n\t\tLU[i]=U;\n\t\tLD[i]=D;\n\t}\n\tint L=0,R=0;\n\tFOR(i,H) {\n\t\tif(LR[i]=='W') L=i;\n\t\tif(LR[i]=='E') R=i;\n\t\tUL[i]=L;\n\t\tUR[i]=R;\n\t}\n\tL=R=H-1;\n\tfor(i=H-1;i>=0;i--) {\n\t\tif(LR[i]=='W') L=i;\n\t\tif(LR[i]=='E') R=i;\n\t\tDL[i]=L;\n\t\tDR[i]=R;\n\t}\n\t\n\twhile(Q--) {\n\t\tcin>>SY>>SX>>TY>>TX;\n\t\tSY--;\n\t\tSX--;\n\t\tTY--;\n\t\tTX--;\n\t\tvector<int> Xs,Ys;\n\t\tYs.push_back(SY);\n\t\tYs.push_back(TY);\n\t\tYs.push_back(UL[SY]);\n\t\tYs.push_back(UR[SY]);\n\t\tYs.push_back(DL[SY]);\n\t\tYs.push_back(DR[SY]);\n\t\tYs.push_back(UL[TY]);\n\t\tYs.push_back(UR[TY]);\n\t\tYs.push_back(DL[TY]);\n\t\tYs.push_back(DR[TY]);\n\t\tXs.push_back(SX);\n\t\tXs.push_back(TX);\n\t\tXs.push_back(RU[SX]);\n\t\tXs.push_back(RD[SX]);\n\t\tXs.push_back(LU[SX]);\n\t\tXs.push_back(LD[SX]);\n\t\tXs.push_back(RU[TX]);\n\t\tXs.push_back(RD[TX]);\n\t\tXs.push_back(LU[TX]);\n\t\tXs.push_back(LD[TX]);\n\t\tsort(ALL(Xs));\n\t\tsort(ALL(Ys));\n\t\tXs.erase(unique(ALL(Xs)),Xs.end());\n\t\tYs.erase(unique(ALL(Ys)),Ys.end());\n\t\tFOR(i,Xs.size()) revx[Xs[i]]=i;\n\t\tFOR(i,Ys.size()) revy[Ys[i]]=i;\n\t\tFOR(y,Ys.size()) FOR(x,Xs.size()) dist[y][x]=1LL<<60;\n\t\tdist[revy[SY]][revx[SX]]=0;\n\t\tpriority_queue<pair<ll,int>> PQ;\n\t\tPQ.push({0,revy[SY]*10+revx[SX]});\n\t\t\n\t\t/*\n\t\tcout<<\"Y  \";\n\t\tFORR(y,Ys) cout<<(y+1)<<\" \";\n\t\tcout<<endl;\n\t\tcout<<\"X  \";\n\t\tFORR(x,Xs) cout<<(x+1)<<\" \";\n\t\tcout<<endl;\n\t\t*/\n\t\twhile(PQ.size()) {\n\t\t\tll co=-PQ.top().first;\n\t\t\tint cy=PQ.top().second/10;\n\t\t\tint cx=PQ.top().second%10;\n\t\t\tPQ.pop();\n\t\t\tif(dist[cy][cx]!=co) continue;\n\t\t\t//cout<<\"!\"<<cx<<\" \"<<cy<<\" \"<<co<<endl;\n\t\t\t\n\t\t\tif(LR[Ys[cy]]=='W' && cx) {\n\t\t\t\tll nc=co+abs(Xs[cx]-Xs[cx-1]);\n\t\t\t\tif(nc<dist[cy][cx-1]) {\n\t\t\t\t\tdist[cy][cx-1]=nc;\n\t\t\t\t\tPQ.push({-nc,(cy)*10+cx-1});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(LR[Ys[cy]]=='E' && cx<Xs.size()-1) {\n\t\t\t\tll nc=co+abs(Xs[cx]-Xs[cx+1]);\n\t\t\t\tif(nc<dist[cy][cx+1]) {\n\t\t\t\t\tdist[cy][cx+1]=nc;\n\t\t\t\t\tPQ.push({-nc,(cy)*10+cx+1});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(UD[Xs[cx]]=='N' && cy) {\n\t\t\t\tll nc=co+abs(Ys[cy]-Ys[cy-1]);\n\t\t\t\tif(nc<dist[cy-1][cx]) {\n\t\t\t\t\tdist[cy-1][cx]=nc;\n\t\t\t\t\tPQ.push({-nc,(cy-1)*10+cx});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(UD[Xs[cx]]=='S' && cy<Ys.size()-1) {\n\t\t\t\tll nc=co+abs(Ys[cy]-Ys[cy+1]);\n\t\t\t\tif(nc<dist[cy+1][cx]) {\n\t\t\t\t\tdist[cy+1][cx]=nc;\n\t\t\t\t\tPQ.push({-nc,(cy+1)*10+cx});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[revy[TY]][revx[TX]]==1LL<<60) {\n\t\t\tdist[revy[TY]][revx[TX]]=-1;\n\t\t}\n\t\tcout<<dist[revy[TY]][revx[TX]]<<endl;\n\t\t\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_set>\n# include <unordered_map>\nusing namespace std;\n\n\nint n, m, qq;\nstring s1, s2;\nint ans;\nint XX, YY;\nint pr1[100005][2];\nint sf1[100005][2];\nint pr2[100005][2];\nint sf2[100005][2];\n\nvoid upd(int x) {\n    if (x < ans) ans = x;\n    return;\n}\n\nvoid check(int x, int y, int len) {\n    if (XX == x && YY == y) { upd(len); return;}\n    len += abs(x - XX) + abs(y - YY);\n    if (XX == x) {\n        if ((YY < y && s1[x] == 'W') || (YY > y && s1[x] == 'E')) { upd(len);}\n        return;\n    }\n    if (YY == y) {\n        if ((XX < x && s2[y] == 'N') || (XX > x && s2[y] == 'S')) upd(len);\n        return;\n    }\n    char c1, c2;\n    if (XX > x) c1 = 'S';\n    else c1 = 'N';\n    if (YY > y) c2 = 'E';\n    else c2 = 'W';\n    if ((s1[x] == c2 && s2[YY] == c1) || (s2[y] == c1 && s1[XX] == c2)) upd(len);\n    return;\n}\n\nvoid recurs(int x, int y, int d, int len) {\n    check(x, y, len);\n    if (d == 5) return;\n    if (s1[x] == 'E' && s2[y] == 'N') {\n        if (sf2[y][1]) recurs(x, sf2[y][1], d + 1, len + sf2[y][1] - y);\n        if (pr1[x][1]) recurs(pr1[x][1], y, d + 1, len + x - pr1[x][1]);\n    } else if (s1[x] == 'E' && s2[y] == 'S') {\n        if (sf2[y][0]) recurs(x, sf2[y][0], d + 1, len + sf2[y][0] - y);\n        if (sf1[x][1]) recurs(sf1[x][1], y, d + 1, len + sf1[x][1] - x);\n    } else if (s1[x] == 'W' && s2[y] == 'N') {\n        if (pr2[y][1]) recurs(x, pr2[y][1], d + 1, len + y - pr2[y][1]);\n        if (pr1[x][0]) recurs(pr1[x][0], y, d + 1, len + x - pr1[x][0]);\n    } else {\n        if (pr2[y][0]) recurs(x, pr2[y][0], d + 1, len + y - pr2[y][0]);\n        if (sf1[x][0]) recurs(sf1[x][0], y, d + 1, len + sf1[x][0] - x);\n    }\n    return;\n}\n\nint main(int argc, const char * argv[]) {\n//    freopen(\"/Users/danya.smelskiy/Documents/Danya/Resources/input.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m >> qq;\n    cin >> s1 >> s2;\n    s1 = \"#\" + s1;\n    s2 = \"#\" + s2;\n    \n    for (int i = 1; i <= n; ++i) {\n        pr1[i][0] = pr1[i - 1][0];\n        pr1[i][1] = pr1[i - 1][1];\n        if (s1[i] == 'E') pr1[i][0] = i;\n        else pr1[i][1] = i;\n    }\n    for (int i = n; i > 0; --i) {\n        sf1[i][0] = sf1[i + 1][0];\n        sf1[i][1] = sf1[i + 1][1];\n        if (s1[i] == 'E') sf1[i][0] = i;\n        else sf1[i][1] = i;\n    }\n    \n    for (int i = 1; i <= m; ++i) {\n        pr2[i][0] = pr2[i - 1][0];\n        pr2[i][1] = pr2[i - 1][1];\n        if (s2[i] == 'N') pr2[i][0] = i;\n        else pr2[i][1] = i;\n    }\n    for (int i = m; i > 0; --i) {\n        sf2[i][0] = sf2[i + 1][0];\n        sf2[i][1] = sf2[i + 1][1];\n        if (s2[i] == 'N') sf2[i][0] = i;\n        else sf2[i][1] = i;\n    }\n    int x, y;\n    while (qq--) {\n        cin >> x >> y >> XX >> YY;\n        ans = 1e9;\n        recurs(x, y, 0, 0);\n        if (ans < 1e9) cout << ans << '\\n';\n        else cout << \"-1\\n\";\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n, m, q;\n    cin>>n>>m>>q;\n    string s, t;\n    cin>>s>>t;\n    vector<int> vw, ve, vn, vs;\n    for(int i=0; i<n; i++){\n        if(s[i]=='W') vw.push_back(i);\n        else ve.push_back(i);\n    }\n    for(int i=0; i<m; i++){\n        if(t[i]=='N') vn.push_back(i);\n        else vs.push_back(i);\n    }\n    while(q--){\n        int a, b, c, d;\n        cin>>a>>b>>c>>d;\n        a--; b--; c--; d--;\n        int h[6], w[6];\n        h[1]=min(a, c), h[4]=max(a, c), w[1]=min(b, d), w[4]=max(b, d);\n        if(s[h[1]]=='W'){\n            h[2]=upper_bound(ve.begin(), ve.end(), h[1])-ve.begin();\n            if(h[2]-1>=0) h[0]=ve[h[2]-1];\n            else h[0]=-1;\n            if(h[2]<ve.size()) h[2]=ve[h[2]];\n            else h[2]=-1;\n            int k=upper_bound(vw.begin(), vw.end(), h[1])-vw.begin();\n            if(k<vw.size()) h[3]=vw[k];\n            else h[3]=-1;\n            if(h[2]>=h[4]) h[2]=-1;\n            if(h[3]>=h[4]) h[3]=-1;\n        }else{\n            h[2]=upper_bound(vw.begin(), vw.end(), h[1])-vw.begin();\n            if(h[2]-1>=0) h[0]=vw[h[2]-1];\n            else h[0]=-1;\n            if(h[2]<vw.size()) h[2]=vw[h[2]];\n            else h[2]=-1;\n            int k=upper_bound(ve.begin(), ve.end(), h[1])-ve.begin();\n            if(k<ve.size()) h[3]=ve[k];\n            else h[3]=-1;\n            if(h[2]>=h[4]) h[2]=-1;\n            if(h[3]>=h[4]) h[3]=-1;\n        }\n        if(s[h[4]]=='W'){\n            h[5]=upper_bound(ve.begin(), ve.end(), h[4])-ve.begin();\n            if(h[5]<ve.size()) h[5]=ve[h[5]];\n            else h[5]=-1;\n        }else{\n            h[5]=upper_bound(vw.begin(), vw.end(), h[4])-vw.begin();\n            if(h[5]<vw.size()) h[5]=vw[h[5]];\n            else h[5]=-1;\n        }\n        if(t[w[1]]=='N'){\n            w[2]=upper_bound(vs.begin(), vs.end(), w[1])-vs.begin();\n            if(w[2]-1>=0) w[0]=vs[w[2]-1];\n            else w[0]=-1;\n            if(w[2]<vs.size()) w[2]=vs[w[2]];\n            else w[2]=-1;\n            int k=upper_bound(vn.begin(), vn.end(), w[1])-vn.begin();\n            if(k<vn.size()) w[3]=vn[k];\n            else w[3]=-1;\n            if(w[2]>=w[4]) w[2]=-1;\n            if(w[3]>=w[4]) w[3]=-1;\n        }else{\n            w[2]=upper_bound(vn.begin(), vn.end(), w[1])-vn.begin();\n            if(w[2]-1>=0) w[0]=vn[w[2]-1];\n            else w[0]=-1;\n            if(w[2]<vn.size()) w[2]=vn[w[2]];\n            else w[2]=-1;\n            int k=upper_bound(vs.begin(), vs.end(), w[1])-vs.begin();\n            if(k<vs.size()) w[3]=vs[k];\n            else w[3]=-1;\n            if(w[2]>=w[4]) w[2]=-1;\n            if(w[3]>=w[4]) w[3]=-1;\n        }\n        if(t[w[4]]=='N'){\n            w[5]=upper_bound(vs.begin(), vs.end(), w[4])-vs.begin();\n            if(w[5]<vs.size()) w[5]=vs[w[5]];\n            else w[5]=-1;\n        }else{\n            w[5]=upper_bound(vn.begin(), vn.end(), w[4])-vn.begin();\n            if(w[5]<vn.size()) w[5]=vn[w[5]];\n            else w[5]=-1;\n        }\n        if(h[2]>h[3]) swap(h[2], h[3]);\n        if(w[2]>w[3]) swap(w[2], w[3]);\n        int h1[6], w1[6], cx=0, cy=0;\n        for(int i=0; i<6; i++){\n            if(h[i]==-1) continue;\n            h1[cx++]=h[i];\n        }\n        for(int i=0; i<6; i++){\n            if(w[i]==-1) continue;\n            w1[cy++]=w[i];\n        }\n        int ax, ay, bx, by;\n        for(int j=0; j<cx; j++){\n            if(h1[j]==a) ax=j;\n            else if(h1[j]==c) bx=j;\n        }\n        for(int j=0; j<cy; j++){\n            if(w1[j]==b) ay=j;\n            else if(w1[j]==d) by=j;\n        }\n        vector<P> g[36];\n        for(int i=0; i<cx; i++){\n            for(int j=0; j<cy-1; j++){\n                if(s[h1[i]]=='W') g[i*cy+j+1].push_back({w1[j+1]-w1[j], i*cy+j});\n                else g[i*cy+j].push_back({w1[j+1]-w1[j], i*cy+j+1});\n            }\n        }\n        for(int j=0; j<cy; j++){\n            for(int i=0; i<cx-1; i++){\n                if(t[w1[j]]=='N') g[(i+1)*cy+j].push_back({h1[i+1]-h1[i], i*cy+j});\n                else g[i*cy+j].push_back({h1[i+1]-h1[i], (i+1)*cy+j});\n            }\n        }\n        priority_queue<P, vector<P>, greater<P>> que;\n        int dist[36];\n        const int INF=1e9+7;\n        fill(dist, dist+36, INF);\n        que.push({0, ax*cy+ay});\n        dist[ax*cy+ay]=0;\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n            int x=p.second;\n            if(dist[x]<p.first) continue;\n            for(auto pr:g[x]){\n                int y=pr.second, e=pr.first;\n                if(dist[y]>dist[x]+e){\n                    dist[y]=dist[x]+e;\n                    que.push({dist[y], y});\n                }\n            }\n        }\n        if(dist[bx*cy+by]<INF) printf(\"%d\\n\", dist[bx*cy+by]);\n        else printf(\"-1\\n\");\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdint>\n#include <type_traits>\n#include <algorithm>\n#include <iterator>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <initializer_list>\nnamespace loquat {\nnamespace bitmanip {\ntemplate <typename T>\ninline auto ctz(T x) noexcept ->\n\ttypename std::enable_if<sizeof(T) <= sizeof(int), unsigned int>::type\n{\n\treturn __builtin_ctz(x);\n}\ntemplate <typename T>\ninline auto ctz(T x) noexcept ->\n\ttypename std::enable_if<sizeof(int) < sizeof(T), unsigned int>::type\n{\n\treturn __builtin_ctzll(x);\n}\ntemplate <typename T>\ninline auto clz(T x) noexcept ->\n\ttypename std::enable_if<sizeof(int) < sizeof(T), unsigned int>::type\n{\n\treturn __builtin_clzll(x);\n}\ntemplate <typename T>\ninline T flp2(T x) noexcept {\n\tif(x == 0u){ return 0u; }\n\treturn T(1u) << (sizeof(T) * 8u - 1u - clz(x));\n}\n}\n}\nnamespace loquat {\ntemplate <typename Impl>\nclass range_query_behavior_wrapper {\npublic:\n\tusing value_type = typename Impl::value_type;\nprivate:\n\tImpl m_impl;\npublic:\n\trange_query_behavior_wrapper(Impl impl) : m_impl(std::move(impl)) { }\n\tvalue_type identity() const {\n\t\treturn m_impl.identity();\n\t}\n\tvalue_type merge(const value_type& a, const value_type& b) const {\n\t\treturn m_impl.merge(a, b);\n\t}\n};\n}\nnamespace loquat {\ntemplate <typename Behavior>\nclass nazo_table {\npublic:\n\tusing behavior_type = Behavior;\n\tusing value_type = typename behavior_type::value_type;\nprivate:\n\tstd::vector<std::vector<value_type>> m_table;\n\trange_query_behavior_wrapper<behavior_type> m_behavior;\n\ttemplate <typename Iterator>\n\tvoid forward_fill(Iterator it, int row, int first, int last){\n\t\tvalue_type acc = m_behavior.identity();\n\t\tm_table[row][first] = acc;\n\t\tfor(int i = first + 1; i < last; ++i, ++it){\n\t\t\tacc = m_behavior.merge(acc, *it);\n\t\t\tm_table[row][i] = acc;\n\t\t}\n\t}\n\ttemplate <typename Iterator>\n\tvoid backward_fill(Iterator it, int row, int first, int last){\n\t\tvalue_type acc = m_behavior.identity();\n\t\t--it;\n\t\tfor(int i = first - 1; i >= last; --i, --it){\n\t\t\tacc = m_behavior.merge(*it, acc);\n\t\t\tm_table[row][i] = acc;\n\t\t}\n\t}\n\ttemplate <typename Iterator>\n\tvoid fill_table(Iterator first, Iterator last){\n\t\tconst int n = std::distance(first, last);\n\t\tIterator it = std::next(first);\n\t\tfor(int i = 1; i <= n; ++i, ++it){\n\t\t\tconst int s = bitmanip::ctz(i);\n\t\t\twhile(m_table.size() <= static_cast<size_t>(s)){\n\t\t\t\tm_table.emplace_back(n + 1);\n\t\t\t}\n\t\t\tbackward_fill(it, s, i, i - (1 << s));\n\t\t\tforward_fill(it, s, i, std::min(n + 1, i + (1 << s)));\n\t\t}\n\t}\npublic:\n\ttemplate <typename Iterator>\n\tnazo_table(\n\t\tIterator first,\n\t\tIterator last,\n\t\tconst behavior_type& behavior = behavior_type())\n\t\t: m_table()\n\t\t, m_behavior(behavior)\n\t{\n\t\tfill_table(first, last);\n\t}\n\tvalue_type query(size_t l, size_t r) const {\n\t\tif(l == r){ return m_behavior.identity(); }\n\t\tconst int s = bitmanip::ctz(bitmanip::flp2(l ^ r));\n\t\treturn m_behavior.merge(m_table[s][l], m_table[s][r]);\n\t}\n};\n}\nusing namespace std;\nstatic const int INF = 1000000000;\nstruct min_behavior {\n\tusing value_type = int;\n\tvalue_type identity() const { return numeric_limits<int>::max(); }\n\tvalue_type merge(const value_type& a, const value_type& b) const { return min(a, b); }\n};\nstruct max_behavior {\n\tusing value_type = int;\n\tvalue_type identity() const { return numeric_limits<int>::min(); }\n\tvalue_type merge(const value_type& a, const value_type& b) const { return max(a, b); }\n};\nint solve(\n\tint depth, int a, int b, int c, int d,\n\tconst string& hor, const string& ver,\n\tconst loquat::nazo_table<min_behavior>& min_w,\n\tconst loquat::nazo_table<max_behavior>& max_w,\n\tconst loquat::nazo_table<min_behavior>& min_e,\n\tconst loquat::nazo_table<max_behavior>& max_e,\n\tconst loquat::nazo_table<min_behavior>& min_n,\n\tconst loquat::nazo_table<max_behavior>& max_n,\n\tconst loquat::nazo_table<min_behavior>& min_s,\n\tconst loquat::nazo_table<max_behavior>& max_s)\n{\n\tif(depth >= 5){ return INF; }\n\tconst int n = hor.size(), m = ver.size();\n\tint answer = INF;\n\tif(hor[a] == 'W' || hor[a] == 'N'){\n\t\tif(d < b){\n\t\t\tif(a == c){ answer = min(answer, b - d); }\n\t\t\tconst int x1 = max_n.query(0, b + 1);\n\t\t\tif(x1 >= 0){ answer = min(answer, solve(depth + 1, x1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - x1)); }\n\t\t\tconst int y1 = max_s.query(0, b + 1);\n\t\t\tif(y1 >= 0){ answer = min(answer, solve(depth + 1, y1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - y1)); }\n\t\t\tconst int x2 = max_n.query(0, d + 1);\n\t\t\tif(x2 >= 0 && x1 != x2){ answer = min(answer, solve(depth + 1, x2, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - x2)); }\n\t\t\tconst int y2 = max_s.query(0, d + 1);\n\t\t\tif(y2 >= 0 && y1 != y2){ answer = min(answer, solve(depth + 1, y2, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - y2)); }\n\t\t}else{\n\t\t\tconst int x1 = max_n.query(0, b + 1);\n\t\t\tif(x1 >= 0){ answer = min(answer, solve(depth + 1, x1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - x1)); }\n\t\t\tconst int y1 = max_s.query(0, b + 1);\n\t\t\tif(y1 >= 0){ answer = min(answer, solve(depth + 1, y1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (b - y1)); }\n\t\t}\n\t}else{\n\t\tif(d > b){\n\t\t\tif(a == c){ answer = min(answer, d - b); }\n\t\t\tconst int x1 = min_n.query(b, m);\n\t\t\tif(x1 < m){ answer = min(answer, solve(depth + 1, x1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (x1 - b)); }\n\t\t\tconst int y1 = min_s.query(b, m);\n\t\t\tif(y1 < m){ answer = min(answer, solve(depth + 1, y1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (y1 - b)); }\n\t\t\tconst int x2 = min_n.query(d, m);\n\t\t\tif(x2 < m && x1 != x2){ answer = min(answer, solve(depth + 1, x2, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (x2 - b)); }\n\t\t\tconst int y2 = min_s.query(d, m);\n\t\t\tif(y2 < m && y1 != y2){ answer = min(answer, solve(depth + 1, y2, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (y2 - b)); }\n\t\t}else{\n\t\t\tconst int x1 = min_n.query(b, m);\n\t\t\tif(x1 < m){ answer = min(answer, solve(depth + 1, x1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (x1 - b)); }\n\t\t\tconst int y1 = min_s.query(b, m);\n\t\t\tif(y1 < m){ answer = min(answer, solve(depth + 1, y1, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e) + (y1 - b)); }\n\t\t}\n\t}\n\treturn answer;\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, q;\n\tstring hor, ver;\n\tcin >> n >> m >> q >> hor >> ver;\n\tvector<int> min_w_init(n, numeric_limits<int>::max());\n\tvector<int> max_w_init(n, numeric_limits<int>::min());\n\tvector<int> min_e_init(n, numeric_limits<int>::max());\n\tvector<int> max_e_init(n, numeric_limits<int>::min());\n\tvector<int> min_n_init(m, numeric_limits<int>::max());\n\tvector<int> max_n_init(m, numeric_limits<int>::min());\n\tvector<int> min_s_init(m, numeric_limits<int>::max());\n\tvector<int> max_s_init(m, numeric_limits<int>::min());\n\tfor(int i = 0; i < n; ++i){\n\t\tif(hor[i] == 'W'){\n\t\t\tmin_w_init[i] = i;\n\t\t\tmax_w_init[i] = i;\n\t\t}else{\n\t\t\tmin_e_init[i] = i;\n\t\t\tmax_e_init[i] = i;\n\t\t}\n\t}\n\tfor(int i = 0; i < m; ++i){\n\t\tif(ver[i] == 'N'){\n\t\t\tmin_n_init[i] = i;\n\t\t\tmax_n_init[i] = i;\n\t\t}else{\n\t\t\tmin_s_init[i] = i;\n\t\t\tmax_s_init[i] = i;\n\t\t}\n\t}\n\tconst loquat::nazo_table<min_behavior> min_w(min_w_init.begin(), min_w_init.end());\n\tconst loquat::nazo_table<max_behavior> max_w(max_w_init.begin(), max_w_init.end());\n\tconst loquat::nazo_table<min_behavior> min_e(min_e_init.begin(), min_e_init.end());\n\tconst loquat::nazo_table<max_behavior> max_e(max_e_init.begin(), max_e_init.end());\n\tconst loquat::nazo_table<min_behavior> min_n(min_n_init.begin(), min_n_init.end());\n\tconst loquat::nazo_table<max_behavior> max_n(max_n_init.begin(), max_n_init.end());\n\tconst loquat::nazo_table<min_behavior> min_s(min_s_init.begin(), min_s_init.end());\n\tconst loquat::nazo_table<max_behavior> max_s(max_s_init.begin(), max_s_init.end());\n\twhile(q--){\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\t--a; --b; --c; --d;\n\t\tconst int answer = min(\n\t\t \tsolve(0, a, b, c, d, hor, ver, min_w, max_w, min_e, max_e, min_n, max_n, min_s, max_s),\n\t\t \tsolve(0, b, a, d, c, ver, hor, min_n, max_n, min_s, max_s, min_w, max_w, min_e, max_e));\n\t\tif(answer >= INF){\n\t\t\tcout << -1 << \"\\n\";\n\t\t}else{\n\t\t\tcout << answer << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sort stable_sort\n#define all(x) (x).begin(),(x).end()\n#define rep(i,x) for (int (i)=(1);(i)<=(x);(i)++)\n#define rep2(i,x) for (int (i)=(x);(i)>=(1);(i)--)\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\nusing namespace std;\nint n,m,q,i,j,nxtx[100005],prex[100005],nxty[100005],prey[100005],x,y,xx,yy,lst1,lst2;\nll dis[55];\nstring s,t;\nchar ss[100005];\nvector<pair<int,int> > all;\nvector<pair<int,int> > bi[55];\nvoid add(int x,int y)\n{\n\tall.push_back(make_pair(x,y));\n\tif (prex[x]) all.push_back(make_pair(prex[x],y));\n\tif (nxtx[x]) all.push_back(make_pair(nxtx[x],y));\n\tif (prey[y]) all.push_back(make_pair(x,prey[y]));\n\tif (nxty[y]) all.push_back(make_pair(x,nxty[y]));\n\tif (prex[x]&&prey[y]) all.push_back(make_pair(prex[x],prey[y]));\n\tif (prex[x]&&nxty[y]) all.push_back(make_pair(prex[x],nxty[y]));\n\tif (nxtx[x]&&prey[y]) all.push_back(make_pair(nxtx[x],prey[y]));\n\tif (nxtx[x]&&nxty[y]) all.push_back(make_pair(nxtx[x],nxty[y]));\n}\nll dijkstra(int x,int y)\n{\n\tmemset(dis,18,sizeof(dis));\n\tdis[x]=0;\n\tpriority_queue<pair<ll,ll> > pq;\n\tpq.push(make_pair(0,x));\n\twhile (!pq.empty())\n\t{\n\t\tx=pq.top().second;pq.pop();\n\t\tforeach(it,bi[x])\n\t\t{\n\t\t\tif (dis[it->fi]>dis[x]+it->se)\n\t\t\t{\n\t\t\t\tdis[it->fi]=dis[x]+it->se;\n\t\t\t\tpq.push(make_pair(-dis[it->fi],it->fi));\n\t\t\t}\n\t\t}\n\t}\n\tif (dis[y]==dis[54]) return -1;\n\treturn dis[y];\n}\nvoid solve(int x,int y,int xx,int yy)\n{\n\tsort(all.begin(),all.end());\n\tall.resize(unique(all.begin(),all.end())-all.begin());\n//\tforeach(it,all) cerr<<it->fi<<' '<<it->se<<endl;\n\tint i,j,ss,tt;\n\tfor (i=0;i<all.size();i++) if (all[i].first==x&&all[i].second==y) ss=i;\n\tfor (i=0;i<all.size();i++) if (all[i].first==xx&&all[i].second==yy) tt=i;\n\tfor (i=0;i<all.size();i++) bi[i].clear();\n\tfor (i=0;i<all.size();i++) for (j=0;j<all.size();j++) if (i!=j)\n\t{\n\t\tif (all[i].first==all[j].first&&((s[all[i].first]=='E')==(all[i].second<all[j].second)))\n\t\t{\n\t\t\tbi[i].push_back(make_pair(j,abs(all[i].second-all[j].second)));\n\t\t}\n\t\tif (all[i].second==all[j].second&&((t[all[i].second]=='S')==(all[i].first<all[j].first)))\n\t\t{\n\t\t\tbi[i].push_back(make_pair(j,abs(all[i].first-all[j].first)));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dijkstra(ss,tt));\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\" %s\",ss);s=ss;s=\" \"+s;\n\tscanf(\" %s\",ss);t=ss;t=\" \"+t;\n\tlst1=lst2=0;\n\trep(i,n){if (s[i]=='W'){prex[i]=lst2;lst1=i;}else{prex[i]=lst1;lst2=i;}}\n\tlst1=lst2=0;\n\trep2(i,n){if (s[i]=='W'){nxtx[i]=lst2;lst1=i;}else{nxtx[i]=lst1;lst2=i;}}\n\tlst1=lst2=0;\n\trep(i,m){if (t[i]=='N'){prey[i]=lst2;lst1=i;}else{prey[i]=lst1;lst2=i;}}\n\tlst1=lst2=0;\n\trep2(i,m){if (t[i]=='N'){nxty[i]=lst2;lst1=i;}else{nxty[i]=lst1;lst2=i;}}\n\twhile (q--)\n\t{\n\t\tscanf(\"%d%d%d%d\",&x,&y,&xx,&yy);\n\t\tall.clear();\n\t\tadd(x,y);add(x,yy);add(xx,y);add(xx,yy);\n\t\tsolve(x,y,xx,yy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }  \n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n    int ans=INF;\n    MFP([&](auto dfs,int y,int x,int sum,int step)->void{                 \n          if(y==c&&x==d) chmin(ans,sum);          \n          if(step>=5) return;          \n          if(sum+abs(y-c)+abs(x-d)>=ans) return;\n          //cout<<y<<\" \"<<x<<\" \"<<sum<<\" \"<<step<<endl;\n          \n          if(s[y]=='W'){\n            // N           \n            for(int xx:{x,d}){\n              auto it=--upper_bound(vn.begin(),vn.end(),xx);\n              if(*it<=x) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n            // S\n            for(int xx:{x,d}){\n              auto it=--upper_bound(vs.begin(),vs.end(),xx);\n              if(*it<=x) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n          }else{\n            // N           \n            for(int xx:{x,d}){\n              auto it=lower_bound(vn.begin(),vn.end(),xx);\n              if(x<=*it) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n            // S\n            for(int xx:{x,d}){\n              auto it=lower_bound(vs.begin(),vs.end(),xx);\n              if(x<=*it) dfs(y,*it,sum+abs(*it-x),step+1);              \n            }\n          }\n          if(t[x]=='N'){            \n            // W         \n            for(int yy:{y,c}){\n              auto it=--upper_bound(vw.begin(),vw.end(),yy);\n              if(*it<=y) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n            // E\n            for(int yy:{y,c}){\n              auto it=--upper_bound(ve.begin(),ve.end(),yy);\n              if(*it<=y) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n          }else{\n            // W         \n            for(int yy:{y,c}){\n              auto it=lower_bound(vw.begin(),vw.end(),yy);\n              if(y<=*it) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n            // E\n            for(int yy:{y,c}){\n              auto it=lower_bound(ve.begin(),ve.end(),yy);\n              if(y<=*it) dfs(*it,x,sum+abs(*it-y),step+1);\n            }\n          }\n        })(a,b,0,0);\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n, m, q;\n    cin>>n>>m>>q;\n    string s, t;\n    cin>>s>>t;\n    vector<int> vw, ve, vn, vs;\n    for(int i=0; i<n; i++){\n        if(s[i]=='W') vw.push_back(i);\n        else ve.push_back(i);\n    }\n    for(int i=0; i<m; i++){\n        if(t[i]=='N') vn.push_back(i);\n        else vs.push_back(i);\n    }\n    while(q--){\n        int a, b, c, d;\n        cin>>a>>b>>c>>d;\n        a--; b--; c--; d--;\n        int h[6], w[6];\n        h[1]=min(a, c), h[4]=max(a, c), w[1]=min(b, d), w[4]=max(b, d);\n        if(s[h[1]]=='W'){\n            h[2]=upper_bound(ve.begin(), ve.end(), h[1])-ve.begin();\n            if(h[2]-1>=0) h[0]=ve[h[2]-1];\n            else h[0]=-1;\n            if(h[2]<ve.size()) h[2]=ve[h[2]];\n            else h[2]=-1;\n            int k=upper_bound(vw.begin(), vw.end(), h[1])-vw.begin();\n            if(k<vw.size()) h[3]=vw[k];\n            else h[3]=-1;\n            if(h[2]>=h[4]) h[2]=-1;\n            if(h[3]>=h[4]) h[3]=-1;\n        }else{\n            h[2]=upper_bound(vw.begin(), vw.end(), h[1])-vw.begin();\n            if(h[2]-1>=0) h[0]=vw[h[2]-1];\n            else h[0]=-1;\n            if(h[2]<vw.size()) h[2]=vw[h[2]];\n            else h[2]=-1;\n            int k=upper_bound(ve.begin(), ve.end(), h[1])-ve.begin();\n            if(k<ve.size()) h[3]=ve[k];\n            else h[3]=-1;\n            if(h[2]>=h[4]) h[2]=-1;\n            if(h[3]>=h[4]) h[3]=-1;\n        }\n        if(s[h[4]]=='W'){\n            h[5]=upper_bound(ve.begin(), ve.end(), h[4])-ve.begin();\n            if(h[5]<ve.size()) h[5]=ve[h[5]];\n            else h[5]=-1;\n        }else{\n            h[5]=upper_bound(vw.begin(), vw.end(), h[4])-vw.begin();\n            if(h[5]<vw.size()) h[5]=vw[h[5]];\n            else h[5]=-1;\n        }\n        if(t[w[1]]=='N'){\n            w[2]=upper_bound(vs.begin(), vs.end(), w[1])-vs.begin();\n            if(w[2]-1>=0) w[0]=vs[w[2]-1];\n            else w[0]=-1;\n            if(w[2]<vs.size()) w[2]=vs[w[2]];\n            else w[2]=-1;\n            int k=upper_bound(vn.begin(), vn.end(), w[1])-vn.begin();\n            if(k<vn.size()) w[3]=vn[k];\n            else w[3]=-1;\n            if(w[2]>=w[4]) w[2]=-1;\n            if(w[3]>=w[4]) w[3]=-1;\n        }else{\n            w[2]=upper_bound(vn.begin(), vn.end(), w[1])-vn.begin();\n            if(w[2]-1>=0) w[0]=vn[w[2]-1];\n            else w[0]=-1;\n            if(w[2]<vn.size()) w[2]=vn[w[2]];\n            else w[2]=-1;\n            int k=upper_bound(vs.begin(), vs.end(), w[1])-vs.begin();\n            if(k<vs.size()) w[3]=vs[k];\n            else w[3]=-1;\n            if(w[2]>=w[4]) w[2]=-1;\n            if(w[3]>=w[4]) w[3]=-1;\n        }\n        if(t[w[4]]=='N'){\n            w[5]=upper_bound(vs.begin(), vs.end(), w[4])-vs.begin();\n            if(w[5]<vs.size()) w[5]=vs[w[5]];\n            else w[5]=-1;\n        }else{\n            w[5]=upper_bound(vn.begin(), vn.end(), w[4])-vn.begin();\n            if(w[5]<vn.size()) w[5]=vn[w[5]];\n            else w[5]=-1;\n        }\n        if(h[2]>h[3]) swap(h[2], h[3]);\n        if(w[2]>w[3]) swap(w[2], w[3]);\n        int h1[6], w1[6], cx=0, cy=0;\n        for(int i=0; i<6; i++){\n            if(h[i]==-1) continue;\n            h1[cx++]=h[i];\n        }\n        for(int i=0; i<6; i++){\n            if(w[i]==-1) continue;\n            w1[cy++]=w[i];\n        }\n        int ax, ay, bx, by;\n        for(int j=0; j<cx; j++){\n            if(h1[j]==a) ax=j;\n            else if(h1[j]==c) bx=j;\n        }\n        for(int j=0; j<cy; j++){\n            if(w1[j]==b) ay=j;\n            else if(w1[j]==d) by=j;\n        }\n        vector<P> g[36];\n        for(int i=0; i<cx; i++){\n            for(int j=0; j<cy-1; j++){\n                if(w1[j]==w1[j+1]){\n                    g[i*cy+j+1].push_back({w1[j+1]-w1[j], i*cy+j});\n                    g[i*cy+j].push_back({w1[j+1]-w1[j], i*cy+j+1});\n                }else if(s[h1[i]]=='W') g[i*cy+j+1].push_back({w1[j+1]-w1[j], i*cy+j});\n                else g[i*cy+j].push_back({w1[j+1]-w1[j], i*cy+j+1});\n            }\n        }\n        for(int j=0; j<cy; j++){\n            for(int i=0; i<cx-1; i++){\n                if(h1[i]==h1[i+1]){\n                    g[(i+1)*cy+j].push_back({h1[i+1]-h1[i], i*cy+j});\n                    g[i*cy+j].push_back({h1[i+1]-h1[i], (i+1)*cy+j});\n                }else if(t[w1[j]]=='N') g[(i+1)*cy+j].push_back({h1[i+1]-h1[i], i*cy+j});\n                else g[i*cy+j].push_back({h1[i+1]-h1[i], (i+1)*cy+j});\n            }\n        }\n        priority_queue<P, vector<P>, greater<P>> que;\n        int dist[36];\n        const int INF=1e9+7;\n        fill(dist, dist+36, INF);\n        que.push({0, ax*cy+ay});\n        dist[ax*cy+ay]=0;\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n            int x=p.second;\n            if(dist[x]<p.first) continue;\n            for(auto pr:g[x]){\n                int y=pr.second, e=pr.first;\n                if(dist[y]>dist[x]+e){\n                    dist[y]=dist[x]+e;\n                    que.push({dist[y], y});\n                }\n            }\n        }\n        if(dist[bx*cy+by]<INF) printf(\"%d\\n\", dist[bx*cy+by]);\n        else printf(\"-1\\n\");\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\nint selectSmall(const set<int>& s, int a)\n{\n    auto it = s.upper_bound(a);\n    if(it == s.begin())\n        return -INF;\n    -- it;\n    return *it;\n}\n\nint selectLarge(const set<int>& s, int a)\n{\n    auto it = s.lower_bound(a);\n    if(it == s.end())\n        return INF;\n    return *it;\n}\n\nint solve(\n    const set<int>& leftRoad,\n    const set<int>& rightRoad,\n    const set<int>& upRoad,\n    const set<int>& downRoad,\n    int sy, int sx, int gy, int gx, int depth\n)\n{\n    if(sy == gy){\n        if((leftRoad.find(sy) != leftRoad.end()) ^ (sx < gx))\n            return abs(sx - gx);\n    }\n\n    if(depth == 0)\n        return INF;\n\n    int ans = INF;\n    if(leftRoad.find(sy) != leftRoad.end()){\n        int x1 = selectSmall(upRoad, sx);\n        int x2 = selectSmall(downRoad, sx);\n        ans = min(ans, abs(sx - x1) + solve(upRoad, downRoad, leftRoad, rightRoad, x1, sy, gx, gy, depth - 1));\n        ans = min(ans, abs(sx - x2) + solve(upRoad, downRoad, leftRoad, rightRoad, x2, sy, gx, gy, depth - 1));\n        if(gx < sx){\n            int x3 = selectSmall(upRoad, gx);\n            int x4 = selectSmall(downRoad, gx);\n            ans = min(ans, abs(sx - x3) + solve(upRoad, downRoad, leftRoad, rightRoad, x3, sy, gx, gy, depth - 1));\n            ans = min(ans, abs(sx - x4) + solve(upRoad, downRoad, leftRoad, rightRoad, x4, sy, gx, gy, depth - 1));\n        }\n    }\n    else{\n        int x1 = selectLarge(upRoad, sx);\n        int x2 = selectLarge(downRoad, sx);\n        ans = min(ans, abs(sx - x1) + solve(upRoad, downRoad, leftRoad, rightRoad, x1, sy, gx, gy, depth - 1));\n        ans = min(ans, abs(sx - x2) + solve(upRoad, downRoad, leftRoad, rightRoad, x2, sy, gx, gy, depth - 1));\n        if(sx < gx){\n            int x3 = selectLarge(upRoad, gx);\n            int x4 = selectLarge(downRoad, gx);\n        ans = min(ans, abs(sx - x3) + solve(upRoad, downRoad, leftRoad, rightRoad, x3, sy, gx, gy, depth - 1));\n        ans = min(ans, abs(sx - x4) + solve(upRoad, downRoad, leftRoad, rightRoad, x4, sy, gx, gy, depth - 1));\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int h, w, q;\n    cin >> h >> w >> q;\n    string s, t;\n    cin >> s >> t;\n\n    set<int> leftRoad, rightRoad, upRoad, downRoad;\n    for(int y=0; y<h; ++y){\n        if(s[y] == 'W')\n            leftRoad.insert(y+1);\n        else\n            rightRoad.insert(y+1);\n    }\n    for(int x=0; x<w; ++x){\n        if(t[x] == 'N')\n            upRoad.insert(x+1);\n        else\n            downRoad.insert(x+1);\n    }\n\n    while(--q >= 0){\n        int sy, sx, gy, gx;\n        cin >> sy >> sx >> gy >> gx;\n        int ans = min(solve(leftRoad, rightRoad, upRoad, downRoad, sy, sx, gy, gx, 4),\n                      solve(upRoad, downRoad, leftRoad, rightRoad, sx, sy, gx, gy, 4));\n        if(ans < INF)\n            cout << ans << endl;\n        else\n            cout << -1 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 100 * 1000 + 7;\nconst int INF = 1e9 + 7;\n\nbool rg[MX], up[MX];\nint n, m;\n\nvector<int> gl, gr, gu, gd;\n\nint d[107][107];\n\nbool can_go(int x1, int y1, int x2, int y2) {\n    if (x1 == x2) {\n        if (y1 < y2) {\n            return rg[x1];\n        } else {\n            return !rg[x1];\n        }\n    } else if (y1 == y2) {\n        if (x2 < x1) {\n            return up[y1];\n        } else {\n            return !up[y1];\n        }\n    }\n    return false;\n}\n\nvector<pair<int, int> > trace(int x, int y, int depth, bool rev) {\n    vector<pair<int, int> > ans;\n    queue<pair<int, int> > q;\n    set<pair<int, int> > was;\n\n    auto ad = [&](int x, int y) {\n        if (was.count(make_pair(x, y))) {\n            return;\n        }\n        was.emplace(x, y);\n        q.emplace(x, y);\n        ans.emplace_back(x, y);\n    };\n\n    ad(x, y);\n    while (!q.empty()) {\n        int x, y;\n        tie(x, y) = q.front();\n        if (ans.size() > depth) {\n            break;\n        }\n        q.pop();\n        if (rg[x] ^ rev) {\n            {\n                int yy = lower_bound(gu.begin(), gu.end(), y) - gu.begin();\n                if (yy != gu.size()) {\n                    yy = gu[yy];\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = lower_bound(gd.begin(), gd.end(), y) - gd.begin();\n                if (yy != gd.size()) {\n                    yy = gd[yy];\n                    ad(x, yy);\n                }\n            }\n        } else {\n            {\n                int yy = upper_bound(gu.begin(), gu.end(), y) - gu.begin() - 1;\n                if (yy >= 0) {\n                    yy = gu[yy];\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = upper_bound(gd.begin(), gd.end(), y) - gd.begin() - 1;\n                if (yy >= 0) {\n                    yy = gd[yy];\n                    ad(x, yy);\n                }\n            }\n        }\n\n        if ((!up[y]) ^ rev) {\n            {\n                int xx = lower_bound(gl.begin(), gl.end(), x) - gl.begin();\n                if (xx != gl.size()) {\n                    xx = gl[xx];\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = lower_bound(gr.begin(), gr.end(), x) - gr.begin();\n                if (xx != gr.size()) {\n                    xx = gr[xx];\n                    ad(xx, y);\n                }\n            }\n        } else {\n            {\n                int xx = upper_bound(gl.begin(), gl.end(), x) - gl.begin() - 1;\n                if (xx >= 0) {\n                    xx = gl[xx];\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = upper_bound(gr.begin(), gr.end(), x) - gr.begin() - 1;\n                if (xx >= 0) {\n                    xx = gr[xx];\n                    ad(xx, y);\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint dist(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int q;\n    cin >> n >> m >> q;\n    string s;\n    cin >> s;\n    for (int i = 1; i <= n; i++) {\n        if (s[i - 1] == 'E') {\n            rg[i] = true;\n            gl.push_back(i);\n        } else {\n            gr.push_back(i);\n        }\n    }\n    cin >> s;\n    for (int i = 1; i <= m; i++) {\n        if (s[i - 1] == 'N') {\n            up[i] = true;\n            gu.push_back(i);\n        } else {\n            gd.push_back(i);\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        vector<pair<int, int> > t1 = trace(x1, y1, 5, false);\n        vector<pair<int, int> > t2 = trace(x2, y2, 5, true);\n        vector<int> xx, yy;\n        for (auto v : t1) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        for (auto v : t2) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        sort(xx.begin(), xx.end());\n        sort(yy.begin(), yy.end());\n        xx.resize(unique(xx.begin(), xx.end()) - xx.begin());\n        yy.resize(unique(yy.begin(), yy.end()) - yy.begin());\n        int n = xx.size(), m = yy.size();\n        set<tuple<int, int, int> > go;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                d[i][j] = INF;\n                if (xx[i] == x1 && yy[j] == y1) {\n                    d[i][j] = 0;\n                }\n                go.emplace(d[i][j], i, j);\n            }\n        }\n        /*\n        cerr << \"X: \";\n        for (int x : xx) {\n            cerr << x << \" \";\n        }\n        cerr << endl;\n        cerr << \"Y: \";\n        for (int y : yy) {\n            cerr << y << \" \";\n        }\n        cerr << endl;\n*/\n\n        while (!go.empty()) {\n            int D, x, y;\n            tie(D, x, y) = *go.begin();\n            go.erase(go.begin());\n            for (int gy = 0; gy < (int)yy.size(); gy++) {\n                if (can_go(xx[x], yy[y], xx[x], yy[gy]) && d[x][gy] > d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy])) {\n                    go.erase(make_tuple(d[x][gy], x, gy));\n                    d[x][gy] = d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy]);\n                    go.insert(make_tuple(d[x][gy], x, gy));\n                }\n            }\n            for (int gx = 0; gx < (int)xx.size(); gx++) {\n                if (can_go(xx[x], yy[y], xx[gx], yy[y]) && d[gx][y] > d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y])) {\n                    go.erase(make_tuple(d[gx][y], gx, y));\n                    d[gx][y] = d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y]);\n                    go.insert(make_tuple(d[gx][y], gx, y));\n                }\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (xx[i] == x2 && yy[j] == y2) {\n                    ans = d[i][j];\n                }\n            }\n        }\n\n        if (ans == INF) {\n            ans = -1;\n        }\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(),x.end()\n#define all(x) x.begin(),x.end()\n#define fi first\n#define se second\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define erase_duplicates(x) sort(all(x)); (x).resize(distance((x).begin(), unique(all(x))));\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set = tree<\nT,\nnull_type,\nless<T>,\nrb_tree_tag,\ntree_order_statistics_node_update>;\n\n//X.find_by_order(k); - zwraca iterator na k-ty element (numeracja od zerowego)\n//X.order_of_key(k); - zwraca liczbę elementów ostro mniejszych niż k\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<char> VC;\ntypedef long double LD;\ntypedef pair<LD,LD> PLD;\ntypedef vector<LD> VLD;\ntypedef vector<PLD> VPLD;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\" = \"<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<\" = \"<<h<<\", \"; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#define cerr if(0)cout\n#endif\n\nconst int maxn = (1e6)+7;\nconst int maxk = 20;\nconst int inf = (1e9)+7;\nconst LL LLinf = ((LL)1e18)+7LL;\nconst LD eps = 1e-9;\nconst LL mod = 1e9+7;\n\n// ***************************** CODE ***************************** //\n\nset<int> gora, dol, lewo, prawo;\nconst int stala = 7;\n\nint odl(PII a, PII b)\n{\n  int xd = abs(a.fi - b.fi) + abs(a.se - b.se);\n  if(a.fi >= b.fi)\n  {\n    if(gora.count(a.se))\n    {\n    //  cerr<<\"HEJ\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.fi <= b.fi)\n  {\n    if(dol.count(a.se))\n    {\n      // cerr<<\"HEJ2\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.se <= b.se)\n  {\n    if(prawo.count(a.fi))\n    {\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  if(a.se >= b.se)\n  {\n    if(lewo.count(a.fi))\n    {\n      // cerr<<\"HEJ\"<<endl;\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  return inf;\n}\n\nvoid dorzuc(vector<pair<int, PII> > & a, vector<pair<int, PII> > b, int dlu)\n{\n  for(auto s : b)\n    a.pb({s.fi + dlu, s.se});\n}\n\nvector<pair<int, PII> > gen(PII cur, int k = stala)\n{\n//  cerr<<cur.fi<<\" \"<<cur.se<<endl;\n  vector<pair<int, PII> > res;\n  res.pb({0, cur});\n  if(k == 0)\n    return res;\n    if(gora.count(cur.se))\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n    else\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n\n    if(lewo.count(cur.fi))\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n    else\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n  return res;\n\n}\n\nvector<pair<int, PII> > gen2(PII cur, int k = stala)\n{\n\n    vector<pair<int, PII> > res;\n    res.pb({0, cur});\n      return res;\n      if(dol.count(cur.se))\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n      else\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n\n      if(prawo.count(cur.fi))\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.fi);\n          if(SZ(gora) > 0 && it != gora.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.fi);\n          if(SZ(dol) > 0 && it != dol.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n      else\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.se);\n          if(SZ(gora) > 0 && it != gora.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.se);\n          if(SZ(dol) > 0 && it != dol.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n    return res;\n\n}\n\nint main()\n{\n\t_upgrade\n  int n, m, q;\n  cin>>n>>m>>q;\n  string s;\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'E')\n      prawo.insert(i + 1);\n    else\n      lewo.insert(i + 1);\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'N')\n      gora.insert(i + 1);\n    else\n      dol.insert(i + 1);\n//  gen({4, 2});\n  // cerr<<odl({4, 2}, {3, 2})<<endl;\n // return 0;\n  while(q--)\n  {\n    PII start, meta;\n    cin>>start.fi>>start.se;\n    cin>>meta.fi>>meta.se;\n    auto it = gen(start);\n    auto it2 = gen2(meta);\n  /*\n    for(auto s : it)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n    cerr<<endl;\n    for(auto s : it2)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n      cerr<<endl;\n      cerr<<endl;\n      cerr<<endl;\n*/\n    int res = inf;\n    for(auto s : it)\n      for(auto v : it2)\n      {\n  //      cerr<<s.fi<<\" \"<<v.fi<<\" \"<<odl(s.se, v.se)<<endl;\n        res = min(res, odl(s.se, v.se) + s.fi + v.fi);\n      }\n    if(res == inf)\n      cout<<\"-1\\n\";\n    else\n      cout<<res<<\"\\n\";\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 100000000000000000\n\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[200005], prer[200005], nextl[200005], nextr[200005];\nllint preu[200005], pred[200005], nextu[200005], nextd[200005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i+1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i+1] == 'S') nextd[i] = i+1;\n\t}\n\t\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(),x.end()\n#define all(x) x.begin(),x.end()\n#define fi first\n#define se second\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define erase_duplicates(x) sort(all(x)); (x).resize(distance((x).begin(), unique(all(x))));\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set = tree<\nT,\nnull_type,\nless<T>,\nrb_tree_tag,\ntree_order_statistics_node_update>;\n\n//X.find_by_order(k); - zwraca iterator na k-ty element (numeracja od zerowego)\n//X.order_of_key(k); - zwraca liczbę elementów ostro mniejszych niż k\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<char> VC;\ntypedef long double LD;\ntypedef pair<LD,LD> PLD;\ntypedef vector<LD> VLD;\ntypedef vector<PLD> VPLD;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\" = \"<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<\" = \"<<h<<\", \"; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#define cerr if(0)cout\n#endif\n\nconst int maxn = (1e6)+7;\nconst int maxk = 20;\nconst int inf = (1e9)+7;\nconst LL LLinf = ((LL)1e18)+7LL;\nconst LD eps = 1e-9;\nconst LL mod = 1e9+7;\n\n// ***************************** CODE ***************************** //\n\nset<int> gora, dol, lewo, prawo;\nconst int stala = 2;\n\nint odl(PII a, PII b)\n{\n  int xd = abs(a.fi - b.fi) + abs(a.se - b.se);\n  if(a.fi >= b.fi)\n  {\n    if(gora.count(a.se))\n    {\n    //  cerr<<\"HEJ\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.fi <= b.fi)\n  {\n    if(dol.count(a.se))\n    {\n      // cerr<<\"HEJ2\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.se <= b.se)\n  {\n    if(prawo.count(a.fi))\n    {\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  if(a.se >= b.se)\n  {\n    if(lewo.count(a.fi))\n    {\n      // cerr<<\"HEJ\"<<endl;\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  return inf;\n}\n\nvoid dorzuc(vector<pair<int, PII> > & a, vector<pair<int, PII> > b, int dlu)\n{\n  for(auto s : b)\n    a.pb({s.fi + dlu, s.se});\n}\n\nvector<pair<int, PII> > gen(PII cur, int k = stala)\n{\n//  cerr<<cur.fi<<\" \"<<cur.se<<endl;\n  vector<pair<int, PII> > res;\n  res.pb({0, cur});\n  if(k == 0)\n    return res;\n    if(gora.count(cur.se))\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n    else\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n\n    if(lewo.count(cur.fi))\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n    else\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n  return res;\n\n}\n\nvector<pair<int, PII> > gen2(PII cur, int k = stala)\n{\n\n    vector<pair<int, PII> > res;\n    res.pb({0, cur});\n    if(k == 0)\n      return res;\n\n      if(dol.count(cur.se))\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n      else\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n\n      if(prawo.count(cur.fi))\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.se);\n          if(SZ(gora) > 0 && it != gora.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.se);\n          if(SZ(dol) > 0 && it != dol.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n      else\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.se);\n          if(SZ(gora) > 0 && it != gora.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.se);\n          if(SZ(dol) > 0 && it != dol.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n    return res;\n\n}\n\nint main()\n{\n\t_upgrade\n  int n, m, q;\n  cin>>n>>m>>q;\n  string s;\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'E')\n      prawo.insert(i + 1);\n    else\n      lewo.insert(i + 1);\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'N')\n      gora.insert(i + 1);\n    else\n      dol.insert(i + 1);\n//  gen({4, 2});\n  // cerr<<odl({4, 2}, {3, 2})<<endl;\n // return 0;\n  while(q--)\n  {\n    PII start, meta;\n    cin>>start.fi>>start.se;\n    cin>>meta.fi>>meta.se;\n    auto it = gen(start);\n    auto it2 = gen2(meta);\n/*\n    for(auto s : it)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n    cerr<<endl;\n    for(auto s : it2)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n      cerr<<endl;\n      cerr<<endl;\n      cerr<<endl;\n      */\nerase_duplicates(it);\nerase_duplicates(it2);\n    int res = inf;\n    for(auto s : it)\n      for(auto v : it2)\n      {\n  //      cerr<<s.fi<<\" \"<<v.fi<<\" \"<<odl(s.se, v.se)<<endl;\n        res = min(res, odl(s.se, v.se) + s.fi + v.fi);\n      }\n    if(res == inf)\n      cout<<\"-1\\n\";\n    else\n      cout<<res<<\"\\n\";\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 200008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\n\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\n\tfor(int i=1;i<=q;i++)\t\n\t{\n\t\tpii s=from[i],t=dest[i];\n\t\t\n\t\tif(s.first>t.first or s.second>t.second) continue;\n\t\t#define case0 case0\n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=ub(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][1]),z=ub(t.first,path[0][0]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n\t\tif(s.second==t.second) continue;\n\t\t#define case1 case1\n\t\tfor(;s.first<=t.first;)\n\t\t{\n\t\t\tint x=lb(s.first,path[0][1]);\n\t\t\tif(!x) break;int tmp=abs(s.first-x)+abs(t.first-x)+abs(s.second-t.second);\n\t\t\tif(x!=s.first) \n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][0]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t#define case2 case2\n\t\tfor(;s.first<t.first;)//middle\n\t\t{\n\t\t\tint x=ub(s.first,path[0][1]);\n\t\t\tif(x>=t.first or x<=s.first) break;int tmp=abs(s.second-t.second)+abs(s.first-t.first);\n\t\t\tint at=1e9,bt=1e9;int otmp=tmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(s.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t\tif(y!=s.second)\n\t\t\t\t{\n\t\t\t\t\tint z=lb(s.first,path[0][1]);\n\t\t\t\t\tif(!z) break;tmp+=abs(z-s.first)*2;\n\t\t\t\t}\t\n\t\t\t\tat=tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t\tbt=tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=min(at,bt);\n\t\t\t\n\t\t\t//copied from  line58\n\t\t\totmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//licensed\n\t\t}\n\t}\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\t\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) dir[0][i]^=1;for(int i=1;i<=m;i++) dir[1][i]^=1;\n\tfor(int i=1;i<=q;i++) swap(from[i],dest[i]);\n\t\n\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class E,class D=ll>\nvc<D> dijkstra(const vvc<E>& g,int s){\n\tconst int n=g.size();\n\tusing P=pair<D,int>;\n\tpriority_queue<P,vc<P>,greater<P>> pq;\n\tvc<D> dist(n,inf);\n\tconst auto ar=[&](int v,D d){\n\t\tif(dist[v]>d){\n\t\t\tdist[v]=d;\n\t\t\tpq.push(P(d,v));\n\t\t}\n\t};\n\tar(s,0);\n\twhile(pq.size()){\n\t\tD d;\n\t\tint v;\n\t\ttie(d,v)=pq.top();pq.pop();\n\t\tfor(auto e:g[v])\n\t\t\tar(e.to,d+e.cost);\n\t}\n\treturn dist;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,m,q;cin>>n>>m>>q;\n\t\n\tvi rt(n);\n\tset<int> rs[2];\n\t{\n\t\tstring s;cin>>s;\n\t\trep(i,n)rt[i]=s[i]=='E';\n\t\trep(i,2){\n\t\t\trs[i].insert(-1);\n\t\t\trs[i].insert(n);\n\t\t}\n\t\trep(i,n)rs[rt[i]].insert(i);\n\t}\n\t\n\t\n\tvi ct(m);\n\tset<int> cs[2];\n\t{\n\t\tstring t;cin>>t;\n\t\trep(i,m)ct[i]=t[i]=='S';\n\t\trep(i,2){\n\t\t\tcs[i].insert(-1);\n\t\t\tcs[i].insert(m);\n\t\t}\n\t\trep(i,m)cs[ct[i]].insert(i);\n\t}\n\t\n\trep(_,q){\n\t\tint a,b,c,d;cin>>a>>b>>c>>d;\n\t\ta--;b--;c--;d--;\n\t\tvi ri{a,c},ci{b,d};\n\t\t\n\t\tfor(auto z:{a,c}){\n\t\t\tauto itr=rs[rt[z]^1].lower_bound(z);\n\t\t\tif(*itr<n)ri.pb(*itr);\n\t\t\titr--;\n\t\t\tif(*itr>=0)ri.pb(*itr);\n\t\t}\n\t\t\n\t\tfor(auto z:{b,d}){\n\t\t\tauto itr=cs[ct[z]^1].lower_bound(z);\n\t\t\tif(*itr<m)ci.pb(*itr);\n\t\t\titr--;\n\t\t\tif(*itr>=0)ci.pb(*itr);\n\t\t}\n\t\t\n\t\tmkuni(ri);\n\t\tmkuni(ci);\n\t\t\n\t\tstruct E{int to,cost;};\n\t\tint h=ri.size(),w=ci.size(),s=h*w;\n\t\tauto id=[&](int i,int j){\n\t\t\ti=lower_bound(all(ri),i)-ri.bg;\n\t\t\tj=lower_bound(all(ci),j)-ci.bg;\n\t\t\treturn i*w+j;\n\t\t};\n\t\tvvc<E> g(s);\n\t\trep(i,h)rep(j,w-1){\n\t\t\tint len=ci[j+1]-ci[j];\n\t\t\tif(rt[ri[i]]==0)\n\t\t\t\tg[i*w+j+1].pb(E{i*w+j,len});\n\t\t\telse\n\t\t\t\tg[i*w+j].pb(E{i*w+j+1,len});\n\t\t}\n\t\trep(j,w)rep(i,h-1){\n\t\t\tint len=ri[i+1]-ri[i];\n\t\t\tif(ct[ci[j]]==0)\n\t\t\t\tg[(i+1)*w+j].pb(E{i*w+j,len});\n\t\t\telse\n\t\t\t\tg[i*w+j].pb(E{(i+1)*w+j,len});\n\t\t}\n\t\t\n\t\tdmp(ri);\n\t\tdmp(ci);\n\t\t\n\t\tint ans=dijkstra<E>(g,id(a,b))[id(c,d)];\n\t\tif(ans==inf)ans=-1;\n\t\tprint(ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nint U[100005][2],D[100005][2],L[100005][2],R[100005][2];\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\t//if(cur_ans >= ans) return;\n\tif(s[a] == 'W'){\n\t    \tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//左\n\t\tint x = U[min(d,b)][0];\n\t\tint xx = U[b][0];\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(U[b][0] > 0){\n\t\t    x = U[b][0]; x--;\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = D[min(d,b)][0];\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(D[b][0] > 0){\n\t\t    y = D[b][0]; y--;\n\t\t    on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\n\t}\n\telse{\n\t    if(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = U[max(d,b)][1];\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(U[b][1] != up.size()){\n\t\t    x = U[b][1];\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = D[max(d,b)][1];\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(D[b][1] != dw.size()){\n\t\t    y = D[b][1];\n\t\t   on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\t//if(cur_ans >= ans) return;\n\tif(t[b] == 'N'){\n\t    if(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//上\n\t\tint x = L[min(a,c)][0];\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(L[a][0]){\n\t\t    x = L[a][0]-1;\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = R[min(a,c)][0];\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(R[a][0]){\n\t\t    y = R[a][0]-1;\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\telse{\n\t    if(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = L[max(a,c)][1];\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(L[a][1] != le.size()){\n\t\t    x = L[a][1];\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = R[max(a,c)][1];\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(R[a][1] != ri.size()){\n\t\t    y = R[a][1];\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<100005;i++){\n\t    L[i][0] = POSL(le,i);\n\t    R[i][0] = POSL(ri,i);\n\t    U[i][0] = POSL(up,i);\n\t    D[i][0] = POSL(dw,i);\n\t     L[i][1] = POSU(le,i);\n\t    R[i][1] = POSU(ri,i);\n\t    U[i][1] = POSU(up,i);\n\t    D[i][1] = POSU(dw,i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,4,0);\n\t\ton_y(a,b,c,d,4,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long long int exa = 1000000000000000000;\n//const int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, turn,dis;\n\tNode(int a, int b, int c = 0, int d = 0) {\n\t\ty = a, x = b;\n\t\tturn = c;\n\t\tdis = d;\n\t}\n};\n\nint border = 6;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int>ldif(W, -1);\n\tvector<int>rdif(W, -1);\n\tfor (int i = 1; i < W; i++) {\n\t\tif (t[i] == t[i - 1])ldif[i] = ldif[i - 1];\n\t\telse ldif[i] = i - 1;\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (t[i] == t[i + 1])rdif[i] = rdif[i + 1];\n\t\telse rdif[i] = i + 1;\n\t}\n\tvector<int>udif(H, -1);\n\tvector<int>ddif(H, -1);\n\tfor (int i = 1; i < H; i++) {\n\t\tif (s[i] == s[i - 1])udif[i] = udif[i - 1];\n\t\telse udif[i] = i - 1;\n\t}\n\tfor (int i = H - 2; i >= 0; i--) {\n\t\tif (s[i] == s[i + 1])ddif[i] = ddif[i + 1];\n\t\telse ddif[i] = i + 1;\n\t}\n\tvector<int>ret;\n\tfor (int i = 0; i < K; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\ta--, b--, c--, d--;\n\t\tqueue<Node>Q;\n\t\tQ.push(Node(a, b));\n\t\tint ans = MOD;\n\t\twhile (!Q.empty()) {\n\t\t\tauto cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (cn.y == c && cn.x == d)ans = min(ans, cn.dis);\n\t\t//\tcout << cn.y << \" \" << cn.x << endl;\n\t\t\tif (cn.turn == border)break;\n\t\t\tif (t[cn.x] == 'N') {//(-,0)\n\t\t\t\tif (c <= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tQ.push(Node(c, cn.x, cn.turn + 1, cn.dis + cn.y - c));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (udif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push({ Node(udif[cn.y],cn.x,cn.turn + 1,cn.dis + cn.y - udif[cn.y]) });\n\t\t\t\t\t}\n\t\t\t\t\tif (udif[c] != -1) {\n\t\t\t\t\t\tQ.push(Node(udif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y + udif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c >= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tQ.push(Node(c, cn.x, cn.turn + 1, cn.dis + c - cn.y));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ddif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[cn.y], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[cn.y])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ddif[c] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y + ddif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[cn.y] == 'W') {\n\t\t\t\tif (d <= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tQ.push(Node(cn.y, d, cn.turn + 1, cn.dis + abs(d - cn.x)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ldif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - ldif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ldif[d] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[d], cn.turn + 1, cn.dis + abs(cn.x - ldif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d >= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tQ.push(Node(cn.y, d, cn.turn + 1, cn.dis + abs(d - cn.x)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (rdif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - rdif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (rdif[d] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[d], cn.turn + 1, cn.dis + abs(cn.x - rdif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == MOD)ans = -1;\n\t\tret.push_back(ans);\n\t}\n\tfor (auto i : ret)cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using T = tuple<int, int, int>;\n    map<T, int> dp;\n    using P = pair<int, T>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      T st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      tie(y,x,step)=st;\n      \n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(dp.count(T(ny,nx,ns))&&dp[T(ny,nx,ns)]<=nd) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        // N           \n        for(int xx:{x,d}){\n          auto it=--upper_bound(vn.begin(),vn.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=--upper_bound(vs.begin(),vs.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }else{\n        // N           \n        for(int xx:{x,d}){\n          auto it=lower_bound(vn.begin(),vn.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=lower_bound(vs.begin(),vs.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }\n      if(t[x]=='N'){            \n        // W         \n        for(int yy:{y,c}){\n          auto it=--upper_bound(vw.begin(),vw.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=--upper_bound(ve.begin(),ve.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      }else{\n        // W         \n        for(int yy:{y,c}){\n          auto it=lower_bound(vw.begin(),vw.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=lower_bound(ve.begin(),ve.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename T> ll min(ll a, const T&& b) { return a < b ? a : b; }\ntemplate<typename T> ll min(const T&& a, ll b) { return a < b ? a : b; }\ntemplate<typename T> ll max(ll a, const T&& b) { return a > b ? a : b; }\ntemplate<typename T> ll max(const T&& a, ll b) { return a > b ? a : b; }\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nvector<ll> merge(const vector<ll>& a, const vector<ll>& b) {\n  vector<ll> res;\n  each(x, a) res.pb(x);\n  each(x, b) res.pb(x);\n  sort(all(res));\n  res.erase(unique(all(res)), res.end());\n  return res;\n}\n\npair<vector<ll>, vector<ll>> merge(const pair<vector<ll>, vector<ll>>& a, const pair<vector<ll>, vector<ll>>& b) {\n  return make_pair(merge(a.first, b.first), merge(a.second, b.second));\n}\n\n#define NODE(x,y) ((y)*m+(x))\n\nvector<ll> dijkstra(const vector<vector<P>>& G, const ll s) {\n  const ll n = G.size();\n  vector<ll> res(n, linf);\n  res[s] = 0;\n  priority_queue<P, vector<P>, greater<P>> Q;\n  Q.push(P(0, s));\n  while ( !Q.empty() ) {\n    P p = Q.top(); Q.pop();\n    ll v = p.second;\n    if (p.first > res[v]) continue;\n    each(e, G[v]) {\n      ll to = e.first, cost = e.second;\n      if (res[v] + cost < res[to]) {\n        res[to] = res[v]+cost;\n        Q.push(P(res[to], to));\n      }\n    }\n  }\n  return res;\n}\n\nll solve(const vector<ll>& L, const vector<ll>& R, const vector<ll>& U, const vector<ll>& D, ll x1, ll y1, ll x2, ll y2) {\n  vector<ll> X = merge(U, D);\n  vector<ll> Y = merge(L, R);\n  const ll n = Y.size(), m = X.size();\n  vector<vector<P>> G(n*m);\n  each(yy, L) {\n    ll y = lower_bound(all(Y), yy) - Y.begin();\n    rep(x, 1, m) {\n      G[NODE(x, y)].eb(NODE(x-1, y), X[x] - X[x-1]);\n    }\n  }\n  each(yy, R) {\n    ll y = lower_bound(all(Y), yy) - Y.begin();\n    rep(x, 1, m) {\n      G[NODE(x-1, y)].eb(NODE(x, y), X[x] - X[x-1]);\n    }\n  }\n  each(xx, U) {\n    ll x = lower_bound(all(X), xx) - X.begin();\n    rep(y, 1, n) {\n      G[NODE(x, y)].eb(NODE(x, y-1), Y[y] - Y[y-1]);\n    }\n  }\n  each(xx, D) {\n    ll x = lower_bound(all(X), xx) - X.begin();\n    rep(y, 1, n) {\n      G[NODE(x, y-1)].eb(NODE(x, y), Y[y] - Y[y-1]);\n    }\n  }\n  x1 = lower_bound(all(X), x1) - X.begin();\n  y1 = lower_bound(all(Y), y1) - Y.begin();\n  x2 = lower_bound(all(X), x2) - X.begin();\n  y2 = lower_bound(all(Y), y2) - Y.begin();\n  ll s = NODE(x1,y1), t = NODE(x2,y2);\n  vector<ll> dist = dijkstra(G, s);\n  return dist[t];\n}\n\nvoid solve() {\n  ll h, w, Q; cin >> h >> w >> Q;\n  string S, T; cin >> S >> T;\n  vector<ll> U, D, L, R;\n  rep(i, h) {\n    if (S[i] == 'E') {\n      R.pb(i);\n    }\n    else {\n      L.pb(i);\n    }\n  }\n  rep(i, w) {\n    if (T[i] == 'N') {\n      U.pb(i);\n    }\n    else {\n      D.pb(i);\n    }\n  }\n  auto pickup2 = [&](ll x, const vector<ll>& a) {\n    auto it = upper_bound(all(a), x);\n    vector<ll> res;\n    if (it != a.end()) res.pb(*it);\n    if (it != a.begin()) {\n      --it;\n      res.pb(*it);\n      if (*it == x && it != a.begin()) {\n        res.pb(*it);\n      }\n    }\n    return res;\n  };\n  auto pickup = [&](ll x, const vector<ll>& a, const vector<ll>& b) {\n    return make_pair(pickup2(x, a), pickup2(x, b));\n  };\n  rep(q, Q) {\n    ll y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2; --y1, --x1, --y2, --x2;\n    auto v1 = pickup(y1, L, R);\n    auto v2 = pickup(x1, U, D);\n    auto v3 = pickup(y2, L, R);\n    auto v4 = pickup(x2, U, D);\n    auto a = merge(v1, v3);\n    auto b = merge(v2, v4);\n    ll ans = solve(a.first, a.second, b.first, b.second, x1, y1, x2, y2);\n    if (ans == linf) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long long int exa = 1000000000000000000;\n//const int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, turn, dis;\n\tNode(int a, int b, int c = 0, int d = 0) {\n\t\ty = a, x = b;\n\t\tturn = c;\n\t\tdis = d;\n\t}\n};\n\nint border = 6;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int>ldif(W, -1);\n\tvector<int>rdif(W, -1);\n\tfor (int i = 1; i < W; i++) {\n\t\tif (t[i] == t[i - 1])ldif[i] = ldif[i - 1];\n\t\telse ldif[i] = i - 1;\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (t[i] == t[i + 1])rdif[i] = rdif[i + 1];\n\t\telse rdif[i] = i + 1;\n\t}\n\tvector<int>udif(H, -1);\n\tvector<int>ddif(H, -1);\n\tfor (int i = 1; i < H; i++) {\n\t\tif (s[i] == s[i - 1])udif[i] = udif[i - 1];\n\t\telse udif[i] = i - 1;\n\t}\n\tfor (int i = H - 2; i >= 0; i--) {\n\t\tif (s[i] == s[i + 1])ddif[i] = ddif[i + 1];\n\t\telse ddif[i] = i + 1;\n\t}\n\tvector<int>ret;\n\tfor (int i = 0; i < K; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\ta--, b--, c--, d--;\n\t\tqueue<Node>Q;\n\t\tQ.push(Node(a, b));\n\t\tint ans = MOD;\n\t\twhile (!Q.empty()) {\n\t\t\tauto cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (cn.y == c && cn.x == d) {\n\t\t\t\tans = min(ans, cn.dis);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cn.turn == border)break;\n\t\t\tif (t[cn.x] == 'N') {//(-,0)\n\t\t\t\tif (c <= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(c - cn.y) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (udif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push({ Node(udif[cn.y],cn.x,cn.turn + 1,cn.dis + cn.y - udif[cn.y]) });\n\t\t\t\t\t}\n\t\t\t\t\tif (udif[c] != -1&&udif[c]!=udif[cn.y]) {\n\t\t\t\t\t\tQ.push(Node(udif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - udif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c >= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(c - cn.y) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ddif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[cn.y], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[cn.y])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ddif[c] != -1 && ddif[c] != ddif[cn.y]) {\n\t\t\t\t\t\tQ.push(Node(ddif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[cn.y] == 'W') {\n\t\t\t\tif (d <= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(d - cn.x) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ldif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - ldif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ldif[d] != -1&&ldif[d]!=ldif[cn.x]) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[d], cn.turn + 1, cn.dis + abs(cn.x - ldif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d >= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(d - cn.x) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (rdif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - rdif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (rdif[d] != -1&&rdif[d]!=rdif[cn.x]) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[d], cn.turn + 1, cn.dis + abs(cn.x - rdif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == MOD)ans = -1;\n\t\tret.push_back(ans);\n\t}\n\tfor (auto i : ret)cout << i << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n    int n, m, q;\n    cin>>n>>m>>q;\n    string s, t;\n    cin>>s>>t;\n    vector<int> vw, ve, vn, vs;\n    for(int i=0; i<n; i++){\n        if(s[i]=='W') vw.push_back(i);\n        else ve.push_back(i);\n    }\n    for(int i=0; i<m; i++){\n        if(t[i]=='N') vn.push_back(i);\n        else vs.push_back(i);\n    }\n    while(q--){\n        int a, b, c, d;\n        cin>>a>>b>>c>>d;\n        a--; b--; c--; d--;\n        int h[6], w[6];\n        h[1]=min(a, c), h[4]=max(a, c), w[1]=min(b, d), w[4]=max(b, d);\n        if(s[h[1]]=='W'){\n            h[2]=upper_bound(ve.begin(), ve.end(), h[1])-ve.begin();\n            if(h[2]-1>=0) h[0]=ve[h[2]-1];\n            else h[0]=-1;\n            if(h[2]<ve.size()) h[2]=ve[h[2]];\n            else h[2]=-1;\n            int k=upper_bound(vw.begin(), vw.end(), h[1])-vw.begin();\n            if(k<vw.size()) h[3]=vw[k];\n            else h[3]=-1;\n            if(h[2]>=h[4]) h[2]=-1;\n            if(h[3]>=h[4]) h[3]=-1;\n        }else{\n            h[2]=upper_bound(vw.begin(), vw.end(), h[1])-vw.begin();\n            if(h[2]-1>=0) h[0]=vw[h[2]-1];\n            else h[0]=-1;\n            if(h[2]<vw.size()) h[2]=vw[h[2]];\n            else h[2]=-1;\n            int k=upper_bound(ve.begin(), ve.end(), h[1])-ve.begin();\n            if(k<ve.size()) h[3]=ve[k];\n            else h[3]=-1;\n            if(h[2]>=h[4]) h[2]=-1;\n            if(h[3]>=h[4]) h[3]=-1;\n        }\n        if(s[h[4]]=='W'){\n            h[5]=upper_bound(ve.begin(), ve.end(), h[4])-ve.begin();\n            if(h[5]<ve.size()) h[5]=ve[h[5]];\n            else h[5]=-1;\n        }else{\n            h[5]=upper_bound(vw.begin(), vw.end(), h[4])-vw.begin();\n            if(h[5]<vw.size()) h[5]=vw[h[5]];\n            else h[5]=-1;\n        }\n        if(t[w[1]]=='N'){\n            w[2]=upper_bound(vs.begin(), vs.end(), w[1])-vs.begin();\n            if(w[2]-1>=0) w[0]=vs[w[2]-1];\n            else w[0]=-1;\n            if(w[2]<vs.size()) w[2]=vs[w[2]];\n            else w[2]=-1;\n            int k=upper_bound(vn.begin(), vn.end(), w[1])-vn.begin();\n            if(k<vn.size()) w[3]=vn[k];\n            else w[3]=-1;\n            if(w[2]>=w[4]) w[2]=-1;\n            if(w[3]>=w[4]) w[3]=-1;\n        }else{\n            w[2]=upper_bound(vn.begin(), vn.end(), w[1])-vn.begin();\n            if(w[2]-1>=0) w[0]=vn[w[2]-1];\n            else w[0]=-1;\n            if(w[2]<vn.size()) w[2]=vn[w[2]];\n            else w[2]=-1;\n            int k=upper_bound(vs.begin(), vs.end(), w[1])-vs.begin();\n            if(k<vs.size()) w[3]=vs[k];\n            else w[3]=-1;\n            if(w[2]>=w[4]) w[2]=-1;\n            if(w[3]>=w[4]) w[3]=-1;\n        }\n        if(t[w[4]]=='N'){\n            w[5]=upper_bound(vs.begin(), vs.end(), w[4])-vs.begin();\n            if(w[5]<vs.size()) w[5]=vs[w[5]];\n            else w[5]=-1;\n        }else{\n            w[5]=upper_bound(vn.begin(), vn.end(), w[4])-vn.begin();\n            if(w[5]<vn.size()) w[5]=vn[w[5]];\n            else w[5]=-1;\n        }\n        if(h[2]>h[3]) swap(h[2], h[3]);\n        if(w[2]>w[3]) swap(w[2], w[3]);\n        int h1[6], w1[6], cx=0, cy=0;\n        for(int i=0; i<6; i++){\n            if(h[i]==-1) continue;\n            h1[cx++]=h[i];\n        }\n        for(int i=0; i<6; i++){\n            if(w[i]==-1) continue;\n            w1[cy++]=w[i];\n        }\n        int ax, ay, bx, by;\n        for(int j=0; j<cx; j++){\n            if(h1[j]==a) ax=j;\n            if(h1[j]==c) bx=j;\n        }\n        for(int j=0; j<cy; j++){\n            if(w1[j]==b) ay=j;\n            if(w1[j]==d) by=j;\n        }\n        vector<P> g[36];\n        for(int i=0; i<cx; i++){\n            for(int j=0; j<cy-1; j++){\n                if(w1[j]==w1[j+1]){\n                    g[i*cy+j+1].push_back({w1[j+1]-w1[j], i*cy+j});\n                    g[i*cy+j].push_back({w1[j+1]-w1[j], i*cy+j+1});\n                }else if(s[h1[i]]=='W') g[i*cy+j+1].push_back({w1[j+1]-w1[j], i*cy+j});\n                else g[i*cy+j].push_back({w1[j+1]-w1[j], i*cy+j+1});\n            }\n        }\n        for(int j=0; j<cy; j++){\n            for(int i=0; i<cx-1; i++){\n                if(h1[i]==h1[i+1]){\n                    g[(i+1)*cy+j].push_back({h1[i+1]-h1[i], i*cy+j});\n                    g[i*cy+j].push_back({h1[i+1]-h1[i], (i+1)*cy+j});\n                }else if(t[w1[j]]=='N') g[(i+1)*cy+j].push_back({h1[i+1]-h1[i], i*cy+j});\n                else g[i*cy+j].push_back({h1[i+1]-h1[i], (i+1)*cy+j});\n            }\n        }\n        priority_queue<P, vector<P>, greater<P>> que;\n        int dist[36];\n        const int INF=1e9+7;\n        fill(dist, dist+36, INF);\n        que.push({0, ax*cy+ay});\n        dist[ax*cy+ay]=0;\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n            int x=p.second;\n            if(dist[x]<p.first) continue;\n            for(auto pr:g[x]){\n                int y=pr.second, e=pr.first;\n                if(dist[y]>dist[x]+e){\n                    dist[y]=dist[x]+e;\n                    que.push({dist[y], y});\n                }\n            }\n        }\n        if(dist[bx*cy+by]<INF) printf(\"%d\\n\", dist[bx*cy+by]);\n        else printf(\"-1\\n\");\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W,Q;\nstring LR,UD;\nint SY,SX,TY,TX;\n\nvector<int> CY[202020];\nvector<int> CX[202020];\nint LU[202020],LD[202020];\nint RU[202020],RD[202020];\nint UL[202020],UR[202020];\nint DL[202020],DR[202020];\n\nint revx[202020],revy[202020];\nll dist[10][10];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W>>Q;\n\tcin>>LR>>UD;\n\t\n\t\n\tint U=W-1,D=W-1;\n\tfor(i=W-1;i>=0;i--) {\n\t\tif(UD[i]=='N') U=i;\n\t\tif(UD[i]=='S') D=i;\n\t\tCX[i].push_back(U);\n\t\tCX[i].push_back(D);\n\t\tCX[i].push_back(i);\n\t}\n\tU=D=0;\n\tFOR(i,W) {\n\t\tif(UD[i]=='N') U=i;\n\t\tif(UD[i]=='S') D=i;\n\t\tCX[i].push_back(U);\n\t\tCX[i].push_back(D);\n\t}\n\tint L=0,R=0;\n\tFOR(i,H) {\n\t\tif(LR[i]=='W') L=i;\n\t\tif(LR[i]=='E') R=i;\n\t\tCY[i].push_back(L);\n\t\tCY[i].push_back(R);\n\t\tCY[i].push_back(i);\n\t}\n\tL=R=H-1;\n\tfor(i=H-1;i>=0;i--) {\n\t\tif(LR[i]=='W') L=i;\n\t\tif(LR[i]=='E') R=i;\n\t\tCY[i].push_back(L);\n\t\tCY[i].push_back(R);\n\t}\n\t\n\twhile(Q--) {\n\t\tcin>>SY>>SX>>TY>>TX;\n\t\tSY--;\n\t\tSX--;\n\t\tTY--;\n\t\tTX--;\n\t\tvector<int> Xs,Ys;\n\t\tFORR(y,CY[SY]) Ys.push_back(y);\n\t\tFORR(y,CY[TY]) Ys.push_back(y);\n\t\tFORR(x,CX[SX]) Xs.push_back(x);\n\t\tFORR(x,CX[TX]) Xs.push_back(x);\n\t\t\n\t\tsort(ALL(Xs));\n\t\tsort(ALL(Ys));\n\t\tXs.erase(unique(ALL(Xs)),Xs.end());\n\t\tYs.erase(unique(ALL(Ys)),Ys.end());\n\t\t\n\t\tFOR(i,Xs.size()) revx[Xs[i]]=i;\n\t\tFOR(i,Ys.size()) revy[Ys[i]]=i;\n\t\tFOR(y,Ys.size()) FOR(x,Xs.size()) dist[y][x]=1LL<<60;\n\t\tpriority_queue<pair<ll,int>> PQ;\n\t\t\n\t\tdist[revy[SY]][revx[SX]]=0;\n\t\tPQ.push({0,revy[SY]*10+revx[SX]});\n\t\t\n\t\twhile(PQ.size()) {\n\t\t\tll co=-PQ.top().first;\n\t\t\tint cy=PQ.top().second/10;\n\t\t\tint cx=PQ.top().second%10;\n\t\t\tPQ.pop();\n\t\t\tif(dist[cy][cx]!=co) continue;\n\t\t\t\n\t\t\tif(LR[Ys[cy]]=='W' && cx) {\n\t\t\t\tll nc=co+abs(Xs[cx]-Xs[cx-1]);\n\t\t\t\tif(nc<dist[cy][cx-1]) {\n\t\t\t\t\tdist[cy][cx-1]=nc;\n\t\t\t\t\tPQ.push({-nc,(cy)*10+cx-1});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(LR[Ys[cy]]=='E' && cx<Xs.size()-1) {\n\t\t\t\tll nc=co+abs(Xs[cx]-Xs[cx+1]);\n\t\t\t\tif(nc<dist[cy][cx+1]) {\n\t\t\t\t\tdist[cy][cx+1]=nc;\n\t\t\t\t\tPQ.push({-nc,(cy)*10+cx+1});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(UD[Xs[cx]]=='N' && cy) {\n\t\t\t\tll nc=co+abs(Ys[cy]-Ys[cy-1]);\n\t\t\t\tif(nc<dist[cy-1][cx]) {\n\t\t\t\t\tdist[cy-1][cx]=nc;\n\t\t\t\t\tPQ.push({-nc,(cy-1)*10+cx});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(UD[Xs[cx]]=='S' && cy<Ys.size()-1) {\n\t\t\t\tll nc=co+abs(Ys[cy]-Ys[cy+1]);\n\t\t\t\tif(nc<dist[cy+1][cx]) {\n\t\t\t\t\tdist[cy+1][cx]=nc;\n\t\t\t\t\tPQ.push({-nc,(cy+1)*10+cx});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[revy[TY]][revx[TX]]==1LL<<60) {\n\t\t\tdist[revy[TY]][revx[TX]]=-1;\n\t\t}\n\t\tcout<<dist[revy[TY]][revx[TX]]<<endl;\n\t\t\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define fi first\n#define se second\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n\nusing namespace std;\nusing ll = int64_t;\n\nint N, M, Q;\nstring S, T;\nvector<int> xPositions[2];\nvector<int> yPositions[2];\nvector<int> interestingX;\nvector<int> interestingY;\nqueue<pair<int,int>> q;\n\nint distances[10][10];\n\nvoid build() {\n  for (int i = 0; i < N; i++)\n    xPositions[S[i] == 'E' ? 1 : 0].pb(i);\n  for (int i = 0; i < M; i++)\n    yPositions[T[i] == 'S' ? 1 : 0].pb(i);\n}\n\nint Next(const vector<int>& v, int x) {\n  auto it = lower_bound(all(v), x);\n  if (it == v.end())\n    return -1;\n  return *it;\n}\n\nint Prev(const vector<int>& v, int x) {\n  auto it = upper_bound(all(v), x);\n  if (it == v.begin())\n    return -1;\n  --it;\n  return *it;\n}\n\nvoid filter(vector<int>& v) {\n  sort(all(v));\n  v.erase(unique(all(v)), v.end());\n  while (!v.empty() && v.front() == -1)\n    v.erase(v.begin());\n}\n\nint ans(int x0, int y0, int x1, int y1) {\n  interestingX.clear();\n  interestingY.clear();\n  \n  interestingX.pb(x0);\n  interestingX.pb(x1);\n  interestingY.pb(y0);\n  interestingY.pb(y1);\n  for (int d = 0; d <= 1; d++) {\n    interestingX.pb(Next(xPositions[d], x0));\n    interestingX.pb(Prev(xPositions[d], x0));\n    interestingX.pb(Next(xPositions[d], x1));\n    interestingX.pb(Prev(xPositions[d], x1));\n\n    interestingY.pb(Next(yPositions[d], y0));\n    interestingY.pb(Prev(yPositions[d], y0));\n    interestingY.pb(Next(yPositions[d], y1));\n    interestingY.pb(Prev(yPositions[d], y1));\n  }\n\n  filter(interestingX);\n  filter(interestingY);\n\n  auto getX = [&](int x) {\n    return lower_bound(all(interestingX), x) - interestingX.begin();\n  };\n\n  auto getY = [&](int y) {\n    return lower_bound(all(interestingY), y) - interestingY.begin();\n  };\n\n  memset(distances, -1, sizeof(distances));\n  x0 = getX(x0);\n  y0 = getY(y0);\n  x1 = getX(x1);\n  y1 = getY(y1);\n  distances[x0][y0] = 0;\n  q.push({x0, y0});\n\n  while (!q.empty()) {\n    auto p = q.front();\n    q.pop();\n    int d = distances[p.fi][p.se];\n    // cerr << \"debug: \" << p.fi << \" \" << p.se << \" \" << d << endl;\n\n    // go x\n    int lx = 0, rx = sz(interestingX) - 1;\n    if (T[interestingY[p.se]] == 'S') lx = p.fi + 1;\n    if (T[interestingY[p.se]] == 'N') rx = p.fi - 1;\n    for (int nx = lx; nx <= rx; nx++) {\n      int nd = d + abs(interestingX[nx] - interestingX[p.fi]);\n      if (distances[nx][p.se] == -1 || distances[nx][p.se] > nd) {\n        distances[nx][p.se] = nd;\n        q.push({nx, p.se});\n      }\n    }\n\n    // go y\n    int ly = 0, ry = sz(interestingY) - 1;\n    if (S[interestingX[p.fi]] == 'E') ly = p.se + 1;\n    if (S[interestingX[p.fi]] == 'W') ry = p.se - 1;\n    for (int ny = ly; ny <= ry; ny++) {\n      int nd = d + abs(interestingY[ny] - interestingY[p.se]);\n      if (distances[p.fi][ny] == -1 || distances[p.fi][ny] > nd) {\n        distances[p.fi][ny] = nd;\n        q.push({p.fi, ny});\n      }\n    }\n  }\n\n  return distances[x1][y1];\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> N >> M >> Q;\n  cin >> S >> T;\n\n  build();\n\n  for (int i = 0; i < Q; i++) {\n    int x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n    --x0, --y0, --x1, --y1;\n    cout << ans(x0, y0, x1, y1) << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long long int exa = 1000000000000000000;\n//const int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, turn, dis;\n\tNode(int a, int b, int c = 0, int d = 0) {\n\t\ty = a, x = b;\n\t\tturn = c;\n\t\tdis = d;\n\t}\n};\n\nint border = 4;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int>ldif(W, -1);\n\tvector<int>rdif(W, -1);\n\tfor (int i = 1; i < W; i++) {\n\t\tif (t[i] == t[i - 1])ldif[i] = ldif[i - 1];\n\t\telse ldif[i] = i - 1;\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (t[i] == t[i + 1])rdif[i] = rdif[i + 1];\n\t\telse rdif[i] = i + 1;\n\t}\n\tvector<int>udif(H, -1);\n\tvector<int>ddif(H, -1);\n\tfor (int i = 1; i < H; i++) {\n\t\tif (s[i] == s[i - 1])udif[i] = udif[i - 1];\n\t\telse udif[i] = i - 1;\n\t}\n\tfor (int i = H - 2; i >= 0; i--) {\n\t\tif (s[i] == s[i + 1])ddif[i] = ddif[i + 1];\n\t\telse ddif[i] = i + 1;\n\t}\n\tvector<int>ret;\n\tfor (int i = 0; i < K; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\ta--, b--, c--, d--;\n\t\tqueue<Node>Q;\n\t\tQ.push(Node(a, b));\n\t\tint ans = MOD;\n\t\twhile (!Q.empty()) {\n\t\t\tauto cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tcerr << cn.y << \" \" << cn.x << \" \" <<cn.turn<<\" \"<< cn.dis << endl;\n\t\t\tif (cn.y == c && cn.x == d) {\n\t\t\t\tans = min(ans, cn.dis);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cn.turn == border)break;\n\t\t\tif (t[cn.x] == 'N') {//(-,0)\n\t\t\t\tif (c <= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(c - cn.y) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (udif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push({ Node(udif[cn.y],cn.x,cn.turn + 1,cn.dis + abs(cn.y - udif[cn.y])) });\n\t\t\t\t\t}\n\t\t\t\t\tif (udif[c] != -1&&udif[c]!=udif[cn.y]) {\n\t\t\t\t\t\tQ.push(Node(udif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - udif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c >= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(c - cn.y) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ddif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[cn.y], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[cn.y])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ddif[c] != -1 && ddif[c] != ddif[cn.y]) {\n\t\t\t\t\t\tQ.push(Node(ddif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[cn.y] == 'W') {\n\t\t\t\tif (d <= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(d - cn.x) + abs(cn.y - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ldif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - ldif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ldif[d] != -1&&ldif[d]!=ldif[cn.x]) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[d], cn.turn + 1, cn.dis + abs(cn.x - ldif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d >= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(d - cn.x) + abs(cn.y - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (rdif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - rdif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (rdif[d] != -1&&rdif[d]!=rdif[cn.x]) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[d], cn.turn + 1, cn.dis + abs(cn.x - rdif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == MOD)ans = -1;\n\t\tret.push_back(ans);\n\t}\n\tfor (auto i : ret)cout << i << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <ctime>\n\nconst int Inf = 0x3f3f3f3f;\n#define fp(i, a, b) for (int i = (a), I = (b) + 1; i < I; ++i)\n#define fd(i, a, b) for (int i = (a), I = (b)-1; i > I; --i)\n#define go(u) for (int i = head[u], v = e[i].v; i; i = e[i].nx, v = e[i].v)\ninline bool cmin(int &a, int b) { return a > b ? a = b, 1 : 0; }\n\nstd::vector<int> N, S, W, E;\nint Pre(std::vector<int> &A, int x) {\n\tif (A.empty())\n\t\treturn 1;\n\tint l = 0, r = A.size() - 1, res = 0;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tA[mid] <= x ? (res = mid, l = mid + 1) : r = mid - 1;\n\t}\n\treturn A[res];\n}\nint Suf(std::vector<int> &A, int x) {\n\tif (A.empty())\n\t\treturn 1;\n\tint l = 0, r = A.size() - 1, res = r;\n\twhile (l <= r) {\n\t\tint mid = (l + r) >> 1;\n\t\tA[mid] >= x ? (res = mid, r = mid - 1) : l = mid + 1;\n\t}\n\treturn A[res];\n}\n\nint head[105], tot;\nstruct eg {\n\tint v, nx, w;\n\teg() {}\n\teg(int v, int nx, int w) : v(v), nx(nx), w(w) {}\n} e[1005];\ninline void add(int u, int v, int w) { e[++tot] = eg(v, head[u], w), head[u] = tot; }\n\nint n, m, Q, cnt, id[25][25], dis[205], vis[205];\nchar s[100005], t[100005];\n\nstruct node {\n\tint u, d;\n\tnode() {}\n\tnode(int uu, int dd) : u(uu), d(dd) {}\n\tinline bool operator<(const node &b) const { return d > b.d; }\n};\nstd::priority_queue<node> q;\n\nint dijk(int S, int T) {\n\tfp(i, 1, cnt) dis[i] = Inf, vis[i] = 0;\n\tq.push(node(S, 0)), dis[S] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.top().u;\n\t\tq.pop();\n\t\tif (vis[u]) continue;\n\t\tvis[u] = 1;\n\t\tgo(u) if (cmin(dis[v], dis[u] + e[i].w)) q.push(node(v, dis[v]));\n\t}\n\treturn dis[T] < Inf ? dis[T] : -1;\n}\n\nint main() {\n//\tfreopen(\"distance.in\", \"r\", stdin);\n//\tfreopen(\"distance.out\", \"w\", stdout);\n\tscanf(\"%d%d%d%s%s\", &n, &m, &Q, s + 1, t + 1);\n\tfp(i, 1, n) s[i] == 'E' ? E.push_back(i) : W.push_back(i);\n\tfp(i, 1, m) t[i] == 'S' ? S.push_back(i) : N.push_back(i);\n\twhile (Q--) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tstd::vector<int> X, Y;\n\t\tX.push_back(Pre(E, a)), X.push_back(Pre(W, a)), X.push_back(Suf(E, a)), X.push_back(Suf(W, a));\n\t\tX.push_back(Pre(E, c)), X.push_back(Pre(W, c)), X.push_back(Suf(E, c)), X.push_back(Suf(W, c));\n\t\tY.push_back(Pre(S, b)), Y.push_back(Pre(N, b)), Y.push_back(Suf(S, b)), Y.push_back(Suf(N, b));\n\t\tY.push_back(Pre(S, d)), Y.push_back(Pre(N, d)), Y.push_back(Suf(S, d)), Y.push_back(Suf(N, d));\n\t\tstd::sort(X.begin(), X.end()), X.resize(unique(X.begin(), X.end()) - X.begin());\n\t\tstd::sort(Y.begin(), Y.end()), Y.resize(unique(Y.begin(), Y.end()) - Y.begin());\n\t\tint lx = X.size(), ly = Y.size(), S, T;\n\t\tcnt = 0;\n\t\tfp(i, 0, lx - 1) fp(j, 0, ly - 1) {\n\t\t\tid[i][j] = ++cnt;\n\t\t\tif (X[i] == a && Y[j] == b)\n\t\t\t\tS = cnt;\n\t\t\tif (X[i] == c && Y[j] == d)\n\t\t\t\tT = cnt;\n\t\t}\n\t\tfp(i, 1, cnt) head[i] = 0;\n\t\ttot = 0;\n\t\tfp(i, 0, lx - 1) if (s[X[i]] == 'E') fp(j, 0, ly - 2) add(id[i][j], id[i][j + 1], Y[j + 1] - Y[j]);\n\t\telse fp(j, 1, ly - 1) add(id[i][j], id[i][j - 1], Y[j] - Y[j - 1]);\n\t\tfp(j, 0, ly - 1) if (t[Y[j]] == 'S') fp(i, 0, lx - 2) add(id[i][j], id[i + 1][j], X[i + 1] - X[i]);\n\t\telse fp(i, 1, lx - 1) add(id[i][j], id[i - 1][j], X[i] - X[i - 1]);\n\t\tprintf(\"%d\\n\", dijk(S, T));\n\t}\n//\tsrand(time(0));\n//\tif (rand() % 2) puts(\"Sry\");\n\treturn 0;\n}\n\n// AtCoder ExaWizards 2019 F"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10, D = 5;\nconst int inf = 1e9 + 42;\n\nint n, m;\nint dx[] = {0, -1, 0, 1};\nint dy[] = {1, 0, -1, 0};\nint dir_x[N], dir_y[N];\nint pref_x[N][D], pref_y[N][D];\nint suff_x[N][D], suff_y[N][D];\n\nll solve(int sx, int sy, int tx, int ty, vector<int> dir);\ninline bool can_move(int x, int y, int d);\ninline bool on_path(int sx, int sy, int tx, int ty, int d);\ninline ll get_dist(int sx, int sy, int tx, int ty);\ninline bool in_dir(int sx, int sy, int tx, int ty, int d);\ninline ll get_next_after(int &sx, int &sy, int tx, int ty, int d0, int d1);\n\nint main() {\n\tfast_cin();\n\tint q; string s, t;\n\tcin >> n >> m >> q >> s >> t;\n\tfor (int x = 1; x <= n; ++x) {\n\t\tdir_x[x] = ((s[x - 1] == 'E') ? 0 : 2);\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tpref_x[x][d] = pref_x[x - 1][d];\n\t\t}\n\t\tpref_x[x][dir_x[x]] = x;\n\t}\n\tsuff_x[n + 1][0] = suff_x[n + 1][1] = n + 1;\n\tfor (int x = n; x >= 1; --x) {\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tsuff_x[x][d] = suff_x[x + 1][d];\n\t\t}\n\t\tsuff_x[x][dir_x[x]] = x;\n\t}\n\tfor (int y = 1; y <= m; ++y) {\n\t\tdir_y[y] = ((t[y - 1] == 'S') ? 3 : 1);\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tpref_y[y][d] = pref_y[y - 1][d];\n\t\t}\n\t\tpref_y[y][dir_y[y]] = y;\n\t}\n\tsuff_y[m + 1][0] = suff_y[m + 1][1] = m + 1;\n\tfor (int y = m; y >= 1; --y) {\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tsuff_y[y][d] = suff_y[y + 1][d];\n\t\t}\n\t\tsuff_y[y][dir_y[y]] = y;\n\t}\n\twhile (q--) {\n\t\tint sx, sy, tx, ty;\n\t\tcin >> sx >> sy >> tx >> ty;\n\t\tll ans = inf;\n\t\tfor (int d0 = 0; d0 < 4; ++d0) {\n\t\t\tfor (int d1 = 0; d1 < 4; ++d1) {\n\t\t\t\tif (d0 % 2 == d1 % 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int d2 = 0; d2 < 4; ++d2) {\n\t\t\t\t\tif (d1 % 2 == d2 % 2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int d3 = 0; d3 < 4; ++d3) {\n\t\t\t\t\t\tif (d2 % 2 == d3 % 2) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int d4 = 0; d4 < 4; ++d4) {\n\t\t\t\t\t\t\tif (d3 % 2 == d4 % 2) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tans = min(ans, solve(sx, sy, tx, ty, {d0, d1, d2, d3, d4}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans >= inf) {\n\t\t\tans = -1;\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n}\n\nll solve(int sx, int sy, int tx, int ty, vector<int> dir) {\n\tif (sx == tx and sy == ty) {\n\t\treturn 0;\n\t} else if (dir.empty()) {\n\t\treturn inf;\n\t} else if (!can_move(sx, sy, dir.back())) {\n\t\treturn inf;\n\t} else {\n\t\tint d = dir.back();\n\t\tdir.pop_back();\n\t\tif (on_path(sx, sy, tx, ty, d)) {\n\t\t\treturn get_dist(sx, sy, tx, ty);\n\t\t} else if (dir.empty()) {\n\t\t\treturn inf;\n\t\t}\n\t\tint x = sx, y = sy;\n\t\tll ans = get_next_after(x, y, sx, sy, d, dir.back());\n\t\tans += solve(x, y, tx, ty, dir);\n\t\tif (in_dir(sx, sy, tx, ty, d)) {\n\t\t\tll cand = get_next_after(sx, sy, tx, ty, d, dir.back());\n\t\t\tcand += solve(sx, sy, tx, ty, dir);\n\t\t\tans = min(ans, cand);\n\t\t}\n\t\treturn ans;\n\t}\n}\n\ninline bool can_move(int x, int y, int d) {\n\tif (d == 0 or d == 2) {\n\t\treturn dir_x[x] == d;\n\t} else {\n\t\treturn dir_y[y] == d;\n\t}\n}\n\ninline bool on_path(int sx, int sy, int tx, int ty, int d) {\n\tll dist = get_dist(sx, sy, tx, ty);\n\tif (sx + dx[d] * dist == tx and sy + dy[d] * dist == ty) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ninline ll get_dist(int sx, int sy, int tx, int ty) {\n\treturn abs(sx - tx) + abs(sy - ty);\n}\n\ninline bool in_dir(int sx, int sy, int tx, int ty, int d) {\n\tll d1 = get_dist(sx, sy, tx, ty);\n\tll d2 = get_dist(sx + dx[d], sy + dy[d], tx, ty);\n\treturn d2 < d1;\n}\n\ninline ll get_next_after(int &sx, int &sy, int tx, int ty, int d0, int d1) {\n\tint x = sx, y = sy;\n\tif (d0 == 0) {\n\t\ty = suff_y[ty][d1];\n\t} else if (d0 == 1) {\n\t\tx = pref_x[tx][d1];\n\t} else if (d0 == 2) {\n\t\ty = pref_y[ty][d1];\n\t} else {\n\t\tx = suff_x[tx][d1];\n\t}\n\tif (x < 1 or x > n or y < 1 or y > m) {\n\t\treturn inf;\n\t} else {\n\t\tll ans = get_dist(x, y, sx, sy);\n\t\tsx = x; sy = y;\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n#include <queue>\n#include <algorithm>\n\ntypedef std::set<int>::iterator Iter;\nconst int Inf = 0x3f3f3f3f;\nconst int MN = 100005;\n\nint N, M, Q;\nchar Str1[MN], Str2[MN];\nstd::set<int> se, sw, ss, sn;\n\nint dx[10], dy[10], cx, cy;\ninline void Add(std::set<int> &st, int id, int *dw, int &cw) {\n\tif (st.empty()) return ;\n\tIter It = st.lower_bound(id);\n\tif (It != st.end()) dw[++cw] = *It;\n\tif (It != st.begin()) --It, dw[++cw] = *It;\n}\n\nint Id[10][10], Cnt, S, T;\nint h[40], nxt[65], to[65], w[65], tot;\ninline void Ins(int x, int y, int z) { nxt[++tot] = h[x], to[tot] = y, w[tot] = z, h[x] = tot; }\n\nstruct nde {\n\tint d, u;\n\tnde() {}\n\tnde(int d, int u) : d(d), u(u) {}\n\tinline friend bool operator <(nde i, nde j) {\n\t\treturn i.d == j.d ? i.u < j.u : i.d > j.d;\n\t}\n};\n\nstd::priority_queue<nde> pq;\nint Vis[40], Dis[40];\ninline int Dijkstra() {\n\tfor (int i = 1; i <= Cnt; ++i) Vis[i] = 0, Dis[i] = Inf;\n\tDis[S] = 0, pq.push(nde(0, S));\n\twhile (!pq.empty()) {\n\t\tnde p = pq.top(); pq.pop();\n\t\tint d = p.d, u = p.u;\n\t\tif (Vis[u]) continue;\n\t\tVis[u] = 1;\n\t\tfor (int i = h[u]; i; i = nxt[i])\n\t\t\tif (Dis[to[i]] > d + w[i])\n\t\t\t\tDis[to[i]] = d + w[i],\n\t\t\t\tpq.push(nde(Dis[to[i]], to[i]));\n\t}\n\treturn Dis[T] == Inf ? -1 : Dis[T];\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tscanf(\"%s%s\", Str1 + 1, Str2 + 1);\n\tfor (int i = 1; i <= N; ++i) (Str1[i] == 'E' ? se : sw).insert(i);\n\tfor (int i = 1; i <= M; ++i) (Str2[i] == 'S' ? ss : sn).insert(i);\n\twhile (Q--) {\n\t\tint sx, sy, tx, ty;\n\t\tscanf(\"%d%d%d%d\", &sx, &sy, &tx, &ty);\n\t\tdx[1] = sx, dx[2] = tx;\n\t\tdy[1] = sy, dy[2] = ty;\n\t\tcx = cy = 2;\n\t\tAdd(Str1[sx] == 'E' ? sw : se, sx, dx, cx);\n\t\tAdd(Str1[tx] == 'E' ? sw : se, tx, dx, cx);\n\t\tAdd(Str2[sy] == 'S' ? sn : ss, sy, dy, cy);\n\t\tAdd(Str2[ty] == 'S' ? sn : ss, ty, dy, cy);\n\t\tstd::sort(dx + 1, dx + cx + 1);\n\t\tcx = std::unique(dx + 1, dx + cx + 1) - dx - 1;\n\t\tstd::sort(dy + 1, dy + cy + 1);\n\t\tcy = std::unique(dy + 1, dy + cy + 1) - dy - 1;\n\t\tCnt = tot = 0;\n\t\tfor (int i = 1; i <= cx; ++i)\n\t\t\tfor (int j = 1; j <= cy; ++j) {\n\t\t\t\tId[i][j] = ++Cnt;\n\t\t\t\tif (dx[i] == sx && dy[j] == sy) S = Cnt;\n\t\t\t\tif (dx[i] == tx && dy[j] == ty) T = Cnt;\n\t\t\t}\n\t\tfor (int i = 1; i <= Cnt; ++i) h[i] = 0;\n\t\tfor (int i = 1; i <= cx; ++i) {\n\t\t\tint dir = Str1[dx[i]] == 'E';\n\t\t\tfor (int j = 1; j < cy; ++j)\n\t\t\t\tIns(Id[i][j + !dir], Id[i][j + dir], dy[j + 1] - dy[j]);\n\t\t}\n\t\tfor (int j = 1; j <= cy; ++j) {\n\t\t\tint dir = Str2[dy[j]] == 'S';\n\t\t\tfor (int i = 1; i < cx; ++i)\n\t\t\t\tIns(Id[i + !dir][j], Id[i + dir][j], dx[i + 1] - dx[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", Dijkstra());\n\t}\n\treturn 0;\n}\n\n// Source : AtCoder ExaWizards 2019 F"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_set>\n# include <unordered_map>\nusing namespace std;\n\n\nint n, m, qq;\nstring s1, s2;\nint ans;\nint XX, YY;\nint pr1[100005][2];\nint sf1[100005][2];\nint pr2[100005][2];\nint sf2[100005][2];\n\nvoid upd(int x) {\n    if (x < ans) ans = x;\n    return;\n}\n\nvoid check(int x, int y, int len) {\n    if (XX == x && YY == y) { upd(len); return;}\n    len += abs(x - XX) + abs(y - YY);\n    if (XX == x) {\n        if ((YY < y && s1[x] == 'W') || (YY > y && s1[x] == 'E')) { upd(len);}\n        return;\n    }\n    if (YY == y) {\n        if ((XX < x && s2[y] == 'N') || (XX > x && s2[y] == 'S')) upd(len);\n        return;\n    }\n    char c1, c2;\n    if (XX > x) c1 = 'S';\n    else c1 = 'N';\n    if (YY > y) c2 = 'E';\n    else c2 = 'W';\n    if ((s1[x] == c2 && s2[YY] == c1) || (s2[y] == c1 && s1[XX] == c2)) upd(len);\n    return;\n}\n\nvoid recurs(int x, int y, int d, int len) {\n    check(x, y, len);\n    if (d == 9) return;\n    if (s1[x] == 'E' && s2[y] == 'N') {\n        if (sf2[y][1]) recurs(x, sf2[y][1], d + 1, len + sf2[y][1] - y);\n        if (pr1[x][1]) recurs(pr1[x][1], y, d + 1, len + x - pr1[x][1]);\n    } else if (s1[x] == 'E' && s2[y] == 'S') {\n        if (sf2[y][0]) recurs(x, sf2[y][0], d + 1, len + sf2[y][0] - y);\n        if (sf1[x][1]) recurs(sf1[x][1], y, d + 1, len + sf1[x][1] - x);\n    } else if (s1[x] == 'W' && s2[y] == 'N') {\n        if (pr2[y][1]) recurs(x, pr2[y][1], d + 1, len + y - pr2[y][1]);\n        if (pr1[x][0]) recurs(pr1[x][0], y, d + 1, len + x - pr1[x][0]);\n    } else {\n        if (pr2[y][0]) recurs(x, pr2[y][0], d + 1, len + y - pr2[y][0]);\n        if (sf1[x][0]) recurs(sf1[x][0], y, d + 1, len + sf1[x][0] - x);\n    }\n    return;\n}\n\nint main(int argc, const char * argv[]) {\n//    freopen(\"/Users/danya.smelskiy/Documents/Danya/Resources/input.txt\",\"r\",stdin);\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> m >> qq;\n    cin >> s1 >> s2;\n    s1 = \"#\" + s1;\n    s2 = \"#\" + s2;\n    \n    for (int i = 1; i <= n; ++i) {\n        pr1[i][0] = pr1[i - 1][0];\n        pr1[i][1] = pr1[i - 1][1];\n        if (s1[i] == 'E') pr1[i][0] = i;\n        else pr1[i][1] = i;\n    }\n    for (int i = n; i > 0; --i) {\n        sf1[i][0] = sf1[i + 1][0];\n        sf1[i][1] = sf1[i + 1][1];\n        if (s1[i] == 'E') sf1[i][0] = i;\n        else sf1[i][1] = i;\n    }\n    \n    for (int i = 1; i <= m; ++i) {\n        pr2[i][0] = pr2[i - 1][0];\n        pr2[i][1] = pr2[i - 1][1];\n        if (s2[i] == 'N') pr2[i][0] = i;\n        else pr2[i][1] = i;\n    }\n    for (int i = m; i > 0; --i) {\n        sf2[i][0] = sf2[i + 1][0];\n        sf2[i][1] = sf2[i + 1][1];\n        if (s2[i] == 'N') sf2[i][0] = i;\n        else sf2[i][1] = i;\n    }\n    int x, y;\n    while (qq--) {\n        cin >> x >> y >> XX >> YY;\n        ans = 1e9;\n        recurs(x, y, 0, 0);\n        if (ans < 1e9) cout << ans << '\\n';\n        else cout << \"-1\\n\";\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(s[a] == 'W'){\n\t\t//左\n\t\tint x = POSL(up,min(d,b));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSL(up,b) > 0){\n\t\t    x = POSL(up,b); x--;\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSL(dw,min(d,b));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSL(dw,b) > 0){\n\t\t    y = POSL(dw,b); y--;\n\t\t    on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(up,max(d,b));\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(POSU(up,b) != up.size()){\n\t\t    x = POSU(up,b);\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSU(dw,max(d,b));\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(POSU(dw,b) != dw.size()){\n\t\t    y = POSU(dw,b);\n\t\t   on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(t[b] == 'N'){\n\t\t//上\n\t\tint x = POSL(le,min(a,c));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSL(le,a)){\n\t\t    x = POSL(le,a)-1;\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSL(ri,min(a,c));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSL(ri,a)){\n\t\t    y = POSL(ri,a)-1;\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(le,max(a,c));\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(POSU(le,a) != le.size()){\n\t\t    x = POSU(le,a);\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSU(ri,max(a,c));\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(POSU(ri,a) != ri.size()){\n\t\t    y = POSU(ri,a);\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,5,0);\n\t\ton_y(a,b,c,d,5,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DBG1\n  #define LOCAL\n#endif\n\n#ifdef LOCAL\n  #define _GLIBCXX_DEBUG\n#endif\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#ifdef DBG1\n    #define dbg(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dbg(...)\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\n\nconst int INF = int(1e29);\n\nvector<int> buildNext(int n, const char *s) {\n  vector<int> next(n, n);\n  for (int i = n - 2; i >= 0; --i) {\n    if (s[i] == s[i + 1]) {\n      next[i] = next[i + 1];\n    } else {\n      next[i] = i + 1;\n    }\n  }\n  for (int i : next) {\n    dbg(\"%d \", i);\n  }\n  dbg(\"\\n\");\n  return next;\n}\n\nvector<int> buildPrev(int n, const char *s) {\n  vector<int> prev(n, -1);\n  for (int i = 1; i < n; ++i) {\n    if (s[i] == s[i - 1]) {\n      prev[i] = prev[i - 1];\n    } else {\n      prev[i] = i - 1;\n    }\n  }\n  for (int i : prev) {\n    dbg(\"%d \", i);\n  }\n  dbg(\"\\n\");\n  return prev;\n}\n\nbool solve() {\n  int n, m, q;\n  if (scanf(\"%d%d%d\", &n, &m, &q) != 3) { return false; }\n\n  static char S[101000];\n  static char T[101000];\n  scanf(\"%s%s\", S, T);\n\n  vector<int> next1 = buildNext(n, S);\n  vector<int> prev1 = buildPrev(n, S);\n  vector<int> next2 = buildNext(m, T);\n  vector<int> prev2 = buildPrev(m, T);\n\n  dbg(\"q = %d\\n\", q);\n\n  for (int ii = 0; ii < q; ++ii) {\n    int x1, y1, x2, y2;\n    scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n    --x1, --y1, --x2, --y2;\n\n    dbg(\"x1 %d y1 %d x2 %d y2 %d\\n\", x1, y1, x2, y2);\n\n    vector<int> xx;\n    xx.push_back(x1);\n    if (next1[x1] < n) xx.push_back(next1[x1]);\n    if (prev1[x1] >= 0) xx.push_back(prev1[x1]);\n    xx.push_back(x2);\n    if (next1[x2] < n) xx.push_back(next1[x2]);\n    if (prev1[x2] >= 0) xx.push_back(prev1[x2]);\n    \n    vector<int> yy;\n    yy.push_back(y1);\n    if (next2[y1] < m) yy.push_back(next2[y1]);\n    if (prev2[y1] >= 0) yy.push_back(prev2[y1]);\n    yy.push_back(y2);\n    if (next2[y2] < m) yy.push_back(next2[y2]);\n    if (prev2[y2] >= 0) yy.push_back(prev2[y2]);\n\n    sort(xx.begin(), xx.end());\n    xx.erase(unique(xx.begin(), xx.end()), xx.end());\n    sort(yy.begin(), yy.end());\n    yy.erase(unique(yy.begin(), yy.end()), yy.end());\n\n    for (int x : xx) {\n      dbg(\"%d \", x);\n    }\n    dbg(\"\\n\");\n    for (int y : yy) {\n      dbg(\"%d \", y);\n    }\n    dbg(\"\\n\");\n\n    vector<vector<int>> d(xx.size(), vector<int>(yy.size(), INF));\n    vector<vector<bool>> used(xx.size(), vector<bool>(yy.size(), false));\n    for (int i = 0; i < int(xx.size()); ++i) {\n      if (xx[i] != x1) { continue; }\n      for (int j = 0; j < int(yy.size()); ++j) {\n        if (yy[j] == y1) {\n          d[i][j] = 0;\n          //dbg(\"start %d %d\\n\", i, j);\n        }\n      }\n    }\n\n    while (1) {\n      int bestI = -1, bestJ = -1, bestD = INF;\n      for (int i = 0; i < int(xx.size()); ++i) {\n        for (int j = 0; j < int(yy.size()); ++j) {\n          if (used[i][j] || d[i][j] == INF) { continue; }\n          if (bestD > d[i][j]) {\n            bestI = i, bestJ = j, bestD = d[i][j];\n          }\n        }\n      }\n      if (bestD == INF) { break; }\n      \n      {\n        int i = bestI;\n        int j = bestJ;\n        //dbg(\"d[%d][%d] = %d\\n\", xx[i], yy[j], d[i][j]);\n        used[i][j] = true;\n        for (int i2 = 0; i2 < int(xx.size()); ++i2) {\n          if ((T[yy[j]] == 'N') != (i2 < i)) { continue; }\n          if (used[i2][j]) { continue; }\n          //dbg(\"%d %d -> %d %d\\n\", xx[i], yy[j], xx[i2], yy[j]);\n          d[i2][j] = min(d[i2][j], d[i][j] + abs(xx[i] - xx[i2]));\n        }\n        for (int j2 = 0; j2 < int(yy.size()); ++j2) {\n          if ((S[xx[i]] == 'W') != (j2 < j)) { continue; }\n          if (used[i][j2]) { continue; }\n          //dbg(\"%d %d -> %d %d\\n\", xx[i], yy[j], xx[i], yy[j2]);\n          d[i][j2] = min(d[i][j2], d[i][j] + abs(yy[j] - yy[j2]));\n        }\n      }\n    }\n\n    bool found = false;\n    for (int i = 0; i < int(xx.size()); ++i) {\n      if (xx[i] != x2) { continue; }\n      for (int j = 0; j < int(yy.size()); ++j) {\n        if (yy[j] == y2) {\n          printf(\"%d\\n\", d[i][j] == INF ? -1 : d[i][j]);\n          assert(!found);\n          found = true;\n        }\n      }\n    }\n    assert(found);\n\n  }\n\n  return true;\n}\n\nint main() {\n  while (solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\ntemplate < class R > inline void Readin( R &K ) {\n\tK = 0 ; register bool F = false ; register char C = getchar() ;\n\twhile( C < '0' or C > '9' ) { if( C == '-' ) F = true ; C = getchar() ; }\n\twhile( C <= '9' and C >= '0' ) K = ( K << 1 ) + ( K << 3 ) + C - '0' , C = getchar() ;\n\tif( F ) K = -K ;\n}\nconst int MaxN = 100000 + 10 ;\nint N , M , Q ;\nbool Tr[MaxN] , Td[MaxN] ;\nint Upu[MaxN] , Upd[MaxN] , Upl[MaxN] , Upr[MaxN] ;\nint Lou[MaxN] , Lod[MaxN] , Lol[MaxN] , Lor[MaxN] ;\nchar S[MaxN] ;\nint X , Y , Ans ;\nint Ls , Rs , Us , Ds , C ;\nbool Tol , Tor , Tou , Tod , Best ;\nvoid Dfs( int A , int B , int Tans , int Step , short Last ) {\n\tif( A == X and B == Y ) {\n\t\tAns = min( Ans , Tans ) ;\n\t\tif( Ans == abs( A - X ) + abs( B - Y ) ) Best = true ;\n\t\treturn ;\n\t}\n\tif( Ls == 3 or Rs == 3 or Us == 3 or Ds == 3 or C == 3 or (++Step) == 8 or Tans >= Ans or Best )\n\t\treturn ;\n\tregister int To1 , To2 ;\n\tif( Last != 0 ) {\n\t\tif( Tr[A] ) {\n\t\t\t++Rs ;\n\t\t\tTo1 = Upu[B+1] ;\n\t\t\tif( To1 != -1 ) Dfs( A , To1 , Tans + To1 - B , Step , 0 ) ;\n\t\t\tif( Y > B ) {\n\t\t\t\t++C ;\n\t\t\t\tTo2 = Upu[Y] ;\n\t\t\t\tif( To2 != -1 and To2 != To1 ) Dfs( A , To2 , Tans + To2 - B , Step , 0 ) ;\n\t\t\t\t--C ;\n\t\t\t}\n\t\t\tTo1 = Upd[B+1] ;\n\t\t\tif( To1 != -1 ) Dfs( A , To1 , Tans + To1 - B , Step , 0 ) ;\n\t\t\tif( Y > B ) {\n\t\t\t\t++C ;\n\t\t\t\tTo2 = Upd[Y] ;\n\t\t\t\tif( To2 != -1 and To2 != To1 ) Dfs( A , To2 , Tans + To2 - B , Step , 0 ) ;\n\t\t\t\t--C ;\n\t\t\t}\n\t\t\t--Rs ;\n\t\t}\n\t\telse {\n\t\t\t++Ls ;\n\t\t\tTo1 = Lou[B-1] ;\n\t\t\tif( To1 != -1 ) Dfs( A , To1 , Tans - To1 + B , Step , 0 ) ;\n\t\t\tif( Y < B ) {\n\t\t\t\t++C ;\n\t\t\t\tTo2 = Lou[Y] ;\n\t\t\t\tif( To2 != -1 and To2 != To1 ) Dfs( A , To2 , Tans - To2 + B , Step , 0 ) ;\n\t\t\t\t--C ;\n\t\t\t}\n\t\t\tTo1 = Lod[B-1] ;\n\t\t\tif( To1 != -1 ) Dfs( A , To1 , Tans - To1 + B , Step , 0 ) ;\n\t\t\tif( Y < B ) {\n\t\t\t\t++C ;\n\t\t\t\tTo2 = Lod[Y] ;\n\t\t\t\tif( To2 != -1 and To2 != To1 ) Dfs( A , To2 , Tans - To2 + B , Step , 0 ) ;\n\t\t\t\t--C ;\n\t\t\t}\n\t\t\t--Ls ;\n\t\t}\n\t}\n\tif( Last != 1 ) {\n\t\tif( Td[B] ) {\n\t\t\t++Us ;\n\t\t\tTo1 = Upl[A+1] ;\n\t\t\tif( To1 != -1 ) Dfs( To1 , B , Tans + To1 - A , Step , 1 ) ;\n\t\t\tif( X > A ) {\n\t\t\t\t++C ;\n\t\t\t\tTo2 = Upl[X] ;\n\t\t\t\tif( To2 != -1 and To2 != To1 ) Dfs( To2 , B , Tans + To2 - A , Step , 1 ) ;\n\t\t\t\t--C ;\n\t\t\t}\n\t\t\tTo1 = Upr[A+1] ;\n\t\t\tif( To1 != -1 ) Dfs( To1 , B , Tans + To1 - A , Step , 1 ) ;\n\t\t\tif( X > A ) {\n\t\t\t\t++C ;\n\t\t\t\tTo2 = Upr[X] ;\n\t\t\t\tif( To2 != -1 and To2 != To1 ) Dfs( To2 , B , Tans + To2 - A , Step , 1 ) ;\n\t\t\t\t--C ;\n\t\t\t}\n\t\t\t--Us ;\n\t\t}\n\t\telse {\n\t\t\t++Ds ;\n\t\t\tTo1 = Lol[A-1] ;\n\t\t\tif( To1 != -1 ) Dfs( To1 , B , Tans - To1 + A , Step , 1 ) ;\n\t\t\tif( X < A ) {\n\t\t\t\t++C ;\n\t\t\t\tTo2 = Lol[X] ;\n\t\t\t\tif( To2 != -1 and To2 != To1 ) Dfs( To2 , B , Tans - To2 + A , Step , 1 ) ;\n\t\t\t\t--C ;\n\t\t\t}\n\t\t\tTo1 = Lor[A-1] ;\n\t\t\tif( To1 != -1 ) Dfs( To1 , B , Tans - To1 + A , Step , 1 ) ;\n\t\t\tif( X < A ) {\n\t\t\t\t++C ;\n\t\t\t\tTo2 = Lor[X] ;\n\t\t\t\tif( To2 != -1 and To2 != To1 ) Dfs( To2 , B , Tans - To2 + A , Step , 1 ) ;\n\t\t\t\t--C ;\n\t\t\t}\n\t\t\t--Ds ;\n\t\t}\n\t}\n}\nint main() {\n\tReadin( N ) ;\n\tReadin( M ) ;\n\tReadin( Q ) ;\n\tscanf( \"%s\" , S + 1 ) ; getchar() ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tTr[i] = ( S[i] == 'E' ) ;\n\tscanf( \"%s\" , S + 1 ) ; getchar() ;\n\tfor(register int i = 0 ; ++i <= M ; )\n\t\tTd[i] = ( S[i] == 'S' ) ;\n\tUpl[N+1] = Upr[N+1] = -1 ;\n\tfor(register int i = N ; i ; --i ) {\n\t\tUpl[i] = Upl[i+1] ;\n\t\tUpr[i] = Upr[i+1] ;\n\t\tTr[i] ? Upr[i] = i : Upl[i] = i ;\n\t}\n\tLol[0] = Lor[0] = -1 ;\n\tfor(register int i = 0 ; ++i <= N ; ) {\n\t\tLol[i] = Lol[i-1] ;\n\t\tLor[i] = Lor[i-1] ;\n\t\tTr[i] ? Lor[i] = i : Lol[i] = i ;\n\t}\n\tUpu[M+1] = Upd[M+1] = -1 ;\n\tfor(register int i = M ; i ; --i ) {\n\t\tUpu[i] = Upu[i+1] ;\n\t\tUpd[i] = Upd[i+1] ;\n\t\tTd[i] ? Upd[i] = i : Upu[i] = i ;\n\t}\n\tLou[0] = Lod[0] = -1 ;\n\tfor(register int i = 0 ; ++i <= M ; ) {\n\t\tLou[i] = Lou[i-1] ;\n\t\tLod[i] = Lod[i-1] ;\n\t\tTd[i] ? Lod[i] = i : Lou[i] = i ;\n\t}\n\twhile( Q-- ) {\n\t\tregister int A , B ;\n\t\tAns = 1 << 30 ;\n\t\tBest = false ;\n\t\tReadin( A ) ;\n\t\tReadin( B ) ;\n\t\tReadin( X ) ;\n\t\tReadin( Y ) ;\n\t\tTol = Y <= B ;\n\t\tTor = Y >= B ;\n\t\tTou = X <= A ;\n\t\tTod = X >= A ;\n\t\tDfs( A , B , 0 , 0 , 233 ) ;\n\t\tif( Ans == ( 1 << 30 ) ) printf( \"-1\\n\" ) ;\n\t\t\telse printf( \"%d\\n\" , Ans ) ;\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(),x.end()\n#define all(x) x.begin(),x.end()\n#define fi first\n#define se second\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define erase_duplicates(x) sort(all(x)); (x).resize(distance((x).begin(), unique(all(x))));\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set = tree<\nT,\nnull_type,\nless<T>,\nrb_tree_tag,\ntree_order_statistics_node_update>;\n\n//X.find_by_order(k); - zwraca iterator na k-ty element (numeracja od zerowego)\n//X.order_of_key(k); - zwraca liczbę elementów ostro mniejszych niż k\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<char> VC;\ntypedef long double LD;\ntypedef pair<LD,LD> PLD;\ntypedef vector<LD> VLD;\ntypedef vector<PLD> VPLD;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\" = \"<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<\" = \"<<h<<\", \"; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#define cerr if(0)cout\n#endif\n\nconst int maxn = (1e6)+7;\nconst int maxk = 20;\nconst int inf = (1e9)+7;\nconst LL LLinf = ((LL)1e18)+7LL;\nconst LD eps = 1e-9;\nconst LL mod = 1e9+7;\n\n// ***************************** CODE ***************************** //\n\nset<int> gora, dol, lewo, prawo;\nconst int stala = 10;\n\nint odl(PII a, PII b)\n{\n  int xd = abs(a.fi - b.fi) + abs(a.se - b.se);\n  if(a.fi >= b.fi)\n  {\n    if(gora.count(a.se))\n    {\n    //  cerr<<\"HEJ\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.fi <= b.fi)\n  {\n    if(dol.count(a.se))\n    {\n      // cerr<<\"HEJ2\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.se <= b.se)\n  {\n    if(prawo.count(a.fi))\n    {\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  if(a.se >= b.se)\n  {\n    if(lewo.count(a.fi))\n    {\n      // cerr<<\"HEJ\"<<endl;\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  return inf;\n}\n\nvoid dorzuc(vector<pair<int, PII> > & a, vector<pair<int, PII> > b, int dlu)\n{\n  for(auto s : b)\n    a.pb({s.fi + dlu, s.se});\n}\n\nvector<pair<int, PII> > gen(PII cur, int k = stala)\n{\n//  cerr<<cur.fi<<\" \"<<cur.se<<endl;\n  vector<pair<int, PII> > res;\n  res.pb({0, cur});\n  if(k == 0)\n    return res;\n    if(gora.count(cur.se))\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n    else\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n\n    if(lewo.count(cur.fi))\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n    else\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n  return res;\n\n}\n\nvector<pair<int, PII> > gen2(PII cur, int k = stala)\n{\n\n    vector<pair<int, PII> > res;\n    res.pb({0, cur});\n      return res;\n      if(dol.count(cur.se))\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n      else\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n\n      if(prawo.count(cur.fi))\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.fi);\n          if(SZ(gora) > 0 && it != gora.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.fi);\n          if(SZ(dol) > 0 && it != dol.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n      else\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.se);\n          if(SZ(gora) > 0 && it != gora.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.se);\n          if(SZ(dol) > 0 && it != dol.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n    return res;\n\n}\n\nint main()\n{\n\t_upgrade\n  int n, m, q;\n  cin>>n>>m>>q;\n  string s;\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'E')\n      prawo.insert(i + 1);\n    else\n      lewo.insert(i + 1);\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'N')\n      gora.insert(i + 1);\n    else\n      dol.insert(i + 1);\n//  gen({4, 2});\n  // cerr<<odl({4, 2}, {3, 2})<<endl;\n // return 0;\n  while(q--)\n  {\n    PII start, meta;\n    cin>>start.fi>>start.se;\n    cin>>meta.fi>>meta.se;\n    auto it = gen(start);\n    auto it2 = gen2(meta);\n  /*\n    for(auto s : it)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n    cerr<<endl;\n    for(auto s : it2)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n      cerr<<endl;\n      cerr<<endl;\n      cerr<<endl;\n*/\n    int res = inf;\n    for(auto s : it)\n      for(auto v : it2)\n      {\n  //      cerr<<s.fi<<\" \"<<v.fi<<\" \"<<odl(s.se, v.se)<<endl;\n        res = min(res, odl(s.se, v.se) + s.fi + v.fi);\n      }\n    if(res == inf)\n      cout<<\"-1\\n\";\n    else\n      cout<<res<<\"\\n\";\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<vector>\nusing namespace std;\n\nint main(){\n\tlong N,M,Q;\n\tcin>>N>>M>>Q;\n\t//int ansarr[Q];\n\tvector<long>ansarr(Q);\n\tstring S,T;\n\tcin>>S>>T;\n\tlong a[Q],b[Q],c[Q],d[Q];\n\tfor(long i=0;i<Q;++i)cin>>a[i]>>b[i]>>c[i]>>d[i];\n\tfor(long i=0;i<Q;++i){\n\t\tchar map[N][M];\n\t\tfor(long j=0;j<N;++j){\n\t\t\tfor(long k=0;k<M;++k){\n\t\t\t\tmap[j][k]='.';\n\t\t\t}\n\t\t}\n\t\tmap[a[i]-1][b[i]-1]='s';\n\t\tqueue<long>x;\n\t\tqueue<long>y;\n\t\tqueue<long>ans;\n\t\tx.push(b[i]);\n\t\ty.push(a[i]);\n\t\tans.push(0);\n\t\tlong pro=1;\n\t\twhile(true){\n\t\t\tif(map[y.front()][x.front()-1]=='.' && y.front()<N && T[x.front()-1]=='S'){\n\t\t\t\tx.push(x.front());\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()+1==c[i] && x.front()==d[i]) break;\n\t\t\t\tmap[y.front()][x.front()-1]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-2][x.front()-1]=='.' && y.front()>1 && T[x.front()-1]=='N'){\n\t\t\t\tx.push(x.front());\n\t\t\t\ty.push(y.front()-1);\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()-1==c[i] && x.front()==d[i]) break;\n\t\t\t\tmap[y.front()-2][x.front()-1]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-1][x.front()]=='.' && x.front()<M && S[y.front()-1]=='E'){\n\t\t\t\tx.push(x.front()+1);\n\t\t\t\ty.push(y.front());\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()==c[i] && x.front()+1==d[i]) break;\n\t\t\t\tmap[y.front()-1][x.front()]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-1][x.front()-2]=='.' && x.front()>1 && S[y.front()-1]=='W'){\n\t\t\t\tx.push(x.front()-1);\n\t\t\t\ty.push(y.front());\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()==c[i] && x.front()-1==d[i]) break;\n\t\t\t\tmap[y.front()-1][x.front()-2]='+';\n\t\t\t}\n\t\t\telse if(x.size()>1){\n\t\t\t\tx.pop();\n\t\t\t\ty.pop();\n\t\t\t\tans.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpro=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pro==0)ansarr[i]=-1;\n\t\telse{\n\t\t\twhile(ans.size()>1)ans.pop();\n\t\t\tansarr[i]=ans.front();\n\t\t}\n\t}\n\tfor(long i=0;i<Q;++i)cout<<ansarr[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sort stable_sort\n#define all(x) (x).begin(),(x).end()\n#define rep(i,x) for (int (i)=(1);(i)<=(x);(i)++)\n#define rep2(i,x) for (int (i)=(x);(i)>=(1);(i)--)\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\nusing namespace std;\nint n,m,q,i,j,nxtx[100005],prex[100005],nxty[100005],prey[100005],x,y,xx,yy,lst1,lst2;\nll dis[75];\nstring s,t;\nchar ss[100005];\nvector<pair<int,int> > all;\nvector<pair<int,int> > bi[75];\nvoid add(int x,int y)\n{\n\tall.push_back(make_pair(x,y));\n\tif (prex[x]) all.push_back(make_pair(prex[x],y));\n\tif (nxtx[x]) all.push_back(make_pair(nxtx[x],y));\n\tif (prey[y]) all.push_back(make_pair(x,prey[y]));\n\tif (nxty[y]) all.push_back(make_pair(x,nxty[y]));\n\tif (prex[prex[x]]) all.push_back(make_pair(prex[prex[x]],y));\n\tif (nxtx[nxtx[x]]) all.push_back(make_pair(nxtx[nxtx[x]],y));\n\tif (prey[prey[y]]) all.push_back(make_pair(x,prey[prey[y]]));\n\tif (nxty[nxty[y]]) all.push_back(make_pair(x,nxty[nxty[y]]));\n\tif (prex[x]&&prey[y]) all.push_back(make_pair(prex[x],prey[y]));\n\tif (prex[x]&&nxty[y]) all.push_back(make_pair(prex[x],nxty[y]));\n\tif (nxtx[x]&&prey[y]) all.push_back(make_pair(nxtx[x],prey[y]));\n\tif (nxtx[x]&&nxty[y]) all.push_back(make_pair(nxtx[x],nxty[y]));\n}\nll dijkstra(int x,int y)\n{\n\tmemset(dis,18,sizeof(dis));\n\tdis[x]=0;\n\tpriority_queue<pair<ll,ll> > pq;\n\tpq.push(make_pair(0,x));\n\twhile (!pq.empty())\n\t{\n\t\tx=pq.top().second;pq.pop();\n\t\tforeach(it,bi[x])\n\t\t{\n\t\t\tif (dis[it->fi]>dis[x]+it->se)\n\t\t\t{\n\t\t\t\tdis[it->fi]=dis[x]+it->se;\n\t\t\t\tpq.push(make_pair(-dis[it->fi],it->fi));\n\t\t\t}\n\t\t}\n\t}\n\tif (dis[y]==dis[54]) return -1;\n\treturn dis[y];\n}\nvoid solve(int x,int y,int xx,int yy)\n{\n\tsort(all.begin(),all.end());\n\tall.resize(unique(all.begin(),all.end())-all.begin());\n//\tforeach(it,all) cerr<<it->fi<<' '<<it->se<<endl;\n\tint i,j,ss,tt;\n\tfor (i=0;i<all.size();i++) if (all[i].first==x&&all[i].second==y) ss=i;\n\tfor (i=0;i<all.size();i++) if (all[i].first==xx&&all[i].second==yy) tt=i;\n\tfor (i=0;i<all.size();i++) bi[i].clear();\n\tfor (i=0;i<all.size();i++) for (j=0;j<all.size();j++) if (i!=j)\n\t{\n\t\tif (all[i].first==all[j].first&&((s[all[i].first]=='E')==(all[i].second<all[j].second)))\n\t\t{\n\t\t\tbi[i].push_back(make_pair(j,abs(all[i].second-all[j].second)));\n\t\t}\n\t\tif (all[i].second==all[j].second&&((t[all[i].second]=='S')==(all[i].first<all[j].first)))\n\t\t{\n\t\t\tbi[i].push_back(make_pair(j,abs(all[i].first-all[j].first)));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dijkstra(ss,tt));\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\" %s\",ss);s=ss;s=\" \"+s;\n\tscanf(\" %s\",ss);t=ss;t=\" \"+t;\n\tlst1=lst2=0;\n\trep(i,n){if (s[i]=='W'){prex[i]=lst2;lst1=i;}else{prex[i]=lst1;lst2=i;}}\n\tlst1=lst2=0;\n\trep2(i,n){if (s[i]=='W'){nxtx[i]=lst2;lst1=i;}else{nxtx[i]=lst1;lst2=i;}}\n\tlst1=lst2=0;\n\trep(i,m){if (t[i]=='N'){prey[i]=lst2;lst1=i;}else{prey[i]=lst1;lst2=i;}}\n\tlst1=lst2=0;\n\trep2(i,m){if (t[i]=='N'){nxty[i]=lst2;lst1=i;}else{nxty[i]=lst1;lst2=i;}}\n\twhile (q--)\n\t{\n\t\tscanf(\"%d%d%d%d\",&x,&y,&xx,&yy);\n\t\tall.clear();\n\t\tadd(x,y);add(x,yy);add(xx,y);add(xx,yy);\n\t\tsolve(x,y,xx,yy);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 100000000000000000\n\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[100005], prer[100005], nextl[100005], nextr[100005];\nllint preu[100005], pred[100005], nextu[100005], nextd[100005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 1, prer[0] = 1;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i] == 'W') prel[i] = i;\n\t\tif(s[i] == 'E') prer[i] = i;\n\t}\n\tnextl[H+1] = H, nextr[H+1] = H;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i] == 'W') nextl[i] = i;\n\t\tif(s[i] == 'E') nextr[i] = i;\n\t}\n\t\n\tpreu[0] = 1, pred[0] = 1;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i] == 'N') preu[i] = i;\n\t\tif(t[i] == 'S') pred[i] = i;\n\t}\n\tnextl[W+1] = W, nextr[W+1] = W;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i] == 'N') nextu[i] = i;\n\t\tif(t[i] == 'S') nextd[i] = i;\n\t}\n\t\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double D;\ntypedef pair<ll,ll> P;\n#define M 1000000007\n#define F first\n#define PB push_back\n#define INF 1000000000\nstruct f{\n\tint c,y,x;\n\tbool operator<(const f&q)const{\n\t\tif(c!=q.c)return c<q.c;\n\t\tif(y!=q.y)return y<q.y;\n\t\treturn x<q.x;\n\t}\n\tbool operator>(const f&q)const{\n\t\tif(c!=q.c)return c>q.c;\n\t\tif(y!=q.y)return y>q.y;\n\t\treturn x>q.x;\n\t}\n};\nint n,m,q;\nvector<int>tt,yk;\nvector<int>N,W,E,S;\nint d[10][10];\npriority_queue<f,vector<f>,greater<f> >dik;\nchar h[100005],w[100005];\nint solve(int sy,int sx,int ty,int tx){\n\tfor(int i=0;i<yk.size();i++){\n\t\tif(yk[i]==sy){\n\t\t\tsy=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<yk.size();i++){\n\t\tif(yk[i]==ty){\n\t\t\tty=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<tt.size();i++){\n\t\tif(tt[i]==sx){\n\t\t\tsx=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<tt.size();i++){\n\t\tif(tt[i]==tx){\n\t\t\ttx=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<yk.size();i++)for(int j=0;j<tt.size();j++)d[i][j]=INF;\n\td[sy][sx]=0;\n\tdik.push(f{0,sy,sx});\n\twhile(!dik.empty()){\n\t\tll c=dik.top().c,y=dik.top().y,x=dik.top().x;\n\t\tdik.pop();\n\t\tif(d[y][x]<c)continue;\n\t\tif(h[yk[y]]=='W'){\n\t\t\tif(x>0&&d[y][x-1]>c+tt[x]-tt[x-1]){\n\t\t\t\td[y][x-1]=c+tt[x]-tt[x-1];\n\t\t\t\tdik.push(f{d[y][x-1],y,x-1});\n\t\t\t}\n\t\t}else{\n\t\t\tif(x+1<tt.size()&&d[y][x+1]>c+tt[x+1]-tt[x]){\n\t\t\t\td[y][x+1]=c+tt[x+1]-tt[x];\n\t\t\t\tdik.push(f{d[y][x+1],y,x+1});\n\t\t\t}\n\t\t}\n\t\tif(w[tt[x]]=='N'){\n\t\t\tif(y>0&&d[y-1][x]>c+yk[y]-yk[y-1]){\n\t\t\t\td[y-1][x]=c+yk[y]-yk[y-1];\n\t\t\t\tdik.push(f{d[y-1][x],y-1,x});\n\t\t\t}\n\t\t}else{\n\t\t\tif(y+1<yk.size()&&d[y+1][x]>c+yk[y+1]-yk[y]){\n\t\t\t\td[y+1][x]=c+yk[y+1]-yk[y];\n\t\t\t\tdik.push(f{d[y+1][x],y+1,x});\n\t\t\t}\n\t\t}\n\t}\n\treturn d[ty][tx];\n}\nint main(void){\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for(int i=1;i<=n;i++){\n\t\tscanf(\" %c\",&h[i]);\n\t\tif(h[i]=='E')E.PB(i);\n\t\telse W.PB(i);\n\t}\n    for(int i=1;i<=m;i++){\n\t\tscanf(\" %c\",&w[i]);\n\t\tif(w[i]=='N')N.PB(i);\n\t\telse S.PB(i);\n\t}\n    while(q--){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tyk.clear();\n\t\ttt.clear();\n\t\tyk.PB(a);\n\t\tyk.PB(c);\n\t\ttt.PB(b);\n\t\ttt.PB(d);\n\t\tint x=lower_bound(W.begin(),W.end(),a)-W.begin();\n\t\tif(x<W.size())yk.PB(W[x]);\n\t\tx=lower_bound(E.begin(),E.end(),a)-E.begin();\n\t\tif(x<E.size())yk.PB(E[x]);\n\t\tx=upper_bound(W.begin(),W.end(),a)-W.begin()-1;\n\t\tif(0<=x)yk.PB(W[x]);\n\t\tx=upper_bound(E.begin(),E.end(),a)-E.begin()-1;\n\t\tif(0<=x)yk.PB(E[x]);\n\t\t\n\t\tx=lower_bound(W.begin(),W.end(),c)-W.begin();\n\t\tif(x<W.size())yk.PB(W[x]);\n\t\tx=lower_bound(E.begin(),E.end(),c)-E.begin();\n\t\tif(x<E.size())yk.PB(E[x]);\n\t\tx=upper_bound(W.begin(),W.end(),c)-W.begin()-1;\n\t\tif(0<=x)yk.PB(W[x]);\n\t\tx=upper_bound(E.begin(),E.end(),c)-E.begin()-1;\n\t\tif(0<=x)yk.PB(E[x]);\n\t\t\n\t\tx=lower_bound(N.begin(),N.end(),b)-N.begin();\n\t\tif(x<N.size())tt.PB(N[x]);\n\t\tx=lower_bound(S.begin(),S.end(),b)-S.begin();\n\t\tif(x<S.size())tt.PB(S[x]);\n\t\tx=upper_bound(N.begin(),N.end(),b)-N.begin()-1;\n\t\tif(0<=x)tt.PB(N[x]);\n\t\tx=upper_bound(S.begin(),S.end(),b)-S.begin()-1;\n\t\tif(0<=x)tt.PB(S[x]);\n\t\t\n\t\tx=lower_bound(N.begin(),N.end(),d)-N.begin();\n\t\tif(x<N.size())tt.PB(N[x]);\n\t\tx=lower_bound(S.begin(),S.end(),d)-S.begin();\n\t\tif(x<S.size())tt.PB(S[x]);\n\t\tx=upper_bound(N.begin(),N.end(),d)-N.begin()-1;\n\t\tif(0<=x)tt.PB(N[x]);\n\t\tx=upper_bound(S.begin(),S.end(),d)-S.begin()-1;\n\t\tif(0<=x)tt.PB(S[x]);\n\t\t\n\t\tsort(yk.begin(),yk.end());\n\t\tsort(tt.begin(),tt.end());\n\t\tyk.erase(unique(yk.begin(),yk.end()),yk.end());\n\t\ttt.erase(unique(tt.begin(),tt.end()),tt.end());\n\t\tint ans=solve(a,b,c,d);\n\t\tif(ans==INF)ans=-1;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n\nusing ll = long long;\nusing i_i = tuple<int, int>;\nusing ll_i = tuple<ll, int>;\nstruct edge { int v, w; };\n\nvector<ll> dijkstra(int N, vector<vector<edge> >& G, int s) {\n\tvector<ll> d(N, LLONG_MAX); d[s] = 0;\n\tpriority_queue<ll_i, vector<ll_i>, greater<ll_i> > pq;\n\tpq.push(ll_i(0, s));\n\twhile (pq.size()) {\n\t\tll_i p = pq.top(); pq.pop();\n\t\tint u = get<1>(p);\n\t\tif (get<0>(p) > d[u]) continue;\n\t\tfor (edge e: G[u])\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tpq.push(ll_i(d[e.v], e.v));\n\t\t\t}\n\t}\n\treturn d;\n}\n\nconst int e5 = 1e5;\n\nint a[e5], b[e5];\n\nvoid f(int l, int r, vector<int>& from, vector<int>& to) {\n    {\n        auto it = lower_bound(all(from), l);\n        if (it != from.end()) {\n            int i = *it;\n            if (l <= i && i <= r) to.pb(i);\n        }\n    }\n    {\n        auto it = upper_bound(all(from), r);\n        if (it != from.begin()) {\n            int i = *prev(it);\n            if (l <= i && i <= r) to.pb(i);\n        }\n    }\n}\n\nint main() {\n    int N, M, Q;\n    cin >> N >> M >> Q;\n    string s, t;\n    cin >> s >> t;\n    vector<int> a(N), b(M);\n    rep(i, N) a[i] = (s[i] == 'E');\n    rep(j, M) b[j] = (t[j] == 'S');\n    vector<vector<int>> A(2), B(2);\n    rep(i, N) A[a[i]].pb(i);\n    rep(j, M) B[b[j]].pb(j);\n    while (Q--) {\n        int i_s, j_s, i_t, j_t;\n        scanf(\"%d%d%d%d\", &i_s, &j_s, &i_t, &j_t);\n        i_s--; j_s--; i_t--; j_t--;\n        vector<int> I = {-1, N, i_s, i_t};\n        vector<int> J = {-1, M, j_s, j_t};\n        sort(all(I)); sort(all(J));\n        I.erase(unique(all(I)), I.end());\n        J.erase(unique(all(J)), J.end());\n        vector<int> R, C;\n        for (int i: I) rep(z, 2) f(i, i, A[z], R);\n        for (int j: J) rep(z, 2) f(j, j, B[z], C);\n        rep(k, I.size() - 1) rep(z, 2) f(I[k] + 1, I[k + 1] - 1, A[z], R);\n        rep(k, J.size() - 1) rep(z, 2) f(J[k] + 1, J[k + 1] - 1, B[z], C);\n        sort(all(R)); sort(all(C));\n        R.erase(unique(all(R)), R.end());\n        C.erase(unique(all(C)), C.end());\n        /*\n        for (int y: R) cout << y << ' ';\n        cout << endl;\n        for (int x: C) cout << x << ' ';\n        cout << endl;\n        */\n        int H = R.size(), W = C.size();\n        vector<vector<edge>> G(H * W);\n        rep(i, H) rep(j, W - 1) {\n            int y = R[i];\n            if (a[y]) G[i * W + j].pb(edge{i * W + j + 1, C[j + 1] - C[j]});\n            if (!a[y]) G[i * W + j + 1].pb(edge{i * W + j, C[j + 1] - C[j]});\n        }\n        rep(j, W) rep(i, H - 1) {\n            int x = C[j];\n            if (b[x]) G[i * W + j].pb(edge{(i + 1) * W + j, R[i + 1] - R[i]});\n            if (!b[x]) G[(i + 1) * W + j].pb(edge{i * W + j, R[i + 1] - R[i]});\n        }\n        int y_s = lower_bound(all(R), i_s) - R.begin();\n        int x_s = lower_bound(all(C), j_s) - C.begin();\n        int y_t = lower_bound(all(R), i_t) - R.begin();\n        int x_t = lower_bound(all(C), j_t) - C.begin();\n        // cout << y_s << ' ' << x_s << ' ' << y_t << ' ' << x_t << endl;\n        auto d = dijkstra(H * W, G, y_s * W + x_s);\n        ll ans = d[y_t * W + x_t];\n        if (ans == LLONG_MAX) ans = -1;\n        printf(\"%lld\\n\", ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n\n#define MAX_N 100000\n#define MAX_M 100000\n\nusing namespace std;\n\nint N, M, Q;\nstring S, T;\n\nint lowerX[MAX_M];\nint upperX[MAX_M];\nint lowerY[MAX_N];\nint upperY[MAX_N];\n\nvoid initCompress()\n{\n    int le = N;\n    int lw = N;\n    for ( int i = 0; i < N; i++ )\n    {\n        if ( S[i] == 'E' ) le = i;\n        if ( S[i] == 'W' ) lw = i;\n\n        lowerY[i] = min( ( S[i] == 'E' ? lw : le ), i );\n    }\n\n    int ue = -1;\n    int uw = -1;\n    for ( int i = N - 1; i >= 0; i-- )\n    {\n        if ( S[i] == 'E' ) ue = i;\n        if ( S[i] == 'W' ) uw = i;\n\n        upperY[i] = max( ( S[i] == 'E' ? uw : ue ), i );\n    }\n\n    int ln = N;\n    int ls = N;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( T[i] == 'N' ) ln = i;\n        if ( T[i] == 'S' ) ls = i;\n\n        lowerX[i] = min( ( T[i] == 'N' ? ls : ln ), i );\n    }\n\n    int un = -1;\n    int us = -1;\n    for ( int i = M - 1; i >= 0; i-- )\n    {\n        if ( T[i] == 'N' ) un = i;\n        if ( T[i] == 'S' ) us = i;\n\n        upperX[i] = max( ( T[i] == 'N' ? us : un ), i );\n    }\n}\n\nbool visited[6][6];\n\ntypedef pair<int, int> P2;\ntypedef pair<int, P2> P3;\n\nint query( int y1, int x1, int y2, int x2 )\n{\n    vector<int> X;\n    vector<int> Y;\n\n    memset( visited, 0, sizeof( visited ) );\n\n    // initialize X\n    X.push_back( x1 );\n    X.push_back( lowerX[x1] );\n    X.push_back( upperX[x1] );\n    X.push_back( x2 );\n    X.push_back( lowerX[x2] );\n    X.push_back( upperX[x2] );\n\n    sort( X.begin(), X.end() );\n    X.erase( unique( X.begin(), X.end() ), X.end() );\n\n    // initialize Y\n    Y.push_back( y1 );\n    Y.push_back( lowerY[y1] );\n    Y.push_back( upperY[y1] );\n    Y.push_back( y2 );\n    Y.push_back( lowerY[y2] );\n    Y.push_back( upperY[y2] );\n\n    sort( Y.begin(), Y.end() );\n    Y.erase( unique( Y.begin(), Y.end() ), Y.end() );\n\n    int scx = find( X.begin(), X.end(), x1 ) - X.begin(); // index of start x\n    int scy = find( Y.begin(), Y.end(), y1 ) - Y.begin(); // index of start y\n    int gcx = find( X.begin(), X.end(), x2 ) - X.begin(); // index of goal x\n    int gcy = find( Y.begin(), Y.end(), y2 ) - Y.begin(); // index of goal y\n\n    priority_queue<P3> q;\n    q.push( P3( 0, P2( scx, scy ) ) );\n\n    while ( !q.empty() )\n    {\n        int d = q.top().first;\n        int cxi = q.top().second.first;\n        int cyi = q.top().second.second;\n\n        q.pop();\n\n        if ( visited[cxi][cyi] ) continue;\n        visited[cxi][cyi] = true;\n\n        if ( cxi == gcx && cyi == gcy ) return d;\n\n        int x = X[cxi];\n        int y = Y[cyi];\n\n        if ( T[x] == 'N' && 0 <= cyi - 1 )\n        {\n            int ny = Y[cyi - 1];\n            q.push( P3( d + abs( ny - y ), P2( cxi, cyi - 1 ) ) );\n        }\n        else if ( T[x] == 'S' && cyi + 1 < Y.size() )\n        {\n            int ny = Y[cyi + 1];\n            q.push( P3( d + abs( ny - y ), P2( cxi, cyi + 1 ) ) );\n        }\n\n        if ( S[y] == 'W' && 0 <= cxi - 1 )\n        {\n            int nx = X[cxi - 1];\n            q.push( P3( d + abs( nx - x ), P2( cxi - 1, cyi ) ) );\n        }\n        else if ( S[y] == 'E' && cxi + 1 < X.size() )\n        {\n            int nx = X[cxi + 1];\n            q.push( P3( d + abs( nx - x ), P2( cxi + 1, cyi ) ) );\n        }\n    }\n\n    return -1;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M >> Q;\n    cin >> S;\n    cin >> T;\n\n    initCompress();\n\n    for ( int q = 0; q < Q; q++ )\n    {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n\n        int ans = query( a - 1, b - 1, c - 1, d - 1 );\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\n\n#define EPS (1e-7)\n#define INF (1e17)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll N, M, Q;\nstring S, T;\nset<ll> EAST, WEST, NORTH, SOUTH;\n\nll search0(int a, int b, int c, int d) {\n    if(a == c && b == d) return 0;\n    if(a == c) {\n        if(b > d) {\n            if(S[a] == 'W') return abs(b - d);\n            else return INF;\n        } else {\n            if(S[a] == 'E') return abs(d - b);\n            else return INF;\n        }\n    }\n    if(b == d) {\n        if(a < c) {\n            if(T[b] == 'S') return abs(a - c);\n            else return INF;\n        } else {\n            if(T[b] == 'N') return abs(c - a);\n            else return INF;\n        } \n    }\n    return INF;\n}\n\nll search1(int a, int b, int c, int d) {\n    if(a == c && b == d) return 0;\n    //cerr << a << \" \" << b << \" \" << c << \" \" << d << endl;\n    ll ret = search0(a, b, c, d);\n    if(a < c) {\n        if(T[b] == 'S') ret = min(ret, c - a + search0(c, b, c, d));\n    }\n    if(a > c) {\n        if(T[b] == 'N') ret = min(ret, a - c + search0(c, b, c, d));\n    }\n    if(b < d) {\n        if(S[a] == 'E') ret = min(ret, d - b + search0(a, d, c, d));\n    }\n    if(b > d) {\n        if(S[a] == 'W') ret = min(ret, b - d + search0(a, d, c, d));\n    }\n    return ret;\n}\n\nll search2(int a, int b, int c, int d) {\n    //cerr << \"SEARCH2 \" << a << \" \" << b << \" \" << c << \" \" << d << endl;\n    if(a == c && b == d) return 0;\n    ll ret = search1(a, b, c, d);\n    auto itr = EAST.lower_bound(c);\n    if(itr != EAST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n    }\n    if(itr != EAST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n    }\n    itr = WEST.lower_bound(c);\n    if(itr != WEST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n    }\n    if(itr != WEST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n    }\n    itr = EAST.lower_bound(a);\n    if(itr != EAST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n    }\n    if(itr != EAST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n    }\n    itr = WEST.lower_bound(a);\n    //cerr << *itr << endl;\n    //cerr << T[b] << endl;\n    if(itr != WEST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n    }\n    if(itr != WEST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search1(newa, b, c, d));\n    }\n    itr = NORTH.lower_bound(b);\n    if(itr != NORTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n    }\n    if(itr != NORTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n    }\n    itr = SOUTH.lower_bound(b);\n    if(itr != SOUTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n    }\n    if(itr != SOUTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n    }\n    itr = NORTH.lower_bound(d);\n    if(itr != NORTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n    }\n    if(itr != NORTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n    }\n    itr = SOUTH.lower_bound(d);\n    if(itr != SOUTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n    }\n    if(itr != SOUTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search1(a, newb, c, d));\n    }\n    return ret;\n}\n\nll search3(int a, int b, int c, int d) {\n    //cerr << \"SEARCH3 \" << a << \" \" << b << \" \" << c << \" \" << d << endl;\n    if(a == c && b == d) return 0;\n    ll ret = search2(a, b, c, d);\n    auto itr = EAST.lower_bound(c);\n    if(itr != EAST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n    }\n    if(itr != EAST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n    }\n    itr = WEST.lower_bound(c);\n    if(itr != WEST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n    }\n    if(itr != WEST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n    }\n    itr = NORTH.lower_bound(d);\n    if(itr != NORTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    if(itr != NORTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    itr = EAST.lower_bound(a);\n    if(itr != EAST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n    }\n    if(itr != EAST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n    }\n    itr = WEST.lower_bound(a);\n    if(itr != WEST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n    }\n    if(itr != WEST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search2(newa, b, c, d));\n    }\n\n    itr = NORTH.lower_bound(b);\n    if(itr != NORTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    if(itr != NORTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    itr = SOUTH.lower_bound(b);\n    if(itr != SOUTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    if(itr != SOUTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    itr = NORTH.lower_bound(d);\n    if(itr != NORTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    if(itr != NORTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    itr = SOUTH.lower_bound(d);\n    if(itr != SOUTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    if(itr != SOUTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search2(a, newb, c, d));\n    }\n    return ret;\n}\n\nll search4(int a, int b, int c, int d) {\n    //cerr << \"SEARCH3 \" << a << \" \" << b << \" \" << c << \" \" << d << endl;\n    if(a == c && b == d) return 0;\n    ll ret = search3(a, b, c, d);\n    auto itr = EAST.lower_bound(c);\n    if(itr != EAST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n    }\n    if(itr != EAST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n    }\n    itr = WEST.lower_bound(c);\n    if(itr != WEST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n    }\n    if(itr != WEST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n    }\n    itr = NORTH.lower_bound(d);\n    if(itr != NORTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    if(itr != NORTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    itr = EAST.lower_bound(a);\n    if(itr != EAST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n    }\n    if(itr != EAST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n    }\n    itr = WEST.lower_bound(a);\n    if(itr != WEST.end()) {\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n    }\n    if(itr != WEST.begin()) {\n        itr--;\n        int newa = *itr;\n        if(a > newa && T[b] == 'N') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n        if(a < newa && T[b] == 'S') ret = min(ret, abs(a - newa) + search3(newa, b, c, d));\n    }\n\n    itr = NORTH.lower_bound(b);\n    if(itr != NORTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    if(itr != NORTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    itr = SOUTH.lower_bound(b);\n    if(itr != SOUTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    if(itr != SOUTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    itr = NORTH.lower_bound(d);\n    if(itr != NORTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    if(itr != NORTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    itr = SOUTH.lower_bound(d);\n    if(itr != SOUTH.end()) {\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    if(itr != SOUTH.begin()) {\n        itr--;\n        int newb = *itr;\n        if(b < newb && S[a] == 'E') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n        if(b > newb && S[a] == 'W') ret = min(ret, abs(b - newb) + search3(a, newb, c, d));\n    }\n    return ret;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M >> Q;\n    cin >> S >> T;\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'W') WEST.insert(i + 1);\n        else EAST.insert(i + 1);\n    }\n    for(int i = 0; i < T.size(); i++) {\n        if(T[i] == 'N') NORTH.insert(i + 1);\n        else SOUTH.insert(i + 1);\n    }\n    S = \"#\" + S;\n    T = \"#\" + T;\n    while(Q--) {\n        ll a, b, c, d;\n        cin >> a >> b >> c >> d;\n        ll ans = search4(a, b, c, d);\n        if(ans >= INF) ans = -1;\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\nusing namespace std;\nconst int N=2e5+10,mod=1e9+7;\nint n,m,q,Ans,HH[N],ZZ[N],dis[N],vis[N];\nchar s[N],t[N];\nset<int> H[2],Z[2];\nqueue<int> Q;\nstruct Node{int x,y;}P[N];\nvoid GetAns(int x1,int y1,int x2,int y2)\n{\n\tint ch=0,cz=0,c=0;\n\tset<int>::iterator it;\n\tfor(int i=0;i<2;i++)\n\t{\n\t\tit=H[i].lower_bound(x1);\n\t\tif(it!=H[i].end()) HH[++ch]=*it;\n\t\tif(it!=H[i].begin()) HH[++ch]=*(--it);\n\t\tit=H[i].lower_bound(x2);\n\t\tif(it!=H[i].end()) HH[++ch]=*it;\n\t\tif(it!=H[i].begin()) HH[++ch]=*(--it);\n\n\t\tit=Z[i].lower_bound(y1);\n\t\tif(it!=Z[i].end()) ZZ[++cz]=*it;\n\t\tif(it!=Z[i].begin()) ZZ[++cz]=*(--it);\n\t\tit=Z[i].lower_bound(y2);\n\t\tif(it!=Z[i].end()) ZZ[++cz]=*it;\n\t\tif(it!=Z[i].begin()) ZZ[++cz]=*(--it);\n\t}\n\tsort(HH+1,HH+ch+1);\n\tch=unique(HH+1,HH+ch+1)-HH-1;\n\tsort(ZZ+1,ZZ+cz+1);\n\tcz=unique(ZZ+1,ZZ+cz+1)-ZZ-1;\n\t\n\tfor(int i=1;i<=ch;i++)\n\t\tfor(int j=1;j<=cz;j++)\n\t\t\tP[++c]=(Node){HH[i],ZZ[j]};\n\tfor(int i=1;i<=c;i++)\n\t\tif(P[i].x==x1&&P[i].y==y1)\n\t\t\tdis[i]=0,Q.push(i),vis[i]=1;\n\t\telse dis[i]=1e9;\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();\n\t\tfor(int i=1;i<=c;i++)\n\t\t{\n\t\t\tif(dis[i]!=1e9) continue;\n\t\t\tif(P[i].x!=P[x].x&&P[i].y!=P[x].y) continue;\n\t\t\tif(P[i].x==P[x].x)\n\t\t\t{\n\t\t\t\tif(P[i].y>P[x].y&&s[P[i].x]=='W') continue;\n\t\t\t\tif(P[i].y<P[x].y&&s[P[i].x]=='E') continue;\n\t\t\t}\n\t\t\tif(P[i].y==P[x].y)\n\t\t\t{\n\t\t\t\tif(P[i].x>P[x].x&&t[P[i].y]=='N') continue;\n\t\t\t\tif(P[i].x<P[x].x&&t[P[i].y]=='S') continue;\n\t\t\t}\n\t\t\tint val=dis[x]+abs(P[i].x-P[x].x)+abs(P[i].y-P[x].y);\n\t\t\tif(dis[i]<=val) continue;\n\t\t\tdis[i]=val;\n\t\t\tif(!vis[i]) Q.push(i),vis[i]=1;\n\t\t}\n\t\tQ.pop(),vis[x]=0;\n\t}\n\tfor(int i=1;i<=c;i++)\n\t\tif(P[i].x==x2&&P[i].y==y2)\n\t\t\tAns=dis[i];\n}\nint main()\n{\n\tscanf(\"%d%d%d%s%s\",&n,&m,&q,s+1,t+1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(s[i]=='E') H[1].insert(i);\n\t\telse H[0].insert(i);\n\tfor(int i=1;i<=m;i++)\n\t\tif(t[i]=='N') Z[1].insert(i);\n\t\telse Z[0].insert(i);\n\tfor(int i=1,x1,y1,x2,y2;i<=q;i++)\n\t{\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tGetAns(x1,y1,x2,y2);\n\t\tif(Ans==1e9) puts(\"-1\");\n\t\telse printf(\"%d\\n\",Ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T,typename U> \nusing gmap = cc_hash_table<T, U, hash<T> >;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  vector<int> pnu(m),psu(m);\n  vector<int> pnl(m),psl(m);\n  for(int j=0;j<m;j++){    \n    pnu[j]=*--upper_bound(vn.begin(),vn.end(),j);\n    psu[j]=*--upper_bound(vs.begin(),vs.end(),j);    \n    pnl[j]=*lower_bound(vn.begin(),vn.end(),j);\n    psl[j]=*lower_bound(vs.begin(),vs.end(),j);\n  }\n  \n  vector<int> pwu(n),peu(n);\n  vector<int> pwl(n),pel(n);\n  for(int i=0;i<n;i++){    \n    pwu[i]=*--upper_bound(vw.begin(),vw.end(),i);\n    peu[i]=*--upper_bound(ve.begin(),ve.end(),i);    \n    pwl[i]=*lower_bound(vw.begin(),vw.end(),i);\n    pel[i]=*lower_bound(ve.begin(),ve.end(),i);\n  }      \n  \n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using ll = long long;    \n    auto T=[&](int y,int x,int step){return ((ll)y<<40)|((ll)x<<20)|(ll)step;};\n    gmap<ll, int> dp;\n    using P = pair<int, ll>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      ll st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      y=(st>>40);\n      x=(st>>20)^((ll)y<<20);\n      step=st&((1<<20)-1);\n      \n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(abs(ny)==INF||abs(nx)==INF) return;\n          if(ny==y&&nx==x) return;         \n          if(dp.find(T(ny,nx,ns))!=dp.end()&&dp[T(ny,nx,ns)]<=nd) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        for(int xx:{x,d}){\n          // N           \n          if(pnu[xx]<=x)\n            push(y,pnu[xx],step+1,sum+abs(pnu[xx]-x));\n          // S\n          if(psu[xx]<=x)\n            push(y,psu[xx],step+1,sum+abs(psu[xx]-x));\n        }\n      }else{\n        for(int xx:{x,d}){\n          // N           \n          if(pnl[xx]>=x)\n            push(y,pnl[xx],step+1,sum+abs(pnl[xx]-x));\n          // S\n          if(psl[xx]>=x)\n            push(y,psl[xx],step+1,sum+abs(psl[xx]-x));\n        }\n      }\n      if(t[x]=='N'){\n        for(int yy:{y,c}){\n          // W\n          if(pwu[yy]<=y)\n            push(pwu[yy],x,step+1,sum+abs(pwu[yy]-y));\n          // E\n          if(peu[yy]<=y)\n            push(peu[yy],x,step+1,sum+abs(peu[yy]-y));\n        }\n      }else{        \n        for(int yy:{y,c}){\n          // W\n          if(pwl[yy]>=y)\n            push(pwl[yy],x,step+1,sum+abs(pwl[yy]-y));\n          // E\n          if(pel[yy]>=y)\n            push(pel[yy],x,step+1,sum+abs(pel[yy]-y));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 6;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\nmap < pair < int, int >, int > mp;\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n   // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (step == BUBEN) return INF;\n    if (mp.count(make_pair(fromx, fromy)) && mp[make_pair(fromx, fromy)] <= step) return INF;\n    mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j] == k) nxt[i][val][0][j] = j;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j] == k) nxt[i][val][1][j] = j;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"BinaryMatrix.h\"\n#include \"BIT.h\"\n#include \"Factorization.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"LazySegmentTree.h\"\n#include \"Math.h\"\n#include \"Matrix.h\"\n#include \"MinMax.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"UnionFind.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint H, W;\nvector<int> S;\nvector<int> T;\nint P[4][100000];\nint Q[4][100000];\n\nconst int di[] = { -1, 0, 1, 0 };\nconst int dj[] = { 0, -1, 0, 1 };\nconst int BIG = 1e8;\n\nint rec(int n, int dir, int i, int j, int gi, int gj, int h, int w) {\n\tif (i < 0 || i > h) return BIG;\n\tif (j < 0 || j > w) return BIG;\n\tint ri = gi - i;\n\tint rj = gj - j;\n\tif (ri <= 0 && rj == 0) return -ri;\n\tif (n == 0) return BIG;\n\n\tif (ri < 0) {\n\t\tif (rj < 0) {\n\t\t\tint lfront = h - Q[(dir + 2) % 4][h - gi];\n\t\t\tint lback = P[dir][gi];\n\t\t\tint rfront = Q[dir][i];\n\n\t\t\tint mn = BIG;\n\t\t\tif (lfront <= i) \n\t\t\tmn = min(mn, rec(n - 1, (dir + 1) % 4, j, h - lfront, gj, h - gi, w, h) + i - lfront);\n\t\t\tmn = min(mn, rec(n - 1, (dir + 1) % 4, j, h - lback, gj, h - gi, w, h) + i - lback);\n\t\t\tmn = min(mn, rec(n - 1, (dir + 3) % 4, w - j, rfront, w - gj, gi, w, h) + i - rfront);\n\t\t\treturn mn;\n\t\t} else {\n\t\t\tint rfront = h - P[(dir + 2) % 4][h - gi];\n\t\t\tint rback = Q[dir][gi];\n\t\t\tint lfront = P[dir][i];\n\n\t\t\tint mn = BIG;\n\t\t\tif (rfront <= i) \n\t\t\tmn = min(mn, rec(n - 1, (dir + 3) % 4, w - j, rfront, w - gj, gi, w, h) + i - rfront);\n\t\t\tmn = min(mn, rec(n - 1, (dir + 3) % 4, w - j, rback, w - gj, gi, w, h) + i - rback);\n\t\t\tmn = min(mn, rec(n - 1, (dir + 1) % 4, j, h - lfront, gj, h - gi, w, h) + i - lfront);\n\t\t\treturn mn;\n\t\t}\n\t} else {\n\t\tint lfront = P[dir][i];\n\t\tint rfront = Q[dir][i];\n\n\t\tint mn = BIG;\n\t\tmn = min(mn, rec(n - 1, (dir + 1) % 4, j, h - lfront, gj, h - gi, w, h) + i - lfront);\n\t\tmn = min(mn, rec(n - 1, (dir + 3) % 4, w - j, rfront, w - gj, gi, w, h) + i - rfront);\n\t\treturn mn;\n\t}\n}\n\nint sub(int si, int sj, int gi, int gj) {\n\tint mn = BIG;\n\tif (T[sj] == 0) {\n\t\tmn = min(mn, rec(4, 0, si, sj, gi, gj, H, W));\n\t} else {\n\t\tmn = min(mn, rec(4, 2, H - si, W - sj, H - gi, W - gj, H, W));\n\t}\n\n\tif (S[si] == 0) {\n\t\tmn = min(mn, rec(4, 1, sj, H - si, gj, H - gi, W, H));\n\t} else {\n\t\tmn = min(mn, rec(4, 3, W - sj, si, W - gj, gi, W, H));\n\t}\n\treturn mn;\n}\n\nvoid pre() {\n\t{\n\t\tint l = -BIG;\n\t\tint r = -BIG;\n\t\tREP(i, 0, H + 1) {\n\t\t\tif (!S[i]) l = i;\n\t\t\tif (S[i]) r = i;\n\t\t\tP[0][i] = l;\n\t\t\tQ[0][i] = r;\n\t\t}\n\t}\n\n\t{\n\t\tint l = -BIG;\n\t\tint r = -BIG;\n\t\tREP(j, 0, W + 1) {\n\t\t\tif (T[j]) l = j;\n\t\t\tif (!T[j]) r = j;\n\t\t\tP[1][j] = l;\n\t\t\tQ[1][j] = r;\n\t\t}\n\t}\n\t\n\t{\n\t\tint l = -BIG;\n\t\tint r = -BIG;\n\t\tREP(i, 0, H + 1) {\n\t\t\tif (S[H - i]) l = i;\n\t\t\tif (!S[H - i]) r = i;\n\t\t\tP[2][i] = l;\n\t\t\tQ[2][i] = r;\n\t\t}\n\t}\n\n\t{\n\t\tint l = -BIG;\n\t\tint r = -BIG;\n\t\tREP(j, 0, W + 1) {\n\t\t\tif (!T[W - j]) l = j;\n\t\t\tif (T[W - j]) r = j;\n\t\t\tP[3][j] = l;\n\t\t\tQ[3][j] = r;\n\t\t}\n\t}\n}\n\nint main() {\n\tint Q;\n\tstring s, t;\n\tvector<PP> A;\n\tvector<PP> B;\n\n\tcin >> H >> W >> Q;\n\t--H; --W;\n\tcin >> s >> t;\n\tfor (char c : s) S.push_back(c == 'E');\n\tfor (char c : t) T.push_back(c == 'S');\n\n\tpre();\n\n\tREP(i, 0, Q) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\t--a; --b; --c; --d;\n\t\tint ans = sub(a, b, c, d);\n\t\tcout << (ans >= BIG ? -1 : ans) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int dir[2] = {-1, 1};\nconst int N = 1e5 + 5, K = 10, INF = 1e9;\nint rt_s[N][2], lt_s[N][2], rt_t[N][2], lt_t[N][2], dt[K][K];\n\n\nvoid build(const string &z, int lt[N][2], int rt[N][2]) {\n    int n = z.size();\n\n    lt[0][0] = lt[0][1] = -1;\n    rt[n - 1][0] = rt[n - 1][1] = -1;\n\n    for (int i = 0; i < n; i++) {\n        lt[i][z[i]] = i;\n        if (i + 1 < n) {\n            lt[i + 1][0] = lt[i][0];\n            lt[i + 1][1] = lt[i][1];\n        }\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        rt[i][z[i]] = i;\n        if (i > 0) {\n            rt[i - 1][0] = rt[i][0];\n            rt[i - 1][1] = rt[i][1];\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string s, t;\n    int n, m, q;\n    cin >> n >> m >> q >> s >> t;\n\n    for (char &c : s) {\n        c = (c == 'E');\n    }\n\n    for (char &c : t) {\n        c = (c == 'S');\n    }\n\n    build(s, lt_s, rt_s);\n    build(t, lt_t, rt_t);\n\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n\n        a--, b--, c--, d--;\n\n        vector<int> hor_lines, ver_lines;\n\n        for (int x : {a, c}) {\n            for (int i = 0; i < 2; i++) {\n                if (lt_s[x][i] != -1)\n                    hor_lines.push_back(lt_s[x][i]);\n                if (rt_s[x][i] != -1)\n                    hor_lines.push_back(rt_s[x][i]);\n            }\n        }\n\n        for (int x : {b, d}) {\n            for (int i = 0; i < 2; i++) {\n                if (lt_t[x][i] != -1)\n                    ver_lines.push_back(lt_t[x][i]);\n                if (rt_t[x][i] != -1)\n                    ver_lines.push_back(rt_t[x][i]);\n            }\n        }\n\n        sort(all(hor_lines));\n        sort(all(ver_lines));\n        hor_lines.erase(unique(all(hor_lines)), hor_lines.end());\n        ver_lines.erase(unique(all(ver_lines)), ver_lines.end());\n\n        priority_queue<pair<ll, pair<int, int>>,\n            vector<pair<ll, pair<int, int>>>,\n            greater<pair<ll, pair<int, int>>>> pq;\n\n        int ch = hor_lines.size(),\n            cv = ver_lines.size(),\n            fx, fy;\n\n        for (int x = 0; x < ch; x++) {\n            for (int y = 0; y < cv; y++) {\n                if (hor_lines[x] == a &&\n                    ver_lines[y] == b) {\n                    dt[x][y] = 0;\n                    pq.push({0, {x, y}});\n                }\n                else {\n                    if (hor_lines[x] == c &&\n                        ver_lines[y] == d) {\n                        fx = x;\n                        fy = y;\n                    }\n                    dt[x][y] = INF;\n                }\n            }\n        }\n\n        // for (int x : hor_lines)\n        //     cout << x << \" \";\n        // cout << \"\\n\";\n        // for (int x : ver_lines)\n        //     cout << x << \" \";\n        // cout << \"\\n\";\n\n        while (!pq.empty()) {\n            int cd = pq.top().first,\n                x = pq.top().second.first,\n                y = pq.top().second.second;\n\n            pq.pop();\n\n            if (dt[x][y] != cd)\n                continue;\n\n            // cout << hor_lines[x] << \" \" << ver_lines[y] << \" \" << cd << \"\\n\";\n\n            // cout << ver_lines[y] << \"\\n\";\n\n            for (int i = 0; i < 2; i++) {\n                int nx = x + ((i & 1) ? dir[t[ver_lines[y]]] : 0), \n                    ny = y + (!(i & 1) ? dir[s[hor_lines[x]]] : 0),\n                    w = abs(hor_lines[x] - hor_lines[nx]) \n                        + abs(ver_lines[y] - ver_lines[ny]);\n\n                if (nx >= 0 && nx < ch && ny >= 0 && ny < cv &&\n                    dt[nx][ny] > dt[x][y] + w) {\n                    dt[nx][ny] = dt[x][y] + w;\n                    pq.push({dt[nx][ny], {nx, ny}});\n                }\n            }\n        }\n\n        if (dt[fx][fy] == INF) {\n            cout << \"-1\\n\";\n        }\n        else {\n            cout << dt[fx][fy] << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <deque>\n#include <cmath>\n#include <cassert>\n#define SIZE 200005\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nchar S[SIZE],T[SIZE];\nint A[SIZE],B[SIZE],C[SIZE],D[SIZE];\nint dw[SIZE],de[SIZE],dw2[SIZE],de2[SIZE];\nint ds[SIZE],dn[SIZE],ds2[SIZE],dn2[SIZE];\nint rs[SIZE],re[SIZE];\nint ans[SIZE];\nint n,m,q;\n\n//South : +1\n//East  : +1\nvoid solve()\n{\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tdw[i]=de[i]=-1;\n\t\tif(i>0)\n\t\t{\n\t\t\tif(dw[i-1]!=-1) dw[i]=dw[i-1]+1;\n\t\t\tif(de[i-1]!=-1) de[i]=de[i-1]+1;\n\t\t}\n\t\tif(T[i]=='E') de[i]=0;\n\t\telse dw[i]=0;\n\t}\n\tfor(int i=m-1;i>=0;i--)\n\t{\n\t\tdw2[i]=de2[i]=-1;\n\t\tif(i+1<m)\n\t\t{\n\t\t\tif(dw2[i+1]!=-1) dw2[i]=dw2[i+1]+1;\n\t\t\tif(de2[i+1]!=-1) de2[i]=de2[i+1]+1;\n\t\t}\n\t\tif(T[i]=='E') de2[i]=0;\n\t\telse dw2[i]=0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tds[i]=dn[i]=-1;\n\t\tif(i>0)\n\t\t{\n\t\t\tif(ds[i-1]!=-1) ds[i]=ds[i-1]+1;\n\t\t\tif(dn[i-1]!=-1) dn[i]=dn[i-1]+1;\n\t\t}\n\t\tif(S[i]=='S') ds[i]=0;\n\t\telse dn[i]=0;\n\t}\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tds2[i]=dn2[i]=-1;\n\t\tif(i+1<n)\n\t\t{\n\t\t\tif(ds2[i+1]!=-1) ds2[i]=ds2[i+1]+1;\n\t\t\tif(dn2[i+1]!=-1) dn2[i]=dn2[i+1]+1;\n\t\t}\n\t\tif(S[i]=='S') ds2[i]=0;\n\t\telse dn2[i]=0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trs[i]=(S[i]=='S');\n\t\tif(i>0) rs[i]+=rs[i-1];\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tre[i]=(T[i]=='E');\n\t\tif(i>0) re[i]+=re[i-1];\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tif(A[i]<=C[i]&&B[i]<=D[i])\n\t\t{\n\t\t\tans[i]=-1;\n\t\t\tif(A[i]==C[i]&&S[A[i]]=='S') ans[i]=D[i]-B[i];\n\t\t\telse if(B[i]==D[i]&&T[B[i]]=='E') ans[i]=C[i]-A[i];\n\t\t\telse\n\t\t\t{\n\t\t\t\tint ms=-1;\n\t\t\t\tif(S[A[i]]=='S') ms=0;\n\t\t\t\telse if(dw[B[i]]!=-1&&ds[A[i]]!=-1) ms=(dw[B[i]]+ds[A[i]])*2;\n\t\t\t\tint me=-1;\n\t\t\t\tif(T[B[i]]=='E') me=0;\n\t\t\t\telse if(de[B[i]]!=-1&&dn[A[i]]!=-1) me=(de[B[i]]+dn[A[i]])*2;\n\t\t\t\tint ms2=-1;\n\t\t\t\tif(S[C[i]]=='S') ms2=0;\n\t\t\t\telse if(dw2[D[i]]!=-1&&ds2[C[i]]!=-1) ms2=(dw2[D[i]]+ds2[C[i]])*2;\n\t\t\t\tint me2=-1;\n\t\t\t\tif(T[D[i]]=='E') me2=0;\n\t\t\t\telse if(de2[D[i]]!=-1&&dn2[C[i]]!=-1) me2=(de2[D[i]]+dn2[C[i]])*2;\n\t\t\t\tint now=INF;\n\t\t\t\tif(ms>=0&&me2>=0) now=min(now,ms+me2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tif(me>=0&&ms2>=0) now=min(now,me+ms2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tint cs=rs[C[i]]-(A[i]==0?0:rs[A[i]-1]);\n\t\t\t\tint ce=re[D[i]]-(B[i]==0?0:re[B[i]-1]);\n\t\t\t\tif(me>=0&&me2>=0&&cs>0) now=min(now,me+me2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tif(ms>=0&&ms2>=0&&ce>0) now=min(now,ms+ms2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\t\n\t\t\t\tif(S[B[i]]=='E'&&S[D[i]]=='E')\n\t\t\t\t{\n\t\t\t\t\tif(ds2[A[i]]!=-1&&dw2[B[i]]!=-1&&B[i]+dw2[B[i]]<D[i]&&ds[A[i]]!=-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tnow=min(now,ds2[A[i]]*2+ds[A[i]]*2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(T[A[i]]=='S'&&T[C[i]]=='S')\n\t\t\t\t{\n\t\t\t\t\tif(de2[B[i]]!=-1&&dn2[A[i]]!=-1&&A[i]+dn2[A[i]]<C[i]&&de[B[i]]!=-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tnow=min(now,de2[B[i]]*2+de[B[i]]*2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now!=INF) ans[i]=now;\n\t\t\t}\n\t\t\t//printf(\"* %d %d %d %d\\n\",A[i],B[i],C[i],D[i]);\n\t\t\t//printf(\"%s %s -> %d\\n\",S,T,ans[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&m,&q);\n\tscanf(\"%s\",&S);\n\tscanf(\"%s\",&T);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(S[i]=='E') S[i]='S';\n\t\telse S[i]='N';\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(T[i]=='S') T[i]='E';\n\t\telse T[i]='W';\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tA[i]--,B[i]--,C[i]--,D[i]--;\n\t}\n\tsolve();\n\tfor(int l=0,r=n-1;l<r;l++,r--) swap(S[l],S[r]);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(T[i]=='E') T[i]='W';\n\t\telse T[i]='E';\n\t}\n\tfor(int i=0;i<q;i++) A[i]=n-A[i]-1,C[i]=n-C[i]-1;\n\tsolve();\n\tfor(int l=0,r=m-1;l<r;l++,r--) swap(T[l],T[r]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(S[i]=='N') S[i]='S';\n\t\telse S[i]='N';\n\t}\n\tfor(int i=0;i<q;i++) B[i]=m-B[i]-1,D[i]=m-D[i]-1;\n\tsolve();\n\tfor(int l=0,r=n-1;l<r;l++,r--) swap(S[l],S[r]);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(T[i]=='E') T[i]='W';\n\t\telse T[i]='E';\n\t}\n\tfor(int i=0;i<q;i++) A[i]=n-A[i]-1,C[i]=n-C[i]-1;\n\tsolve();\n\tfor(int i=0;i<q;i++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long long int exa = 1000000000000000000;\n//const int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, turn,dis;\n\tNode(int a, int b, int c = 0, int d = 0) {\n\t\ty = a, x = b;\n\t\tturn = c;\n\t\tdis = d;\n\t}\n};\n\nint border = 7;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int>ldif(W, -1);\n\tvector<int>rdif(W, -1);\n\tfor (int i = 1; i < W; i++) {\n\t\tif (t[i] == t[i - 1])ldif[i] = ldif[i - 1];\n\t\telse ldif[i] = i - 1;\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (t[i] == t[i + 1])rdif[i] = rdif[i + 1];\n\t\telse rdif[i] = i + 1;\n\t}\n\tvector<int>udif(H, -1);\n\tvector<int>ddif(H, -1);\n\tfor (int i = 1; i < H; i++) {\n\t\tif (s[i] == s[i - 1])udif[i] = udif[i - 1];\n\t\telse udif[i] = i - 1;\n\t}\n\tfor (int i = H - 2; i >= 0; i--) {\n\t\tif (s[i] == s[i + 1])ddif[i] = ddif[i + 1];\n\t\telse ddif[i] = i + 1;\n\t}\n\tvector<int>ret;\n\tfor (int i = 0; i < K; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\ta--, b--, c--, d--;\n\t\tqueue<Node>Q;\n\t\tQ.push(Node(a, b));\n\t\tunordered_map<long long int, int>m;\n\t\tm[(a*H + b)*W + 0] = 0;\n\t\tint ans = MOD;\n\t\twhile (!Q.empty()) {\n\t\t\tauto cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (cn.y == c && cn.x == d)ans = min(ans, cn.dis);\n\t\t\tauto it = m.find((cn.y*H + cn.x)*W + cn.turn);\n\t\t\tif (it != m.end()) {\n\t\t\t\tif (it->second < cn.dis)continue;\n\t\t\t}\n\t\t//\tcout << cn.y << \" \" << cn.x << endl;\n\t\t\tif (cn.turn == border)break;\n\t\t\tif (t[cn.x] == 'N') {//(-,0)\n\t\t\t\tif (c <= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tQ.push(Node(c, cn.x, cn.turn + 1, cn.dis + cn.y - c));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (udif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push({ Node(udif[cn.y],cn.x,cn.turn + 1,cn.dis + cn.y - udif[cn.y]) });\n\t\t\t\t\t}\n\t\t\t\t\tif (udif[c] != -1) {\n\t\t\t\t\t\tQ.push(Node(udif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y + udif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c >= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tQ.push(Node(c, cn.x, cn.turn + 1, cn.dis + c - cn.y));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ddif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[cn.y], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[cn.y])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ddif[c] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y + ddif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[cn.y] == 'W') {\n\t\t\t\tif (d <= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tQ.push(Node(cn.y, d, cn.turn + 1, cn.dis + abs(d - cn.x)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ldif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - ldif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ldif[d] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[d], cn.turn + 1, cn.dis + abs(cn.x - ldif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d >= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tQ.push(Node(cn.y, d, cn.turn + 1, cn.dis + abs(d - cn.x)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (rdif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - rdif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (rdif[d] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[d], cn.turn + 1, cn.dis + abs(cn.x - rdif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == MOD)ans = -1;\n\t\tret.push_back(ans);\n\t}\n\tfor (auto i : ret)cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to, cost;\n\tedge(){}\n\tedge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint H, W, Q;\nstring s, t;\nint prel[100005], prer[100005], nextl[100005], nextr[100005];\nint preu[100005], pred[100005], nextu[100005], nextd[100005];\nvector<int> vecx, vecy;\nvector<edge> G[205];\nint dist[205];\nint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(int s, int g, vector<int> &vec, int N, int preu[], int pred[], int nextu[], int nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(int i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(int i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i+1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(int i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(int i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i+1] == 'S') nextd[i] = i+1;\n\t}\n\n\tint sx, sy, gx, gy;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tint w = vecx.size(), h = vecy.size();\n\t\tfor(int i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\tint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint SX, GX, SY, GY;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << endl;\n\t\telse cout << dist[T] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 8;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\n\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\n\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n    // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (step == BUBEN) return INF;\n   // mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j] == k) nxt[i][val][0][j] = j;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j] == k) nxt[i][val][1][j] = j;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n//        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n\nusing namespace std;\n\nchar hroad[1048576]; // 가로\nchar vroad[1048576]; // 세로\n\nstruct seg {\n  int r, c; // start\n  int d; // direction\n  seg() : r(0), c(0), d(0) {}\n  seg(int r, int c, int d) : r(r), c(c), d(d) { }\n  seg flip_x() const {\n    seg s;\n    s.r = r;\n    s.c = -c;\n    s.d = ((d <= 1) ? (1 ^ d) : d);\n    return s;\n  }\n  seg swap_xy() const {\n    seg s;\n    s.r = c;\n    s.c = r;\n    s.d = d ^ 2;\n    return s;\n  }\n};\n\nconst int dir[4][2] = {\n  0, -1, // W\n  0, 1, // E\n  -1, 0, // N\n  1, 0 // S\n};\n\nint check_cross(int base, seg s, seg t) {\n  if (s.d == 0) {\n    if (t.d == 0) return (s.r == t.r) ? (base + abs(s.c - t.c)) : -1;\n    else if (t.d == 1) return (s.r == t.r && s.c >= t.c) ? (base + abs(s.c - t.c)) : -1;\n    else if (t.d == 2) return (s.r <= t.r && s.c >= t.c) ? (base + abs(s.c - t.c) + abs(s.r - t.r)) : -1;\n    else if (t.d == 3) return (s.r >= t.r && s.c >= t.c) ? (base + abs(s.c - t.c) + abs(s.r - t.r)) : -1;\n  }\n  else if (s.d == 1) {\n    return check_cross(base, s.flip_x(), t.flip_x());\n  }\n  else if (s.d == 2) {\n    return check_cross(base, s.swap_xy(), t.swap_xy());\n  }\n  else if (s.d == 3) {\n    return check_cross(base, s.swap_xy(), t.swap_xy());\n  }\n}\n\nint c2d(char v) {\n  if (v == 'W') return 0;\n  if (v == 'E') return 1;\n  if (v == 'N') return 2;\n  if (v == 'S') return 3;\n  return 0;\n}\n\nint lastW[100002];\nint lastE[100002];\nint lastN[100002];\nint lastS[100002];\n\nint firstW[100002];\nint firstE[100002];\nint firstN[100002];\nint firstS[100002];\n\nint main() {\n  int n, m, q;\n  scanf(\"%d%d%d\", &n, &m, &q);\n  scanf(\"%s\", hroad);\n  scanf(\"%s\", vroad);\n  {\n    int iW = -1, iE = -1;\n    for (int i = 0; i < n; i++) {\n      if (hroad[i] == 'W') {\n        iW = i;\n      }\n      else {\n        iE = i;\n      }\n      lastW[i] = iW;\n      lastE[i] = iE;\n    }\n  }\n  {\n    int iN = -1, iS = -1;\n    for (int i = 0; i < m; i++) {\n      if (vroad[i] == 'N') {\n        iN = i;\n      }\n      else {\n        iS = i;\n      }\n      lastN[i] = iN;\n      lastS[i] = iS;\n    }\n  }\n  {\n    int iW = -1, iE = -1;\n    for (int i = n-1; i >= 0; i--) {\n      if (hroad[i] == 'W') {\n        iW = i;\n      }\n      else {\n        iE = i;\n      }\n      firstW[i] = iW;\n      firstE[i] = iE;\n    }\n  }\n  {\n    int iN = -1, iS = -1;\n    for (int i = m-1; i >= 0; i--) {\n      if (vroad[i] == 'N') {\n        iN = i;\n      }\n      else {\n        iS = i;\n      }\n      firstN[i] = iN;\n      firstS[i] = iS;\n    }\n  }\n\n\n\n  for (int i = 0; i < q; i++) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a,&b,&c,&d);\n    a--, b--, c--, d--;\n    int ans = -1;\n    vector<seg> c1;\n    vector<seg> c2;\n\n    c1.emplace_back(a, b, c2d(hroad[a]));\n    if (hroad[a] == 'W') {\n      if (lastN[b] != -1) c1.emplace_back(a, lastN[b], c2d('N'));\n      if (lastS[b] != -1) c1.emplace_back(a, lastS[b], c2d('S'));\n    }\n    else {\n      if (firstN[b] != -1) c1.emplace_back(a, firstN[b], c2d('N'));\n      if (firstS[b] != -1) c1.emplace_back(a, firstS[b], c2d('S'));\n    }\n    c1.emplace_back(a, b, c2d(vroad[b]));\n    if (vroad[b] == 'N') {\n      if (lastE[a] != -1) c1.emplace_back(lastE[a], b, c2d('E'));\n      if (lastW[a] != -1) c1.emplace_back(lastW[a], b, c2d('W'));\n    }\n    else {\n      if (firstE[a] != -1) c1.emplace_back(firstE[a], b, c2d('E'));\n      if (firstW[a] != -1) c1.emplace_back(firstW[a], b, c2d('W'));\n    }\n\n    c2.emplace_back(c, d, 1^c2d(hroad[c]));\n    if (hroad[c] != 'W') {\n      if (lastN[d] != -1) c2.emplace_back(c, lastN[d], 1^c2d('N'));\n      if (lastS[d] != -1) c2.emplace_back(c, lastS[d], 1^c2d('S'));\n    }\n    else {\n      if (firstN[d] != -1) c2.emplace_back(c, firstN[d], 1^c2d('N'));\n      if (firstS[d] != -1) c2.emplace_back(c, firstS[d], 1^c2d('S'));\n    }\n    c2.emplace_back(c, d, 1^c2d(vroad[d]));\n    if (vroad[d] != 'N') {\n      if (lastE[c] != -1) c2.emplace_back(lastE[c], d, 1^c2d('E'));\n      if (lastW[c] != -1) c2.emplace_back(lastW[c], d, 1^c2d('W'));\n    }\n    else {\n      if (firstE[c] != -1) c2.emplace_back(firstE[c], d, 1^c2d('E'));\n      if (firstW[c] != -1) c2.emplace_back(firstW[c], d, 1^c2d('W'));\n    }\n\n    //TODO: fill c1, c2\n    for (const auto &A : c1) {\n      for (const auto &B : c2) {\n        int base = abs(a - A.r) + abs(b - A.c) + abs(c - B.r) + abs(d - B.c);\n        int result = check_cross(base, A, B);\n        if (result < 0) continue;\n        if (ans == -1 || ans > result) {\n          ans = result;\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define ll long long\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nvector<int> N,W,E,S;\nint Findpre(vector<int> &A,int x)\n{\n\tif(!A.size())return 1;\n\tint l=0,r=A.size()-1,ret=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(A[mid]<=x)ret=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn A[ret];\n}\nint Findsuf(vector<int> &A,int x)\n{\n\tif(!A.size())return 1;\n\tint l=0,r=A.size()-1,ret=r;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(A[mid]>=x)ret=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn A[ret];\n}\nint n,m,Q;char dS[100100],dT[100100];\nstruct Line{int v,next,w;}e[1000];\nint bh[20][20],tot;\nint h[100],cnt;\ninline void Add(int u,int v,int w){e[cnt]=(Line){v,h[u],w};h[u]=cnt++;}\nint dis[200];bool vis[200];\nint SPFA(int S,int T)\n{\n\tfor(int i=1;i<=tot;++i)dis[i]=1e9,vis[i]=false;\n\tqueue<int> Q;Q.push(S);dis[S]=0;vis[S]=true;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=h[u];i;i=e[i].next)\n\t\t\tif(dis[e[i].v]>dis[u]+e[i].w)\n\t\t\t{\n\t\t\t\tdis[e[i].v]=dis[u]+e[i].w;\n\t\t\t\tif(!vis[e[i].v])vis[e[i].v]=true,Q.push(e[i].v);\n\t\t\t}\n\t\tvis[u]=false;\n\t}\n\treturn dis[T]<1e9?dis[T]:-1;\n}\nint main()\n{\n\tn=read();m=read();Q=read();\n\tscanf(\"%s\",dS+1);scanf(\"%s\",dT+1);\n\tfor(int i=1;i<=n;++i)\n\t\tif(dS[i]=='E')E.push_back(i);\n\t\telse W.push_back(i);\n\tfor(int i=1;i<=m;++i)\n\t\tif(dT[i]=='N')N.push_back(i);\n\t\telse S.push_back(i);\n\twhile(Q--)\n\t{\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tvector<int> X,Y;\n\t\tX.push_back(Findpre(E,a));X.push_back(Findpre(W,a));\n\t\tX.push_back(Findsuf(E,a));X.push_back(Findsuf(W,a));\n\t\tX.push_back(Findpre(E,c));X.push_back(Findpre(W,c));\n\t\tX.push_back(Findsuf(E,c));X.push_back(Findsuf(W,c));\n\t\tY.push_back(Findpre(N,b));Y.push_back(Findpre(S,b));\n\t\tY.push_back(Findsuf(N,b));Y.push_back(Findsuf(S,b));\n\t\tY.push_back(Findpre(N,d));Y.push_back(Findpre(S,d));\n\t\tY.push_back(Findsuf(N,d));Y.push_back(Findsuf(S,d));\n\t\tsort(X.begin(),X.end());X.resize(unique(X.begin(),X.end())-X.begin());\n\t\tsort(Y.begin(),Y.end());Y.resize(unique(Y.begin(),Y.end())-Y.begin());\n\t\tint lx=X.size(),ly=Y.size(),S,T;tot=0;\n\t\tfor(int i=0;i<lx;++i)\n\t\t\tfor(int j=0;j<ly;++j)\n\t\t\t{\n\t\t\t\tbh[i][j]=++tot;\n\t\t\t\tif(X[i]==a&&Y[j]==b)S=tot;\n\t\t\t\tif(X[i]==c&&Y[j]==d)T=tot;\n\t\t\t}\n\t\tfor(int i=1;i<=tot;++i)h[i]=0;cnt=2;\n\t\tfor(int i=0;i<lx;++i)\n\t\t\tif(dS[X[i]]=='E')for(int j=0;j<ly-1;++j)Add(bh[i][j],bh[i][j+1],Y[j+1]-Y[j]);\n\t\t\telse for(int j=1;j<ly;++j)Add(bh[i][j],bh[i][j-1],Y[j]-Y[j-1]);\n\t\tfor(int i=0;i<ly;++i)\n\t\t\tif(dT[Y[i]]=='N')for(int j=1;j<lx;++j)Add(bh[j][i],bh[j-1][i],X[j]-X[j-1]);\n\t\t\telse for(int j=0;j<lx-1;++j)Add(bh[j][i],bh[j+1][i],X[j+1]-X[j]);\n\t\tprintf(\"%d\\n\",SPFA(S,T));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 200008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\n\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\n\tfor(int i=1;i<=q;i++)\t\n\t{\n\t\tpii s=from[i],t=dest[i];\n\t\t\n\t\tif(s.first>t.first or s.second>t.second) continue;\n\t\t#define case0 case0\n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=ub(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][1]),z=ub(t.first,path[0][0]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=lb(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][0]),z=ub(t.first,path[0][1]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n\t\tif(s.second==t.second) continue;\n\t\t#define case1 case1\n\t\tfor(;s.first<=t.first;)\n\t\t{\n\t\t\tint x=lb(s.first,path[0][1]);\n\t\t\tif(!x) break;int tmp=abs(s.first-x)+abs(t.first-x)+abs(s.second-t.second);\n\t\t\tif(x!=s.first) \n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][0]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or y<s.second) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t#define case2 case2\n\n\t\tfor(;s.first<t.first;)\n\t\t{\n\t\t\tint x=ub(s.first,path[0][1]);\n\t\t\tif(x>=t.first or x<=s.first) break;int tmp=abs(s.second-t.second)+abs(s.first-t.first);\n\t\t\tint at=1e9,bt=1e9;\n\t\t\n\t\t\tif(1)\n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\t\n\t\t\t//copied from  line58\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or y<s.second) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//licensed\n\t\t}\n\t}\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\t\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) dir[0][i]^=1;for(int i=1;i<=m;i++) dir[1][i]^=1;\n\tfor(int i=1;i<=q;i++) swap(from[i],dest[i]);\n\t\n\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\nusing namespace std;\nconst int N=2e5+10,mod=1e9+7;\nint n,m,q,Ans,HH[N],ZZ[N],dis[N],vis[N];\nchar s[N],t[N];\nset<int> H[2],Z[2];\nqueue<int> Q;\nstruct Node{int x,y;}P[N];\nvoid GetAns(int x1,int y1,int x2,int y2)\n{\n\tint ch=0,cz=0,c=0;\n\tset<int>::iterator it;\n\tfor(int i=0;i<2;i++)\n\t{\n\t\tit=H[i].lower_bound(x1);\n\t\tif(it!=H[i].end()) HH[++ch]=*it;\n\t\tif(it!=H[i].begin()) HH[++ch]=*(--it);\n\t\tit=H[i].lower_bound(x2);\n\t\tif(it!=H[i].end()) HH[++ch]=*it;\n\t\tif(it!=H[i].begin()) HH[++ch]=*(--it);\n\n\t\tit=Z[i].lower_bound(y1);\n\t\tif(it!=Z[i].end()) ZZ[++cz]=*it;\n\t\tif(it!=Z[i].begin()) ZZ[++cz]=*(--it);\n\t\tit=Z[i].lower_bound(y2);\n\t\tif(it!=Z[i].end()) ZZ[++cz]=*it;\n\t\tif(it!=Z[i].begin()) ZZ[++cz]=*(--it);\n\t}\n\tsort(HH+1,HH+ch+1);\n\tch=unique(HH+1,HH+ch+1)-HH-1;\n\tsort(ZZ+1,ZZ+cz+1);\n\tcz=unique(ZZ+1,ZZ+cz+1)-ZZ-1;\n\n//\tprintf(\"HH:\");for(int i=1;i<=ch;i++) printf(\"%d \",HH[i]);puts(\"\");\n//\tprintf(\"ZZ:\");for(int i=1;i<=cz;i++) printf(\"%d \",ZZ[i]);puts(\"\");\n\t\n\tfor(int i=1;i<=ch;i++)\n\t\tfor(int j=1;j<=cz;j++)\n\t\t\tP[++c]=(Node){HH[i],ZZ[j]};\n\tfor(int i=1;i<=c;i++)\n\t\tif(P[i].x==x1&&P[i].y==y1)\n\t\t\tdis[i]=0,Q.push(i),vis[i]=1;\n\t\telse dis[i]=1e9;\n//\tfor(int i=1;i<=c;i++) printf(\"P[%d](%d,%d),dis[%d]=%d\\n\",i,P[i].x,P[i].y,i,dis[i]);\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.front();\n//\t\tprintf(\"dis[%d]=%d\\n\",x,dis[x]);\n\t\tfor(int i=1;i<=c;i++)\n\t\t{\n\t\t\tif(P[i].x!=P[x].x&&P[i].y!=P[x].y) continue;\n\t\t\tif(P[i].x==P[x].x)\n\t\t\t{\n\t\t\t\tif(P[i].y>P[x].y&&s[P[i].x]=='W') continue;\n\t\t\t\tif(P[i].y<P[x].y&&s[P[i].x]=='E') continue;\n\t\t\t}\n\t\t\tif(P[i].y==P[x].y)\n\t\t\t{\n\t\t\t\tif(P[i].x>P[x].x&&t[P[i].y]=='N') continue;\n\t\t\t\tif(P[i].x<P[x].x&&t[P[i].y]=='S') continue;\n\t\t\t}\n\t\t\tint val=dis[x]+abs(P[i].x-P[x].x)+abs(P[i].y-P[x].y);\n\t\t\tif(dis[i]<=val) continue;\n\t\t\tdis[i]=val;\n//\t\t\tprintf(\"!!!%d->dis[%d]=%d\\n\",x,i,val);\n\t\t\tif(!vis[i]) Q.push(i),vis[i]=1;\n\t\t}\n\t\tQ.pop(),vis[x]=0;\n\t}\n\tfor(int i=1;i<=c;i++)\n\t\tif(P[i].x==x2&&P[i].y==y2)\n\t\t\tAns=dis[i];\n}\nint main()\n{\n\tscanf(\"%d%d%d%s%s\",&n,&m,&q,s+1,t+1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(s[i]=='E') H[1].insert(i);\n\t\telse H[0].insert(i);\n\tfor(int i=1;i<=m;i++)\n\t\tif(t[i]=='N') Z[1].insert(i);\n\t\telse Z[0].insert(i);\n\tfor(int i=1,x1,y1,x2,y2;i<=q;i++)\n\t{\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tGetAns(x1,y1,x2,y2);\n\t\tif(Ans==1e9) puts(\"-1\");\n\t\telse printf(\"%d\\n\",Ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define ll long long\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nvector<int> N,W,E,S;\nint Findpre(vector<int> A,int x)\n{\n\tif(!A.size())return 1;\n\tint l=0,r=A.size()-1,ret=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(A[mid]<=x)ret=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn A[ret];\n}\nint Findsuf(vector<int> A,int x)\n{\n\tif(!A.size())return 1;\n\tint l=0,r=A.size()-1,ret=r;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(A[mid]>=x)ret=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn A[ret];\n}\nint n,m,Q;char dS[100100],dT[100100];\nstruct Line{int v,next,w;}e[1000];\nint bh[20][20],tot;\nint h[100],cnt;\ninline void Add(int u,int v,int w){e[cnt]=(Line){v,h[u],w};h[u]=cnt++;}\nint dis[200];bool vis[200];\nint SPFA(int S,int T)\n{\n\tfor(int i=1;i<=tot;++i)dis[i]=1e9;\n\tqueue<int> Q;Q.push(S);dis[S]=0;vis[S]=true;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=h[u];i;i=e[i].next)\n\t\t\tif(dis[e[i].v]>dis[u]+e[i].w)\n\t\t\t{\n\t\t\t\tdis[e[i].v]=dis[u]+e[i].w;\n\t\t\t\tif(!vis[e[i].v])vis[e[i].v]=true,Q.push(e[i].v);\n\t\t\t}\n\t\tvis[u]=false;\n\t}\n\treturn dis[T]<1e9?dis[T]:-1;\n}\nint main()\n{\n\tn=read();m=read();Q=read();\n\tscanf(\"%s\",dS+1);scanf(\"%s\",dT+1);\n\tfor(int i=1;i<=n;++i)\n\t\tif(dS[i]=='E')E.push_back(i);\n\t\telse W.push_back(i);\n\tfor(int i=1;i<=m;++i)\n\t\tif(dT[i]=='N')N.push_back(i);\n\t\telse S.push_back(i);\n\twhile(Q--)\n\t{\n\t\tint a=read(),b=read(),c=read(),d=read();\n\t\tvector<int> X,Y;\n\t\tX.push_back(Findpre(E,a));X.push_back(Findpre(W,a));\n\t\tX.push_back(Findsuf(E,a));X.push_back(Findsuf(W,a));\n\t\tX.push_back(Findpre(E,c));X.push_back(Findpre(W,c));\n\t\tX.push_back(Findsuf(E,c));X.push_back(Findsuf(W,c));\n\t\tY.push_back(Findpre(N,b));Y.push_back(Findpre(S,b));\n\t\tY.push_back(Findsuf(N,b));Y.push_back(Findsuf(S,b));\n\t\tY.push_back(Findpre(N,d));Y.push_back(Findpre(S,d));\n\t\tY.push_back(Findsuf(N,d));Y.push_back(Findsuf(S,d));\n\t\tsort(X.begin(),X.end());X.resize(unique(X.begin(),X.end())-X.begin());\n\t\tsort(Y.begin(),Y.end());Y.resize(unique(Y.begin(),Y.end())-Y.begin());\n\t\tint lx=X.size(),ly=Y.size(),S,T;tot=0;\n\t\tfor(int i=0;i<lx;++i)\n\t\t\tfor(int j=0;j<ly;++j)\n\t\t\t{\n\t\t\t\tbh[i][j]=++tot;\n\t\t\t\tif(X[i]==a&&Y[j]==b)S=tot;\n\t\t\t\tif(X[i]==c&&Y[j]==d)T=tot;\n\t\t\t}\n\t\tfor(int i=1;i<=tot;++i)h[i]=0;cnt=2;\n\t\tfor(int i=0;i<lx;++i)\n\t\t\tif(dS[X[i]]=='E')for(int j=0;j<ly-1;++j)Add(bh[i][j],bh[i][j+1],Y[j+1]-Y[j]);\n\t\t\telse for(int j=1;j<ly;++j)Add(bh[i][j],bh[i][j-1],Y[j]-Y[j-1]);\n\t\tfor(int i=0;i<ly;++i)\n\t\t\tif(dT[Y[i]]=='N')for(int j=1;j<lx;++j)Add(bh[j][i],bh[j-1][i],X[j]-X[j-1]);\n\t\t\telse for(int j=0;j<lx-1;++j)Add(bh[j][i],bh[j+1][i],X[j+1]-X[j]);\n\t\tprintf(\"%d\\n\",SPFA(S,T));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\nint gi(){\n\tint x=0,w=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')w=0,ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn w?x:-x;\n}\n#define mk make_pair\nint n,m,q,dis[8][8],inf;char s[100005],t[100005];\nvector<int>vec[4];queue<pair<int,int> >Q;\nvoid add(int i,int x,vector<int>&v){\n\tint sz=vec[i].size(),p=lower_bound(vec[i].begin(),vec[i].end(),x)-vec[i].begin();\n\tif(p)v.push_back(vec[i][p-1]);if(p<sz)v.push_back(vec[i][p]);\n}\nvoid upt(int x,int y,int z){\n\tif(dis[x][y]>z)dis[x][y]=z,Q.push(mk(x,y));\n}\nint main(){\n\tn=gi();m=gi();q=gi();scanf(\"%s%s\",s+1,t+1);\n\tfor(int i=1;i<=n;++i)vec[s[i]=='W'?0:1].push_back(i);\n\tfor(int i=1;i<=m;++i)vec[t[i]=='N'?2:3].push_back(i);\n\twhile(q--){\n\t\tint a=gi(),b=gi(),c=gi(),d=gi();vector<int>X,Y;\n\t\tfor(int i=0;i<2;++i)add(i,a,X),add(i,c,X);\n\t\tfor(int i=2;i<4;++i)add(i,b,Y),add(i,d,Y);\n\t\tsort(X.begin(),X.end());X.erase(unique(X.begin(),X.end()),X.end());\n\t\tsort(Y.begin(),Y.end());Y.erase(unique(Y.begin(),Y.end()),Y.end());\n//\t\tputs(\"x :\");for(int x:X)printf(\"%d \",x);puts(\"\");\n//\t\tputs(\"y :\");for(int y:Y)printf(\"%d \",y);puts(\"\");\n\t\tint lx=X.size(),ly=Y.size();\n\t\tint sx=lower_bound(X.begin(),X.end(),a)-X.begin();\n\t\tint sy=lower_bound(Y.begin(),Y.end(),b)-Y.begin();\n\t\tint tx=lower_bound(X.begin(),X.end(),c)-X.begin();\n\t\tint ty=lower_bound(Y.begin(),Y.end(),d)-Y.begin();\n\t\tmemset(dis,63,sizeof(dis));inf=dis[0][0];dis[sx][sy]=0;Q.push(mk(sx,sy));\n\t\twhile(!Q.empty()){\n\t\t\tint x=Q.front().first,y=Q.front().second;Q.pop();\n//\t\t\tprintf(\"x=%d y=%d\\n\",x,y);\n\t\t\tif(s[X[x]]=='W')for(int z=y-1;z>=0;--z)upt(x,z,dis[x][y]+Y[y]-Y[z]);\n\t\t\telse for(int z=y+1;z<ly;++z)upt(x,z,dis[x][y]+Y[z]-Y[y]);\n\t\t\tif(t[Y[y]]=='N')for(int z=x-1;z>=0;--z)upt(z,y,dis[x][y]+X[x]-X[z]);\n\t\t\telse for(int z=x+1;z<lx;++z)upt(z,y,dis[x][y]+X[z]-X[x]);\n\t\t}\n//\t\tfor(int i=0;i<lx;++i,puts(\"\"))\n//\t\t\tfor(int j=0;j<ly;++j)\n//\t\t\t\tprintf(\"%d \",dis[i][j]==inf?-1:dis[i][j]);\n\t\tprintf(\"%d\\n\",dis[tx][ty]==inf?-1:dis[tx][ty]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n \n#define MAX 200002\n \nint n;\nint m;\n \nchar buf[MAX];\nstring s;\nstring t;\n \nint qq;\n \nvector<int> row[2];\nvector<int> col[2];\n \nvector<int> R;\nvector<int> C;\n \nvoid row_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(row[i].begin(), row[i].end(), y) - row[i].begin();\n\t\tif (id != row[i].size()) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tR.push_back(row[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != row[i].size() && row[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != row[i].size()) {\n\t\t\t\tR.push_back(row[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid col_ava(int y) {\n\tfor (int i = 0; i < 2; i++) {\n\t\tint id = lower_bound(col[i].begin(), col[i].end(), y) - col[i].begin();\n\t\tif (id != col[i].size()) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid--;\n\t\tif (id >= 0) {\n\t\t\tC.push_back(col[i][id]);\n\t\t}\n\t\tid++;\n\t\tif (id != col[i].size() && col[i][id] == y) {\n\t\t\tid++;\n\t\t\tif (id != col[i].size()) {\n\t\t\t\tC.push_back(col[i][id]);\n\t\t\t}\n\t\t}\n\t}\n}\n \nint dist[10][10];\n priority_queue<pair<int,pair<int, int> >,vector<pair<int, pair<int, int> > > , greater<pair<int, pair<int, int> > > > q;\n \nint main() {\n\tcin >> n>>m>>qq;\n\tscanf(\"%s\", buf);\n\ts = buf;\n\tscanf(\"%s\", buf);\n\tt = buf;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif (s[i] == 'W') {\n\t\t\trow[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\trow[1].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'N') {\n\t\t\tcol[0].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tcol[1].push_back(i);\n\t\t}\n\t}\n\twhile (qq--) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\ta--;\n\t\tb--;\n\t\tc--;\n\t\td--;\n\t\tR.clear();\n\t\tC.clear();\n\t\trow_ava(a);\n\t\trow_ava(c);\n\t\tcol_ava(b);\n\t\tcol_ava(d);\n\t\tsort(R.begin(), R.end());\n\t\tR.erase(unique(R.begin(), R.end()),R.end());\n\t\tsort(C.begin(), C.end());\n\t\tC.erase(unique(C.begin(), C.end()),C.end());\n\t\tpair<int, int> star = make_pair(-1, -1);\n\t\tpair<int, int> en = make_pair(-1, -1);\n\t\tfor (int i = 0; i < R.size(); i++) {\n\t\t\tfor (int j = 0; j < C.size(); j++) {\n\t\t\t\tdist[i][j] = -1;\n\t\t\t\tif (R[i] == a && C[j] == b) {\n\t\t\t\t\tstar = make_pair(i, j);\n\t\t\t\t}\n\t\t\t\tif (R[i] == c && C[j] == d) {\n\t\t\t\t\ten = make_pair(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdist[star.first][star.second] = 0;\n\t\t\n\t\tq.push(make_pair(0,make_pair(star.first, star.second)));\n\t\twhile (!q.empty()) {\n\t\t\tint x = q.top().second.first;\n\t\t\tint y = q.top().second.second;\n\t\t\tint est = q.top().first;\n\t\t\tq.pop();\n\t\t\tint ds = dist[x][y];\n\t\t\tif (ds != est)continue;\n\t\t\tif (s[R[x]] == 'W') {\n\t\t\t\tif (y) {\n\t\t\t\t\tint nex = (C[y] - C[y - 1]) + ds;\n\t\t\t\t\tif (dist[x][y-1]==-1||dist[x][y - 1] > nex) {\n\t\t\t\t\t\tdist[x][y - 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex,make_pair(x, y - 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[R[x]] == 'E') {\n\t\t\t\tif (y+1<C.size()) {\n\t\t\t\t\tint nex = (C[y+1] - C[y]) + ds;\n\t\t\t\t\tif (dist[x][y + 1] == -1 || dist[x][y +1] > nex) {\n\t\t\t\t\t\tdist[x][y + 1] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x, y + 1)));\n\t\t\t\t\t\t//continue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'N') {\n\t\t\t\tif (x) {\n\t\t\t\t\tint nex = (R[x] - R[x - 1]) + ds;\n\t\t\t\t\tif (dist[x - 1][y] == -1 || dist[x - 1][y] > nex) {\n\t\t\t\t\t\tdist[x - 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x - 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[C[y]] == 'S') {\n\t\t\t\tif (x+1<R.size()) {\n\t\t\t\t\tint nex = (R[x+1] - R[x]) + ds;\n\t\t\t\t\tif (dist[x + 1][y] == -1 || dist[x + 1][y] > nex) {\n\t\t\t\t\t\tdist[x + 1][y] = nex;\n\t\t\t\t\t\tq.push(make_pair(nex, make_pair(x + 1, y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", dist[en.first][en.second]);\n\t}\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\n\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\n\tfor(int i=1;i<=q;i++)\t\n\t{\n\t\tpii s=from[i],t=dest[i];\n\t\t\n\t\tif(s.first>t.first or s.second>t.second) continue;\n\t\t#define case0 case0\n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=ub(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][1]),z=ub(t.first,path[0][0]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n//\t\tif(s.second==t.second) continue;\n\t\t#define case1 case1\n\t\tfor(;s.first<=t.first;)\n\t\t{\n\t\t\tint x=lb(s.first,path[0][1]);\n\t\t\tif(!x) break;int tmp=abs(s.first-x)+abs(t.first-x)+abs(s.second-t.second);\n\t\t\tif(x!=s.first) \n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][0]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or y<s.second) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t#define case2 case2\n\n\t\tfor(;s.first<t.first;)\n\t\t{\n\t\t\tint x=ub(s.first,path[0][1]);\n\t\t\tif(x>=t.first or x<=s.first) break;int tmp=abs(s.second-t.second)+abs(s.first-t.first);\n\t\t\tint at=1e9,bt=1e9;\n\t\t\tint zyz;\n\t\t\tif(1)\n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][1]);if(!y) break;\n\t\t\t\tzyz=y;tmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\t\n\t\t\t//copied from  line58\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or (y<zyz)) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//licensed\n\t\t}\n\t}\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\t\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) dir[0][i]^=1;for(int i=1;i<=m;i++) dir[1][i]^=1;\n\tfor(int i=1;i<=q;i++) swap(from[i],dest[i]);\n\t\n\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\nconst ll INF = TEN(18);\n\nint main() {\n    int N, M, Q;\n    string S, T;\n    cin >> N >> M >> Q >> S >> T;\n    debug(S, T);\n    V<int> vw, ve, vn, vs;\n    rep(i, N) {\n        if (S[i] == 'W') {\n            vw.pb(i);\n        } else {\n            ve.pb(i);\n        }\n    }\n    rep(i, M) {\n        if (T[i] == 'N') {\n            vn.pb(i);\n        } else {\n            vs.pb(i);\n        }\n    }\n    while (Q--) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        --a, --b, --c, --d;\n        V<int> xs{a, c}, ys{b, d};\n        for (int x : {a, c}) {\n            if (S[a] == 'E') {\n                auto it = lower_bound(ALL(vw), x);\n                if (it != vw.end()) {\n                    xs.pb(*it);\n                }\n                if (it != vw.begin()) {\n                    --it;\n                    xs.pb(*it);\n                }\n            } else {\n                auto it = lower_bound(ALL(ve), x);\n                if (it != ve.end()) {\n                    xs.pb(*it);\n                }\n                if (it != ve.begin()) {\n                    --it;\n                    xs.pb(*it);\n                }\n            }\n        }\n        for (int y : {b, d}) {\n            if (T[y] == 'N') {\n                auto it = lower_bound(ALL(vs), y);\n                if (it != vs.end()) {\n                    ys.pb(*it);\n                }\n                if (it != vs.begin()) {\n                    --it;\n                    ys.pb(*it);\n                }\n            } else {\n                auto it = lower_bound(ALL(vn), y);\n                if (it != vn.end()) {\n                    ys.pb(*it);\n                }\n                if (it != vn.begin()) {\n                    --it;\n                    ys.pb(*it);\n                }\n            }\n        }\n        sort(ALL(xs));\n        xs.erase(unique(ALL(xs)), xs.end());\n        sort(ALL(ys));\n        ys.erase(unique(ALL(ys)), ys.end());\n        debug(xs, ys);\n\n        a = lower_bound(ALL(xs), a) - xs.begin();\n        b = lower_bound(ALL(ys), b) - ys.begin();\n        c = lower_bound(ALL(xs), c) - xs.begin();\n        d = lower_bound(ALL(ys), d) - ys.begin();\n\n        using Data = pair<ll, pii>;\n        priority_queue<Data, V<Data>, greater<Data>> que;\n        VV<ll> ds(xs.size(), V<ll>(ys.size(), INF));\n        ds[a][b] = 0;\n        que.push(mp(0, mp(a, b)));\n        while (!que.empty()) {\n            auto t = que.top();\n            que.pop();\n            int x, y;\n            tie(x, y) = t.se;\n            if (ds[x][y] < t.fi) continue;\n\n            if (T[ys[y]] == 'S') {\n                for (int nx = x + 1; nx < xs.size(); ++nx) {\n                    ll nd = ds[x][y] + abs(xs[nx] - xs[x]);\n                    if (ds[nx][y] > nd) {\n                        ds[nx][y] = nd;\n                        que.push(mp(nd, mp(nx, y)));\n                    }\n                }\n            } else {\n                for (int nx = x - 1; nx >= 0; --nx) {\n                    ll nd = ds[x][y] + abs(xs[nx] - xs[x]);\n                    if (ds[nx][y] > nd) {\n                        ds[nx][y] = nd;\n                        que.push(mp(nd, mp(nx, y)));\n                    }\n                }\n            }\n            if (S[xs[x]] == 'E') {\n                for (int ny = y + 1; ny < ys.size(); ++ny) {\n                    ll nd = ds[x][y] + abs(ys[ny] - ys[y]);\n                    if (ds[x][ny] > nd) {\n                        ds[x][ny] = nd;\n                        que.push(mp(nd, mp(x, ny)));\n                    }\n                }\n            } else {\n                for (int ny = y - 1; ny >= 0; --ny) {\n                    ll nd = ds[x][y] + abs(ys[ny] - ys[y]);\n                    if (ds[x][ny] > nd) {\n                        ds[x][ny] = nd;\n                        que.push(mp(nd, mp(x, ny)));\n                    }\n                }\n            }\n        }\n        ll ans = ds[c][d];\n        if (ans == INF) ans = -1;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <deque>\n#include <cmath>\n#include <cassert>\n#define SIZE 200005\n#define INF 1000000000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nchar S[SIZE],T[SIZE];\nint A[SIZE],B[SIZE],C[SIZE],D[SIZE];\nint dw[SIZE],de[SIZE],dw2[SIZE],de2[SIZE];\nint ds[SIZE],dn[SIZE],ds2[SIZE],dn2[SIZE];\nint rs[SIZE],re[SIZE];\nint ans[SIZE];\nint n,m,q;\n\n//South : +1\n//East  : +1\nvoid solve()\n{\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tdw[i]=de[i]=-1;\n\t\tif(i>0)\n\t\t{\n\t\t\tif(dw[i-1]!=-1) dw[i]=dw[i-1]+1;\n\t\t\tif(de[i-1]!=-1) de[i]=de[i-1]+1;\n\t\t}\n\t\tif(T[i]=='E') de[i]=0;\n\t\telse dw[i]=0;\n\t}\n\tfor(int i=m-1;i>=0;i--)\n\t{\n\t\tdw2[i]=de2[i]=-1;\n\t\tif(i+1<m)\n\t\t{\n\t\t\tif(dw2[i+1]!=-1) dw2[i]=dw2[i+1]+1;\n\t\t\tif(de2[i+1]!=-1) de2[i]=de2[i+1]+1;\n\t\t}\n\t\tif(T[i]=='E') de2[i]=0;\n\t\telse dw2[i]=0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tds[i]=dn[i]=-1;\n\t\tif(i>0)\n\t\t{\n\t\t\tif(ds[i-1]!=-1) ds[i]=ds[i-1]+1;\n\t\t\tif(dn[i-1]!=-1) dn[i]=dn[i-1]+1;\n\t\t}\n\t\tif(S[i]=='S') ds[i]=0;\n\t\telse dn[i]=0;\n\t}\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tds2[i]=dn2[i]=-1;\n\t\tif(i+1<n)\n\t\t{\n\t\t\tif(ds2[i+1]!=-1) ds2[i]=ds2[i+1]+1;\n\t\t\tif(dn2[i+1]!=-1) dn2[i]=dn2[i+1]+1;\n\t\t}\n\t\tif(S[i]=='S') ds2[i]=0;\n\t\telse dn2[i]=0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\trs[i]=(S[i]=='S');\n\t\tif(i>0) rs[i]+=rs[i-1];\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tre[i]=(T[i]=='E');\n\t\tif(i>0) re[i]+=re[i-1];\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tif(A[i]<=C[i]&&B[i]<=D[i])\n\t\t{\n\t\t\tans[i]=-1;\n\t\t\tif(A[i]==C[i]&&S[A[i]]=='S') ans[i]=D[i]-B[i];\n\t\t\telse if(B[i]==D[i]&&T[B[i]]=='E') ans[i]=C[i]-A[i];\n\t\t\telse\n\t\t\t{\n\t\t\t\tint ms=-1;\n\t\t\t\tif(S[A[i]]=='S') ms=0;\n\t\t\t\telse if(dw[B[i]]!=-1&&ds[A[i]]!=-1) ms=(dw[B[i]]+ds[A[i]])*2;\n\t\t\t\tint me=-1;\n\t\t\t\tif(T[B[i]]=='E') me=0;\n\t\t\t\telse if(de[B[i]]!=-1&&dn[A[i]]!=-1) me=(de[B[i]]+dn[A[i]])*2;\n\t\t\t\tint ms2=-1;\n\t\t\t\tif(S[C[i]]=='S') ms2=0;\n\t\t\t\telse if(dw2[D[i]]!=-1&&ds2[C[i]]!=-1) ms2=(dw2[D[i]]+ds2[C[i]])*2;\n\t\t\t\tint me2=-1;\n\t\t\t\tif(T[D[i]]=='E') me2=0;\n\t\t\t\telse if(de2[D[i]]!=-1&&dn2[C[i]]!=-1) me2=(de2[D[i]]+dn2[C[i]])*2;\n\t\t\t\tint now=INF;\n\t\t\t\tif(ms>=0&&me2>=0) now=min(now,ms+me2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tif(me>=0&&ms2>=0) now=min(now,me+ms2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tint cs=rs[C[i]]-(A[i]==0?0:rs[A[i]-1]);\n\t\t\t\tint ce=re[D[i]]-(B[i]==0?0:re[B[i]-1]);\n\t\t\t\tif(me>=0&&me2>=0&&cs>0) now=min(now,me+me2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\tif(ms>=0&&ms2>=0&&ce>0) now=min(now,ms+ms2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\t\n\t\t\t\tif(T[B[i]]=='E'&&T[D[i]]=='E')\n\t\t\t\t{\n\t\t\t\t\t//printf(\"%d %d %d\\n\",ds2[A[i]],dw2[B[i]],ds[A[i]]);\n\t\t\t\t\tif(ds2[A[i]]!=-1&&dw2[B[i]]!=-1&&B[i]+dw2[B[i]]<D[i]&&ds[A[i]]!=-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tnow=min(now,ds2[A[i]]*2+ds[A[i]]*2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(S[A[i]]=='S'&&S[C[i]]=='S')\n\t\t\t\t{\n\t\t\t\t\tif(de2[B[i]]!=-1&&dn2[A[i]]!=-1&&A[i]+dn2[A[i]]<C[i]&&de[B[i]]!=-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tnow=min(now,de2[B[i]]*2+de[B[i]]*2+C[i]+D[i]-A[i]-B[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(now!=INF) ans[i]=now;\n\t\t\t}\n\t\t\t//printf(\"* %d %d %d %d\\n\",A[i],B[i],C[i],D[i]);\n\t\t\t//printf(\"%s %s -> %d\\n\",S,T,ans[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&m,&q);\n\tscanf(\"%s\",&S);\n\tscanf(\"%s\",&T);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(S[i]=='E') S[i]='S';\n\t\telse S[i]='N';\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(T[i]=='S') T[i]='E';\n\t\telse T[i]='W';\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tscanf(\"%d %d %d %d\",&A[i],&B[i],&C[i],&D[i]);\n\t\tA[i]--,B[i]--,C[i]--,D[i]--;\n\t}\n\tsolve();\n\tfor(int l=0,r=n-1;l<r;l++,r--) swap(S[l],S[r]);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(T[i]=='E') T[i]='W';\n\t\telse T[i]='E';\n\t}\n\tfor(int i=0;i<q;i++) A[i]=n-A[i]-1,C[i]=n-C[i]-1;\n\tsolve();\n\tfor(int l=0,r=m-1;l<r;l++,r--) swap(T[l],T[r]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(S[i]=='N') S[i]='S';\n\t\telse S[i]='N';\n\t}\n\tfor(int i=0;i<q;i++) B[i]=m-B[i]-1,D[i]=m-D[i]-1;\n\tsolve();\n\tfor(int l=0,r=n-1;l<r;l++,r--) swap(S[l],S[r]);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(T[i]=='E') T[i]='W';\n\t\telse T[i]='E';\n\t}\n\tfor(int i=0;i<q;i++) A[i]=n-A[i]-1,C[i]=n-C[i]-1;\n\tsolve();\n\tfor(int i=0;i<q;i++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define fi first\n#define se second\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n\nusing namespace std;\nusing ll = int64_t;\n\nint N, M, Q;\nstring S, T;\nmap<int, vector<int>> xPositions;\nmap<int, vector<int>> yPositions;\nvector<int> interestingX;\nvector<int> interestingY;\nmap<pair<int,int>, int> distances;\nqueue<pair<int,int>> q;\n\nvoid build() {\n  for (int i = 0; i < N; i++)\n    xPositions[S[i] == 'E' ? 1 : -1].pb(i);\n  for (int i = 0; i < M; i++)\n    yPositions[T[i] == 'S' ? 1 : -1].pb(i);\n}\n\nint Next(const vector<int>& v, int x) {\n  auto it = lower_bound(all(v), x);\n  if (it == v.end())\n    return -1;\n  return *it;\n}\n\nint Prev(const vector<int>& v, int x) {\n  auto it = upper_bound(all(v), x);\n  if (it == v.begin())\n    return -1;\n  --it;\n  return *it;\n}\n\nvoid filter(vector<int>& v) {\n  sort(all(v));\n  v.erase(unique(all(v)), v.end());\n  while (!v.empty() && v.front() == -1)\n    v.erase(v.begin());\n}\n\nint ans(int x0, int y0, int x1, int y1) {\n  interestingX.clear();\n  interestingY.clear();\n  \n  interestingX.pb(x0);\n  interestingX.pb(x1);\n  interestingY.pb(y0);\n  interestingY.pb(y1);\n  for (int d = -1; d <= 1; d++) {\n    interestingX.pb(Next(xPositions[d], x0));\n    interestingX.pb(Prev(xPositions[d], x0));\n    interestingX.pb(Next(xPositions[d], x1));\n    interestingX.pb(Prev(xPositions[d], x1));\n\n    interestingY.pb(Next(yPositions[d], y0));\n    interestingY.pb(Prev(yPositions[d], y0));\n    interestingY.pb(Next(yPositions[d], y1));\n    interestingY.pb(Prev(yPositions[d], y1));\n  }\n\n  filter(interestingX);\n  filter(interestingY);\n\n  distances.clear();\n  distances[{x0, y0}] = 0;\n  q.push({x0, y0});\n\n  while (!q.empty()) {\n    auto p = q.front();\n    q.pop();\n    int d = distances[{p.fi, p.se}];\n    // cerr << \"debug: \" << p.fi << \" \" << p.se << \" \" << d << endl;\n\n    // go x\n    for (int nx : interestingX) {\n      if (T[p.se] == 'S' && nx < p.fi)\n        continue;\n      if (T[p.se] == 'N' && nx > p.fi)\n        continue;\n      int nd = d + abs(nx - p.fi);\n      auto it = distances.find({nx, p.se});\n      if (it == distances.end() || it->second > nd) {\n        distances[{nx, p.se}] = nd;\n        q.push({nx, p.se});\n      }\n    }\n\n    // go y\n    for (int ny : interestingY) {\n      if (S[p.fi] == 'E' && ny < p.se)\n        continue;\n      if (S[p.fi] == 'W' && ny > p.se)\n        continue;\n      int nd = d + abs(ny - p.se);\n      auto it = distances.find({p.fi, ny});\n      if (it == distances.end() || it->second > nd) {\n        distances[{p.fi, ny}] = nd;\n        q.push({p.fi, ny});\n      }\n    }\n  }\n\n  auto it = distances.find({x1, y1});\n  return (it == distances.end() ? -1 : it->second);\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> N >> M >> Q;\n  cin >> S >> T;\n\n  build();\n\n  for (int i = 0; i < Q; i++) {\n    int x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n    --x0, --y0, --x1, --y1;\n    cout << ans(x0, y0, x1, y1) << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int N=200005;\nstruct node\n{\n\tint h,d;\n}tp;\nbool operator <(node a,node b)\n{\n\treturn a.d>b.d;\n}\npriority_queue<node> Q;\nint n,m,q,lste[N],nxte[N],lstw[N],nxtw[N],lstn[N],nxtn[N],lsts[N],nxts[N],p1[N],p2[N],cnt1,cnt2,px[N],py[N],num,wx[N],wy[N],dis[N],head[N],adj[N],nxt[N],len[N],i,j,k,l,x[2],y[2];\nbool v[N];\nchar s[N],t[N];\nint Abs(int a)\n{\n\treturn a>0?a:-a;\n}\nvoid addedge(int u,int v,int w)\n{\n\tadj[++l]=v;\n\tnxt[l]=head[u];\n\thead[u]=l;\n\tlen[l]=w;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s%s\",s+1,t+1);\n\tfor(i=1;i<=n;++i)\n\t\tif(s[i]=='E')\n\t\t{\n\t\t\tlste[i]=i;\n\t\t\tlstw[i]=lstw[i-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlste[i]=lste[i-1];\n\t\t\tlstw[i]=i;\n\t\t}\n\tfor(i=n;i>=1;--i)\n\t\tif(s[i]=='E')\n\t\t{\n\t\t\tnxte[i]=i;\n\t\t\tnxtw[i]=nxtw[i+1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnxte[i]=nxte[i+1];\n\t\t\tnxtw[i]=i;\n\t\t}\n\tfor(i=1;i<=m;++i)\n\t\tif(t[i]=='N')\n\t\t{\n\t\t\tlstn[i]=i;\n\t\t\tlsts[i]=lsts[i-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlstn[i]=lstn[i-1];\n\t\t\tlsts[i]=i;\n\t\t}\n\tfor(i=m;i>=1;--i)\n\t\tif(t[i]=='N')\n\t\t{\n\t\t\tnxtn[i]=i;\n\t\t\tnxts[i]=nxts[i+1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnxtn[i]=nxtn[i+1];\n\t\t\tnxts[i]=i;\n\t\t}\n\twhile(q--)\n\t{\n\t\tscanf(\"%d%d%d%d\",&x[0],&y[0],&x[1],&y[1]);\n\t\tcnt1=cnt2=0;\n\t\tfor(j=0;j<=1;++j)\n\t\t{\n\t\t\tif(lste[x[j]])\n\t\t\t\tp1[++cnt1]=lste[x[j]];\n\t\t\tif(lstw[x[j]])\n\t\t\t\tp1[++cnt1]=lstw[x[j]];\n\t\t\tif(nxte[x[j]])\n\t\t\t\tp1[++cnt1]=nxte[x[j]];\n\t\t\tif(nxtw[x[j]])\n\t\t\t\tp1[++cnt1]=nxtw[x[j]];\n\t\t\tif(lstn[y[j]])\n\t\t\t\tp2[++cnt2]=lstn[y[j]];\n\t\t\tif(lsts[y[j]])\n\t\t\t\tp2[++cnt2]=lsts[y[j]];\n\t\t\tif(nxtn[y[j]])\n\t\t\t\tp2[++cnt2]=nxtn[y[j]];\n\t\t\tif(nxts[y[j]])\n\t\t\t\tp2[++cnt2]=nxts[y[j]];\n\t\t}\n\t\tnum=0;\n\t\tfor(i=1;i<=cnt1;++i)\n\t\t\tfor(j=1;j<=cnt2;++j)\n\t\t\t{\n\t\t\t\t++num;\n\t\t\t\twx[num]=p1[i],wy[num]=p2[j];\n\t\t\t}\n\t\tfor(i=1;i<=num;++i)\n\t\t\thead[i]=0;\n\t\tl=0;\n\t\tfor(i=1;i<=num;++i)\n\t\t\tfor(j=i+1;j<=num;++j)\n\t\t\t\tif(wx[i]==wx[j])\n\t\t\t\t{\n\t\t\t\t\tif((wy[i]<wy[j])==(s[wx[i]]=='E'))\n\t\t\t\t\t\taddedge(i,j,Abs(wy[i]-wy[j]));\n\t\t\t\t\telse\n\t\t\t\t\t\taddedge(j,i,Abs(wy[i]-wy[j]));\n\t\t\t\t}\n\t\t\t\telse if(wy[i]==wy[j])\n\t\t\t\t{\n\t\t\t\t\tif((wx[i]<wx[j])==(t[wy[i]]=='S'))\n\t\t\t\t\t\taddedge(i,j,Abs(wx[i]-wx[j]));\n\t\t\t\t\telse\n\t\t\t\t\t\taddedge(j,i,Abs(wx[i]-wx[j]));\n\t\t\t\t}\n\t\tfor(i=1;i<=num;++i)\n\t\t\tif(wx[i]==x[0]&&wy[i]==y[0])\n\t\t\t\tbreak;\n\t\tfor(j=1;j<=num;++j)\n\t\t\tdis[j]=1<<30,v[j]=false;\n\t\tdis[i]=0;\n\t\tQ.push((node){i,0});\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttp=Q.top();\n\t\t\tQ.pop();\n\t\t\tfor(j=head[tp.h];j;j=nxt[j])\n\t\t\t\tif(tp.d+len[j]<dis[adj[j]])\n\t\t\t\t{\n\t\t\t\t\tdis[adj[j]]=tp.d+len[j];\n\t\t\t\t\tQ.push((node){adj[j],dis[adj[j]]});\n\t\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=num;++i)\n\t\t\tif(wx[i]==x[1]&&wy[i]==y[1])\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",dis[i]<(1<<30)?dis[i]:-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing nagai = long long;\n#define sz(x) int((x).size())\nconst int N=100100;\nconst int Q=200200;\nint n,m,q;\nstring s,t;\nint sgn(int x){\n\t return (x>0)-(x<0);\n}\nint dir1[N],dir2[N];\n\nvector<int>occ1[2],occ2[2];\nvector<int>inter1,inter2;\nconst int SZ=8;\nbool used[SZ][SZ];\nnagai d[SZ][SZ];\nconst nagai oo=0x3f3f3f3f3f3f3f3f;\n\nstruct cmp{\n\tbool operator()(pair<int,int>a,pair<int,int>b)const{\n\t\tif(d[a.first][a.second]!=d[b.first][b.second])\n\t\t\treturn d[a.first][a.second]>d[b.first][b.second];\n\t\treturn a<b;\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n>>m>>q;\n\tcin>>s>>t;\n\tfor(int i=0;i<n;++i)\n\t\tdir1[i]=s[i]=='E'?1:-1;\n\tfor(int i=0;i<m;++i)\n\t\tdir2[i]=t[i]=='S'?1:-1;\n\tfor(int i=0;i<n;++i)\n\t\tocc1[dir1[i]>0].push_back(i);\n\tfor(int i=0;i<m;++i)\n\t\tocc2[dir2[i]>0].push_back(i);\n\tfor(int i=0;i<q;++i){\n\t\t int a,b,c,D;\n\t\t cin>>a>>b>>c>>D;\n\t\t --a,--b,--c,--D;\n\t\t inter1.clear();\n\t\t inter2.clear();\n\t\t for(int d=0;d<2;++d){\n\t\t\t for(int pt:{a,c}){\n\t\t\t\t int kek=lower_bound(occ1[d].begin(),occ1[d].end(),pt)-occ1[d].begin();\n\t\t\t\t if(kek!=occ1[d].size())inter1.push_back(occ1[d][kek]);\n\t\t\t\t if(kek!=0)inter1.push_back(occ1[d][kek-1]);\n\t\t\t }\n\t\t\t for(int pt:{b,D}){\n\t\t\t\t int kek=lower_bound(occ2[d].begin(),occ2[d].end(),pt)-occ2[d].begin();\n\t\t\t\t if(kek!=occ2[d].size())inter2.push_back(occ2[d][kek]);\n\t\t\t\t if(kek!=0)inter2.push_back(occ2[d][kek-1]);\n\t\t\t }\n\t\t }\n\t\t sort(inter1.begin(),inter1.end());\n\t\t inter1.erase(unique(inter1.begin(),inter1.end()),inter1.end());\n\t\t sort(inter2.begin(),inter2.end());\n\t\t inter2.erase(unique(inter2.begin(),inter2.end()),inter2.end());\n\t\t memset(d,0x3f,sizeof d);\n\t\t auto find=[&](vector<int>&vec,int x){\n\t\t\t return lower_bound(vec.begin(),vec.end(),x)-vec.begin();\n\t\t };\n\t\t int sx=find(inter1,a);\n\t\t int sy=find(inter2,b);\n\t\t d[sx][sy]=0;\n\t\t memset(used,0,sizeof used);\n\t\t int sz1=inter1.size();\n\t\t int sz2=inter2.size();\n\t\t int tx=find(inter1,c);\n\t\t int ty=find(inter2,D);\n\t\t while(true){\n\t\t\t nagai mn=oo;\n\t\t\t int x=-1,y=-1;\n\t\t\t for(int i=0;i<sz1;++i)\n\t\t\t\t for(int j=0;j<sz2;++j)\n\t\t\t\t\t if(!used[i][j]&&d[i][j]<mn)\n\t\t\t\t\t\t mn=d[i][j],x=i,y=j;\n\t\t\t if(x==-1)break;\n\t\t\t if(x==tx&&y==ty){\n\t\t\t\t break;\n\t\t\t }\n\t\t\t used[x][y]=true;\n\t\t\t for(int x1=0;x1<sz1;++x1)\n\t\t\t\t if(sgn(x1-x)==dir2[inter2[y]])\n\t\t\t\t\t d[x1][y]=min(d[x1][y],d[x][y]+abs(inter1[x]-inter1[x1]));\n\t\t\t for(int y1=0;y1<sz2;++y1)\n\t\t\t\t if(sgn(y1-y)==dir1[inter1[x]]){\n\t\t\t\t\t d[x][y1]=min(d[x][y1],d[x][y]+abs(inter2[y1]-inter2[y]));\n\t\t\t\t }\n\t\t }\n\t\t if(d[tx][ty]==oo)\n\t\t\t cout<<-1<<'\\n';\n\t\t else\n\t\t\t cout<<d[tx][ty]<<'\\n';\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define maxn 100010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int x,y,di;}t;\nint m,n,q,xl,yl,xr,yr,a[20],b[20],na,nb,nc,c[20],di[12][12];\nstring s1,s2;\nset<int> W,E,N,S;\nbool operator <(Info x,Info y){return x.di<y.di;}\nint main(){\n\tread(n);read(m);read(q);\n\tcin>>s1;cin>>s2;\n\tfor (int i=0;i<n;i++) if (s1[i]=='W')W.insert(i+1);else E.insert(i+1);\n\tfor (int i=0;i<m;i++) if (s2[i]=='N')N.insert(i+1);else S.insert(i+1);\n\twhile (q--){\n\t\tread(xl);read(yl);read(xr);read(yr);\n\t\tmemset(a,0,sizeof(a));memset(b,0,sizeof(b));na=nb=0;\n\t\tset<int>::iterator p;\n\t\tp=W.lower_bound(xl);\n\t\tif (p!=W.end())a[++na]=*p;\n\t\tif (p!=W.begin()&&(*p!=xl)){p--;a[++na]=*p;}\n\t\tp=W.lower_bound(xr);\n\t\tif (p!=W.end())a[++na]=*p;\n\t\tif (p!=W.begin()&&(*p!=xr)){p--;a[++na]=*p;}\n\t\tp=E.lower_bound(xl);\n\t\tif (p!=E.end())a[++na]=*p;\n\t\tif (p!=E.begin()&&(*p!=xl)){p--;a[++na]=*p;}\n\t\tp=E.lower_bound(xr);\n\t\tif (p!=E.end())a[++na]=*p;\n\t\tif (p!=E.begin()&&(*p!=xr)){p--;a[++na]=*p;}\n\t\tp=S.lower_bound(yl);\n\t\tif (p!=S.end())b[++nb]=*p;\n\t\tif (p!=S.begin()&&(*p!=yl)){p--;b[++nb]=*p;}\n\t\tp=S.lower_bound(yr);\n\t\tif (p!=S.end())b[++nb]=*p;\n\t\tif (p!=S.begin()&&(*p!=yr)){p--;b[++nb]=*p;}\n\t\tp=N.lower_bound(yl);\n\t\tif (p!=N.end())b[++nb]=*p;\n\t\tif (p!=N.begin()&&(*p!=yl)){p--;b[++nb]=*p;}\n\t\tp=N.lower_bound(yr);\n\t\tif (p!=N.end())b[++nb]=*p;\n\t\tif (p!=N.begin()&&(*p!=yr)){p--;b[++nb]=*p;}\n\t\tsort(a+1,a+na+1);\n\t\tsort(b+1,b+nb+1);\n\t\tfor (int i=1;i<=na;i++)c[i]=a[i];\n\t\tnc=na;na=0;\n\t\tfor (int i=1;i<=nc;i++)if (i==1||c[i]!=c[i-1]) a[++na]=c[i];\n\t\tfor (int i=1;i<=nb;i++)c[i]=b[i];\n\t\tnc=nb;nb=0;\n\t\tfor (int i=1;i<=nc;i++)if (i==1||c[i]!=c[i-1]) b[++nb]=c[i];\n\t\tfor (int i=1;i<=na;i++)\n\t\t\tfor (int j=1;j<=nb;j++)di[i][j]=INF;\n\t\tpriority_queue<Info> s;while (!s.empty()) s.pop();\n\t\tfor (int i=1;i<=na;i++)\n\t\t\tfor (int j=1;j<=nb;j++)\n\t\t\t\tif (a[i]==xl&&b[j]==yl){di[i][j]=0;s.push((Info){i,j,0});}\n//\t\tcout<<na<<' '<<nb<<endl;\n//\t\tfor (int i=1;i<=na;i++) cout<<a[i]<<' ';cout<<endl;\n//\t\tfor (int i=1;i<=nb;i++) cout<<b[i]<<' ';cout<<endl;\n\t\twhile (!s.empty()){\n\t\t\tt=s.top();s.pop();\n//\t\t\tcout<<t.x<<' '<<t.y<<' '<<t.di<<endl;\n\t\t\tint nx=t.x,ny=t.y;\n\t\t\tif (s2[b[ny]-1]=='N')nx--;else nx++;\n\t\t\tif (nx>0&&nx<=na){\n\t\t\t\tif (di[nx][ny]>t.di+abs(a[nx]-a[t.x])){\n\t\t\t\t\tdi[nx][ny]=t.di+abs(a[nx]-a[t.x]);\n\t\t\t\t\ts.push((Info){nx,ny,di[nx][ny]});\n\t\t\t\t}\n\t\t\t}\n\t\t\tnx=t.x,ny=t.y;\n\t\t\tif (s1[a[nx]-1]=='W')ny--;else ny++;\n\t\t\tif (ny>0&&ny<=nb){\n\t\t\t\tif (di[nx][ny]>t.di+abs(b[ny]-b[t.y])){\n\t\t\t\t\tdi[nx][ny]=t.di+abs(b[ny]-b[t.y]);\n\t\t\t\t\ts.push((Info){nx,ny,di[nx][ny]});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<=na;i++)\n\t\t\tfor (int j=1;j<=nb;j++)\n\t\t\t\tif (a[i]==xr&&b[j]==yr){if (di[i][j]==INF) puts(\"-1\");else printf(\"%d\\n\",di[i][j]);}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 4;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\nmap < pair < int, int >, int > mp;\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n   // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (can_simple(fromx, fromy, tox, toy)) return abs(fromx - tox) + abs(fromy - toy);\n    if (step == BUBEN) return INF;\n    if (mp.count(make_pair(fromx, fromy)) && mp[make_pair(fromx, fromy)] <= step) return INF;\n    mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][toy] == -1) continue;\n            int where = nxt[1][val][i][toy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][tox] == -1) continue;\n            int where = nxt[0][val][i][tox];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j] == k) nxt[i][val][0][j] = j;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j] == k) nxt[i][val][1][j] = j;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 100, INF = 5e18;\nvector <ii> g[N];\nint dist[N];\nbool in[N];\n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    string s, t;\n    cin >> s >> t;\n\n    while (q--) {\n\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        --x1; --y1; --x2; --y2;\n\n        auto add_row = [&](vector <int> &row, int x) {\n            row.app(x);\n            for (int i = x - 1; i >= 0; --i)\n                if (s[i] != s[x]) {\n                    row.app(i);\n                    break;\n                }   \n            for (int i = x + 1; i < n; ++i)\n                if (s[i] != s[x]) {\n                    row.app(i);\n                    break;\n                }               \n        };\n        \n        auto add_col = [&](vector <int> &col, int y) {\n            col.app(y);\n            for (int i = y - 1; i >= 0; --i)\n                if (t[i] != t[y]) {\n                    col.app(i);\n                    break;\n                }           \n            for (int i = y + 1; i < m; ++i)\n                if (t[i] != t[y]) {\n                    col.app(i);\n                    break;\n                }           \n        };\n\n        vector <int> row;\n        add_row(row, x1);\n        add_row(row, x2);\n\n        vector <int> col;\n        add_col(col, y1);\n        add_col(col, y2);\n\n        auto compr = [](vector <int> &a) {\n            sort(all(a));\n            a.resize(unique(all(a)) - a.begin());\n        };\n\n        compr(row);\n        compr(col);\n\n        x1 = lower_bound(all(row), x1) - row.begin();\n        x2 = lower_bound(all(row), x2) - row.begin();\n        \n        y1 = lower_bound(all(col), y1) - col.begin();\n        y2 = lower_bound(all(col), y2) - col.begin();\n\n        int S = x1 * 10 + y1;\n        int T = x2 * 10 + y2;\n\n    //E - right\n    //W - left\n    //N - up\n    //S - down\n\n        for (int i = 0; i < N; ++i)\n            g[i].clear();            \n\n        for (int i = 0; i < row.size(); ++i) {\n            for (int j = 0; j < col.size(); ++j) {\n                int u = i * 10 + j;\n                if (s[row[i]] == 'E') {\n                    if (j + 1 < col.size()) {\n                        //cout << u << ' ' << u + 1 << ' ' << col[j+1]-col[j] << endl;\n                        g[u].app(mp(u+1, col[j+1]-col[j]));                        \n                    }   \n                }   \n                else {\n                    if (j) {\n                        //cout << u << ' ' << u - 1 << ' ' << col[j]-col[j-1] << endl;\n                        g[u].app(mp(u-1, col[j]-col[j-1]));\n                    }   \n                }\n\n                if (t[col[j]] == 'N') {\n                    if (i) {\n                        g[u].app(mp(u-10, row[i]-row[i-1]));\n                    }   \n                }   \n                else {\n                    if (i+1 < row.size()) {\n                        g[u].app(mp(u+10, row[i+1]-row[i]));\n                    }   \n                }   \n            }   \n        }   \n\n        for (int i = 0; i < N; ++i)\n            dist[i] = INF;        \n\n        dist[S] = 0;\n        queue <int> q;\n        q.push(S);\n        in[S] = 1;\n\n        /*\n        for (auto e : row)\n            cout << e << ' ';\n        cout << endl;\n\n        for (auto e : col)\n            cout << e << ' ';\n        cout << endl;\n        */\n\n        while (q.size()) {\n            int u = q.front();\n            in[u] = 0; q.pop();\n\n            //cout << u << ' ' << dist[u] << endl;\n\n            for (auto e : g[u]) {\n                int v = e.f, c = e.s;\n                if (dist[u]+c < dist[v]) {\n                    dist[v] = dist[u]+c;\n                    if (!in[v]) {\n                        in[v] = 1;\n                        q.push(v);\n                    }   \n                }   \n            }\n        }\n\n        //cout << \"T \" << T << endl;\n\n        if (dist[T] == INF)\n            cout << -1 << endl;\n        else\n            cout << dist[T] << endl;\n    }   \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  vector<int> pnu(m),psu(m);\n  vector<int> pnl(m),psl(m);\n  for(int j=0;j<m;j++){    \n    pnu[j]=*--upper_bound(vn.begin(),vn.end(),j);\n    psu[j]=*--upper_bound(vs.begin(),vs.end(),j);    \n    pnl[j]=*lower_bound(vn.begin(),vn.end(),j);\n    psl[j]=*lower_bound(vs.begin(),vs.end(),j);\n  }\n  \n  vector<int> pwu(n),peu(n);\n  vector<int> pwl(n),pel(n);\n  for(int i=0;i<n;i++){    \n    pwu[i]=*--upper_bound(vw.begin(),vw.end(),i);\n    peu[i]=*--upper_bound(ve.begin(),ve.end(),i);    \n    pwl[i]=*lower_bound(vw.begin(),vw.end(),i);\n    pel[i]=*lower_bound(ve.begin(),ve.end(),i);\n  }      \n  \n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using ll = long long;    \n    auto T=[&](int y,int x,int step){return ((ll)y<<40)|((ll)x<<20)|(ll)step;};\n    map<ll, int> dp;\n    using P = pair<int, ll>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      ll st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      y=(st>>40);\n      x=(st>>20)^((ll)y<<20);\n      step=st&((1<<20)-1);\n      \n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(abs(ny)==INF||abs(nx)==INF) return;\n          if(ny==y&&nx==x) return;          \n          if(dp.count(T(ny,nx,ns))&&dp[T(ny,nx,ns)]<=nd) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        for(int xx:{x,d}){\n          // N           \n          if(pnu[xx]<=x)\n            push(y,pnu[xx],step+1,sum+abs(pnu[xx]-x));\n          // S\n          if(psu[xx]<=x)\n            push(y,psu[xx],step+1,sum+abs(psu[xx]-x));\n        }\n      }else{\n        for(int xx:{x,d}){\n          // N           \n          if(pnl[xx]>=x)\n            push(y,pnl[xx],step+1,sum+abs(pnl[xx]-x));\n          // S\n          if(psl[xx]>=x)\n            push(y,psl[xx],step+1,sum+abs(psl[xx]-x));\n        }\n      }\n      if(t[x]=='N'){\n        for(int yy:{y,c}){\n          // W\n          if(pwu[yy]<=y)\n            push(pwu[yy],x,step+1,sum+abs(pwu[yy]-y));\n          // E\n          if(peu[yy]<=y)\n            push(peu[yy],x,step+1,sum+abs(peu[yy]-y));\n        }\n      }else{        \n        for(int yy:{y,c}){\n          // W\n          if(pwl[yy]>=y)\n            push(pwl[yy],x,step+1,sum+abs(pwl[yy]-y));\n          // E\n          if(pel[yy]>=y)\n            push(pel[yy],x,step+1,sum+abs(pel[yy]-y));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N,M,Q; cin >> N >> M >> Q;\n\tstring S,T; cin >> S; cin >> T;\n\tvector<int> ln(M+2,-1e9),rn(M+2,1e9),ls(M+2,-1e9),rs(M+2,1e9);\n\tvector<int> ue(N+2,-1e9),de(N+2,1e9),uw(N+2,-1e9),dw(N+2,1e9);\n\trepp(i,0,M){\n\t\tln[i+1] = ln[i]; ls[i+1] = ls[i];\n\t\tif(T[i] == 'N') ln[i+1] = i+1;\n\t\telse ls[i+1] = i+1;\n\t}\n\trepm(i,M,0){\n\t\trn[i] = rn[i+1]; rs[i] = rs[i+1];\n\t\tif(T[i-1] == 'N') rn[i] = i;\n\t\telse rs[i] = i;\n\t}\n\trepp(i,0,N){\n\t\tue[i+1] = ue[i]; uw[i+1] = uw[i];\n\t\tif(S[i] == 'E') ue[i+1] = i+1;\n\t\telse uw[i+1] = i+1;\n\t}\n\trepm(i,N,0){\n\t\tde[i] = de[i+1]; dw[i] = dw[i+1];\n\t\tif(S[i-1] == 'E') de[i] = i;\n\t\telse dw[i] = i;\n\t}\n\trepp(rep_q,0,Q){\n\t\tint a,b,c,d; cin >> a >> b >> c >> d;\n\t\tvector<int> v(6),h(6);\n\t\th[0] = a; v[0] = b; h[5] = c; v[5] = d;\n\t\tif(S[a-1] == 'E'){\n\t\t\th[1] = uw[a]; h[2] = dw[a];\n\t\t} else {\n\t\t\th[1] = ue[a]; h[2] = de[a];\n\t\t}\n\t\tif(S[c-1] == 'E'){\n\t\t\th[3] = uw[c]; h[4] = dw[c];\n\t\t} else {\n\t\t\th[3] = ue[c]; h[4] = de[c];\n\t\t}\n\t\tif(T[b-1] == 'N'){\n\t\t\tv[1] = ls[b]; v[2] = rs[b];\n\t\t} else {\n\t\t\tv[1] = ln[b]; v[2] = rn[b];\n\t\t}\n\t\tif(T[d-1] == 'N'){\n\t\t\tv[3] = ls[d]; v[4] = rs[d];\n\t\t} else {\n\t\t\tv[3] = ln[d]; v[4] = rn[d];\n\t\t}\n\t\tvector<vector<int>> ans(6,vector<int>(6,1e8)),p(6,vector<int>(6,0));\n\t\tans[0][0] = 0;\n\t\tint x = 0, y = 0;\n\t\twhile(x != -1){\n\t\t\tp[x][y] = 1;\n\t\t\tint xx = -1, yy = -1, zz = 1e8;\n\t\t\trepp(i,0,6) repp(j,0,6) if(!p[i][j]){\n\t\t\t\tif(x == i && h[x] > 0 && h[x] <= N && ((S[h[x]-1]=='W')^(v[y]<=v[j]))) ans[i][j] = min(ans[i][j],ans[x][y]+abs(v[j]-v[y]));\n\t\t\t\tif(y == j && v[y] > 0 && v[y] <= M && ((T[v[y]-1]=='N')^(h[x]<=h[i]))) ans[i][j] = min(ans[i][j],ans[x][y]+abs(h[i]-h[x]));\n\t\t\t\tif(zz > ans[i][j]){\n\t\t\t\t\txx = i; yy = j; zz = ans[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = xx; y = yy;\n\t\t}\n\t\tcout << (ans[5][5]==1e8?-1:ans[5][5]) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v.size()==0  or v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v.size()==0 or v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\nint lb2(int x,vector<int> &v) {if(v.size()==0 or v[0]>x) return 1e8;return x-v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub2(int x,vector<int> &v) {if(v.size()==0 or v[v.size()-1]<x) return 1e8;return v[lower_bound(v.begin(),v.end(),x)-v.begin()]-x;}\nint bet(int l,int r,vector<int> &v) {return (ub(l,v) and ub(l,v)<=r);}\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\tfor(int i=1;i<=n;i++) path[0][dir[0][i]].push_back(i);for(int i=1;i<=m;i++) path[1][dir[1][i]].push_back(i);\n \t\n\t\n\tfor(int i=1;i<=n;i++)\n\t{pii s=from[i],t=dest[i];\n\t\tif(s.first==t.first and dir[0][s.first]==s.second<t.second) ans[i]=0;\n\t\tif(s.second==t.second and dir[1][s.second]==s.first<t.first) ans[i]=0;\n\t\tif(s.first<=t.first and s.second<=t.second)\n\t\t{\n\t\t\tint me=0,me2=0,ms=0,ms2=0;\n\t\t\tif(!dir[0][s.first])me=(lb2(s.first,path[0][1])+lb2(s.second,path[1][0]))*2;\n\t\t\tif(!dir[1][s.second])ms=(lb2(s.first,path[0][0])+lb2(s.second,path[1][1]))*2;\n\t\t\t\n\t\t\tif(!dir[0][t.first])me2=(ub2(t.first,path[0][1])+ub2(t.second,path[1][0]))*2;\n\t\t\tif(!dir[1][t.second])ms2=(ub2(t.first,path[0][0])+ub2(t.second,path[1][1]))*2;\n\t\t\t\n\t\t\tans[i]=min(ans[i],me+ms2);ans[i]=min(ans[i],ms+me2);\n\t\t\tif(bet(s.first,t.first,path[0][1])) ans[i]=min(ans[i],ms+ms2);\n\t\t\tif(bet(s.second,t.second,path[1][1])) ans[i]=min(ans[i],me+me2);\n\t\t\t\n\t\t\tif(dir[1][s.second] and dir[1][t.second])\n\t\t\t\tif(bet(s.second,t.second,path[1][0]))\n\t\t\t\t\tans[i]=min(ans[i],(lb2(s.first,path[0][1])+ub2(s.first,path[0][1]))*2);\n\t\t\t\n\t\t\tif(dir[0][s.first] and dir[0][t.first])\n\t\t\t\tif(bet(s.first,t.first,path[0][0]))\n\t\t\t\t\tans[i]=min(ans[i],(lb2(s.second,path[1][1])+ub2(s.second,path[1][1]))*2);\n\t\t}\n\t} \n \t\n\t \t\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]+abs(from[i].first-dest[i].first)+abs(from[i].second-dest[i].second));else printf(\"%d\\n\",-1);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10, D = 5;\nconst int inf = 1e9 + 42;\n\nint n, m;\nint dx[] = {0, -1, 0, 1};\nint dy[] = {1, 0, -1, 0};\nint dir_x[N], dir_y[N];\nint pref_x[N][D], pref_y[N][D];\nint suff_x[N][D], suff_y[N][D];\nvector<int> temp;\n\nll solve(int sx, int sy, int tx, int ty, int di);\ninline bool can_move(int x, int y, int d);\ninline bool on_path(int sx, int sy, int tx, int ty, int d);\ninline ll get_dist(int sx, int sy, int tx, int ty);\ninline bool in_dir(int sx, int sy, int tx, int ty, int d);\ninline ll get_next_after(int &sx, int &sy, int tx, int ty, int d0, int d1);\n\nint main() {\n\tfast_cin();\n\tint q; string s, t;\n\tcin >> n >> m >> q >> s >> t;\n\tfor (int x = 1; x <= n; ++x) {\n\t\tdir_x[x] = ((s[x - 1] == 'E') ? 0 : 2);\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tpref_x[x][d] = pref_x[x - 1][d];\n\t\t}\n\t\tpref_x[x][dir_x[x]] = x;\n\t}\n\tsuff_x[n + 1][0] = suff_x[n + 1][1] = n + 1;\n\tfor (int x = n; x >= 1; --x) {\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tsuff_x[x][d] = suff_x[x + 1][d];\n\t\t}\n\t\tsuff_x[x][dir_x[x]] = x;\n\t}\n\tfor (int y = 1; y <= m; ++y) {\n\t\tdir_y[y] = ((t[y - 1] == 'S') ? 3 : 1);\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tpref_y[y][d] = pref_y[y - 1][d];\n\t\t}\n\t\tpref_y[y][dir_y[y]] = y;\n\t}\n\tsuff_y[m + 1][0] = suff_y[m + 1][1] = m + 1;\n\tfor (int y = m; y >= 1; --y) {\n\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\tsuff_y[y][d] = suff_y[y + 1][d];\n\t\t}\n\t\tsuff_y[y][dir_y[y]] = y;\n\t}\n\twhile (q--) {\n\t\tint sx, sy, tx, ty;\n\t\tcin >> sx >> sy >> tx >> ty;\n\t\tll ans = inf;\n\t\tfor (int d0 = 0; d0 < 4; ++d0) {\n\t\t\tfor (int d1 = 0; d1 < 4; ++d1) {\n\t\t\t\tif (d0 % 2 == d1 % 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int d2 = 0; d2 < 4; ++d2) {\n\t\t\t\t\tif (d1 % 2 == d2 % 2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int d3 = 0; d3 < 4; ++d3) {\n\t\t\t\t\t\tif (d2 % 2 == d3 % 2) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int d4 = 0; d4 < 4; ++d4) {\n\t\t\t\t\t\t\tif (d3 % 2 == d4 % 2) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttemp = {d0, d1, d2, d3, d4};\n\t\t\t\t\t\t\tans = min(ans, solve(sx, sy, tx, ty, 4));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans >= inf) {\n\t\t\tans = -1;\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n}\n\nll solve(int sx, int sy, int tx, int ty, int di) {\n\tif (sx == tx and sy == ty) {\n\t\treturn 0;\n\t} else if (di < 0) {\n\t\treturn inf;\n\t} else if (!can_move(sx, sy, temp[di])) {\n\t\treturn inf;\n\t} else {\n\t\tint d = temp[di];\n\t\tif (on_path(sx, sy, tx, ty, d)) {\n\t\t\treturn get_dist(sx, sy, tx, ty);\n\t\t} else if (di == 0) {\n\t\t\treturn inf;\n\t\t}\n\t\tint x = sx, y = sy;\n\t\tll ans = get_next_after(x, y, sx, sy, d, temp[di - 1]);\n\t\tans += solve(x, y, tx, ty, di - 1);\n\t\tif (in_dir(sx, sy, tx, ty, d)) {\n\t\t\tll cand = get_next_after(sx, sy, tx, ty, d, temp[di - 1]);\n\t\t\tcand += solve(sx, sy, tx, ty, di - 1);\n\t\t\tans = min(ans, cand);\n\t\t}\n\t\treturn ans;\n\t}\n}\n\ninline bool can_move(int x, int y, int d) {\n\tif (d == 0 or d == 2) {\n\t\treturn dir_x[x] == d;\n\t} else {\n\t\treturn dir_y[y] == d;\n\t}\n}\n\ninline bool on_path(int sx, int sy, int tx, int ty, int d) {\n\tll dist = get_dist(sx, sy, tx, ty);\n\tif (sx + dx[d] * dist == tx and sy + dy[d] * dist == ty) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\ninline ll get_dist(int sx, int sy, int tx, int ty) {\n\treturn abs(sx - tx) + abs(sy - ty);\n}\n\ninline bool in_dir(int sx, int sy, int tx, int ty, int d) {\n\tll d1 = get_dist(sx, sy, tx, ty);\n\tll d2 = get_dist(sx + dx[d], sy + dy[d], tx, ty);\n\treturn d2 < d1;\n}\n\ninline ll get_next_after(int &sx, int &sy, int tx, int ty, int d0, int d1) {\n\tint x = sx, y = sy;\n\tif (d0 == 0) {\n\t\ty = suff_y[ty][d1];\n\t} else if (d0 == 1) {\n\t\tx = pref_x[tx][d1];\n\t} else if (d0 == 2) {\n\t\ty = pref_y[ty][d1];\n\t} else {\n\t\tx = suff_x[tx][d1];\n\t}\n\tif (x < 1 or x > n or y < 1 or y > m) {\n\t\treturn inf;\n\t} else {\n\t\tll ans = get_dist(x, y, sx, sy);\n\t\tsx = x; sy = y;\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n\n#define MAX_N 100000\n#define MAX_M 100000\n\nusing namespace std;\n\nint N, M, Q;\nstring S, T;\n\nint lowerX[MAX_M];\nint upperX[MAX_M];\nint lowerY[MAX_N];\nint upperY[MAX_N];\n\nvoid initCompress()\n{\n    int le = N;\n    int lw = N;\n    for ( int i = 0; i < N; i++ )\n    {\n        if ( S[i] == 'E' ) le = i;\n        if ( S[i] == 'W' ) lw = i;\n\n        lowerY[i] = min( ( S[i] == 'E' ? lw : le ), i );\n    }\n\n    int ue = -1;\n    int uw = -1;\n    for ( int i = N - 1; i >= 0; i-- )\n    {\n        if ( S[i] == 'E' ) ue = i;\n        if ( S[i] == 'W' ) uw = i;\n\n        upperY[i] = max( ( S[i] == 'E' ? uw : ue ), i );\n    }\n\n    int ln = N;\n    int ls = N;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( T[i] == 'N' ) ln = i;\n        if ( T[i] == 'S' ) ls = i;\n\n        lowerX[i] = min( ( T[i] == 'N' ? ls : ln ), i );\n    }\n\n    int un = -1;\n    int us = -1;\n    for ( int i = M - 1; i >= 0; i-- )\n    {\n        if ( T[i] == 'N' ) un = i;\n        if ( T[i] == 'S' ) us = i;\n\n        upperX[i] = max( ( T[i] == 'N' ? us : un ), i );\n    }\n}\n\nlong long dist[6][6];\n\ntypedef pair<int, int> P2;\ntypedef pair<int, P2> P3;\n\nint query( int y1, int x1, int y2, int x2 )\n{\n    vector<int> X;\n    vector<int> Y;\n\n    memset( dist, -1, sizeof( dist ) );\n\n    // initialize X\n    X.push_back( x1 );\n    X.push_back( lowerX[x1] );\n    X.push_back( upperX[x1] );\n    X.push_back( x2 );\n    X.push_back( lowerX[x2] );\n    X.push_back( upperX[x2] );\n\n    sort( X.begin(), X.end() );\n    X.erase( unique( X.begin(), X.end() ), X.end() );\n\n    // initialize Y\n    Y.push_back( y1 );\n    Y.push_back( lowerY[y1] );\n    Y.push_back( upperY[y1] );\n    Y.push_back( y2 );\n    Y.push_back( lowerY[y2] );\n    Y.push_back( upperY[y2] );\n\n    sort( Y.begin(), Y.end() );\n    Y.erase( unique( Y.begin(), Y.end() ), Y.end() );\n\n    int scx = find( X.begin(), X.end(), x1 ) - X.begin(); // index of start x\n    int scy = find( Y.begin(), Y.end(), y1 ) - Y.begin(); // index of start y\n    int gcx = find( X.begin(), X.end(), x2 ) - X.begin(); // index of goal x\n    int gcy = find( Y.begin(), Y.end(), y2 ) - Y.begin(); // index of goal y\n\n    priority_queue<P3> q;\n    q.push( P3( 0, P2( scx, scy ) ) );\n\n    while ( !q.empty() )\n    {\n        long long d = -q.top().first;\n        int cxi = q.top().second.first;\n        int cyi = q.top().second.second;\n\n        q.pop();\n\n        if ( cxi == gcx && cyi == gcy ) return d;\n\n        int x = X[cxi];\n        int y = Y[cyi];\n\n        if ( T[x] == 'N' && 0 <= cyi - 1 )\n        {\n            int ny = Y[cyi - 1];\n            long long nd = d + abs( ny - y );\n\n            if ( nd < dist[cxi][cyi - 1] || dist[cxi][cyi - 1] == -1 )\n            {\n                dist[cxi][cyi - 1] = nd;\n                q.push( P3( -nd, P2( cxi, cyi - 1 ) ) );\n            }\n        }\n        else if ( T[x] == 'S' && cyi + 1 < Y.size() )\n        {\n            int ny = Y[cyi + 1];\n            long long nd = d + abs( ny - y );\n\n            if ( nd < dist[cxi][cyi + 1] || dist[cxi][cyi + 1] == -1 )\n            {\n                dist[cxi][cyi + 1] = nd;\n                q.push( P3( -nd, P2( cxi, cyi + 1 ) ) );\n            }\n        }\n\n        if ( S[y] == 'W' && 0 <= cxi - 1 )\n        {\n            int nx = X[cxi - 1];\n            long long nd = d + abs( nx - x );\n\n            if ( nd < dist[cxi - 1][cyi] || dist[cxi - 1][cyi] == -1 )\n            {\n                dist[cxi - 1][cyi] = nd;\n                q.push( P3( -nd, P2( cxi - 1, cyi ) ) );\n            }\n        }\n        else if ( S[y] == 'E' && cxi + 1 < X.size() )\n        {\n            int nx = X[cxi + 1];\n            long long nd = d + abs( nx - x );\n\n            if ( nd < dist[cxi + 1][cyi] || dist[cxi + 1][cyi] == -1 )\n            {\n                dist[cxi + 1][cyi] = nd;\n                q.push( P3( -nd, P2( cxi + 1, cyi ) ) );\n            }\n        }\n    }\n\n    return dist[gcx][gcy];\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M >> Q;\n    cin >> S;\n    cin >> T;\n\n    initCompress();\n\n    for ( int q = 0; q < Q; q++ )\n    {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n\n        int ans = query( a - 1, b - 1, c - 1, d - 1 );\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXH=100000;\nconst int MAXW=100000;\nconst int MAXQ=200000;\n\nint h,w,nq;\nchar hordir[MAXH+1];\nchar vertdir[MAXW+1];\nint qsx[MAXQ],qsy[MAXQ],qtx[MAXQ],qty[MAXQ],qans[MAXQ];\n\nbool qdone[MAXQ];\nint prvlt[MAXH],prvrt[MAXH],nxtlt[MAXH],nxtrt[MAXH];\nint prvup[MAXW],prvdn[MAXW],nxtup[MAXW],nxtdn[MAXW];\n\nint calc(int sx,int sy,int tx,int ty,const vector<int> &xval,const vector<int> &yval) {\n\t//printf(\"calc (%d,%d)-(%d,%d) xval:\",sx,sy,tx,ty); REPSZ(i,xval) printf(\" %d\",xval[i]); printf(\" yval:\"); REPSZ(i,yval) printf(\" %d\",yval[i]); puts(\"\");\n\tint nx=SZ(xval),ny=SZ(yval);\n\tvector<vector<int>> d(nx,vector<int>(ny,INT_MAX));\n\tpriority_queue<pair<int,pair<int,int>>> pq;\n\tREP(x,nx) REP(y,ny) if(xval[x]==sx&&yval[y]==sy) d[x][y]=0,pq.push(MP(-d[x][y],MP(x,y)));\n\twhile(!pq.empty()) {\n\t\tint cost=-pq.top().first,x=pq.top().second.first,y=pq.top().second.second; pq.pop();\n\t\tif(cost!=d[x][y]) continue;\n\t\t//printf(\"\\t(%d,%d)=%d\\n\",xval[x],yval[y],cost);\n\t\tREP(xx,nx) {\n\t\t\tif(xx<x&&vertdir[yval[y]]=='S'||xx>x&&vertdir[yval[y]]=='N') continue;\n\t\t\tint ncost=cost+abs(xval[x]-xval[xx]); if(ncost<d[xx][y]) d[xx][y]=ncost,pq.push(MP(-d[xx][y],MP(xx,y)));\n\t\t}\n\t\tREP(yy,ny) {\n\t\t\tif(yy<y&&hordir[xval[x]]=='E'||yy>y&&hordir[xval[x]]=='W') continue;\n\t\t\tint ncost=cost+abs(yval[y]-yval[yy]); if(ncost<d[x][yy]) d[x][yy]=ncost,pq.push(MP(-d[x][yy],MP(x,yy)));\n\t\t}\n\t}\n\tint ret=INT_MAX; REP(x,nx) REP(y,ny) if(xval[x]==tx&&yval[y]==ty) ret=min(ret,d[x][y]); return ret;\n}\n\nvoid solve() {\n\tREP(i,nq) qdone[i]=false;\n\tREP(invhor,2) {\n\t\tREP(invvert,2) {\n\t\t\tREP(x,h) prvlt[x]=hordir[x]=='W'?x:x==0?-1:prvlt[x-1];\n\t\t\tREP(x,h) prvrt[x]=hordir[x]=='E'?x:x==0?-1:prvrt[x-1];\n\t\t\tfor(int x=h-1;x>=0;--x) nxtlt[x]=hordir[x]=='W'?x:x+1==h?-1:nxtlt[x+1];\n\t\t\tfor(int x=h-1;x>=0;--x) nxtrt[x]=hordir[x]=='E'?x:x+1==h?-1:nxtrt[x+1];\n\t\t\tREP(y,w) prvup[y]=vertdir[y]=='N'?y:y==0?-1:prvup[y-1];\n\t\t\tREP(y,w) prvdn[y]=vertdir[y]=='S'?y:y==0?-1:prvdn[y-1];\n\t\t\tfor(int y=w-1;y>=0;--y) nxtup[y]=vertdir[y]=='N'?y:y+1==w?-1:nxtup[y+1];\n\t\t\tfor(int y=w-1;y>=0;--y) nxtdn[y]=vertdir[y]=='S'?y:y+1==w?-1:nxtdn[y+1];\n\t\t\t\n\t\t\tREP(i,nq) if(qsx[i]<=qtx[i]&&qsy[i]<=qty[i]&&!qdone[i]) {\n\t\t\t\tvector<int> usehor,usevert;\n\t\t\t\tif(prvlt[qsx[i]]!=-1) usehor.PB(prvlt[qsx[i]]);\n\t\t\t\tif(prvrt[qsx[i]]!=-1) usehor.PB(prvrt[qsx[i]]);\n\t\t\t\tif(nxtlt[qtx[i]]!=-1) usehor.PB(nxtlt[qtx[i]]);\n\t\t\t\tif(nxtrt[qtx[i]]!=-1) usehor.PB(nxtrt[qtx[i]]);\n\t\t\t\tif(qsx[i]!=qtx[i]&&nxtlt[qsx[i]+1]!=-1&&nxtlt[qsx[i]+1]<qtx[i]) usehor.PB(nxtlt[qsx[i]+1]);\n\t\t\t\tif(qsx[i]!=qtx[i]&&nxtrt[qsx[i]+1]!=-1&&nxtrt[qsx[i]+1]<qtx[i]) usehor.PB(nxtrt[qsx[i]+1]);\n\t\t\t\tif(prvup[qsy[i]]!=-1) usevert.PB(prvup[qsy[i]]);\n\t\t\t\tif(prvdn[qsy[i]]!=-1) usevert.PB(prvdn[qsy[i]]);\n\t\t\t\tif(nxtup[qty[i]]!=-1) usevert.PB(nxtup[qty[i]]);\n\t\t\t\tif(nxtdn[qty[i]]!=-1) usevert.PB(nxtdn[qty[i]]);\n\t\t\t\tif(qsy[i]!=qty[i]&&nxtup[qsy[i]+1]!=-1&&nxtup[qsy[i]+1]<qty[i]) usevert.PB(nxtup[qsy[i]+1]);\n\t\t\t\tif(qsy[i]!=qty[i]&&nxtdn[qsy[i]+1]!=-1&&nxtdn[qsy[i]+1]<qty[i]) usevert.PB(nxtdn[qsy[i]+1]);\n\t\t\t\tsort(usehor.begin(),usehor.end()); sort(usevert.begin(),usevert.end()); usehor.erase(unique(usehor.begin(),usehor.end()),usehor.end()); usevert.erase(unique(usevert.begin(),usevert.end()),usevert.end());\n\t\t\t\tqans[i]=calc(qsx[i],qsy[i],qtx[i],qty[i],usehor,usevert);\n\t\t\t\tqdone[i]=true;\n\t\t\t}\n\t\t\treverse(vertdir,vertdir+w); REP(x,h) if(hordir[x]=='E') hordir[x]='W'; else if(hordir[x]=='W') hordir[x]='E'; REP(i,nq) qsy[i]=w-qsy[i]-1,qty[i]=w-qty[i]-1;\n\t\t}\n\t\treverse(hordir,hordir+h); REP(y,w) if(vertdir[y]=='S') vertdir[y]='N'; else if(vertdir[y]=='N') vertdir[y]='S'; REP(i,nq) qsx[i]=h-qsx[i]-1,qtx[i]=h-qtx[i]-1;\n\t}\n}\n\nvoid run() {\n\tscanf(\"%d%d%d\",&h,&w,&nq);\n\tscanf(\"%s\",hordir);\n\tscanf(\"%s\",vertdir);\n\tREP(i,nq) scanf(\"%d%d%d%d\",&qsx[i],&qsy[i],&qtx[i],&qty[i]),--qsx[i],--qsy[i],--qtx[i],--qty[i];\n\tsolve();\n\tREP(i,nq) printf(\"%d\\n\",qans[i]==INT_MAX?-1:qans[i]);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<ll,ll> P;\nclass RMQ{\npublic:\n  int n,dat[555555];\n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    fill(dat,dat+2*n-1,MAX);\n  }\n  void update(int k,int a){\n    k+=n-1;dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=min(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b){return query(a,b,0,0,n);}\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return MAX;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n\nclass RMQ2{\npublic:\n  int n,dat[555555];\n  void init(int _n){\n    n=1;\n    while(n<_n)n*=2;\n    fill(dat,dat+2*n-1,-MAX);\n  }\n  void update(int k,int a){\n    k+=n-1;dat[k]=a;\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=max(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  int query(int a,int b){return query(a,b,0,0,n);}\n  int query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l) return -MAX;\n    if(a<=l&&r<=b) return dat[k];\n    int vl=query(a,b,k*2+1,l,(l+r)/2);\n    int vr=query(a,b,k*2+2,(l+r)/2,r);\n    return max(vl,vr);\n  }\n};\n\nRMQ tx[2],ty[2];\nRMQ2 rx[2],ry[2];\n\nvoid Main() {\n  ll n,m,T;\n  string s,t;\n  cin >> n >> m >> T >> s >> t;\n  rep(i,2) tx[i].init(n);\n  rep(i,2) ty[i].init(m);\n  rep(i,2) rx[i].init(n);\n  rep(i,2) ry[i].init(m);\n  rep(i,n) {\n    if(s[i]=='E') {\n      tx[0].update(i,i);\n      rx[0].update(i,i);\n    } else {\n      tx[1].update(i,i);\n      rx[1].update(i,i);\n    }\n  }\n  rep(i,m) {\n    if(t[i]=='N') {\n      ty[0].update(i,i);\n      ry[0].update(i,i);\n    } else {\n      ty[1].update(i,i);\n      ry[1].update(i,i);\n    }\n  }\n  while(T--) {\n    ll ans=MAX;\n    ll x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1--,y1--,x2--,y2--;\n    string w=\"ENSW\";\n    do {\n      int c1=w[0],c2=w[2];\n      if(c1>c2) swap(c1,c2);\n      if(c1=='E'&&c2=='W'||c1=='N'&&c2=='S') {\n        string r=w+w;\n        ll x=x1,y=y1,sum=0;\n        rep(i,r.size()) {\n          if(x==x2&&y<=y2&&s[x]=='E') {\n            sum+=abs(y-y2);\n            break;\n          }\n          if(x==x2&&y>=y2&&s[x]=='W') {\n            sum+=abs(y-y2);\n            break;\n          }\n          if(y==y2&&x<=x2&&t[y]=='S') {\n            sum+=abs(x-x2);\n            break;\n          }\n          if(y==y2&&x>=x2&&t[y]=='N') {\n            sum+=abs(x-x2);\n            break;\n          }\n          if(P(x,y)==P(x2,y2)) break;\n          ll z=0;\n          if(r[i]=='E') {\n            if(t[y]=='N') {\n              z=rx[0].query(0,min(x,x2)+1);\n              if(z==-MAX) goto next;\n            } else {\n              z=tx[0].query(max(x,x2),n);\n              if(z==MAX) goto next;\n            }\n            sum+=abs(x-z);\n            x=z;\n          } else if(r[i]=='W') {\n            if(t[y]=='N') {\n              z=rx[1].query(0,min(x,x2)+1);\n              if(z==-MAX) goto next;\n            } else {\n              z=tx[1].query(max(x,x2),n);\n              if(z==MAX) goto next;\n            }\n            sum+=abs(x-z);\n            x=z;\n          } else if(r[i]=='N') {\n            if(s[x]=='W') {\n              z=ry[0].query(0,min(y,y2)+1);\n              if(z==-MAX) goto next;\n            } else {\n              z=ty[0].query(max(y,y2),m);\n              if(z==MAX) goto next;\n            }\n            sum+=abs(y-z);\n            y=z;\n          } else {\n            if(s[x]=='W') {\n              z=ry[1].query(0,min(y,y2)+1);\n              if(z==-MAX) goto next;\n            } else {\n              z=ty[1].query(max(y,y2),m);\n              if(z==MAX) goto next;\n            }\n            sum+=abs(y-z);\n            y=z;\n          }\n        }\n        ans=min(ans,sum);\n      }\n    next:;\n    } while(next_permutation(all(w)));\n    if(ans==MAX) ans=-1;\n    pr(ans);\n  }\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 400008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\n\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\n\tfor(int i=1;i<=q;i++)\t\n\t{\n\t\tpii s=from[i],t=dest[i];\n\t\t\n\t\tif(s.first>t.first or s.second>t.second) continue;\n\t\t#define case0 case0\n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=ub(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][1]),z=ub(t.first,path[0][0]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n//\t\tif(s.second==t.second) continue;\n\t\t#define case1 case1\n\t\tfor(;s.first<=t.first;)\n\t\t{\n\t\t\tint x=lb(s.first,path[0][1]);\n\t\t\tif(!x) break;int tmp=abs(s.first-x)+abs(t.first-x)+abs(s.second-t.second);\n\t\t\tint zyz=s.second;\n\t\t\tif(x!=s.first) \n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][0]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;zyz=y;\n\t\t\t}\n\t\t\t\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or y<zyz) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t#define case2 case2\n\n\t\tfor(;s.first<t.first;)\n\t\t{\n\t\t\tint x=ub(s.first,path[0][1]);\n\t\t\tif(x>=t.first or x<=s.first) break;int tmp=abs(s.second-t.second)+abs(s.first-t.first);\n\t\t\tint at=1e9,bt=1e9;\n\t\t\tint zyz;\n\t\t\tif(1)\n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][1]);if(!y) break;\n\t\t\t\tzyz=y;tmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\t\n\t\t\t//copied from  line58\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y or (y<zyz)) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//licensed\n\t\t}\n\t}\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\t\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) dir[0][i]^=1;for(int i=1;i<=m;i++) dir[1][i]^=1;\n\tfor(int i=1;i<=q;i++) swap(from[i],dest[i]);\n\t\n\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\n\nconst int inf = 1e9;\nint H,W,Q;\nstring sh,sw;\nint ans;\nV<int> Ln,Ls,Rn,Rs,Uw,Ue,Dw,De;\n\nvoid dfs(int a,int b,int c,int d,bool vert,int turn,int dist){\n\t#define goNext(na,nb) if(a!=na || b!=nb) dfs(na,nb,c,d,!vert,turn+1,dist+abs(a-na)+abs(b-nb))\n\t#define goNext2(na,nb) if(a!=na || b!=nb) dfs(na,nb,c,d,vert,turn,dist+abs(a-na)+abs(b-nb))\n\n\tif(a == -1 || a == H || b == -1 || b == W) return;\n\n\tif(a == c && b == d){\n\t\tchmin(ans,dist);\n\t\treturn;\n\t}\n\tif(turn == 5){\n\t\treturn;\n\t}\n\tif(vert){\n\t\tif(sw[b] == 'N'){\t//a--\n\t\t\tgoNext(Uw[a],b);\n\t\t\tgoNext(Ue[a],b);\n\t\t\tif(a>c){\n\t\t\t\tgoNext(c,b);\n\t\t\t\tgoNext2(c,b);\n\t\t\t}\n\t\t}else{\n\t\t\tgoNext(Dw[a],b);\n\t\t\tgoNext(De[a],b);\n\t\t\tif(a<c){\n\t\t\t\tgoNext(c,b);\n\t\t\t\tgoNext2(c,b);\n\t\t\t}\n\t\t}\n\t}else{\n\t\tif(sh[a] == 'W'){\n\t\t\tgoNext(a,Ln[b]);\n\t\t\tgoNext(a,Ls[b]);\n\t\t\tif(b>d){\n\t\t\t\tgoNext(a,d);\n\t\t\t\tgoNext2(a,d);\n\t\t\t}\n\t\t}else{\n\t\t\tgoNext(a,Rn[b]);\n\t\t\tgoNext(a,Rs[b]);\n\t\t\tif(b<d){\n\t\t\t\tgoNext(a,d);\n\t\t\t\tgoNext2(a,d);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tcin >> H >> W >> Q;\n\tcin >> sh >> sw;\n\n\t{\n\t\tLn = V<int>(W,-1);\n\t\tLs = V<int>(W,-1);\n\t\trep(i,W){\n\t\t\tif(i != 0) Ln[i] = Ln[i-1], Ls[i] = Ls[i-1];\n\t\t\tif(sw[i] == 'N') Ln[i] = i;\n\t\t\telse Ls[i] = i;\n\t\t}\n\t}\n\t{\n\t\tRn = V<int>(W,-1);\n\t\tRs = V<int>(W,-1);\n\t\trep(i,W){\n\t\t\tif(i != 0) Rn[i] = Rn[i-1], Rs[i] = Rs[i-1];\n\t\t\tif(sw[W-1-i] == 'N') Rn[i] = i;\n\t\t\telse Rs[i] = i;\n\t\t}\n\t\treverse(all(Rn));\n\t\treverse(all(Rs));\n\t\trep(i,W) Rn[i] = W-1 - Rn[i], Rs[i] = W-1 - Rs[i];\n\t}\n\t{\n\t\tUw = V<int>(H,-1);\n\t\tUe = V<int>(H,-1);\n\t\trep(i,H){\n\t\t\tif(i != 0) Uw[i] = Uw[i-1], Ue[i] = Ue[i-1];\n\t\t\tif(sh[i] == 'W') Uw[i] = i;\n\t\t\telse Ue[i] = i;\n\t\t}\n\t}\n\t{\n\t\tDw = V<int>(H,-1);\n\t\tDe = V<int>(H,-1);\n\t\trep(i,H){\n\t\t\tif(i != 0) Dw[i] = Dw[i-1], De[i] = De[i-1];\n\t\t\tif(sh[H-1-i] == 'W') Dw[i] = i;\n\t\t\telse De[i] = i;\n\t\t}\n\t\treverse(all(Dw));\n\t\treverse(all(De));\n\t\trep(i,H) Dw[i] = H-1-Dw[i], De[i] = H-1-De[i];\n\t}\n\tshow(Ln);\n\tshow(Ls);\n\tshow(Rn);\n\tshow(Rs);\n\tshow(Ue);\n\tshow(Uw);\n\tshow(De);\n\tshow(Dw);\n\n\trep(_,Q){\n\t\tint a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\ta--,b--,c--,d--;\n\t\tans = inf;\n\t\tdfs(a,b,c,d,false,0,0);\n\t\tdfs(a,b,c,d,true,0,0);\n\t\tif(ans == inf) ans = -1;\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf (int)(1e9)\n\nstruct edge{\n\tint to;\n\tint cost;\n\n\tedge(int to, int cost) : to(to), cost(cost){}\n};\n\nvector<int> dijkstra(vector<vector<edge> > g, int s){\n\tvector<int> ans(g.size(), inf);\n\tpriority_queue<pair<int, int> > q;//(距離, 頂点番号)\n\tq.push(pair<int, int>(0, s));\n\twhile(q.size() > 0){\n\t\tint dis = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tif(dis < ans[v]){\n\t\t\tans[v] = dis;\n\t\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\t\tq.push(pair<int, int>(dis + g[v][i].cost, g[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint align(int x, int y){\n\treturn 5 * x + y;\n}\n\nint main(){\n\tint N, M, Q, i, j;\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<char> S(N + 2);\n\tvector<int> nextW(N + 2), nextE(N + 2), prevW(N + 2), prevE(N + 2);\n\tscanf(\"%s\", &S[1]);\n\tnextW[N + 1] = N + 1;\n\tnextE[N + 1] = N + 1;\n\tfor(i = N; i > 0; i--){\n\t\tif(S[i] == 'W'){\n\t\t\tnextW[i] = i;\n\t\t\tnextE[i] = nextE[i + 1];\n\t\t}\n\t\telse{\n\t\t\tnextW[i] = nextW[i + 1];\n\t\t\tnextE[i] = i;\n\t\t}\n\t}\n\tprevW[0] = 0;\n\tprevE[0] = 0;\n\tfor(i = 1; i <= N; i++){\n\t\tif(S[i] == 'W'){\n\t\t\tprevW[i] = i;\n\t\t\tprevE[i] = prevE[i - 1];\n\t\t}\n\t\telse{\n\t\t\tprevW[i] = prevW[i - 1];\n\t\t\tprevE[i] = i;\n\t\t}\n\t}\n\n\tvector<char> T(M + 2);\n\tvector<int> nextN(M + 2), nextS(M + 2), prevN(M + 2), prevS(M + 2);\n\tscanf(\"%s\", &T[1]);\n\tnextN[M + 1] = M + 1;\n\tnextS[M + 1] = M + 1;\n\tfor(i = M; i > 0; i--){\n\t\tif(T[i] == 'N'){\n\t\t\tnextN[i] = i;\n\t\t\tnextS[i] = nextS[i + 1];\n\t\t}\n\t\telse{\n\t\t\tnextN[i] = nextN[i + 1];\n\t\t\tnextS[i] = i;\n\t\t}\n\t}\n\tprevN[0] = 0;\n\tprevS[0] = 0;\n\tfor(i = 1; i <= M; i++){\n\t\tif(T[i] == 'N'){\n\t\t\tprevN[i] = i;\n\t\t\tprevS[i] = prevS[i - 1];\n\t\t}\n\t\telse{\n\t\t\tprevN[i] = prevN[i - 1];\n\t\t\tprevS[i] = i;\n\t\t}\n\t}\n\tfor(int q = 0; q < Q; q++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x[5], y[5];\n\t\tx[1] = min(a, c);\n\t\tx[3] = max(a, c);\n\t\ty[1] = min(b, d);\n\t\ty[3] = max(b, d);\n\n\t\tif(S[x[1]] == 'W'){\n\t\t\tx[0] = prevE[x[1] - 1];\n\t\t\tx[2] = min(x[3], nextE[x[1] + 1]);\n\t\t}\n\t\telse{\n\t\t\tx[0] = prevW[x[1] - 1];\n\t\t\tx[2] = min(x[3], nextW[x[1] + 1]);\n\t\t}\n\t\tif(x[0] == 0){\n\t\t\tx[0] = x[1];\n\t\t}\n\t\tif(S[x[3]] == 'W'){\n\t\t\tx[4] = nextE[x[3] + 1];\n\t\t}\n\t\telse{\n\t\t\tx[4] = nextW[x[3] + 1];\n\t\t}\n\t\tif(x[4] == N + 1){\n\t\t\tx[4] = x[3];\n\t\t}\n\n\t\tif(T[y[1]] == 'N'){\n\t\t\ty[0] = prevS[y[1] - 1];\n\t\t\ty[2] = min(y[3], nextS[y[1] + 1]);\n\t\t}\n\t\telse{\n\t\t\ty[0] = prevN[y[1] - 1];\n\t\t\ty[2] = min(y[3], nextN[y[1] + 1]);\n\t\t}\n\t\tif(y[0] == 0){\n\t\t\ty[0] = y[1];\n\t\t}\n\t\tif(T[y[3]] == 'N'){\n\t\t\ty[4] = nextS[y[3] + 1];\n\t\t}\n\t\telse{\n\t\t\ty[4] = nextN[y[3] + 1];\n\t\t}\n\t\tif(y[4] == M + 1){\n\t\t\ty[4] = y[3];\n\t\t}\n\n/*\t\tprintf(\"x:\");\n\t\tfor(i = 0; i < 5; i++){\n\t\t\tprintf(\"%d \", x[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"y:\");\n\t\tfor(i = 0; i < 5; i++){\n\t\t\tprintf(\"%d \", y[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n*/\n\t\tvector<vector<edge> > g(25, vector<edge>());\n\t\tfor(i = 0; i < 5; i++){\n\t\t\tif(S[x[i]] == 'W'){\n\t\t\t\tfor(j = 1; j < 5; j++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i, j - 1), y[j] - y[j - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j = 0; j < 4; j++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i, j + 1), y[j + 1] - y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(j = 0; j < 5; j++){\n\t\t\tif(T[y[j]] == 'N'){\n\t\t\t\tfor(i = 1; i < 5; i++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i - 1, j), x[i] - x[i - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i = 0; i < 4; i++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i + 1, j), x[i + 1] - x[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s, t;\n\t\tfor(i = 0; i < 25; i++){\n\t\t\tif(x[i / 5] == a && y[i % 5] == b){\n\t\t\t\ts = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < 25; i++){\n\t\t\tif(x[i / 5] == c && y[i % 5] == d){\n\t\t\t\tt = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n/*\t\tfor(i = 0; i < 25; i++){\n\t\t\tprintf(\"edge[%d]:\", i);\n\t\t\tfor(j = 0; j < g[i].size(); j++){\n\t\t\t\tprintf(\"(%d, %d) \", g[i][j].to, g[i][j].cost);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"(s, t) = (%d, %d)\\n\", s, t);\n*/\t\tvector<int> res = dijkstra(g, s);\n\t\tif(res[t] == inf){\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\", res[t]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n//~ #pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) x.begin(),x.end()\n#define all(x) x.begin(),x.end()\n#define fi first\n#define se second\n#define _upgrade ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define erase_duplicates(x) sort(all(x)); (x).resize(distance((x).begin(), unique(all(x))));\n\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<typename T>\nusing ordered_set = tree<\nT,\nnull_type,\nless<T>,\nrb_tree_tag,\ntree_order_statistics_node_update>;\n\n//X.find_by_order(k); - zwraca iterator na k-ty element (numeracja od zerowego)\n//X.order_of_key(k); - zwraca liczbę elementów ostro mniejszych niż k\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PII> VPII;\ntypedef vector<PLL> VPLL;\ntypedef vector<LL> VLL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<char> VC;\ntypedef long double LD;\ntypedef pair<LD,LD> PLD;\ntypedef vector<LD> VLD;\ntypedef vector<PLD> VPLD;\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\" = \"<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<\" = \"<<h<<\", \"; _dbg(sdbg+1, a...);\n}\n\n#ifdef LOCAL\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define dbg(...)\n#define cerr if(0)cout\n#endif\n\nconst int maxn = (1e6)+7;\nconst int maxk = 20;\nconst int inf = (1e9)+7;\nconst LL LLinf = ((LL)1e18)+7LL;\nconst LD eps = 1e-9;\nconst LL mod = 1e9+7;\n\n// ***************************** CODE ***************************** //\n\nset<int> gora, dol, lewo, prawo;\nconst int stala = 5;\n\nint odl(PII a, PII b)\n{\n  int xd = abs(a.fi - b.fi) + abs(a.se - b.se);\n  if(a.fi >= b.fi)\n  {\n    if(gora.count(a.se))\n    {\n    //  cerr<<\"HEJ\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.fi <= b.fi)\n  {\n    if(dol.count(a.se))\n    {\n      // cerr<<\"HEJ2\"<<endl;\n      if(a.se <= b.se)\n      {\n        if(prawo.count(b.fi))\n          return xd;\n      }\n      if(a.se >= b.se)\n      {\n        if(lewo.count(b.fi))\n          return xd;\n      }\n    }\n  }\n  if(a.se <= b.se)\n  {\n    if(prawo.count(a.fi))\n    {\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  if(a.se >= b.se)\n  {\n    if(lewo.count(a.fi))\n    {\n      // cerr<<\"HEJ\"<<endl;\n      if(a.fi >= b.fi)\n      {\n        if(gora.count(b.se))\n          return xd;\n      }\n      if(a.fi <= b.fi)\n        if(dol.count(b.se))\n          return xd;\n    }\n  }\n  return inf;\n}\n\nvoid dorzuc(vector<pair<int, PII> > & a, vector<pair<int, PII> > b, int dlu)\n{\n  for(auto s : b)\n    a.pb({s.fi + dlu, s.se});\n}\n\nvector<pair<int, PII> > gen(PII cur, int k = stala)\n{\n//  cerr<<cur.fi<<\" \"<<cur.se<<endl;\n  vector<pair<int, PII> > res;\n  res.pb({0, cur});\n  if(k == 0)\n    return res;\n    if(gora.count(cur.se))\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.begin())\n        {\n          it--;\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n    else\n    {\n      if(lewo.count(cur.fi))\n      {\n        auto it = prawo.lower_bound(cur.fi);\n        if(SZ(prawo) > 0 && it != prawo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n      else\n      {\n        auto it = lewo.lower_bound(cur.fi);\n        if(SZ(lewo) > 0 && it != lewo.end())\n        {\n          auto cnt = gen({*it, cur.se}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.fi));\n        }\n      }\n    }\n\n    if(lewo.count(cur.fi))\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.begin())\n        {\n          it--;\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n    else\n    {\n      if(gora.count(cur.se))\n      {\n        auto it = dol.lower_bound(cur.se);\n        if(SZ(dol) > 0 && it != dol.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n      else\n      {\n        auto it = gora.lower_bound(cur.se);\n        if(SZ(gora) > 0 && it != gora.end())\n        {\n          auto cnt = gen({cur.fi, *it}, k - 1);\n          dorzuc(res, cnt, abs(*it - cur.se));\n        }\n      }\n    }\n  return res;\n\n}\n\nvector<pair<int, PII> > gen2(PII cur, int k = stala)\n{\n\n    vector<pair<int, PII> > res;\n    res.pb({0, cur});\n      return res;\n      if(dol.count(cur.se))\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.begin())\n          {\n            it--;\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n      else\n      {\n        if(prawo.count(cur.fi))\n        {\n          auto it = lewo.lower_bound(cur.fi);\n          if(SZ(lewo) > 0 && it != lewo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n        else\n        {\n          auto it = prawo.lower_bound(cur.fi);\n          if(SZ(prawo) > 0 && it != prawo.end())\n          {\n            auto cnt = gen2({*it, cur.se}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.fi));\n          }\n        }\n      }\n\n      if(prawo.count(cur.fi))\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.fi);\n          if(SZ(gora) > 0 && it != gora.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.fi);\n          if(SZ(dol) > 0 && it != dol.begin())\n          {\n            it--;\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n      else\n      {\n        if(dol.count(cur.se))\n        {\n          auto it = gora.lower_bound(cur.se);\n          if(SZ(gora) > 0 && it != gora.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n        else\n        {\n          auto it = dol.lower_bound(cur.se);\n          if(SZ(dol) > 0 && it != dol.end())\n          {\n            auto cnt = gen2({cur.fi, *it}, k - 1);\n            dorzuc(res, cnt, abs(*it - cur.se));\n          }\n        }\n      }\n    return res;\n\n}\n\nint main()\n{\n\t_upgrade\n  int n, m, q;\n  cin>>n>>m>>q;\n  string s;\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'E')\n      prawo.insert(i + 1);\n    else\n      lewo.insert(i + 1);\n  cin>>s;\n  for(int i = 0;i < SZ(s);i++)\n    if(s[i] == 'N')\n      gora.insert(i + 1);\n    else\n      dol.insert(i + 1);\n//  gen({4, 2});\n  // cerr<<odl({4, 2}, {3, 2})<<endl;\n // return 0;\n  while(q--)\n  {\n    PII start, meta;\n    cin>>start.fi>>start.se;\n    cin>>meta.fi>>meta.se;\n    auto it = gen(start);\n    auto it2 = gen2(meta);\n  /*\n    for(auto s : it)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n    cerr<<endl;\n    for(auto s : it2)\n      cerr<<s.fi<<\" \"<<s.se.fi<<\" \"<<s.se.se<<endl;\n      cerr<<endl;\n      cerr<<endl;\n      cerr<<endl;\n*/\n    int res = inf;\n    for(auto s : it)\n      for(auto v : it2)\n      {\n  //      cerr<<s.fi<<\" \"<<v.fi<<\" \"<<odl(s.se, v.se)<<endl;\n        res = min(res, odl(s.se, v.se) + s.fi + v.fi);\n      }\n    if(res == inf)\n      cout<<\"-1\\n\";\n    else\n      cout<<res<<\"\\n\";\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nint n, m, q;\nstring s, t;\nconst int mod = (int)1e9 + 7;\nconst int maxN = (int)1e5 + 100;\nint tp[2][maxN];\nint nxt[2][2][2][maxN];\nint num[2];\nconst int INF = (int)1e9;\nconst int BUBEN = 6;\nint get_dir(int a) {\n    if (a > 0) return 1;\n    else if (a == 0) return 0;\n    else return -1;\n}\n// nxt[a][b][c][d]\n// a - row / cols\n// b - find up or down\n// c - upper or downer\n// d - who\n//map < pair < int, int >, int > mp;\nbool can_simple(int fromx, int fromy, int tox, int toy) {\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return true;\n    return false;\n}\nint solve(int fromx, int fromy, int tox, int toy, int step) {\n    // cout << fromx << \" \" << fromy << \" \" << tox << \" \" << toy << \" \" << step << endl;\n    /*if (fromx == 3 && fromy == 1 && step == 5) {\n        exit(0);\n    }*/\n    if (step == BUBEN) return INF;\n   // mp[make_pair(fromx, fromy)] = step;\n    int ans = INF;\n    bool ok1 = true;\n    bool ok2 = true;\n    if (fromx != tox) {\n        if (get_dir(tox - fromx) != tp[1][fromy]) {\n            ok1 = false;\n        }\n        if (get_dir(tox - fromx) != tp[1][toy]) ok2 = false;\n    }\n    if (fromy != toy) {\n        if (get_dir(toy - fromy) != tp[0][tox]) ok1 = false;\n        if (get_dir(toy - fromy) != tp[0][fromx]) ok2 = false;\n    }\n    if (ok1 || ok2) return abs(fromx - tox) + abs(fromy - toy);\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[0][val][i][fromx] == -1) continue;\n            int where = nxt[0][val][i][fromx];\n            if (where == fromx) continue;\n            if (where != fromx) {\n                if (get_dir(where - fromx) != tp[1][fromy]) continue;\n            }\n            ans = min(ans, abs(where - fromx) + solve(where, fromy, tox, toy, step + 1));\n        }\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            if (nxt[1][val][i][fromy] == -1) continue;\n            int where = nxt[1][val][i][fromy];\n            if (where == fromy) continue;\n            if (where != fromy) {\n                if (get_dir(where - fromy) != tp[0][fromx]) continue;\n            }\n            ans = min(ans, abs(where - fromy) + solve(fromx, where, tox, toy, step + 1));\n        }\n    }\n    return ans;\n}\nsigned main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> m >> q;\n    num[0] = n;\n    num[1] = m;\n    cin >> s >> t;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'E') tp[0][i + 1] = 1;\n        else tp[0][i + 1] = -1;\n    }\n    for (int j = 0; j < t.size(); j++) {\n        if (t[j] == 'N') tp[1][j + 1] = -1;\n        else tp[1][j + 1] = 1;\n    }\n    for (int i = 0; i < 2; i++) {\n        for (int k = -1; k <= 1; k += 2) {\n            int val = (k + 1) / 2;\n            nxt[i][val][0][0] = -1;\n            for (int j = 1; j <= num[i]; j++) {\n                nxt[i][val][0][j] = nxt[i][val][0][j - 1];\n                if (tp[i][j] == k) nxt[i][val][0][j] = j;\n            }\n            nxt[i][val][1][num[i] + 1] = -1;\n            for (int j = num[i]; j >= 1; j--) {\n                nxt[i][val][1][j] = nxt[i][val][1][j + 1];\n                if (tp[i][j] == k) nxt[i][val][1][j] = j;\n            }\n        }\n    }\n    for (int i = 0; i < q; i++) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n//        mp.clear();\n        int x = solve(a, b, c, d, 0);\n        if (x >= INF) cout << -1 << '\\n';\n        else cout << x << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n, m, q;\n    string S, T;\n\n    cin >> n >> m >> q >> S >> T;\n\n    \n    vector<int> prevW(n, -1), prevE(n, -1), prevN(m, -1), prevS(m, -1);\n    vector<int> nextW(n, -1), nextE(n, -1), nextN(m, -1), nextS(m, -1);\n\n    for (int i = 0; i != n; ++i) {\n        if (i != 0)\n            prevW[i] = prevW[i - 1], prevE[i] = prevE[i - 1];\n\n        if (S[i] == 'W')\n            prevW[i] = i;\n        else\n            prevE[i] = i;\n    }\n    \n    for (int i = n - 1; i >= 0; --i) {\n        if (i != n - 1)\n            nextW[i] = nextW[i + 1], nextE[i] = nextE[i + 1];\n\n        if (S[i] == 'W')\n            nextW[i] = i;\n        else\n            nextE[i] = i;\n    }\n    \n\n    for (int i = 0; i != m; ++i) {\n        if (i != 0)\n            prevN[i] = prevN[i - 1], prevS[i] = prevS[i - 1];\n\n        if (T[i] == 'N')\n            prevN[i] = i;\n        else\n            prevS[i] = i;\n    }\n    \n    for (int i = m - 1; i >= 0; --i) {\n        if (i != m - 1)\n            nextN[i] = nextN[i + 1], nextS[i] = nextS[i + 1];\n\n        if (T[i] == 'N')\n            nextN[i] = i;\n        else\n            nextS[i] = i;\n    }\n    \n    for (int i = 0; i != q; ++i) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        --a; --b; --c; --d;\n\n        std::function<int(int, int, int)> fuck = [&](int x, int y, int rec) {\n            if (x == -1 or y == -1)\n                return TYPEMAX(int) / 3;\n            \n            if (x == c and y == d)\n                return 0;\n                        \n            int ans = TYPEMAX(int) / 3;\n            if (rec == 0)\n                return ans;\n\n            // if (x == c) {\n            //     if (bool(y < d) == bool(S[x] == 'E')) {\n            //         return abs(d - y);\n            //     }\n            // }\n\n            // if (y == d) {\n            //     if (bool(x < c) == bool(T[y] == 'S')) {\n            //         return abs(x - c);\n            //     }\n            // }\n            \n            if (bool(y < d) == bool(S[x] == 'E')) {\n                ans = min(ans, abs(d - y) + fuck(x, d, rec - 1));\n            }\n            if (bool(x < c) == bool(T[y] == 'S')) {\n                ans = min(ans, abs(x - c) + fuck(c, y, rec - 1));\n            }\n            \n            auto& nxtN = (S[x] == 'W' ? prevN : nextN);\n            auto& nxtS = (S[x] == 'W' ? prevS : nextS);\n\n            ans = min(ans, abs(nxtN[y] - y) + fuck(x, nxtN[y], rec - 1));\n            ans = min(ans, abs(nxtS[y] - y) + fuck(x, nxtS[y], rec - 1));\n\n            auto& nxtW = (T[y] == 'N' ? prevW : nextW);\n            auto& nxtE = (T[y] == 'N' ? prevE : nextE);\n\n            ans = min(ans, abs(nxtW[x] - x) + fuck(nxtW[x], y, rec - 1));\n            ans = min(ans, abs(nxtE[x] - x) + fuck(nxtE[x], y, rec - 1));\n\n            return ans;\n        };\n\n        int ans = TYPEMAX(int) / 3;\n        ans = min(ans, fuck(a, b, 6));\n        \n        if (ans == TYPEMAX(int) / 3)\n            ans = -1;\n\n        cout << ans << \"\\n\";\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct state{int x,y,d,dir;}st[5][11001];\nchar s[110001],t[110001];\nint n,m,q,sl[110001][2],sr[110001][2],tl[110001][2],tr[110001][2],ex,ey,sx,sy,ans,cnt[5];\nvoid go(int id,int x,int y,int d,bool ns)\n{\n\tif(ns)\n\t\tif(t[y]=='S')\n\t\t{\n\t\t\tif(sr[x][0])st[id][cnt[id]++]={sr[x][0],y,d+sr[x][0]-x,ns};\n\t\t\tif(sr[x][1])st[id][cnt[id]++]={sr[x][1],y,d+sr[x][1]-x,ns};\n\t\t\tif(ex>x)\n\t\t\t{\n\t\t\t\tif(ey==y)ans=min(ans,d+ex-x);\n\t\t\t\tif(int z=sr[ex-1][ey>y])st[id][cnt[id]++]={z,y,d+z-x,ns};\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sl[x][0])st[id][cnt[id]++]={sl[x][0],y,d+x-sl[x][0],ns};\n\t\t\tif(sl[x][1])st[id][cnt[id]++]={sl[x][1],y,d+x-sl[x][1],ns};\n\t\t\tif(ex<x)\n\t\t\t{\n\t\t\t\tif(ey==y)ans=min(ans,d+x-ex);\n\t\t\t\tif(int z=sl[ex+1][ey>y])st[id][cnt[id]++]={z,y,d+x-z,ns};\n\t\t\t}\n\t\t}\n\telse if(s[x]=='E')\n\t{\n\t\tif(tr[y][0])st[id][cnt[id]++]={x,tr[y][0],d+tr[y][0]-y,ns};\n\t\tif(tr[y][1])st[id][cnt[id]++]={x,tr[y][1],d+tr[y][1]-y,ns};\n\t\tif(ey>y)\n\t\t{\n\t\t\tif(ex==x)ans=min(ans,d+ey-y);\n\t\t\tif(int z=tr[ey-1][ex>x])st[id][cnt[id]++]={x,z,d+z-y,ns};\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(tl[y][0])st[id][cnt[id]++]={x,tl[y][0],d+y-tl[y][0],ns};\n\t\tif(tl[y][1])st[id][cnt[id]++]={x,tl[y][1],d+y-tl[y][1],ns};\n\t\tif(ey<y)\n\t\t{\n\t\t\tif(ex==x)ans=min(ans,d+y-ey);\n\t\t\tif(int z=tl[ey+1][ex>x])st[id][cnt[id]++]={x,z,d+y-z,ns};\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n>>m>>q>>(s+1)>>(t+1);\n\tfor(int i=2;i<=n;i++){sl[i][0]=sl[i-1][0];sl[i][1]=sl[i-1][1];sl[i][s[i-1]=='E']=i-1;}\n\tfor(int i=2;i<=m;i++){tl[i][0]=tl[i-1][0];tl[i][1]=tl[i-1][1];tl[i][t[i-1]=='S']=i-1;}\n\tfor(int i=n-1;i;i--){sr[i][0]=sr[i+1][0];sr[i][1]=sr[i+1][1];sr[i][s[i+1]=='E']=i+1;}\n\tfor(int i=m-1;i;i--){tr[i][0]=tr[i+1][0];tr[i][1]=tr[i+1][1];tr[i][t[i+1]=='S']=i+1;}\n\twhile(q--)\n\t{\n\t\tcin>>sx>>sy>>ex>>ey;\n\t\tans=1<<30;\n\t\tmemset(cnt,0,sizeof cnt);\n\t\tgo(0,sx,sy,0,0);\n\t\tgo(0,sx,sy,0,1);\n\t\tfor(int i=0;i<4;i++)\n\t\t\tfor(int j=0;j<cnt[i];j++)go(i+1,st[i][j].x,st[i][j].y,st[i][j].d,st[i][j].dir^1);\n\t\tcout<<(ans==(1<<30)?-1:ans)<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iterator>\n#include<cassert>\n#include<cstring>\n#include<cstdio>\n#include<set>\nusing namespace std;\n//   1\n// 0   2\n//   3\nint n,m;\nstruct R{int v,z,w;}e[1111];\nint K[111],ce,d[111];\nbool viz[111];\nint ss,tt;\nvoid ins(int a,int b,int c)\n{\n\t//printf(\"ins %d %d %d\\n\",a,b,c);\n\te[++ce]=(R){b,K[a],c};\n\tK[a]=ce;\n}\nvoid clg()\n{\n\tmemset(d,0x3f,sizeof(d));\n\tmemset(K,0,sizeof(K));\n\tmemset(viz,0,sizeof(viz));\n\tce=0;\n}\nint q[66666];\nunsigned short du,my;\nvoid SPFA()\n{\n\tmy=1;\n\tq[du=0]=ss;\n\td[ss]=0;\n\tviz[ss]=1;\t\n\tfor(;du!=my;)\n\t{\n\t\tint u=q[du++];\n\t\t//printf(\">> %d %d %d %d\\n\",ss,d[ss],u,d[u]);\n\t\tviz[u]=0;\n\t\tfor(int i=K[u];i;i=e[i].z)if(d[e[i].v]>d[u]+e[i].w)\n\t\t{\n\t\t\td[e[i].v]=d[u]+e[i].w;\n\t\t\tif(!viz[e[i].v])\n\t\t\t{\n\t\t\t\tviz[e[i].v]=1;\n\t\t\t\tq[my++]=e[i].v;\n\t\t\t}\n\t\t}\n\t}\n}\n#define cmin(a,b) ((a)=(a)<(b)?(a):(b))\n#define cmax(a,b) ((a)=(a)>(b)?(a):(b))\nchar s[111111],t[111111];\nstruct ds\n{\n\tint mi[2][2][111111],ma[2][2][111111];\n\tds()\n\t{\n\t\tmemset(mi,0x3f,sizeof(mi));\n\t\tmemset(ma,0xcf,sizeof(ma));\n\t}\n\tvoid C(int t,int x)\n\t{\n\t\tmi[t&1][t>>1][x]=x;\n\t\tma[t&1][t>>1][x]=x;\n\t}\n\tvoid qwq()\n\t{\n\t\tfor(int i=0;i<2;++i)\t\n\t\t\tfor(int j=0;j<2;++j)\n\t\t\t\tfor(int k=(i?m:n);k;--k)\n\t\t\t\t\tcmin(mi[i][j][k],mi[i][j][k+1]);\n\t\tfor(int i=0;i<2;++i)\t\n\t\t\tfor(int j=0;j<2;++j)\n\t\t\t\tfor(int k=1;k<=(i?m:n);++k)\n\t\t\t\t\tcmax(ma[i][j][k],ma[i][j][k-1]);\n\t}\n\tset<int>x,y;\n\tvoid buildGraph(int a,int b,int c,int d)\n\t{\n\t\tint lx[22],ly[22],cx=0,cy=0;\n\t\tfor(set<int>::iterator it=x.begin();it!=x.end();++it)\n\t\t\tif(*it>=1&&*it<=n)lx[cx++]=*it;\n\t\tfor(set<int>::iterator it=y.begin();it!=y.end();++it)\n\t\t\tif(*it>=1&&*it<=m)ly[cy++]=*it;\n\t\tclg();\n\t\t//for(int i=0;i<cx;++i)printf(\"x %d %d\\n\",i,lx[i]);\n\t\t//for(int i=0;i<cy;++i)printf(\"y %d %d\\n\",i,ly[i]);\n\t\t//printf(\"%d %d %d %d\\n\",a,b,c,d);\n\t\tfor(int i=0;i<cx;++i)\n\t\t\tfor(int j=0;j<cy;++j)\n\t\t\t{\n\t\t\t\tif(j&&s[lx[i]]==0)ins(i*10+j,i*10+j-1,ly[j]-ly[j-1]);\n\t\t\t\tif(i&&t[ly[j]]==1)ins(i*10+j,i*10+j-10,lx[i]-lx[i-1]);\n\t\t\t\tif(j<cy-1&&s[lx[i]]==2)ins(i*10+j,i*10+j+1,ly[j+1]-ly[j]);\n\t\t\t\tif(i<cx-1&&t[ly[j]]==3)ins(i*10+j,i*10+j+10,lx[i+1]-lx[i]);\n\t\t\t\tif(lx[i]==a&&ly[j]==b)ss=i*10+j;\n\t\t\t\tif(lx[i]==c&&ly[j]==d)tt=i*10+j;\n\t\t\t}\n\t\t//printf(\">> %d %d\\n\",ss,tt);\n\t}\n\tvoid werken(int a,int b,int c,int d)\n\t{\n\t\tx.clear();\n\t\ty.clear();\n\t\t\n\t\tx.insert(a);\n\t\tx.insert(c);\n\t\tx.insert(mi[0][0][a]);\n\t\tx.insert(mi[0][1][a]);\n\t\tx.insert(mi[0][0][c]);\n\t\tx.insert(mi[0][1][c]);\n\t\tx.insert(ma[0][0][a]);\n\t\tx.insert(ma[0][1][a]);\n\t\tx.insert(ma[0][0][c]);\n\t\tx.insert(ma[0][1][c]);\n\t\t\n\t\ty.insert(b);\n\t\ty.insert(d);\n\t\ty.insert(mi[1][0][b]);\n\t\ty.insert(mi[1][1][b]);\n\t\ty.insert(mi[1][0][d]);\n\t\ty.insert(mi[1][1][d]);\n\t\ty.insert(ma[1][0][b]);\n\t\ty.insert(ma[1][1][b]);\n\t\ty.insert(ma[1][0][d]);\n\t\ty.insert(ma[1][1][d]);\n\t\t\n\t\tbuildGraph(a,b,c,d);\n\t\tSPFA();\n\t}\n}f;\nint mp[4];\nint main()\n{\n\tint q;\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",s+1);\n\tscanf(\"%s\",t+1);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(s[i]=='W')s[i]=0;\n\t\telse s[i]=2;\n\t\tf.C(s[i],i);\n\t}\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tif(t[i]=='N')t[i]=1;\n\t\telse t[i]=3;\n\t\tf.C(t[i],i);\n\t}\n\tf.qwq();\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tf.werken(a,b,c,d);\n\t\tprintf(\"%d\\n\",::d[tt]>1e8?-1: ::d[tt]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nconst int INF = INT_MAX / 4;\n\nint selectSmall(const set<int>& s, int a)\n{\n    auto it = s.upper_bound(a);\n    if(it == s.begin())\n        return -INF;\n    -- it;\n    return *it;\n}\n\nint selectLarge(const set<int>& s, int a)\n{\n    auto it = s.lower_bound(a);\n    if(it == s.end())\n        return INF;\n    return *it;\n}\n\nint solve(\n    const set<int>& leftRoad,\n    const set<int>& rightRoad,\n    const set<int>& upRoad,\n    const set<int>& downRoad,\n    int sy, int sx, int gy, int gx, int depth\n)\n{\n    if(sy == gy){\n        if((leftRoad.find(sy) != leftRoad.end()) ^ (sx < gx))\n            return abs(sx - gx);\n    }\n\n    if(depth == 0)\n        return INF;\n\n    int ans = INF;\n    if(leftRoad.find(sy) != leftRoad.end()){\n        int x1 = selectSmall(upRoad, sx);\n        int x2 = selectSmall(downRoad, sx);\n        if(x1 != sx)\n            ans = min(ans, abs(sx - x1) + solve(upRoad, downRoad, leftRoad, rightRoad, x1, sy, gx, gy, depth - 1));\n        if(x2 != sx)\n            ans = min(ans, abs(sx - x2) + solve(upRoad, downRoad, leftRoad, rightRoad, x2, sy, gx, gy, depth - 1));\n        if(gx < sx){\n            int x3 = selectSmall(upRoad, gx);\n            int x4 = selectSmall(downRoad, gx);\n            ans = min(ans, abs(sx - x3) + solve(upRoad, downRoad, leftRoad, rightRoad, x3, sy, gx, gy, depth - 1));\n            ans = min(ans, abs(sx - x4) + solve(upRoad, downRoad, leftRoad, rightRoad, x4, sy, gx, gy, depth - 1));\n        }\n    }\n    else{\n        int x1 = selectLarge(upRoad, sx);\n        int x2 = selectLarge(downRoad, sx);\n        if(x1 != sx)\n            ans = min(ans, abs(sx - x1) + solve(upRoad, downRoad, leftRoad, rightRoad, x1, sy, gx, gy, depth - 1));\n        if(x2 != sx)\n            ans = min(ans, abs(sx - x2) + solve(upRoad, downRoad, leftRoad, rightRoad, x2, sy, gx, gy, depth - 1));\n        if(sx < gx){\n            int x3 = selectLarge(upRoad, gx);\n            int x4 = selectLarge(downRoad, gx);\n        ans = min(ans, abs(sx - x3) + solve(upRoad, downRoad, leftRoad, rightRoad, x3, sy, gx, gy, depth - 1));\n        ans = min(ans, abs(sx - x4) + solve(upRoad, downRoad, leftRoad, rightRoad, x4, sy, gx, gy, depth - 1));\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int h, w, q;\n    cin >> h >> w >> q;\n    string s, t;\n    cin >> s >> t;\n\n    set<int> leftRoad, rightRoad, upRoad, downRoad;\n    for(int y=0; y<h; ++y){\n        if(s[y] == 'W')\n            leftRoad.insert(y+1);\n        else\n            rightRoad.insert(y+1);\n    }\n    for(int x=0; x<w; ++x){\n        if(t[x] == 'N')\n            upRoad.insert(x+1);\n        else\n            downRoad.insert(x+1);\n    }\n\n    while(--q >= 0){\n        int sy, sx, gy, gx;\n        cin >> sy >> sx >> gy >> gx;\n        int ans = min(solve(leftRoad, rightRoad, upRoad, downRoad, sy, sx, gy, gx, 4),\n                      solve(upRoad, downRoad, leftRoad, rightRoad, sx, sy, gx, gy, 4));\n        if(ans < INF)\n            cout << ans << endl;\n        else\n            cout << -1 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n\nusing namespace std;\n\nchar hroad[1048576]; // 가로\nchar vroad[1048576]; // 세로\n\nstruct seg {\n  int r, c; // start\n  int d; // direction\n  seg() : r(0), c(0), d(0) {}\n  seg(int r, int c, int d) : r(r), c(c), d(d) { }\n  seg flip_x() const {\n    seg s;\n    s.r = r;\n    s.c = -c;\n    s.d = ((d <= 1) ? (1 ^ d) : d);\n    return s;\n  }\n  seg swap_xy() const {\n    seg s;\n    s.r = c;\n    s.c = r;\n    s.d = d ^ 2;\n    return s;\n  }\n};\n\nconst int dir[4][2] = {\n  0, -1, // W\n  0, 1, // E\n  -1, 0, // N\n  1, 0 // S\n};\n\nint check_cross(int base, seg s, seg t) {\n  if (s.d == 0) {\n    if (t.d == 0) return (s.r == t.r) ? (base + abs(s.c - t.c)) : -1;\n    else if (t.d == 1) return (s.r == t.r && s.c >= t.c) ? (base + abs(s.c - t.c)) : -1;\n    else if (t.d == 2) return (s.r <= t.r && s.c >= t.c) ? (base + abs(s.c - t.c) + abs(s.r - t.r)) : -1;\n    else if (t.d == 3) return (s.r >= t.r && s.c >= t.c) ? (base + abs(s.c - t.c) + abs(s.r - t.r)) : -1;\n  }\n  else if (s.d == 1) {\n    return check_cross(base, s.flip_x(), t.flip_x());\n  }\n  else if (s.d == 2) {\n    return check_cross(base, s.swap_xy(), t.swap_xy());\n  }\n  else if (s.d == 3) {\n    return check_cross(base, s.swap_xy(), t.swap_xy());\n  }\n}\n\nint c2d(char v) {\n  if (v == 'W') return 0;\n  if (v == 'E') return 1;\n  if (v == 'N') return 2;\n  if (v == 'S') return 3;\n  return 0;\n}\n\nint lastW[100002];\nint lastE[100002];\nint lastN[100002];\nint lastS[100002];\n\nint firstW[100002];\nint firstE[100002];\nint firstN[100002];\nint firstS[100002];\n\nvoid expand(seg v, vector<seg> &app) {\n  if (v.d == 0) {\n    if (lastN[v.c] != -1) app.emplace_back(v.r, lastN[v.c], c2d('N'));\n    if (lastS[v.c] != -1) app.emplace_back(v.r, lastS[v.c], c2d('S'));\n  }\n  else if (v.d == 1) {\n    if (firstN[v.c] != -1) app.emplace_back(v.r, firstN[v.c], c2d('N'));\n    if (firstS[v.c] != -1) app.emplace_back(v.r, firstS[v.c], c2d('S'));\n  }\n  else if (v.d == 2) {\n    if (lastW[v.r] != -1) app.emplace_back(lastW[v.r], v.c, c2d('W'));\n    if (lastE[v.r] != -1) app.emplace_back(lastE[v.r], v.c, c2d('E'));\n  }\n  else if (v.d == 3) {\n    if (firstW[v.r] != -1) app.emplace_back(firstW[v.r], v.c, c2d('W'));\n    if (firstE[v.r] != -1) app.emplace_back(firstE[v.r], v.c, c2d('E'));\n  }\n}\n\nint main() {\n  int n, m, q;\n  scanf(\"%d%d%d\", &n, &m, &q);\n  scanf(\"%s\", hroad);\n  scanf(\"%s\", vroad);\n  {\n    int iW = -1, iE = -1;\n    for (int i = 0; i < n; i++) {\n      if (hroad[i] == 'W') {\n        iW = i;\n      }\n      else {\n        iE = i;\n      }\n      lastW[i] = iW;\n      lastE[i] = iE;\n    }\n  }\n  {\n    int iN = -1, iS = -1;\n    for (int i = 0; i < m; i++) {\n      if (vroad[i] == 'N') {\n        iN = i;\n      }\n      else {\n        iS = i;\n      }\n      lastN[i] = iN;\n      lastS[i] = iS;\n    }\n  }\n  {\n    int iW = -1, iE = -1;\n    for (int i = n-1; i >= 0; i--) {\n      if (hroad[i] == 'W') {\n        iW = i;\n      }\n      else {\n        iE = i;\n      }\n      firstW[i] = iW;\n      firstE[i] = iE;\n    }\n  }\n  {\n    int iN = -1, iS = -1;\n    for (int i = m-1; i >= 0; i--) {\n      if (vroad[i] == 'N') {\n        iN = i;\n      }\n      else {\n        iS = i;\n      }\n      firstN[i] = iN;\n      firstS[i] = iS;\n    }\n  }\n\n  for (int i = 0; i < q; i++) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a,&b,&c,&d);\n    a--, b--, c--, d--;\n    int ans = -1;\n    vector<seg> c1;\n    vector<seg> c2;\n\n    c1.emplace_back(a, b, c2d(hroad[a]));\n    c1.emplace_back(a, b, c2d(vroad[b]));\n    for (int i = 0; i < 2; i++) {\n      expand(c1[i], c1);\n    }\n    for (int i = 2, iEnd = c1.size(); i < iEnd; i++) {\n      expand(c1[i], c1);\n    }\n\n    c2.emplace_back(c, d, 1^c2d(hroad[c]));\n    if (hroad[c] != 'W') {\n      if (lastN[d] != -1) c2.emplace_back(c, lastN[d], 1^c2d('N'));\n      if (lastS[d] != -1) c2.emplace_back(c, lastS[d], 1^c2d('S'));\n    }\n    else {\n      if (firstN[d] != -1) c2.emplace_back(c, firstN[d], 1^c2d('N'));\n      if (firstS[d] != -1) c2.emplace_back(c, firstS[d], 1^c2d('S'));\n    }\n    c2.emplace_back(c, d, 1^c2d(vroad[d]));\n    if (vroad[d] != 'N') {\n      if (lastE[c] != -1) c2.emplace_back(lastE[c], d, 1^c2d('E'));\n      if (lastW[c] != -1) c2.emplace_back(lastW[c], d, 1^c2d('W'));\n    }\n    else {\n      if (firstE[c] != -1) c2.emplace_back(firstE[c], d, 1^c2d('E'));\n      if (firstW[c] != -1) c2.emplace_back(firstW[c], d, 1^c2d('W'));\n    }\n\n    for (const auto &A : c1) {\n      for (const auto &B : c2) {\n        int base = abs(a - A.r) + abs(b - A.c) + abs(c - B.r) + abs(d - B.c);\n        int result = check_cross(base, A, B);\n        if (result < 0) continue;\n        if (ans == -1 || ans > result) {\n          ans = result;\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 266666,inf=0x3f3f3f3f;\nint n,m,q,res;char S[N],T[N];\nint qz1[N][2],hz1[N][2],hz0[N][2],qz0[N][2];//0:- 1:+\nint Abs(int x){return x>0?x:-x;}\nvoid dfs(int x1, int y1, int x2, int y2, int cur, bool dir, int dep){\n\tif(dep>4)return;\n//\tprintf(\"dfs %d %d %d %d\\n\",x1,y1,dir,cur);\n\tif(!dir){\n\t\tif(S[x1]=='E'){\n\t\t\tif(x1==x2&&y1<y2){umin(res,cur+Abs(x2-x1)+Abs(y2-y1));return;}\n\t\t\tif(hz1[y1][0])dfs(x1,hz1[y1][0],x2,y2,cur+Abs(hz1[y1][0]-y1),dir^1,dep+1);\n\t\t\tif(hz1[y1][1])dfs(x1,hz1[y1][1],x2,y2,cur+Abs(hz1[y1][1]-y1),dir^1,dep+1);\n\t\t\tif(y2>y1&&hz1[y2][x2>x1])dfs(x1,hz1[y2][x2>x1],x2,y2,cur+Abs(hz1[y2][x2>x1]-y1),dir^1,dep+1);\n\t\t}\n\t\telse{\n\t\t\tif(x1==x2&&y1>y2){umin(res,cur+Abs(x2-x1)+Abs(y2-y1));return;}\n\t\t\tif(qz1[y1][0])dfs(x1,qz1[y1][0],x2,y2,cur+Abs(qz1[y1][0]-y1),dir^1,dep+1);\n\t\t\tif(qz1[y1][1])dfs(x1,qz1[y1][1],x2,y2,cur+Abs(qz1[y1][1]-y1),dir^1,dep+1);\n\t\t\tif(y2<y1&&qz1[y2][x2>x1])dfs(x1,qz1[y2][x2>x1],x2,y2,cur+Abs(qz1[y2][x2>x1]-y1),dir^1,dep+1);\n\t\t}\n\t}\n\telse{\n\t\tif(T[y1]=='S'){\n\t\t\tif(y1==y2&&x1<x2){umin(res,cur+Abs(x2-x1)+Abs(y2-y1));return;}\n\t\t\tif(hz0[x1][0])dfs(hz0[x1][0],y1,x2,y2,cur+Abs(hz0[x1][0]-x1),dir^1,dep+1);\n\t\t\tif(hz0[x1][1])dfs(hz0[x1][1],y1,x2,y2,cur+Abs(hz0[x1][1]-x1),dir^1,dep+1);\n\t\t\tif(x2>x1&&hz0[x2][y2>y1])dfs(hz0[x2][y2>y1],y1,x2,y2,cur+Abs(hz0[x2][y2>y1]-x1),dir^1,dep+1);\n\t\t}\n\t\telse{\n\t\t\tif(y1==y2&&x1>x2){umin(res,cur+Abs(x2-x1)+Abs(y2-y1));return;}\n\t\t\tif(qz0[x1][0])dfs(qz0[x1][0],y1,x2,y2,cur+Abs(qz0[x1][0]-x1),dir^1,dep+1);\n\t\t\tif(qz0[x1][1])dfs(qz0[x1][1],y1,x2,y2,cur+Abs(qz0[x1][1]-x1),dir^1,dep+1);\n\t\t\tif(x2<x1&&qz0[x2][y2>y1])dfs(qz0[x2][y2>y1],y1,x2,y2,cur+Abs(qz0[x2][y2>y1]-x1),dir^1,dep+1);\n\t\t}\n\t}\n}\nint main() {\n\tread(n);read(m);read(q);\n\tscanf(\"%s%s\",S+1,T+1);\n\tper(i,m,1){\n\t\tmemcpy(hz1[i],hz1[i+1],sizeof(hz1[i+1]));\n\t\tif(T[i]=='N')hz1[i][0]=i;else hz1[i][1]=i;\n\t}\n\trep(i,1,m){\n\t\tmemcpy(qz1[i],qz1[i-1],sizeof(qz1[i-1]));\n\t\tif(T[i]=='N')qz1[i][0]=i;else qz1[i][1]=i;\n\t}\n\tper(i,n,1){\n\t\tmemcpy(hz0[i],hz0[i+1],sizeof(hz0[i+1]));\n\t\tif(S[i]=='W')hz0[i][0]=i;else hz0[i][1]=i;\n\t}\n\trep(i,1,n){\n\t\tmemcpy(qz0[i],qz0[i-1],sizeof(qz0[i-1]));\n\t\tif(S[i]=='W')qz0[i][0]=i;else qz0[i][1]=i;\n\t}\n\twhile(q--){\n\t\tint x1,y1,x2,y2;\n\t\tread(x1);read(y1);read(x2);read(y2);\n\t\tres=inf;dfs(x1,y1,x2,y2,0,0,0);dfs(x1,y1,x2,y2,0,1,0);\n\t\tprintf(\"%d\\n\",res<inf?res:-1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 200008\n#define pii pair<int,int>\n#define mp make_pair\nint n,m;int q;pii from[nn],dest[nn];\nint ans[nn];\nint dir[2][nn];\nvector<int> path[2][2];\n/*\n0...\n....\n...1\n\n0->\n1|\n*/\nint lb(int x,vector<int> &v) {if(v[0]>x) return 0;return v[upper_bound(v.begin(),v.end(),x)-v.begin()-1];}\nint ub(int x,vector<int> &v) {if(v[v.size()-1]<x) return 0;return v[lower_bound(v.begin(),v.end(),x)-v.begin()];}\n\n\nvoid solve()\n{\n\tpath[0][0].clear(),path[0][1].clear(),path[1][0].clear(),path[1][1].clear();\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tpath[0][dir[0][i]].push_back(i);\n\t\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tpath[1][dir[1][i]].push_back(i);\n\n\tfor(int i=1;i<=q;i++)\t\n\t{\n\t\tpii s=from[i],t=dest[i];\n\t\t\n\t\tif(s.first>t.first or s.second>t.second) continue;\n\t\t#define case0 case0\n\t\tfor(;s.second==t.second;)\n\t\t{\n\t\t\tint x=ub(s.second,path[1][1]);\n\t\t\tif(x==s.second) {ans[i]=abs(s.first-t.first);break;}\n\t\t\tint y=lb(s.first,path[0][1]),z=ub(t.first,path[0][0]);\n\t\t\tif(x&&y&&z) ans[i]=min(ans[i],abs(s.first-t.first)+abs(y-s.first)*2+abs(s.second-x)*2+abs(t.first-z)*2);\n\t\t\tbreak;\n\t\t} \n\t\tif(s.second==t.second) continue;\n\t\t#define case1 case1\n\t\tfor(;s.first<=t.first;)\n\t\t{\n\t\t\tint x=lb(s.first,path[0][1]);\n\t\t\tif(!x) break;int tmp=abs(s.first-x)+abs(t.first-x)+abs(s.second-t.second);\n\t\t\tif(x!=s.first) \n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][0]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t}\n\t\t\tint otmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t#define case2 case2\n\t\tfor(;s.first<t.first;)//middle\n\t\t{\n\t\t\tint x=ub(s.first,path[0][1]);\n\t\t\tif(x>=t.first or x<=s.first) break;int tmp=abs(s.second-t.second)+abs(s.first-t.first);\n\t\t\tint at=1e9,bt=1e9;int otmp=tmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(s.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t\tif(y!=s.second)\n\t\t\t\t{\n\t\t\t\t\tint z=lb(s.second,path[0][1]);\n\t\t\t\t\tif(!z) break;tmp+=abs(z-s.first)*2;\n\t\t\t\t}\t\n\t\t\t\tat=tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(s.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-s.second)*2;\n\t\t\t\tbt=tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=min(at,bt);\n\t\t\t\n\t\t\t//copied from  line58\n\t\t\totmp=tmp;\n\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=ub(t.second,path[1][1]);if(!y) break;\n\t\t\t\ttmp+=abs(y-t.second)*2;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][0]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp=otmp;\n\t\t\tfor(;1;)\n\t\t\t{\n\t\t\t\tint y=lb(t.second,path[1][1]);if(!y) break;\n\t\t\t\tif(y!=t.second)\n\t\t\t\t{\n\t\t\t\t\tint z=ub(t.first,path[0][1]);if(!z) break;\n\t\t\t\t\ttmp+=abs(z-t.first)*2;\n\t\t\t\t}\n\t\t\t\tans[i]=min(ans[i],tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t//licensed\n\t\t}\n\t}\n}\n\n\nvoid transform(int mask)\n{\n\tfor(int i=1;i<=n;i++) if(mask&1) dir[0][i]^=1;\n\tif(mask&2) reverse(dir[0]+1,dir[0]+n+1);\n\tfor(int i=1;i<=m;i++) if(mask&2) dir[1][i]^=1;\n\tif(mask&1) reverse(dir[1]+1,dir[1]+m+1);\n\t\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tif(mask&2) \n\t\t{\n\t\t\tfrom[i].first=n-from[i].first+1;\n\t\t\tdest[i].first=n-dest[i].first+1;\n\t\t}\n\t\tif(mask&1)\n\t\t{\n\t\t\tfrom[i].second=m-from[i].second+1;\n\t\t\tdest[i].second=m-dest[i].second+1;\n\t\t}\n\t}\n}\nchar buf[nn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",buf+1);for(int i=1;i<=n;i++) dir[0][i]=(buf[i]=='E');\n\tscanf(\"%s\",buf+1);for(int i=1;i<=m;i++) dir[1][i]=(buf[i]=='S');\n\t\n\t\n\t\n\tfor(int i=1;i<=q;i++) ans[i]=1e9,scanf(\"%d%d%d%d\",&from[i].first,&from[i].second,&dest[i].first,&dest[i].second);\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\t\n\t\n\tfor(int i=1;i<=n;i++) dir[0][i]^=1;for(int i=1;i<=m;i++) dir[1][i]^=1;\n\tfor(int i=1;i<=q;i++) swap(from[i],dest[i]);\n\t\n\t\n\t\n\tfor(int i=0;i<4;i++) {transform(i);solve();transform(i);}\t\n\t\n\tfor(int i=1;i<=q;i++) if(ans[i]<1e7)printf(\"%d\\n\",ans[i]);else printf(\"%d\\n\",-1);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m,q;\n  cin>>n>>m>>q;\n  string s,t;\n  cin>>s>>t;\n  \n  const int INF = 1e9;\n  vector<int> vw,ve,vn,vs;\n  vw.emplace_back(-INF);\n  ve.emplace_back(-INF);\n  vn.emplace_back(-INF);\n  vs.emplace_back(-INF);  \n  for(int i=0;i<n;i++){\n    if(s[i]=='W') vw.emplace_back(i);\n    if(s[i]=='E') ve.emplace_back(i);\n  }\n  for(int i=0;i<m;i++){\n    if(t[i]=='N') vn.emplace_back(i);\n    if(t[i]=='S') vs.emplace_back(i);\n  }  \n  vw.emplace_back(+INF);\n  ve.emplace_back(+INF);\n  vn.emplace_back(+INF);\n  vs.emplace_back(+INF);\n\n  for(int i=0;i<q;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    a--;b--;c--;d--;\n\n    using ll = long long;    \n    auto T=[&](int y,int x,int step){return ((ll)y<<40)|((ll)x<<20)|(ll)step;};\n    unordered_map<ll, int> dp;\n    using P = pair<int, ll>;\n    priority_queue<P, vector<P>, greater<P> > pq;\n    dp[T(a,b,0)]=0;\n    pq.emplace(dp[T(a,b,0)],T(a,b,0));\n\n    int ans=INF;\n    while(!pq.empty()){\n      int sum=pq.top().first;\n      ll st=pq.top().second;\n      pq.pop();\n      if(dp[st]<sum) continue;\n      int y,x,step;\n      y=(st>>40);\n      x=(st>>20)^((ll)y<<20);\n      step=st&((1<<20)-1);\n      \n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      \n      if((s[y]=='E'&&x<=d)||(s[y]=='W'&&x>=d))\n        if((t[d]=='S'&&y<=c)||(t[d]=='N'&&y>=c))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n      \n      if((t[x]=='S'&&y<=c)||(t[x]=='N'&&y>=c))\n        if((s[c]=='E'&&x<=d)||(s[c]=='W'&&x>=d))\n          chmin(ans,sum+abs(y-c)+abs(x-d));\n\n      if(sum+abs(y-c)+abs(x-d)>=ans) continue;\n      if(step>=3) continue;\n      auto push=\n        [&](int ny,int nx,int ns,int nd){\n          if(abs(ny)==INF||abs(nx)==INF) return;\n          if(ny==y&&nx==x) return;          \n          if(dp.count(T(ny,nx,ns))&&dp[T(ny,nx,ns)]<=nd) return;\n          dp[T(ny,nx,ns)]=nd;\n          pq.emplace(nd,T(ny,nx,ns));\n        };\n\n      if(s[y]=='W'){\n        // N           \n        for(int xx:{x,d}){\n          auto it=--upper_bound(vn.begin(),vn.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=--upper_bound(vs.begin(),vs.end(),xx);\n          if(*it<=x) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }else{\n        // N           \n        for(int xx:{x,d}){\n          auto it=lower_bound(vn.begin(),vn.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n        // S\n        for(int xx:{x,d}){\n          auto it=lower_bound(vs.begin(),vs.end(),xx);\n          if(x<=*it) push(y,*it,step+1,sum+abs(*it-x));              \n        }\n      }\n      if(t[x]=='N'){            \n        // W         \n        for(int yy:{y,c}){\n          auto it=--upper_bound(vw.begin(),vw.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=--upper_bound(ve.begin(),ve.end(),yy);\n          if(*it<=y) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      }else{\n        // W         \n        for(int yy:{y,c}){\n          auto it=lower_bound(vw.begin(),vw.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n        // E\n        for(int yy:{y,c}){\n          auto it=lower_bound(ve.begin(),ve.end(),yy);\n          if(y<=*it) push(*it,x,step+1,sum+abs(*it-y));\n        }\n      } \n    }\n    if(ans==INF) ans=-1;\n    cout<<ans<<\"\\n\";\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define inf 100000000000000000\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[100005], prer[100005], nextl[100005], nextr[100005];\nllint preu[100005], pred[100005], nextu[100005], nextd[100005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i+1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i+1] == 'S') nextd[i] = i+1;\n\t}\n\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(s[a] == 'W'){\n\t\t//左\n\t\tint x = POSL(up,min(d,b));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSL(dw,min(d,b));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(up,max(d,b));\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSU(dw,max(d,b));\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(t[b] == 'N'){\n\t\t//上\n\t\tint x = POSL(le,min(a,c));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSL(ri,min(a,c));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(le,max(a,c));\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSU(ri,max(a,c));\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,7,0);\n\t\ton_y(a,b,c,d,7,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(s[a] == 'W'){\n\t\t//左\n\t\tint x = POSL(up,min(d,b));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\telse if(POSL(up,b) > 0){\n\t\t    x = POSL(up,b); x--;\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSL(dw,min(d,b));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\telse if(POSL(dw,b) > 0){\n\t\t    y = POSL(dw,b); y--;\n\t\t    on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(up,max(d,b));\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\telse if(POSU(up,b) != up.size()){\n\t\t    x = POSU(up,b);\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = POSU(dw,max(d,b));\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\telse if(POSU(dw,b) != dw.size()){\n\t\t    y = POSU(dw,b);\n\t\t   on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(t[b] == 'N'){\n\t\t//上\n\t\tint x = POSL(le,min(a,c));\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\telse if(POSL(le,a)){\n\t\t    x = POSL(le,a)-1;\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSL(ri,min(a,c));\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\telse if(POSL(ri,a)){\n\t\t    y = POSL(ri,a)-1;\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t//右\n\t\tint x = POSU(le,max(a,c));\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\telse if(POSU(le,a) != le.size()){\n\t\t    x = POSU(le,a);\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = POSU(ri,max(a,c));\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\telse if(POSU(ri,a) != ri.size()){\n\t\t    y = POSU(ri,a);\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,5,0);\n\t\ton_y(a,b,c,d,5,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long long int exa = 1000000000000000000;\n//const int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, turn, dis;\n\tNode(int a, int b, int c = 0, int d = 0) {\n\t\ty = a, x = b;\n\t\tturn = c;\n\t\tdis = d;\n\t}\n};\n\nint border = 4;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int>ldif(W, -1);\n\tvector<int>rdif(W, -1);\n\tfor (int i = 1; i < W; i++) {\n\t\tif (t[i] == t[i - 1])ldif[i] = ldif[i - 1];\n\t\telse ldif[i] = i - 1;\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (t[i] == t[i + 1])rdif[i] = rdif[i + 1];\n\t\telse rdif[i] = i + 1;\n\t}\n\tvector<int>udif(H, -1);\n\tvector<int>ddif(H, -1);\n\tfor (int i = 1; i < H; i++) {\n\t\tif (s[i] == s[i - 1])udif[i] = udif[i - 1];\n\t\telse udif[i] = i - 1;\n\t}\n\tfor (int i = H - 2; i >= 0; i--) {\n\t\tif (s[i] == s[i + 1])ddif[i] = ddif[i + 1];\n\t\telse ddif[i] = i + 1;\n\t}\n\tvector<int>ret;\n\tfor (int i = 0; i < K; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\ta--, b--, c--, d--;\n\t\tqueue<Node>Q;\n\t\tQ.push(Node(a, b));\n\t\tint ans = MOD;\n\t\twhile (!Q.empty()) {\n\t\t\tauto cn = Q.front();\n\t\t\tQ.pop();\n\t\t\t//cerr << cn.y << \" \" << cn.x << \" \" << cn.turn << \" \" << cn.dis << endl;\n\t\t\tif (cn.y == c && cn.x == d) {\n\t\t\t\tans = min(ans, cn.dis);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cn.turn == border)break;\n\t\t\tif (t[cn.x] == 'N') {//(-,0)\n\t\t\t\tif (c <= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(c - cn.y) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (c <= cn.y) {\n\t\t\t\t\tif (udif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push({ Node(udif[cn.y],cn.x,cn.turn + 1,cn.dis + abs(cn.y - udif[cn.y])) });\n\t\t\t\t\t}\n\t\t\t\t\tif (udif[c] != -1 && udif[c] != udif[cn.y]) {\n\t\t\t\t\t\tQ.push(Node(udif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - udif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (udif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push({ Node(udif[cn.y],cn.x,cn.turn + 1,cn.dis + abs(cn.y - udif[cn.y])) });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c >= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(c - cn.y) + abs(cn.x - d));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if (c >= cn.y) {\n\t\t\t\t\tif (ddif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[cn.y], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[cn.y])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ddif[c] != -1 && ddif[c] != ddif[cn.y]) {\n\t\t\t\t\t\tQ.push(Node(ddif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ddif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[cn.y], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[cn.y])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[cn.y] == 'W') {\n\t\t\t\tif (d <= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(d - cn.x) + abs(cn.y - c));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(d<=cn.x){\n\t\t\t\t\tif (ldif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - ldif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ldif[d] != -1 && ldif[d] != ldif[cn.x]) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[d], cn.turn + 1, cn.dis + abs(cn.x - ldif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ldif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - ldif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d >= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tans = min(ans, cn.dis + abs(d - cn.x) + abs(cn.y - c));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(d>=cn.x){\n\t\t\t\t\tif (rdif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - rdif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (rdif[d] != -1 && rdif[d] != rdif[cn.x]) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[d], cn.turn + 1, cn.dis + abs(cn.x - rdif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (rdif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - rdif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == MOD)ans = -1;\n\t\tret.push_back(ans);\n\t}\n\tfor (auto i : ret)cout << i << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename T> ll min(ll a, const T&& b) { return a < b ? a : b; }\ntemplate<typename T> ll min(const T&& a, ll b) { return a < b ? a : b; }\ntemplate<typename T> ll max(ll a, const T&& b) { return a > b ? a : b; }\ntemplate<typename T> ll max(const T&& a, ll b) { return a > b ? a : b; }\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nvector<ll> merge(const vector<ll>& a, const vector<ll>& b) {\n  vector<ll> res;\n  each(x, a) res.pb(x);\n  each(x, b) res.pb(x);\n  sort(all(res));\n  return res;\n}\n\npair<vector<ll>, vector<ll>> merge(const pair<vector<ll>, vector<ll>>& a, const pair<vector<ll>, vector<ll>>& b) {\n  return make_pair(merge(a.first, b.first), merge(a.second, b.second));\n}\n\n#define NODE(x,y) ((y)*m+(x))\n\nvector<ll> dijkstra(const vector<vector<P>>& G, const ll s) {\n  const ll n = G.size();\n  vector<ll> res(n, linf);\n  res[s] = 0;\n  priority_queue<P, vector<P>, greater<P>> Q;\n  Q.push(P(0, s));\n  while ( !Q.empty() ) {\n    P p = Q.top(); Q.pop();\n    ll v = p.second;\n    if (p.first > res[v]) continue;\n    each(e, G[v]) {\n      ll to = e.first, cost = e.second;\n      if (res[v] + cost < res[to]) {\n        res[to] = res[v]+cost;\n        Q.push(P(res[to], to));\n      }\n    }\n  }\n  return res;\n}\n\nll solve(const vector<ll>& L, const vector<ll>& R, const vector<ll>& U, const vector<ll>& D, ll x1, ll y1, ll x2, ll y2) {\n  vector<ll> X = merge(U, D);\n  vector<ll> Y = merge(L, R);\n  const ll n = Y.size(), m = X.size();\n  vector<vector<P>> G(n*m);\n  each(yy, L) {\n    ll y = lower_bound(all(Y), yy) - Y.begin();\n    rep(x, 1, m) {\n      G[NODE(x, y)].eb(NODE(x-1, y), X[x] - X[x-1]);\n    }\n  }\n  each(yy, R) {\n    ll y = lower_bound(all(Y), yy) - Y.begin();\n    rep(x, 1, m) {\n      G[NODE(x-1, y)].eb(NODE(x, y), X[x] - X[x-1]);\n    }\n  }\n  each(xx, U) {\n    ll x = lower_bound(all(X), xx) - X.begin();\n    rep(y, 1, n) {\n      G[NODE(x, y)].eb(NODE(x, y-1), Y[y] - Y[y-1]);\n    }\n  }\n  each(xx, D) {\n    ll x = lower_bound(all(X), xx) - X.begin();\n    rep(y, 1, n) {\n      G[NODE(x, y-1)].eb(NODE(x, y), Y[y] - Y[y-1]);\n    }\n  }\n  x1 = lower_bound(all(X), x1) - X.begin();\n  y1 = lower_bound(all(Y), y1) - Y.begin();\n  x2 = lower_bound(all(X), x2) - X.begin();\n  y2 = lower_bound(all(Y), y2) - Y.begin();\n  ll s = NODE(x1,y1), t = NODE(x2,y2);\n  vector<ll> dist = dijkstra(G, s);\n  return dist[t];\n}\n\nvoid solve() {\n  ll h, w, Q; cin >> h >> w >> Q;\n  string S, T; cin >> S >> T;\n  vector<ll> U, D, L, R;\n  rep(i, h) {\n    if (S[i] == 'E') {\n      R.pb(i);\n    }\n    else {\n      L.pb(i);\n    }\n  }\n  rep(i, w) {\n    if (T[i] == 'N') {\n      U.pb(i);\n    }\n    else {\n      D.pb(i);\n    }\n  }\n  auto pickup2 = [&](ll x, const vector<ll>& a) {\n    auto it = upper_bound(all(a), x);\n    vector<ll> res;\n    if (it != a.end()) res.pb(*it);\n    if (it != a.begin()) {\n      --it;\n      res.pb(*it);\n      if (*it == x && it != a.begin()) {\n        res.pb(*it);\n      }\n    }\n    return res;\n  };\n  auto pickup = [&](ll x, const vector<ll>& a, const vector<ll>& b) {\n    return make_pair(pickup2(x, a), pickup2(x, b));\n  };\n  rep(q, Q) {\n    ll y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2; --y1, --x1, --y2, --x2;\n    auto v1 = pickup(y1, L, R);\n    auto v2 = pickup(x1, U, D);\n    auto v3 = pickup(y2, L, R);\n    auto v4 = pickup(x2, U, D);\n    auto a = merge(v1, v3);\n    auto b = merge(v2, v4);\n    ll ans = solve(a.first, a.second, b.first, b.second, x1, y1, x2, y2);\n    if (ans == linf) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,q;\nchar s[100005];\nchar t[100005];\nvector<int>up,dw,le,ri;\nll ans;\nint U[100005][2],D[100005][2],L[100005][2],R[100005][2];\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans);\n\nvoid  on_x(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(s[a] == 'W'){\n\t    \tif(d <= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//左\n\t\tint x = U[min(d,b)][0];\n\t\tint xx = U[b][0];\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(U[b][0] > 0){\n\t\t    x = U[b][0]; x--;\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = D[min(d,b)][0];\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(D[b][0] > 0){\n\t\t    y = D[b][0]; y--;\n\t\t    on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\n\t}\n\telse{\n\t    if(d >= b){\n\t\t\tif(t[d] == 'N' && c <= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(t[d] == 'S' && c >= a){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = U[max(d,b)][1];\n\t\tif(x < up.size()){\n\t\t\ton_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tif(U[b][1] != up.size()){\n\t\t    x = U[b][1];\n\t\t    on_y(a,up[x],c,d,dep-1,cur_ans+abs(b-up[x]));\n\t\t}\n\t\tint y = D[max(d,b)][1];\n\t\tif(y < dw.size()){\n\t\t\ton_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\tif(D[b][1] != dw.size()){\n\t\t    y = D[b][1];\n\t\t   on_y(a,dw[y],c,d,dep-1,cur_ans+abs(b-dw[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nvoid  on_y(int a,int b,int c,int d,int dep,ll cur_ans){\n\tif(dep == 0) return ;\n\tif(cur_ans >= ans) return;\n\tif(t[b] == 'N'){\n\t    if(c <= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//上\n\t\tint x = L[min(a,c)][0];\n\t\tif(x){\n\t\t\tx--;\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(L[a][0]){\n\t\t    x = L[a][0]-1;\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = R[min(a,c)][0];\n\t\tif(y){\n\t\t\ty--;\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(R[a][0]){\n\t\t    y = R[a][0]-1;\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\telse{\n\t    if(c >= a){\n\t\t\tif(s[c] == 'W' && d <= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t\tif(s[c] == 'E' && d >= b){\n\t\t\t\tans = min(ans,cur_ans+abs(a-c)+abs(b-d));\n\t\t\t}\n\t\t}\n\t\t//右\n\t\tint x = L[max(a,c)][1];\n\t\tif(x < le.size()){\n\t\t\ton_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tif(L[a][1] != le.size()){\n\t\t    x = L[a][1];\n\t\t    on_x(le[x],b,c,d,dep-1,cur_ans+abs(a-le[x]));\n\t\t}\n\t\tint y = R[max(a,c)][1];\n\t\tif(y < ri.size()){\n\t\t\ton_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\tif(R[a][1] != ri.size()){\n\t\t    y = R[a][1];\n\t\t    on_x(ri[y],b,c,d,dep-1,cur_ans+abs(a-ri[y]));\n\t\t}\n\t\t\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",&s);\n\tfor(int i=0;i<n;i++){\n\t\tif(s[i] == 'W') le.pb(i);\n\t\telse ri.pb(i);\n\t}\n\tscanf(\"%s\",&t);\n\tfor(int i=0;i<m;i++){\n\t\tif(t[i] == 'N') up.pb(i);\n\t\telse dw.pb(i);\n\t}\n\tfor(int i=0;i<100005;i++){\n\t    L[i][0] = POSL(le,i);\n\t    R[i][0] = POSL(ri,i);\n\t    U[i][0] = POSL(up,i);\n\t    D[i][0] = POSL(dw,i);\n\t     L[i][1] = POSU(le,i);\n\t    R[i][1] = POSU(ri,i);\n\t    U[i][1] = POSU(up,i);\n\t    D[i][1] = POSU(dw,i);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint a,b,c,d; scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--; b--; c--; d--;\n\t\tans = 1e18;\n\t\ton_x(a,b,c,d,4,0);\n\t\ton_y(a,b,c,d,4,0);\n\t\tif(ans > 1e17) puts(\"-1\");\n\t\telse printf(\"%lld\\n\",ans);\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n, m, q;\n    string S, T;\n\n    cin >> n >> m >> q >> S >> T;\n\n    \n    vector<int> prevW(n, -1), prevE(n, -1), prevN(m, -1), prevS(m, -1);\n    vector<int> nextW(n, -1), nextE(n, -1), nextN(m, -1), nextS(m, -1);\n\n    for (int i = 0; i != n; ++i) {\n        if (i != 0)\n            prevW[i] = prevW[i - 1], prevE[i] = prevE[i - 1];\n\n        if (S[i] == 'W')\n            prevW[i] = i;\n        else\n            prevE[i] = i;\n    }\n    \n    for (int i = n - 1; i >= 0; --i) {\n        if (i != n - 1)\n            nextW[i] = nextW[i + 1], nextE[i] = nextE[i + 1];\n\n        if (S[i] == 'W')\n            nextW[i] = i;\n        else\n            nextE[i] = i;\n    }\n    \n\n    for (int i = 0; i != m; ++i) {\n        if (i != 0)\n            prevN[i] = prevN[i - 1], prevS[i] = prevS[i - 1];\n\n        if (T[i] == 'N')\n            prevN[i] = i;\n        else\n            prevS[i] = i;\n    }\n    \n    for (int i = m - 1; i >= 0; --i) {\n        if (i != m - 1)\n            nextN[i] = nextN[i + 1], nextS[i] = nextS[i + 1];\n\n        if (T[i] == 'N')\n            nextN[i] = i;\n        else\n            nextS[i] = i;\n    }\n    \n    for (int i = 0; i != q; ++i) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        --a; --b; --c; --d;\n\n        std::function<int(int, int, int)> fuck = [&](int x, int y, int rec) {\n            if (x == -1 or y == -1)\n                return TYPEMAX(int) / 3;\n            \n            if (x == c and y == d)\n                return 0;\n                        \n            int ans = TYPEMAX(int) / 3;\n            if (rec == 0)\n                return ans;\n\n            // if (x == c) {\n            //     if (bool(y < d) == bool(S[x] == 'E')) {\n            //         return abs(d - y);\n            //     }\n            // }\n\n            // if (y == d) {\n            //     if (bool(x < c) == bool(T[y] == 'S')) {\n            //         return abs(x - c);\n            //     }\n            // }\n            \n            if (bool(y < d) == bool(S[x] == 'E')) {\n                ans = min(ans, abs(d - y) + fuck(x, d, rec - 1));\n            }\n            if (bool(x < c) == bool(T[y] == 'S')) {\n                ans = min(ans, abs(x - c) + fuck(c, y, rec - 1));\n            }\n            \n            auto& nxtN = (S[x] == 'W' ? prevN : nextN);\n            auto& nxtS = (S[x] == 'W' ? prevS : nextS);\n\n            ans = min(ans, abs(nxtN[y] - y) + fuck(x, nxtN[y], rec - 1));\n            ans = min(ans, abs(nxtS[y] - y) + fuck(x, nxtS[y], rec - 1));\n\n            auto& nxtW = (T[y] == 'N' ? prevW : nextW);\n            auto& nxtE = (T[y] == 'N' ? prevE : nextE);\n\n            ans = min(ans, abs(nxtW[x] - x) + fuck(nxtW[x], y, rec - 1));\n            ans = min(ans, abs(nxtE[x] - x) + fuck(nxtE[x], y, rec - 1));\n\n            return ans;\n        };\n\n        int ans = TYPEMAX(int) / 3;\n        ans = min(ans, fuck(a, b, 5));\n        \n        if (ans == TYPEMAX(int) / 3)\n            ans = -1;\n\n        cout << ans << \"\\n\";\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#define inf 1000000000\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to, cost;\n\tedge(){}\n\tedge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint H, W, Q;\nstring s, t;\nint prel[100005], prer[100005], nextl[100005], nextr[100005];\nint preu[100005], pred[100005], nextu[100005], nextd[100005];\nvector<int> vecx, vecy;\nvector<edge> G[205];\nint dist[205];\nint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(int i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(int sx, int gx, vector<int> &vec, int N, int preu[], int pred[], int nextu[], int nextd[])\n{\n\tvec.clear();\n\tvec.push_back(sx);\n\tvec.push_back(preu[sx]);\n\tvec.push_back(pred[sx]);\n\tvec.push_back(nextu[sx]);\n\tvec.push_back(nextd[sx]);\n\tvec.push_back(gx);\n\tvec.push_back(preu[gx]);\n\tvec.push_back(pred[gx]);\n\tvec.push_back(nextu[gx]);\n\tvec.push_back(nextd[gx]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(int i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(int i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i-1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(int i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(int i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i-1] == 'S') nextd[i] = i+1;\n\t}\n\n\tint sx, sy, gx, gy;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tint w = vecx.size(), h = vecy.size();\n\t\tfor(int i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\tint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint SX, GX, SY, GY;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << endl;\n\t\telse cout << dist[T] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nnamespace ShortestPath {\n\tconst ll INF = 1e18;\n\tconst int MAXP = 1e6;\n\tstruct edge {int dest, len; };\n\tint n; ll dist[MAXP];\n\tvector <edge> a[MAXP];\n\tset <pair <ll, int> > st;\n\tvoid addedge(int x, int y, int z) {\n\t\ta[x].push_back((edge) {y, z});\n\t}\n\tvoid init(int x) {\n\t\tn = x; st.clear();\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdist[i] = INF;\n\t\t\ta[i].clear();\n\t\t}\n\t}\n\tvoid work(int s) {\n\t\tdist[s] = 0;\n\t\tst.insert(make_pair(0, s));\n\t\twhile (!st.empty()) {\n\t\t\tpair <ll, int> tmp = *st.begin();\n\t\t\tst.erase(tmp);\n\t\t\tfor (unsigned i = 0; i < a[tmp.second].size(); i++) {\n\t\t\t\tint dest = a[tmp.second][i].dest;\n\t\t\t\tll newlen = tmp.first + a[tmp.second][i].len;\n\t\t\t\tif (newlen < dist[dest]) {\n\t\t\t\t\tst.erase(make_pair(dist[dest], dest));\n\t\t\t\t\tdist[dest] = newlen;\n\t\t\t\t\tst.insert(make_pair(dist[dest], dest));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint n, m, q;\nchar h[MAXN], v[MAXN];\nint hpre[MAXN][2], hsuf[MAXN][2];\nint vpre[MAXN][2], vsuf[MAXN][2];\nint nx, ny; vector <int> x, y;\nbool sx[MAXN], sy[MAXN];\nvoid addx(int pos) {\n\tif (!sx[pos]) {\n\t\tsx[pos] = true;\n\t\tx.push_back(pos);\n\t}\n}\nvoid addy(int pos) {\n\tif (!sy[pos]) {\n\t\tsy[pos] = true;\n\t\ty.push_back(pos);\n\t}\n}\nint path(pair <int, int> s, pair <int, int> t) {\n\tnx = x.size(), ny = y.size();\n\tstatic int point[16][16];\n\tint tot = 0;\n\tfor (int i = 0; i < nx; i++)\n\tfor (int j = 0; j < ny; j++)\n\t\tpoint[i][j] = ++tot;\n\tShortestPath :: init(tot);\n\tfor (int i = 0; i < nx; i++)\n\tfor (int j = 0; j < ny; j++) {\n\t\tif (h[x[i]] == 'E' && j < ny - 1) ShortestPath :: addedge(point[i][j], point[i][j + 1], y[j + 1] - y[j]);\n\t\tif (h[x[i]] == 'W' && j > 0) ShortestPath :: addedge(point[i][j], point[i][j - 1], y[j] - y[j - 1]);\n\t\tif (v[y[j]] == 'S' && i < nx - 1) ShortestPath :: addedge(point[i][j], point[i + 1][j], x[i + 1] - x[i]);\n\t\tif (v[y[j]] == 'N' && i > 0) ShortestPath :: addedge(point[i][j], point[i - 1][j], x[i] - x[i - 1]);\n\t}\n\tfor (int i = 0; i < nx; i++)\n\tfor (int j = 0; j < ny; j++)\n\t\tif (x[i] == s.first && y[j] == s.second) ShortestPath :: work(point[i][j]);\n\tfor (int i = 0; i < nx; i++)\n\tfor (int j = 0; j < ny; j++)\n\t\tif (x[i] == t.first && y[j] == t.second) {\n\t\t\tll tmp = ShortestPath :: dist[point[i][j]];\n\t\t\tif (tmp > 1e8) return -1;\n\t\t\telse return tmp;\n\t\t}\n\tassert(false);\n\treturn -1;\n}\nint main() {\n\tread(n), read(m), read(q);\n\tscanf(\"\\n%s\\n%s\", h + 1, v + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\thpre[i][0] = hpre[i - 1][0];\n\t\thpre[i][1] = hpre[i - 1][1];\n\t\tif (h[i] == 'E') hpre[i][1] = i;\n\t\telse hpre[i][0] = i;\n\t}\n\tfor (int i = n; i >= 1; i--) {\n\t\thsuf[i][0] = hsuf[i + 1][0];\n\t\thsuf[i][1] = hsuf[i + 1][1];\n\t\tif (h[i] == 'E') hsuf[i][1] = i;\n\t\telse hsuf[i][0] = i;\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tvpre[i][0] = vpre[i - 1][0];\n\t\tvpre[i][1] = vpre[i - 1][1];\n\t\tif (v[i] == 'S') vpre[i][1] = i;\n\t\telse vpre[i][0] = i;\n\t}\n\tfor (int i = m; i >= 1; i--) {\n\t\tvsuf[i][0] = vsuf[i + 1][0];\n\t\tvsuf[i][1] = vsuf[i + 1][1];\n\t\tif (v[i] == 'S') vsuf[i][1] = i;\n\t\telse vsuf[i][0] = i;\n\t}\n\tsx[0] = sy[0] = true;\n\tfor (int i = 1; i <= q; i++) {\n\t\tpair <int, int> s, t;\n\t\tread(s.first), read(s.second);\n\t\tread(t.first), read(t.second);\n\t\t\taddy(vsuf[s.second][0]);\n\t\t\taddy(vsuf[s.second][1]);\n\t\t\taddy(vpre[s.second][0]);\n\t\t\taddy(vpre[s.second][1]);\n\t\t\taddy(vpre[t.second][0]);\n\t\t\taddy(vpre[t.second][1]);\n\t\t\taddy(vsuf[t.second][0]);\n\t\t\taddy(vsuf[t.second][1]);\n\t\t\taddx(hsuf[s.first][0]);\n\t\t\taddx(hsuf[s.first][1]);\n\t\t\taddx(hpre[s.first][0]);\n\t\t\taddx(hpre[s.first][1]);\n\t\t\taddx(hpre[t.first][0]);\n\t\t\taddx(hpre[t.first][1]);\n\t\t\taddx(hsuf[t.first][0]);\n\t\t\taddx(hsuf[t.first][1]);\n\t\tsort(x.begin(), x.end());\n\t\tsort(y.begin(), y.end());\n\t\twriteln(path(s, t));\n\t\tfor (auto pos : x)\n\t\t\tsx[pos] = false;\n\t\tfor (auto pos : y)\n\t\t\tsy[pos] = false;\n\t\tx.clear(), y.clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <cstdlib>\n#define llint long long\n#define inf 100000000000000000\n\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(){}\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint H, W, Q;\nstring s, t;\nllint prel[200005], prer[200005], nextl[200005], nextr[200005];\nllint preu[200005], pred[200005], nextu[200005], nextd[200005];\nvector<llint> vecx, vecy;\nvector<edge> G[205];\nllint dist[205];\nllint S, T, V;\n\nvoid dijkstra()\n{\n\tfor(llint i = 0; i < V; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > PQ;\n\tPQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(PQ.size()){\n\t\td = PQ.top().first;\n\t\tv = PQ.top().second;\n\t\tPQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(llint i = 0; i < G[v].size(); i++){\n\t\t\tif(dist[G[v][i].to] > d + G[v][i].cost){\n\t\t\t\tdist[G[v][i].to] = d + G[v][i].cost;\n\t\t\t\tPQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make(llint s, llint g, vector<llint> &vec, llint N, llint preu[], llint pred[], llint nextu[], llint nextd[])\n{\n\tvec.clear();\n\tvec.push_back(s);\n\tvec.push_back(preu[s]);\n\tvec.push_back(pred[s]);\n\tvec.push_back(nextu[s]);\n\tvec.push_back(nextd[s]);\n\tvec.push_back(g);\n\tvec.push_back(preu[g]);\n\tvec.push_back(pred[g]);\n\tvec.push_back(nextu[g]);\n\tvec.push_back(nextd[g]);\n\t\n\tsort(vec.begin(), vec.end());\n\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\tif(vec.front() == 0) vec.erase(vec.begin());\n\tif(vec.back() == N+1) vec.erase(vec.end()-1);\n}\n\nint main(void)\n{\n\tcin >> H >> W >> Q;\n\tcin >> s >> t;\n\ts = \"#\" + s + \"#\", t = \"#\" + t + \"#\";\n\t\n\tprel[0] = 0, prer[0] = 0;\n\tfor(llint i = 1; i <= H; i++){\n\t\tprel[i] = prel[i-1];\n\t\tprer[i] = prer[i-1];\n\t\tif(s[i-1] == 'W') prel[i] = i-1;\n\t\tif(s[i-1] == 'E') prer[i] = i-1;\n\t}\n\tnextl[H+1] = H+1, nextr[H+1] = H+1;\n\tfor(llint i = H; i >= 1; i--){\n\t\tnextl[i] = nextl[i+1];\n\t\tnextr[i] = nextr[i+1];\n\t\tif(s[i+1] == 'W') nextl[i] = i+1;\n\t\tif(s[i+1] == 'E') nextr[i] = i+1;\n\t}\n\t\n\tpreu[0] = 0, pred[0] = 0;\n\tfor(llint i = 1; i <= W; i++){\n\t\tpreu[i] = preu[i-1];\n\t\tpred[i] = pred[i-1];\n\t\tif(t[i-1] == 'N') preu[i] = i-1;\n\t\tif(t[i-1] == 'S') pred[i] = i-1;\n\t}\n\tnextl[W+1] = W+1, nextr[W+1] = W+1;\n\tfor(llint i = W; i >= 1; i--){\n\t\tnextu[i] = nextu[i+1];\n\t\tnextd[i] = nextd[i+1];\n\t\tif(t[i+1] == 'N') nextu[i] = i+1;\n\t\tif(t[i+1] == 'S') nextd[i] = i+1;\n\t}\n\t\n\tllint sx, sy, gx, gy;\n\tfor(llint q = 0; q < Q; q++){\n\t\tcin >> sy >> sx >> gy >> gx;\n\t\tmake(sx, gx, vecx, W, preu, pred, nextu, nextd);\n\t\tmake(sy, gy, vecy, H, prel, prer, nextl, nextr);\n\t\t\n\t\tllint w = vecx.size(), h = vecy.size();\n\t\tfor(llint i = 0; i < w*h; i++) G[i].clear();\n\t\tfor(llint x = 0; x < w; x++){\n\t\t\tfor(llint y = 0; y < h; y++){\n\t\t\t\tllint nx = x, ny = y;\n\t\t\t\tif(t[vecx[x]] == 'N') ny--;\n\t\t\t\telse ny++;\n\t\t\t\tif(ny >= 0 && ny < h){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecy[y]-vecy[ny])));\n\t\t\t\t}\n\t\t\t\tnx = x, ny = y;\n\t\t\t\tif(s[vecy[y]] == 'W') nx--;\n\t\t\t\telse nx++;\n\t\t\t\tif(nx >= 0 && nx < w){\n\t\t\t\t\tG[x+y*w].push_back(edge(nx+ny*w, abs(vecx[x]-vecx[nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tllint SX, GX, SY, GY;\n\t\tfor(llint i = 0; i < w; i++){\n\t\t\tif(vecx[i] == sx) SX = i;\n\t\t\tif(vecx[i] == gx) GX = i;\n\t\t}\n\t\tfor(llint i = 0; i < h; i++){\n\t\t\tif(vecy[i] == sy) SY = i;\n\t\t\tif(vecy[i] == gy) GY = i;\n\t\t}\n\t\tS = SX + SY*w, T = GX + GY*w, V = w*h;\n\t\t\n\t\tdijkstra();\n\t\tif(dist[T] >= inf) cout << -1 << \"\\n\";\n\t\telse cout << dist[T] << \"\\n\";\n\t}\n\tflush(cout);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nint n,m,q,cntr,cntc;\nchar rs[maxn],cs[maxn];\nint r[maxn],c[maxn],curr[maxn],curc[maxn];\nint rnxt[maxn][2],rprv[maxn][2],cnxt[maxn][2],cprv[maxn][2];\nint dist[maxn];\npriority_queue<pii>pq;\nvector<pii>edge[maxn];\n//0: from left to right & from up to down\n//1: from right to left & from down to up\n\nint getid(int x,int y){\n\treturn x*cntc+y;\n}\n\nint calc(int s,int t,int n){\n\trep(i,n)dist[i]=INF;\n\tdist[s]=0;\n\tpq.push(mp(0,s));\n\twhile(!pq.empty()){\n\t\tpii x=pq.top();\n\t\tpq.pop();\n\t\tx.fst=-x.fst;\n\t\tif(dist[x.snd]!=x.fst)continue;\n\t\trep(i,edge[x.snd].size()){\n\t\t\tpii y=edge[x.snd][i];\n\t\t\tif(dist[y.fst]>dist[x.snd]+y.snd){\n\t\t\t\tdist[y.fst]=dist[x.snd]+y.snd;\n\t\t\t\tpq.push(mp(-dist[y.fst],y.fst));\n\t\t\t} \n\t\t}\n\t}\n\tif(dist[t]==INF)return -1;\n\treturn dist[t];\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d%d%s%s\",&n,&m,&q,rs,cs);\n\trep(i,n){\n\t\tr[i]=rs[i]=='W';\n\t\trep(j,2){\n\t\t\trprv[i][j]=(!i?-1:rprv[i-1][j]);\n\t\t\tif(j==r[i])rprv[i][j]=i;\n\t\t} \n\t}\n\tfor(int i=n-1;i>=0;i--){\n\t\trep(j,2){\n\t\t\trnxt[i][j]=(i==n-1?n:rnxt[i+1][j]);\n\t\t\tif(j==r[i])rnxt[i][j]=i;\n\t\t}\n\t}\n\trep(i,m){\n\t\tc[i]=cs[i]=='N';\n\t\trep(j,2){\n\t\t\tcprv[i][j]=(!i?-1:cprv[i-1][j]);\n\t\t\tif(j==c[i])cprv[i][j]=i;\n\t\t}\n\t}\n\tfor(int i=m-1;i>=0;i--){\n\t\trep(j,2){\n\t\t\tcnxt[i][j]=(i==m-1?m:cnxt[i+1][j]);\n\t\t\tif(j==c[i])cnxt[i][j]=i;\n\t\t}\n\t}\n\twhile(q--){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta--;b--;c--;d--;\n\t\tcntr=0,cntc=0;\n\t\tint ida,idb,idc,idd;\n\t\tcurr[cntr++]=a;\n\t\tif(a&&rprv[a-1][1^r[a]]>=0)curr[cntr++]=rprv[a-1][1^r[a]];\n\t\tif(a<n-1&&rnxt[a+1][1^r[a]]<n)curr[cntr++]=rnxt[a+1][1^r[a]];\n\t\tcurr[cntr++]=c;\n\t\tif(c&&rprv[c-1][1^r[c]]>=0)curr[cntr++]=rprv[c-1][1^r[c]];\n\t\tif(c<n-1&&rnxt[c+1][1^r[c]]<n)curr[cntr++]=rnxt[c+1][1^r[c]];\n\t\tcurc[cntc++]=b;\n\t\tif(b&&cprv[b-1][1^::c[b]]>=0)curc[cntc++]=cprv[b-1][1^::c[b]];\n\t\tif(b<m-1&&cnxt[b+1][1^::c[b]]<m)curc[cntc++]=cnxt[b+1][1^::c[b]];\n\t\tcurc[cntc++]=d;\n\t\tif(d&&cprv[d-1][1^::c[d]]>=0)curc[cntc++]=cprv[d-1][1^::c[d]];\n\t\tif(d<m-1&&cnxt[d+1][1^::c[d]]<m)curc[cntc++]=cnxt[d+1][1^::c[d]];\n\t\tsort(curr,curr+cntr);\n\t\tsort(curc,curc+cntc);\n\t\trep(i,cntr){\n\t\t\tif(i>0&&curr[i]==curr[i-1]){\n\t\t\t\tfor(int j=i+1;j<cntr;j++)curr[j-1]=curr[j];\n\t\t\t\tcntr--;\n\t\t\t}\n\t\t}\n\t\trep(i,cntr){\n\t\t\tif(curr[i]==a)ida=i;\n\t\t\tif(curr[i]==c)idc=i;\n\t\t}\n\t\trep(i,cntc){\n\t\t\tif(i>0&&curc[i]==curc[i-1]){\n\t\t\t\tfor(int j=i+1;j<cntc;j++)curc[j-1]=curc[j];\n\t\t\t\tcntc--;\n\t\t\t}\n\t\t}\n\t\trep(i,cntc){\n\t\t\tif(curc[i]==b)idb=i;\n\t\t\tif(curc[i]==d)idd=i;\n\t\t}\n\t\trep(i,cntr)rep(j,cntc){\n\t\t\tif(!r[curr[i]]&&j<cntc-1)edge[getid(i,j)].pb(mp(getid(i,j+1),curc[j+1]-curc[j]));\n\t\t\tif(r[curr[i]]&&j>0)edge[getid(i,j)].pb(mp(getid(i,j-1),curc[j]-curc[j-1]));\n\t\t\tif(!::c[curc[j]]&&i<cntr-1)edge[getid(i,j)].pb(mp(getid(i+1,j),curr[i+1]-curr[i]));\n\t\t\tif(::c[curc[j]]&&i>0)edge[getid(i,j)].pb(mp(getid(i-1,j),curr[i]-curr[i-1]));\n\t\t}\n\t\tprintf(\"%d\\n\",calc(getid(ida,idb),getid(idc,idd),cntr*cntc));\n\t\trep(i,cntr*cntc)edge[i].clear();\n\t}\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\n\nint main(){\n\tlong N,M,Q;\n\tcin>>N>>M>>Q;\n\tlong ansarr[Q];\n\tstring S,T;\n\tcin>>S>>T;\n\tlong a[Q],b[Q],c[Q],d[Q];\n\tfor(long i=0;i<Q;++i)cin>>a[i]>>b[i]>>c[i]>>d[i];\n\tfor(long i=0;i<Q;++i){\n\t\tchar map[N][M];\n\t\tfor(long j=0;j<N;++j){\n\t\t\tfor(long k=0;k<M;++k){\n\t\t\t\tmap[j][k]='.';\n\t\t\t}\n\t\t}\n\t\tmap[a[i]-1][b[i]-1]='s';\n\t\tqueue<long>x;\n\t\tqueue<long>y;\n\t\tqueue<long>ans;\n\t\tx.push(b[i]);\n\t\ty.push(a[i]);\n\t\tans.push(0);\n\t\tlong pro=1;\n\t\twhile(true){\n\t\t\tif(map[y.front()][x.front()-1]=='.' && y.front()<N && T[x.front()-1]=='S'){\n\t\t\t\tx.push(x.front());\n\t\t\t\ty.push(y.front()+1);\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()+1==c[i] && x.front()==d[i]) break;\n\t\t\t\tmap[y.front()][x.front()-1]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-2][x.front()-1]=='.' && y.front()>1 && T[x.front()-1]=='N'){\n\t\t\t\tx.push(x.front());\n\t\t\t\ty.push(y.front()-1);\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()-1==c[i] && x.front()==d[i]) break;\n\t\t\t\tmap[y.front()-2][x.front()-1]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-1][x.front()]=='.' && x.front()<M && S[y.front()-1]=='E'){\n\t\t\t\tx.push(x.front()+1);\n\t\t\t\ty.push(y.front());\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()==c[i] && x.front()+1==d[i]) break;\n\t\t\t\tmap[y.front()-1][x.front()]='+';\n\t\t\t}\n\t\t\telse if(map[y.front()-1][x.front()-2]=='.' && x.front()>1 && S[y.front()-1]=='W'){\n\t\t\t\tx.push(x.front()-1);\n\t\t\t\ty.push(y.front());\n\t\t\t\tans.push(ans.front()+1);\n\t\t\t\tif(y.front()==c[i] && x.front()-1==d[i]) break;\n\t\t\t\tmap[y.front()-1][x.front()-2]='+';\n\t\t\t}\n\t\t\telse if(x.size()>1){\n\t\t\t\tx.pop();\n\t\t\t\ty.pop();\n\t\t\t\tans.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpro=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(pro==0)ansarr[i]=-1;\n\t\telse{\n\t\t\twhile(ans.size()>1)ans.pop();\n\t\t\tansarr[i]=ans.front();\n\t\t}\n\t}\n\tfor(long i=0;i<Q;++i)cout<<ansarr[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 100 * 1000 + 7;\nconst int INF = 1e9 + 7;\n\nbool rg[MX], up[MX];\nint n, m;\n\nvector<int> gl, gr, gu, gd;\n\nint d[107][107];\n\nint pl[MX], nl[MX], pr[MX], nr[MX], pu[MX], nu[MX], pd[MX], nd[MX];\n\nvoid fl(vector<int> x, int n, int *p, int *nx) {\n    p[0] = -1;\n    nx[n + 1] = n + 1;\n    for (int xx : x) {\n        p[xx] = xx;\n        nx[xx] = xx;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (p[i] != i) {\n            p[i] = p[i - 1];\n        }\n    }\n    for (int i = n; i >= 1; i--) {\n        if (nx[i] != i) {\n            nx[i] = nx[i + 1];\n        }\n    }\n}\n\nbool can_go(int x1, int y1, int x2, int y2) {\n    if (x1 == x2) {\n        if (y1 < y2) {\n            return rg[x1];\n        } else {\n            return !rg[x1];\n        }\n    } else if (y1 == y2) {\n        if (x2 < x1) {\n            return up[y1];\n        } else {\n            return !up[y1];\n        }\n    }\n    return false;\n}\n\nvector<pair<int, int> > trace(int x, int y, int depth, bool rev) {\n    vector<pair<int, int> > ans;\n    static queue<pair<int, int> > q;\n    static set<pair<int, int> > was;\n\n    was.clear();\n    while (!q.empty()) {\n        q.pop();\n    }\n    auto ad = [&](int x, int y) {\n        if (was.count(make_pair(x, y))) {\n            return;\n        }\n        was.emplace(x, y);\n        q.emplace(x, y);\n        if (ans.size() <= depth) {\n            ans.emplace_back(x, y);\n        }\n    };\n\n    ad(x, y);\n    while (!q.empty()) {\n        int x, y;\n        tie(x, y) = q.front();\n        if (ans.size() > depth) {\n            break;\n        }\n        q.pop();\n        if (rg[x] ^ rev) {\n            {\n                int yy = nu[y];\n                if (yy != m + 1) {\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = nd[y];\n                if (yy != m + 1) {\n                    ad(x, yy);\n                }\n            }\n        } else {\n            {\n                int yy = pd[y];\n                if (yy != -1) {\n                    ad(x, yy);\n                }\n            }\n            {\n                int yy = pu[y]; \n                if (yy != -1) {\n                    ad(x, yy);\n                }\n            }\n        }\n\n        if ((!up[y]) ^ rev) {\n            {\n                int xx = nl[x];\n                if (xx != n + 1) {\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = nr[x];\n                if (xx != n + 1) {\n                    ad(xx, y);\n                }\n            }\n        } else {\n            {\n                int xx = pl[x];\n                if (xx >= 0) {\n                    ad(xx, y);\n                }\n            }\n            {\n                int xx = pr[x];\n                if (xx >= 0) {\n                    ad(xx, y);\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint dist(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int q;\n    cin >> n >> m >> q;\n    string s;\n    cin >> s;\n    for (int i = 1; i <= n; i++) {\n        if (s[i - 1] == 'E') {\n            rg[i] = true;\n            gl.push_back(i);\n        } else {\n            gr.push_back(i);\n        }\n    }\n    cin >> s;\n    for (int i = 1; i <= m; i++) {\n        if (s[i - 1] == 'N') {\n            up[i] = true;\n            gu.push_back(i);\n        } else {\n            gd.push_back(i);\n        }\n    }\n\n    fl(gl, n, pl, nl);\n    fl(gr, n, pr, nr);\n    fl(gu, m, pu, nu);\n    fl(gd, m, pd, nd);\n\n    set<tuple<int, int, int> > go;\n    for (int i = 0; i < q; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        vector<pair<int, int> > t1 = trace(x1, y1, 5, false);\n        vector<pair<int, int> > t2 = trace(x2, y2, 5, true);\n        vector<int> xx, yy;\n        for (auto v : t1) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        for (auto v : t2) {\n            xx.push_back(v.first);\n            yy.push_back(v.second);\n        }\n        sort(xx.begin(), xx.end());\n        sort(yy.begin(), yy.end());\n        xx.resize(unique(xx.begin(), xx.end()) - xx.begin());\n        yy.resize(unique(yy.begin(), yy.end()) - yy.begin());\n        int n = xx.size(), m = yy.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                d[i][j] = INF;\n                if (xx[i] == x1 && yy[j] == y1) {\n                    d[i][j] = 0;\n                }\n                go.emplace(d[i][j], i, j);\n            }\n        }\n        /*\n        cerr << \"X: \";\n        for (int x : xx) {\n            cerr << x << \" \";\n        }\n        cerr << endl;\n        cerr << \"Y: \";\n        for (int y : yy) {\n            cerr << y << \" \";\n        }\n        cerr << endl;\n*/\n\n        while (!go.empty()) {\n            int D, x, y;\n            tie(D, x, y) = *go.begin();\n            go.erase(go.begin());\n          /*  for (int gy = max(0, y - 1); gy < min(y + 1, (int)yy.size()); gy++) {\n                if (can_go(xx[x], yy[y], xx[x], yy[gy]) && d[x][gy] > d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy])) {\n                    go.erase(make_tuple(d[x][gy], x, gy));\n                    d[x][gy] = d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy]);\n                    go.insert(make_tuple(d[x][gy], x, gy));\n                }\n            }\n            for (int gx = max(0, x - 1); gx < min(x + 1, (int)xx.size()); gx++) {\n                if (can_go(xx[x], yy[y], xx[gx], yy[y]) && d[gx][y] > d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y])) {\n                    go.erase(make_tuple(d[gx][y], gx, y));\n                    d[gx][y] = d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y]);\n                    go.insert(make_tuple(d[gx][y], gx, y));\n                }\n            } */\n            for (int gy = 0; gy < (int)yy.size(); gy++) {\n                if (can_go(xx[x], yy[y], xx[x], yy[gy]) && d[x][gy] > d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy])) {\n                    go.erase(make_tuple(d[x][gy], x, gy));\n                    d[x][gy] = d[x][y] + dist(xx[x], yy[y], xx[x], yy[gy]);\n                    go.insert(make_tuple(d[x][gy], x, gy));\n                }\n            }\n            for (int gx = 0; gx < (int)xx.size(); gx++) {\n                if (can_go(xx[x], yy[y], xx[gx], yy[y]) && d[gx][y] > d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y])) {\n                    go.erase(make_tuple(d[gx][y], gx, y));\n                    d[gx][y] = d[x][y] + dist(xx[x], yy[y], xx[gx], yy[y]);\n                    go.insert(make_tuple(d[gx][y], gx, y));\n                }\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (xx[i] == x2 && yy[j] == y2) {\n                    ans = d[i][j];\n                }\n            }\n        }\n\n        if (ans == INF) {\n            ans = -1;\n        }\n        cout << ans << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define fi first\n#define se second\n#define all(v) v.begin(), v.end()\n#define sz(v) int(v.size())\n\nusing namespace std;\nusing ll = int64_t;\n\nint N, M, Q;\nstring S, T;\nmap<int, vector<int>> xPositions;\nmap<int, vector<int>> yPositions;\nvector<int> interestingX;\nvector<int> interestingY;\nqueue<pair<int,int>> q;\n\nint distances[10][10];\n\nvoid build() {\n  for (int i = 0; i < N; i++)\n    xPositions[S[i] == 'E' ? 1 : -1].pb(i);\n  for (int i = 0; i < M; i++)\n    yPositions[T[i] == 'S' ? 1 : -1].pb(i);\n}\n\nint Next(const vector<int>& v, int x) {\n  auto it = lower_bound(all(v), x);\n  if (it == v.end())\n    return -1;\n  return *it;\n}\n\nint Prev(const vector<int>& v, int x) {\n  auto it = upper_bound(all(v), x);\n  if (it == v.begin())\n    return -1;\n  --it;\n  return *it;\n}\n\nvoid filter(vector<int>& v) {\n  sort(all(v));\n  v.erase(unique(all(v)), v.end());\n  while (!v.empty() && v.front() == -1)\n    v.erase(v.begin());\n}\n\nint ans(int x0, int y0, int x1, int y1) {\n  interestingX.clear();\n  interestingY.clear();\n  \n  interestingX.pb(x0);\n  interestingX.pb(x1);\n  interestingY.pb(y0);\n  interestingY.pb(y1);\n  for (int d = -1; d <= 1; d++) {\n    interestingX.pb(Next(xPositions[d], x0));\n    interestingX.pb(Prev(xPositions[d], x0));\n    interestingX.pb(Next(xPositions[d], x1));\n    interestingX.pb(Prev(xPositions[d], x1));\n\n    interestingY.pb(Next(yPositions[d], y0));\n    interestingY.pb(Prev(yPositions[d], y0));\n    interestingY.pb(Next(yPositions[d], y1));\n    interestingY.pb(Prev(yPositions[d], y1));\n  }\n\n  filter(interestingX);\n  filter(interestingY);\n\n  auto getX = [&](int x) {\n    return lower_bound(all(interestingX), x) - interestingX.begin();\n  };\n\n  auto getY = [&](int y) {\n    return lower_bound(all(interestingY), y) - interestingY.begin();\n  };\n\n  memset(distances, -1, sizeof(distances));\n  x0 = getX(x0);\n  y0 = getY(y0);\n  distances[x0][y0] = 0;\n  q.push({x0, y0});\n\n  while (!q.empty()) {\n    auto p = q.front();\n    q.pop();\n    int d = distances[p.fi][p.se];\n    // cerr << \"debug: \" << p.fi << \" \" << p.se << \" \" << d << endl;\n\n    // go x\n    for (int nx = 0; nx < sz(interestingX); nx++) {\n      if (T[interestingY[p.se]] == 'S' && nx < p.fi)\n        continue;\n      if (T[interestingY[p.se]] == 'N' && nx > p.fi)\n        continue;\n      int nd = d + abs(interestingX[nx] - interestingX[p.fi]);\n      if (distances[nx][p.se] == -1 || distances[nx][p.se] > nd) {\n        distances[nx][p.se] = nd;\n        q.push({nx, p.se});\n      }\n    }\n\n    // go y\n    for (int ny = 0; ny < sz(interestingY); ny++) {\n      if (S[interestingX[p.fi]] == 'E' && ny < p.se)\n        continue;\n      if (S[interestingX[p.fi]] == 'W' && ny > p.se)\n        continue;\n      int nd = d + abs(interestingY[ny] - interestingY[p.se]);\n      if (distances[p.fi][ny] == -1 || distances[p.fi][ny] > nd) {\n        distances[p.fi][ny] = nd;\n        q.push({p.fi, ny});\n      }\n    }\n  }\n\n  return distances[getX(x1)][getY(y1)];\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> N >> M >> Q;\n  cin >> S >> T;\n\n  build();\n\n  for (int i = 0; i < Q; i++) {\n    int x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n    --x0, --y0, --x1, --y1;\n    cout << ans(x0, y0, x1, y1) << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\nconst long long int exa = 1000000000000000000;\n//const int MOD = 1000000007;\n//const int MOD = 998244353;\n\nlong long int N, M, K, H, W, L, R;\n//int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, turn,dis;\n\tNode(int a, int b, int c = 0, int d = 0) {\n\t\ty = a, x = b;\n\t\tturn = c;\n\t\tdis = d;\n\t}\n};\n\nint border = 6;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> H >> W >> K;\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int>ldif(W, -1);\n\tvector<int>rdif(W, -1);\n\tfor (int i = 1; i < W; i++) {\n\t\tif (t[i] == t[i - 1])ldif[i] = ldif[i - 1];\n\t\telse ldif[i] = i - 1;\n\t}\n\tfor (int i = W - 2; i >= 0; i--) {\n\t\tif (t[i] == t[i + 1])rdif[i] = rdif[i + 1];\n\t\telse rdif[i] = i + 1;\n\t}\n\tvector<int>udif(H, -1);\n\tvector<int>ddif(H, -1);\n\tfor (int i = 1; i < H; i++) {\n\t\tif (s[i] == s[i - 1])udif[i] = udif[i - 1];\n\t\telse udif[i] = i - 1;\n\t}\n\tfor (int i = H - 2; i >= 0; i--) {\n\t\tif (s[i] == s[i + 1])ddif[i] = ddif[i + 1];\n\t\telse ddif[i] = i + 1;\n\t}\n\tvector<int>ret;\n\tfor (int i = 0; i < K; i++) {\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\ta--, b--, c--, d--;\n\t\tqueue<Node>Q;\n\t\tQ.push(Node(a, b));\n\t\tunordered_map<long long int, int>m;\n\t\tm[(a*H + b)*W + 0] = 0;\n\t\tint ans = MOD;\n\t\twhile (!Q.empty()) {\n\t\t\tauto cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tif (cn.y == c && cn.x == d)ans = min(ans, cn.dis);\n\t\t\tauto it = m.find((cn.y*H + cn.x)*W + cn.turn);\n\t\t\tif (it != m.end()) {\n\t\t\t\tif (it->second < cn.dis)continue;\n\t\t\t}\n\t\t//\tcout << cn.y << \" \" << cn.x << endl;\n\t\t\tif (cn.turn == border)break;\n\t\t\tif (t[cn.x] == 'N') {//(-,0)\n\t\t\t\tif (c <= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tQ.push(Node(c, cn.x, cn.turn + 1, cn.dis + cn.y - c));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (udif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push({ Node(udif[cn.y],cn.x,cn.turn + 1,cn.dis + cn.y - udif[cn.y]) });\n\t\t\t\t\t}\n\t\t\t\t\tif (udif[c] != -1) {\n\t\t\t\t\t\tQ.push(Node(udif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - udif[c])));\n\t\t\t\t\t}\n\t\t\t\t\t//if (ddif[c] != -1) {\n\t\t\t\t\t//\tQ.push(Node(ddif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y + udif[c])));\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c >= cn.y && ((s[c] == 'W'&&cn.x >= d) || (s[c] == 'E'&&cn.x <= d))) {\n\t\t\t\t\tQ.push(Node(c, cn.x, cn.turn + 1, cn.dis + c - cn.y));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ddif[cn.y] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[cn.y], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[cn.y])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ddif[c] != -1) {\n\t\t\t\t\t\tQ.push(Node(ddif[c], cn.x, cn.turn + 1, cn.dis + abs(cn.y - ddif[c])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s[cn.y] == 'W') {\n\t\t\t\tif (d <= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tQ.push(Node(cn.y, d, cn.turn + 1, cn.dis + abs(d - cn.x)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ldif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - ldif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (ldif[d] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, ldif[d], cn.turn + 1, cn.dis + abs(cn.x - ldif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (d >= cn.x && ((t[d] == 'N'&&cn.y >= c) || (t[d] == 'S'&&cn.y <= c))) {\n\t\t\t\t\tQ.push(Node(cn.y, d, cn.turn + 1, cn.dis + abs(d - cn.x)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (rdif[cn.x] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[cn.x], cn.turn + 1, cn.dis + abs(cn.x - rdif[cn.x])));\n\t\t\t\t\t}\n\t\t\t\t\tif (rdif[d] != -1) {\n\t\t\t\t\t\tQ.push(Node(cn.y, rdif[d], cn.turn + 1, cn.dis + abs(cn.x - rdif[d])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == MOD)ans = -1;\n\t\tret.push_back(ans);\n\t}\n\tfor (auto i : ret)cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int N=1e5+5;\nint n,m,q,tot,id[7][7],dis[50][50];\nvector<int>north,south,east,west;\nchar s1[N],s2[N];\nunordered_map<int,int>vis1,vis2;\nvector<int>v1,v2;\nvoid solve2(int a,int b)\n{\n    int pos;\n    if(s2[b]=='N')\n    {\n        pos=lower_bound(south.begin(),south.end(),b)-south.begin();\n        if(pos<south.size()&&!vis2[south[pos]])\n        {\n            v2.push_back(south[pos]);\n            vis2[south[pos]]=true;\n        }\n    }\n    else\n    {\n        pos=lower_bound(north.begin(),north.end(),b)-north.begin();\n        if(pos<north.size()&&!vis2[north[pos]])\n        {\n            v2.push_back(north[pos]);\n            vis2[north[pos]]=true;\n        }\n    }\n    if(s2[b]=='N')\n    {\n        pos=lower_bound(south.begin(),south.end(),b)-south.begin()-1;\n        if(pos<south.size()&&!vis2[south[pos]])\n        {\n            v2.push_back(south[pos]);\n            vis2[south[pos]]=true;\n        }\n    }\n    else\n    {\n        pos=lower_bound(north.begin(),north.end(),b)-north.begin()-1;\n        if(pos<north.size()&&!vis2[north[pos]])\n        {\n            v2.push_back(north[pos]);\n            vis2[north[pos]]=true;\n        }\n    }\n}\nvoid solve1(int a,int b)\n{\n    int pos;\n    if(s1[a]=='W')\n    {\n        pos=lower_bound(east.begin(),east.end(),a)-east.begin();\n        if(pos<east.size()&&!vis1[east[pos]])\n        {\n            v1.push_back(east[pos]);\n            vis1[east[pos]]=true;\n        }\n    }\n    else\n    {\n        pos=lower_bound(west.begin(),west.end(),a)-west.begin();\n        if(pos<west.size()&&!vis1[west[pos]])\n        {\n            v1.push_back(west[pos]);\n            vis1[west[pos]]=true;\n        }\n    }\n    if(s1[a]=='W')\n    {\n        pos=lower_bound(east.begin(),east.end(),a)-east.begin()-1;\n        if(pos>=0&&!vis1[east[pos]])\n        {\n            v1.push_back(east[pos]);\n            vis1[east[pos]]=true;\n        }\n    }\n    else\n    {\n        pos=lower_bound(west.begin(),west.end(),a)-west.begin()-1;\n        if(pos>=0&&!vis1[west[pos]])\n        {\n            v1.push_back(west[pos]);\n            vis1[west[pos]]=true;\n        }\n    }\n}\nstruct node\n{\n    int u,x;\n    node(int u=0,int x=0):u(u),x(x){}\n    bool operator<(const node&o)const\n    {\n        return x>o.x;\n    }\n};\nint d[50*50];\nbool vis[50*50];\nint dijkstra(int s,int t)\n{\n    memset(d,inf,sizeof(d));\n    memset(vis,false,sizeof(vis));\n    priority_queue<node>q;\n    d[s]=0;\n    q.push(node(s,0));\n    while(!q.empty())\n    {\n        int u=q.top().u;q.pop();\n        if(vis[u]) continue;\n        if(u==t) return d[t];\n        vis[u]=true;\n        for(int i=1;i<=tot;i++)\n            if(d[i]>d[u]+dis[u][i])\n        {\n            d[i]=d[u]+dis[u][i];\n            q.push(node(i,d[i]));\n        }\n    }\n    return d[t];\n}\nvoid ts(int x)\n{\n    //cout<<\"test \"<<x<<endl;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&q);\n    scanf(\"%s\",s1+1);\n    for(int i=1;i<=n;i++)\n        if(s1[i]=='E')\n        east.push_back(i);\n    else west.push_back(i);\n    scanf(\"%s\",s2+1);\n    for(int i=1;i<=m;i++)\n        if(s2[i]=='N') north.push_back(i);\n    else south.push_back(i);\n    while(q--)\n    {\n        int a,b,c,d;\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        vis1.clear();vis2.clear();\n        v1.clear();v2.clear();\n        v1.push_back(a);v2.push_back(b);\n        vis1[a]=vis2[b]=true;\n        if(!vis1[c]) v1.push_back(c),vis1[c]=true;\n        if(!vis2[d]) v2.push_back(d),vis2[d]=true;\n        solve1(a,b);solve1(c,d);\n        solve2(a,b);solve2(c,d);\n        sort(v1.begin(),v1.end());\n        sort(v2.begin(),v2.end());\n        memset(dis,inf,sizeof(dis));\n        memset(id,0,sizeof(id));\n        tot=0;\n        int s,t;\n        for(int i=0;i<v1.size();i++)\n            for(int j=0;j<v2.size();j++)\n        {\n            //cout<<tot+1<<' '<<v1[i]<<' '<<v2[j]<<endl;\n            id[i][j]=++tot;\n            if(v1[i]==a&&v2[j]==b) s=tot;\n            if(v1[i]==c&&v2[j]==d) t=tot;\n            if(j>0)\n            {\n                if(s1[v1[i]]=='W')\n                    dis[id[i][j]][id[i][j-1]]=v2[j]-v2[j-1];\n                else dis[id[i][j-1]][id[i][j]]=v2[j]-v2[j-1];\n            }\n            if(i>0)\n            {\n                if(s2[v2[j]]=='N')\n                    dis[id[i][j]][id[i-1][j]]=v1[i]-v1[i-1];\n                else dis[id[i-1][j]][id[i][j]]=v1[i]-v1[i-1];\n            }\n        }\n        //cout<<tot<<endl;\n        for(int i=1;i<=tot;i++) dis[i][i]=0;\n        //cout<<s<<' '<<t<<endl;\n        //for(int i=1;i<=tot;i++)\n       //     for(int j=1;j<=tot;j++)\n        //        printf(j==tot?\"%d\\n\":\"%d\\t\",dis[i][j]==inf?-1:dis[i][j]);\n        int dis=dijkstra(s,t);\n        if(dis==inf) printf(\"-1\\n\");\n        else printf(\"%d\\n\",dis);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf (int)(1e9)\n\nstruct edge{\n\tint to;\n\tint cost;\n\n\tedge(int to, int cost) : to(to), cost(cost){}\n};\n\nvector<int> dijkstra(vector<vector<edge> > &g, int s){\n\tvector<int> ans(g.size(), inf);\n\tpriority_queue<pair<int, int> > q;//(距離, 頂点番号)\n\tq.push(pair<int, int>(0, s));\n\twhile(q.size() > 0){\n\t\tint dis = q.top().first, v = q.top().second;\n\t\tq.pop();\n\t\tif(dis < ans[v]){\n\t\t\tans[v] = dis;\n\t\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\t\tq.push(pair<int, int>(dis + g[v][i].cost, g[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint align(int x, int y){\n\treturn 5 * x + y;\n}\n\nint main(){\n\tint N, M, Q, i, j;\n\tscanf(\"%d%d%d\", &N, &M, &Q);\n\tvector<char> S(N + 2);\n\tvector<int> nextW(N + 2), nextE(N + 2), prevW(N + 2), prevE(N + 2);\n\tscanf(\"%s\", &S[1]);\n\tnextW[N + 1] = N + 1;\n\tnextE[N + 1] = N + 1;\n\tfor(i = N; i > 0; i--){\n\t\tif(S[i] == 'W'){\n\t\t\tnextW[i] = i;\n\t\t\tnextE[i] = nextE[i + 1];\n\t\t}\n\t\telse{\n\t\t\tnextW[i] = nextW[i + 1];\n\t\t\tnextE[i] = i;\n\t\t}\n\t}\n\tprevW[0] = 0;\n\tprevE[0] = 0;\n\tfor(i = 1; i <= N; i++){\n\t\tif(S[i] == 'W'){\n\t\t\tprevW[i] = i;\n\t\t\tprevE[i] = prevE[i - 1];\n\t\t}\n\t\telse{\n\t\t\tprevW[i] = prevW[i - 1];\n\t\t\tprevE[i] = i;\n\t\t}\n\t}\n\n\tvector<char> T(M + 2);\n\tvector<int> nextN(M + 2), nextS(M + 2), prevN(M + 2), prevS(M + 2);\n\tscanf(\"%s\", &T[1]);\n\tnextN[M + 1] = M + 1;\n\tnextS[M + 1] = M + 1;\n\tfor(i = M; i > 0; i--){\n\t\tif(T[i] == 'N'){\n\t\t\tnextN[i] = i;\n\t\t\tnextS[i] = nextS[i + 1];\n\t\t}\n\t\telse{\n\t\t\tnextN[i] = nextN[i + 1];\n\t\t\tnextS[i] = i;\n\t\t}\n\t}\n\tprevN[0] = 0;\n\tprevS[0] = 0;\n\tfor(i = 1; i <= M; i++){\n\t\tif(T[i] == 'N'){\n\t\t\tprevN[i] = i;\n\t\t\tprevS[i] = prevS[i - 1];\n\t\t}\n\t\telse{\n\t\t\tprevN[i] = prevN[i - 1];\n\t\t\tprevS[i] = i;\n\t\t}\n\t}\n\tfor(int q = 0; q < Q; q++){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tint x[5], y[5];\n\t\tx[1] = min(a, c);\n\t\tx[3] = max(a, c);\n\t\ty[1] = min(b, d);\n\t\ty[3] = max(b, d);\n\n\t\tif(S[x[1]] == 'W'){\n\t\t\tx[0] = prevE[x[1] - 1];\n\t\t\tx[2] = min(x[3], nextE[x[1] + 1]);\n\t\t}\n\t\telse{\n\t\t\tx[0] = prevW[x[1] - 1];\n\t\t\tx[2] = min(x[3], nextW[x[1] + 1]);\n\t\t}\n\t\tif(x[0] == 0){\n\t\t\tx[0] = x[1];\n\t\t}\n\t\tif(S[x[3]] == 'W'){\n\t\t\tx[4] = nextE[x[3] + 1];\n\t\t}\n\t\telse{\n\t\t\tx[4] = nextW[x[3] + 1];\n\t\t}\n\t\tif(x[4] == N + 1){\n\t\t\tx[4] = x[3];\n\t\t}\n\n\t\tif(T[y[1]] == 'N'){\n\t\t\ty[0] = prevS[y[1] - 1];\n\t\t\ty[2] = min(y[3], nextS[y[1] + 1]);\n\t\t}\n\t\telse{\n\t\t\ty[0] = prevN[y[1] - 1];\n\t\t\ty[2] = min(y[3], nextN[y[1] + 1]);\n\t\t}\n\t\tif(y[0] == 0){\n\t\t\ty[0] = y[1];\n\t\t}\n\t\tif(T[y[3]] == 'N'){\n\t\t\ty[4] = nextS[y[3] + 1];\n\t\t}\n\t\telse{\n\t\t\ty[4] = nextN[y[3] + 1];\n\t\t}\n\t\tif(y[4] == M + 1){\n\t\t\ty[4] = y[3];\n\t\t}\n\n/*\t\tprintf(\"x:\");\n\t\tfor(i = 0; i < 5; i++){\n\t\t\tprintf(\"%d \", x[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"y:\");\n\t\tfor(i = 0; i < 5; i++){\n\t\t\tprintf(\"%d \", y[i]);\n\t\t}\n\t\tprintf(\"\\n\");\n*/\n\t\tvector<vector<edge> > g(25, vector<edge>());\n\t\tfor(i = 0; i < 5; i++){\n\t\t\tif(S[x[i]] == 'W'){\n\t\t\t\tfor(j = 1; j < 5; j++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i, j - 1), y[j] - y[j - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j = 0; j < 4; j++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i, j + 1), y[j + 1] - y[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(j = 0; j < 5; j++){\n\t\t\tif(T[y[j]] == 'N'){\n\t\t\t\tfor(i = 1; i < 5; i++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i - 1, j), x[i] - x[i - 1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i = 0; i < 4; i++){\n\t\t\t\t\tg[align(i, j)].push_back(edge(align(i + 1, j), x[i + 1] - x[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s, t;\n\t\tfor(i = 0; i < 25; i++){\n\t\t\tif(x[i / 5] == a && y[i % 5] == b){\n\t\t\t\ts = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < 25; i++){\n\t\t\tif(x[i / 5] == c && y[i % 5] == d){\n\t\t\t\tt = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n/*\t\tfor(i = 0; i < 25; i++){\n\t\t\tprintf(\"edge[%d]:\", i);\n\t\t\tfor(j = 0; j < g[i].size(); j++){\n\t\t\t\tprintf(\"(%d, %d) \", g[i][j].to, g[i][j].cost);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"(s, t) = (%d, %d)\\n\", s, t);\n*/\t\tvector<int> res = dijkstra(g, s);\n\t\tif(res[t] == inf){\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\", res[t]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n\nint n,m,q;\nchar s[125252];\nint rw[125252], re[125252], lw[125252], le[125252];\nchar t[125252];\nint rn[125252], rs[125252], ln[125252], ls[125252];\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tscanf(\"%s\",s);\n\tscanf(\"%s\",t);\n\n\trw[n-1] = s[n-1]=='W' ? n-1 : -1;\n\tre[n-1] = s[n-1]=='E' ? n-1 : -1;\n\tFORR(i,0,n-1){\n\t\trw[i] = s[i]=='W' ? i : rw[i+1];\n\t\tre[i] = s[i]=='E' ? i : re[i+1];\n\t}\n\tlw[0] = s[0]=='W' ? 0 : -1;\n\tle[0] = s[0]=='E' ? 0 : -1;\n\tFOR(i,1,n){\n\t\tlw[i] = s[i]=='W' ? i : lw[i-1];\n\t\tle[i] = s[i]=='E' ? i : le[i-1];\n\t}\n\n\trn[m-1] = t[m-1]=='N' ? m-1 : -1;\n\trs[m-1] = t[m-1]=='S' ? m-1 : -1;\n\tFORR(i,0,m-1){\n\t\trn[i] = t[i]=='N' ? i : rn[i+1];\n\t\trs[i] = t[i]=='S' ? i : rs[i+1];\n\t}\n\tln[0] = t[0]=='N' ? 0 : -1;\n\tls[0] = t[0]=='S' ? 0 : -1;\n\tFOR(i,1,m){\n\t\tln[i] = t[i]=='N' ? i : ln[i-1];\n\t\tls[i] = t[i]=='S' ? i : ls[i-1];\n\t}\n\n\twhile(q--){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t--a;--b;--c;--d;\n\t\tset<pii> ys,xs;\n\t\tys.insert(pii(a,s[a]));\n\t\tys.insert(pii(c,s[c]));\n\t\tif(s[a]=='W'){\n\t\t\tint y;\n\t\t\ty=le[a];if(y!=-1)ys.insert(pii(y,s[y]));\n\t\t\ty=re[a];if(y!=-1)ys.insert(pii(y,s[y]));\n\t\t}else{\n\t\t\tint y;\n\t\t\ty=lw[a];if(y!=-1)ys.insert(pii(y,s[y]));\n\t\t\ty=rw[a];if(y!=-1)ys.insert(pii(y,s[y]));\n\t\t}\n\t\tif(s[c]=='W'){\n\t\t\tint y;\n\t\t\ty=le[c];if(y!=-1)ys.insert(pii(y,s[y]));\n\t\t\ty=re[c];if(y!=-1)ys.insert(pii(y,s[y]));\n\t\t}else{\n\t\t\tint y;\n\t\t\ty=lw[c];if(y!=-1)ys.insert(pii(y,s[y]));\n\t\t\ty=rw[c];if(y!=-1)ys.insert(pii(y,s[y]));\n\t\t}\n\t\txs.insert(pii(b,t[b]));\n\t\txs.insert(pii(d,t[d]));\n\t\tif(t[b]=='N'){\n\t\t\tint x;\n\t\t\tx=ls[b];if(x!=-1)xs.insert(pii(x,t[x]));\n\t\t\tx=rs[b];if(x!=-1)xs.insert(pii(x,t[x]));\n\t\t}else{\n\t\t\tint x;\n\t\t\tx=ln[b];if(x!=-1)xs.insert(pii(x,t[x]));\n\t\t\tx=rn[b];if(x!=-1)xs.insert(pii(x,t[x]));\n\t\t}\n\t\tif(t[d]=='N'){\n\t\t\tint x;\n\t\t\tx=ls[d];if(x!=-1)xs.insert(pii(x,t[x]));\n\t\t\tx=rs[d];if(x!=-1)xs.insert(pii(x,t[x]));\n\t\t}else{\n\t\t\tint x;\n\t\t\tx=ln[d];if(x!=-1)xs.insert(pii(x,t[x]));\n\t\t\tx=rn[d];if(x!=-1)xs.insert(pii(x,t[x]));\n\t\t}\n\t\tvector<pii> xx, yy;\n\t\tfor(pii P : xs){\n\t\t\txx.push_back(P);\n\t\t}\n\t\tfor(pii P : ys){\n\t\t\tyy.push_back(P);\n\t\t}\n\t\tint sx,sy,gx,gy;\n\t\tint X = xx.size();\n\t\tint Y = yy.size();\n\t\tREP(i,Y)REP(j,X){\n\t\t\tif(yy[i].first==a && xx[j].first==b){\n\t\t\t\tsy=i; sx=j;\n\t\t\t}\n\t\t\tif(yy[i].first==c && xx[j].first==d){\n\t\t\t\tgy=i; gx=j;\n\t\t\t}\n\t\t}\n\t\tvi dist(X*Y, 1<<30);\n\t\tpriority_queue<pii> Q;\n\t\tdist[sy*X+sx] = 0;\n\t\tQ.push(pii(0,sy*X+sx));\n\t\twhile(!Q.empty()){\n\t\t\tpii P = Q.top(); Q.pop();\n\t\t\tif(-P.first != dist[P.second])continue;\n\t\t\tint y = P.second / X;\n\t\t\tint x = P.second % X;\n\t\t\tint d = dist[P.second];\n\t\t\tif(yy[y].second=='E' && x+1<X){\n\t\t\t\tint np = (y+0)*X+(x+1);\n\t\t\t\tint nd = d + abs(xx[x+1].first-xx[x].first);\n\t\t\t\tif(nd < dist[np]){\n\t\t\t\t\tdist[np] = nd;\n\t\t\t\t\tQ.push(pii(-nd,np));\n\t\t\t\t}\n\t\t\t}else if(yy[y].second == 'W' && x-1>=0){\n\t\t\t\tint np = (y+0)*X+(x-1);\n\t\t\t\tint nd = d + abs(xx[x-1].first-xx[x].first);\n\t\t\t\tif(nd < dist[np]){\n\t\t\t\t\tdist[np] = nd;\n\t\t\t\t\tQ.push(pii(-nd,np));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(xx[x].second=='S' && y+1<Y){\n\t\t\t\tint np = (y+1)*X+(x+0);\n\t\t\t\tint nd = d + abs(yy[y+1].first-yy[y].first);\n\t\t\t\tif(nd < dist[np]){\n\t\t\t\t\tdist[np] = nd;\n\t\t\t\t\tQ.push(pii(-nd,np));\n\t\t\t\t}\n\t\t\t}else if(xx[x].second=='N' && y-1>=0){\n\t\t\t\tint np = (y-1)*X+(x+0);\n\t\t\t\tint nd = d + abs(yy[y-1].first-yy[y].first);\n\t\t\t\tif(nd < dist[np]){\n\t\t\t\t\tdist[np] = nd;\n\t\t\t\t\tQ.push(pii(-nd,np));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// puts(\"\");\n\t\t// REP(i,X)printf(\"(%d,%c) \",xx[i].first,(char)xx[i].second);puts(\"\");\n\t\t// REP(i,Y)printf(\"(%d,%c) \",yy[i].first,(char)yy[i].second);puts(\"\");\n\t\t// DEBUG(sx);DEBUG(sy);DEBUG(gx);DEBUG(gy);\n\t\tint ans = dist[gy*X+gx];\n\t\tif(ans==(1<<30)){\n\t\t\tputs(\"-1\");\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t\t// break;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Text",
    "code": "記念提出"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.util.AbstractCollection;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FMoreRealisticManhattanDistance solver = new FMoreRealisticManhattanDistance();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FMoreRealisticManhattanDistance {\n        int h;\n        int w;\n        int q;\n        TreeSet<Integer> left = new TreeSet<>();\n        TreeSet<Integer> right = new TreeSet<>();\n        TreeSet<Integer> up = new TreeSet<>();\n        TreeSet<Integer> down = new TreeSet<>();\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            h = in.nextInt();\n            w = in.nextInt();\n            q = in.nextInt();\n            char[] s = in.nextChars();\n            char[] t = in.nextChars();\n            for (int i = 0; i < h; i++) {\n                if (s[i] == 'W') left.add(i);\n                else right.add(i);\n            }\n            for (int i = 0; i < w; i++) {\n                if (t[i] == 'N') up.add(i);\n                else down.add(i);\n            }\n            while (q-- > 0) {\n                int y0 = in.nextInt() - 1;\n                int x0 = in.nextInt() - 1;\n                int y1 = in.nextInt() - 1;\n                int x1 = in.nextInt() - 1;\n                out.println(dijkstra(x0, y0, x1, y1));\n            }\n        }\n\n        int dijkstra(int x0, int y0, int x1, int y1) {\n            PriorityQueue<S> que = new PriorityQueue<>();\n            que.add(new S(x0, y0, 0, 0));\n//        int dr = Integer.MAX_VALUE;\n//        int dl = Integer.MIN_VALUE;\n//        int dd = Integer.MAX_VALUE;\n//        int du = Integer.MIN_VALUE;\n            while (!que.isEmpty()) {\n                S s = que.poll();\n                if (s.x == x1 && s.y == y1) {\n//                dump(s.x, s.y, s.d, s.t);\n                    return s.d;\n                }\n                if (s.t >= 5) continue;\n//            if (dr <= s.x && s.x >= x1) continue;\n//            if (dl >= s.x && s.x <= x1) continue;\n//            if (dd <= s.y && s.y >= y1) continue;\n//            if (du >= s.y && s.y <= y1) continue;\n//            if (s.x >= x1) dr = Math.min(dr, s.x);\n//            if (s.x <= x1) dl = Math.max(dl, s.x);\n//            if (s.y >= y1) dd = Math.min(dd, s.y);\n//            if (s.y <= y1) du = Math.max(du, s.y);\n//            dump(s.x, s.y, s.d);\n                if (right.contains(s.y)) {\n                    nextR(que, x1, s, up);\n                    nextR(que, x1, s, down);\n                }\n                if (left.contains(s.y)) {\n                    nextL(que, x1, s, up);\n                    nextL(que, x1, s, down);\n                }\n                if (up.contains(s.x)) {\n                    nextU(que, y1, s, left);\n                    nextU(que, y1, s, right);\n                }\n                if (down.contains(s.x)) {\n                    nextD(que, y1, s, left);\n                    nextD(que, y1, s, right);\n                }\n            }\n            return -1;\n        }\n\n        void nextR(PriorityQueue<S> que, int x1, S s, TreeSet<Integer> st) {\n            Integer x = st.higher(s.x);\n            if (x != null) que.add(new S(x, s.y, s.d + Math.abs(s.x - x), s.t + 1));\n            if (x1 >= s.x) {\n                x = st.higher(x1);\n                if (x != null) que.add(new S(x, s.y, s.d + Math.abs(s.x - x), s.t + 1));\n                if (s.x != x1) que.add(new S(x1, s.y, s.d + Math.abs(s.x - x1), s.t + 1));\n            }\n        }\n\n        void nextL(PriorityQueue<S> que, int x1, S s, TreeSet<Integer> st) {\n            Integer x = st.lower(s.x);\n            if (x != null) que.add(new S(x, s.y, s.d + Math.abs(s.x - x), s.t + 1));\n            if (x1 <= s.x) {\n                x = st.lower(x1);\n                if (x != null) que.add(new S(x, s.y, s.d + Math.abs(s.x - x), s.t + 1));\n                if (s.x != x1) que.add(new S(x1, s.y, s.d + Math.abs(s.x - x1), s.t + 1));\n            }\n        }\n\n        void nextU(PriorityQueue<S> que, int y1, S s, TreeSet<Integer> st) {\n            Integer y = st.lower(s.y);\n            if (y != null) que.add(new S(s.x, y, s.d + Math.abs(s.y - y), s.t + 1));\n            if (y1 <= s.y) {\n                y = st.lower(y1);\n                if (y != null) que.add(new S(s.x, y, s.d + Math.abs(s.y - y), s.t + 1));\n                if (s.y != y1) que.add(new S(s.x, y1, s.d + Math.abs(s.y - y1), s.t + 1));\n            }\n        }\n\n        void nextD(PriorityQueue<S> que, int y1, S s, TreeSet<Integer> st) {\n            Integer y = st.higher(s.y);\n            if (y != null) que.add(new S(s.x, y, s.d + Math.abs(s.y - y), s.t + 1));\n            if (y1 >= s.y) {\n                y = st.higher(y1);\n                if (y != null) que.add(new S(s.x, y, s.d + Math.abs(s.y - y), s.t + 1));\n                if (s.y != y1) que.add(new S(s.x, y1, s.d + Math.abs(s.y - y1), s.t + 1));\n            }\n        }\n\n        class S implements Comparable<S> {\n            final int x;\n            final int y;\n            final int d;\n            final int t;\n\n            S(int x, int y, int d, int t) {\n                this.x = x;\n                this.y = y;\n                this.d = d;\n                this.t = t;\n            }\n\n            public int compareTo(S o) {\n                return d - o.d;\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public char[] nextChars() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            return Arrays.copyOf(str, len);\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.InputStreamReader;\nimport java.util.TreeSet;\nimport java.util.AbstractCollection;\nimport java.util.TreeMap;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        FMoreRealisticManhattanDistance solver = new FMoreRealisticManhattanDistance();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FMoreRealisticManhattanDistance {\n        int h;\n        int w;\n        int q;\n        TreeSet<Integer> left = new TreeSet<>();\n        TreeSet<Integer> right = new TreeSet<>();\n        TreeSet<Integer> up = new TreeSet<>();\n        TreeSet<Integer> down = new TreeSet<>();\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            h = in.nextInt();\n            w = in.nextInt();\n            q = in.nextInt();\n            char[] s = in.nextChars();\n            char[] t = in.nextChars();\n            for (int i = 0; i < h; i++) {\n                if (s[i] == 'W') left.add(i);\n                else right.add(i);\n            }\n            for (int i = 0; i < w; i++) {\n                if (t[i] == 'N') up.add(i);\n                else down.add(i);\n            }\n            while (q-- > 0) {\n                int y0 = in.nextInt() - 1;\n                int x0 = in.nextInt() - 1;\n                int y1 = in.nextInt() - 1;\n                int x1 = in.nextInt() - 1;\n                out.println(dijkstra(x0, y0, x1, y1));\n            }\n        }\n\n        int dijkstra(int x0, int y0, int x1, int y1) {\n            PriorityQueue<S> que = new PriorityQueue<>();\n            que.add(new S(x0, y0, 0, 0));\n//        int dr = Integer.MAX_VALUE;\n//        int dl = Integer.MIN_VALUE;\n//        int dd = Integer.MAX_VALUE;\n//        int du = Integer.MIN_VALUE;\n            Map<S, Integer> mp = new TreeMap<>((a, b) -> {\n                if (a.x != b.x) return a.x - b.x;\n                return a.y - b.y;\n            });\n            while (!que.isEmpty()) {\n                S s = que.poll();\n                if (s.x == x1 && s.y == y1) {\n//                dump(s.x, s.y, s.d, s.t);\n                    return s.d;\n                }\n                if (s.d > mp.getOrDefault(s, 1 << 29)) continue;\n                mp.put(s, s.d);\n                if (s.t >= 5) continue;\n//            if (dr <= s.x && s.x >= x1) continue;\n//            if (dl >= s.x && s.x <= x1) continue;\n//            if (dd <= s.y && s.y >= y1) continue;\n//            if (du >= s.y && s.y <= y1) continue;\n//            if (s.x >= x1) dr = Math.min(dr, s.x);\n//            if (s.x <= x1) dl = Math.max(dl, s.x);\n//            if (s.y >= y1) dd = Math.min(dd, s.y);\n//            if (s.y <= y1) du = Math.max(du, s.y);\n//            dump(s.x, s.y, s.d);\n                if (right.contains(s.y)) {\n                    nextR(que, x1, s, up);\n                    nextR(que, x1, s, down);\n                }\n                if (left.contains(s.y)) {\n                    nextL(que, x1, s, up);\n                    nextL(que, x1, s, down);\n                }\n                if (up.contains(s.x)) {\n                    nextU(que, y1, s, left);\n                    nextU(que, y1, s, right);\n                }\n                if (down.contains(s.x)) {\n                    nextD(que, y1, s, left);\n                    nextD(que, y1, s, right);\n                }\n            }\n            return -1;\n        }\n\n        void nextR(PriorityQueue<S> que, int x1, S s, TreeSet<Integer> st) {\n            Integer x = st.higher(s.x);\n            if (x != null) que.add(new S(x, s.y, s.d + Math.abs(s.x - x), s.t + 1));\n            if (x1 >= s.x) {\n                x = st.higher(x1);\n                if (x != null) que.add(new S(x, s.y, s.d + Math.abs(s.x - x), s.t + 1));\n                if (s.x != x1) que.add(new S(x1, s.y, s.d + Math.abs(s.x - x1), s.t + 1));\n            }\n        }\n\n        void nextL(PriorityQueue<S> que, int x1, S s, TreeSet<Integer> st) {\n            Integer x = st.lower(s.x);\n            if (x != null) que.add(new S(x, s.y, s.d + Math.abs(s.x - x), s.t + 1));\n            if (x1 <= s.x) {\n                x = st.lower(x1);\n                if (x != null) que.add(new S(x, s.y, s.d + Math.abs(s.x - x), s.t + 1));\n                if (s.x != x1) que.add(new S(x1, s.y, s.d + Math.abs(s.x - x1), s.t + 1));\n            }\n        }\n\n        void nextU(PriorityQueue<S> que, int y1, S s, TreeSet<Integer> st) {\n            Integer y = st.lower(s.y);\n            if (y != null) que.add(new S(s.x, y, s.d + Math.abs(s.y - y), s.t + 1));\n            if (y1 <= s.y) {\n                y = st.lower(y1);\n                if (y != null) que.add(new S(s.x, y, s.d + Math.abs(s.y - y), s.t + 1));\n                if (s.y != y1) que.add(new S(s.x, y1, s.d + Math.abs(s.y - y1), s.t + 1));\n            }\n        }\n\n        void nextD(PriorityQueue<S> que, int y1, S s, TreeSet<Integer> st) {\n            Integer y = st.higher(s.y);\n            if (y != null) que.add(new S(s.x, y, s.d + Math.abs(s.y - y), s.t + 1));\n            if (y1 >= s.y) {\n                y = st.higher(y1);\n                if (y != null) que.add(new S(s.x, y, s.d + Math.abs(s.y - y), s.t + 1));\n                if (s.y != y1) que.add(new S(s.x, y1, s.d + Math.abs(s.y - y1), s.t + 1));\n            }\n        }\n\n        class S implements Comparable<S> {\n            final int x;\n            final int y;\n            final int d;\n            final int t;\n\n            S(int x, int y, int d, int t) {\n                this.x = x;\n                this.y = y;\n                this.d = d;\n                this.t = t;\n            }\n\n            public int compareTo(S o) {\n                return d - o.d;\n            }\n\n        }\n\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        public char[] nextChars() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            return Arrays.copyOf(str, len);\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\t\n\tstatic char[] s, t;\n\tstatic int n, m;\n\tstatic int[] mmn, mms, mme, mmw;\n\tstatic LST ns, ss, es, ws;\n\t\n\tstatic void solve()\n\t{\n\t\tn = ni();\n\t\tm = ni();\n\t\tint Q = ni();\n\t\ts = ns(n);\n\t\tt = ns(m);\n\t\t\n\t\tns = new LST(m);\n\t\tss = new LST(m);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(t[i] == 'N')ns.set(i);\n\t\t\tif(t[i] == 'S')ss.set(i);\n\t\t}\n\t\tes = new LST(n);\n\t\tws = new LST(n);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(s[i] == 'E')es.set(i);\n\t\t\tif(s[i] == 'W')ws.set(i);\n\t\t}\n\t\t\n\t\tmmn = get(t, 'N');\n\t\tmms = get(t, 'S');\n\t\tmme = get(s, 'E');\n\t\tmmw = get(s, 'W');\n\t\thist = new ArrayList<>();\n\t\ttrail = new char[20];\n\t\t\n\t\tfor(int z = 0;z < Q;z++){\n\t\t\tint r1 = ni()-1, c1 = ni()-1;\n\t\t\tint r2 = ni()-1, c2 = ni()-1;\n\t\t\t\n\t\t\tans = Long.MAX_VALUE / 2;\n\t\t\tdfs(r1, c1, r2, c2, s[r1]);\n\t\t\tdfs(r1, c1, r2, c2, t[c1]);\n\t\t\t\n\t\t\tif(ans > Long.MAX_VALUE / 10){\n\t\t\t\tout.println(-1);\n\t\t\t}else{\n\t\t\t\tout.println(ans);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tstatic long ans;\n\t\n\tstatic List<int[]> hist;\n\tstatic char[] trail;\n\t\n\tstatic void dfs(int r, int c, int tr, int tc, char dir)\n\t{\n\t\tif(r == tr && c == tc){\n\t\t\thist.add(new int[]{r, c});\n\t\t\t// shrink\n//\t\t\ttr(Arrays.copyOf(trail, hist.size()-1));\n//\t\t\tfor(int[] e : hist){\n//\t\t\t\ttr(e);\n//\t\t\t}\n\t\t\t\n\t\t\tint[][] lhist = new int[hist.size()][];\n\t\t\tfor(int i = 0;i < hist.size();i++){\n\t\t\t\tlhist[i] = Arrays.copyOf(hist.get(i), 2);\n\t\t\t}\n\t\t\tfor(int i = 0;i < lhist.length-3;i++){\n\t\t\t\tif(trail[i] != trail[i+2]){\n\t\t\t\t\t// 90 90 90\n\t\t\t\t\tif(trail[i] == 'N'){\n\t\t\t\t\t\tint base = Math.min(lhist[i][0], lhist[i+3][0]);\n\t\t\t\t\t\tif(trail[i+1] == 'E'){\n\t\t\t\t\t\t\tint pre = es.prev(base-1);\n\t\t\t\t\t\t\tlhist[i+1][0] = lhist[i+2][0] = pre;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tint pre = ws.prev(base-1);\n\t\t\t\t\t\t\tlhist[i+1][0] = lhist[i+2][0] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(trail[i] == 'S'){\n\t\t\t\t\t\tint base = Math.max(lhist[i][0], lhist[i+3][0]);\n\t\t\t\t\t\tif(trail[i+1] == 'E'){\n\t\t\t\t\t\t\tint pre = es.next(base+1);\n\t\t\t\t\t\t\tlhist[i+1][0] = lhist[i+2][0] = pre;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tint pre = ws.next(base+1);\n\t\t\t\t\t\t\tlhist[i+1][0] = lhist[i+2][0] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(trail[i] == 'W'){\n\t\t\t\t\t\tint base = Math.min(lhist[i][1], lhist[i+3][1]);\n\t\t\t\t\t\tif(trail[i+1] == 'N'){\n\t\t\t\t\t\t\tint pre = ns.prev(base-1);\n\t\t\t\t\t\t\tlhist[i+1][1] = lhist[i+2][1] = pre;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tint pre = ss.prev(base-1);\n\t\t\t\t\t\t\tlhist[i+1][1] = lhist[i+2][1] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(trail[i] == 'E'){\n\t\t\t\t\t\tint base = Math.max(lhist[i][1], lhist[i+3][1]);\n\t\t\t\t\t\tif(trail[i+1] == 'N'){\n\t\t\t\t\t\t\tint pre = ns.next(base+1);\n\t\t\t\t\t\t\tlhist[i+1][1] = lhist[i+2][1] = pre;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tint pre = ss.next(base+1);\n\t\t\t\t\t\t\tlhist[i+1][1] = lhist[i+2][1] = pre;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong len = 0;\n\t\t\tfor(int i = 0;i < lhist.length-1;i++){\n\t\t\t\tlen += Math.abs(lhist[i][0]-lhist[i+1][0]);\n\t\t\t\tlen += Math.abs(lhist[i][1]-lhist[i+1][1]);\n\t\t\t}\n\t\t\tans = Math.min(ans, len);\n\n\t\t\thist.remove(hist.size()-1);\n\t\t\treturn;\n\t\t}\n\t\tif(hist.size() > 6)return;\n\t\t\n\t\ttrail[hist.size()] = dir;\n\t\thist.add(new int[]{r, c});\n\t\t\n//\t\ttr(r, c, tr, tc, dir);\n\t\t\n\t\tif(dir == 'N'){\n\t\t\tif(tr < r && c == tc){\n\t\t\t\tdfs(tr, tc, tr, tc, '_');\n\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(tr < r){\n\t\t\t\tif(s[tr] == 'E' && c < tc){\n\t\t\t\t\tdfs(tr, c, tr, tc, 'E');\n\t\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(s[tr] == 'W' && c > tc){\n\t\t\t\t\tdfs(tr, c, tr, tc, 'W');\n\t\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mme[0] >= 0 && mme[0] < r){\n\t\t\t\tdfs(mme[0], c, tr, tc, 'E');\n\t\t\t}\n\t\t\tif(mmw[0] >= 0 && mmw[0] < r){\n\t\t\t\tdfs(mmw[0], c, tr, tc, 'W');\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(dir == 'S'){\n\t\t\tif(tr > r && c == tc){\n\t\t\t\tdfs(tr, tc, tr, tc, '_');\n\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(tr > r){\n\t\t\t\tif(s[tr] == 'E' && c < tc){\n\t\t\t\t\tdfs(tr, c, tr, tc, 'E');\n\t\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(s[tr] == 'W' && c > tc){\n\t\t\t\t\tdfs(tr, c, tr, tc, 'W');\n\t\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mme[1] < n && mme[1] > r){\n\t\t\t\tdfs(mme[1], c, tr, tc, 'E');\n\t\t\t}\n\t\t\tif(mmw[1] < n && mmw[1] > r){\n\t\t\t\tdfs(mmw[1], c, tr, tc, 'W');\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(dir == 'W'){\n\t\t\tif(tc < c && r == tr){\n\t\t\t\tdfs(tr, tc, tr, tc, '_');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(tc < c){\n\t\t\t\tif(t[tc] == 'S' && r < tr){\n\t\t\t\t\tdfs(r, tc, tr, tc, 'S');\n\t\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(t[tc] == 'N' && r > tr){\n\t\t\t\t\tdfs(r, tc, tr, tc, 'N');\n\t\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mms[0] >= 0 && mms[0] < c){\n\t\t\t\tdfs(r, mms[0], tr, tc, 'S');\n\t\t\t}\n\t\t\tif(mmn[0] >= 0 && mmn[0] < c){\n\t\t\t\tdfs(r, mmn[0], tr, tc, 'N');\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tif(dir == 'E'){\n\t\t\tif(tc > c && r == tr){\n\t\t\t\tdfs(tr, tc, tr, tc, '_');\n\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(tc > c){\n\t\t\t\tif(t[tc] == 'S' && r < tr){\n\t\t\t\t\tdfs(r, tc, tr, tc, 'S');\n\t\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(t[tc] == 'N' && r > tr){\n\t\t\t\t\tdfs(r, tc, tr, tc, 'N');\n\t\t\t\t\thist.remove(hist.size()-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(mms[1] < m && mms[1] > c){\n\t\t\t\tdfs(r, mms[1], tr, tc, 'S');\n\t\t\t}\n\t\t\tif(mmn[1] < m && mmn[1] > c){\n\t\t\t\tdfs(r, mmn[1], tr, tc, 'N');\n\t\t\t}\n\t\t}\n\t\t\n\t\thist.remove(hist.size()-1);\n\t}\n\t\n\tpublic static class LST {\n\t\tpublic long[][] set;\n\t\tpublic int n;\n//\t\tpublic int size;\n\t\t\n\t\tpublic LST(int n) {\n\t\t\tthis.n = n;\n\t\t\tint d = 1;\n\t\t\tfor(int m = n;m > 1;m>>>=6, d++);\n\t\t\t\n\t\t\tset = new long[d][];\n\t\t\tfor(int i = 0, m = n>>>6;i < d;i++, m>>>=6){\n\t\t\t\tset[i] = new long[m+1];\n\t\t\t}\n//\t\t\tsize = 0;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST setRange(int r)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\tfor(int j = 0;j < r>>>6;j++){\n\t\t\t\t\tset[i][j] = -1L;\n\t\t\t\t}\n\t\t\t\tif((r&63) != 0)set[i][r>>>6] |= (1L<<r)-1;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\t// [0,r)\n\t\tpublic LST unsetRange(int r)\n\t\t{\n\t\t\tif(r >= 0){\n\t\t\t\tfor(int i = 0;i < set.length;i++, r=r+63>>>6){\n\t\t\t\t\tfor(int j = 0;j < r+63>>>6;j++){\n\t\t\t\t\t\tset[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif((r&63) != 0)set[i][r>>>6] &= ~((1L<<r)-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST set(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(!get(pos))size++;\n\t\t\t\tfor(int i = 0;i < set.length;i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] |= 1L<<pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic LST unset(int pos)\n\t\t{\n\t\t\tif(pos >= 0 && pos < n){\n//\t\t\t\tif(get(pos))size--;\n\t\t\t\tfor(int i = 0;i < set.length && (i == 0 || set[i-1][pos] == 0L);i++, pos>>>=6){\n\t\t\t\t\tset[i][pos>>>6] &= ~(1L<<pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\tpublic boolean get(int pos)\n\t\t{\n\t\t\treturn pos >= 0 && pos < n && set[0][pos>>>6]<<~pos<0;\n\t\t}\n\t\t\n\t\tpublic LST toggle(int pos)\n\t\t{\n\t\t\treturn get(pos) ? unset(pos) : set(pos);\n\t\t}\n\t\t\n\t\tpublic int prev(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos >= 0;i++, pos>>>=6, pos--){\n\t\t\t\tint pre = prev(set[i][pos>>>6], pos&63);\n\t\t\t\tif(pre != -1){\n\t\t\t\t\tpos = pos>>>6<<6|pre;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|63-Long.numberOfLeadingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tpublic int next(int pos)\n\t\t{\n\t\t\tfor(int i = 0;i < set.length && pos>>>6 < set[i].length;i++, pos>>>=6, pos++){\n\t\t\t\tint nex = next(set[i][pos>>>6], pos&63);\n\t\t\t\tif(nex != -1){\n\t\t\t\t\tpos = pos>>>6<<6|nex;\n\t\t\t\t\twhile(i > 0)pos = pos<<6|Long.numberOfTrailingZeros(set[--i][pos]);\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tprivate static int prev(long set, int n)\n\t\t{\n\t\t\tlong h = set<<~n;\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn -Long.numberOfLeadingZeros(h)+n;\n\t\t}\n\t\t\n\t\tprivate static int next(long set, int n)\n\t\t{\n\t\t\tlong h = set>>>n;\n\t\t\tif(h == 0L)return -1;\n\t\t\treturn Long.numberOfTrailingZeros(h)+n;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int pos = next(0);pos != -1;pos = next(pos+1)){\n\t\t\t\tlist.add(pos);\n\t\t\t}\n\t\t\treturn list.toString();\n\t\t}\n\t}\n\n\t\n\tstatic int[] get(char[] s, char c)\n\t{\n\t\tint min = s.length, max = -1;\n\t\tfor(int i = 0;i < s.length;i++){\n\t\t\tif(s[i] == c){\n\t\t\t\tif(min == s.length)min = i;\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\t\treturn new int[]{min, max};\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "inputs = (gets).split(\" \")\nI = inputs[0].to_i\nJ = inputs[1].to_i\nQ = inputs[2].to_i\n\nroad_i = []\n(gets).chars do |c|\n  case c\n    when 'W'\n      road_i << false\n    when 'E'\n      road_i << true\n    else\n      break\n  end\nend\n\nroad_j = []\n(gets).chars do |c|\n  case c\n    when 'N'\n      road_j << false\n    when 'S'\n      road_j << true\n    else\n      break\n  end\nend\n\nclass Dijkstra\n  def initialize(ii, jj)\n      @iwe = ii.dup\n      @jns = jj.dup\n      @blist = []\n      @amap = []\n      @safe = 0\n      #p @iwe\n      #p @jns\n  end\n\n  def blist_add(p, expand=false)\n      i,j,d = p\n      @blist << p\n      if expand then\n          @blist << [i-1, j] if (i > 0 && @jns[j])\n          @blist << [i+1, j] if (i < I-1 && !@jns[j])\n          @blist << [i, j-1] if (j > 0 && @iwe[i])\n          @blist << [i, j+1] if (j < J-1 && !@iwe[i])\n      end\n  end\n  def blist_check(ps)\n      rps = []\n      ps.each do |p|\n          p2 = p[0..1]\n          if not @blist.include?(p2) then\n              rps << p\n              @blist << p2\n          end\n      end\n      #p rps\n      #@blist = @blist + rps if not rps.length == 0\n      return rps\n  end\n  def blist_rm(p)\n      @blist.reject!{ |i,j| i==p[0] && j==p[1] }\n  end\n  def blist_clear()\n      @blist = []\n  end\n\n  def amap_add(i,j,ps)\n      if @amap[i*J+j].nil? then\n          @amap[i*J+j] = [ps]\n      else\n          @amap[i*J+j].push(ps)\n      end\n  end\n  def amap_search(p1, p2)\n      am = @amap[p2[0]*J+p2[1]]\n      gs = [p2]\n      ret = -1\n      if am.nil? then\n          return ret,gs\n      end\n      am.each do |m|\n          if ( ix = m.index(p1) ).nil? then\n              gs = gs + m # 直接の経路がなければ途中までの地点すべてをゴールにする\n          else\n              ret = m.length - ix\n              #puts \"! find !\"\n              break\n          end\n      end\n      return ret,gs\n  end\n  def amap_dist_andExpand(p1, p2, pa)\n      am = @amap[p2[0]*J+p2[1]]\n      gaps = []\n      buf = am.dup\n      #puts \"---\"\n      #p buf\n      am.each do |m|\n          ix = m.index(p1)\n          if not ix.nil? then\n              m2 = m[ix..(m.length-1)]\n              #p m2\n              #ixs << ix\n              buf.push(pa[2] + m2)\n              #p pa[2]\n              gaps << m2.length\n          end\n      end\n      am = buf\n      #p am\n      #puts \"---\"\n      return gaps.max\n  end\n\n  def next_get(p)\n      rp = []\n      buf = p[2].dup\n      i = p[0]\n      j = p[1]\n      buf.push(p[0..1])\n      rp[rp.length] = [i-1, j, buf] if (i > 0 && !@jns[j])\n      rp[rp.length] = [i+1, j, buf] if (i < I-1 && @jns[j])\n      rp[rp.length] = [i, j-1, buf] if (j > 0 && !@iwe[i])\n      rp[rp.length] = [i, j+1, buf] if (j < J-1 && @iwe[i])\n      #p rp\n      rp.each do |i,j|\n          amap_add(i, j, buf)\n      end\n      #puts \"(#{i}, #{j})\"\n      #p rp\n      return blist_check(rp)\n  end\n\n  def search(p1, p2)\n      blist_clear()\n      #p p1\n      #p p2\n      dist,goals = amap_search(p1, p2)\n      gap = 0\n      if dist >= 0 then\n          return dist\n      end\n      #p goals\n      pos = []\n      pos << [p1[0], p1[1], []] # pos/poの２つめの要素は通ってきたものを示す\n      isGoal = false\n      ds = []\n      #p pos\n      blist_add(p1)\n      #blist_add(p2)\n      blist_rm(p2)\n      #while @safe < 12\n      while true\n          #@safe = @safe + 1\n          buf = []\n          if pos.length == 0 then\n              #pos << [-1, -1, []]\n              #puts \"end\"\n              break\n          end\n          #p pos\n          pos.map! do |po|\n              #isReach = false\n              nps = next_get(po)\n              #if nps.length == 0 then\n              #    po[0] = -1\n              #    next\n              #end\n              #p \"---\"\n              #p nps\n              goals.each.with_index do |g, ix|\n                if not ( arrived = nps.find{ |i,j| (i==g[0] && j==g[1]) } ).nil? then\n                  #buf << arrived\n                  if ix != 0 then\n                      #isReach = true\n                      gap = amap_dist_andExpand(g, p2, arrived)\n                      ds << (arrived[2].length + gap)\n                      #p arrived\n                      arrived[0] = -1\n                      #puts \"gap = #{gap} : (#{g[0]}, #{g[1]})\"\n                      #p arrived[2]\n                 else\n                      #puts \">> Goal! <<\"\n                      isGoal = true\n                      ds << (arrived[2].length)\n                      break\n                  end\n                end #find\n              end #each\n              nps.reject! {|i,j| i == -1}\n              #p nps\n              buf = buf + nps #if not isReach\n          end #pos\n          pos = buf.dup\n          #puts \"---\"\n          #p pos\n          #p @blist\n          break if isGoal\n      end\n      #p pos\n      #return isGoal ? pos[0][2].length+gap : -1\n      #p ds\n      return ds.length > 0 ? ds.min : -1\n  end\nend\n\ndik = Dijkstra.new(road_i, road_j)\nanswers = []\nQ.times do\n    ins = (gets).split(\" \").map{|g| g.to_i - 1}\n    dist = dik.search([ins[0], ins[1]], [ins[2], ins[3]])\n    answers << dist\nend\n\nanswers.each {|ans| puts ans}"
  },
  {
    "language": "Ruby",
    "code": "inputs = (gets).split(\" \")\nI = inputs[0].to_i\nJ = inputs[1].to_i\nQ = inputs[2].to_i\n\nroad_i = []\n(gets).chars do |c|\n  case c\n    when 'W'\n      road_i << false\n    when 'E'\n      road_i << true\n    else\n      break\n  end\nend\n\nroad_j = []\n(gets).chars do |c|\n  case c\n    when 'N'\n      road_j << false\n    when 'S'\n      road_j << true\n    else\n      break\n  end\nend\n\nclass Dijkstra\n  def initialize(ii, jj)\n      @iwe = ii.dup\n      @jns = jj.dup\n      @blist = []\n      @safe = 0\n      #p @iwe\n      #p @jns\n  end\n\n  def blist_add(p, expand=false)\n      i,j,d = p\n      @blist << p\n      if expand then\n          @blist << [i-1, j] if (i > 0 && @jns[j])\n          @blist << [i+1, j] if (i < I-1 && !@jns[j])\n          @blist << [i, j-1] if (j > 0 && @iwe[i])\n          @blist << [i, j+1] if (j < J-1 && !@iwe[i])\n      end\n  end\n  def blist_check(ps)\n      rps = []\n      ps.each do |p|\n          p2 = p[0..1]\n          if not @blist.include?(p2) then\n              rps << p\n              @blist << p2\n          end\n      end\n      #p rps\n      #@blist = @blist + rps if not rps.length == 0\n      return rps\n  end\n  def blist_rm(p)\n      @blist.reject!{ |i,j| i==p[0] && j==p[1] }\n  end\n  def blist_clear()\n      @blist = []\n  end\n\n  def next_get(p)\n      rp = []\n      i = p[0]\n      j = p[1]\n      d = p[2] + 1\n      rp << [i-1, j, d] if (i > 0 && !@jns[j])\n      rp << [i+1, j, d] if (i < I-1 && @jns[j])\n      rp << [i, j-1, d] if (j > 0 && !@iwe[i])\n      rp << [i, j+1, d] if (j < J-1 && @iwe[i])\n      #puts \"(#{i}, #{j}, #{d-1})\"\n      #p rp\n      return blist_check(rp)\n  end\n\n  def search(p1, p2)\n      blist_clear()\n      #p p1\n      #p p2\n      goal_i, goal_j = p2\n      pos = []\n      pos << [p1[0], p1[1], 0] # pos/poの２つめの要素は距離を示す\n      isGoal = false\n      #p pos\n      blist_add(p1)\n      #blist_add(p2)\n      blist_rm(p2)\n      #while @safe < 12\n      while true\n          #@safe = @safe + 1\n          buf = []\n          if pos.length == 0 then\n              pos << [0, 0, -1]\n              #puts \"end\"\n              break\n          end\n          pos.map! do |po|\n              nps = next_get(po)\n              #if nps.length == 0 then\n              #    po[0] = -1\n              #    next\n              #end\n              #p nps\n              if not ( arrived = nps.find{ |i,j,d| (i==goal_i && j==goal_j) } ).nil? then\n                  isGoal = true\n                  #puts \">> Goal! <<\"\n                  buf << arrived\n                  break\n              end\n              buf = buf + nps\n          end\n          pos = buf.dup\n          #puts \"---\"\n          #p pos\n          #p @blist\n          break if isGoal\n      end\n      #p pos\n      return ( pos.map{ |po| po[2]} ).min\n  end\nend\n\ndik = Dijkstra.new(road_i, road_j)\nanswers = []\nQ.times do\n    ins = (gets).split(\" \").map{|g| g.to_i - 1}\n    dist = dik.search([ins[0], ins[1]], [ins[2], ins[3]])\n    answers << dist\nend\n\nanswers.each {|ans| puts ans}"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum INF = 10^^9;\nenum L = 8;\n\nint M, N, Q;\nstring S, T;\nint[] A, B, C, D;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      M = readInt();\n      N = readInt();\n      Q = readInt();\n      S = readToken();\n      T = readToken();\n      A = new int[Q];\n      B = new int[Q];\n      C = new int[Q];\n      D = new int[Q];\n      foreach (q; 0 .. Q) {\n        A[q] = readInt() - 1;\n        B[q] = readInt() - 1;\n        C[q] = readInt() - 1;\n        D[q] = readInt() - 1;\n      }\n      \n      auto nextE = new int[M];\n      auto nextW = new int[M];\n      auto prevE = new int[M];\n      auto prevW = new int[M];\n      auto nextS = new int[N];\n      auto nextN = new int[N];\n      auto prevS = new int[N];\n      auto prevN = new int[N];\n      foreach_reverse (x; 0 .. M) {\n        nextE[x] = (S[x] == 'E') ? x : (x == M - 1) ? M : nextE[x + 1];\n        nextW[x] = (S[x] == 'W') ? x : (x == M - 1) ? M : nextW[x + 1];\n      }\n      foreach (x; 0 .. M) {\n        prevE[x] = (S[x] == 'E') ? x : (x == 0) ? -1 : prevE[x - 1];\n        prevW[x] = (S[x] == 'W') ? x : (x == 0) ? -1 : prevW[x - 1];\n      }\n      foreach_reverse (y; 0 .. N) {\n        nextS[y] = (T[y] == 'S') ? y : (y == N - 1) ? N : nextS[y + 1];\n        nextN[y] = (T[y] == 'N') ? y : (y == N - 1) ? N : nextN[y + 1];\n      }\n      foreach (y; 0 .. N) {\n        prevS[y] = (T[y] == 'S') ? y : (y == 0) ? -1 : prevS[y - 1];\n        prevN[y] = (T[y] == 'N') ? y : (y == 0) ? -1 : prevN[y - 1];\n      }\n      debug {\n        writeln(\"nextE = \", nextE);\n        writeln(\"nextW = \", nextW);\n        writeln(\"prevE = \", prevE);\n        writeln(\"prevW = \", prevW);\n        writeln(\"nextS = \", nextS);\n        writeln(\"nextN = \", nextN);\n        writeln(\"prevS = \", prevS);\n        writeln(\"prevN = \", prevN);\n      }\n      \n      foreach (q; 0 .. Q) {\n        int ans = INF;\n        foreach (dir; 0 .. 2) {\n          foreach (p; 0 .. 1 << L) {\n            int cost;\n            int x = A[q], y = B[q];\n            foreach (i; 0 .. L) {\n              if (x == C[q] && y == D[q]) {\n                chmin(ans, cost);\n                break;\n              }\n              if ((dir + i) & 1) {\n                // vertical move\n                if (T[y] == 'S') {\n                  const xx = ((p >> i) & 1) ? nextE[max(x, C[q])] : nextW[max(x, C[q])];\n                  if (xx >= M) {\n                    break;\n                  }\n                  if (xx == x) {\n                    break;\n                  }\n                  cost += (xx - x);\n                  x = xx;\n                } else {\n                  const xx = ((p >> i) & 1) ? prevE[min(x, C[q])] : prevW[min(x, C[q])];\n                  if (xx < 0) {\n                    break;\n                  }\n                  if (xx == x) {\n                    break;\n                  }\n                  cost += (x - xx);\n                  x = xx;\n                }\n              } else {\n                // horizontal move\n                if (S[x] == 'E') {\n                  const yy = ((p >> i) & 1) ? nextS[max(y, D[q])] : nextN[max(y, D[q])];\n                  if (yy >= N) {\n                    break;\n                  }\n                  if (yy == y) {\n                    break;\n                  }\n                  cost += (yy - y);\n                  y = yy;\n                } else {\n                  const yy = ((p >> i) & 1) ? prevS[min(y, D[q])] : prevN[min(y, D[q])];\n                  if (yy < 0) {\n                    break;\n                  }\n                  if (yy == y) {\n                    break;\n                  }\n                  cost += (y - yy);\n                  y = yy;\n                }\n              }\n            }\n          }\n        }\n        writeln((ans < INF) ? ans : -1);\n      }\n      \n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum INF = 10^^9;\nenum L = 8;\n\nint M, N, Q;\nstring S, T;\nint[] A, B, C, D;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      M = readInt();\n      N = readInt();\n      Q = readInt();\n      S = readToken();\n      T = readToken();\n      A = new int[Q];\n      B = new int[Q];\n      C = new int[Q];\n      D = new int[Q];\n      foreach (q; 0 .. Q) {\n        A[q] = readInt() - 1;\n        B[q] = readInt() - 1;\n        C[q] = readInt() - 1;\n        D[q] = readInt() - 1;\n      }\n      \n      auto nextE = new int[M];\n      auto nextW = new int[M];\n      auto prevE = new int[M];\n      auto prevW = new int[M];\n      auto nextS = new int[N];\n      auto nextN = new int[N];\n      auto prevS = new int[N];\n      auto prevN = new int[N];\n      foreach_reverse (x; 0 .. M) {\n        nextE[x] = (S[x] == 'E') ? x : (x == M - 1) ? M : nextE[x + 1];\n        nextW[x] = (S[x] == 'W') ? x : (x == M - 1) ? M : nextW[x + 1];\n      }\n      foreach (x; 0 .. M) {\n        prevE[x] = (S[x] == 'E') ? x : (x == 0) ? -1 : prevE[x - 1];\n        prevW[x] = (S[x] == 'W') ? x : (x == 0) ? -1 : prevW[x - 1];\n      }\n      foreach_reverse (y; 0 .. N) {\n        nextS[y] = (T[y] == 'S') ? y : (y == N - 1) ? N : nextS[y + 1];\n        nextN[y] = (T[y] == 'N') ? y : (y == N - 1) ? N : nextN[y + 1];\n      }\n      foreach (y; 0 .. N) {\n        prevS[y] = (T[y] == 'S') ? y : (y == 0) ? -1 : prevS[y - 1];\n        prevN[y] = (T[y] == 'N') ? y : (y == 0) ? -1 : prevN[y - 1];\n      }\n      debug {\n        writeln(\"nextE = \", nextE);\n        writeln(\"nextW = \", nextW);\n        writeln(\"prevE = \", prevE);\n        writeln(\"prevW = \", prevW);\n        writeln(\"nextS = \", nextS);\n        writeln(\"nextN = \", nextN);\n        writeln(\"prevS = \", prevS);\n        writeln(\"prevN = \", prevN);\n      }\n      \n      foreach (q; 0 .. Q) {\n        int ans = INF;\n        foreach (dir; 0 .. 2) {\n          foreach (p; 0 .. 1 << L) {\n            int cost;\n            int x = A[q], y = B[q];\n            foreach (i; 0 .. L) {\n              if (x == C[q] && y == D[q]) {\n                chmin(ans, cost);\n                break;\n              }\n              if ((dir + i) & 1) {\n                // vertical move\n                if (T[y] == 'S') {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? nextE[x] : nextW[x];\n                  } else {\n                    if (x < C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (C[q] - x));\n                        break;\n                      }\n                      xx = (y < D[q]) ? nextE[C[q]] : nextW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx >= M) {\n                    break;\n                  }\n                  cost += (xx - x);\n                  x = xx;\n                } else {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? prevE[x] : prevW[x];\n                  } else {\n                    if (x > C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (x - C[q]));\n                        break;\n                      }\n                      xx = (y < D[q]) ? prevE[C[q]] : prevW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx < 0) {\n                    break;\n                  }\n                  cost += (x - xx);\n                  x = xx;\n                }\n              } else {\n                // horizontal move\n                if (S[x] == 'E') {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? nextS[y] : nextN[y];\n                  } else {\n                    if (y < D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (D[q] - y));\n                        break;\n                      }\n                      yy = (x < C[q]) ? nextS[D[q]] : nextN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy >= N) {\n                    break;\n                  }\n                  cost += (yy - y);\n                  y = yy;\n                } else {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? prevS[y] : prevN[y];\n                  } else {\n                    if (y > D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (y - D[q]));\n                        break;\n                      }\n                      yy = (x < C[q]) ? prevS[D[q]] : prevN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy < 0) {\n                    break;\n                  }\n                  cost += (y - yy);\n                  y = yy;\n                }\n              }\n            }\n          }\n        }\n        writeln((ans < INF) ? ans : -1);\n      }\n      \n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum INF = 10^^9;\nenum L = 6;\n\nint M, N, Q;\nstring S, T;\nint[] A, B, C, D;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      M = readInt();\n      N = readInt();\n      Q = readInt();\n      S = readToken();\n      T = readToken();\n      A = new int[Q];\n      B = new int[Q];\n      C = new int[Q];\n      D = new int[Q];\n      foreach (q; 0 .. Q) {\n        A[q] = readInt() - 1;\n        B[q] = readInt() - 1;\n        C[q] = readInt() - 1;\n        D[q] = readInt() - 1;\n      }\n      \n      auto nextE = new int[M];\n      auto nextW = new int[M];\n      auto prevE = new int[M];\n      auto prevW = new int[M];\n      auto nextS = new int[N];\n      auto nextN = new int[N];\n      auto prevS = new int[N];\n      auto prevN = new int[N];\n      foreach_reverse (x; 0 .. M) {\n        nextE[x] = (S[x] == 'E') ? x : (x == M - 1) ? M : nextE[x + 1];\n        nextW[x] = (S[x] == 'W') ? x : (x == M - 1) ? M : nextW[x + 1];\n      }\n      foreach (x; 0 .. M) {\n        prevE[x] = (S[x] == 'E') ? x : (x == 0) ? -1 : prevE[x - 1];\n        prevW[x] = (S[x] == 'W') ? x : (x == 0) ? -1 : prevW[x - 1];\n      }\n      foreach_reverse (y; 0 .. N) {\n        nextS[y] = (T[y] == 'S') ? y : (y == N - 1) ? N : nextS[y + 1];\n        nextN[y] = (T[y] == 'N') ? y : (y == N - 1) ? N : nextN[y + 1];\n      }\n      foreach (y; 0 .. N) {\n        prevS[y] = (T[y] == 'S') ? y : (y == 0) ? -1 : prevS[y - 1];\n        prevN[y] = (T[y] == 'N') ? y : (y == 0) ? -1 : prevN[y - 1];\n      }\n      debug {\n        writeln(\"nextE = \", nextE);\n        writeln(\"nextW = \", nextW);\n        writeln(\"prevE = \", prevE);\n        writeln(\"prevW = \", prevW);\n        writeln(\"nextS = \", nextS);\n        writeln(\"nextN = \", nextN);\n        writeln(\"prevS = \", prevS);\n        writeln(\"prevN = \", prevN);\n      }\n      \n      foreach (q; 0 .. Q) {\n        int ans = INF;\n        foreach (dir; 0 .. 2) {\n          foreach (p; 0 .. 1 << L) {\n            int cost;\n            int x = A[q], y = B[q];\n            foreach (i; 0 .. L) {\n              if (x == C[q] && y == D[q]) {\n                chmin(ans, cost);\n                break;\n              }\n              if ((dir + i) & 1) {\n                // vertical move\n                if (T[y] == 'S') {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? nextE[x] : nextW[x];\n                  } else {\n                    if (x < C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (C[q] - x));\n                        break;\n                      }\n                      xx = (y < D[q]) ? nextE[C[q]] : nextW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx >= M) {\n                    break;\n                  }\n                  cost += (xx - x);\n                  x = xx;\n                } else {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? prevE[x] : prevW[x];\n                  } else {\n                    if (x > C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (x - C[q]));\n                        break;\n                      }\n                      xx = (y < D[q]) ? prevE[C[q]] : prevW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx < 0) {\n                    break;\n                  }\n                  cost += (x - xx);\n                  x = xx;\n                }\n              } else {\n                // horizontal move\n                if (S[x] == 'E') {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? nextS[y] : nextN[y];\n                  } else {\n                    if (y < D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (D[q] - y));\n                        break;\n                      }\n                      yy = (x < C[q]) ? nextS[D[q]] : nextN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy >= N) {\n                    break;\n                  }\n                  cost += (yy - y);\n                  y = yy;\n                } else {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? prevS[y] : prevN[y];\n                  } else {\n                    if (y > D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (y - D[q]));\n                        break;\n                      }\n                      yy = (x < C[q]) ? prevS[D[q]] : prevN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy < 0) {\n                    break;\n                  }\n                  cost += (y - yy);\n                  y = yy;\n                }\n              }\n            }\n          }\n        }\n        writeln((ans < INF) ? ans : -1);\n      }\n      \n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum INF = 10^^9;\nenum L = 7;\n\nint M, N, Q;\nstring S, T;\nint[] A, B, C, D;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      M = readInt();\n      N = readInt();\n      Q = readInt();\n      S = readToken();\n      T = readToken();\n      A = new int[Q];\n      B = new int[Q];\n      C = new int[Q];\n      D = new int[Q];\n      foreach (q; 0 .. Q) {\n        A[q] = readInt() - 1;\n        B[q] = readInt() - 1;\n        C[q] = readInt() - 1;\n        D[q] = readInt() - 1;\n      }\n      \n      auto nextE = new int[M];\n      auto nextW = new int[M];\n      auto prevE = new int[M];\n      auto prevW = new int[M];\n      auto nextS = new int[N];\n      auto nextN = new int[N];\n      auto prevS = new int[N];\n      auto prevN = new int[N];\n      foreach_reverse (x; 0 .. M) {\n        nextE[x] = (S[x] == 'E') ? x : (x == M - 1) ? M : nextE[x + 1];\n        nextW[x] = (S[x] == 'W') ? x : (x == M - 1) ? M : nextW[x + 1];\n      }\n      foreach (x; 0 .. M) {\n        prevE[x] = (S[x] == 'E') ? x : (x == 0) ? -1 : prevE[x - 1];\n        prevW[x] = (S[x] == 'W') ? x : (x == 0) ? -1 : prevW[x - 1];\n      }\n      foreach_reverse (y; 0 .. N) {\n        nextS[y] = (T[y] == 'S') ? y : (y == N - 1) ? N : nextS[y + 1];\n        nextN[y] = (T[y] == 'N') ? y : (y == N - 1) ? N : nextN[y + 1];\n      }\n      foreach (y; 0 .. N) {\n        prevS[y] = (T[y] == 'S') ? y : (y == 0) ? -1 : prevS[y - 1];\n        prevN[y] = (T[y] == 'N') ? y : (y == 0) ? -1 : prevN[y - 1];\n      }\n      debug {\n        writeln(\"nextE = \", nextE);\n        writeln(\"nextW = \", nextW);\n        writeln(\"prevE = \", prevE);\n        writeln(\"prevW = \", prevW);\n        writeln(\"nextS = \", nextS);\n        writeln(\"nextN = \", nextN);\n        writeln(\"prevS = \", prevS);\n        writeln(\"prevN = \", prevN);\n      }\n      \n      foreach (q; 0 .. Q) {\n        int ans = INF;\n        foreach (dir; 0 .. 2) {\n          foreach (p; 0 .. 1 << L) {\n            int cost;\n            int x = A[q], y = B[q];\n            foreach (i; 0 .. L) {\n              if (x == C[q] && y == D[q]) {\n                chmin(ans, cost);\n                break;\n              }\n              if ((dir + i) & 1) {\n                // vertical move\n                if (T[y] == 'S') {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? nextE[x] : nextW[x];\n                  } else {\n                    if (x < C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (C[q] - x));\n                        break;\n                      }\n                      xx = (y < D[q]) ? nextE[C[q]] : nextW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx >= M) {\n                    break;\n                  }\n                  cost += (xx - x);\n                  x = xx;\n                } else {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? prevE[x] : prevW[x];\n                  } else {\n                    if (x > C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (x - C[q]));\n                        break;\n                      }\n                      xx = (y < D[q]) ? prevE[C[q]] : prevW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx < 0) {\n                    break;\n                  }\n                  cost += (x - xx);\n                  x = xx;\n                }\n              } else {\n                // horizontal move\n                if (S[x] == 'E') {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? nextS[y] : nextN[y];\n                  } else {\n                    if (y < D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (D[q] - y));\n                        break;\n                      }\n                      yy = (x < C[q]) ? nextS[D[q]] : nextN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy >= N) {\n                    break;\n                  }\n                  cost += (yy - y);\n                  y = yy;\n                } else {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? prevS[y] : prevN[y];\n                  } else {\n                    if (y > D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (y - D[q]));\n                        break;\n                      }\n                      yy = (x < C[q]) ? prevS[D[q]] : prevN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy < 0) {\n                    break;\n                  }\n                  cost += (y - yy);\n                  y = yy;\n                }\n              }\n            }\n          }\n        }\n        writeln((ans < INF) ? ans : -1);\n      }\n      \n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum INF = 10^^9;\nenum L = 5;\n\nint M, N, Q;\nstring S, T;\nint[] A, B, C, D;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      M = readInt();\n      N = readInt();\n      Q = readInt();\n      S = readToken();\n      T = readToken();\n      A = new int[Q];\n      B = new int[Q];\n      C = new int[Q];\n      D = new int[Q];\n      foreach (q; 0 .. Q) {\n        A[q] = readInt() - 1;\n        B[q] = readInt() - 1;\n        C[q] = readInt() - 1;\n        D[q] = readInt() - 1;\n      }\n      \n      auto nextE = new int[M];\n      auto nextW = new int[M];\n      auto prevE = new int[M];\n      auto prevW = new int[M];\n      auto nextS = new int[N];\n      auto nextN = new int[N];\n      auto prevS = new int[N];\n      auto prevN = new int[N];\n      foreach_reverse (x; 0 .. M) {\n        nextE[x] = (S[x] == 'E') ? x : (x == M - 1) ? M : nextE[x + 1];\n        nextW[x] = (S[x] == 'W') ? x : (x == M - 1) ? M : nextW[x + 1];\n      }\n      foreach (x; 0 .. M) {\n        prevE[x] = (S[x] == 'E') ? x : (x == 0) ? -1 : prevE[x - 1];\n        prevW[x] = (S[x] == 'W') ? x : (x == 0) ? -1 : prevW[x - 1];\n      }\n      foreach_reverse (y; 0 .. N) {\n        nextS[y] = (T[y] == 'S') ? y : (y == N - 1) ? N : nextS[y + 1];\n        nextN[y] = (T[y] == 'N') ? y : (y == N - 1) ? N : nextN[y + 1];\n      }\n      foreach (y; 0 .. N) {\n        prevS[y] = (T[y] == 'S') ? y : (y == 0) ? -1 : prevS[y - 1];\n        prevN[y] = (T[y] == 'N') ? y : (y == 0) ? -1 : prevN[y - 1];\n      }\n      debug {\n        writeln(\"nextE = \", nextE);\n        writeln(\"nextW = \", nextW);\n        writeln(\"prevE = \", prevE);\n        writeln(\"prevW = \", prevW);\n        writeln(\"nextS = \", nextS);\n        writeln(\"nextN = \", nextN);\n        writeln(\"prevS = \", prevS);\n        writeln(\"prevN = \", prevN);\n      }\n      \n      foreach (q; 0 .. Q) {\n        int ans = INF;\n        foreach (dir; 0 .. 2) {\n          foreach (p; 0 .. 1 << L) {\n            int cost;\n            int x = A[q], y = B[q];\n            foreach (i; 0 .. L) {\n              if (x == C[q] && y == D[q]) {\n                chmin(ans, cost);\n                break;\n              }\n              if ((dir + i) & 1) {\n                // vertical move\n                if (T[y] == 'S') {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? nextE[x] : nextW[x];\n                  } else {\n                    if (x < C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (C[q] - x));\n                        break;\n                      }\n                      xx = (y < D[q]) ? nextE[C[q]] : nextW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx >= M) {\n                    break;\n                  }\n                  cost += (xx - x);\n                  x = xx;\n                } else {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? prevE[x] : prevW[x];\n                  } else {\n                    if (x > C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (x - C[q]));\n                        break;\n                      }\n                      xx = (y < D[q]) ? prevE[C[q]] : prevW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx < 0) {\n                    break;\n                  }\n                  cost += (x - xx);\n                  x = xx;\n                }\n              } else {\n                // horizontal move\n                if (S[x] == 'E') {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? nextS[y] : nextN[y];\n                  } else {\n                    if (y < D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (D[q] - y));\n                        break;\n                      }\n                      yy = (x < C[q]) ? nextS[D[q]] : nextN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy >= N) {\n                    break;\n                  }\n                  cost += (yy - y);\n                  y = yy;\n                } else {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? prevS[y] : prevN[y];\n                  } else {\n                    if (y > D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (y - D[q]));\n                        break;\n                      }\n                      yy = (x < C[q]) ? prevS[D[q]] : prevN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy < 0) {\n                    break;\n                  }\n                  cost += (y - yy);\n                  y = yy;\n                }\n              }\n            }\n          }\n        }\n        writeln((ans < INF) ? ans : -1);\n      }\n      \n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum INF = 10^^9;\nenum L = 4;\n\nint M, N, Q;\nstring S, T;\nint[] A, B, C, D;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      M = readInt();\n      N = readInt();\n      Q = readInt();\n      S = readToken();\n      T = readToken();\n      A = new int[Q];\n      B = new int[Q];\n      C = new int[Q];\n      D = new int[Q];\n      foreach (q; 0 .. Q) {\n        A[q] = readInt() - 1;\n        B[q] = readInt() - 1;\n        C[q] = readInt() - 1;\n        D[q] = readInt() - 1;\n      }\n      \n      auto nextE = new int[M];\n      auto nextW = new int[M];\n      auto prevE = new int[M];\n      auto prevW = new int[M];\n      auto nextS = new int[N];\n      auto nextN = new int[N];\n      auto prevS = new int[N];\n      auto prevN = new int[N];\n      foreach_reverse (x; 0 .. M) {\n        nextE[x] = (S[x] == 'E') ? x : (x == M - 1) ? M : nextE[x + 1];\n        nextW[x] = (S[x] == 'W') ? x : (x == M - 1) ? M : nextW[x + 1];\n      }\n      foreach (x; 0 .. M) {\n        prevE[x] = (S[x] == 'E') ? x : (x == 0) ? -1 : prevE[x - 1];\n        prevW[x] = (S[x] == 'W') ? x : (x == 0) ? -1 : prevW[x - 1];\n      }\n      foreach_reverse (y; 0 .. N) {\n        nextS[y] = (T[y] == 'S') ? y : (y == N - 1) ? N : nextS[y + 1];\n        nextN[y] = (T[y] == 'N') ? y : (y == N - 1) ? N : nextN[y + 1];\n      }\n      foreach (y; 0 .. N) {\n        prevS[y] = (T[y] == 'S') ? y : (y == 0) ? -1 : prevS[y - 1];\n        prevN[y] = (T[y] == 'N') ? y : (y == 0) ? -1 : prevN[y - 1];\n      }\n      debug {\n        writeln(\"nextE = \", nextE);\n        writeln(\"nextW = \", nextW);\n        writeln(\"prevE = \", prevE);\n        writeln(\"prevW = \", prevW);\n        writeln(\"nextS = \", nextS);\n        writeln(\"nextN = \", nextN);\n        writeln(\"prevS = \", prevS);\n        writeln(\"prevN = \", prevN);\n      }\n      \n      foreach (q; 0 .. Q) {\n        int ans = INF;\n        foreach (dir; 0 .. 2) {\n          foreach (p; 0 .. 1 << L) {\n            int cost;\n            int x = A[q], y = B[q];\n            foreach (i; 0 .. L) {\n              if (x == C[q] && y == D[q]) {\n                chmin(ans, cost);\n                break;\n              }\n              if ((dir + i) & 1) {\n                // vertical move\n                if (T[y] == 'S') {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? nextE[x] : nextW[x];\n                  } else {\n                    if (x < C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (C[q] - x));\n                        break;\n                      }\n                      xx = (y < D[q]) ? nextE[C[q]] : nextW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx >= M) {\n                    break;\n                  }\n                  cost += (xx - x);\n                  x = xx;\n                } else {\n                  int xx;\n                  if ((p >> i) & 1) {\n                    xx = (S[x] != 'E') ? prevE[x] : prevW[x];\n                  } else {\n                    if (x > C[q]) {\n                      if (y == D[q]) {\n                        chmin(ans, cost + (x - C[q]));\n                        break;\n                      }\n                      xx = (y < D[q]) ? prevE[C[q]] : prevW[C[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (xx < 0) {\n                    break;\n                  }\n                  cost += (x - xx);\n                  x = xx;\n                }\n              } else {\n                // horizontal move\n                if (S[x] == 'E') {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? nextS[y] : nextN[y];\n                  } else {\n                    if (y < D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (D[q] - y));\n                        break;\n                      }\n                      yy = (x < C[q]) ? nextS[D[q]] : nextN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy >= N) {\n                    break;\n                  }\n                  cost += (yy - y);\n                  y = yy;\n                } else {\n                  int yy;\n                  if ((p >> i) & 1) {\n                    yy = (T[y] != 'S') ? prevS[y] : prevN[y];\n                  } else {\n                    if (y > D[q]) {\n                      if (x == C[q]) {\n                        chmin(ans, cost + (y - D[q]));\n                        break;\n                      }\n                      yy = (x < C[q]) ? prevS[D[q]] : prevN[D[q]];\n                    } else {\n                      break;\n                    }\n                  }\n                  if (yy < 0) {\n                    break;\n                  }\n                  cost += (y - yy);\n                  y = yy;\n                }\n              }\n            }\n          }\n        }\n        writeln((ans < INF) ? ans : -1);\n      }\n      \n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "def read():\n    N, M, Q = map(int, input().split(' '))\n    S = input()\n    T = input()\n    qs = []\n    for _ in range(N):\n      a, b, c, d = map(int, input().split(' '))\n      qs.append((a, b, c, d))\n    return N, M, Q, S, T, qs\n\n\nDS = {'W': (-1, 0), 'E': (1, 0), 'N': (0, -1), 'S': (0, 1)}\n\n\ndef ans_q(N, M, Q, S, T, a, b, c, d):\n    # ds[i][j] スタート地点からの距離(未達は-1)\n    ds = [[-1 for _ in range(M)] for _ in range(N)]\n    q = [(a-1, b-1)]\n    ds[a-1][b-1] = 0\n    while q:\n        i, j = q.pop()\n        dd = ds[i][j]\n        drs = [DS.get(s) for s in [S[i], T[j]]]\n        for dx, dy in drs:\n            i2 = i + dy\n            j2 = j + dx\n            if i2 < 0 or i2 >= N or j2 < 0 or j2 >= M:\n                continue\n            if ds[i2][j2] >= 0 and ds[i2][j2] <= dd + 1:\n                continue\n            ds[i2][j2] = dd + 1\n            q.append((i2, j2))\n    return ds[c-1][d-1]\n\n\nif __name__ == '__main__':\n    N, M, Q, S, T, qs = read()\n    for a, b, c, d in qs:\n        print(ans_q(N, M, Q, S, T, a, b, c, d))"
  },
  {
    "language": "Python",
    "code": "def read():\n    N, M, Q = map(int, input().split(' '))\n    S = input()\n    T = input()\n    qs = []\n    for _ in range(N):\n      a, b, c, d = map(int, input().split(' '))\n      qs.append((a, b, c, d))\n    return N, M, Q, S, T, qs\n\n\nDS = {'W': (-1, 0), 'E': (1, 0), 'N': (0, -1), 'S': (0, 1)}\n\n\ndef ans_q(N, M, Q, S, T, a, b, c, d):\n    # ds[i][j] スタート地点からの距離(未達は-1)\n    ds = [[-1 for _ in range(M)] for _ in range(N)]\n    q = [(a-1, b-1)]\n    ds[a-1][b-1] = 0\n    while q:\n        i, j = q.pop()\n        dd = ds[i][j]\n        drs = [DS.get(s) for s in [S[i], T[j]]]\n        for dx, dy in drs:\n            i2 = i + dy\n            j2 = j + dx\n            if i2 < 0 or i2 >= N or j2 < 0 or j2 >= M:\n                continue\n            if ds[i2][j2] >= 0 and ds[i2][j2] <= dd + 1:\n                continue\n            ds[i2][j2] = dd + 1\n            q.append((i2, j2))\n    return ds[c-1][d-1]\n\n\nif __name__ == '__main__':\n    for a, b, c, d in qs:\n        print(ans_q(N, M, Q, S, T, a, b, c, d))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom heapq import heappop, heappush\n\nclass Graph(object):\n    def __init__(self):\n        self.graph = defaultdict(list)\n\n    def __len__(self):\n        return len(self.graph)\n\n    def add_edge(self, src, dst, weight=1):\n        self.graph[src].append((dst, weight))\n\n    def get_nodes(self):\n        return self.graph.keys()\n\n\nclass Dijkstra(object):\n    def __init__(self, graph, start):\n        self.g = graph.graph\n        self.dist = defaultdict(lambda: float('inf'))\n        self.dist[start] = 0\n\n        self.prev = defaultdict(lambda: None)\n\n        self.Q = []\n        heappush(self.Q, (self.dist[start], start))\n\n        while self.Q:\n            dist_u, u = heappop(self.Q)\n            if self.dist[u] < dist_u:\n                continue\n            for v, weight in self.g[u]:\n                alt = dist_u + weight\n                if self.dist[v] > alt:\n                    self.dist[v] = alt\n                    self.prev[v] = u\n                    heappush(self.Q, (alt, v))\n\n    def shortest_distance(self, goal):\n        return self.dist[goal]\n      \nn, m, q = list(map(int, input().split()))\ns = list(input()) \nt = list(input())     \n\ninputs = []\nfor i, s_ in enumerate(s):\n  if s_==\"E\":\n    inputs += [(i*m+j, i*m+j+1, 1) for j in range(0,m-1)]\n  else:\n    inputs += [(i*m+j, i*m+j-1, 1) for j in range(m-1,0,-1)]\nfor i, t_ in enumerate(t):\n  if t_==\"N\":\n    inputs += [(j*m+i, (j-1)*m+i, 1) for j in range(m-1,0,-1)]\n  else:\n    inputs += [(j*m+i, (j+1)*m+i, 1) for j in range(0, m-1)]\ng = Graph()\nfor src, dst, weight in inputs:\n    g.add_edge(src, dst, weight)\n\nfor i in range(q):\n  a, b, c, d = list(map(int, input().split()))\n  dij = Dijkstra(g, (a-1)*m+b-1)\n  dist = dij.shortest_distance((c-1)*m+d-1)\n  if dist!=float('inf'):\n    print(dist)\n  else:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\nimport itertools\nimport time\nimport numpy as np\n\n\nN, M, Q = [int(x) for x in input().split(\" \")]\nS = input()\nT = input()\n\n\ndef is_outside(pos):\n    return pos[0] < 0 or pos[0] >= N \\\n            or pos[1] < 0 or pos[1] >= M\n\n\ndef argmin_positive(array):\n    pmin = M * N\n    pargmin = (-1, -1)\n    for i, j in itertools.product(range(N), range(M)):\n        v = array[i, j]\n        if pmin > v > 0:\n            pmin = v\n            pargmin = (i, j)\n    return pargmin\n\n\ndef fn(a, b, c, d):\n    distance = np.full((N, M), M*N, dtype=np.int32)\n    updated = np.zeros((N, M), dtype=np.int8)\n    src = (a - 1, b - 1)\n    dst = (c - 1, d - 1)\n    focused = src\n    distance[src[0], src[1]] = 0\n    while focused != dst:\n        # time.sleep(0.5)\n        # print(distance)\n        # print(updated)\n        # print(focused)\n\n        d = distance[focused[0], focused[1]]\n        horizontal_next = (focused[0],\n                           focused[1] + (1 if S[focused[0]] is \"E\" else -1))\n        vertical_next = (focused[0] + (1 if T[focused[1]] is \"S\" else -1),\n                         focused[1])\n\n        try:\n            if not is_outside(vertical_next):\n                vd = distance[vertical_next[0], vertical_next[1]]\n                if vd > d + 1:\n                    distance[vertical_next[0], vertical_next[1]] = d + 1\n                    updated[vertical_next[0], vertical_next[1]] = 1\n        except IndexError:\n            pass\n\n        try:\n            if not is_outside(horizontal_next):\n                hd = distance[horizontal_next[0], horizontal_next[1]]\n                if hd > d + 1:\n                    distance[horizontal_next[0], horizontal_next[1]] = d + 1\n                    updated[horizontal_next[0], horizontal_next[1]] = 1\n        except IndexError:\n            pass\n\n        updated[focused[0], focused[1]] = 0\n        if np.max(updated) == 0:\n            print(-1)\n            return\n        # focused = tuple(np.unravel_index(np.argmin(distance * updated,\n        #                                           axis=None),\n        #                                 distance.shape))\n        focused = argmin_positive(distance * updated)\n    print(distance[dst[0], dst[1]])\n\n\nfor _ in range(Q):\n    a, b, c, d = [int(x) for x in input().split(\" \")]\n    fn(a, b, c, d)"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n//////////////////////////////// LIBRARY START ////////////////////////////////\n#[macro_use]\npub mod contest {\n    #[macro_use]\n    pub mod io {\n        /// Scanner\n        ///\n        /// # Example\n        /// ```\n        /// use contest::io::Scanner;\n        /// let mut sc = Scanner::new(\"1 2 \\n\\n \\r\\t \\n 3.5\".as_bytes());\n        /// assert_eq!(\"1\".to_string(), sc.next::<String>());\n        /// assert_eq!(2, sc.next());\n        /// assert_eq!(3.5, sc.next());\n        ///\n        /// // To create a scanner from stdin:\n        /// Scanner::new(std::io::stdin());\n        /// ```\n        use std;\n        use std::io;\n        use std::io::BufRead;\n\n        pub struct Scanner<R: io::Read> {\n            br: io::BufReader<R>,\n            // Read tokens are stored in reversed order per line.\n            buf: Vec<String>,\n        }\n\n        pub fn new<R: io::Read>(r: R) -> Scanner<R> {\n            Scanner::new(r)\n        }\n\n        impl<R: io::Read> Scanner<R> {\n            #[inline]\n            pub fn new(r: R) -> Scanner<R> {\n                Scanner {\n                    br: io::BufReader::new(r),\n                    buf: vec![],\n                }\n            }\n            #[inline]\n            pub fn next<T>(&mut self) -> T\n            where\n                T: std::str::FromStr,\n                T::Err: std::fmt::Debug,\n            {\n                self.next_string()\n                    .map(|s| s.parse::<T>().expect(\"Parse failed: \"))\n                    .expect(\"Unexpected EOF\")\n            }\n            #[inline]\n            pub fn next2<T1, T2>(&mut self) -> (T1, T2)\n            where\n                T1: std::str::FromStr,\n                T2: std::str::FromStr,\n                T1::Err: std::fmt::Debug,\n                T2::Err: std::fmt::Debug,\n            {\n                (self.next(), self.next())\n            }\n            fn next_string(&mut self) -> Option<String> {\n                self.buf.pop().or_else(|| match self.update() {\n                    true => self.next_string(),\n                    false => None,\n                })\n            }\n            #[inline]\n            fn update(&mut self) -> bool {\n                let mut s = String::new();\n                let res = self.br.read_line(&mut s);\n                match res.expect(\"I/O error.\") {\n                    0 => false,\n                    _ => {\n                        self.buf = s.split_whitespace().map(|x| x.to_string()).rev().collect();\n                        true\n                    }\n                }\n            }\n        }\n\n        #[test]\n        fn test_next() {\n            let mut sc = new(\"hoge\".as_bytes());\n            let s: String = sc.next();\n            assert_eq!(\"hoge\", s);\n        }\n    }\n    #[macro_use]\n    pub mod prelude {\n        use std::fmt;\n        use std::iter::FromIterator;\n        use std::ops::*;\n\n        /// `Vec` indexable with `i32`, `i64` or `usize`.\n        #[derive(Clone, Debug, PartialEq, PartialOrd)]\n        pub struct MyVec<T>(pub Vec<T>);\n\n        /// Creates `MyVec`\n        #[macro_export]\n        macro_rules! v {\n    ( $( $x:expr ),* ) => {\n        MyVec(vec![ $( $x, )* ])\n    };\n    ( $x:expr ; $n:expr ) => {\n        {\n            MyVec(vec![$x; $n as usize])\n        }\n    };\n}\n\n        impl<T: fmt::Display> fmt::Display for MyVec<T> {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                let n = self.len();\n                for i in 0..n {\n                    let r = if i < n - 1 {\n                        writeln!(f, \"{}\", self.0[i])\n                    } else {\n                        write!(f, \"{}\", self.0[i])\n                    };\n                    if r.is_err() {\n                        return r;\n                    }\n                }\n                Ok(())\n            }\n        }\n\n        impl<T> Deref for MyVec<T> {\n            type Target = Vec<T>;\n\n            fn deref(&self) -> &Vec<T> {\n                &self.0\n            }\n        }\n\n        impl<T> DerefMut for MyVec<T> {\n            fn deref_mut(&mut self) -> &mut Vec<T> {\n                &mut self.0\n            }\n        }\n\n        impl<T> FromIterator<T> for MyVec<T> {\n            fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n                MyVec(Vec::from_iter(iter))\n            }\n        }\n\n        impl<T, I: ToUsize> Index<I> for MyVec<T> {\n            type Output = T;\n\n            fn index(&self, i: I) -> &T {\n                &self.0[i.to_usize()]\n            }\n        }\n\n        impl<T, I: ToUsize> IndexMut<I> for MyVec<T> {\n            fn index_mut(&mut self, i: I) -> &mut T {\n                &mut self.0[i.to_usize()]\n            }\n        }\n\n        pub trait ToUsize: Sized {\n            fn to_usize(self) -> usize;\n        }\n\n        impl ToUsize for i32 {\n            #[inline]\n            fn to_usize(self) -> usize {\n                self as usize\n            }\n        }\n\n        impl ToUsize for i64 {\n            #[inline]\n            fn to_usize(self) -> usize {\n                self as usize\n            }\n        }\n\n        impl ToUsize for usize {\n            #[inline]\n            fn to_usize(self) -> usize {\n                self\n            }\n        }\n\n        #[test]\n        fn test_myvec() {\n            let mut x = v![3, 2, 1];\n            x.sort();\n            assert_eq!(vec![1, 2, 3], *x);\n            let i = 1i32;\n            assert_eq!(2, x[i]);\n            x[i] = 3;\n            assert_eq!(3, x[i]);\n            let u = 1usize;\n            assert_eq!(3, x[u]);\n            x[u] = 2;\n            assert_eq!(2, x[u]);\n            assert_eq!(2, x[1]);\n\n            assert_eq!(\"MyVec([1, 2, 3])\", format!(\"{:?}\", x));\n            assert_eq!(v![1, 2, 3], x);\n\n            assert_eq!(\"1\\n2\\n3\", format!(\"{}\", x));\n\n            let mut y = v![v![1, 2]; 3];\n            y[0][0] = 2;\n            assert_eq!(vec![2, 2], *y[0]);\n            assert_eq!(vec![1, 2], *y[1]);\n        }\n    }\n}\n//////////////////////////////// LIBRARY END ////////////////////////////////\n\nuse contest::io::Scanner;\nuse contest::prelude::MyVec;\nuse std::collections::BinaryHeap;\n\nfn main() {\n    let mut sc = Scanner::new(std::io::stdin());\n    let n = sc.next::<i32>();\n    let m = sc.next::<i32>();\n    let q = sc.next::<i32>();\n    let s = sc.next::<String>().chars().collect::<MyVec<char>>();\n    let t = sc.next::<String>().chars().collect::<MyVec<char>>();\n\n    let mut bottomLeft = v![-1; n];\n    let mut bottomRight = v![-1; n];\n    let mut upLeft = v![-1; n];\n    let mut upRight = v![-1; n];\n    for i in 0..n {\n        if s[i] == 'W' {\n            upLeft[i] = i;\n            if i > 0 {\n                upRight[i] = upRight[i - 1];\n            }\n        } else {\n            upRight[i] = i;\n            if i > 0 {\n                upLeft[i] = upLeft[i - 1];\n            }\n        }\n    }\n    for i in (0..n).rev() {\n        if s[i] == 'W' {\n            bottomLeft[i] = i;\n            if i + 1 < n {\n                bottomRight[i] = bottomRight[i + 1];\n            }\n        } else {\n            bottomRight[i] = i;\n            if i + 1 < n {\n                bottomLeft[i] = bottomLeft[i + 1];\n            }\n        }\n    }\n\n    let mut leftUp = v![-1; m];\n    let mut leftDown = v![-1; m];\n    let mut rightUp = v![-1; m];\n    let mut rightDown = v![-1; m];\n    for i in 0..m {\n        if t[i] == 'N' {\n            leftUp[i] = i;\n            if i > 0 {\n                leftDown[i] = leftDown[i - 1];\n            }\n        } else {\n            leftDown[i] = i;\n            if i > 0 {\n                leftUp[i] = leftUp[i - 1];\n            }\n        }\n    }\n    for i in (0..m).rev() {\n        if t[i] == 'N' {\n            rightUp[i] = i;\n            if i + 1 < m {\n                rightDown[i] = rightDown[i + 1];\n            }\n        } else {\n            rightDown[i] = i;\n            if i + 1 < m {\n                rightUp[i] = rightUp[i + 1];\n            }\n        }\n    }\n\n    for _ in 0..q {\n        let a = sc.next::<i32>() - 1;\n        let b = sc.next::<i32>() - 1;\n        let c = sc.next::<i32>() - 1;\n        let d = sc.next::<i32>() - 1;\n\n        let mut rows = v![];\n        let mut cols = v![];\n\n        push(&mut rows, (upRight[a], 'R'));\n        push(&mut rows, (upRight[a], 'R'));\n        push(&mut rows, (upRight[c], 'R'));\n        push(&mut rows, (bottomRight[a], 'R'));\n        push(&mut rows, (bottomRight[c], 'R'));\n        push(&mut rows, (upLeft[a], 'L'));\n        push(&mut rows, (upLeft[c], 'L'));\n        push(&mut rows, (bottomLeft[a], 'L'));\n        push(&mut rows, (bottomLeft[c], 'L'));\n\n        push(&mut cols, (leftUp[b], 'U'));\n        push(&mut cols, (leftUp[d], 'U'));\n        push(&mut cols, (rightUp[b], 'U'));\n        push(&mut cols, (rightUp[d], 'U'));\n        push(&mut cols, (leftDown[b], 'D'));\n        push(&mut cols, (leftDown[d], 'D'));\n        push(&mut cols, (rightDown[b], 'D'));\n        push(&mut cols, (rightDown[d], 'D'));\n\n        rows.sort();\n        cols.sort();\n\n        rows.dedup();\n        cols.dedup();\n\n        let mut startX = 10;\n        let mut startY = 10;\n        let mut goalX = 10;\n        let mut goalY = 10;\n        for i in 0..rows.len() {\n            if rows[i].0 == a {\n                startX = i;\n            }\n            if rows[i].0 == c {\n                goalX = i;\n            }\n        }\n        for i in 0..cols.len() {\n            if cols[i].0 == b {\n                startY = i;\n            }\n            if cols[i].0 == d {\n                goalY = i;\n            }\n        }\n\n        let inf = 1_000_000_000;\n        let mut dist = v![v![inf; 8]; 8];\n        let mut q = BinaryHeap::new();\n        q.push((inf - 0, startX, startY));\n        while !q.is_empty() {\n            let (dd, x, y) = q.pop().unwrap();\n            if dist[x][y] < inf {\n                continue;\n            }\n            dist[x][y] = inf - dd;\n            if rows[x].1 == 'L' {\n                if y > 0 {\n                    let d = cols[y].0 - cols[y - 1].0;\n                    q.push((dd - d, x, y - 1));\n                }\n            } else {\n                if y + 1 < cols.len() {\n                    let d = cols[y + 1].0 - cols[y].0;\n                    q.push((dd - d, x, y + 1));\n                }\n            }\n            if cols[y].1 == 'U' {\n                if x > 0 {\n                    let d = rows[x].0 - rows[x - 1].0;\n                    q.push((dd - d, x - 1, y));\n                }\n            } else {\n                if x + 1 < rows.len() {\n                    let d = rows[x + 1].0 - rows[x].0;\n                    q.push((dd - d, x + 1, y));\n                }\n            }\n        }\n        let res = dist[goalX][goalY];\n        if res == inf {\n            println!(\"-1\");\n        } else {\n            println!(\"{}\", res);\n        }\n    }\n}\n\nfn push(rows: &mut Vec<(i32, char)>, (x, d): (i32, char)) {\n    if x >= 0 {\n        rows.push((x, d));\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n//////////////////////////////// LIBRARY START ////////////////////////////////\n#[macro_use]\npub mod contest {\n    #[macro_use]\n    pub mod io {\n        /// Scanner\n        ///\n        /// # Example\n        /// ```\n        /// use contest::io::Scanner;\n        /// let mut sc = Scanner::new(\"1 2 \\n\\n \\r\\t \\n 3.5\".as_bytes());\n        /// assert_eq!(\"1\".to_string(), sc.next::<String>());\n        /// assert_eq!(2, sc.next());\n        /// assert_eq!(3.5, sc.next());\n        ///\n        /// // To create a scanner from stdin:\n        /// Scanner::new(std::io::stdin());\n        /// ```\n        use std;\n        use std::io;\n        use std::io::BufRead;\n\n        pub struct Scanner<R: io::Read> {\n            br: io::BufReader<R>,\n            // Read tokens are stored in reversed order per line.\n            buf: Vec<String>,\n        }\n\n        pub fn new<R: io::Read>(r: R) -> Scanner<R> {\n            Scanner::new(r)\n        }\n\n        impl<R: io::Read> Scanner<R> {\n            #[inline]\n            pub fn new(r: R) -> Scanner<R> {\n                Scanner {\n                    br: io::BufReader::new(r),\n                    buf: vec![],\n                }\n            }\n            #[inline]\n            pub fn next<T>(&mut self) -> T\n            where\n                T: std::str::FromStr,\n                T::Err: std::fmt::Debug,\n            {\n                self.next_string()\n                    .map(|s| s.parse::<T>().expect(\"Parse failed: \"))\n                    .expect(\"Unexpected EOF\")\n            }\n            #[inline]\n            pub fn next2<T1, T2>(&mut self) -> (T1, T2)\n            where\n                T1: std::str::FromStr,\n                T2: std::str::FromStr,\n                T1::Err: std::fmt::Debug,\n                T2::Err: std::fmt::Debug,\n            {\n                (self.next(), self.next())\n            }\n            fn next_string(&mut self) -> Option<String> {\n                self.buf.pop().or_else(|| match self.update() {\n                    true => self.next_string(),\n                    false => None,\n                })\n            }\n            #[inline]\n            fn update(&mut self) -> bool {\n                let mut s = String::new();\n                let res = self.br.read_line(&mut s);\n                match res.expect(\"I/O error.\") {\n                    0 => false,\n                    _ => {\n                        self.buf = s.split_whitespace().map(|x| x.to_string()).rev().collect();\n                        true\n                    }\n                }\n            }\n        }\n\n        #[test]\n        fn test_next() {\n            let mut sc = new(\"hoge\".as_bytes());\n            let s: String = sc.next();\n            assert_eq!(\"hoge\", s);\n        }\n    }\n    #[macro_use]\n    pub mod prelude {\n        //! Items most contest code will use.\n\n        use std::fmt;\n        use std::iter::FromIterator;\n        use std::ops::*;\n\n        /// `Vec` indexable with `i32`, `i64` or `usize`.\n        #[derive(Clone, Debug, PartialEq, PartialOrd)]\n        pub struct MyVec<T>(pub Vec<T>);\n\n        /// Creates `MyVec`\n        #[macro_export]\n        macro_rules! v {\n    ( $( $x:expr ),* ) => {\n        MyVec(vec![ $( $x, )* ])\n    };\n    ( $x:expr ; $n:expr ) => {\n        {\n            MyVec(vec![$x; $n as usize])\n        }\n    };\n}\n\n        impl<T: fmt::Display> fmt::Display for MyVec<T> {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                let n = self.len();\n                for i in 0..n {\n                    let r = write!(f, \"{}\\n\", self.0[i]);\n                    if r.is_err() {\n                        return r;\n                    }\n                }\n                Ok(())\n            }\n        }\n\n        impl<T> Deref for MyVec<T> {\n            type Target = Vec<T>;\n\n            fn deref(&self) -> &Vec<T> {\n                &self.0\n            }\n        }\n\n        impl<T> DerefMut for MyVec<T> {\n            fn deref_mut(&mut self) -> &mut Vec<T> {\n                &mut self.0\n            }\n        }\n\n        impl<T> FromIterator<T> for MyVec<T> {\n            fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n                MyVec(Vec::from_iter(iter))\n            }\n        }\n\n        macro_rules! impl_index {\n            ($x: ty) => {\n                impl<T> Index<$x> for MyVec<T> {\n                    type Output = T;\n\n                    fn index(&self, i: $x) -> &T {\n                        &self.0[i as usize]\n                    }\n                }\n\n                impl<T> IndexMut<$x> for MyVec<T> {\n                    fn index_mut(&mut self, i: $x) -> &mut T {\n                        &mut self.0[i as usize]\n                    }\n                }\n            };\n        }\n\n        impl_index!(i32);\n        impl_index!(i64);\n        impl_index!(usize);\n\n        #[test]\n        fn test_myvec() {\n            let mut x = v![3, 2, 1];\n            x.sort();\n            assert_eq!(vec![1, 2, 3], *x);\n            let i = 1i32;\n            assert_eq!(2, x[i]);\n            x[i] = 3;\n            assert_eq!(3, x[i]);\n            let u = 1usize;\n            assert_eq!(3, x[u]);\n            x[u] = 2;\n            assert_eq!(2, x[u]);\n\n            assert_eq!(\"MyVec([1, 2, 3])\", format!(\"{:?}\", x));\n            assert_eq!(v![1, 2, 3], x);\n\n            assert_eq!(\"1\\n2\\n3\\n\", format!(\"{}\", x));\n\n            let mut y = v![v![1,2]; 3];\n            y[0i32][0i32] = 2i32;\n            assert_eq!(vec![2, 2], *y[0i32]);\n            assert_eq!(vec![1, 2], *y[1i32]);\n        }\n    }\n}\n//////////////////////////////// LIBRARY END ////////////////////////////////\n\nuse contest::io::Scanner;\nuse contest::prelude::MyVec;\nuse std::collections::BinaryHeap;\n\nfn main() {\n    let mut sc = Scanner::new(std::io::stdin());\n    let n = sc.next::<i32>();\n    let m = sc.next::<i32>();\n    let q = sc.next::<i32>();\n    let s = sc.next::<String>().chars().collect::<MyVec<char>>();\n    let t = sc.next::<String>().chars().collect::<MyVec<char>>();\n\n    let mut bottomLeft = v![-1; n];\n    let mut bottomRight = v![-1; n];\n    let mut upLeft = v![-1; n];\n    let mut upRight = v![-1; n];\n    for i in 0..n {\n        if s[i] == 'W' {\n            upLeft[i] = i;\n            if i > 0 {\n                upRight[i] = upRight[i - 1];\n            }\n        } else {\n            upRight[i] = i;\n            if i > 0 {\n                upLeft[i] = upLeft[i - 1];\n            }\n        }\n    }\n    for i in (0..n).rev() {\n        if s[i] == 'W' {\n            bottomLeft[i] = i;\n            if i + 1 < n {\n                bottomRight[i] = bottomRight[i + 1];\n            }\n        } else {\n            bottomRight[i] = i;\n            if i + 1 < n {\n                bottomLeft[i] = bottomLeft[i + 1];\n            }\n        }\n    }\n\n    let mut leftUp = v![-1; m];\n    let mut leftDown = v![-1; m];\n    let mut rightUp = v![-1; m];\n    let mut rightDown = v![-1; m];\n    for i in 0..m {\n        if t[i] == 'N' {\n            leftUp[i] = i;\n            if i > 0 {\n                leftDown[i] = leftDown[i - 1];\n            }\n        } else {\n            leftDown[i] = i;\n            if i > 0 {\n                leftUp[i] = leftUp[i - 1];\n            }\n        }\n    }\n    for i in (0..m).rev() {\n        if t[i] == 'N' {\n            rightUp[i] = i;\n            if i + 1 < m {\n                rightDown[i] = rightDown[i + 1];\n            }\n        } else {\n            rightDown[i] = i;\n            if i + 1 < m {\n                rightUp[i] = rightUp[i + 1];\n            }\n        }\n    }\n\n    for _ in 0..q {\n        let a = sc.next::<i32>() - 1;\n        let b = sc.next::<i32>() - 1;\n        let c = sc.next::<i32>() - 1;\n        let d = sc.next::<i32>() - 1;\n\n        let mut rows = v![];\n        let mut cols = v![];\n\n        push(&mut rows, (upRight[a], 'R'));\n        push(&mut rows, (upRight[a], 'R'));\n        push(&mut rows, (upRight[c], 'R'));\n        push(&mut rows, (bottomRight[a], 'R'));\n        push(&mut rows, (bottomRight[c], 'R'));\n        push(&mut rows, (upLeft[a], 'L'));\n        push(&mut rows, (upLeft[c], 'L'));\n        push(&mut rows, (bottomLeft[a], 'L'));\n        push(&mut rows, (bottomLeft[c], 'L'));\n\n        push(&mut cols, (leftUp[b], 'U'));\n        push(&mut cols, (leftUp[d], 'U'));\n        push(&mut cols, (rightUp[b], 'U'));\n        push(&mut cols, (rightUp[d], 'U'));\n        push(&mut cols, (leftDown[b], 'D'));\n        push(&mut cols, (leftDown[d], 'D'));\n        push(&mut cols, (rightDown[b], 'D'));\n        push(&mut cols, (rightDown[d], 'D'));\n\n        rows.sort();\n        cols.sort();\n\n        rows.dedup();\n        cols.dedup();\n\n        let mut startX = 10;\n        let mut startY = 10;\n        let mut goalX = 10;\n        let mut goalY = 10;\n        for i in 0..rows.len() {\n            if rows[i].0 == a {\n                startX = i;\n            }\n            if rows[i].0 == c {\n                goalX = i;\n            }\n        }\n        for i in 0..cols.len() {\n            if cols[i].0 == b {\n                startY = i;\n            }\n            if cols[i].0 == d {\n                goalY = i;\n            }\n        }\n\n        let inf = 1_000_000_000;\n        let mut dist = v![v![inf; 8]; 8];\n        let mut q = BinaryHeap::new();\n        q.push((inf - 0, startX, startY));\n        while !q.is_empty() {\n            let (dd, x, y) = q.pop().unwrap();\n            if dist[x][y] < inf {\n                continue;\n            }\n            dist[x][y] = inf - dd;\n            if rows[x].1 == 'L' {\n                if y > 0 {\n                    let d = cols[y].0 - cols[y - 1].0;\n                    q.push((dd - d, x, y - 1));\n                }\n            } else {\n                if y + 1 < cols.len() {\n                    let d = cols[y + 1].0 - cols[y].0;\n                    q.push((dd - d, x, y + 1));\n                }\n            }\n            if cols[y].1 == 'U' {\n                if x > 0 {\n                    let d = rows[x].0 - rows[x - 1].0;\n                    q.push((dd - d, x - 1, y));\n                }\n            } else {\n                if x + 1 < rows.len() {\n                    let d = rows[x + 1].0 - rows[x].0;\n                    q.push((dd - d, x + 1, y));\n                }\n            }\n        }\n        let res = dist[goalX][goalY];\n        if res == inf {\n            println!(\"-1\");\n        } else {\n            println!(\"{}\", res);\n        }\n    }\n}\n\nfn push(rows: &mut Vec<(i32, char)>, (x, d): (i32, char)) {\n    if x >= 0 {\n        rows.push((x, d));\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use contest::io::Scanner;\nuse std::collections::BinaryHeap;\nuse std::io::Write;\n\nfn main() {\n    let mut sc = Scanner::new(std::io::stdin());\n    let n = sc.next::<usize>();\n    let m = sc.next::<usize>();\n    let q = sc.next::<usize>();\n    let s = sc.next::<String>().chars().collect::<Vec<char>>();\n    let t = sc.next::<String>().chars().collect::<Vec<char>>();\n\n    let mut bottomLeft: Vec<i32> = vec![-1; n];\n    let mut bottomRight: Vec<i32> = vec![-1; n];\n    let mut upLeft: Vec<i32> = vec![-1; n];\n    let mut upRight: Vec<i32> = vec![-1; n];\n    for i in 0..n {\n        if s[i] == 'W' {\n            upLeft[i] = i as i32;\n            if i > 0 {\n                upRight[i] = upRight[i - 1];\n            }\n        } else {\n            upRight[i] = i as i32;\n            if i > 0 {\n                upLeft[i] = upLeft[i - 1];\n            }\n        }\n    }\n    for i in (0..n).rev() {\n        if s[i] == 'W' {\n            bottomLeft[i] = i as i32;\n            if i + 1 < n {\n                bottomRight[i] = bottomRight[i + 1];\n            }\n        } else {\n            bottomRight[i] = i as i32;\n            if i + 1 < n {\n                bottomLeft[i] = bottomLeft[i + 1];\n            }\n        }\n    }\n\n    let mut leftUp: Vec<i32> = vec![-1; m];\n    let mut leftDown: Vec<i32> = vec![-1; m];\n    let mut rightUp: Vec<i32> = vec![-1; m];\n    let mut rightDown: Vec<i32> = vec![-1; m];\n    for i in 0..m {\n        if t[i] == 'N' {\n            leftUp[i] = i as i32;\n            if i > 0 {\n                leftDown[i] = leftDown[i - 1];\n            }\n        } else {\n            leftDown[i] = i as i32;\n            if i > 0 {\n                leftUp[i] = leftUp[i - 1];\n            }\n        }\n    }\n    for i in (0..m).rev() {\n        if t[i] == 'N' {\n            rightUp[i] = i as i32;\n            if i + 1 < m {\n                rightDown[i] = rightDown[i + 1];\n            }\n        } else {\n            rightDown[i] = i as i32;\n            if i + 1 < m {\n                rightUp[i] = rightUp[i + 1];\n            }\n        }\n    }\n\n    for _ in 0..q {\n        let a = sc.next::<usize>() - 1;\n        let b = sc.next::<usize>() - 1;\n        let c = sc.next::<usize>() - 1;\n        let d = sc.next::<usize>() - 1;\n\n        let mut rows: Vec<(i32, char)> = vec![];\n        let mut cols: Vec<(i32, char)> = vec![];\n\n        push(&mut rows, (upRight[a], 'R'));\n        push(&mut rows, (upRight[a], 'R'));\n        push(&mut rows, (upRight[c], 'R'));\n        push(&mut rows, (bottomRight[a], 'R'));\n        push(&mut rows, (bottomRight[c], 'R'));\n        push(&mut rows, (upLeft[a], 'L'));\n        push(&mut rows, (upLeft[c], 'L'));\n        push(&mut rows, (bottomLeft[a], 'L'));\n        push(&mut rows, (bottomLeft[c], 'L'));\n\n        push(&mut cols, (leftUp[b], 'U'));\n        push(&mut cols, (leftUp[d], 'U'));\n        push(&mut cols, (rightUp[b], 'U'));\n        push(&mut cols, (rightUp[d], 'U'));\n        push(&mut cols, (leftDown[b], 'D'));\n        push(&mut cols, (leftDown[d], 'D'));\n        push(&mut cols, (rightDown[b], 'D'));\n        push(&mut cols, (rightDown[d], 'D'));\n\n        rows.sort();\n        cols.sort();\n\n        rows.dedup();\n        cols.dedup();\n\n        let mut startX = 10;\n        let mut startY = 10;\n        let mut goalX = 10;\n        let mut goalY = 10;\n        for i in 0..rows.len() {\n            if rows[i].0 == a as i32 {\n                startX = i;\n            }\n            if rows[i].0 == c as i32 {\n                goalX = i;\n            }\n        }\n        for i in 0..cols.len() {\n            if cols[i].0 == b as i32 {\n                startY = i;\n            }\n            if cols[i].0 == d as i32 {\n                goalY = i;\n            }\n        }\n        // println!(\"sX sY gX gY: {} {} {} {}\", startX, startY, goalX, goalY);\n\n        let inf = 1_000_000_000 as i32;\n        let mut dist = vec![vec![inf; 8]; 8];\n        let mut q = BinaryHeap::new();\n        q.push((inf - 0, startX, startY));\n        while !q.is_empty() {\n            let (dd, x, y) = q.pop().unwrap();\n            // println!(\"q.pop: {} {} {}\", inf - dd, x, y);\n            if dist[x][y] < inf {\n                continue;\n            }\n            dist[x][y] = inf - dd;\n            if rows[x].1 == 'L' {\n                if y > 0 {\n                    let d = cols[y].0 - cols[y - 1].0;\n                    q.push((dd - d, x, y - 1));\n                }\n            } else {\n                if y + 1 < cols.len() {\n                    let d = cols[y + 1].0 - cols[y].0;\n                    q.push((dd - d, x, y + 1));\n                }\n            }\n            if cols[y].1 == 'U' {\n                if x > 0 {\n                    let d = rows[x].0 - rows[x - 1].0;\n                    q.push((dd - d, x - 1, y));\n                }\n            } else {\n                if x + 1 < rows.len() {\n                    let d = rows[x + 1].0 - rows[x].0;\n                    q.push((dd - d, x + 1, y));\n                }\n            }\n        }\n        // write!(std::io::stderr(), \"{:?}\\n\", rows);\n        // write!(std::io::stderr(), \"{:?}\\n\", cols);\n        // write!(std::io::stderr(), \"{:?}\\n\", dist);\n        let mut res = dist[goalX][goalY];\n        if res == inf {\n            println!(\"-1\");\n        } else {\n            println!(\"{}\", res);\n        }\n    }\n}\n\nfn push(rows: &mut Vec<(i32, char)>, (x, d): (i32, char)) {\n    if x >= 0 {\n        rows.push((x, d));\n    }\n}\npub mod contest {\n    pub mod io {\n        /// Scanner\n        ///\n        /// # Example\n        /// ```\n        /// use contest::io::Scanner;\n        /// let mut sc = Scanner::new(\"1 2 \\n\\n \\r\\t \\n 3.5\".as_bytes());\n        /// assert_eq!(\"1\".to_string(), sc.next::<String>());\n        /// assert_eq!(2, sc.next());\n        /// assert_eq!(3.5, sc.next());\n        ///\n        /// // To create a scanner from stdin:\n        /// Scanner::new(std::io::stdin());\n        /// ```\n        use std;\n        use std::io;\n        use std::io::BufRead;\n\n        pub struct Scanner<R: io::Read> {\n            br: io::BufReader<R>,\n            // Read tokens are stored in reversed order per line.\n            buf: Vec<String>,\n        }\n\n        pub fn new<R: io::Read>(r: R) -> Scanner<R> {\n            Scanner::new(r)\n        }\n\n        impl<R: io::Read> Scanner<R> {\n            #[inline]\n            pub fn new(r: R) -> Scanner<R> {\n                Scanner {\n                    br: io::BufReader::new(r),\n                    buf: vec![],\n                }\n            }\n            #[inline]\n            pub fn next<T>(&mut self) -> T\n            where\n                T: std::str::FromStr,\n                T::Err: std::fmt::Debug,\n            {\n                self.next_string()\n                    .map(|s| s.parse::<T>().expect(\"Parse failed: \"))\n                    .expect(\"Unexpected EOF\")\n            }\n            #[inline]\n            pub fn next2<T1, T2>(&mut self) -> (T1, T2)\n            where\n                T1: std::str::FromStr,\n                T2: std::str::FromStr,\n                T1::Err: std::fmt::Debug,\n                T2::Err: std::fmt::Debug,\n            {\n                (self.next(), self.next())\n            }\n            fn next_string(&mut self) -> Option<String> {\n                self.buf.pop().or_else(|| match self.update() {\n                    true => self.next_string(),\n                    false => None,\n                })\n            }\n            #[inline]\n            fn update(&mut self) -> bool {\n                let mut s = String::new();\n                let res = self.br.read_line(&mut s);\n                match res.expect(\"I/O error.\") {\n                    0 => false,\n                    _ => {\n                        self.buf = s.split_whitespace().map(|x| x.to_string()).rev().collect();\n                        true\n                    }\n                }\n            }\n        }\n\n        #[test]\n        fn test_next() {\n            let mut sc = new(\"hoge\".as_bytes());\n            let s: String = sc.next();\n            assert_eq!(\"hoge\", s);\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n//////////////////////////////// LIBRARY START ////////////////////////////////\n#[macro_use]\npub mod contest {\n    #[macro_use]\n    pub mod io {\n        /// Scanner\n        ///\n        /// # Example\n        /// ```\n        /// use contest::io::Scanner;\n        /// let mut sc = Scanner::new(\"1 2 \\n\\n \\r\\t \\n 3.5\".as_bytes());\n        /// assert_eq!(\"1\".to_string(), sc.next::<String>());\n        /// assert_eq!(2, sc.next());\n        /// assert_eq!(3.5, sc.next());\n        ///\n        /// // To create a scanner from stdin:\n        /// Scanner::new(std::io::stdin());\n        /// ```\n        use std;\n        use std::io;\n        use std::io::BufRead;\n\n        pub struct Scanner<R: io::Read> {\n            br: io::BufReader<R>,\n            // Read tokens are stored in reversed order per line.\n            buf: Vec<String>,\n        }\n\n        pub fn new<R: io::Read>(r: R) -> Scanner<R> {\n            Scanner::new(r)\n        }\n\n        impl<R: io::Read> Scanner<R> {\n            #[inline]\n            pub fn new(r: R) -> Scanner<R> {\n                Scanner {\n                    br: io::BufReader::new(r),\n                    buf: vec![],\n                }\n            }\n            #[inline]\n            pub fn next<T>(&mut self) -> T\n            where\n                T: std::str::FromStr,\n                T::Err: std::fmt::Debug,\n            {\n                self.next_string()\n                    .map(|s| s.parse::<T>().expect(\"Parse failed: \"))\n                    .expect(\"Unexpected EOF\")\n            }\n            #[inline]\n            pub fn next2<T1, T2>(&mut self) -> (T1, T2)\n            where\n                T1: std::str::FromStr,\n                T2: std::str::FromStr,\n                T1::Err: std::fmt::Debug,\n                T2::Err: std::fmt::Debug,\n            {\n                (self.next(), self.next())\n            }\n            fn next_string(&mut self) -> Option<String> {\n                self.buf.pop().or_else(|| match self.update() {\n                    true => self.next_string(),\n                    false => None,\n                })\n            }\n            #[inline]\n            fn update(&mut self) -> bool {\n                let mut s = String::new();\n                let res = self.br.read_line(&mut s);\n                match res.expect(\"I/O error.\") {\n                    0 => false,\n                    _ => {\n                        self.buf = s.split_whitespace().map(|x| x.to_string()).rev().collect();\n                        true\n                    }\n                }\n            }\n        }\n\n        #[test]\n        fn test_next() {\n            let mut sc = new(\"hoge\".as_bytes());\n            let s: String = sc.next();\n            assert_eq!(\"hoge\", s);\n        }\n    }\n    #[macro_use]\n    pub mod prelude {\n        use std::fmt;\n        use std::iter::FromIterator;\n        use std::ops::*;\n\n        /// `Vec` indexable with `i32`, `i64` or `usize`.\n        #[derive(Clone, Debug, PartialEq, PartialOrd)]\n        pub struct MyVec<T>(pub Vec<T>);\n\n        /// Creates `MyVec`\n        #[macro_export]\n        macro_rules! v {\n    ( $( $x:expr ),* ) => {\n        MyVec(vec![ $( $x, )* ])\n    };\n    ( $x:expr ; $n:expr ) => {\n        {\n            MyVec(vec![$x; $n as usize])\n        }\n    };\n}\n\n        impl<T: fmt::Display> fmt::Display for MyVec<T> {\n            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                let n = self.len();\n                for i in 0..n {\n                    let r = if i < n - 1 {\n                        writeln!(f, \"{}\", self.0[i])\n                    } else {\n                        write!(f, \"{}\", self.0[i])\n                    };\n                    if r.is_err() {\n                        return r;\n                    }\n                }\n                Ok(())\n            }\n        }\n\n        impl<T> Deref for MyVec<T> {\n            type Target = Vec<T>;\n\n            #[inline]\n            fn deref(&self) -> &Vec<T> {\n                &self.0\n            }\n        }\n\n        impl<T> DerefMut for MyVec<T> {\n            #[inline]\n            fn deref_mut(&mut self) -> &mut Vec<T> {\n                &mut self.0\n            }\n        }\n\n        impl<T> FromIterator<T> for MyVec<T> {\n            #[inline]\n            fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n                MyVec(Vec::from_iter(iter))\n            }\n        }\n\n        impl<T, I: ToUsize> Index<I> for MyVec<T> {\n            type Output = T;\n\n            #[inline]\n            fn index(&self, i: I) -> &T {\n                &self.0[i.to_usize()]\n            }\n        }\n\n        impl<T, I: ToUsize> IndexMut<I> for MyVec<T> {\n            #[inline]\n            fn index_mut(&mut self, i: I) -> &mut T {\n                &mut self.0[i.to_usize()]\n            }\n        }\n\n        pub trait ToUsize: Sized {\n            fn to_usize(self) -> usize;\n        }\n\n        impl ToUsize for i32 {\n            #[inline]\n            fn to_usize(self) -> usize {\n                self as usize\n            }\n        }\n\n        impl ToUsize for i64 {\n            #[inline]\n            fn to_usize(self) -> usize {\n                self as usize\n            }\n        }\n\n        impl ToUsize for usize {\n            #[inline]\n            fn to_usize(self) -> usize {\n                self\n            }\n        }\n\n        #[test]\n        fn test_myvec() {\n            let mut x = v![3, 2, 1];\n            x.sort();\n            assert_eq!(vec![1, 2, 3], *x);\n            let i = 1i32;\n            assert_eq!(2, x[i]);\n            x[i] = 3;\n            assert_eq!(3, x[i]);\n            let u = 1usize;\n            assert_eq!(3, x[u]);\n            x[u] = 2;\n            assert_eq!(2, x[u]);\n            assert_eq!(2, x[1]);\n\n            assert_eq!(\"MyVec([1, 2, 3])\", format!(\"{:?}\", x));\n            assert_eq!(v![1, 2, 3], x);\n\n            assert_eq!(\"1\\n2\\n3\", format!(\"{}\", x));\n\n            let mut y = v![v![1, 2]; 3];\n            y[0][0] = 2;\n            assert_eq!(vec![2, 2], *y[0]);\n            assert_eq!(vec![1, 2], *y[1]);\n        }\n    }\n}\n//////////////////////////////// LIBRARY END ////////////////////////////////\n\nuse contest::io::Scanner;\nuse contest::prelude::MyVec;\nuse std::collections::BinaryHeap;\n\nfn main() {\n    let mut sc = Scanner::new(std::io::stdin());\n    let n = sc.next::<i32>();\n    let m = sc.next::<i32>();\n    let q = sc.next::<i32>();\n    let s = sc.next::<String>().chars().collect::<MyVec<char>>();\n    let t = sc.next::<String>().chars().collect::<MyVec<char>>();\n\n    let mut bottomLeft = v![-1; n];\n    let mut bottomRight = v![-1; n];\n    let mut upLeft = v![-1; n];\n    let mut upRight = v![-1; n];\n    for i in 0..n {\n        if s[i] == 'W' {\n            upLeft[i] = i;\n            if i > 0 {\n                upRight[i] = upRight[i - 1];\n            }\n        } else {\n            upRight[i] = i;\n            if i > 0 {\n                upLeft[i] = upLeft[i - 1];\n            }\n        }\n    }\n    for i in (0..n).rev() {\n        if s[i] == 'W' {\n            bottomLeft[i] = i;\n            if i + 1 < n {\n                bottomRight[i] = bottomRight[i + 1];\n            }\n        } else {\n            bottomRight[i] = i;\n            if i + 1 < n {\n                bottomLeft[i] = bottomLeft[i + 1];\n            }\n        }\n    }\n\n    let mut leftUp = v![-1; m];\n    let mut leftDown = v![-1; m];\n    let mut rightUp = v![-1; m];\n    let mut rightDown = v![-1; m];\n    for i in 0..m {\n        if t[i] == 'N' {\n            leftUp[i] = i;\n            if i > 0 {\n                leftDown[i] = leftDown[i - 1];\n            }\n        } else {\n            leftDown[i] = i;\n            if i > 0 {\n                leftUp[i] = leftUp[i - 1];\n            }\n        }\n    }\n    for i in (0..m).rev() {\n        if t[i] == 'N' {\n            rightUp[i] = i;\n            if i + 1 < m {\n                rightDown[i] = rightDown[i + 1];\n            }\n        } else {\n            rightDown[i] = i;\n            if i + 1 < m {\n                rightUp[i] = rightUp[i + 1];\n            }\n        }\n    }\n\n    for _ in 0..q {\n        let a = sc.next::<i32>() - 1;\n        let b = sc.next::<i32>() - 1;\n        let c = sc.next::<i32>() - 1;\n        let d = sc.next::<i32>() - 1;\n\n        let mut rows = v![];\n        let mut cols = v![];\n\n        push(&mut rows, (upRight[a], 'R'));\n        push(&mut rows, (upRight[a], 'R'));\n        push(&mut rows, (upRight[c], 'R'));\n        push(&mut rows, (bottomRight[a], 'R'));\n        push(&mut rows, (bottomRight[c], 'R'));\n        push(&mut rows, (upLeft[a], 'L'));\n        push(&mut rows, (upLeft[c], 'L'));\n        push(&mut rows, (bottomLeft[a], 'L'));\n        push(&mut rows, (bottomLeft[c], 'L'));\n\n        push(&mut cols, (leftUp[b], 'U'));\n        push(&mut cols, (leftUp[d], 'U'));\n        push(&mut cols, (rightUp[b], 'U'));\n        push(&mut cols, (rightUp[d], 'U'));\n        push(&mut cols, (leftDown[b], 'D'));\n        push(&mut cols, (leftDown[d], 'D'));\n        push(&mut cols, (rightDown[b], 'D'));\n        push(&mut cols, (rightDown[d], 'D'));\n\n        rows.sort();\n        cols.sort();\n\n        rows.dedup();\n        cols.dedup();\n\n        let mut startX = 10;\n        let mut startY = 10;\n        let mut goalX = 10;\n        let mut goalY = 10;\n        for i in 0..rows.len() {\n            if rows[i].0 == a {\n                startX = i;\n            }\n            if rows[i].0 == c {\n                goalX = i;\n            }\n        }\n        for i in 0..cols.len() {\n            if cols[i].0 == b {\n                startY = i;\n            }\n            if cols[i].0 == d {\n                goalY = i;\n            }\n        }\n\n        let inf = 1_000_000_000;\n        let mut dist = v![v![inf; 8]; 8];\n        let mut q = BinaryHeap::new();\n        q.push((inf - 0, startX, startY));\n        while !q.is_empty() {\n            let (dd, x, y) = q.pop().unwrap();\n            if dist[x][y] < inf {\n                continue;\n            }\n            dist[x][y] = inf - dd;\n            if rows[x].1 == 'L' {\n                if y > 0 {\n                    let d = cols[y].0 - cols[y - 1].0;\n                    q.push((dd - d, x, y - 1));\n                }\n            } else {\n                if y + 1 < cols.len() {\n                    let d = cols[y + 1].0 - cols[y].0;\n                    q.push((dd - d, x, y + 1));\n                }\n            }\n            if cols[y].1 == 'U' {\n                if x > 0 {\n                    let d = rows[x].0 - rows[x - 1].0;\n                    q.push((dd - d, x - 1, y));\n                }\n            } else {\n                if x + 1 < rows.len() {\n                    let d = rows[x + 1].0 - rows[x].0;\n                    q.push((dd - d, x + 1, y));\n                }\n            }\n        }\n        let res = dist[goalX][goalY];\n        if res == inf {\n            println!(\"-1\");\n        } else {\n            println!(\"{}\", res);\n        }\n    }\n}\n\nfn push(rows: &mut Vec<(i32, char)>, (x, d): (i32, char)) {\n    if x >= 0 {\n        rows.push((x, d));\n    }\n}\n"
  }
]