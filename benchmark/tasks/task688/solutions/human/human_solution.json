[
  {
    "language": "Scala",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\n#define MP make_pair\n#define fi first\n#define se second\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\nconst int N = 100003, M = 1024, mod = 998244353;\ntemplate<typename T>\nvoid read(T &x){\n\tint ch = getchar(); x = 0; bool f = false;\n\tfor(;ch < '0' || ch > '9';ch = getchar()) f |= ch == '-';\n\tfor(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';\n\tif(f) x = -x;\n}\nvoid qmo(int &x){x += (x >> 31) & mod;}\nint ksm(int a, int b){\n\tint res = 1;\n\tfor(;b;b >>= 1, a = (LL) a * a % mod) if(b & 1) res = (LL) res * a % mod;\n\treturn res;\n}\ntemplate<typename T>\ninline bool chmax(T &a, const T &b){if(a < b) return a = b, 1; return 0;}\ntemplate<typename T>\ninline bool chmin(T &a, const T &b){if(a > b) return a = b, 1; return 0;}\nint n, m, head[N], to[N], nxt[N], cnt, f[3][M], sg[N], pw[N], ans; bool vis[N];\nvoid add(int a, int b){\n\tto[++ cnt] = b; nxt[cnt] = head[a]; head[a] = cnt;\n}\nvoid solve(int t){\n\tcnt = 0; read(m);\n\tfor(Rint i = 1;i <= n;++ i) head[i] = sg[i] = 0;\n\tfor(Rint i = 1, u, v;i <= m;++ i){\n\t\tread(u); read(v); if(u > v) swap(u, v); add(u, v);\n\t}\n\tfor(Rint i = n;i;-- i){\n\t\tfor(Rint j = head[i];j;j = nxt[j]) vis[sg[to[j]]] = true;\n\t\tfor(;vis[sg[i]];++ sg[i]); qmo(f[t][sg[i]] += pw[i] - mod);\n\t\tfor(Rint j = head[i];j;j = nxt[j]) vis[sg[to[j]]] = false;\n\t}\n}\nint main(){\n\tread(n); pw[0] = 1; pw[1] = 716070898;\n\tfor(Rint i = 2;i <= n;++ i) pw[i] = (LL) pw[i-1] * pw[1] % mod;\n\tfor(Rint t = 0;t < 3;++ t) solve(t);\n\tfor(Rint i = 0;i < M;++ i)\n\t\tfor(Rint j = 0;j < M;++ j)\n\t\t\tqmo(ans += (LL) f[0][i] * f[1][j] % mod * f[2][i^j] % mod - mod);\n\tprintf(\"%d\\n\", ans);\n} // NTFTWFX"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 1;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  long long backup[3], primary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    vector<bool> usable(N+1, true);\n    vector<bool> used(N+1, false);\n    long long ret_g = 0;\n    for(int ctr = N; ctr>0; --ctr) {\n      if(usable[ctr]) {\n        used[ctr] = true;\n        primary[graph] = (primary[graph] + pows[ctr]) % MOD;\n        for(int i = 0; i<adj[ctr].size(); ++i) {\n          usable[adj[ctr][i]] = false;\n        }\n      }\n    }\n    usable.assign(N+1, true);\n    for(int ctr = N; ctr>0; --ctr) {\n      if(usable[ctr] && !used[ctr]) {\n        backup[graph] = (backup[graph] + pows[ctr]) % MOD;\n        for(int i = 0; i<adj[ctr].size(); ++i) {\n          usable[adj[ctr][i]] = false;\n        }\n      }\n    }\n\n    ret = (ret * primary[graph]) % MOD;\n  }\n\n  ret = (ret + ((backup[0] * backup[1])%MOD) * primary[2] + ((backup[0] * primary[1])%MOD) * backup[2] + ((primary[0] * backup[1])%MOD) * backup[2]) % MOD;\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;    \n    vector<vector<int>> E[3];\n    for (int i=0; i<3; i++)\n    {\n        int M;\n        cin>>M;\n        E[i].resize(N);\n        for (int j=0; j<M; j++)\n        {\n            int a, b;\n            cin>>a>>b;\n            E[i][a-1].push_back(b-1);\n            E[i][b-1].push_back(a-1);\n        }\n    }\n\n    vector<int> G[3];\n    set<int> S;\n    for (int i=0; i<3; i++)\n    {\n        G[i] = vector<int>(N);\n        for (int j=N-1; j>=0; j--)\n        {\n            S.clear();\n            for (int e: E[i][j])\n                if (e>j)\n                    S.insert(G[i][e]);\n            for (int k=0; ; k++)\n                if (S.count(k)==0)\n                {\n                    G[i][j] = k;\n                    break;\n                }\n        }\n    }\n\n    long long M = 998244353LL;\n    vector<long long> P10(N+1);\n    P10[0] = 1;\n    for (int i=1; i<=N; i++)\n        P10[i] = P10[i-1]*(1000000000000000000%M)%M;\n\n    vector<long long> GS[3];\n    int MG[3];\n    for (int i=0; i<3; i++)\n    {\n        GS[i] = vector<long long>(N);\n        for (int j=0; j<N; j++)\n        {\n            GS[i][G[i][j]] += P10[j+1];\n            GS[i][G[i][j]] %= M;\n            MG[i] = max(MG[i], G[i][j]);\n        }\n    }\n\n    long long ans = 0;\n    for (int i=0; i<=MG[0]; i++)\n        for (int j=0; j<=MG[1]; j++)\n        {\n            int k = i^j;\n            if (k<=MG[2])\n            {\n                ans += GS[0][i]*GS[1][j]%M*GS[2][k]%M;\n                ans %= M;\n            }\n        }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), end(x))\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int DX[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\ntemplate<typename T> void fft(std::vector<T> &x, const std::vector<T> &w) {\n    int n = x.size();\n    int m = n >> 1;\n    std::vector<T> y(n);\n    for (int i = 1; i <= m; i <<= 1) {\n        for (int j = 0; j < m; j += i) {\n            for (int k = 0; k < i; k++) {\n                int u = j + k;\n                y[(u << 1) + 0] = (x[u + 0] + x[u + m]);\n                y[(u << 1) + 1] = (x[u + 0] - x[u + m]) * w[j];\n            }\n        }\n        std::swap(x, y);\n    }\n}\n\ntemplate<typename T> void ifft(std::vector<T> &x, const std::vector<T> &w) {\n    int n = x.size();\n    int m = n >> 1;\n    std::vector<T> y(n);\n    for (int i = m; i > 0; i >>= 1) {\n        for (int j = 0; j < m; j += i) {\n            for (int k = 0; k < i; k++) {\n                int u = j + k;\n                x[(u << 1) + 1] *= w[j];\n                y[u + 0] = x[(u << 1) + 0] + x[(u << 1) + 1];\n                y[u + m] = x[(u << 1) + 0] - x[(u << 1) + 1];\n            }\n        }\n        std::swap(x, y);\n    }\n    T n_inv = T(1) / n;\n    for (int i = 0; i < n; i++) { x[i] *= n_inv; }\n}\n\ntemplate<int MOD, int ROOT>\nstd::vector<int> friendly_mod_convolute(const std::vector<int> &a, const std::vector<int> &b) {\n    int n_a = a.size(), n_b = b.size();\n    int n_ = n_a + n_b - 1, n;\n    for (n = 1; n < n_; n <<= 1) {}\n    int m = n >> 1;\n    std::vector<mod_int<MOD>> a_mint(n), b_mint(n), w(m + 2);\n    std::copy(a.begin(), a.end(), a_mint.begin()), std::copy(b.begin(), b.end(), b_mint.begin());\n    w[0] = 1, w[1] = mod_int<MOD>(ROOT).pow((MOD - 1) / n);\n    for (int i = 2; i < m; i++) { w[i] = w[i - 1] * w[1]; }\n    fft(a_mint, w);\n    fft(b_mint, w);\n    for (int i = 0; i < n; i++) { a_mint[i] *= b_mint[i]; }\n    w[1] = w[1].inv();\n    for (int i = 2; i < m; i++) { w[i] = w[i - 1] * w[1]; }\n    ifft(a_mint, w);\n    std::vector<int> ret(n_);\n    for (int i = 0; i < n_; i++) { ret[i] = a_mint[i].val; }\n    return ret;\n}\n\nconstexpr int MOD = 998244353, ROOT = 3;\nusing mint = mod_int<MOD>;\nsigned main() {\n    int N;\n    int M1, M2, M3;\n    cin >> N;\n    vvint Gx(N), Gy(N), Gz(N);\n    cin >> M1;\n    rep(i, M1) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        if (a > b) { swap(a, b); }\n        Gx[a].push_back(b);\n    }\n    cin >> M2;\n    rep(i, M2) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        if (a > b) { swap(a, b); }\n        Gy[a].push_back(b);\n    }\n    cin >> M3;\n    rep(i, M3) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        if (a > b) { swap(a, b); }\n        Gz[a].push_back(b);\n    }\n    vint ex(N), ey(N), ez(N);\n    vint ox(N), oy(N), oz(N);\n    for (int i = N - 1; i >= 0; i--) {\n        set<bool> st;\n        rep(j, Gx[i].size()) {\n            if (ex[Gx[i][j]]) { st.insert(0); }\n            if (ox[Gx[i][j]]) { st.insert(1); }\n        }\n        if (st.size() == 0) { ox[i] = 1; }\n        if (st.size() == 1) {\n            if (*st.begin() == 0) { ox[i] = 1; }\n            else { ex[i] = 1; }\n        }\n    }\n    for (int i = N - 1; i >= 0; i--) {\n        set<bool> st;\n        rep(j, Gy[i].size()) {\n            if (ey[Gy[i][j]]) { st.insert(0); }\n            if (oy[Gy[i][j]]) { st.insert(1); }\n        }\n        if (st.size() == 0) { oy[i] = 1; }\n        if (st.size() == 1) {\n            if (*st.begin() == 0) { oy[i] = 1; }\n            else { ey[i] = 1; }\n        }\n    }\n    for (int i = N - 1; i >= 0; i--) {\n        set<bool> st;\n        rep(j, Gz[i].size()) {\n            if (ez[Gz[i][j]]) { st.insert(0); }\n            if (oz[Gz[i][j]]) { st.insert(1); }\n        }\n        if (st.size() == 0) { oz[i] = 1; }\n        if (st.size() == 1) {\n            if (*st.begin() == 0) { oz[i] = 1; }\n            else { ez[i] = 1; }\n        }\n    }\n    vint v111 = friendly_mod_convolute<MOD, ROOT>(friendly_mod_convolute<MOD, ROOT>(ox, oy), oz);\n    vint v100 = friendly_mod_convolute<MOD, ROOT>(friendly_mod_convolute<MOD, ROOT>(ox, ey), ez);\n    vint v010 = friendly_mod_convolute<MOD, ROOT>(friendly_mod_convolute<MOD, ROOT>(ex, oy), ez);\n    vint v001 = friendly_mod_convolute<MOD, ROOT>(friendly_mod_convolute<MOD, ROOT>(ex, ey), oz);\n    mint ans = 0;\n    rep(i, 3 * N - 2) {\n        ans += mint(10).pow(18 * (i + 3)) * (v111[i] + v100[i] + v010[i] + v001[i]);\n    }\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\nconst num BASE(int64_t(1e18));\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nvoid slow() {\n\tint N; cin >> N;\n\tvector<vector<vector<int>>> adj(3, vector<vector<int>>(N));\n\tfor (int z = 0; z < 3; z++) {\n\t\tint M; cin >> M;\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tint u, v; cin >> u >> v; u--, v--;\n\t\t\tassert(u != v);\n\t\t\tif (u > v) swap(u, v);\n\t\t\tassert(u < v);\n\t\t\tadj[z][u].push_back(v);\n\t\t}\n\t}\n\tnum ans = 0;\n\tvector<vector<vector<bool>>> take(N, vector<vector<bool>>(N, vector<bool>(N, false)));\n\tfor (int s = 3*(N-1); s >= 0; s--) {\n\t\tfor (int x = 0; x < N; x++) {\n\t\t\tfor (int y = 0; y < N; y++) {\n\t\t\t\tint z = s-x-y;\n\t\t\t\tif (0 <= z && z < N) {\n\t\t\t\t\ttake[x][y][z] = true;\n\t\t\t\t\tfor (int x2 : adj[0][x]) {\n\t\t\t\t\t\tif (take[x2][y][z]) take[x][y][z] = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int y2 : adj[1][y]) {\n\t\t\t\t\t\tif (take[x][y2][z]) take[x][y][z] = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int z2 : adj[2][z]) {\n\t\t\t\t\t\tif (take[x][y][z2]) take[x][y][z] = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (take[x][y][z]) {\n\t\t\t\t\t\tcerr << x+1 << ' ' << y+1 << ' ' << z+1 << '\\n';\n\t\t\t\t\t\tans += pow(BASE, x+y+z+3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<num> cost(N);\n\tcost[0] = BASE;\n\tfor (int i = 1; i < N; i++) cost[i] = cost[i-1] * BASE;\n\n\tconst int LG = 9;\n\tconst int S = 1 << LG;\n\n\tvector<num> ans(S, 1);\n\n\tfor (int z = 0; z < 3; z++) {\n\t\tint M; cin >> M;\n\t\tvector<vector<int>> adj(N);\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tint u, v; cin >> u >> v; u--, v--;\n\t\t\tassert(u != v);\n\t\t\tif (u > v) swap(u, v);\n\t\t\tassert(u < v);\n\t\t\tadj[u].push_back(v);\n\t\t}\n\n\t\tvector<num> cnt(S);\n\t\tvector<int> nimber(N);\n\t\tfor (int i = N-1; i >= 0; i--) {\n\t\t\tset<int> s;\n\t\t\tfor (int j : adj[i]) {\n\t\t\t\ts.insert(nimber[j]);\n\t\t\t}\n\t\t\tnimber[i] = 0;\n\t\t\twhile (s.count(nimber[i])) nimber[i]++;\n\t\t\tcnt[nimber[i]] += cost[i];\n\t\t}\n\t\tfor (int l = 0; l < LG; l++) {\n\t\t\tfor (int m = 0; m < S; m++) {\n\t\t\t\tif (m & (1<<l)) continue;\n\t\t\t\tnum s = cnt[m | (1<<l)];\n\t\t\t\tnum a = cnt[m];\n\t\t\t\tcnt[m] = a+s;\n\t\t\t\tcnt[m|(1<<l)] = a-s;\n\t\t\t}\n\t\t}\n\n\t\tfor (int m = 0; m < S; m++) {\n\t\t\tans[m] *= cnt[m];\n\t\t}\n\t}\n\n\tfor (int l = 0; l < LG; l++) {\n\t\tfor (int m = 0; m < S; m++) {\n\t\t\tif (m & (1<<l)) continue;\n\t\t\tnum s = ans[m | (1<<l)];\n\t\t\tnum a = ans[m];\n\t\t\tans[m] = (a+s)/2;\n\t\t\tans[m|(1<<l)] = (a-s)/2;\n\t\t}\n\t}\n\n\n\tcout << ans[0] << '\\n';\n\n\treturn 0;\n}\n\n// sample2:\n// 3,31,32\n//\n// 3,3,3\n// 3,3,2\n// 2,2,3\n// 3,1,3\n// 2,2,2\n// 3,1,2\n// 3,2,1\n// 2,3,1\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstring>\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\ntypedef long long ll;\nconst int Mod=998244353;\n\nint n,m;\nint p[100010];\n\nint f[100010];\nint find(int x){return f[x]?f[x]=find(f[x]):x;}\nint a[2],b[2],c[2];\nstruct Edge{\n\tint to,nxt;\n}edge[200010];\nint cnt,last[100010];\ninline void addedge(int x,int y){\n\tedge[++cnt]=(Edge){y,last[x]},last[x]=cnt;\n\tedge[++cnt]=(Edge){x,last[y]},last[y]=cnt;\n\tx=find(x),y=find(y); if (x^y) f[min(x,y)]=max(x,y);\n}\nint que[100010],hd,tl; int dep[100010];\ninline void add(int &x,int y){x=(x+y)%Mod;}\nint main()\n{\n\tn=read(); p[0]=1; p[1]=1000000000000000000LL%Mod;\n\tfor (int i=2;i<=n;i++) p[i]=1LL*p[i-1]*p[1]%Mod;\n\t\n\tmemset(f+1,0,n*sizeof(int));\n\tm=read(); cnt=1; memset(last+1,0,n*sizeof(int));\n\tfor (int i=1;i<=m;i++) addedge(read(),read());\n\thd=tl=0; memset(dep+1,-1,n*sizeof(int));\n\tfor (int i=1;i<=n;i++) if (find(i)==0||find(i)==i) que[++tl]=i,dep[i]=0;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v; add(a[dep[u]&1],p[u]);\n//\t\tprintf(\"A %d\\n\",dep[u]);\n\t\tfor (int i=last[u];i;i=edge[i].nxt)\n\t\t\tif (!~dep[v=edge[i].to]){\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tque[++tl]=v;\n\t\t\t}\n\t}\n\t\n\tmemset(f+1,0,n*sizeof(int));\n\tm=read(); cnt=1; memset(last+1,0,n*sizeof(int));\n\tfor (int i=1;i<=m;i++) addedge(read(),read());\n\thd=tl=0; memset(dep+1,-1,n*sizeof(int));\n\tfor (int i=1;i<=n;i++) if (find(i)==0||find(i)==i) que[++tl]=i,dep[i]=0;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v; add(b[dep[u]&1],p[u]);\n//\t\tprintf(\"B %d\\n\",dep[u]);\n\t\tfor (int i=last[u];i;i=edge[i].nxt)\n\t\t\tif (!~dep[v=edge[i].to]){\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tque[++tl]=v;\n\t\t\t}\n\t}\n\t\n\tmemset(f+1,0,n*sizeof(int));\n\tm=read(); cnt=1; memset(last+1,0,n*sizeof(int));\n\tfor (int i=1;i<=m;i++) addedge(read(),read());\n\thd=tl=0; memset(dep+1,-1,n*sizeof(int));\n\tfor (int i=1;i<=n;i++) if (find(i)==0||find(i)==i) que[++tl]=i,dep[i]=0;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v; add(c[dep[u]&1],p[u]);\n//\t\tprintf(\"C %d\\n\",dep[u]);\n\t\tfor (int i=last[u];i;i=edge[i].nxt)\n\t\t\tif (!~dep[v=edge[i].to]){\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tque[++tl]=v;\n\t\t\t}\n\t}\n\t\n\tint ans=0;\n\tfor (int i=0;i<2;i++)\n\t\tfor (int j=0;j<2;j++)\n\t\t\tfor (int k=0;k<2;k++)\n\t\t\t\tif (i^j^k^1) ans=(ans+1LL*a[i]*b[j]%Mod*c[k])%Mod;\n\tprintf(\"%d\\n\",(ans+Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n\ttemplate<class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator () (a...); }\n} read;\n\nconst int maxn = 200005, mod = 998244353;\nstd::vector<int> G[maxn];\nint sg[3][maxn];\nll f[3][maxn], g[maxn];\nll po[maxn * 3];\n\ninline ll power(ll x, int k) {\n\tif(k < 0) k += mod - 1;\n\tll res = 1;\n\twhile(k) {\n\t\tif(k & 1) (res *= x) %= mod;\n\t\t(x *= x) %= mod;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\nvoid FWT (ll *a, int n) {\n\tfor (int m = 1; m < n; m <<= 1)\n\t\tfor (int i = 0; i < n; i += m << 1)\n\t\t\tfor (int k = i; k < i + m; k ++) {\n\t\t\tll x = a[k], y = a[k + m];\n\t\t\t(a[k] = x + y) %= mod;\n\t\t\t(a[k + m] = x + mod - y) %= mod;\n\t\t}\n}\n\nvoid iFWT (ll *a, int n) {\n\tfor (int m = 1; m < n; m <<= 1)\n\t\tfor (int i = 0; i < n; i += m << 1)\n\t\t\tfor (int k = i; k < i + m; k ++) {\n\t\t\tll x = a[k], y = a[k + m];\n\t\t\t(a[k] = x + y) %= mod;\n\t\t\t(a[k + m] = x + mod - y) %= mod;\n\t\t\t(a[k] *= (mod + 1) >> 1) %= mod;\n\t\t\t(a[k + m] *= (mod + 1) >> 1) %= mod;\n\t\t}\n}\n\nint main () {\n\tint n = read, len = 1;\n\twhile (len < n)\n\t\tlen <<= 1;\n\n\tpo[0] = 1;\n\tll bs = 1000000000000000000ll % mod;\n\t/* ll bs = 10; */\n\tfor (int i = 1; i <= n * 3; i ++)\n\t\tpo[i] = po[i - 1] * bs % mod;\n\n\tfor (int o = 0; o < 3; o ++) {\n\t\tint m = read;\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tG[i].clear();\n\t\tfor (int i = 1; i <= m; i ++) {\n\t\t\tint u = read, v = read;\n\t\t\tif (u < v) G[u].push_back(v);\n\t\t\tif (v < u) G[v].push_back(u);\n\t\t}\n\t\tfor (int i = n; i; i --) {\n\t\t\tif (!G[i].empty()) {\n\t\t\t\tstd::set<int> mex;\n\t\t\t\tfor (int j : G[i])\n\t\t\t\t\tmex.insert(sg[o][j]);\n\t\t\t\twhile(mex.count(sg[o][i]))\n\t\t\t\t\t++ sg[o][i];\n\t\t\t}\n\t\t\t/* debug(\"%d\\n\", sg[o][i]); */\n\t\t}\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\t(f[o][sg[o][i]] += po[i]) %= mod;\n\t\t/* for (int i = 0; i < len; i ++) */\n\t\t/* \tdebug(\" %lld\", f[o][i]); */\n\t\t/* debug(\"\\n\"); */\n\t\tFWT(f[o], len);\n\t}\n\n\tfor (int i = 0; i < len; i ++)\n\t\tg[i] = f[0][i] * f[1][i] % mod * f[2][i] % mod;\n\tiFWT(g, len);\n\n\tll ans = g[0];\n\t/* for (int i = 1; i < len; i ++) */\n\t/* \tans += g[i]; */\n\t/* ans %= mod; */\n\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=998244353;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tint i,j,n;cin>>n;\n\tllint S=1000000000000000000LL%mod;\n\t\n\t\n\tvector<llint>kei(n);\n\tkei[0]=S;\n\tfor(i=0;i<n-1;i++){kei[i+1]=kei[i]*S%mod;}\n\tllint L=512;\n\t//cerr<<\"L=\"<<L<<endl;\n\tvector<llint>ans(L);ans[0]=1;\n\tfor(int kai=0;kai<3;kai++){\n\t\tint m;cin>>m;\n\t\tvector<vector<int>>go(n);\n\t\twhile(m--){\n\t\t\tint a,b;cin>>a>>b;a--;b--;\n\t\t\tif(a<b){swap(a,b);}\n\t\t\tgo[b].pub(a);\n\t\t}\n\t\tvector<int>gru(n);\n\t\tvector<int>hyo(L,mod);\n\t\tvector<llint>gen(L,0);\n\t\tfor(i=n-1;i>=0;i--){\n\t\t\tfor(auto it:go[i]){hyo[gru[it]]=i;}\n\t\t\tint g=0;\n\t\t\twhile(hyo[g]==i){g++;}\n\t\t\tgru[i]=g;\n\t\t\tgen[g]+=kei[i];gen[g]%=mod;\n\t\t}\n\t\tvector<llint>dp(L,0);\n\t\tfor(i=0;i<L;i++){\n\t\t\t//cerr<<gen[i]<<endl;\n\t\t\tfor(j=0;j<L;j++){\n\t\t\t\tdp[i^j]+=ans[i]*gen[j];\n\t\t\t\tdp[i^j]%=mod;\n\t\t\t}\n\t\t}\n\t\tans=dp;\n\t}\n\tcout<<ans[0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nconst int MOD = 998244353;\nconst long long w = ((long long)1e18)%MOD;\nlong long wpow[101010];\n\nvector<long long> solve(vector<pair<int, int> > V)\n{\n    vector<vector<int> > conn(N+1);\n    vector<int> sidx(N+1);\n    vector<long long> ret(N);\n    for(auto x: V)\n    {\n        int u, v; tie(u, v) = x;\n        conn[u].push_back(v);\n        conn[v].push_back(u);\n    }\n    for(int i=N; i>=1; --i)\n    {\n        set<int> S;\n        for(auto x: conn[i])\n            S.insert(sidx[x]);\n        for(int t=1; t<=N; ++t)\n            if(S.count(t) == 0)\n            {\n                sidx[i] = t;\n                ret[t-1] = ret[t-1] + wpow[i];\n                if(ret[t-1] >= MOD) ret[t-1] -= MOD;\n                break;\n            }\n    }\n    while(ret.back() == 0) ret.pop_back();\n    return ret;\n}\nint main()\n{\n    scanf(\"%d\", &N);\n    wpow[0] = 1;\n    for(int i=1; i<=N; ++i)\n        wpow[i] = wpow[i-1]*w%MOD;\n    vector<vector<long long> > Q;\n    for(int i=0; i<3; ++i)\n    {\n        vector<pair<int, int> > V;\n        int M; scanf(\"%d\", &M);\n        for(int j=0; j<M; ++j)\n        {\n            int u, v; scanf(\"%d%d\", &u, &v);\n            V.emplace_back(u, v);\n        }\n        Q.push_back(solve(V));\n    }\n    int maxi = max({Q[0].size(), Q[1].size(), Q[2].size()});\n    vector<vector<bool>> adj(maxi+1, vector<bool>(maxi+1, false));\n    long long ans = 0;\n    auto add_ans = [&](int a, int b, int c)\n    {\n        //cerr << a << \" \" << b << \" \" << c << endl;\n        //printf(\"%d %d %d\\n\", a, b, c);\n        --a; --b; --c;\n        if(a<(int)Q[0].size() && b<(int)Q[1].size() && c<(int)Q[2].size())\n            ans += Q[0][a]*Q[1][b]%MOD*Q[2][c]%MOD;\n        if(b!=c && a<(int)Q[0].size() && c<(int)Q[1].size() && b<(int)Q[2].size())\n            ans += Q[0][a]*Q[1][c]%MOD*Q[2][b]%MOD;\n        if(a!=b && b<(int)Q[0].size() && a<(int)Q[1].size() && c<(int)Q[2].size())\n            ans += Q[0][b]*Q[1][a]%MOD*Q[2][c]%MOD;\n        if(a!=b && b<(int)Q[0].size() && c<(int)Q[1].size() && a<(int)Q[2].size())\n            ans += Q[0][b]*Q[1][c]%MOD*Q[2][a]%MOD;\n        if(b!=c && c<(int)Q[0].size() && a<(int)Q[1].size() && b<(int)Q[2].size())\n            ans += Q[0][c]*Q[1][a]%MOD*Q[2][b]%MOD;\n        if(a!=b && b!=c && c<(int)Q[0].size() && b<(int)Q[1].size() && a<(int)Q[2].size())\n            ans += Q[0][c]*Q[1][b]%MOD*Q[2][a]%MOD;\n        ans %= MOD;\n    };\n    for(int i=1; i<=maxi; ++i)\n    {\n        add_ans(1, i, i);\n        adj[i][i] = true;\n    }\n    for(int i=2; i<=maxi; ++i)\n    {\n        for(int j=i+1; j<=maxi; ++j)\n        {\n            if(adj[i][j]) continue;\n            for(int k=j+1; k<=maxi; ++k)\n            {\n                if(!adj[j][k] && !adj[i][k])\n                {\n                    adj[j][k] = adj[k][j] = true;\n                    adj[i][j] = adj[j][i] = true;\n                    adj[i][k] = adj[k][i] = true;\n                    add_ans(i, j, k);\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define mod 998244353\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint n,lim;\nstruct qaq{\n\tint SG[100010],yes[100010],cnt[1020];\n\tint fir[100010],dis[100010],nxt[100010],id;\n\tvoid input(){\n\t\tint m=gi(),a,b;\n\t\twhile(m--){\n\t\t\ta=gi(),b=gi();if(a>b)std::swap(a,b);\n\t\t\tnxt[++id]=fir[a],fir[a]=id,dis[id]=b;\n\t\t}\n\t\tfor(int i=n;i;--i){\n\t\t\tfor(int j=fir[i];j;j=nxt[j])yes[SG[dis[j]]]=1;\n\t\t\twhile(yes[SG[i]])++SG[i];\n\t\t\tfor(int j=fir[i];j;j=nxt[j])yes[SG[dis[j]]]=0;\n\t\t}\n\t\tfor(int i=1,p=716070898;i<=n;++i,p=716070898ll*p%mod)inc(cnt[SG[i]],p),cxk(lim,SG[i]);\n\t}\n}A,B,C;\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tn=gi();\n\tA.input();B.input();C.input();\n\tint ans=0;\n\tfor(int i=0;i<=lim;++i)\n\t\tfor(int j=0;j<=lim;++j)\n\t\t\tinc(ans,1ll*A.cnt[i]*B.cnt[j]%mod*C.cnt[i^j]%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int MOD = 998244353;\n\nvoid sadd(int &a, int b)\n{\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\nint add(int a, int b)\n{\n    sadd(a, b);\n    return a;\n}\nint mul(int a, int b)\n{\n    return (a * 1LL * b) % MOD;\n}\n\nint fpow(int x, int n)\n{\n    if (n == 0)\n        return 1;\n    int a = fpow(x, n >> 1);\n    a = mul(a, a);\n    if (n & 1)\n        a = mul(a, x);\n    return a;\n}\n\n\nconst int N = (int) 1e5 + 100;\nvector <int> g[N];\nint used[N];\nint val[3][N];\n\nvoid solve(int t, int n)\n{\n    for (int i = 0; i <= n; i++)\n    {\n        used[i] = 0;\n        g[i].clear();\n    }\n    int m;\n    scanf(\"%d\", &m);\n\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        if (a > b) swap(a, b);\n        g[a].push_back(b);\n    }\n\n    set <int> s;\n    for (int i = n; i >= 1; i--)\n    {\n        s.clear();\n        for (int to : g[i])\n            s.insert(used[to]);\n        while (s.count(used[i]))\n            used[i]++;\n        int x = fpow(10, 18 * i);\n        sadd(val[t][used[i]], x);\n    }\n}\n\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int n;\n    scanf(\"%d\", &n);\n\n    int ans = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        solve(i, n);\n    }\n    \n    sadd(ans, mul(val[0][0], mul(val[1][0], val[2][0])));\n\n    for (int i = 1; i < n; i++)\n    {\n        sadd(ans, mul(val[0][0], mul(val[1][i], val[2][i])));\n        sadd(ans, mul(val[0][i], mul(val[1][0], val[2][i])));\n        sadd(ans, mul(val[0][i], mul(val[1][i], val[2][0])));\n    }\n    \n    \n    printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 100005;\nconst ll t18 = 1000'000'000'000'000'000;\n\nconst int MOD = 998244353;\n\ninline ll mul(ll a, ll b)\n{\n\treturn (a * b) % MOD;\n}\n\ninline ll add(ll a, ll b)\n{\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\ninline ll sub(ll a, ll b)\n{\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\ninline ll powmod(ll a, ll b)\n{\n\tll ans = 1;\n\tll tmp = a;\n\twhile (b)\n\t{\n\t\tif (b & 1) ans = mul(ans, tmp);\n\t\ttmp = mul(tmp, tmp);\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\ninline int inv(ll a)\n{\n\treturn powmod(a, MOD - 2);\n}\n\nint v[3][maxn];\nvector<int> gr[maxn];\nint was[maxn];\nint p10[3 * maxn];\nint kwas;\nint n;\nll a[3][2 * maxn];\nll b[2 * maxn];\n\nvoid transform(ll *from, ll *to) \n{ \n    if(to - from == 1) \n        return; \n    ll *mid = from + (to - from) / 2; \n    transform(from, mid); \n    transform(mid, to); \n    for(int i = 0; i < mid - from; i++) \n    {\n        ll a = *(from + i);\n        ll b = *(mid + i);\n        *(from + i) = add(a, b);\n        *(mid + i) = sub(a, b);\n    }\n} \n\nint main()\n{\n\tp10[0] = 1;\n\tfor (int i = 1; i < 3 * maxn; i++) p10[i] = mul(p10[i - 1], t18 % MOD);\n\tscanf(\"%d\", &n);\n\tint np2 = n;\n\twhile (np2 & (np2 - 1)) np2++;\n\t//cout << np2 << endl;\n\tfor (int T = 0; T < 3; T++)\n\t{\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 0; i < n; i++) gr[i].clear();\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\ta--, b--;\n\t\t\tgr[a].pb(b);\n\t\t\tgr[b].pb(a);\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t{\n\t\t\tsort(all(gr[i]));\n\t\t\tkwas++;\n\t\t\tfor (auto t : gr[i]) if (t > i) was[v[T][t]] = kwas;\n\t\t\tv[T][i] = 0;\n\t\t\twhile (was[v[T][i]] == kwas) v[T][i]++;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) a[T][v[T][i]] = add(a[T][v[T][i]], p10[i + 1]);\n\t\t//for (int i = 0; i < np2; i++) cout << a[T][i] << ' ';\n\t\t//cout << endl;\n\t\ttransform(a[T], a[T] + np2);\n\t\t//for (int i = 0; i < np2; i++) cout << a[T][i] << ' ';\n\t\t//cout << endl;\n\t}\n\t\n\tfor (int i = 0; i < np2; i++)\n\t{\n\t\tb[i] = mul(mul(a[0][i], a[1][i]), a[2][i]);\n\t}\n\ttransform(b, b + np2);\n\t//for (int i = 0; i < np2; i++) cout << b[i] << ' ';\n\t//cout << endl;\n\tll dby = inv(np2);\n\tfor (int i = 0; i < np2; i++) b[i] = mul(b[i], dby);\n\t//for (int i = 0; i < np2; i++) cout << b[i] << ' ';\n\t//cout << endl;\n\tcout << b[0] << endl;\n\t\n\t\n\t//int answer = 0;\n\t//for (int i = 0; i < n; i++)\n\t//{\n\t\t//for (int j = 0; j < n; j++)\n\t\t//{\n\t\t\t//for (int k = 0; k < n; k++) if ((v[0][i] ^ v[1][j] ^ v[2][k]) == 0)\n\t\t\t//{\n\t\t\t\t//answer = add(answer, p10[i + j + k + 3]);\n\t\t\t//}\n\t\t//}\n\t//}\n\t//cout << answer << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include<bits\\stdc++.h>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<ctime>\n#include<cmath>\n#include<cctype>\n#include<cstdlib>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<bitset>\n#include<set>\n#include<map>\n#define ll long long\n#define db double\n#define INF 10000000000000010ll\n#define ldb long double\n#define pb push_back\n#define put_(x) printf(\"%d \",x);\n#define get(x) x=read()\n#define gt(x) scanf(\"%d\",&x)\n#define gi(x) scanf(\"%lf\",&x)\n#define put(x) printf(\"%d\\n\",x)\n#define putl(x) printf(\"%lld\\n\",x)\n#define gc(a) scanf(\"%s\",a+1)\n#define rep(p,n,i) for(RE int i=p;i<=n;++i)\n#define go(x) for(int i=lin[x],tn=ver[i];i;tn=ver[i=nex[i]])\n#define fep(n,p,i) for(RE int i=n;i>=p;--i)\n#define vep(p,n,i) for(RE int i=p;i<n;++i)\n#define pii pair<int,int>\n#define mk make_pair\n#define RE register\n#define P 1000000007\n#define gf(x) scanf(\"%lf\",&x)\n#define pf(x) ((x)*(x))\n#define uint unsigned long long\n#define ui unsigned\n#define EPS 1e-8\n#define sq sqrt\n#define S second\n#define F first\n#define mod 998244353\nusing namespace std;\nchar buf[1<<15],*fs,*ft;\ninline char getc()\n{\n    return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;\n}\ninline int read()\n{\n    RE int x=0,f=1;RE char ch=getc();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getc();}\n    while(ch>='0'&&ch<='9'){x=((ll)x*10+ch-'0')%mod;ch=getc();}\n    return x*f;\n}\nconst int MAXN=100010,M=1000000000000000000ll%mod;\nint c[MAXN];int n,m;\ninline int add(int x,int y){return x=x+y>=mod?x+y-mod:x+y;}\ninline int mul(int x,int y){return (ll)x*y%mod;}\nstruct wy\n{\n\tint f[MAXN],g[MAXN],len;\n\tint lin[MAXN],ver[MAXN],nex[MAXN];\n\tinline void add(int x,int y)\n\t{\n\t\tver[++len]=y;\n\t\tnex[len]=lin[x];\n\t\tlin[x]=len;\n\t}\n\tinline void topsort()\n\t{\n\t\tfep(n,1,j)\n\t\t{\n\t\t\tgo(j)c[f[tn]]=1;\n\t\t\tint ww=0;\n\t\t\twhile(c[ww])++ww;\n\t\t\tf[j]=ww;\n\t\t\tgo(j)c[f[tn]]=0;\n\t\t}\n\t\tint ww=M;\n\t\trep(1,n,i)\n\t\t{\n\t\t\tg[f[i]]=(g[f[i]]+ww)%mod;\n\t\t\tww=mul(ww,M);\n\t\t\t//cout<<g[f[i]]<<' '<<ww<<endl;\n\t\t}\n\t}\n}A[3];\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\tget(n);\n\trep(0,2,i)\n\t{\n\t\tget(m);\n\t\trep(1,m,j)\n\t\t{\n\t\t\tint get(x),get(y);\n\t\t\tif(x>y)swap(x,y);\n\t\t\tA[i].add(x,y);\n\t\t}\n\t\tA[i].topsort();\n\t}\n\tint ans=0;\n\trep(0,511,i)rep(0,511,j)\n\tans=add(ans,mul(mul(A[0].g[i],A[1].g[j]),A[2].g[i^j]));\n\tput(ans);return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int P = 998244353;\nint base = 1e9;\nint mul(int a,int b){\n  return a * b % P;\n}\nint mul(int a,int b,int c){\n  return a * b % P * c % P;\n}\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\n\nint n,m;\nvector<int> licz(){\n  cin >> m;\n  vector<vector<int>> d;\n  d.resize(n);\n  R(i,m){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    if(a > b)swap(a,b);\n    d[a].PB(b);\n  }\n  vector<int> val(n);\n  for(int i = n-1; i>=0;i--){\n    vector<int> pom;\n    for(int el:d[i]){\n      pom.PB(val[el]);\n    }\n    sort(ALL(pom));\n    val[i] = 0;\n    R(j,SZ(pom)){\n      if(pom[j] == val[i])val[i]++;\n    }\n  }\n  int mn = base;\n  vector<int> res(n);\n  R(i,n){\n    add(res[val[i]],mn);\n    mn = mul(mn, base);\n  }\n  return res;\n}\nvector<int> splot(vector<int> a,vector<int> b){\n  while(a.back() == 0)a.pop_back();\n  while(b.back() == 0)b.pop_back();\n  vector<int> res(SZ(a) + SZ(b));\n  R(i,SZ(a))R(j,SZ(b)){\n    add(res[i ^ j], mul(a[i], b[j]));\n  }\n  return res;\n}\n\nint32_t main() {\n  base = mul(base,base);\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  vector<int> res = splot(licz(), splot(licz(),licz()));\n  res.resize(1,0);\n  cout << res[0] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nmint pow1018[100001];\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    vec num;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        num = vec(N, -1);\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    mvec calc(){\n        mvec val(N, 0);\n        IREP(i, N){\n            set<int> s;\n            for(auto e: G[i]) if(num[e.to] >= 0) s.insert(num[e.to]);\n\n            REP(j, N) if(s.count(j) == 0){\n                num[i] = j;\n                val[j] += pow1018[i + 1];\n                break;\n            }\n        }\n        return val;\n    }\n\n};\n\nsigned main(){\n\n    pow1018[0] = 1;\n    mint v_1018 = ((mint)10).pow(18);\n    REP(i, 100000) pow1018[i + 1] = pow1018[i] * v_1018;\n\n    int N; cin >> N;\n    Graph X(N), Y(N), Z(N);\n    \n    int M1; cin >> M1;\n    REP(i, M1){\n        int a, b; cin >> a >> b;\n        a--; b--;\n        X.add_Undirected_edge(a, b);\n    }\n\n    int M2; cin >> M2;\n    REP(i, M2){\n        int a, b; cin >> a >> b;\n        a--; b--;\n        Y.add_Undirected_edge(a, b);\n    }\n\n    int M3; cin >> M3;\n    REP(i, M3){\n        int a, b; cin >> a >> b;\n        a--; b--;\n        Z.add_Undirected_edge(a, b);\n    }\n\n    mmat vals(3);\n    vals[0] = X.calc();\n    vals[1] = Y.calc();\n    vals[2] = Z.calc();\n    //mdebug(vals);\n\n    mint ans = vals[0][0] * vals[1][0] * vals[2][0];\n    REP(x, 3){\n        FOR(i, 1, N){\n            mint tmp = 1;\n            REP(j, 3) if(j != x) tmp *= vals[j][i];\n            ans += vals[x][0] * tmp;\n        }\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct Problem {\n\n\tvoid Solve() {\n\t\tconst ULL M = 998244353;\n\t\tconst ULL Z = 1000000000000000000 % 998244353;\n\n\n\t\tUL N; cin >> N;\n\n\t\tvector<UL> POWZ(N + 1); POWZ[0] = 1;\n\t\trep(i, N) POWZ[i + 1] = POWZ[i] * Z % M;\n\t\tvector<ULL> A[3];\n\n\t\tconst UL X = min(N, 512u);\n\n\t\trep(t, 3) {\n\t\t\tUL S; cin >> S;\n\t\t\tvector<vector<UL>> E(N);\n\t\t\trep(j, S) {\n\t\t\t\tUL u, v; cin >> u >> v; u--; v--;\n\t\t\t\tE[min(u, v)].push_back(max(u, v));\n\t\t\t}\n\t\t\tA[t].resize(X);\n\t\t\tvector<UL> F(X, -1), G(N);\n\t\t\tfor (UL v = N - 1; v != -1; v--) {\n\t\t\t\tfor (UL e : E[v]) F[G[e]] = v;\n\t\t\t\twhile (F[G[v]] == v) G[v]++;\n\t\t\t\tA[t][G[v]] += POWZ[v + 1];\n\t\t\t\tA[t][G[v]] %= M;\n\t\t\t}\n\t\t}\n\n\t\tULL ans = 0;\n\t\t{\n\t\t\trep(a, X) rep(b, X) {\n\t\t\t\tUL c = a ^ b; if (c >= X) continue;\n\t\t\t\tans += A[0][a] * A[1][b] % M * A[2][c] % M;\n\t\t\t\tans %= M;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD_> struct ModInt {\n    static constexpr unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconstexpr LL MOD = 998244353;\nusing Mint = ModInt<MOD>;\n\nint N;\nint S[100011];\nMint B[100011];\n\nvector<Mint> calc() {\n    int M;\n    scanf(\"%d\", &M);\n    vector<pair<int, int> > E;\n    REP (i, M) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tif (x > y) swap(x, y);\n\tE.emplace_back(x, y);\n    }\n    sort(E.begin(), E.end());\n    reverse(E.begin(), E.end());\n\n    for (int v=N, i=0; v>=1; v--) {\n\tVI ar;\n\n\twhile (i < (int)E.size() && E[i].first == v) {\n\t    int p = E[i].second;\n\t    ar.push_back(S[p]);\n\t    i++;\n\t}\n\tsort(ar.begin(), ar.end());\n\tar.erase(unique(ar.begin(), ar.end()), ar.end());\n\tar.push_back(-1);\n\tS[v] = 100;\n\tREP (j, ar.size()) if (ar[j] != j) {\n\t    S[v] = j;\n\t    break;\n\t}\n    }\n\n    int ma = *max_element(S+1, S+N+1);\n    vector<Mint> ret(ma+1);\n    for (int v=1; v<=N; v++) {\n\tret[S[v]] += B[v];\n    }\n    return ret;\n}\n\nvoid MAIN() {\n    B[0] = 1;\n    B[1] = Mint(10).pow(18);\n    for (int i=2; i<100011; i++) B[i] = B[i-1] * B[1];\n\n    scanf(\"%d\", &N);\n    auto X = calc();\n    auto Y = calc();\n    auto Z = calc();\n\n    Mint ans = 0;\n    REP (i, X.size()) REP (j, Y.size()) {\n\tint k = i^j;\n\tif (k < (int)Z.size()) ans += X[i] * Y[j] * Z[k];\n    }\n\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n/*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n//    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define iostream_untie true\n#include <bits/stdc++.h>\n#include <ext/rope>\n#define __all(v) std::begin(v), std::end(v)\n#define __rall(v) std::rbegin(v), std::rend(v)\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n#else\n    #define dump(...) ((void)0)\n#endif\n\n/* function utility start */\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n/*\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n*/\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n/* using alias end */\n\n/* library start */\n\n\n\n/* library end */\n\n/* The main code follows. */\n\nstruct solver; template <class T = solver> void _main();\nint main() { _main<>(); }\n\ntemplate <class solver>\nvoid _main()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n\n    }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b) - 1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n \n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n \ntypedef long long Int;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n \nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000;\nconst Int LINF = INF * (Int) INF;\nconst int MAX = 100007;\nconst int MOD = 998244353;\n\n\nint n;\n\nVI G[MAX];\nInt pw[MAX];\n\nInt bpow(Int a, Int k) {\n    Int res = 1;\n    while (k) {\n        if(k & 1) {\n            res *= a;\n            res %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        k /= 2;\n    }\n    return res;\n}\n\nvector<Int> fwht(vector<Int> data) {\n    int n = SZ(data);\n    while (n & (n - 1)) {\n        ++ n;\n        data.push_back(0);\n    }\n    for (int len = 1; 2 * len <= n; len <<= 1) {\n        for (int i = 0; i < n; i += 2 * len) {\n            for (int j = 0; j < len; j++) {\n                int a = data[i + j];\n                int b = data[i + j + len];\n                data[i + j] = (a + b) % MOD;\n                data[i + j + len] = (MOD + a - b) % MOD;\n            }   \n        }\n    }\n    return data;\n}\n\nvector<Int> F() {\n    int m;\n    cin >> m;\n    FOR(i,0,n)\n        G[i].clear();\n    FOR(i,0,m) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        if (a < b) swap(a, b);\n        G[a].push_back(b);\n    }\n    vector<Int> R;\n    set<int> S, T;\n    FOR(i,0,n)\n        S.insert(i);\n    while (SZ(S)) {\n        Int c = 0;\n        while (SZ(S)) {\n            int v = *S.rbegin();\n            S.erase(v);\n            c += pw[v + 1];\n            c %= MOD;\n            for(int to: G[v]) {\n                if (S.find(to) != S.end()) {\n                    S.erase(to);\n                    T.insert(to);\n                }\n            }\n        }\n        // cout << endl;\n        R.push_back(c);\n        S.swap(T);\n    }\n    // cout << endl;\n    while (SZ(R) < n) R.push_back(0);\n    return R;\n}\n\nint main(int argc, char* argv[])\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    // mt19937 rng(47);\n\n    Int val = 1;\n    FOR(i,0,18) {\n        val = val * 10 % MOD;\n    }\n    pw[0] = 1;\n    FOR(i,1,MAX)\n        pw[i] = pw[i - 1] * val % MOD;\n    \n    cin >> n;\n    vector<Int> A = F();\n    vector<Int> B = F();\n    vector<Int> C = F();\n\n    A = fwht(A);\n    B = fwht(B);\n    C = fwht(C);\n    FOR(i,0,SZ(A)) {\n        A[i] = A[i] * B[i] % MOD * C[i] % MOD;\n    }\n    A = fwht(A);\n\n    cout << A[0] * bpow(SZ(A), MOD - 2) % MOD << endl;\n    \n    cerr << 1.0 * clock() / CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M[3];\nvector<int> E[3][101010];\nconst ll mo=998244353;\nll p10[20];\nll pv[303030];\n\nint ok[3][303030];\n\nll from[1010];\nll dp[1010];\nll to[1010];\n\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tll sum=0;\n\n\tp10[0]=1;\n\tFOR(i,19) p10[i+1]=p10[i]*10%mo;\n\tpv[0]=1;\n\tFOR(i,302020) pv[i+1]=pv[i]*p10[18]%mo;\n\t\n\tfrom[0]=1;\n\tFOR(i,3) {\n\t\tcin>>M[i];\n\t\tFOR(j,M[i]) {\n\t\t\tcin>>x>>y;\n\t\t\tE[i][x-1].push_back(y-1);\n\t\t\tE[i][y-1].push_back(x-1);\n\t\t}\n\t\tZERO(dp);\n\t\tfor(j=N-1;j>=0;j--) {\n\t\t\tset<int> S;\n\t\t\tFORR(e,E[i][j]) if(e>j) S.insert(ok[i][e]);\n\t\t\twhile(S.count(ok[i][j])) ok[i][j]++;\n\t\t\t(dp[ok[i][j]]+=pv[j+1])%=mo;\n\t\t}\n\t\tZERO(to);\n\t\tFOR(x,1000) FOR(y,1000) {\n\t\t\t(to[x^y]+=from[x]*dp[y])%=mo;\n\t\t}\n\t\tswap(from,to);\n\t}\n\t\n\tcout<<from[0]<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\nconst int   mod = 998244353;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\n\ntypedef pair<int,int>   ii;\ntypedef vector<int>     vi;\n\nvector<int> g[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    auto calc = [&]()   {\n        int m;  cin >> m;\n\n        set<int> S;\n        set<int> R;\n\n        for(int i = 1 ; i <= n ; ++i)   {\n            g[i].clear();\n            S.insert(i);\n        }\n        for(int i = 1 ; i <= m ; ++i)   {\n            int x;  cin >> x;\n            int y;  cin >> y;\n\n            g[x].pb(y);\n            g[y].pb(x);\n        }\n        vector<int> res;\n\n        while (S.size() || R.size())    {\n            int val = 0;\n\n            while (S.size())    {\n                int x = (*S.rbegin());\n                S.erase(x);\n\n                add(val,Pow(10,18 * x));\n\n                for(int u : g[x])\n                    if (S.count(u)) {\n                        S.erase(u);\n                        R.insert(u);\n                    }\n            }\n            res.pb(val);\n            S.swap(R);\n        }\n        return  res;\n    };\n    vector<int> v1 = calc();\n    vector<int> v2 = calc();\n    vector<int> v3 = calc();\n\n    int S = 1e9;\n\n    S = min(S,sz(v1));\n    S = min(S,sz(v2));\n    S = min(S,sz(v3));\n\n    v1.resize(S);\n    v2.resize(S);\n    v3.resize(S);\n\n    vector<vi>  ok(S,vi(S,1));\n\n    int ans = 0;\n\n    for(int i = 0 ; i < S ; ++i)    {\n        vector<bool> used(S,0);\n\n        for(int j = 0 ; j < S ; ++j)\n        for(int k = 0 ; k < S ; ++k)    if (ok[j][k] && !used[k])   {\n            int val = 1;\n            val = mul(val,v1[i]);\n            val = mul(val,v2[j]);\n            val = mul(val,v3[k]);\n\n            add(ans,val);\n\n            ok[j][k] = 0;\n            used [k] = 1;\n            break;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdio>\n#include <complex>\n#include <numeric>\n#include <string.h>\n#include <random>\n#include <cmath>\n#include <unordered_map>\n#include <unordered_set>\n#include <chrono>\n#include <cassert>\n#define rep(i,n) for (ll i = 0; i < (ll)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\ndouble PI = 3.141592653589793238462643383279;\nconst double EPS = 1e-9;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate< int mod >\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n         return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt< MOD >;\n\nint n;\nint m[3];\nvector<vector<int>> e[3];\nbool done[3][100000];\nbool done2[3][100000];\nmint val[3];\nmint val2[3];\nmint ten = 10;\nmint ans;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i,3) {\n        e[i].resize(n);\n        cin >> m[i];\n        rep(j,m[i]) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            e[i][a].push_back(b);\n            e[i][b].push_back(a);\n        }\n    }\n    rep(i,3) {\n        for (int j = n-1; j >= 0; j--) {\n            if (done[i][j]) continue;\n            val[i] += ten.pow(18*(j+1));\n            for (int to : e[i][j]) {\n                done[i][to] = true;\n            }\n        }\n    }\n    ans = val[0]*val[1]*val[2];\n    while (true) {\n        rep(i,3) val2[i] = 0;\n        memset(done2, 0, sizeof(done2));\n        rep(i,3) {\n            for (int j = n-1; j >= 0; j--) {\n                if (!done[i][j]) continue;\n                if (done2[i][j]) continue;\n                val2[i] += ten.pow(18*(j+1));\n                for (int to : e[i][j]) {\n                    done2[i][to] = true;\n                }\n            }\n        }\n        ans += val2[0]*val2[1]*val[2];\n        ans += val2[0]*val[1]*val2[2];\n        ans += val[0]*val2[1]*val2[2];\n        rep(i,3) val[i] += val2[i];\n        int cz = 0;\n        rep(i,3) if (val2[i] == 0) cz++;\n        if (cz >= 2) break;\n        rep(i,3) rep(j,n) if (!done2[i][j]) {\n            done[i][j] = false;\n        }\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5,M=505,mod=998244353;\nll p[N];\nint n,m,tot,vis[N],head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvector<ll>res[3];\nvoid solve(int flag)\n{\n    tot=0;memset(head,0,sizeof(head));\n    memset(vis,false,sizeof(vis));\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    priority_queue<int>q[2];\n    int x=0,tim=0;\n    for(int i=1;i<=n;i++) q[x].push(i);\n    while(!q[x].empty())\n    {\n        tim++;\n        ll ans=0;\n        while(!q[x].empty())\n        {\n            while(!q[x].empty()&&vis[q[x].top()]==tim) q[x].pop();\n            if(q[x].empty()) break;\n            int u=q[x].top();q[x].pop();\n            vis[u]=1e9;\n            ans=(ans+p[u])%mod;\n            for(int i=head[u];i;i=nex[i])\n            {\n                int v=to[i];\n                if(vis[v]<tim)\n                {\n                    vis[v]=tim;\n                    q[x^1].push(v);\n                }\n            }\n        }\n        x^=1;\n        res[flag].push_back(ans);\n    }\n}\nbool vis1[M][M],vis2[M];\nll solve()\n{\n    memset(vis2,0,sizeof(vis2));\n    ll ans=0;\n    for(int i=0;i<res[1].size();i++)\n    {\n        int mx=0;\n        while(mx<res[2].size()&&vis1[i][mx]||vis2[mx]) mx++;\n        if(mx<res[2].size())\n        {\n            vis1[i][mx]=vis2[mx]=true;\n            ans=(ans+res[1][i]*res[2][mx])%mod;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    p[0]=1;\n    for(int i=1;i<N;i++) p[i]=1000000000000000000ll%mod*p[i-1]%mod;\n    scanf(\"%d\",&n);\n    solve(0);solve(1);solve(2);\n    assert(res[0].size()<M);\n    assert(res[1].size()<M);\n    assert(res[2].size()<M);\n    ll ans=0;\n    for(int i=0;i<res[0].size();i++)\n        ans=(ans+res[0][i]*solve())%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nint M[3];\nvi G[3][MAX_N];\nint grundy[3][MAX_N];\nll E[3][2010];\nll pow10[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(q, 0, 3) {\n\t\tcin >> M[q];\n\t\trep(i, 0, M[q]) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\tG[q][a].pb(b);\n\t\t\tG[q][b].pb(a);\n\t\t}\n\t}\n\tpow10[0] = pow10[1] = 1;\n\trep(_, 0, 18) MUL(pow10[1], 10);\n\trep(i, 1, N) pow10[i + 1] = pow10[i] * pow10[1] % mod;\n\trep(q, 0, 3) {\n\t\trer(i, N, 0) {\n\t\t\tset<int> S;\n\t\t\trep(j, 0, sz(G[q][i])) {\n\t\t\t\tint n = G[q][i][j];\n\t\t\t\tif(n > i) {\n\t\t\t\t\t// debug(q, i, n, grundy[q][n]);\n\t\t\t\t\tS.insert(grundy[q][n]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!S.empty() && grundy[q][i] == *S.begin()) {\n\t\t\t\tgrundy[q][i]++;\n\t\t\t\tS.erase(S.begin());\n\t\t\t}\n\t\t\t// debug(q, i, grundy[q][i]);\n\t\t\tADD(E[q][grundy[q][i]], pow10[i + 1]);\n\t\t}\n\t}\n\tll res = 0;\n\trep(i, 0, 1024) {\n\t\trep(j, 0, 1024) {\n\t\t\tADD(res, E[0][i] * E[1][j] % mod * E[2][i ^ j] % mod);\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// No.074901032320\n#include <bits/stdc++.h>\n#define N 100100\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, m, vis[N], sg[N], f[3][N], mx, pw[N];\nvector<int> G[N];\n\nint main() {\n#ifdef isLOCAL\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    int base = 1000000000000000000ll % Mod;\n    for (int i = pw[0] = 1; i <= n; ++i)\n        pw[i] = 1ll * pw[i - 1] * base % Mod;\n\n    for (int g = 0; g < 3; ++g) {\n        cin >> m;\n        for (int i = 1; i <= n; ++i) G[i].clear();\n        for (int i = 1, u, v; i <= m; ++i) {\n            scanf(\"%d%d\", &u, &v);\n            if (u > v) swap(u, v);\n            G[u].push_back(v);\n        }\n        for (int i = n; i >= 1; --i) {\n            for (int v : G[i])\n                vis[sg[v]]++;\n            sg[i] = 0;\n            while (vis[sg[i]]) ++sg[i];\n            for (int v : G[i])\n                vis[sg[v]]--;\n            mx = max(mx, sg[i]);\n            f[g][sg[i]] = (f[g][sg[i]] + pw[i]) % Mod;\n        }\n    }\n    \n    long long ans = 0;\n    for (int i = 0; i <= mx; ++i)\n        for (int j = 0; j <= mx; ++j)\n            ans = (ans + 1ll * f[0][i] * f[1][j] % Mod * f[2][i xor j]) % Mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n        #define int long long\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int  Inv2 = (MOD+1)/2;\ntemplate <typename T>\nvoid fwt(vector<T>& f,int n) {\n  \n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD, f[j | i] = (x+MOD - y)%MOD;\n            }\n        }\n    }\n}\ntemplate <typename T>\nvoid ifwt(vector<T>& f,int n) {\n    \n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD *Inv2 %MOD, f[j | i] = (x+MOD - y) %MOD *Inv2 %MOD;\n            }\n        }\n    }\n}\n     signed main(){\n   int n,nn=1,t=1,m,a,b;\n   for(int i=0;i<18;i++)t=(t*10)%MOD;\n   cin>>n;\n   while(nn<n)nn*=2;\n vector<int> p(nn,0),q(nn,0),r(nn,0),ban(n,0),henp[n],henq[n],henr[n];\n cin>>m;\n for(int i=0;i<m;i++){\n         cin>>a>>b;a--;b--;\n         if(a>b)swap(a,b);\n         henp[a].push_back(b);\n }\n        cin>>m;\n for(int i=0;i<m;i++){\n         cin>>a>>b;a--;b--;\n         if(a>b)swap(a,b);\n         henq[a].push_back(b);\n }\n cin>>m;\n for(int i=0;i<m;i++){\n         cin>>a>>b;a--;b--;\n         if(a>b)swap(a,b);\n         henr[a].push_back(b);\n }\n\npriority_queue<int,vector<int>,greater<int>> que;\nint mb=1;\n for(int i=n-1;i>=0;i--){\n         ban[i]=0;\n         for(int j=0;j<henp[i].size();j++)que.push(ban[henp[i][j]]);\n         while(!que.empty()){\n                 if(ban[i]==que.top())ban[i]++;\n                \n                 que.pop();\n         }\n        while(mb<=ban[i])mb*=2;\n }\n a=1;\n for(int i=0;i<n;i++){\n         a=(a*t)%MOD;\n        p[ban[i]]=(p[ban[i]]+a)%MOD;\n }\n for(int i=n-1;i>=0;i--){\n         ban[i]=0;\n         for(int j=0;j<henq[i].size();j++)que.push(ban[henq[i][j]]);\n         while(!que.empty()){\n                 if(ban[i]==que.top())ban[i]++;\n                 que.pop();\n         }\n       while(mb<=ban[i])mb*=2;\n }\n a=1;\n for(int i=0;i<n;i++){\n         a=(a*t)%MOD;\n        q[ban[i]]=(q[ban[i]]+a)%MOD;\n }\n for(int i=n-1;i>=0;i--){\n         ban[i]=0;\n         for(int j=0;j<henr[i].size();j++)que.push(ban[henr[i][j]]);\n         while(!que.empty()){\n                 if(ban[i]==que.top())ban[i]++;\n                 que.pop();\n         }\n        while(mb<=ban[i])mb*=2;\n }\n a=1;\n for(int i=0;i<n;i++){\n         a=(a*t)%MOD;\n        r[ban[i]]=(r[ban[i]]+a)%MOD;\n }\n fwt(p,mb);fwt(q,mb);\n for(int i=0;i<nn;i++)q[i]=(q[i]*p[i])%MOD;\n ifwt(q,mb);\n int ans=0;\n for(int i=0;i<nn;i++)ans=(ans+(q[i]*r[i])%MOD)%MOD;\n cout<<ans<<endl;\n\n\n         \n}\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 998244353;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int sub(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int mul(int a,int b){return 1ll*a*b%mod;}\ninline int qpow(int a,int b){int ret=1;for(;b;b>>=1,a=mul(a,a))if(b&1)ret=mul(ret,a);return ret;}\nconst int inv2 = (mod+1)>>1;\n/* math */\nconst int N = 1e5+5;\nint a[1<<19],b[1<<19],c[1<<19],d[1<<19];\ninline void fwt(int *f,int n,int type){\n\tfor(int step=1;step<n;step<<=1){\n\t\tfor(int i=0;i<n;i+=step<<1){\n\t\t\tfor(int j=0;j<step;j++){\n\t\t\t\tint x=f[i+j], y=f[i+j+step];\n\t\t\t\tf[i+j] = add(x,y);\n\t\t\t\tf[i+j+step] = sub(x,y);\n\t\t\t\tif(type==0){\n\t\t\t\t\tf[i+j] = mul(f[i+j], inv2);\n\t\t\t\t\tf[i+j+step] = mul(f[i+j+step], inv2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint n,buc[N],sg[N];\nvector<int> s[N];\ninline void calc(int n,int *q){\n\tint m;cin >> m;for(int i=1;i<=n;i++)s[i].clear();\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\ts[min(u,v)].push_back(max(u,v));\n\t}\n\tfor(int i=n;i;i--){\n\t\tsg[i]=0;\n\t\tfor(size_t j=0;j<s[i].size();j++){\n\t\t\tint v=s[i][j];\n\t\t\t// cout << i << \" -> \" << v << endl;\n\t\t\tbuc[sg[v]]++;\n\t\t}\n\t\twhile(buc[sg[i]])sg[i]++;\n\t\tfor(size_t j=0;j<s[i].size();j++){\n\t\t\tint v=s[i][j];\n\t\t\tbuc[sg[v]]--;\n\t\t}\n\t\t// cout << i << \" \" << sg[i] << endl;\n\t\tq[sg[i]]=add(q[sg[i]], qpow(10,18*i));\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tcalc(n,a),calc(n,b),calc(n,c);\n\tfwt(a,1<<19,1);\n\tfwt(b,1<<19,1);\n\tfwt(c,1<<19,1);\n\tfor(int i=0;i<1<<19;i++){\n\t\td[i]=mul(a[i],mul(b[i],c[i]));\n\t}\n\tfwt(d,1<<19,0);\n\tcout << d[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nconstexpr int MOD = 998244353;\nusing mint = ModInt<MOD>;\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nvoid brute() {\n    int n;\n    std::cin >> n;\n\n    std::vector<mint> tens(n + 1);\n    {\n        mint ten = 1;\n        for (int i = 0; i < 18; ++i) ten *= 10;\n\n        tens[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            tens[i] = tens[i - 1] * ten;\n        }\n    }\n\n    std::vector<Graph<>> graphs(3);\n    std::vector<mint> iss, dss;\n    for (auto& graph : graphs) {\n        graph.resize(n);\n\n        int m;\n        std::cin >> m;\n\n        while (m--) {\n            int u, v;\n            std::cin >> u >> v;\n            --u, --v;\n            graph[u].emplace_back(u, v);\n            graph[v].emplace_back(v, u);\n        }\n    }\n\n    mint ans = 0;\n    auto used = vec(n, vec(n, vec(n, false)));\n    for (int s = (n - 1) * 3; s >= 0; --s) {\n        for (int i = 0; i < n && i <= s; ++i) {\n            for (int j = 0; j < n && i + j <= s; ++j) {\n                int k = s - i - j;\n                if (k >= n || used[i][j][k]) continue;\n\n                std::cerr << i + 1 << \" \" << j + 1 << \" \" << k + 1 << std::endl;\n                ans += tens[i + 1] * tens[j + 1] * tens[k + 1];\n\n                for (auto e : graphs[0][i]) {\n                    used[e.dst][j][k] = true;\n                }\n                for (auto e : graphs[1][j]) {\n                    used[i][e.dst][k] = true;\n                }\n                for (auto e : graphs[2][k]) {\n                    used[i][j][e.dst] = true;\n                }\n            }\n        }\n    }\n    std::cout << ans << std::endl;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<mint> tens(n + 1);\n    {\n        mint ten = 1;\n        for (int i = 0; i < 18; ++i) ten *= 10;\n\n        tens[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            tens[i] = tens[i - 1] * ten;\n        }\n    }\n\n    std::vector<Graph<>> graphs(3);\n    std::vector<std::vector<mint>> iss;\n    for (auto& graph : graphs) {\n        graph.resize(n);\n\n        int m;\n        std::cin >> m;\n\n        while (m--) {\n            int u, v;\n            std::cin >> u >> v;\n            --u, --v;\n            graph[u].emplace_back(u, v);\n            graph[v].emplace_back(v, u);\n        }\n\n        std::vector<bool> used(n, false);\n        iss.push_back(std::vector<mint>());\n\n        while (std::any_of(used.begin(), used.end(), [](auto b) { return !b; })) {\n            std::vector<bool> out = used;\n            mint score = 0;\n            for (int v = n - 1; v >= 0; --v) {\n                if (out[v]) continue;\n\n                used[v] = true;\n                score += tens[v + 1];\n                for (auto e : graph[v]) {\n                    out[e.dst] = true;\n                }\n            }\n\n            iss.back().push_back(score);\n        }\n    }\n\n    mint ans = 0;\n\n    for (int i = 0; i < (int)iss[0].size(); ++i) {\n        for (int j = 0; j < (int)iss[1].size(); ++j) {\n            for (int k = 0; k < (int)iss[2].size(); ++k) {\n                if ((i ^ j ^ k) == 0) {\n                    ans += iss[0][i] * iss[1][j] * iss[2][k];\n                }\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    // brute();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : C.cpp\n * Author  : Kazune Takahashi\n * Created : 4/20/2020, 9:36:35 PM\n * Powered by Visual Studio Code\n */\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n// ----- using directives and manipulations -----\nusing namespace std;\nusing boost::rational;\nusing boost::multiprecision::cpp_int;\nusing ll = long long;\ntemplate <typename T>\nusing max_heap = priority_queue<T>;\ntemplate <typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// ----- constexpr for Mint and Combination -----\n// constexpr ll MOD{1000000007LL};\nconstexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{(x % MOD + MOD) % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator++() { return *this += 1; }\n  Mint &operator++(int)\n  {\n    Mint tmp{*this};\n    ++*this;\n    return tmp;\n  }\n  Mint &operator--() { return *this -= 1; }\n  Mint &operator--(int)\n  {\n    Mint tmp{*this};\n    --*this;\n    return tmp;\n  }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  Mint const power(ll N) const\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\ntemplate <typename T>\nT gcd(T x, T y) { return y ? gcd(y, x % y) : x; }\ntemplate <typename T>\nT lcm(T x, T y) { return x / gcd(x, y) * y; }\n// ----- for C++17 -----\ntemplate <typename T>\nint popcount(T x) // C++20\n{\n  int ans{0};\n  while (x != 0)\n  {\n    ans += x & 1;\n    x >>= 1;\n  }\n  return ans;\n}\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1000000000000000LL}; // or\n// constexpr int infty{1'000'000'010};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nconstexpr int MAX_G{700};\nconst mint BASE{1'000'000'000'000'000'000};\n\n// ----- Graph -----\n\nclass Graph\n{\n  int N;\n  vector<vector<int>> V;\n  vector<int> G;\n\npublic:\n  Graph(int N, vector<vector<int>> V) : N{N}, V{V}, G(N, -1) {}\n\n  vector<mint> table()\n  {\n    vector<mint> ans(MAX_G, 0);\n    for (auto i = 0; i < N; ++i)\n    {\n      ans[grundy(i)] += BASE.power(i + 1);\n    }\n    return ans;\n  }\n\nprivate:\n  int grundy(int n)\n  {\n    if (G[n] >= 0)\n    {\n      return G[n];\n    }\n    unordered_set<int> S;\n    for (auto e : V[n])\n    {\n      S.insert(grundy(e));\n    }\n    for (auto i = 0; i < MAX_G; ++i)\n    {\n      if (S.find(i) == S.end())\n      {\n        return G[n] = i;\n      }\n    }\n    throw runtime_error(\"Invalid grundy number.\");\n    return -1;\n  }\n};\n\n// ----- Solve -----\n\nclass Solve\n{\n  Graph X, Y, Z;\n\npublic:\n  Solve(vector<Graph> V) : X{V[0]}, Y{V[1]}, Z{V[2]} {}\n\n  mint answer()\n  {\n    mint ans{0};\n    vector<mint> TX{X.table()}, TY{Y.table()}, TZ{Z.table()};\n    for (auto i = 0; i < MAX_G; ++i)\n    {\n      for (auto j = 0; j < MAX_G; ++j)\n      {\n        int k{i ^ j};\n        if (k < MAX_G)\n        {\n          ans += TX[i] * TY[j] * TZ[k];\n        }\n      }\n    }\n    return ans;\n  }\n};\n\n// ----- main() -----\n\nint main()\n{\n  int N;\n  cin >> N;\n  vector<Graph> V;\n  for (auto q = 0; q < 3; ++q)\n  {\n    vector<vector<int>> W(N);\n    int M;\n    cin >> M;\n    for (auto i = 0; i < M; ++i)\n    {\n      int u, v;\n      cin >> u >> v;\n      --u;\n      --v;\n      if (u > v)\n      {\n        swap(u, v);\n      }\n      W[u].push_back(v);\n    }\n    V.push_back(Graph(N, W));\n  }\n  Solve solve(V);\n  cout << solve.answer() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\n\nint n,m[3],gr[3][100005];\nvi g[3][100005];\nMint sum[3][350],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,3){\n\t\tcin>>m[i];\n\t\trep(j,m[i]){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tg[i][--a].pb(--b);\n\t\t\tg[i][b].pb(a);\n\t\t}\n\t\tvi p;\n\t\trrep(j,n){\n\t\t\tp.clear();\n\t\t\tfor(auto &k:g[i][j]){\n\t\t\t\tif(j<k){\n\t\t\t\t\tp.pb(gr[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(p));\n\t\t\tp.erase(unique(all(p)),p.end());\n\t\t\tgr[i][j]=-1;\n\t\t\trep(k,si(p)){\n\t\t\t\tif(k!=p[k]){\n\t\t\t\t\tgr[i][j]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(gr[i][j]==-1)gr[i][j]=si(p);\n\t\t\tsum[i][gr[i][j]]+=Mint(10).pow(18*(j+1));\n\t\t\tcout<<i<<' '<<j<<' '<<gr[i][j]<<endl;\n\t\t}\n\t}\n\trep(i,350){\n\t\trep(j,350){\n\t\t\trep(k,350){\n\t\t\t\tif(i^j^k==0){\n\t\t\t\t\tans+=sum[0][i]*sum[1][j]*sum[2][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nconst int mod = 998244353;\nconst int N = 1 << 17;\nlong long dp[3][N];\n\nvoid wh(long long* b, long long* e) {\n\tif (e == b + 1) {\n\t\treturn;\n\t}\n\tlong long *m = b + (e - b) / 2;\n\twh(b, m);\n\twh(m, e);\n\twhile (m != e) {\n\t\tauto x = *b, y = *m;\n\t\t*b = x + y;\n\t\t*m = x - y;\n\t\t++b, ++m;\n\t}\n}\n\nint mex(vector<int> a) {\n\tmake_unique(a);\n\tint res = 0;\n\twhile (res < (int)a.size() && a[res] == res) {\n\t\t++res;\n\t}\n\treturn res;\n}\n\nlong long inv(long long a, long long b) {\n\treturn 1 < a ? b - inv(b % a, a) * b / a : 1;\n}\n\nint main() {\n\tint n = nxt();\n\tconst long long rem = (long long)(1e18) % mod;\n\tvector<long long> deg(n + 1);\n\tdeg[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdeg[i] = deg[i - 1] * rem % mod;\n\t}\n\tfor (int i = 0; i < 3; ++i) {\n\t\tint m = nxt();\n\t\tvector<vector<int>> a(n);\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\t\tif (u > v) {\n\t\t\t\tswap(u, v);\n\t\t\t}\n\t\t\ta[u].push_back(v);\n\t\t}\n\t\tvector<int> gr(n);\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tvector<int> grs;\n\t\t\tfor (int x : a[j]) {\n\t\t\t\tgrs.push_back(gr[x]);\n\t\t\t}\n\t\t\tgr[j] = mex(grs);\n\t\t\tdp[i][gr[j]] += deg[j + 1];\n\t\t}\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tdp[i][j] %= mod;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; ++i) {\n\t\twh(dp[i], dp[i] + N);\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tdp[i][j] %= mod;\n\t\t\tif (dp[i][j] < 0) {\n\t\t\t\tdp[i][j] += mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[0][i] *= dp[1][i];\n\t\tdp[0][i] %= mod;\n\t\tdp[0][i] *= dp[2][i];\n\t\tdp[0][i] %= mod;\n\t}\n\twh(dp[0], dp[0] + N);\n\tdp[0][0] %= mod;\n\tif (dp[0][0] < 0) {\n\t\tdp[0][0] += mod;\n\t}\n\tcout << dp[0][0] * inv(N, mod) % mod << \"\\n\";\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 998244353\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\ni64 mof = 1000000000000000000LL % MOD;\n\nint N;\nvector<int> edge[101010];\nint grundy[101010];\n\nvector<i64> analyze()\n{\n\tint M;\n\tscanf(\"%d\", &M);\n\tfor (int i = 1; i <= N; ++i) edge[i].clear();\n\tfor (int i = 0; i < M; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tif (a > b) swap(a, b);\n\t\tedge[a].push_back(b);\n\t}\n\tgrundy[N] = 0;\n\tfor (int i = N - 1; i >= 1; --i) {\n\t\tset<int> waf;\n\t\tfor (int j : edge[i]) waf.insert(grundy[j]);\n\t\tfor (int j = 0;; ++j) {\n\t\t\tif (waf.count(j) == 0) {\n\t\t\t\tgrundy[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<i64> res(1024, 0LL);\n\n\ti64 w = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tw = w * mof % MOD;\n\t\tADD(res[grundy[i]], w);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tvector<i64> seq1 = analyze();\n\tvector<i64> seq2 = analyze();\n\tvector<i64> seq3 = analyze();\n\ti64 ret = 0;\n\tfor (int i = 0; i < 1024; ++i) {\n\t\tfor (int j = 0; j < 1024; ++j) {\n\t\t\tADD(ret, seq1[i] * seq2[j] % MOD * seq3[i ^ j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ff first\n#define ss second\n#define pii pair<int, int>\n#define pb emplace_back\n#define pf emplace_front\n#define mp make_pair\n#define ld long double\n#define all(x) x.begin(), x.end()\n#define uniq(x) sort(all(x)), x.resize(unique(all(x)) - x.begin())\n\n//random_device rd;\n//mt19937_64 gen(rd());\n//\n//template<typename T>\n//T rand(T l, T r) {\n//    uniform_int_distribution<T> uid(l, r);\n//    return uid(gen);\n//}\n\nconst int maxn = 1e5 + 9;\nvector<int> g[3][maxn];\nint c[3][maxn];\nint n;\nint mod = 998244353;\nint p[maxn];\nvector<int> w[3];\nint ans;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    p[0] = 1;\n    p[1] = ((int)1e18) % mod;\n    for (int i = 2; i < maxn; i++)\n        p[i] = (p[i - 1] * p[1]) % mod;\n    cin >> n;\n    for (int j = 0; j < 3; j++)\n    {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++)\n        {\n            int a, b;\n            cin >> a >> b;\n            a--, b--;\n            g[j][a].pb(b);\n            g[j][b].pb(a);\n        }\n        int kek = 0;\n        int t = 0;\n        while (kek != n)\n        {\n            t++;\n            for (int i = n - 1; i >= 0; i--)\n            {\n                if (c[j][i])\n                    continue;\n                bool fl = 0;\n                for (int to : g[j][i])\n                {\n                    if (c[j][to] == t)\n                        fl = 1;\n                }\n                if (!fl)\n                {\n                    c[j][i] = t;\n                    if (w[j].size() < t + 1)\n                        w[j].resize(t + 1, 0);\n                    w[j][t] = (w[j][t] + p[i + 1]) % mod;\n                    kek++;\n                }\n            }\n        }\n//        for (int i = 0; i < n; i++)\n//            cout << c[j][i] << \" \";\n//        cout << \"\\n\";\n    }\n    vector<vector<int> > q;\n    for (int a = 0; a < 3; a++)\n        for (int b = 0; b < 3; b++)\n            for (int c = 0; c < 3; c++)\n    {\n        if (a != b && b != c && a != c)\n        {\n            vector<int> cur = {a, b, c};\n            q.pb(cur);\n        }\n    }\n    set<pii> used;\n    int sz = max(max(w[0].size(), w[1].size()), w[2].size());\n    for (int a = 1; a < sz; a++)\n    {\n        for (int b = 1; b <= a; b++)\n        {\n            for (int c = 1; c <= b; c++)\n            {\n                if (used.find(mp(a, b)) != used.end())\n                    continue;\n                if (used.find(mp(a, c)) != used.end())\n                    continue;\n                if (used.find(mp(b, c)) != used.end())\n                    continue;\n\n                bool fl = 0;\n                for (auto u : q)\n                {\n                    vector<int> polina;\n                    bool U[3] = {};\n                    bool fll = 1;\n                    for (int r = 0; r < 3; r++)\n                    {\n                        if (u[r] == 0)\n                        {\n                            polina.pb(a);\n                            if (a == b && U[1])\n                                fll = 0;\n                            U[0] = 1;\n                        }\n                        else if (u[r] == 1)\n                        {\n                            polina.pb(b);\n                            if (b == c && U[2])\n                                fll = 0;\n                            U[1] = 1;\n                        }\n                        else\n                        {\n                            polina.pb(c);\n                            U[2] = 1;\n                        }\n\n                    }\n                    if (!fll)\n                        continue;\n                    int cur = 1;\n\n                    if ((int)w[0].size() > polina[0])\n                        cur = (cur * w[0][polina[0]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[1].size() > polina[1])\n                        cur = (cur * w[1][polina[1]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[2].size() > polina[2])\n                        cur = (cur * w[2][polina[2]]) % mod;\n                    else\n                        fll = 0;\n\n                    if (fll)\n                    {\n                        ans = (ans + cur) % mod;\n                        fl = 1;\n                    }\n                }\n                if (fl)\n                {\n//                    cout << a << \" \" << b << \" \" << c << \"\\n\";\n                    used.emplace(a, b);\n                    used.emplace(a, c);\n                    used.emplace(b, c);\n                }\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nconst int MOD = 998244353;\nconst long long w = ((long long)1e18)%MOD;\nlong long wpow[101010];\n\nvector<long long> solve(vector<pair<int, int> > V)\n{\n    vector<vector<int> > conn(N+1);\n    vector<int> sidx(N+1);\n    vector<long long> ret(N);\n    for(auto x: V)\n    {\n        int u, v; tie(u, v) = x;\n        conn[u].push_back(v);\n        conn[v].push_back(u);\n    }\n    for(int i=N; i>=1; --i)\n    {\n        set<int> S;\n        for(auto x: conn[i])\n            S.insert(sidx[x]);\n        for(int t=1; t<=N; ++t)\n            if(S.count(t) == 0)\n            {\n                sidx[i] = t;\n                ret[t-1] = ret[t-1] + wpow[i];\n                if(ret[t-1] >= MOD) ret[t-1] -= MOD;\n                break;\n            }\n    }\n    return ret;\n}\nint main()\n{\n    scanf(\"%d\", &N);\n    wpow[0] = 1;\n    for(int i=1; i<=N; ++i)\n        wpow[i] = wpow[i-1]*w%MOD;\n    vector<vector<long long> > Q;\n    for(int i=0; i<3; ++i)\n    {\n        vector<pair<int, int> > V;\n        int M; scanf(\"%d\", &M);\n        for(int j=0; j<M; ++j)\n        {\n            int u, v; scanf(\"%d%d\", &u, &v);\n            V.emplace_back(u, v);\n        }\n        Q.push_back(solve(V));\n    }\n    long long ans = Q[0][0] * Q[1][0]%MOD*Q[2][0]%MOD;\n    for(int i=1; i<N; ++i)\n    {\n        ans += Q[0][0] * Q[1][i]%MOD*Q[2][i]%MOD;\n        ans += Q[0][i] * Q[1][0]%MOD*Q[2][i]%MOD;\n        ans += Q[0][i] * Q[1][i]%MOD*Q[2][0]%MOD;\n        ans %= MOD;\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define MOD 1000000007\n#define MOD 998244353\n\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\n//const int mod = 1000000007;\nconst int mod = 998244353;\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n\nstd::vector<std::vector<int>> iig(int vn, int en) { \n        std::vector<std::vector<int>> res(vn); \n        for(int i = 0; i < en; i++) { \n                int s, t; \n                std::cin >> s >> t; \n                s--; t--; \n\t\tif (s > t) swap(s, t);\n                res[t].push_back(s); \n        } \n        return res; \n}\n\nstd::vector<int> assign_grundy(std::vector<std::vector<int>>& dg) {\n\tint gsize = dg.size();\n\tstd::vector<int> incomings(gsize);\n\tfor(int i = 0; i < gsize; i++) {\n\t\tfor(int j: dg[i]) {\n\t\t\tincomings[j]++;\n\t\t}\n\t}\n\tstd::vector<int> vs_ready;\n\tfor(int i = 0; i < gsize; i++) {\n\t\tif (incomings[i] == 0) vs_ready.push_back(i);\n\t}\n\tstd::vector<std::set<int>> prohibited_grundy(gsize);\n\tstd::vector<int> grundy(gsize);\n\twhile(!vs_ready.empty()) {\n\t\tint i = vs_ready.back();\n\t\tvs_ready.pop_back();\n\t\tint g = 0;\n\t\tfor(int pg: prohibited_grundy[i]) {\n\t\t\tif (g == pg) g++;\n\t\t\telse break;\n\t\t}\n\t\tgrundy[i] = g;\n\t\tfor(int j: dg[i]) {\n\t\t\tprohibited_grundy[j].insert(g);\n\t\t\tif ((--incomings[j]) == 0) vs_ready.push_back(j);\n\t\t}\n\t}\n\treturn grundy;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n;\n\tcin >> m;\n\tauto g1 = iig(n, m);\n\tcin >> m;\n\tauto g2 = iig(n, m);\n\tcin >> m;\n\tauto g3 = iig(n, m);\n\t// assume that each edge direction is reversed\n\tauto grn1 = assign_grundy(g1);\n\tauto grn2 = assign_grundy(g2);\n\tauto grn3 = assign_grundy(g3);\t\n\t// gmax * (gmax + 1) <= E * 2\n\n\tvector<mint> w(n + 1);\n\tmint step = mint(10).pow(18);\n\tw[0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tw[i] = w[i-1] * step;\n\t}\n\n\tvector<mint> gcount1(500), gcount2(500), gcount3(500);\n\tfor(int i = 0; i < n; i++) {\n\t\tgcount1[grn1[i]] += w[i+1];\n\t\tgcount2[grn2[i]] += w[i+1];\n\t\tgcount3[grn3[i]] += w[i+1];\n\t}\n\n\tmint res = 0;\n\n\tfor(int i = 0; i < 500; i++)\n\t\tfor(int j = 0; j < 500; j++) {\n\t\t\tint k = i ^ j;\n\t\t\tres += gcount1[i] * gcount2[j] * gcount3[k];\n\t\t}\n\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate<class T> inline void read(T &x){\n\tx=0; register char c=getchar(); register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\n\nconst int N=1e5+10,M=400,mod=998244353;\nint n,lim,max,m[3],sg[N];\nstd::vector<int> G[3][N];\n\nstruct z {\n\tint x;\n\tz(int x=0):x(x){}\n\tfriend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n\tfriend inline z operator-(z a,z b){return (a.x-=b.x)<0?a.x+mod:a.x;}\n\tfriend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}ans,pw[N],f[3][N],g[N];\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&1)s=s*a;return s;}\n\nvoid SG(int m,std::vector<int> G[N],int sg[N]){\n\tstatic bool vis[N];\n\tfor(int i=n;i>=1;i--){\n\t\tfor(int j:G[i])vis[sg[j]]=1;\n\t\tsg[i]=0;\n\t\twhile(vis[sg[i]])sg[i]++;\n\t\tfor(int j:G[i])vis[sg[j]]=0;\n\t}\n}\n\nvoid fwt(z *a){\n\tfor(int len=1;len<lim;len<<=1)\n\t\tfor(int i=0;i<lim;i+=(len<<1))\n\t\t\tfor(int j=0;j<len;j++){\n\t\t\t\tz x=a[i+j],y=a[i+j+len];\n\t\t\t\ta[i+j]=x+y,a[i+j+len]=x-y;\n\t\t\t}\n}\n\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(n),lim=sqrt(n);\n\tfor(int i=0;i<3;i++){\n\t\tread(m[i]);\n\t\tfor(int u,v,j=1;j<=m[i];j++){\n\t\t\tread(u),read(v);\n\t\t\t// G[i][u].push_back(v);\n\t\t\tG[i][std::min(u,v)].push_back(std::max(u,v));\n\t\t\t// G[i][std::max(u,v)].push_back(std::min(u,v));\n\t\t}\n\t}\n\tpw[0]=1,pw[1]=fpow(10,18);\n\tfor(int i=2;i<=n;i++)pw[i]=pw[i-1]*pw[1];\n\tfor(int i=0;i<3;i++){\n\t\tSG(m[i],G[i],sg);\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmax=std::max(max,sg[j]);\n\t\t\tf[i][sg[j]]=f[i][sg[j]]+pw[j];\n\t\t}\n\t\t// for(int j=1;j<=n;j++){\n\t\t// \tprintf(\"%d%c\",sg[j],\" \\n\"[j==n]);\n\t\t// }\n\t}\n\tlim=1; while(lim<=max)lim<<=1;\n\t// for(int i=0;i<lim;i++)\n\t// \tfor(int j=0;j<lim;j++)\n\t// \t\tfor(int k=0;k<lim;k++){\n\t// \t\t\tg[i^j^k]=g[i^j^k]+f[0][i]*f[1][j]*f[2][k];\n\t// \t\t\t// if(f[0][i].x&&f[1][j].x&&f[2][k].x){\n\t// \t\t\t// \tprintf(\"%d %d %d : %d\\n\",i,j,k,f[0][i]*f[1][j]*f[2][k]);\n\t// \t\t\t// }\n\t// \t\t}\n\tfor(int i=0;i<3;i++)fwt(f[i]);\n\tfor(int i=0;i<lim;i++)g[i]=f[0][i]*f[1][i]*f[2][i];\n\tfwt(g);\n\tz invlim=fpow(lim,mod-2);\n\tfor(int i=0;i<lim;i++)g[i]=g[i]*invlim;\n\t// for(int i=0;i<lim;i++){\n\t// \tprintf(\"%d : %d\\n\",i,g[i]);\n\t// }\n\tprintf(\"%d\\n\",g[0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=998244353;\nint n,m,x,y,sg1[111111],sg2[111111],sg3[111111],pos,ans;\nlong long a[111111],b[111111],c[111111];\nvector<int> g1[111111],g2[111111],g3[111111];\nbool used[111111];\nint binpow(int a,int t)\n{\n\tint res=1,p=a;\n\tfor (int i=t;i;i>>=1)\n\t{\n\t\tif (i&1) res=1ll*res*p%mod;\n\t\tp=1ll*p*p%mod;\n\t}\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>y) swap(x,y);\n\t\tg1[x].push_back(y);\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tfor (int j=0;j<g1[i].size();j++)\n\t\t{\n\t\t\tused[sg1[g1[i][j]]]=1;\n\t\t}\n\t\tpos=0;\n\t\twhile(used[pos]) pos++;\n\t\tsg1[i]=pos;a[pos]=(a[pos]+binpow(10,18*i))%mod;\n\t\tfor (int j=0;j<g1[i].size();j++)\n\t\t{\n\t\t\tused[sg1[g1[i][j]]]=0;\n\t\t}\n\t}\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>y) swap(x,y);\n\t\tg2[x].push_back(y);\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tfor (int j=0;j<g2[i].size();j++)\n\t\t{\n\t\t\tused[sg2[g2[i][j]]]=1;\n\t\t}\n\t\tpos=0;\n\t\twhile(used[pos]) pos++;\n\t\tsg2[i]=pos;b[pos]=(b[pos]+binpow(10,18*i))%mod;\n\t\tfor (int j=0;j<g2[i].size();j++)\n\t\t{\n\t\t\tused[sg2[g2[i][j]]]=0;\n\t\t}\n\t}\n\tscanf(\"%d\",&m);\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (x>y) swap(x,y);\n\t\tg3[x].push_back(y);\n\t}\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tfor (int j=0;j<g3[i].size();j++)\n\t\t{\n\t\t\tused[sg3[g3[i][j]]]=1;\n\t\t}\n\t\tpos=0;\n\t\twhile(used[pos]) pos++;\n\t\tsg3[i]=pos;c[pos]=(c[pos]+binpow(10,18*i))%mod;\n\t\tfor (int j=0;j<g3[i].size();j++)\n\t\t{\n\t\t\tused[sg3[g3[i][j]]]=0;\n\t\t}\n\t}\n\tfor (int i=0;i<=n;i++)\n\t{\n\t\tif (!a[i]) continue;\n\t\tfor (int j=0;j<=n;j++)\n\t\t{\n\t\t\tif (!b[j] || !c[i^j]) continue;\n\t\t\tans=(1ll*a[i]*b[j]%mod*c[i^j]+ans)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef long long LL;\nconst int N=3e5+100,mod=998244353;\nint n,m,ans,f[N][3],pw[N],sg[N];\nvector<int> G[N];\nint main() {\n\tscanf(\"%d\",&n);\n\tpw[0]=1, pw[1]=(LL)(1e18)%mod;\n\tfor(int i=2;i<=n;++i)\n\t\tpw[i]=(LL)pw[i-1]*pw[1]%mod;\n\tfor(int o=0;o<3;++o) {\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=1;i<=n;++i) sg[i]=0, G[i].clear();\n\t\tfor(int i=1,x,y;i<=m;++i) {\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tif(x>y) swap(x,y);\n\t\t\tG[x].pb(y);\n\t\t}\n\t\tfor(int u=n;u>=1;--u) {\n\t\t\tset<int> mex;\n\t\t\tfor(auto v:G[u]) {\n\t\t\t\tmex.insert(sg[v]);\n\t\t\t\twhile(mex.count(sg[u]))\n\t\t\t\t\t++sg[u];\n\t\t\t}\n\t\t\t(f[sg[u]][o] += pw[u])%=mod;\n\t\t}\n\t}\n\tfor(int i=0;i<=500;++i)\n\t\tfor(int j=0;j<=500;++j)\n\t\t\t(ans += (LL)f[i][0]*f[j][1]%mod*f[i^j][2]%mod)%=mod;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define re register\n#define LL long long\n#define MOD 998244353\n#define MAXN 100005\nusing namespace std;\nLL n,ans,bs[3*MAXN];\nLL rd(){\n\tLL x=0,tp=1;char c;c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')tp=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=(x*10+c-'0');c=getchar();}\n\treturn x*tp;\n}\nstruct Graph{\n\tLL m,sqr,sg[MAXN],f[MAXN];\n\tvector<int>e[MAXN];\n\tvoid work(){\n\t\tint x,y;\n\t\tm=rd();sqr=sqrt(2*m);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tx=rd(),y=rd();\n\t\t\tif(x>y)swap(x,y);\n\t\t\te[x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tset<int>s;\n\t\t\tint sz=e[i].size();\n\t\t\tfor(int j=0;j<sz;j++)s.insert(sg[e[i][j]]);\n\t\t\twhile(s.count(sg[i]))sg[i]++;\n\t\t\t(f[sg[i]]+=bs[i])%=MOD;\n\t\t\t// printf(\"sg[%d]=%d\\n\",i,sg[i]);\n\t\t}\n\t}\n}g[3];\nint main(){\n\t// freopen(\"testdata.in\",\"r\",stdin);\n\t// freopen(\"shit.out\",\"w\",stdout);\n\tn=rd();\n\tbs[0]=1;LL fuck=1000000000000000000ll%MOD;\n\tfor(int i=1;i<=3*n;i++)bs[i]=bs[i-1]*fuck%MOD;\n\tfor(int i=0;i<3;i++)g[i].work();\n\tfor(int i=0;i<=g[0].sqr;i++)\n\t\tfor(int j=0;j<=g[1].sqr;j++)\n\t\t\t(ans+=g[0].f[i]*g[1].f[j]%MOD*g[2].f[i^j]%MOD)%=MOD;\n\tprintf(\"%lld\\n\",ans);\n\t// printf(\"%.2lf\\n\",(double)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdio>\n#include <complex>\n#include <numeric>\n#include <string.h>\n#include <random>\n#include <cmath>\n#include <unordered_map>\n#include <unordered_set>\n#include <chrono>\n#include <cassert>\n#define rep(i,n) for (ll i = 0; i < (ll)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\ndouble PI = 3.141592653589793238462643383279;\nconst double EPS = 1e-9;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate< int mod >\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n         return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt< MOD >;\n\nint n;\nint m[3];\nvector<vector<int>> e[3];\nbool done[3][100000];\nbool done2[3][100000];\nmint val[3];\nmint val2[3];\nmint ten = 10;\nmint ans;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i,3) {\n        e[i].resize(n);\n        cin >> m[i];\n        rep(j,m[i]) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            e[i][a].push_back(b);\n            e[i][b].push_back(a);\n        }\n    }\n    rep(i,3) {\n        for (int j = n-1; j >= 0; j--) {\n            if (done[i][j]) continue;\n            val[i] += ten.pow(18*(j+1));\n            for (int to : e[i][j]) {\n                done[i][to] = true;\n            }\n        }\n    }\n    ans = val[0]*val[1]*val[2];\n    while (true) {\n        rep(i,3) val2[i] = 0;\n        memset(done2, 0, sizeof(done2));\n        bool end = true;\n        rep(i,3) {\n            for (int j = n-1; j >= 0; j--) {\n                if (!done[i][j]) continue;\n                if (done2[i][j]) continue;\n                val2[i] += ten.pow(18*(j+1));\n                end = false;\n                for (int to : e[i][j]) {\n                    if (to > j) continue;\n                    done2[i][to] = true;\n                }\n            }\n        }\n        if (end) break;\n        ans += val2[0]*val2[1]*val[2];\n        ans += val2[0]*val[1]*val2[2];\n        ans += val[0]*val2[1]*val2[2];\n        rep(i,3) val[i] += val2[i];\n        rep(i,3) rep(j,n) if (!done2[i][j]) {\n            done[i][j] = false;\n        }\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int S = 500, SSS = S * S * S, N = 1e5 + 5, mod = 998244353;\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nconst int base = powmod(10, 18);\n\nbitset<SSS> vis;\n\nint pos(int a, int b, int c) {\n  return ((a * S) + b) * S + c;\n}\n\ntuple<int, int, int> decod(int v) {\n  int c = v % S;\n  v /= S;\n  int b = v % S;\n  v /= S;\n  return make_tuple(v, b, c);\n}\n\nvector<int> g[N];\n\nvector<pair<int, int>> independent(int n, vector<pair<int ,int>> & edges) {\n  for (int i = 0; i < n; ++i)\n    g[i].clear();\n  for (auto e : edges) {\n    g[e.first].push_back(e.second);\n    g[e.second].push_back(e.first);\n  }\n  vector<bool> done(n, false), mark(n);\n  int cnt = 0;\n  vector<pair<int, int>> res;\n  while (cnt < n) {\n    mark = done;\n    int hig = -1, sum = 0;\n    for (int v = n-1; v >= 0; --v) {\n      if (mark[v]) continue;\n      ++cnt;\n      done[v] = 1;\n      hig = max(hig, v+1);\n      sum = (sum + powmod(base, v+1)) % mod;\n      for (int u : g[v]) {\n        mark[u] = 1;\n      }\n    }\n    res.emplace_back(hig, sum);\n  }\n  return res;\n}\n\nvector<pair<int, int>> read_edges() {\n  int m;\n  scanf(\"%d\", &m);\n  vector<pair<int, int>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &edges[i].first, &edges[i].second);\n    --edges[i].first;\n    --edges[i].second;\n  }\n  return edges;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> ex = read_edges();\n  vector<pair<int, int>> ey = read_edges();\n  vector<pair<int, int>> ez = read_edges();\n  vector<pair<int, int>> rx = independent(n, ex);\n  vector<pair<int, int>> ry = independent(n, ey);\n  vector<pair<int, int>> rz = independent(n, ez);\n  assert(rx.size() < S);\n  assert(ry.size() < S);\n  assert(rz.size() < S);\n  vector<vector<bool>> xy(rx.size(), vector<bool>(ry.size(), false));\n  vector<vector<bool>> xz(rx.size(), vector<bool>(rz.size(), false));\n  vector<vector<bool>> yz(ry.size(), vector<bool>(rz.size(), false));\n  priority_queue<pair<int, int>> pq;\n  auto insert_node = [&](int i, int j, int k) {\n    if (i >= (int)rx.size() || j >= (int)ry.size() || k >= (int)rz.size())\n      return;\n    int now = pos(i, j, k);\n    if (vis[now])\n      return;\n    pq.emplace(rx[i].first + ry[j].first + rz[k].first, now);\n    vis[now] = 1;\n  };\n  insert_node(0, 0, 0);\n  long long ans = 0;\n  while (!pq.empty()) {\n    auto it = pq.top();\n    pq.pop();\n    int i, j, k;\n    tie(i, j, k) = decod(it.second);\n    insert_node(i+1, j, k);\n    insert_node(i, j+1, k);\n    insert_node(i, j, k+1);\n    if (xy[i][j] || xz[i][k] || yz[j][k]) continue;\n    long long cur = rx[i].second * (long long) ry[j].second % mod;\n    cur = cur * rz[k].second % mod;\n    ans = (ans + cur) % mod;\n    xy[i][j] = 1;\n    xz[i][k] = 1;\n    yz[j][k] = 1;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\n#define P 998244353\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nll perm(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (fac[n]*finv[n-k])%P;\n}\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\n\ntypedef vector<set<ll>> graph;\nll n;\n\nvvl get(graph g){\n  //なるべく大きい要素を取る独立集合\n  //現在とったものに隣接していない最大の要素を貪欲に取っていく\n  vvl dat;\n  vll go(n+1, 0);\n\n  for(int i=n;i>0;i--){\n    //iが何番目の集合に入るか\n    if(dat.size()<=go[i]) dat.push_back(vll());\n    dat[go[i]].push_back(i);\n    for(auto to:g[i]){\n      if(go[to]==go[i]) go[to]++;\n      g[to].erase(i);\n    }\n  }\n  return dat;\n}\n\nvector<ll> cost(400000, 1);\n\n\n//独立集合の重み\nll get_cost(vll v){\n  ll ret = 0;\n  for(int i=0;i<v.size();i++) ret = (ret + cost[v[i]])%P;\n  return ret;\n}\n\nint main(int argc, char const *argv[]) {\n  init();\n  ll x = 1000000000000000000LL%P;\n  for(int i=1;i<400000;i++) cost[i] = (cost[i-1] * x)%P;\n\n  std::cin >> n;\n\n  vvl d = VV(3, 0, 0, ll);\n  for(int i=0;i<3;i++){\n    ll m;std::cin >> m;\n    graph g(n+1);\n    for(int j=0;j<m;j++){\n      ll a, b;scanf(\"%lld %lld\", &a, &b);\n      g[a].insert(b);\n      g[b].insert(a);\n    }\n    vvl X = get(g);\n    for(int j=0;j<X.size();j++) {\n      d[i].push_back(get_cost(X[j]));\n    }\n  }\n\n  ll ans = pp(pp(d[0][0], d[1][0]), d[2][0]);\n  //0\n  for(int j=1;j<n;j++){\n    if(j>=d[1].size()||j>=d[2].size()) break;\n    ans = (ans + pp(d[0][0], pp(d[1][j], d[2][j])))%P;\n  }\n  //1\n  for(int j=1;j<n;j++){\n    if(j>=d[2].size()||j>=d[0].size()) break;\n    ans = (ans + pp(d[1][0], pp(d[0][j], d[2][j])))%P;\n  }\n  //2\n  for(int j=1;j<n;j++){\n    if(j>=d[1].size()||j>=d[0].size()) break;\n    ans = (ans + pp(d[2][0], pp(d[0][j], d[1][j])))%P;\n  }\n  ll p = d[0].size(), q = d[1].size(), r = d[2].size();\n  vll ps(p, 0), qs(q, 0), rs(r, 0);\n  for(int i=0;i<=p;i++) ps[i] = ((i==0?0:ps[i-1]) + d[0][i])%P;\n  for(int i=0;i<=q;i++) qs[i] = ((i==0?0:qs[i-1]) + d[1][i])%P;\n  for(int i=0;i<=r;i++) rs[i] = ((i==0?0:rs[i-1]) + d[2][i])%P;\n  ll pmax = ps[p-1];\n  ll qmax = qs[q-1];\n  ll rmax = rs[r-1];\n\n  //0\n  if(p>1){\n\n    for(ll i=1;i<p;i++){\n      for(ll j=i+1;j<q;j++) {\n        ll upper = min(r-1, j);\n        ans = (ans + pp(d[0][i], pp(d[1][j], (rmax - rs[upper] + P)%P)))%P;\n      }\n      for(ll j=i+1;j<r;j++) {\n        ll upper = min(q-1, j);\n        ans = (ans + pp(d[0][i], pp(d[2][j], (qmax - qs[upper] + P)%P)))%P;\n      }\n    }\n  }\n\n  if(q>1){\n    //1\n    for(int i=1;i<q;i++){\n      for(ll j=i+1;j<p;j++) {\n        ll upper = min(r-1, j);\n        ans = (ans + pp(d[1][i], pp(d[0][j], (rmax - rs[upper] + P)%P)))%P;\n      }\n      for(ll j=i+1;j<r;j++) {\n        ll upper = min(p-1, j);\n        ans = (ans + pp(d[1][i], pp(d[2][j], (pmax - ps[upper] + P)%P)))%P;\n      }\n    }\n  }\n\n  if(r>1){\n    //2\n    for(int i=1;i<r;i++){\n      for(ll j=i+1;j<p;j++) {\n        ll upper = min(q-1, j);\n        ans = (ans + pp(d[2][i], pp(d[0][j], (qmax - qs[upper] + P)%P)))%P;\n      }\n      for(ll j=i+1;j<q;j++) {\n        ll upper = min(p-1, j);\n        ans = (ans + pp(d[2][i], pp(d[1][j], (pmax - ps[upper] + P)%P)))%P;\n      }\n    }\n  }\n\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// by newbiechd\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl\n\nconst int N_MAX = 100003;\nint n;\n\nconst int mod = 998244353;\nint powK[N_MAX];\n\nstruct Graph {\n  int m;\n  vector<int> g[N_MAX];\n  bool tub[N_MAX];\n  int sg[N_MAX], mx, f[N_MAX];\n  \n  void build() {\n    cin >> m;\n    for (int i = 1; i <= m; ++i) {\n      int x, y;\n      cin >> x >> y;\n      if (x > y)\n        swap(x, y);\n      g[x].push_back(y);\n    }\n    for (int x = n; x > 0; --x) {\n      for (int y : g[x])\n        tub[sg[y]] = 1;\n      int i = 0;\n      while (tub[i])\n        ++i;\n      sg[x] = i;\n      mx = max(mx, i);\n      f[i] = (powK[x] + f[i]) % mod;\n      for (int y : g[x])\n        tub[sg[y]] = 0;\n    }\n  }\n}G[3];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  \n  cin >> n;\n  const int K = (long long)1e18 % mod;\n  powK[0] = 1;\n  for (int i = 1; i <= n; ++i)\n    powK[i] = 1ll * K * powK[i - 1] % mod;\n  for (int i = 0; i < 3; ++i)\n    G[i].build();\n  int ans = 0;\n  for (int i = 0; i <= G[0].mx; ++i)\n    for (int j = 0; j <= G[1].mx; ++j)\n      ans = (1ll * G[0].f[i] * G[1].f[j] % mod * G[2].f[i ^ j] + ans) % mod;\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdio>\n#include <complex>\n#include <numeric>\n#include <string.h>\n#include <random>\n#include <cmath>\n#include <unordered_map>\n#include <unordered_set>\n#include <chrono>\n#include <cassert>\n#define rep(i,n) for (ll i = 0; i < (ll)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\ndouble PI = 3.141592653589793238462643383279;\nconst double EPS = 1e-9;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate< int mod >\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n         return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt< MOD >;\n\nint n;\nint m[3];\nvector<vector<int>> e[3];\nbool done[3][100000];\nbool done2[3][100000];\nmint val[3];\nmint val2[3];\nmint ten = 10;\nmint ans;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i,3) {\n        e[i].resize(n);\n        cin >> m[i];\n        rep(j,m[i]) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            e[i][a].push_back(b);\n            e[i][b].push_back(a);\n        }\n    }\n    rep(i,3) {\n        for (int j = n-1; j >= 0; j--) {\n            if (done[i][j]) continue;\n            val[i] += ten.pow(18*(j+1));\n            for (int to : e[i][j]) {\n                done[i][to] = true;\n            }\n        }\n    }\n    ans = val[0]*val[1]*val[2];\n    rep(i,3) {\n        for (int j = n-1; j >= 0; j--) {\n            if (!done[i][j]) continue;\n            if (done2[i][j]) continue;\n            val2[i] += ten.pow(18*(j+1));\n            for (int to : e[i][j]) {\n                done2[i][to] = true;\n            }\n        }\n    }\n    ans += val2[0]*val2[1]*val[2];\n    ans += val2[0]*val[1]*val2[2];\n    ans += val[0]*val2[1]*val2[2];\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 3;\nconst int mod = 998244353;\n\nint n, m[4];\nvector <int> adj[4][maxn];\nvoid read()\n{\n    cin >> n;\n    for (int i = 1; i <= 3; i++)\n    {\n        cin >> m[i];\n        for (int j = 1; j <= m[i]; j++)\n        {\n            int a, b;\n            cin >> a >> b;\n\n            adj[i][a].push_back(b);\n            adj[i][b].push_back(a);\n        }\n    }\n}\n\nlong long add(long long a, long long b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n\n    return a;\n}\n\nlong long pow[maxn*2];\nint gr[4][maxn];\nmap <int, long long> mp[4];\nvoid solve()\n{\n    pow[0] = 1;\n    for (int i = 1; i <= 2 * n; i++)\n        pow[i] = pow[i-1] * 1000000000 % mod;\n\n    for (int i = 1; i <= 3; i++)\n    {\n        mp[i][0] = add(mp[i][0], pow[n*2]);\n        for (int j = n-1; j >= 1; j--)\n        {\n            set <int> s;\n            for (auto k: adj[i][j])\n                if (k > j)\n                s.insert(gr[i][k]);\n\n            while (s.find(gr[i][j]) != s.end())\n                gr[i][j]++;\n\n            mp[i][gr[i][j]] = add(mp[i][gr[i][j]], pow[j*2]);\n        }\n    }\n\n    int p = sqrt(max({m[1], m[2], m[3]})) + 10;\n    long long ans = 0;\n    for (int i = 0; i <= p; i++)\n        if (mp[1].count(i))\n        for (int j = 0; j <= p; j++)\n        if (mp[2].count(j))\n            ans = add(ans, mp[1][i] * mp[2][j] % mod * mp[3][i^j] % mod);\n\n    cout << ans << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    read();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\nnamespace dfcmd {\n\n    typedef long long LL;\n\n    const int maxn = 100005;\n    const int mod = 998244353;\n    const int di = 1000000000000000000LL % mod;\n    \n    int bin[maxn * 3];\n    \n    inline void add(int& x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    int n;\n\n    struct myhnb {\n        int m;\n        int sg[maxn];\n        int ss[maxn];\n\n        struct Edge {\n            int to, nxt;\n        } e[maxn];\n\n        int first[maxn];\n\n        inline void add_edge(int u, int v) {\n            static int cnt = 0;\n            if (u > v) {\n                swap(u, v);\n            }\n            e[++cnt].nxt = first[u];\n            first[u] = cnt;\n            e[cnt].to = v;\n        }\n        \n        int vis[maxn];\n\n        myhnb() {\n            memset(first, 0, sizeof(first));\n            memset(ss, 0, sizeof(ss));\n            memset(vis, 0, sizeof(vis));\n        }\n    \n        inline void dfs(int now) {\n            vis[now] = true;\n            set<int> sgg;\n            sgg.clear();\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!vis[to]) {\n                    dfs(to);\n                }\n                sgg.insert(sg[to]);\n            }\n            sg[now] = 0;\n            while (sgg.count(sg[now])) {\n                sg[now]++;\n            }\n//            cout << \"alb \" << now << ' ' << sg[now] << ' ' << bin[now] << endl;\n            add(ss[sg[now]], bin[now]);\n        }\n        \n        inline void Dfs() {\n            for (int i = 1; i <= n; ++i) {\n                if (!vis[i]) {\n                    dfs(i);\n                }\n            }\n        }\n        \n        inline int& operator [] (int x) {\n            return ss[x];\n        }\n    } d[3];\n\n    int main() {\n        read(n);\n        bin[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            bin[i] = (LL) bin[i - 1] * di % mod;\n        }\n        for (int i = 0; i < 3; ++i) {\n            read(d[i].m);\n            for (int j = 1; j <= d[i].m; ++j) {\n                int u, v;\n                read(u), read(v);\n                d[i].add_edge(u, v);\n            }\n            d[i].Dfs();\n//            cout << \"sg = \";\n//            for (int j = 1; j <= n; ++j) {\n//                cout << d[i].sg[j] << ' ';\n//            }\n//            cout << endl;\n        }\n        int ans = 0;\n        for (int i = 0; i <= 5000; ++i) {\n            for (int j = 0; j <= 5000; ++j) {\n                add(ans, (LL) d[0][i] * d[1][j] % mod * d[2][i ^ j] % mod);\n            }\n        }\n        writeln(ans);\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ff first\n#define ss second\n#define pii pair<int, int>\n#define pb emplace_back\n#define pf emplace_front\n#define mp make_pair\n#define ld long double\n#define all(x) x.begin(), x.end()\n#define uniq(x) sort(all(x)), x.resize(unique(all(x)) - x.begin())\n\n//random_device rd;\n//mt19937_64 gen(rd());\n//\n//template<typename T>\n//T rand(T l, T r) {\n//    uniform_int_distribution<T> uid(l, r);\n//    return uid(gen);\n//}\n\nconst int maxn = 1e5 + 9;\nvector<int> g[3][maxn];\nint c[3][maxn];\nint n;\nint mod = 998244353;\nint p[maxn];\nvector<int> w[3];\nint ans;\nbool used[1000][1000];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    p[0] = 1;\n    p[1] = ((int)1e18) % mod;\n    for (int i = 2; i < maxn; i++)\n        p[i] = (p[i - 1] * p[1]) % mod;\n    cin >> n;\n    for (int j = 0; j < 3; j++)\n    {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++)\n        {\n            int a, b;\n            cin >> a >> b;\n            a--, b--;\n            g[j][a].pb(b);\n            g[j][b].pb(a);\n        }\n        int kek = 0;\n        int t = 0;\n        while (kek != n)\n        {\n            t++;\n            for (int i = n - 1; i >= 0; i--)\n            {\n                if (c[j][i])\n                    continue;\n                bool fl = 0;\n                for (int to : g[j][i])\n                {\n                    if (c[j][to] == t)\n                        fl = 1;\n                }\n                if (!fl)\n                {\n                    c[j][i] = t;\n                    if (w[j].size() < t + 1)\n                        w[j].resize(t + 1, 0);\n                    w[j][t] = (w[j][t] + p[i + 1]) % mod;\n                    kek++;\n                }\n            }\n        }\n//        for (int i = 0; i < n; i++)\n//            cout << c[j][i] << \" \";\n//        cout << \"\\n\";\n    }\n    vector<vector<int> > q;\n    for (int a = 0; a < 3; a++)\n        for (int b = 0; b < 3; b++)\n            for (int c = 0; c < 3; c++)\n    {\n        if (a != b && b != c && a != c)\n        {\n            vector<int> cur = {a, b, c};\n            q.pb(cur);\n        }\n    }\n    int sz = max(max(w[0].size(), w[1].size()), w[2].size());\n    for (int a = 1; a < sz; a++)\n    {\n        for (int b = 1; b <= a; b++)\n        {\n            for (int c = 1; c <= b; c++)\n            {\n                if (used[a][b] || used[b][c] || used[a][c])\n                    continue;\n\n                bool fl = 0;\n                for (auto u : q)\n                {\n                    vector<int> polina;\n                    bool U[3] = {};\n                    bool fll = 1;\n                    for (int r = 0; r < 3; r++)\n                    {\n                        if (u[r] == 0)\n                        {\n                            polina.pb(a);\n                            if (a == b && U[1])\n                                fll = 0;\n                            U[0] = 1;\n                        }\n                        else if (u[r] == 1)\n                        {\n                            polina.pb(b);\n                            if (b == c && U[2])\n                                fll = 0;\n                            U[1] = 1;\n                        }\n                        else\n                        {\n                            polina.pb(c);\n                            U[2] = 1;\n                        }\n\n                    }\n                    if (!fll)\n                        continue;\n                    int cur = 1;\n\n                    if ((int)w[0].size() > polina[0])\n                        cur = (cur * w[0][polina[0]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[1].size() > polina[1])\n                        cur = (cur * w[1][polina[1]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[2].size() > polina[2])\n                        cur = (cur * w[2][polina[2]]) % mod;\n                    else\n                        fll = 0;\n\n                    if (fll)\n                    {\n                        ans = (ans + cur) % mod;\n                        fl = 1;\n                    }\n                }\n                if (fl)\n                {\n                    used[a][b] = 1;\n                    used[a][c] = 1;\n                    used[b][c] = 1;\n                }\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef vector<int>VI;\ntypedef long long LL;\nconst int N=100005,P=998244353,B=(LL)1e18%P;\nint n,pw[N],m[3],sg[3][N],mx[3],f[3][N];VI G[N];bool ban[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tpw[0]=1;rep(i,1,N-1)pw[i]=1LL*pw[i-1]*B%P;\n\trep(i,0,2){\n\t\tscanf(\"%d\",&m[i]);\n\t\trep(j,1,n)G[j].clear();\n\t\trep(j,1,m[i]){\n\t\t\tint k1,k2;scanf(\"%d%d\",&k1,&k2);\n\t\t\tif(k2<k1)swap(k1,k2);\n\t\t\tG[k1].PB(k2);\n\t\t}\n\t\tper(k1,n,1){\n\t\t\tfor(auto j:G[k1])ban[sg[i][j]]=1;\n\t\t\tint&k=sg[i][k1];\n\t\t\twhile(ban[k])++k;\n\t\t\tfor(auto j:G[k1])ban[sg[i][j]]=0;\n\t\t}\n\t\trep(j,1,n){\n\t\t\t(f[i][sg[i][j]]+=pw[j])%=P;\n\t\t\tmx[i]=max(mx[i],sg[i][j]);\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,0,mx[0])rep(j,0,mx[1])(ans+=1LL*f[0][i]*f[1][j]%P*f[2][i^j]%P)%=P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /** 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\ntemplate<typename T>\nvector<int> TopologicalSort(T &g){\n  int N = g.size();\n  vector<int> marked(N , 0) , temp(N , 0) , v;\n  auto visit = [&](auto f, int i) -> bool{\n    if(temp[i] == 1) return false;\n    if(marked[i] == 0){\n      temp[i] = 1;\n      for(auto &e : g[i]){\n        if(f(f , e) == false) return false;\n      }\n      marked[i] = 1;\n      v.push_back(i);\n      temp[i] = 0;\n    }\n    return true;\n  };\n  for(int i = 0 ; i < N ; i++){\n    if(marked[i] == 0) {\n      if(visit(visit , i) == false) return vector<int>();\n    }\n  }\n  reverse( v.begin() , v.end() );\n  return v;\n}\n\nvector<int> GrundyNumber(vector<vector<int>> &g){\n  vector<int> topo = TopologicalSort(g);\n  if((int)topo.size() == 0) return vector<int>();\n  vector<int> grundy(g.size() , 0);\n  vector<int> memo(g.size() + 1 , 0);\n  for(int _ = (int)g.size() - 1; _ >= 0 ; _--){\n    int i = topo[_];\n    if(g[i].size() == 0) continue;\n    for(auto &x : g[i]){\n      memo[grundy[x]]++;\n    }\n    while(memo[grundy[i]] > 0) grundy[i]++;\n    for(auto &x : g[i]){\n      memo[grundy[x]]--;\n    }\n  }\n  return grundy;\n};\n\ntemplate <typename T>\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\ntemplate <typename T>\nusing Edges = vector<edge<T> >;\ntemplate <typename T>\nusing WeightedGraph = vector<Edges<T> >;\nusing UnweightedGraph = vector<vector<int> >;\n\n// Input of (Unweighted) Graph\nUnweightedGraph graph(int N, int M = -1, bool is_directed = false,\n                      bool is_1origin = true) {\n  UnweightedGraph g(N);\n  if (M == -1) M = N - 1;\n  for (int _ = 0; _ < M; _++) {\n    int x, y;\n    cin >> x >> y;\n    if (is_1origin) x--, y--;\n    g[x].pb(y);\n    if (!is_directed) g[y].pb(x);\n  }\n  return g;\n}\n\n// Input of Weighted Graph\ntemplate <typename T>\nWeightedGraph<T> wgraph(int N, int M = -1, bool is_directed = false,\n                        bool is_1origin = true) {\n  WeightedGraph<T> g(N);\n  if (M == -1) M = N - 1;\n  for (int _ = 0; _ < M; _++) {\n    int x, y;\n    cin >> x >> y;\n    T c;\n    cin >> c;\n    if (is_1origin) x--, y--;\n    g[x].eb(x, y, c);\n    if (!is_directed) g[y].eb(y, x, c);\n  }\n  return g;\n}\n\n// Depth of Rooted Tree\n// unvisited nodes : d = -1\nvector<int> Depth(UnweightedGraph &g, int start = 0) {\n  vector<int> d(g.size(), -1);\n  auto dfs = [&](auto rec, int cur, int par = -1) -> void {\n    d[cur] = par == -1 ? 0 : d[par] + 1;\n    each(dst, g[cur]) {\n      if (dst == par) continue;\n      rec(rec, dst, cur);\n    }\n  };\n  dfs(dfs, start);\n  return d;\n}\n\n// Diameter of Tree\npair<int, int> Diameter(UnweightedGraph &g, int start = 0) {\n  auto d = Depth(g, start);\n  int u = max_element(begin(d), end(d)) - begin(d);\n  d = Depth(g, u);\n  int v = max_element(begin(d), end(d)) - begin(d);\n  return make_pair(u, v);\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing vm = vector<modint>;\nusing mint = modint;\n\nvoid solve(){\n  ini(N);\n  \n  auto get = [&N]() -> vi{\n    ini(M);\n    vvi g(N);\n    rep(i , M){\n      ini(a,b); a--,b--;\n      if(a > b) swap(a,b);\n      g[a].pb(b);\n    }\n    return GrundyNumber(g);\n  };\n\n  auto x = get();\n  auto y = get();\n  auto z = get();\n\n  mint base = mint(10).pow(18);\n  mint cur = base;\n  vm X(701),Y(701),Z(701);\n  for(int i = 1 ; i <= N ; i++){\n    X[x[i-1]] += cur;\n    Y[y[i-1]] += cur;\n    Z[z[i-1]] += cur;\n    cur *= base;\n  }\n  vm W(1024);\n\n  //trc(x,y,z);\n  vm g(N * 2 , 0);\n  for(int i = 0 ; i <= 700 ; i++)\n    for(int j = 0 ; j <= 700 ; j++){\n      W[i ^ j] += X[i] * Y[j];\n    }\n  \n  mint ans = 0;\n  for(int i = 0 ; i <= 700 ; i++){\n    ans += W[i] * Z[i];\n  }\n  out(ans);\n\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nconstexpr auto pow(long long x, long long n, const long long mod) {\n    long long ret = 1;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint main() {\n    constexpr i64 mod = 998244353, base = pow(10, 18, mod), lim = 480;\n    int n;\n    std::cin >> n;\n\n    auto f = [=](int n) { return pow(base, n, mod); };\n\n    std::vector<i64> used(lim);\n    std::vector<std::vector<i64>> ss(3, std::vector<i64>(lim));\n    for (int i = 0; i < 3; i++) {\n        int m;\n        std::cin >> m;\n        std::vector<std::vector<int>> g(n + 1);\n        std::vector<int> par(n + 1);\n        for (int j = 0; j < m; j++) {\n            int u, v;\n            std::cin >> u >> v;\n            if (u < v) std::swap(u, v);\n            g[v].push_back(u);\n        }\n\n        for (int j = n; j > 0; j--) {\n            if (g[j].size() >= lim) std::fill(used.begin(), used.end(), 0ll);\n            else std::fill(used.begin(), used.begin() + g[j].size() + 1, 0ll);\n\n            for (int p : g[j]) used[par[p]] = 1;\n\n            par[j] = std::find(used.begin(), used.end(), 0ll) - used.begin();\n            ss[i][par[j]] = (ss[i][par[j]] + f(j)) % mod;\n        }\n    }\n\n    i64 ret = 0;\n    for (int i = 0; i < lim; i++) for (int j = 0; j < lim; j++) {\n        if ((i ^ j) < lim) ret = (ret + ss[0][i] * ss[1][j] % mod * ss[2][i ^ j] % mod) % mod;\n    }\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n// Problem : C - Giant Graph\n// Contest : AtCoder - AtCoder Grand Contest 043\n// URL : https://atcoder.jp/contests/agc043/tasks/agc043_c\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nvector<int> powers;\nint n;\n\nstruct Graph {\n\tvector<vector<int>> edges;\n\tvector<int> nimber;\n\tvector<int> groups;\n\t\n\tvoid read() {\n\t\tedges.resize(n + 1);\n\t\tint m;\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tedges[a].push_back(b);\n\t\t\tedges[b].push_back(a);\n\t\t}\n\t\tnimber.resize(n + 1);\n\t\tfor (int a = n; a >= 1; a--) {\n\t\t\tset<int> nei;\n\t\t\tfor (int b : edges[a]) {\n\t\t\t\tif (b > a) {\n\t\t\t\t\tnei.insert(nimber[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int val = 0; true; val++) {\n\t\t\t\tif (nei.count(val) == 0) {\n\t\t\t\t\tnimber[a] = val;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint i = nimber[a];\n\t\t\twhile (groups.size() <= i) {\n\t\t\t\tgroups.push_back(0);\n\t\t\t}\n\t\t\tgroups[i] += powers[a];\n\t\t\tgroups[i] %= MOD;\n\t\t}\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tpowers.resize(n + 1);\n\tpowers[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpowers[i] = (long long) 1'000'000'000'000'000'000 % MOD * powers[i - 1] % MOD;\n\t}\n\tGraph graphs[3];\n\tfor (int i : {0, 1, 2}) {\n\t\tgraphs[i].read();\n\t}\n\t\n\tint answer = 0;\n\tfor (int a = 0; a < graphs[0].groups.size(); a++) {\n\t\tfor (int b = 0; b < graphs[1].groups.size(); b++) {\n\t\t\tint c = a ^ b;\n\t\t\tif (c < graphs[2].groups.size()) {\n\t\t\t\tanswer += (long long) graphs[0].groups[a] * graphs[1].groups[b] % MOD * graphs[2].groups[c] % MOD;\n\t\t\t\tanswer %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tcout << answer << endl;\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cctype>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++)\n#define mk make_pair\n#define pi pair<int,int>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int N=1e5+10,size=1<<20,mod=998244353;\n\nchar buf[size],*p1=buf,*p2=buf;\ntemplate<class o> void qr(o &x) {\n\tchar c=gc; x=0; int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=gc;}\n\twhile(isdigit(c)) x=x*10+c-'0',c=gc;\n\tx*=f;\n}\ntemplate<class o> void qw(o x) {\n\tif(x/10) qw(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class o> void pr1(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x); putchar(' ');\n}\ntemplate<class o> void pr2(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x); puts(\"\");\n}\n\nstruct edge{int y,next;}a[N];int len,last[N];\nvoid ins(int x,int y) {a[++len]=(edge){y,last[x]};last[x]=len;}\n\nvoid upd(int &x) {x+=x>>31&mod;}\n\nll power(ll a,ll b=mod-2) {\n\tll c=1;\n\tfor(   ;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) c=c*a%mod;\n\treturn c;\n}\n\nint n,m,f[N],sum[3][N],sz[3],g[N],num,ans,fir,inv=power(fir=power(10,18));\n\nint main() {\n\tqr(n);\n\tfor(int graph=0;graph<3;graph++) {\n\t\tif(len) memset(last+1,0,n<<2),len=0;\n\t\tqr(m); for(int j=1,x,y;j<=m;j++) {\n\t\t\tqr(x),qr(y);\n\t\t\tif(x>y) swap(x,y);\n\t\t\tins(x,y);\n\t\t}\n\t\tint now=power(fir,n);\n\t\tfor(int i=n; i;i--) {\n\t\t\t//��sg����(f)\n\t\t\t++num;\n\t\t\tfor(int k=last[i];k;k=a[k].next)\n\t\t\t\tg[f[a[k].y]]=num;\n\t\t\tf[i]=0;\n\t\t\twhile(g[f[i]]==num) f[i]++;\n\t\t\tsz[graph]=max(sz[graph],f[i]);\n\t\t\tupd(sum[graph][f[i]]+=now-mod);\n\t\t\tnow=(ll)now*inv%mod;\n\t\t}\n\t}\n\tfor(int i=0;i<=sz[0];i++)\n\t\tfor(int j=0,k;j<=sz[1];j++) {\n\t\t\tk=i^j;\n\t\t\tupd(ans+=(ll)sum[0][i]*sum[1][j]%mod*sum[2][k]%mod-mod);\n\t\t}\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nmt19937 mt(736);\n\nconst int mod = 998244353;\n\n\nint powmod10(int n)\n{\n\tstatic vector<int> dp = {1};\n\n\twhile (n >= dp.size())\n\t\tdp.push_back((10ll * dp.back()) % mod);\n\n\treturn dp[n];\n}\n\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint n;\n\n\tcin >> n;\n\n\tarray<vector<vector<int>>, 3> xyz;\n\n\tfor (auto &gr : xyz)\n\t{\n\t\tgr.resize(n);\n\n\t\tint m;\n\n\t\tcin >> m;\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\n\t\t\tcin >> a >> b;\n\t\t\ta--;\n\t\t\tb--;\n\n\t\t\tgr[a].push_back(b);\n\t\t\tgr[b].push_back(a);\n\t\t}\n\t}\n\n\tarray<vector<int>, 3> mex;\n\n\tarray<ll, 3> wm{}, bm{};\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tmex[i].resize(n, -1);\n\n\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t{\n\t\t\tunordered_set<int> neigh;\n\n\t\t\tfor (auto it : xyz[i][j])\n\t\t\t\tneigh.insert(mex[i][it]);\n\n\t\t\tfor (mex[i][j] = 0; neigh.count(mex[i][j]); mex[i][j]++);\n\t\t}\n\t}\n\n\tarray<vector<ll>, 3> grundy;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tgrundy[i].resize(*max_element(mex[i].begin(), mex[i].end()) + 1);\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tgrundy[i][mex[i][j]] += powmod10(18 * (j + 1));\n\t}\n\n\tll ans = 0;\n\n\tfor (int x = 0; x < grundy[0].size(); x++)\n\t\tfor (int y = 0; y < grundy[1].size(); y++)\n\t\t{\n\t\t\tauto z = x ^y;\n\n\t\t\tif (z < grundy[2].size())\n\t\t\t\tans += grundy[0][x] * grundy[1][y] % mod * grundy[2][z] % mod;\n\t\t}\n\n\tcout << ans % mod << endl;\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcout << fixed;\n\n#ifdef LOCAL\n\tauto st = clock();\n\n\tifstream fin(\"../input.txt\");\n\n\tsolve(fin);\n\n\tcout << \"clock: \" << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tsolve();\n#endif\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,abm,mmx,popcnt,avx,avx2,tune=native\")\n           \n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n           \n//#define int long long\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pld;\n\ntemplate<typename T>\nusing kawaii_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n  \nvoid FAST_IO() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.setf(ios::fixed);\n    //cout.precision(20);\n    #ifndef _offline\n    //freopen(\"mincost.in\", \"r\", stdin);\n    //freopen(\"mincost.out\", \"w\", stdout);\n    #endif\n}\n\nconst ll mod = 998244353;\nconst ll kek = 716070898;\nconst int K = 350;\nconst int MAXN = 1e5 + 100;\nvector<int> g1[MAXN], g2[MAXN], g3[MAXN];\nint v1[MAXN], v2[MAXN], v3[MAXN];\nll s1[K], s2[K], s3[K];\n\nll binpow(ll a, ll n) {\n    ll res = 1;\n    while (n) {\n        if (n & 1) {\n            res = (res * a) % mod;\n        }\n        a = (a * a) % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nvoid relax1(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g1[u]) {\n        bs[v1[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v1[u] = i;\n            break;\n        }\n    }\n    s1[v1[u]] += binpow(kek, u + 1);\n    if (s1[v1[u]] >= mod) {\n        s1[v1[u]] -= mod;\n    }\n}\n\nvoid relax2(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g2[u]) {\n        bs[v2[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v2[u] = i;\n            break;\n        }\n    }\n    s2[v2[u]] += binpow(kek, u + 1);\n    if (s2[v2[u]] >= mod) {\n        s2[v2[u]] -= mod;\n    }\n}\n\nvoid relax3(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g3[u]) {\n        bs[v3[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v3[u] = i;\n            break;\n        }\n    }\n    s3[v3[u]] += binpow(kek, u + 1);\n    if (s3[v3[u]] >= mod) {\n        s3[v3[u]] -= mod;\n    }\n}\n\nsigned main() {\n    FAST_IO();\n    int n;\n    cin >> n;\n    int m1;\n    cin >> m1;\n    for (int i = 0; i < m1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g1[u].push_back(v);\n    }\n    int m2;\n    cin >> m2;\n    for (int i = 0; i < m2; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g2[u].push_back(v);\n    }\n    int m3;\n    cin >> m3;\n    for (int i = 0; i < m3; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g3[u].push_back(v);\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        relax1(i);\n        relax2(i);\n        relax3(i);\n    }\n    vector<tuple<int, int, int>> kektor;\n    for (int i = 0; i < K; ++i) {\n        if (s1[i] == 0) {\n            continue;\n        }\n        for (int j = 0; j < K; ++j) {\n            if (s2[j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < K; ++k) {\n                if (s3[k] == 0) {\n                    continue;\n                }\n                kektor.push_back({i, j, k});\n            }\n        }\n    }\n    sort(all(kektor), [&](tuple<int, int, int> a, tuple<int, int, int> b) {\n        return get<0>(a) + get<1>(a) + get<2>(a) < get<0>(b) + get<1>(b) + get<2>(b);\n    });\n    set<pii> xy, xz, yz;\n    ll ans = 0;\n    for (auto t : kektor) {\n        int x, y, z;\n        tie(x, y, z) = t;\n        if (xy.count({x, y}) || xz.count({x, z}) || yz.count({y, z})) {\n            continue;\n        }\n        ll val = (s1[x] * s2[y]) % mod;\n        val = (val * s3[z]) % mod;\n        ans += val;\n        if (ans >= mod) {\n            ans -= mod;\n        }\n        xy.insert({x, y});\n        xz.insert({x, z});\n        yz.insert({y, z});\n    }\n    cout << ans << '\\n';\n}  "
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=998244353;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tint i,j,n;cin>>n;\n\tllint S=1000000000000000000LL%mod;\n\t\n\t\n\tvector<llint>kei(n);\n\tkei[0]=S;\n\tfor(i=0;i<n-1;i++){kei[i+1]=kei[i]*S%mod;}\n\tint Lq=1;\n\twhile(Lq*Lq<n){Lq++;}\n\tLq*=2;\n\tLq+=10;\n\tllint L=1;\n\twhile(L<Lq){L*=2;}\n\t//cerr<<\"L=\"<<L<<endl;\n\tvector<llint>ans(L);ans[0]=1;\n\tfor(int kai=0;kai<3;kai++){\n\t\tint m;cin>>m;\n\t\tvector<vector<int>>go(n);\n\t\twhile(m--){\n\t\t\tint a,b;cin>>a>>b;a--;b--;\n\t\t\tif(a<b){swap(a,b);}\n\t\t\tgo[b].pub(a);\n\t\t}\n\t\tvector<int>gru(n);\n\t\tvector<int>hyo(L,mod);\n\t\tvector<llint>gen(L,0);\n\t\tfor(i=n-1;i>=0;i--){\n\t\t\tfor(auto it:go[i]){hyo[gru[it]]=i;}\n\t\t\tint g=0;\n\t\t\twhile(hyo[g]==i){g++;}\n\t\t\tgru[i]=g;\n\t\t\tgen[g]+=kei[i];gen[g]%=mod;\n\t\t}\n\t\tvector<llint>dp(L,0);\n\t\tfor(i=0;i<L;i++){\n\t\t\t//cerr<<gen[i]<<endl;\n\t\t\tfor(j=0;j<L;j++){\n\t\t\t\tdp[i^j]+=ans[i]*gen[j];\n\t\t\t\tdp[i^j]%=mod;\n\t\t\t}\n\t\t}\n\t\tans=dp;\n\t}\n\tcout<<ans[0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 998244353;\nconst int N = 1e5+7;\nconst long long B = 1000000000000000000;\ntypedef long long LL;\n\nLL pb[N];\nvoid pre() {\n    pb[0] = 1;\n    LL b = B%M;\n    for (int i=1; i<N; i++)\n        pb[i] = (pb[i-1]*b)%M;\n}\n\nvector<int> bfs(vector<vector<int>>adj) {\n    int n = adj.size()-1;\n    vector<int> col(n+1, N);\n\n    vector<bool> vis(n);\n    for (int i=n; i>0; i--) {\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 1;\n        }\n\n        for (int ii=0; ii<=n; ii++)\n            if (!vis[ii]) {\n                col[i] = ii;\n                break;\n            }\n\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 0;\n        }\n    }\n    return col;\n}\n\nint m[3];\nvector<vector<int>> adj[3];\nvector<int> dis[3];\nvector<LL> con[3];\n\nLL power(LL a, LL p) {\n    if (p == 0) return 1;\n    LL ans = power(a, p/2);\n    ans = (ans * ans)%M;\n    if (p%2)    ans = (ans * a)%M;\n    return ans;\n}\n\nvoid FWHT(vector< LL >&p, bool inverse) {\n    int n = p.size();\n    assert((n&(n-1))==0);\n\n    for (int len = 1; 2*len <= n; len <<= 1) {\n        for (int i = 0; i < n; i += len+len) {\n            for (int j = 0; j < len; j++) {\n                LL u = p[i+j];\n                LL v = p[i+len+j];\n                p[i+j] = u+v;\n                if (p[i+j] >= M)    p[i+j] -= M;\n                p[i+len+j] = u-v;\n                if (p[i+len+j] < 0) p[i+len+j] += M;\n            }\n        }\n    }\n    if (inverse) {\n        LL inv = power(n, M-2);\n        for (int i = 0; i < n; i++) {\n            p[i] = (p[i] * inv)%M;\n        }\n    }\n}\n\nint main() {\n    pre();\n\n    int n;\n    cin>>n;\n    const int MX = 1<<17;\n\n    for (int g=0; g<3; g++) {\n        cin>>m[g];\n        adj[g].resize(n+1);\n        for (int i=0; i<m[g]; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[g][u].push_back(v);\n            adj[g][v].push_back(u);\n        }\n        dis[g] = bfs(adj[g]);\n\n        con[g].resize(MX);\n        for (int i=1; i<=n; i++) {\n            con[g][dis[g][i]] = (con[g][dis[g][i]] + pb[i])%M;\n        }\n    }\n\n    vector<LL> ans(MX,1);\n    for (int g=0; g<3; g++) {\n        FWHT(con[g], false);\n        for (int i=0; i<MX; i++)\n            ans[i] = (ans[i] * con[g][i])%M;\n    }\n\n    FWHT(ans, true);\n    cout<<ans[0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n #include <stdio.h>\n #include <bits/stdc++.h>\n\n\n\n\n\n\nusing namespace std;\n\n\n\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n\n\n\n\n\n\nusing li = long long int;\nusing lu = long long unsigned;\nusing ld = long double;\n\n\nusing pii = tuple<li, li>;\nusing piii = tuple<li, li, li>;\nusing piiii = tuple<li, li, li, li>;\nusing vi = vector<li>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\nstruct empty_t {};\nnamespace tuple_access {\n\n  struct xx_t {} xx;\n  struct yy_t {} yy;\n  struct zz_t {} zz;\n  struct ww_t {} ww;\n\n  template<class T>\n  typename tuple_element<0,T>::type& operator^(T& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type const& operator^(T const& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type&& operator^(T&& v, xx_t) { return get<0>(v); }\n\n  template<class T>\n  typename tuple_element<1,T>::type& operator^(T& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type const& operator^(T const& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type&& operator^(T&& v, yy_t) { return get<1>(v); }\n\n  template<class T>\n  typename tuple_element<2,T>::type& operator^(T& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type const& operator^(T const& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type&& operator^(T&& v, zz_t) { return get<2>(v); }\n\n  template<class T>\n  typename tuple_element<3,T>::type& operator^(T& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type const& operator^(T const& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type&& operator^(T&& v, ww_t) { return get<3>(v); }\n}\nusing namespace tuple_access;\n\n\nint ilog2(int x){ return 31 - __builtin_clz(x); }\n\ntemplate <class T>\nstruct identity : std::unary_function <T, T> {\n  T operator() (const T& x) const {return x;}\n};\n\ntemplate<class T>\nT& smin(T& x, T const& y) { x = min(x,y); return x; }\n\ntemplate <class T>\nT& smax(T& x, T const& y) { x = max(x, y); return x; }\n\n\ntemplate<typename T>\nT isqrt(T const&x){\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(sqrtl(x));\n  while(ret>0 && ret*ret>x) --ret;\n  while(x-ret*ret>2*ret) ++ret;\n  return ret;\n}\n\ntemplate<typename T>\nT icbrt(T const&x) {\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(cbrt(x));\n  while(ret>0 && ret*ret*ret>x) --ret;\n  while(x-ret*ret*ret>3*ret*(ret+1)) ++ret;\n  return ret;\n}\nconst li MOD = 998'244'353;\n\n\n\ntemplate<li M = MOD>\nstruct Zn {\n  static_assert(M > 2, \"M > 2\");\n  static_assert(M < (1ll<<31), \"M < (1ll<<31)\");\n  int value;\n\n  Zn() : value(0) { }\n\n  Zn(int x) : value(x%M) {\n    if(value < 0) value += M;\n  }\n\n  Zn(li x) : value(x%M) {\n    if(value < 0) value += M;\n  }\n\n  Zn& operator+=(Zn const& o) {\n    value += o.value;\n    if(value >= M) value -= M;\n    return *this;\n  }\n\n  Zn& operator-=(Zn const& o) {\n    value += M - o.value;\n    if(value >= M) value -= M;\n    return *this;\n  }\n\n  Zn& operator*=(Zn const& o) {\n    value = ((li)value*(li)o.value)%M;\n    return *this;\n  }\n\n  Zn& operator/=(Zn const& o) {\n    return operator*=(o.inverse());\n  }\n\n  Zn operator-() const { Zn r; r.value = value ? M-value : 0; return r; }\n  Zn operator+(Zn const& o) const { Zn r; r.value = value+o.value; if(r.value>=M) r.value -= M; return r; }\n  Zn operator-(Zn const& o) const { Zn r; r.value = value+M-o.value; if(r.value>=M) r.value -= M; return r; }\n  Zn operator*(Zn const& o) const { return Zn((li)value * (li)o.value); }\n  Zn operator/(Zn const& o) const { Zn a = *this; a /= o; return a; }\n\n  Zn inverse() const {\n    int a = value, b = M, u = 0, v = 1;\n    while (a != 0) {\n      int t = b / a;\n      b -= t * a; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    return Zn(u);\n  }\n\n  bool operator==(Zn const& o) const { return value == o.value; }\n  bool operator!=(Zn const& o) const { return value != o.value; }\n  bool operator<(Zn const& o) const { return value < o.value; }\n  bool operator>(Zn const& o) const { return value > o.value; }\n  bool operator<=(Zn const& o) const { return value <= o.value; }\n  bool operator>=(Zn const& o) const { return value >= o.value; }\n};\n\ntemplate<li M>\nZn<M> pow(Zn<M> a, li b) {\n  Zn<M> r = 1;\n  while(b){\n    if(b&1) r = r*a;\n    a = a * a;\n    b /= 2;\n  }\n  return r;\n}\n\ntemplate<li M>\nZn<M> operator+(int const& x, Zn<M> const& o) { return Zn<M>(x) + o; }\ntemplate<li M>\nZn<M> operator+(li const& x, Zn<M> const& o) { return Zn<M>(x) + o; }\n\ntemplate<li M>\nZn<M> operator*(int const& x, Zn<M> const& o) { return Zn<M>(x) * o; }\ntemplate<li M>\nZn<M> operator*(li const& x, Zn<M> const& o) { return Zn<M>(x) * o; }\n\ntemplate<li M>\nZn<M> operator/(int const& x, Zn<M> const& o) { return Zn<M>(x) / o; }\ntemplate<li M>\nZn<M> operator/(li const& x, Zn<M> const& o) { return Zn<M>(x) / o; }\n\n\ntemplate<li M>\nostream& operator<<(ostream& ss, Zn<M> const& a) {\n  return ss << a.value;\n}\n\ntemplate<li M>\nistream& operator>>(istream& ss, Zn<M> &a) {\n  li x; ss>>x;\n  a = Zn<M>(x);\n  return ss;\n}\n\nvvi readg(int n) {\n  int m; cin>>m;\n  vvi G(n);\n  for(li i = 0; i < (li)(m); ++i) {\n    int u,v; cin>>u>>v;\n    --u; --v;\n    if(u>v) swap(u,v);\n    G[u].push_back(v);\n  }\n  return G;\n}\n\nconst int N = 1e5+10;\nusing ZN = Zn<>;\nZN P10[N+10];\n\nvector<ZN> splitg(int n, vvi const& G) {\n  vi C(n,0);\n  vector<ZN> r;\n  for(li i = (n-1); i >= (li)(0); --i) {\n    set<int> K; for(int j : G[i]) K.insert(C[j]);\n    while(K.count(C[i])) C[i] += 1;\n    while(C[i]>=(int)r.size())r.emplace_back(0);\n    r[C[i]] += P10[i+1];\n  }\n  return r;\n}\n\nbool takenab[1000][1000];\nbool takenbc[1000][1000];\nbool takenac[1000][1000];\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n\n  ZN p18 = pow(ZN(10), 18);\n  P10[0] = 1;\n  for(li i = 0; i < (li)(N); ++i) P10[i+1] = p18*P10[i];\n\n  int n; cin>>n;\n  vvi X = readg(n);\n  vvi Y = readg(n);\n  vvi Z = readg(n);\n\n  auto a = splitg(n,X);\n  auto b = splitg(n,Y);\n  auto c = splitg(n,Z);\n\n\n\n\n\n  ZN ans = 0;\n  for(li i = 0; i < (li)(a.size()); ++i) for(li j = 0; j < (li)(b.size()); ++j) for(li k = 0; k < (li)(c.size()); ++k) {\n    if(takenab[i][j]) continue;\n    if(takenac[i][k]) continue;\n    if(takenbc[j][k]) continue;\n    takenab[i][j]=1;\n    takenac[i][k]=1;\n    takenbc[j][k]=1;\n    ans += a[i]*b[j]*c[k];\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace chrono;\nusing namespace __gnu_pbds;\nmt19937 rng(high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rngll(high_resolution_clock::now().time_since_epoch().count());\ntemplate<typename T> T ctmax(T &x, const T &y){ return x = max(x, y); }\ntemplate<typename T> T ctmin(T &x, const T &y){ return x = min(x, y); }\ntemplate<typename T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\ntemplate<typename T>\nT modexp(T b, long long e){\n\tT res = 1;\n\tfor(; e; b *= b, e >>= 1) if(e & 1) res *= b;\n\treturn res;\n}\ntemplate<typename T>\nT modinv(T a, T m){\n\tT u = 0, v = 1;\n\twhile(a){\n\t\tT t = m / a;\n\t\tm -= t * a; swap(a, m);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tassert(m == 1);\n\treturn u;\n}\ntemplate<typename T>\nstruct Z_p{\n\tusing Type = typename decay<decltype(T::value)>::type;\n\tconstexpr Z_p(): value(){ }\n\ttemplate<typename U> Z_p(const U &x){ value = normalize(x); }\n\ttemplate<typename U> static Type normalize(const U &x){\n\t\tType v;\n\t\tif(-mod() <= x && x < mod()) v = static_cast<Type>(x);\n\t\telse v = static_cast<Type>(x % mod());\n\t\tif(v < 0) v += mod();\n\t\treturn v;\n\t}\n\tconst Type& operator()() const{ return value; }\n\ttemplate<typename U> explicit operator U() const{ return static_cast<U>(value); }\n\tconstexpr static Type mod(){ return T::value; }\n\tZ_p &operator+=(const Z_p &otr){ if((value += otr.value) >= mod()) value -= mod(); return *this; }\n\tZ_p &operator-=(const Z_p &otr){ if((value -= otr.value) < 0) value += mod(); return *this; }\n\ttemplate<typename U> Z_p &operator+=(const U &otr){ return *this += Z_p(otr); }\n\ttemplate<typename U> Z_p &operator-=(const U &otr){ return *this -= Z_p(otr); }\n\tZ_p &operator++(){ return *this += 1; }\n\tZ_p &operator--(){ return *this -= 1; }\n\tZ_p operator++(int){ Z_p result(*this); *this += 1; return result; }\n\tZ_p operator--(int){ Z_p result(*this); *this -= 1; return result; }\n\tZ_p operator-() const{ return Z_p(-value); }\n\ttemplate<typename U = T>\n\ttypename enable_if<is_same<typename Z_p<U>::Type, int>::value, Z_p>::type& operator*=(const Z_p& rhs){\n\t\t#ifdef _WIN32\n\t\tuint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n\t\tuint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n\t\tasm(\n\t\t\t\"divl %4; \\n\\t\"\n\t\t\t: \"=a\" (d), \"=d\" (m)\n\t\t\t: \"d\" (xh), \"a\" (xl), \"r\" (mod())\n\t\t);\n\t\tvalue = m;\n\t\t#else\n\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n\t\t#endif\n\t\treturn *this;\n\t}\n\ttemplate<typename U = T>\n\ttypename enable_if<is_same<typename Z_p<U>::Type, int64_t>::value, Z_p>::type& operator*=(const Z_p &rhs){\n\t\tint64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n\t\tvalue = normalize(value * rhs.value - q * mod());\n\t\treturn *this;\n\t}\n\ttemplate<typename U = T>\n\ttypename enable_if<!is_integral<typename Z_p<U>::Type>::value, Z_p>::type& operator*=(const Z_p &rhs){\n\t\tvalue = normalize(value * rhs.value);\n\t\treturn *this;\n\t}\n\tZ_p &operator/=(const Z_p &otr){ return *this *= Z_p(modinv(otr.value, mod())); }\n\ttemplate<typename U> friend const Z_p<U> &abs(const Z_p<U> &v){ return v; }\n\ttemplate<typename U> friend bool operator==(const Z_p<U> &lhs, const Z_p<U> &rhs);\n\ttemplate<typename U> friend bool operator<(const Z_p<U> &lhs, const Z_p<U> &rhs);\n\ttemplate<typename U> friend istream &operator>>(istream &in, Z_p<U> &number);\n\tType value;\n};\ntemplate<typename T> bool operator==(const Z_p<T> &lhs, const Z_p<T> &rhs){ return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Z_p<T>& lhs, U rhs){ return lhs == Z_p<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) == rhs; }\ntemplate<typename T> bool operator!=(const Z_p<T> &lhs, const Z_p<T> &rhs){ return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Z_p<T> &lhs, U rhs){ return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Z_p<T> &rhs){ return !(lhs == rhs); }\ntemplate<typename T> bool operator<(const Z_p<T> &lhs, const Z_p<T> &rhs){ return lhs.value < rhs.value; }\ntemplate<typename T> Z_p<T> operator+(const Z_p<T> &lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Z_p<T> operator+(const Z_p<T> &lhs, U rhs){ return Z_p<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Z_p<T> operator+(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) += rhs; }\ntemplate<typename T> Z_p<T> operator-(const Z_p<T> &lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator-(const Z_p<T>& lhs, U rhs){ return Z_p<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator-(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) -= rhs; }\ntemplate<typename T> Z_p<T> operator*(const Z_p<T> &lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator*(const Z_p<T>& lhs, U rhs){ return Z_p<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator*(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) *= rhs; }\ntemplate<typename T> Z_p<T> operator/(const Z_p<T> &lhs, const Z_p<T> &rhs) { return Z_p<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator/(const Z_p<T>& lhs, U rhs) { return Z_p<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator/(U lhs, const Z_p<T> &rhs) { return Z_p<T>(lhs) /= rhs; }\ntemplate<typename T> istream &operator>>(istream &in, Z_p<T> &number){\n\ttypename common_type<typename Z_p<T>::Type, int64_t>::type x;\n\tin >> x;\n\tnumber.value = Z_p<T>::normalize(x);\n\treturn in;\n}\ntemplate<typename T> ostream &operator<<(ostream &out, const Z_p<T> &number){ return out << number(); }\nconstexpr int mod = 998244353;\nusing Zp = Z_p<integral_constant<decay<decltype(mod)>::type, mod>>;\n\nint main(){\n\tcin.tie(0)->sync_with_stdio(0);\n\tint n;\n\tcin >> n;\n\tvector<int> m(3);\n\tvector<vector<vector<int>>> adj(3, vector<vector<int>>(n));\n\tfor(int i = 0; i < 3; ++ i){\n\t\tcin >> m[i];\n\t\tfor(int j = 0; j < m[i]; ++ j){\n\t\t\tint u, v;\n\t\t\tcin >> u >> v, -- u, -- v;\n\t\t\tadj[i][u].push_back(v), adj[i][v].push_back(u);\n\t\t}\n\t}\n\tconst Zp base = (long long)1e18;\n\tvector<Zp> p(n + 1, 1);\n\tfor(int i = 0; i < n; ++ i){\n\t\tp[i + 1] = p[i] * base;\n\t}\n\tvector<vector<Zp>> layer(3);\n\tfor(int i = 0; i < 3; ++ i){\n\t\tvector<int> used(n), cur(n);\n\t\tint rem = n;\n\t\twhile(rem){\n\t\t\tlayer[i].emplace_back();\n\t\t\tfill(cur.begin(), cur.end(), false);\n\t\t\tfor(int u = n - 1; u >= 0; -- u){\n\t\t\t\tif(!used[u] && !cur[u]){\n\t\t\t\t\tused[u] = cur[u] = true;\n\t\t\t\t\t-- rem;\n\t\t\t\t\tlayer[i].back() += p[u + 1];\n\t\t\t\t\tfor(auto v: adj[i][u]){\n\t\t\t\t\t\tcur[v] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tZp res = 0;\n\tfor(int i = 0; i < int(layer[0].size()); ++ i){\n\t\tfor(int j = 0; j < int(layer[1].size()); ++ j){\n\t\t\tfor(int k = 0; k < int(layer[2].size()); ++ k){\n\t\t\t\tif(!(i ^ j ^ k)){\n\t\t\t\t\tres += layer[0][i] * layer[1][j] * layer[2][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << res;\n\treturn 0;\n}\n\n/*\n\n*/\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n//                                   Coded by Aeren                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nlong long pow10(long long p){\n    long long res = 1;\n    long long cur = 10;\n    while(p){\n        if(p%2) res = (res*cur)%MOD;\n        cur = (cur*cur)%MOD;\n        p /= 2;\n    }\n    return res;\n}\n\nvector<long long> makeGrundy(int N){\n    int M; cin >> M;\n    vector<vector<int>> g(N+1);\n    for(int i=0;i<M;i++){\n        int a, b; cin >> a >> b;\n        if(a > b) swap(a, b);\n        g[a].push_back(b);\n    }\n    vector<int> grundy(N+1);\n    vector<long long> res(512, 0);\n    grundy[N] = 0;\n    res[0] = pow10(18*N);\n    for(int i=N-1;i>=1;i--){\n        vector<int> visit(512, 0);\n        for(auto& t : g[i]){\n             visit[grundy[t]] = 1;\n        }\n        for(int j=0;j<512;j++){\n            if(!visit[j]){\n                grundy[i] = j;\n                res[j] = (res[j] + pow10(18*i)) % MOD;\n                break;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N; cin >> N;\n    auto g1 = makeGrundy(N);\n    auto g2 = makeGrundy(N);\n    auto g3 = makeGrundy(N);\n    long long res = 0;\n    for(int i=0;i<512;i++){\n        for(int j=0;j<512;j++){\n            res = (res + g1[i] * g2[j] % MOD * g3[i^j] % MOD) % MOD;\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// BEGIN CUT HERE\ntemplate <typename T>\nclass Vector : public vector<T> {\n    using parent = vector<T>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const T& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<T> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    const T& operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    T& operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<T>& operator=(Vector<T>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<T>& operator=(const Vector<T>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\ntemplate <>\nclass Vector<bool> : public vector<bool> {\n    using parent = vector<bool>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<bool> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    parent::const_reference operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    parent::reference operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<bool>& operator=(const Vector<bool>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\n#ifdef LOCAL\n#define vec Vector\n#else\n// END CUT HERE\n#define vec vector\n// BEGIN CUT HERE\n#endif\n// END CUT HERE\n\nusing vi = vec<int>;\n\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) {\n        allocate(n);\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i = 0; i < n; ++i) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr3d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int shift;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    const T& operator()(int i1, int i2, int i3) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    arr2d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr2d<T>(b + at * shift, d2, d3);\n    }\n\n    vector<vector<vector<T>>> view() {\n        vector<vector<vector<T>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr4d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int d4;\n    int shift1;\n    int shift2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n    }\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    int dim4() const {\n        return d4;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3, int i4) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    const T& operator()(int i1, int i2, int i3, int i4) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    arr3d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr3d<T>(b + at * shift1, d2, d3, d4);\n    }\n\n    vector<vector<vector<vector<T>>>> view() {\n        vector<vector<vector<vector<T>>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n);\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vec<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vec<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        if (c == EOF) {\n            exhausted = true;\n        }\n        return c;\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    ll readLong() {\n        return readInteger<ll>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return string(all(res));\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i = 0; i < n; i++) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return string(all(res));\n    }\n\n    double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    bool isExhausted() { return exhausted; }\n\n    void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ndouble Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\nint Input::readType() {\n    return readInt();\n}\n\ntemplate <>\nll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\nchar Input::readType() {\n    return readChar();\n}\n\ntemplate <>\nstring Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream& out = cout;\n\n    template <typename T>\n    void printSingle(const T& value) {\n        out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vec<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                out << array(i, j);\n                if (j + 1 != m) {\n                    out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    void printSingle(const pair<T, U>& value) {\n        out << value.first << ' ' << value.second;\n    }\n\npublic:\n    Output() {//ostream& out) : out(out) {\n        out << fixed << setprecision(20);\n    }\n\n    void print() {}\n\n    template <typename T, typename...Targs>\n    void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            out << ' ';\n            print(args...);\n        }\n    }\n\n    template <typename...Targs>\n    void printLine(const Targs... args) {\n        print(args...);\n        out << '\\n';\n    }\n\n    void flush() {\n        out.flush();\n    }\n};\n\nOutput out;\n\n\ntemplate <typename W, typename C>\nclass WeightedFlowEdge {\nprivate:\n    WeightedFlowEdge<W, C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    C capacity;\n    int id;\n\n    WeightedFlowEdge(int from, int to, W weight, C capacity) : from(from), to(to), weight(weight), capacity(capacity) {\n        reverseEdge = new WeightedFlowEdge(this);\n    }\n\n    WeightedFlowEdge<W, C>* transposed() { return nullptr; }\n\n    WeightedFlowEdge<W, C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    WeightedFlowEdge(WeightedFlowEdge<W, C>* reverse) : from(reverse->to), to(reverse->from), weight(-reverse->weight),\n                                                        capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename C>\nclass FlowEdge {\nprivate:\n    FlowEdge<C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    C capacity;\n    int id;\n\n    FlowEdge(int from, int to, C capacity) : from(from), to(to), capacity(capacity) {\n        reverseEdge = new FlowEdge(this);\n    }\n\n    FlowEdge<C>* transposed() { return nullptr; }\n\n    FlowEdge<C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    FlowEdge(FlowEdge<C>* reverse) : from(reverse->to), to(reverse->from), capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename W>\nclass WeightedEdge {\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    WeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n    }\n\n    WeightedEdge<W>* transposed() { return nullptr; }\n\n    WeightedEdge<W>* reverse() { return nullptr; }\n};\n\ntemplate <typename W>\nclass BiWeightedEdge {\nprivate:\n    BiWeightedEdge<W>* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    BiWeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n        transposedEdge = new BiWeightedEdge(this);\n    }\n\n    BiWeightedEdge<W>* transposed() { return transposedEdge; }\n\n    BiWeightedEdge<W>* reverse() { return nullptr; }\n\nprivate:\n    BiWeightedEdge(BiWeightedEdge<W>* transposed) : from(transposed->to), to(transposed->from),\n                                                    weight(transposed->weight) {\n        transposedEdge = transposed;\n    }\n};\n\nclass BaseEdge {\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BaseEdge(int from, int to) : from(from), to(to) {\n    }\n\n    BaseEdge* transposed() { return nullptr; }\n\n    BaseEdge* reverse() { return nullptr; }\n};\n\nclass BiEdge {\nprivate:\n    BiEdge* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BiEdge(int from, int to) : from(from), to(to) {\n        transposedEdge = new BiEdge(this);\n    }\n\n    BiEdge* transposed() { return transposedEdge; }\n\n    BiEdge* reverse() { return nullptr; }\n\nprivate:\n    BiEdge(BiEdge* transposed) : from(transposed->to), to(transposed->from) {\n        transposedEdge = transposed;\n    }\n};\n\ntemplate <class Edge>\nclass Graph {\npublic:\n    int vertexCount;\n    int edgeCount = 0;\nprivate:\n    vec<vec<Edge*>> edges;\n\npublic:\n    Graph(int vertexCount) : vertexCount(vertexCount), edges(vertexCount, vec<Edge*>()) {}\n\n    void addEdge(Edge* edge) {\n#ifdef LOCAL\n        if (edge->from < 0 || edge->to < 0 || edge->from >= vertexCount || edge->to >= vertexCount) {\n            throw \"Out of bounds\";\n        }\n#endif\n        edge->id = edgeCount;\n        edges[edge->from].push_back(edge);\n        Edge* reverse = edge->reverse();\n        if (reverse != nullptr) {\n            reverse->id = edgeCount;\n            edges[reverse->from].push_back(reverse);\n        }\n        Edge* transposed = edge->transposed();\n        if (transposed != nullptr) {\n            edges[transposed->from].push_back(transposed);\n            transposed->id = edgeCount;\n            Edge* transRev = transposed->reverse();\n            if (transRev != nullptr) {\n                edges[transRev->from].push_back(transRev);\n                transRev->id = edgeCount;\n            }\n        }\n        edgeCount++;\n    }\n\n    template <typename...Ts>\n    void addEdge(Ts...args) {\n        addEdge(new Edge(args...));\n    }\n\n    vec<Edge*>& operator[](int at) {\n        return edges[at];\n    }\n\n    void addVertices(int count) {\n        vertexCount += count;\n        edges.resize(vertexCount);\n    }\n};\n\n\nconst int MOD7 = 1000000007;\nconst int MOD9 = 1000000009;\nconst int MODF = 998244353;\n\nint mod = MOD7;\n\ntemplate <typename T>\nT gcd(T a, T b, T& x, T& y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int d = gcd(b % a, a, y, x);\n    x -= (b / a) * y;\n    return d;\n}\n\nclass modint {\npublic:\n    int n;\n\n    modint() : n(0) {}\n\n    modint(ll n) {\n        if (n >= 0 && n < mod) {\n            this->n = n;\n            return;\n        }\n        n %= mod;\n        if (n < 0) {\n            n += mod;\n        }\n        this->n = n;\n    }\n\n    modint& operator+=(const modint& other) {\n        n += other.n;\n        if (n >= mod) {\n            n -= mod;\n        }\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        n -= other.n;\n        if (n < 0) {\n            n += mod;\n        }\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        n = ll(n) * other.n % mod;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n#ifdef LOCAL\n        if (other.n == 0) {\n            throw \"Division by zero\";\n        }\n#endif\n        return *this *= other.inverse();\n    }\n\n    modint operator-() {\n        if (n == 0) {\n            return 0;\n        }\n        return modint(mod - n);\n    }\n\n    modint inverse() const {\n        ll x, y;\n        ll g = gcd(ll(n), ll(mod), x, y);\n#ifdef LOCAL\n        if (g != 1) {\n            throw \"not inversable\";\n        }\n#endif\n        return x;\n    }\n\n    int log(modint alpha);\n};\n\nmodint operator+(const modint& a, const modint& b) {\n    return modint(a) += b;\n}\n\nmodint operator-(const modint& a, const modint& b) {\n    return modint(a) -= b;\n}\n\nmodint operator*(const modint& a, const modint& b) {\n    return modint(a) *= b;\n}\n\nmodint operator/(const modint& a, const modint& b) {\n    return modint(a) /= b;\n}\n\nostream& operator<<(ostream& out, const modint& val) {\n    return out << val.n;\n}\n\nbool operator==(const modint& a, const modint& b) {\n    return a.n == b.n;\n}\n\nbool operator!=(const modint& a, const modint& b) {\n    return a.n != b.n;\n}\n\nnamespace std {\n    template <>\n    struct hash<modint> {\n        size_t operator()(const modint& n) const {\n            return n.n;\n        }\n    };\n}\n\nint modint::log(modint alpha) {\n    unordered_map<modint, int> base;\n    int exp = 0;\n    modint pow = 1;\n    modint inv = *this;\n    modint alInv = alpha.inverse();\n    while (exp * exp < mod) {\n        if (inv == 1) {\n            return exp;\n        }\n        base[inv] = exp++;\n        pow *= alpha;\n        inv *= alInv;\n    }\n    modint step = pow;\n    for (int i = 1;; i++) {\n        if (base.count(pow)) {\n            return exp * i + base[pow];\n        }\n        pow *= step;\n    }\n}\n\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        a = a % b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T>\nT lcm(T a, T b) {\n    return a / gcd(a, b) * b;\n}\n\ntemplate <typename T>\nT power(const T& a, ll b) {\n    if (b == 0) {\n        return 1;\n    }\n    if ((b & 1) == 0) {\n        T res = power(a, b >> 1);\n        return res * res;\n    } else {\n        return power(a, b - 1) * a;\n    }\n}\n\ntemplate <typename T>\nT factorial(int n) {\n    T result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> factorials(int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> powers(T base, int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * base;\n    }\n    return result;\n}\n\n\nclass ReverseNumberIterator : public NumberIterator {\npublic:\n    ReverseNumberIterator(int v) : NumberIterator(v) {}\n\n    ReverseNumberIterator& operator++() {\n        --v;\n        return *this;\n    }\n};\n\nclass RevRange : pii {\npublic:\n    RevRange(int begin, int end) : pii(begin - 1, min(begin, end) - 1) {}\n\n    RevRange(int n) : pii(n - 1, min(n, 0) - 1) {}\n\n    ReverseNumberIterator begin() {\n        return first;\n    }\n\n    ReverseNumberIterator end() {\n        return second;\n    }\n};\n\n\nclass CGiantGraph {\npublic:\n    void solve() {\n        int n = in.readInt();\n        arri m(3);\n        arr<Graph<BaseEdge>> graphs(3, Graph<BaseEdge>(n));\n        for (int i : range(3)) {\n            m[i] = in.readInt();\n            arri u, v;\n            in.readArrays(m[i], u, v);\n            decreaseByOne(u, v);\n            for (int j : range(m[i])) {\n                graphs[i].addEdge(min(u[j], v[j]), max(u[j], v[j]));\n            }\n        }\n\n        mod = MODF;\n        auto p = powers(modint(1000000000000000000ll), n + 1);\n        arr2d<modint> levels(3, n, 0);\n        arri level(n);\n        for (int i : range(3)) {\n            level[n - 1] = 0;\n            levels(i, 0) += p[n];\n            for (int j : RevRange(n - 1)) {\n                unordered_set<int> bad;\n                for (auto* e : graphs[i][j]) {\n                    bad.insert(level[e->to]);\n                }\n                for (int k : range(n)) {\n                    if (!bad.count(k)) {\n                        level[j] = k;\n                        levels(i, k) += p[j + 1];\n                        break;\n                    }\n                }\n            }\n        }\n        modint answer = levels(0, 0) * levels(1, 0) * levels(2, 0);\n        for (int i : range(3)) {\n            for (int j : range(i)) {\n                for (int k : range(1, n)) {\n                    answer += levels(i, k) * levels(j, k) * levels(3 - i - j, 0);\n                }\n            }\n        }\n        out.printLine(answer);\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    CGiantGraph solver;\n\n\n    solver.solve();\n    fflush(stdout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nint bp(int x, int y) {\n\tif (y==0) return 1;\n\tif (y==1) return x%mod;\n\tif (y%2) return ((ll) x * bp(x, y-1)) % mod;\n\tint t = bp(x, y/2);\n\treturn ((ll) t * t) % mod;\n}\n\nint n;\n\nvector<vector<int> > gr;\n\nvector<int> get() {\n\n\n\tvector<int> grundy(n, 0);\n\n\tgr.assign(n, {});\n\n\tint m;\n\tcin >> m;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tif (u > v) swap(u, v);\n\t\tgr[u].push_back(v);\n\t}\n\n\tfor (int i = n-1; i >= 0; i--) {\n\t\tset<int> kek;\n\t\tfor (int j = 0; j < gr[i].size(); ++j) {\n\t\t\tint to = gr[i][j];\n\t\t\tkek.insert(grundy[to]);\n\t\t}\n\t\tint Q = 0;\n\t\twhile (kek.count(Q)) Q++;\n\t\tgrundy[i] = Q;\n\t}\n\n\tvector<int> rg(n, 0);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint Q = bp(10, 18);\n\t\tQ = bp(Q, i+1);\n\n\t\trg[grundy[i]] += Q;\n\t\trg[grundy[i]] %= mod;\n\t}\n\n\tgrundy = rg;\n\n\n\treturn grundy;\n\n}\n\n\n// u can set modular arithmetic here\nvoid hadamard(vector<int>& v){\n\tint K = v.size();\n    for (int step=K; step > 1; step /= 2){\n        for (int start=0; start < K; start += step){\n            for (int w=0; w < step/2; w++){\n                int F = (v[start+w] + v[start+step/2+w]) % mod;\n                int S = (v[start+w] - v[start+step/2+w] + mod) % mod;\n                v[start + w] = F;\n                v[start+step/2+w] = S;\n            }\n        }\n    }\n}\n\n\nvector<int> mult(vector<int> a, vector<int> b) {\n\tint n = 1;\n\twhile (n < a.size() || n < b.size()) n *= 2;\n\twhile (a.size() < n) a.push_back(0);\n\twhile (b.size() < n) b.push_back(0);\n\n    hadamard(a);\n    hadamard(b);\n    for (int i=0; i < a.size(); i++) a[i] = ((ll) a[i] * b[i]) % mod;\n    hadamard(a);\n\tint R = bp(a.size(), mod-2);\n    for (int i=0; i < a.size(); i++) a[i] = ((ll) a[i] * R) % mod;\n\n    return a;\n    // f is ur answer\n}\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"A_input.txt\", \"r\", stdin);\n\t//freopen(\"A_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n\n\tvector<vector<int> > arr;\n\n\tfor (int i = 0; i < 3; ++i) {\n\t\tauto kek = get();\n\t\tarr.push_back(kek);\n\t}\t\n\n\tvector<int> c = {0, 1}, d = {0, 1};\n\tvector<int> e = mult(c, d);\n\n\tvector<int> a = mult(arr[0], mult(arr[1], arr[2]));\n\n\n\tcout << a[0];\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nlld arr[300000];\nvector<lld> adj[300000][3];\nar<lld,3> siz;\nlld grundy[300000][3];\nmap<lld,lld> sums[3];\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nvoid dfs_grundy(lld node,lld grp){\n    if (grundy[node][grp]!=-1)return ;\n    grundy[node][grp]=0;\n    vector<lld> mex;\n    //nums[0][grp]++;\n    for (auto it:adj[node][grp]){\n        if (it<node) continue;\n        dfs_grundy(it,grp);\n        mex.pb(grundy[it][grp]);\n    }\n    if (mex.empty()) {sums[grp][0]+=fastpower(10,18*(node+1),modd);sums[grp][0]%=modd;return;}\n    sort(all(mex));\n    rep(i,0,mex.size()-1){\n        if (i!=mex[i]){\n            grundy[node][grp]=i;\n        //    nums[0][grp]--;\n      //      nums[i][grp]++;\n            sums[grp][i]+=fastpower(10,18*(node+1),modd);sums[grp][i]%=modd;\n            return ;\n        }\n    }\n    grundy[node][grp]=mex.size();\n    //nums[0][grp]--;\n    //nums[mex.size()][grp]++;\n    sums[grp][mex.size()]+=fastpower(10,18*(node+1),modd);sums[grp][mex.size()]%=modd;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,r,k,c,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n//     ans=0;\n     //cin>>TESTS;\n     memset(grundy,-1,sizeof(grundy));\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(j,0,2){\n         cin>>siz[j];\n         rep(i,0,siz[j]-1){\n            cin>>a>>b;a--;b--;\n            adj[a][j].pb(b);\n            adj[b][j].pb(a);\n         }\n         }\n         rep(j,0,2) rep(i,0,n-1) dfs_grundy(i,j);\n         lld ans=0;\n         rep(i,0,1000) rep(j,0,1000) {\n            lld k=i^j;\n            if(k<sums[2].size())ans+=(((sums[0][i]*sums[1][j])%modd)*sums[2][k])%modd;\n            ans%=modd;\n         }\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n\nconstexpr ll MOD = 998244353;\nconstexpr int IMAX = 450;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    vb usedrow(IMAX, false);\n    vector<vb> used(IMAX, usedrow);\n\n    vector<tuple<int, int, int>> good;\n    for (int i=0;i<IMAX;i++) {\n        good.push_back(tuple<int, int, int>{0, i , i});\n        // cout << 0 << \" \" << i << \" \" << i << endl;\n    }\n\n    for (int i=1;i<IMAX;i++) {\n        // cout << \"i = \" << i << endl;\n        int j = i+1;\n        while (j < IMAX) {\n            while (j < IMAX && used[i][j]) {\n                j++;\n            }\n            if (j < IMAX) {\n                int k = j+1;\n                while (k < IMAX && (used[i][k] || used[j][k])) {\n                    k++;\n                }\n                if (k < IMAX) {\n                    good.push_back(tuple<int, int, int>{i, j, k});\n                    // cout << i << \" \" << j << \" \" << k << endl;\n                    used[i][j] = true;\n                    used[i][k] = true;\n                    used[j][k] = true;\n                }\n            }\n            j++;\n        }\n    }\n\n    // cout << good.size() << endl;\n\n    int N;\n    cin >> N;\n    vvi adj1(N);\n    vvi adj2(N);\n    vvi adj3(N);\n\n    int M1;\n    cin >> M1;\n    for (int i=0;i<M1;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj1[u].push_back(v);\n        adj1[v].push_back(u);\n    }\n\n    int M2;\n    cin >> M2;\n    for (int i=0;i<M2;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj2[u].push_back(v);\n        adj2[v].push_back(u);\n    }\n\n    int M3;\n    cin >> M3;\n    for (int i=0;i<M3;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj3[u].push_back(v);\n        adj3[v].push_back(u);\n    }\n\n    vi label1(N, 0);\n    vi label2(N, 0);\n    vi label3(N, 0);\n\n    vb levels(IMAX, false);\n    int max_label = 0;\n    for (int i=N-1;i>=0;i--) {\n        for (int nbr : adj1[i]) {\n            if (nbr > i) levels[label1[nbr]] = true;\n            \n        }\n        while(levels[label1[i]]) label1[i]++;\n        max_label = max(max_label, label1[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj2[i]) {\n            if (nbr > i) levels[label2[nbr]] = true;\n            \n        }\n        while(levels[label2[i]]) label2[i]++;\n        max_label = max(max_label, label2[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj3[i]) {\n            if (nbr > i) levels[label3[nbr]] = true;\n            \n        }\n        while(levels[label3[i]]) label3[i]++;\n        max_label = max(max_label, label3[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n    }\n\n    // for (int i=0;i<N;i++) {\n    //     cout << i << \" \" << label1[i] << \" \" << label2[i] << \" \" << label3[i] << endl;\n    // }\n\n    vector<modnum<MOD>> wts1(IMAX+1, 0);\n    vector<modnum<MOD>> wts2(IMAX+1, 0);\n    vector<modnum<MOD>> wts3(IMAX+1, 0);\n\n    modnum<MOD> base = modnum<MOD>(10).pow(18);\n    for (int i=0;i<N;i++) {\n        wts1[label1[i]] += base.pow(i+1);\n        wts2[label2[i]] += base.pow(i+1);\n        wts3[label3[i]] += base.pow(i+1);\n    }\n\n    // cout << \"weights: \" << endl;\n    // for (int i=0;i<5;i++) {\n    //     cout << i << \" \" << wts1[i] << \" \" << wts2[i] << \" \" << wts3[i] << endl;\n    // }\n\n    modnum<MOD> ans = 0;\n\n    for (auto gtrip : good) {\n        int x = get<0>(gtrip);\n        int y = get<1>(gtrip);\n        int z = get<2>(gtrip);\n\n        if (x == y  && x == z) {\n            ans += wts1[x] * wts2[y] * wts3[z];\n        } else if (y == z) {\n            ans += wts1[x] * wts2[y] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[y];\n            ans += wts1[y] * wts2[y] * wts3[x];\n        } else {\n            ans += wts1[x] * wts2[y] * wts3[z];\n            ans += wts1[x] * wts2[z] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[z];\n            ans += wts1[y] * wts2[z] * wts3[x];\n            ans += wts1[z] * wts2[x] * wts3[y];\n            ans += wts1[z] * wts2[y] * wts3[x];\n        }\n    }\n\n    cout << ans << endl;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// BEGIN CUT HERE\ntemplate <typename T>\nclass Vector : public vector<T> {\n    using parent = vector<T>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const T& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<T> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    const T& operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    T& operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<T>& operator=(Vector<T>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<T>& operator=(const Vector<T>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\ntemplate <>\nclass Vector<bool> : public vector<bool> {\n    using parent = vector<bool>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<bool> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    parent::const_reference operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    parent::reference operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<bool>& operator=(const Vector<bool>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\n#ifdef LOCAL\n#define vec Vector\n#else\n// END CUT HERE\n#define vec vector\n// BEGIN CUT HERE\n#endif\n// END CUT HERE\n\nusing vi = vec<int>;\n\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) {\n        allocate(n);\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i = 0; i < n; ++i) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr3d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int shift;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    const T& operator()(int i1, int i2, int i3) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    arr2d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr2d<T>(b + at * shift, d2, d3);\n    }\n\n    vector<vector<vector<T>>> view() {\n        vector<vector<vector<T>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr4d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int d4;\n    int shift1;\n    int shift2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n    }\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    int dim4() const {\n        return d4;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3, int i4) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    const T& operator()(int i1, int i2, int i3, int i4) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    arr3d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr3d<T>(b + at * shift1, d2, d3, d4);\n    }\n\n    vector<vector<vector<vector<T>>>> view() {\n        vector<vector<vector<vector<T>>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n);\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vec<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vec<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        if (c == EOF) {\n            exhausted = true;\n        }\n        return c;\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    ll readLong() {\n        return readInteger<ll>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return string(all(res));\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i = 0; i < n; i++) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return string(all(res));\n    }\n\n    double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    bool isExhausted() { return exhausted; }\n\n    void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ndouble Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\nint Input::readType() {\n    return readInt();\n}\n\ntemplate <>\nll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\nchar Input::readType() {\n    return readChar();\n}\n\ntemplate <>\nstring Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream& out = cout;\n\n    template <typename T>\n    void printSingle(const T& value) {\n        out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vec<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                out << array(i, j);\n                if (j + 1 != m) {\n                    out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    void printSingle(const pair<T, U>& value) {\n        out << value.first << ' ' << value.second;\n    }\n\npublic:\n    Output() {//ostream& out) : out(out) {\n        out << fixed << setprecision(20);\n    }\n\n    void print() {}\n\n    template <typename T, typename...Targs>\n    void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            out << ' ';\n            print(args...);\n        }\n    }\n\n    template <typename...Targs>\n    void printLine(const Targs... args) {\n        print(args...);\n        out << '\\n';\n    }\n\n    void flush() {\n        out.flush();\n    }\n};\n\nOutput out;\n\n\ntemplate <typename W, typename C>\nclass WeightedFlowEdge {\nprivate:\n    WeightedFlowEdge<W, C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    C capacity;\n    int id;\n\n    WeightedFlowEdge(int from, int to, W weight, C capacity) : from(from), to(to), weight(weight), capacity(capacity) {\n        reverseEdge = new WeightedFlowEdge(this);\n    }\n\n    WeightedFlowEdge<W, C>* transposed() { return nullptr; }\n\n    WeightedFlowEdge<W, C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    WeightedFlowEdge(WeightedFlowEdge<W, C>* reverse) : from(reverse->to), to(reverse->from), weight(-reverse->weight),\n                                                        capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename C>\nclass FlowEdge {\nprivate:\n    FlowEdge<C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    C capacity;\n    int id;\n\n    FlowEdge(int from, int to, C capacity) : from(from), to(to), capacity(capacity) {\n        reverseEdge = new FlowEdge(this);\n    }\n\n    FlowEdge<C>* transposed() { return nullptr; }\n\n    FlowEdge<C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    FlowEdge(FlowEdge<C>* reverse) : from(reverse->to), to(reverse->from), capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename W>\nclass WeightedEdge {\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    WeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n    }\n\n    WeightedEdge<W>* transposed() { return nullptr; }\n\n    WeightedEdge<W>* reverse() { return nullptr; }\n};\n\ntemplate <typename W>\nclass BiWeightedEdge {\nprivate:\n    BiWeightedEdge<W>* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    BiWeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n        transposedEdge = new BiWeightedEdge(this);\n    }\n\n    BiWeightedEdge<W>* transposed() { return transposedEdge; }\n\n    BiWeightedEdge<W>* reverse() { return nullptr; }\n\nprivate:\n    BiWeightedEdge(BiWeightedEdge<W>* transposed) : from(transposed->to), to(transposed->from),\n                                                    weight(transposed->weight) {\n        transposedEdge = transposed;\n    }\n};\n\nclass BaseEdge {\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BaseEdge(int from, int to) : from(from), to(to) {\n    }\n\n    BaseEdge* transposed() { return nullptr; }\n\n    BaseEdge* reverse() { return nullptr; }\n};\n\nclass BiEdge {\nprivate:\n    BiEdge* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BiEdge(int from, int to) : from(from), to(to) {\n        transposedEdge = new BiEdge(this);\n    }\n\n    BiEdge* transposed() { return transposedEdge; }\n\n    BiEdge* reverse() { return nullptr; }\n\nprivate:\n    BiEdge(BiEdge* transposed) : from(transposed->to), to(transposed->from) {\n        transposedEdge = transposed;\n    }\n};\n\ntemplate <class Edge>\nclass Graph {\npublic:\n    int vertexCount;\n    int edgeCount = 0;\nprivate:\n    vec<vec<Edge*>> edges;\n\npublic:\n    Graph(int vertexCount) : vertexCount(vertexCount), edges(vertexCount, vec<Edge*>()) {}\n\n    void addEdge(Edge* edge) {\n#ifdef LOCAL\n        if (edge->from < 0 || edge->to < 0 || edge->from >= vertexCount || edge->to >= vertexCount) {\n            throw \"Out of bounds\";\n        }\n#endif\n        edge->id = edgeCount;\n        edges[edge->from].push_back(edge);\n        Edge* reverse = edge->reverse();\n        if (reverse != nullptr) {\n            reverse->id = edgeCount;\n            edges[reverse->from].push_back(reverse);\n        }\n        Edge* transposed = edge->transposed();\n        if (transposed != nullptr) {\n            edges[transposed->from].push_back(transposed);\n            transposed->id = edgeCount;\n            Edge* transRev = transposed->reverse();\n            if (transRev != nullptr) {\n                edges[transRev->from].push_back(transRev);\n                transRev->id = edgeCount;\n            }\n        }\n        edgeCount++;\n    }\n\n    template <typename...Ts>\n    void addEdge(Ts...args) {\n        addEdge(new Edge(args...));\n    }\n\n    vec<Edge*>& operator[](int at) {\n        return edges[at];\n    }\n\n    void addVertices(int count) {\n        vertexCount += count;\n        edges.resize(vertexCount);\n    }\n};\n\n\nconst int MOD7 = 1000000007;\nconst int MOD9 = 1000000009;\nconst int MODF = 998244353;\n\nint mod = MOD7;\n\ntemplate <typename T>\nT gcd(T a, T b, T& x, T& y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int d = gcd(b % a, a, y, x);\n    x -= (b / a) * y;\n    return d;\n}\n\nclass modint {\npublic:\n    int n;\n\n    modint() : n(0) {}\n\n    modint(ll n) {\n        if (n >= 0 && n < mod) {\n            this->n = n;\n            return;\n        }\n        n %= mod;\n        if (n < 0) {\n            n += mod;\n        }\n        this->n = n;\n    }\n\n    modint& operator+=(const modint& other) {\n        n += other.n;\n        if (n >= mod) {\n            n -= mod;\n        }\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        n -= other.n;\n        if (n < 0) {\n            n += mod;\n        }\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        n = ll(n) * other.n % mod;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n#ifdef LOCAL\n        if (other.n == 0) {\n            throw \"Division by zero\";\n        }\n#endif\n        return *this *= other.inverse();\n    }\n\n    modint operator-() {\n        if (n == 0) {\n            return 0;\n        }\n        return modint(mod - n);\n    }\n\n    modint inverse() const {\n        ll x, y;\n        ll g = gcd(ll(n), ll(mod), x, y);\n#ifdef LOCAL\n        if (g != 1) {\n            throw \"not inversable\";\n        }\n#endif\n        return x;\n    }\n\n    int log(modint alpha);\n};\n\nmodint operator+(const modint& a, const modint& b) {\n    return modint(a) += b;\n}\n\nmodint operator-(const modint& a, const modint& b) {\n    return modint(a) -= b;\n}\n\nmodint operator*(const modint& a, const modint& b) {\n    return modint(a) *= b;\n}\n\nmodint operator/(const modint& a, const modint& b) {\n    return modint(a) /= b;\n}\n\nostream& operator<<(ostream& out, const modint& val) {\n    return out << val.n;\n}\n\nbool operator==(const modint& a, const modint& b) {\n    return a.n == b.n;\n}\n\nbool operator!=(const modint& a, const modint& b) {\n    return a.n != b.n;\n}\n\nnamespace std {\n    template <>\n    struct hash<modint> {\n        size_t operator()(const modint& n) const {\n            return n.n;\n        }\n    };\n}\n\nint modint::log(modint alpha) {\n    unordered_map<modint, int> base;\n    int exp = 0;\n    modint pow = 1;\n    modint inv = *this;\n    modint alInv = alpha.inverse();\n    while (exp * exp < mod) {\n        if (inv == 1) {\n            return exp;\n        }\n        base[inv] = exp++;\n        pow *= alpha;\n        inv *= alInv;\n    }\n    modint step = pow;\n    for (int i = 1;; i++) {\n        if (base.count(pow)) {\n            return exp * i + base[pow];\n        }\n        pow *= step;\n    }\n}\n\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        a = a % b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T>\nT lcm(T a, T b) {\n    return a / gcd(a, b) * b;\n}\n\ntemplate <typename T>\nT power(const T& a, ll b) {\n    if (b == 0) {\n        return 1;\n    }\n    if ((b & 1) == 0) {\n        T res = power(a, b >> 1);\n        return res * res;\n    } else {\n        return power(a, b - 1) * a;\n    }\n}\n\ntemplate <typename T>\nT factorial(int n) {\n    T result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> factorials(int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> powers(T base, int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * base;\n    }\n    return result;\n}\n\n\nclass ReverseNumberIterator : public NumberIterator {\npublic:\n    ReverseNumberIterator(int v) : NumberIterator(v) {}\n\n    ReverseNumberIterator& operator++() {\n        --v;\n        return *this;\n    }\n};\n\nclass RevRange : pii {\npublic:\n    RevRange(int begin, int end) : pii(begin - 1, min(begin, end) - 1) {}\n\n    RevRange(int n) : pii(n - 1, min(n, 0) - 1) {}\n\n    ReverseNumberIterator begin() {\n        return first;\n    }\n\n    ReverseNumberIterator end() {\n        return second;\n    }\n};\n\n\nclass CGiantGraph {\npublic:\n    void solve() {\n        int n = in.readInt();\n        arr<Graph<BaseEdge>> graphs(3, Graph<BaseEdge>(n));\n        for (int i : range(3)) {\n            int m = in.readInt();\n            arri u, v;\n            in.readArrays(m, u, v);\n            decreaseByOne(u, v);\n            for (int j : range(m)) {\n                graphs[i].addEdge(min(u[j], v[j]), max(u[j], v[j]));\n            }\n        }\n\n        mod = MODF;\n        auto p = powers(modint(1000000000000000000ll), n + 1);\n        arr2d<modint> levels(3, n, 0);\n        arri level(n);\n        int maxLevel = 0;\n        for (int i : range(3)) {\n            for (int j : RevRange(n)) {\n                unordered_set<int> bad;\n                for (auto* e : graphs[i][j]) {\n                    bad.insert(level[e->to]);\n                }\n                for (int k : range(n)) {\n                    if (!bad.count(k)) {\n                        level[j] = k;\n                        levels(i, k) += p[j + 1];\n                        break;\n                    }\n                }\n                maxim(maxLevel, level[j]);\n            }\n        }\n        maxLevel++;\n        modint answer = levels(0, 0) * levels(1, 0) * levels(2, 0);\n        for (int i : range(3)) {\n            for (int j : range(i)) {\n                for (int k : range(1, maxLevel)) {\n                    answer += levels(i, k) * levels(j, k) * levels(3 - i - j, 0);\n                }\n            }\n        }\n        for (int i : range(1, maxLevel)) {\n            for (int j = 2 * i; j < maxLevel; j += 2 * i) {\n                for (int k : range(i)) {\n                    if (j + i + k >= maxLevel) {\n                        break;\n                    }\n                    for (int a : range(3)) {\n                        for (int b : range(3)) {\n                            if (a == b) {\n                                continue;\n                            }\n                            answer += levels(a, i) * levels(b, j + k) * levels(3 - a - b, j + i + k);\n                        }\n                    }\n                }\n            }\n        }\n        out.printLine(answer);\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    CGiantGraph solver;\n\n\n    solver.solve();\n    fflush(stdout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nlld arr[300000];\nvector<lld> adj[300000][3];\nar<lld,3> siz;\nlld grundy[300000][3];\nmap<lld,lld> sums[3];\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nvoid dfs_grundy(lld node,lld grp){\n    if (grundy[node][grp]!=-1)return ;\n  //  grundy[node][grp]=0;\n    vector<lld> mex;\n    //nums[0][grp]++;\n    for (auto it:adj[node][grp]){\n        if (it<node) continue;\n        dfs_grundy(it,grp);\n        mex.pb(grundy[it][grp]);\n    }\n    if (mex.empty()) {grundy[node][grp]=0;sums[grp][0]+=fastpower(10,18*(node+1),modd);sums[grp][0]%=modd;return;}\n    sort(all(mex));\n    rep(i,0,mex.size()-1){\n        if (i!=mex[i]){\n            grundy[node][grp]=i;\n        //    nums[0][grp]--;\n      //      nums[i][grp]++;\n            sums[grp][i]+=fastpower(10,18*(node+1),modd);sums[grp][i]%=modd;\n            return ;\n        }\n    }\n    grundy[node][grp]=mex.size();\n    //nums[0][grp]--;\n    //nums[mex.size()][grp]++;\n    sums[grp][mex.size()]+=fastpower(10,18*(node+1),modd);sums[grp][mex.size()]%=modd;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,r,k,c,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n//     ans=0;\n     //cin>>TESTS;\n     memset(grundy,-1,sizeof(grundy));\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(j,0,2){\n         cin>>siz[j];\n         rep(i,0,siz[j]-1){\n            cin>>a>>b;a--;b--;\n            adj[a][j].pb(b);\n            adj[b][j].pb(a);\n         }\n         }\n         rep(j,0,2) rep(i,0,n-1) dfs_grundy(i,j);\n         lld ans=0;\n         rep(i,0,1000) rep(j,0,1000) {\n            lld k=i^j;\n            if(k<sums[2].size())ans+=(((sums[0][i]*sums[1][j])%modd)*sums[2][k])%modd;\n            ans%=modd;\n         }\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef double db;\nmt19937 mrand(random_device{}());\nconst ll mod = 998244353;\nint rnd(int x) { return mrand() % x; }\nll powmod(ll a, ll b) { ll res = 1; a %= mod; assert(b >= 0); for (; b; b >>= 1) { if (b & 1)res = res * a%mod; a = a * a%mod; }return res; }\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n// head\n\ntemplate <uint MD> struct ModInt {\n\tusing M = ModInt;\n\tconst static M G;\n\tuint v;\n\tModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n\tM& set_v(uint _v)\n\t{\n\t\tv = (_v < MD) ? _v : _v - MD;\n\t\treturn *this;\n\t}\n\texplicit operator bool() const { return v != 0; }\n\tM operator-() const { return M() - *this; }\n\tM operator+(const M& r) const { return M().set_v(v + r.v); }\n\tM operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n\tM operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n\tM operator/(const M& r) const { return *this * r.inv(); }\n\tM& operator+=(const M& r) { return *this = *this + r; }\n\tM& operator-=(const M& r) { return *this = *this - r; }\n\tM& operator*=(const M& r) { return *this = *this * r; }\n\tM& operator/=(const M& r) { return *this = *this / r; }\n\tbool operator==(const M& r) const { return v == r.v; }\n\tM pow(ll n) const\n\t{\n\t\tM x = *this, r = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) r *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn r;\n\t}\n\tM inv() const { return pow(MD - 2); }\n\tfriend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<mod>;\n\nconst Mint ibase = Mint(10).pow(18).inv();\n\nconst int MAXN = 100000 + 5;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//\tfreopen(\"a.in\",\"r\",stdin);\n\t//\tfreopen(\"a.out\",\"w\",stdout);\n\n\tint n, m;\n\tcin >> n;\n\t\n\tint u, v;\n\tvector<vector<Mint>> sumg(3);\n\trep(x, 0, 3)\n\t{\n\t\tcin >> m;\n\t\tvector<vi> G(n + 1);\n\t\trep(i, 0, m)\n\t\t{\n\t\t\tcin >> u >> v;\n\t\t\tif (u > v) swap(u, v);\n\t\t\tG[u].push_back(v);\n\t\t}\n\n\t\tvi grundy(n + 1, 0);\n\t\tvi vis(n + 1, -1);\n\t\tper(i, 1, n + 1)\n\t\t{\n\t\t\tfor (int to : G[i]) {\n\t\t\t\tvis[grundy[to]] = i;\n\t\t\t}\n\t\t\twhile (vis[grundy[i]] == i) grundy[i]++;\n\t\t\twhile (sumg[x].size() <= grundy[i]) sumg[x].resize(grundy[i] + 1);\n\t\t\tsumg[x][grundy[i]] += Mint(10).pow(18 * i);\n\t\t}\n\t}\n\n\tMint ans = 0;\n\trep(i, 0, sumg[0].size())\n\t{\n\t\trep(j, 0, sumg[1].size())\n\t\t{\n\t\t\tint k = i ^ j;\n\t\t\tif (k < sumg[2].size()) {\n\t\t\t\tans += sumg[0][i] * sumg[1][j] * sumg[2][k];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 1e6+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 998244353;\n\nint sg[3][maxn],n,f[3][maxn],r[maxn],c[3][maxn];\nvector<int > e[maxn];\n\nint qpow(int a,int x) {\n    int res=1;\n    for(;x;x>>=1,a=1ll*a*a%mod) if(x&1) res=1ll*res*a%mod;\n    return res;\n}\n\nvoid update(int &x,int y) {x+=y;if(x>=mod) x-=mod;}\n\nvoid solve(int t) {\n    int m;read(m);\n    for(int i=1;i<=n;i++) e[i].clear();\n    for(int i=1,x,y;i<=m;i++) read(x),read(y),e[x].pb(y),e[y].pb(x);\n    for(int i=n;i;i--) {\n        for(auto v:e[i]) if(v>i) r[sg[t][v]]=1;\n        int x=0;for(;r[x];x++);sg[t][i]=x;c[t][x]++;\n        for(auto v:e[i]) r[sg[t][v]]=0;\n        update(f[t][sg[t][i]],qpow(10,18*i));\n    }\n}\n\nint main() {\n    read(n);\n    for(int i=0;i<=2;i++) solve(i);\n    int ans=0;\n    for(int i=0;c[0][i];i++)\n        for(int j=0;c[1][j];j++) {\n            int k=i^j;\n            // printf(\"%d %d %d\\n\",f[0][i],f[1][j],f[2][k]);\n            update(ans,1ll*f[0][i]*f[1][j]%mod*f[2][k]%mod);\n        }\n    write(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __VECTOR_UTIL_H__\n#define __VECTOR_UTIL_H__\n\n/* updated: 2020-03-22 */\n\n#include <cassert>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n\ntemplate <class T>\nstd::vector<T> inputVector(int size, std::istream& ist = std::cin);\ntemplate <class T>\nstd::vector<std::vector<T>> inputVector2D(int height, int width, std::istream& ist = std::cin);\ntemplate <class T>\nvoid outputVector(const std::vector<T>& vec, const std::string& delimiter = \" \", std::ostream& ost = std::cout);\ntemplate <class T>\nstd::vector<T> makeVector(int size, const T& value);\ntemplate <class T, class Func>\nvoid apply(std::vector<T>& vec, Func func);\ntemplate <class T, class BinaryFunc>\nstd::vector<T> elementwise(std::vector<T>& a, std::vector<T>& b, BinaryFunc func);\ntemplate <class T>\nvoid sortAndUnique(std::vector<T>& vec);\ntemplate <class T>\nint mex(const std::vector<T>& vec);\n\n/* 標準入力から値を受け取り vector を生成 */\ntemplate <class T>\nstd::vector<T> inputVector(int size, std::istream& ist) {\n\tstd::vector<T> ret(size);\n\tfor (int i = 0; i < size; ++i) {\n\t\tist >> ret[i];\n\t}\n\treturn ret;\n}\n\n/* 標準入力から値を受け取り2次元 vector を生成 */\ntemplate <class T>\nstd::vector<std::vector<T>> inputVector2D(int height, int width, std::istream& ist) {\n\tstd::vector<std::vector<T>> ret(height, std::vector<T>(width));\n\tfor (int i = 0; i < height; ++i) {\n\t\tfor (int j = 0; j < width; ++j) {\n\t\t\tist >> ret[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* vector の内容を delimiter 区切りで出力 */\ntemplate <class T>\nvoid outputVector(const std::vector<T>& vec, const std::string& delimiter, std::ostream& ost) {\n\tint size = vec.size();\n\tfor (int i = 0; i < size; ++i) {\n\t\tost << vec[i];\n\t\tif (i == size - 1) {\n\t\t\tost << std::endl;\n\t\t} else {\n\t\t\tost << delimiter;\n\t\t}\n\t}\n}\n\n/* vector 生成のヘルパー関数(主に多次元配列用) */\ntemplate <class T>\nstd::vector<T> makeVector(int size, const T& value) {\n\treturn std::vector<T>(size, value);\n}\n\n/* vector の各要素に関数を適用する */\ntemplate <class T, class Func>\nvoid apply(std::vector<T>& vec, Func func) {\n\tstd::transform(vec.begin(), vec.end(), vec.begin(), func);\n}\n\n/* 2つの vector に対して要素ごとの演算を行って1つの vector を生成する */\ntemplate <class T, class BinaryFunc>\nstd::vector<T> elementwise(std::vector<T>& a, std::vector<T>& b, BinaryFunc func) {\n\tassert(a.size() == b.size());\n\t\n\tconst int size = a.size();\n\tstd::vector<T> ret(size);\n\tfor (int i = 0; i < size; ++i) {\n\t\tret[i] = func(a[i], b[i]);\n\t}\n\treturn ret;\n}\n\n/* sort + unique O(n log n) */\ntemplate <class T>\nvoid sortAndUnique(std::vector<T>& vec) {\n\tsort(vec.begin(), vec.end());\n\tauto it = unique(vec.begin(), vec.end());\n\tvec.erase(it, vec.end());\n}\n\n/* vector に含まれない非負整数のうち、最小のもの (minimum excluded) を得る O(n log n) */\n/* template である必要ないかも */\ntemplate <class T>\nint mex(const std::vector<T>& vec) {\n\tstd::vector<int> copied(vec);\n\tsortAndUnique(copied);\n\t\n\tint value = 0;\n\twhile (value < copied.size() && copied[value] == value) {\n\t\t++value;\n\t}\n\treturn value;\n}\n\n#endif\n\n\n\n#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#ifndef __SETS_H__\n#define __SETS_H__\n\n/* updated: 2020-03-28 */\n\n// 集合系の関数などを置きたい\n\n#include <cstdint>\n#include <vector>\n#include <cassert>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\n// ビット演算系\n\n/* 立っているビットの数を数える */\ninline int popcount(uint64_t value) {\n#ifdef _MSC_VER\n\treturn __popcnt64(value);\n#elif defined(__GNUC__)\n\treturn __builtin_popcountll(value);\n#else\n\tvalue = (value & 0x5555555555555555) + ((value >>  1) & 0x5555555555555555);\n\tvalue = (value & 0x3333333333333333) + ((value >>  2) & 0x3333333333333333);\n\tvalue = (value & 0x0f0f0f0f0f0f0f0f) + ((value >>  4) & 0x0f0f0f0f0f0f0f0f);\n\tvalue = (value & 0x00ff00ff00ff00ff) + ((value >>  8) & 0x00ff00ff00ff00ff);\n\tvalue = (value & 0x0000ffff0000ffff) + ((value >> 16) & 0x0000ffff0000ffff);\n\tvalue = (value & 0x00000000ffffffff) + ((value >> 32) & 0x00000000ffffffff);\n\treturn value;\n#endif\n}\n\n/* 最上位ビットの位置を返す (0-based, value == 0 のときは -1 を返す) */\n/* floor(log2(value)) と一致する */\ninline int msbPosition(uint64_t value) {\n\tvalue |= value >> 1;\n\tvalue |= value >> 2;\n\tvalue |= value >> 4;\n\tvalue |= value >> 8;\n\tvalue |= value >> 16;\n\tvalue |= value >> 32;\n\treturn popcount(value) - 1;\n}\n\n/* 最下位ビットの位置を返す (0-based, value == 0 のときは 64 を返す) */\ninline int lsbPosition(uint64_t value) {\n\tvalue |= value << 1;\n\tvalue |= value << 2;\n\tvalue |= value << 4;\n\tvalue |= value << 8;\n\tvalue |= value << 16;\n\tvalue |= value << 32;\n\treturn 64 - popcount(value);\n}\n\n/* 最上位ビットを取得 (value == 0 のときは 0 を返す) */\ninline uint64_t msb(uint64_t value) {\n\tif (value == 0) return uint64_t();\n\treturn uint64_t(1) << msbPosition(value);\n}\n\n/* 最下位ビットを取得 (value == 0 のときは 0 を返す) */\n/* TODO: これに関しては明らかに value & -value のほうが速いと思うけどどうしようか */\ninline uint64_t lsb(uint64_t value) {\n\tif (value == 0) return uint64_t();\n\treturn uint64_t(1) << lsbPosition(value);\n}\n\n/* ceil(log2(value)) を返す (value == 0 のときは -1 を返す) */\n/* 戻り値の範囲は -1 <= ret <= 64 */\ninline int ceilLog2(uint64_t value) {\n\tif (value == 0) return -1;\n\treturn msbPosition(value - 1) + 1;\n}\n\n/* ビットの並びを逆転させる */\ninline uint64_t bitReverse(uint64_t val) {\n\tval = (val & 0x5555555555555555) <<  1 | (val & 0xAAAAAAAAAAAAAAAA) >>  1;\n\tval = (val & 0x3333333333333333) <<  2 | (val & 0xCCCCCCCCCCCCCCCC) >>  2;\n\tval = (val & 0x0F0F0F0F0F0F0F0F) <<  4 | (val & 0xF0F0F0F0F0F0F0F0) >>  4;\n\tval = (val & 0x00FF00FF00FF00FF) <<  8 | (val & 0xFF00FF00FF00FF00) >>  8;\n\tval = (val & 0x0000FFFF0000FFFF) << 16 | (val & 0xFFFF0000FFFF0000) >> 16;\n\tval = (val & 0x00000000FFFFFFFF) << 32 | (val & 0xFFFFFFFF00000000) >> 32;\n\treturn val;\n}\n\n/* 下位 digits ビットについてビットの並びを逆転させる (上位ビットは無視) */\ninline uint64_t bitReverse(uint64_t val, int digits) {\n\tassert(digits > 0 || digits <= 64);\n\treturn bitReverse(val) >> (64 - digits);\n}\n\n/* 1 << quantity を返す */\ninline uint64_t shift(int quantity) {\n\treturn uint64_t(1) << quantity;\n}\n\n/* 整数 sets を集合としてみたとき、element 番目の要素を持つかどうか bool(s & (1 << element)) */\ninline bool isIn(uint64_t sets, int element) {\n\treturn sets & shift(element);\n}\n\ntemplate <class T>\nvoid bitReverseArray(std::vector<T>& arr);\n\n/* 配列の要素を添字のビット逆順に並べ替える (配列長は2冪) */\ntemplate <class T>\nvoid bitReverseArray(std::vector<T>& arr) {\n\tconst int rank = msbPosition(arr.size());\n\tconst int length = 1 << rank;\n\tassert(arr.size() == length);\n\n\tfor (int i = 0; i < length; ++i) {\n\t\tint j = bitReverse(i, rank);\n\t\tif (j > i) {\n\t\t\tstd::swap(arr[i], arr[j]);\n\t\t}\n\t}\n}\n\n\n// 畳み込み演算系\n\ntemplate <class T>\nvoid transformSubsetZeta(std::vector<T>& arr);\ntemplate <class T>\nvoid transformInverseSubsetZeta(std::vector<T>& arr);\ntemplate <class T>\nvoid transformSupersetZeta(std::vector<T>& arr);\ntemplate <class T>\nvoid transformInverseSupersetZeta(std::vector<T>& arr);\ntemplate <class T>\nvoid transformHadamard(std::vector<T>& vec);\ntemplate <class T>\nstd::vector<T> convolveOnXor(const std::vector<T>& a, const std::vector<T>& b);\n\n/* 逆変換とまとめられないか？ */\n/* 高速ゼータ変換 O(n log n), n は2冪 */\n/* b[s] = sum[t is a subset of s] a[t] */\ntemplate <class T>\nvoid transformSubsetZeta(std::vector<T>& arr) {\n\tconst uint64_t length = arr.size();\n\tconst int level = msbPosition(length);\n\tassert(length == shift(level));\n\n\tfor (int k = 0; k < level; ++k) {\n\t\tfor (uint64_t s = 0; s < length; ++s) {\n\t\t\tif (isIn(s, k)) continue;\n\t\t\tarr[s] += arr[s | shift(k)];\n\t\t}\n\t}\n}\n\n/* 高速ゼータ変換の逆変換 O(n log n), n は2冪 */\ntemplate <class T>\nvoid transformInverseSubsetZeta(std::vector<T>& arr) {\n\tconst uint64_t length = arr.size();\n\tconst int level = msbPosition(length);\n\tassert(length == (uint64_t(1) << level));\n\n\tfor (int k = 0; k < level; ++k) {\n\t\tfor (uint64_t s = 0; s < length; ++s) {\n\t\t\tif (isIn(s, k)) continue;\n\t\t\tarr[s | shift(k)] -= arr[s];\n\t\t}\n\t}\n}\n\n/* 高速(上位集合)ゼータ変換 O(n log n), n は2冪 */\n/* b[s] = sum[t is a superset of s] a[t] */\ntemplate <class T>\nvoid transformSupersetZeta(std::vector<T>& arr) {\n\tconst uint64_t length = arr.size();\n\tconst int level = msbPosition(length);\n\tassert(length == (uint64_t(1) << level));\n\n\tfor (int k = 0; k < level; ++k) {\n\t\tfor (uint64_t s = 0; s < length; ++s) {\n\t\t\tif (isIn(s, k)) continue;\n\t\t\tarr[s | shift(k)] += arr[s];\n\t\t}\n\t}\n}\n\n/* 高速(上位集合)ゼータ変換の逆変換 O(n log n), n は2冪 */\ntemplate <class T>\nvoid transformInverseSupersetZeta(std::vector<T>& arr) {\n\tconst uint64_t length = arr.size();\n\tconst int level = msbPosition(length);\n\tassert(length == (uint64_t(1) << level));\n\n\tfor (int k = 0; k < level; ++k) {\n\t\tfor (uint64_t s = 0; s < length; ++s) {\n\t\t\tif (isIn(s, k)) continue;\n\t\t\tarr[s] -= arr[s | shift(k)];\n\t\t}\n\t}\n}\n\n/* 高速アダマール変換 O(n log n), n は2冪 (オーバーフロー注意) */\n/* オーバーフロー注意 */\ntemplate <class T>\nvoid transformHadamard(std::vector<T>& vec) {\n\tconst int rank = msbPosition(vec.size());\n\tconst int length = 1 << rank;\n\tassert(vec.size() == length);\n\n\t/* バタフライ演算 */\n\tauto butterfly = [](T& a, T& b) -> void {\n\t\tT tmp(a);\n\t\ta += b;\n\t\tb = tmp - b;\n\t};\n\n\t/* FFT 同様に各ビットについてバタフライ演算を回す */\n\tfor (int cnt = 0; cnt < rank; ++cnt) {\n\t\tconst int blk_max = length >> (cnt + 1);\n\t\tconst int blk_size = 1 << (cnt + 1);\n\n\t\tfor (int blk = 0; blk < blk_max; ++blk) {\n\t\t\tconst int idx_max = 1 << cnt;\n\n\t\t\tfor (int idx = 0; idx < idx_max; ++idx) {\n\t\t\t\tconst int left = (blk * blk_size + idx);\n\t\t\t\tconst int right = left + blk_size / 2;\n\n\t\t\t\tbutterfly(vec[left], vec[right]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* xor 畳み込み O(n log n), n は2冪 (オーバーフロー注意) */\n/* ret[n] = sum [i xor j == n] (a[i] * b[j]) */\ntemplate <class T>\nstd::vector<T> convolveOnXor(const std::vector<T>& a, const std::vector<T>& b) {\n\tconst int rank = msbPosition(a.size());\n\tconst int size = 1 << rank;\n\tassert(a.size() == b.size());\n\tassert(a.size() == size);\n\n\tstd::vector<T> a_copied = a;\n\tstd::vector<T> b_copied = b;\n\ttransformHadamard(a_copied);\n\ttransformHadamard(b_copied);\n\n\tstd::vector<T> ret(size);\n\tfor (int i = 0; i < size; ++i) {\n\t\tret[i] = a_copied[i] * b_copied[i];\n\t}\n\ttransformHadamard(ret);\n\n\t/* 関数 transformHadamard はユニタリ変換ではないので係数を調整 */\n\t/* IntMod など -> 逆元を前計算することも可能 */\n\tfor (int i = 0; i < size; ++i) {\n\t\tret[i] /= size;\n\t}\n\treturn ret;\n}\n\n\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nvector<vector<int>> in(int n) {\n\tint m;\n\tcin >> m;\n\n\tvector<vector<int>> ret(n);\n\tREP(i, 0, m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tret[a].push_back(b);\n\t\tret[b].push_back(a);\n\t}\n\treturn ret;\n}\n\nvector<MF> sub(const vector<vector<int>>& g) {\n\tvector<int> grundy(g.size());\n\tREM(from, 0, g.size()) {\n\t\tvector<int> v;\n\t\tfor (int to : g[from]) {\n\t\t\tif (to < from) continue;\n\t\t\tv.push_back(grundy[to]);\n\t\t}\n\t\tgrundy[from] = mex(v);\n\t}\n\n\tconst MF base = MF(10)[18];\n\tvector<MF> ret(1 << ceilLog2(g.size()));\n\tREP(i, 0, g.size()) {\n\t\tret[grundy[i]] += base[i + 1];\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tauto G = in(N);\n\tauto H = in(N);\n\tauto I = in(N);\n\n\tauto A = sub(G);\n\tauto B = sub(H);\n\tauto C = sub(I);\n\n\tauto S = convolveOnXor(A, convolveOnXor(B, C));\n\tcout << S[0] << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nusing cat = long long;\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint N;\n\tcin >> N;\n\tcat mod = 998244353;\n\tvector<cat> pw(N+1, 1);\n\tfor(int i = 0; i < 18; i++) pw[1] = pw[1] * 10 % mod;\n\tfor(int i = 2; i <= N; i++) pw[i] = pw[i-1] * pw[1] % mod;\n\tvector<int> level[3];\n\tvector<cat> level_w[3];\n\tint V[3] = {0, 0, 0};\n\tfor(int k = 0; k < 3; k++) {\n\t\tint M;\n\t\tvector< vector<int> > G(N);\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tG[--u].push_back(--v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tlevel[k].resize(N, 0);\n\t\tfor(int i = N-1; i >= 0; i--) {\n\t\t\tstatic vector<int> l_gt(N+1, 0);\n\t\t\tfor(auto x : G[i]) if(x > i) l_gt[level[k][x]]++;\n\t\t\twhile(l_gt[level[k][i]]) level[k][i]++;\n\t\t\tfor(auto x : G[i]) if(x > i) l_gt[level[k][x]]--;\n\t\t\tV[k] = max(V[k], level[k][i]);\n\t\t}\n\t\tlevel_w[k].resize(V[k]+1, 0);\n\t\tfor(int i = N-1; i >= 0; i--) {\n\t\t\tlevel_w[k][level[k][i]] += pw[i+1];\n\t\t\tif(level_w[k][level[k][i]] >= mod) level_w[k][level[k][i]] -= mod;\n\t\t}\n\t}\n\tvector< vector< vector<char> > > state(V[0]+1, vector< vector<char> >(V[1]+1, vector<char>(V[2]+1, 0)));\n\tvector< vector<char> > used[3];\n\tused[0].resize(V[1]+1, vector<char>(V[2]+1, 0));\n\tused[1].resize(V[0]+1, vector<char>(V[2]+1, 0));\n\tused[2].resize(V[0]+1, vector<char>(V[1]+1, 0));\n\tfor(int i = 0; i <= V[0]; i++)\n\t\tfor(int j = 0; j <= V[1]; j++)\n\t\t\tfor(int k = 0; k <= V[2]; k++)\n\t\t\t\tif(!used[0][j][k] && !used[1][i][k] && !used[2][i][j])\n\t\t\t\t\tstate[i][j][k] = used[0][j][k] = used[1][i][k] = used[2][i][j] = 1;\n\tcat ans = 0;\n\tfor(int i = 0; i <= V[0]; i++)\n\t\tfor(int j = 0; j <= V[1]; j++)\n\t\t\tfor(int k = 0; k <= V[2]; k++)\n\t\t\t\tif(state[i][j][k])\n\t\t\t\t\tans = (ans + level_w[0][i] * level_w[1][j] % mod * level_w[2][k]) % mod;\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 100007\n#define modp 998244353\nusing namespace std;\nint base=1;\nint n,m1,m2,m3;\nint n1,n2,n3,val1[Maxn],val2[Maxn],val3[Maxn],val[3*Maxn];\nvector<int> e1[Maxn],e2[Maxn],e3[Maxn];\nbool vis[Maxn],flag[Maxn];\nbool vis1[2007][2007],vis2[2007][2007],vis3[2007][2007];\nvoid solve1()\n{\n    n1=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val1[++n1]=val[i];\n                } else val1[n1]=(val1[n1]+val[i])%modp;\n                for (int j=0;j<(int)e1[i].size();j++)\n                    flag[e1[i][j]]=false;\n            }\n    }\n}\nvoid solve2()\n{\n    n2=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val2[++n2]=val[i];\n                } else val2[n2]=(val2[n2]+val[i])%modp;\n                for (int j=0;j<(int)e2[i].size();j++)\n                    flag[e2[i][j]]=false;\n            }\n    }\n}\nvoid solve3()\n{\n    n3=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val3[++n3]=val[i];\n                } else val3[n3]=(val3[n3]+val[i])%modp;\n                for (int j=0;j<(int)e3[i].size();j++)\n                    flag[e3[i][j]]=false;\n            }\n    }\n}\nint main()\n{\n    for (int i=1;i<=18;i++)\n        base=(10LL*base)%modp;\n    scanf(\"%d\",&n);\n    val[0]=1;\n    for (int i=1;i<=3*n;i++)\n        val[i]=(1LL*val[i-1]*base)%modp;\n    scanf(\"%d\",&m1);\n    for (int i=1;i<=m1;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e1[u].push_back(v);\n        e1[v].push_back(u);\n    }\n    scanf(\"%d\",&m2);\n    for (int i=1;i<=m2;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e2[u].push_back(v);\n        e2[v].push_back(u);\n    }\n    scanf(\"%d\",&m3);\n    for (int i=1;i<=m3;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e3[u].push_back(v);\n        e3[v].push_back(u);\n    }\n    solve1();\n    solve2();\n    solve3();\n    int ans=0;\n    memset(vis1,true,sizeof(vis1));\n    memset(vis2,true,sizeof(vis2));\n    memset(vis3,true,sizeof(vis3));\n    for (int x=3;x<=n1+n2+n3;x++)\n        for (int i=1;i<=n1;i++)\n            for (int j=1;j<=n2;j++)\n            {\n                int k=x-i-j;\n                if (k>=1&&k<=n3)\n                {\n                    if (vis1[i][j]&&vis2[j][k]&&vis3[k][i])\n                    {\n                        vis1[i][j]=false;\n                        vis2[j][k]=false;\n                        vis3[k][i]=false;\n                        int tmp=(1LL*val1[i]*val2[j])%modp;\n                        tmp=(1LL*tmp*val3[k])%modp;\n                        ans=(ans+tmp)%modp;\n                    }\n                }\n            }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 1e5 + 7 , MOD = 998244353;\nstruct Edge{int end , upEd;};\nint pw[300003] , N;\n\nnamespace graph3{\n\tEdge Ed[_ << 1]; int head[_] , cntEd , M , val[_];\n\tvoid addEd(int a , int b){Ed[++cntEd] = (Edge){b , head[a]}; head[a] = cntEd;}\n\tvoid input(){cin >> M; for(int i = 1 ; i <= M ; ++i){int x , y; cin >> x >> y; addEd(x , y); addEd(y , x);}}\n\n\tbool vis[_] , ban[_];\n\tvoid calc(){\n\t\tfor(int i = 0 ; i < 512 ; ++i){\n\t\t\tmemset(ban , 0 , sizeof(ban));\n\t\t\tfor(int j = N ; j ; --j)\n\t\t\t\tif(!vis[j] && !ban[j]){\n\t\t\t\t\tval[i] = (val[i] + pw[j]) % MOD; vis[j] = 1;\n\t\t\t\t\tfor(int p = head[j] ; p ; p = Ed[p].upEd) ban[Ed[p].end] = 1;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nnamespace graph2{\n\tEdge Ed[_ << 1]; int head[_] , cntEd , M , val[_] , vl[_]; bool table[1003][1003];\n\tvoid addEd(int a , int b){Ed[++cntEd] = (Edge){b , head[a]}; head[a] = cntEd;}\n\tvoid input(){cin >> M; for(int i = 1 ; i <= M ; ++i){int x , y; cin >> x >> y; addEd(x , y); addEd(y , x);}}\n\n\tbool vis[_] , ban[_];\n\tvoid calc(){\n\t\tvector < int > pot;\n\t\tfor(int i = 0 ; i < 512 ; ++i){\n\t\t\tmemset(ban , 0 , sizeof(ban)); int sum = 0;\n\t\t\tfor(int j = N ; j ; --j)\n\t\t\t\tif(!vis[j] && !ban[j]){\n\t\t\t\t\tsum = (sum + pw[j]) % MOD; vis[j] = 1;\n\t\t\t\t\tfor(int p = head[j] ; p ; p = Ed[p].upEd) ban[Ed[p].end] = 1;\n\t\t\t\t}\n\t\t\tpot.push_back(sum);\n\t\t}\n\t\tfor(int i = 0 ; i < 512 ; ++i)\n\t\t\tfor(int j = 0 ; j < 512; ++j)\n\t\t\t\tval[i] = (val[i] + 1ll * pot[j] * graph3::val[i ^ j]) % MOD;\n\t}\n}\n\nnamespace graph1{\n\tEdge Ed[_ << 1]; int head[_] , cntEd , M;\n\tvoid addEd(int a , int b){Ed[++cntEd] = (Edge){b , head[a]}; head[a] = cntEd;}\n\tvoid input(){cin >> M; for(int i = 1 ; i <= M ; ++i){int x , y; cin >> x >> y; addEd(x , y); addEd(y , x);}}\n\n\tbool vis[_] , ban[_];\n\tvoid calc(){\n\t\tvector < int > pot;\n\t\tfor(int i = 0 ; i < 512 ; ++i){\n\t\t\tmemset(ban , 0 , sizeof(ban)); int sum = 0;\n\t\t\tfor(int j = N ; j ; --j)\n\t\t\t\tif(!vis[j] && !ban[j]){\n\t\t\t\t\tsum = (sum + pw[j]) % MOD; vis[j] = 1;\n\t\t\t\t\tfor(int p = head[j] ; p ; p = Ed[p].upEd) ban[Ed[p].end] = 1;\n\t\t\t\t}\n\t\t\tpot.push_back(sum);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0 ; i < 512 ; ++i)\n\t\t\tsum = (sum + 1ll * pot[i] * graph2::val[i]) % MOD;\n\t\tcout << sum;\n\t}\n\t\n}\n\nint main(){\n\tcin >> N; pw[0] = 1; pw[1] = (long long)1e18 % MOD;\n\tfor(int i = 1 ; i <= 3 * N ; ++i) pw[i] = 1ll * pw[i - 1] * pw[1] % MOD;\n\tgraph1::input(); graph2::input(); graph3::input();\n\tgraph3::calc(); graph2::calc(); graph1::calc(); \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 998244353;\nconst int N = 1e5+7;\nconst long long B = 1000000000000000000;\ntypedef long long LL;\n\nLL pb[N];\nvoid pre() {\n    pb[0] = 1;\n    LL b = B%M;\n    for (int i=1; i<N; i++)\n        pb[i] = (pb[i-1]*b)%M;\n}\n\nvector<int> bfs(vector<vector<int>>adj) {\n    int n = adj.size()-1;\n    vector<int> col(n+1, N);\n\n    vector<bool> vis(n);\n    for (int i=n; i>0; i--) {\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 1;\n        }\n\n        for (int ii=0; ii<=n; ii++)\n            if (!vis[ii]) {\n                col[i] = ii;\n                break;\n            }\n\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 0;\n        }\n    }\n    return col;\n}\n\nint m[3];\nvector<vector<int>> adj[3];\nvector<int> dis[3];\nvector<LL> con[3];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    pre();\n\n    int n;\n    cin>>n;\n    const int MX = 1<<17;\n\n    for (int g=0; g<3; g++) {\n        cin>>m[g];\n        adj[g].resize(n+1);\n        for (int i=0; i<m[g]; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[g][u].push_back(v);\n            adj[g][v].push_back(u);\n        }\n        dis[g] = bfs(adj[g]);\n\n        con[g].resize(MX);\n        for (int i=1; i<=n; i++) {\n            con[g][dis[g][i]] = (con[g][dis[g][i]] + pb[i])%M;\n        }\n    }\n    LL ans = 0;\n    for (int i=0; i<MX; i++) {\n        if (con[0][i] == 0) continue;\n        for (int j=0; j<MX; j++) {\n            if (con[1][j] == 0)  continue;\n            ans = (ans + ((con[0][i]*con[1][j])%M)*con[2][i^j])%M;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\n\ntemplate <long long mod>\nstruct modint {\n    long long x;\n\n    modint<mod>(): x(0LL) {}\n    modint<mod>(const long long _data) {\n        if (_data < 0) {\n            x = (_data % mod + mod) % mod;\n        } else if (_data >= mod) {\n            x = _data % mod;\n        } else {\n            x = _data;\n        }\n    }\n\n    bool operator==(const modint<mod>& op) const {\n        return x == op.x;\n    }\n\n    bool operator!=(const modint<mod>& op) const {\n        return !((*this) == op);\n    }\n\n    modint<mod> operator-() const {\n        if (x == 0) {\n            return modint(0);\n        }\n        return modint(mod - x);\n    }\n\n    modint<mod> operator+(const modint<mod>& op) const {\n        const long long newdata = x + op.x;\n        if (newdata >= mod) {\n            return modint<mod>(newdata - mod);\n        } else {\n            return modint<mod>(newdata);\n        }\n    }\n\n    modint<mod>& operator+=(const modint<mod>& op) {\n        x = (*this + op).x;\n        return *this;\n    }\n\n    modint<mod> operator-(const modint<mod>& op) const {\n        return *this + (-op);\n    }\n\n    modint<mod>& operator-=(const modint<mod>& op) {\n        x = (*this - op).x;\n        return *this;\n    }\n\n    modint<mod> operator*(const modint<mod>& op) const {\n        return modint<mod>(x * op.x % mod);\n    }\n\n    modint<mod>& operator*=(const modint<mod>& op) {\n        x = (*this * op).x;\n        return *this;\n    }\n\n    modint<mod> pow(const long long n) const {\n        if (n == 0) {\n            return modint<mod>(1);\n        }\n        modint<mod> sq = pow(n / 2);\n        if (n & 1) {\n            return (*this) * sq * sq;\n        } else {\n            return sq * sq;\n        }\n    }\n\n    modint<mod> inverse() const {\n        return pow(mod - 2);\n    }\n\n    modint<mod> operator/(const modint<mod>& op) const {\n        return (*this) * op.inverse();\n    }\n\n    modint<mod>& operator/=(const modint<mod>& op) {\n        x = (*this / op).x;\n        return *this;\n    }\n\n    friend modint<mod> operator/(const long long dividend, const modint<mod>& divisor) {\n        return modint<mod>(dividend) / divisor;\n    }\n\n    static modint<mod> factorial(const long long n) {\n        static std::vector<modint<mod>> cache(1, 1);\n\n        while (cache.size() <= n) {\n            modint<mod> next = cache.back() * cache.size();\n            cache.push_back(next);\n        }\n        return cache[n];\n    }\n\n    static modint<mod> invfact(const long long n) {\n        static std::vector<modint<mod>> cache(1, 1);\n\n        while (cache.size() <= n) {\n            modint<mod> next = cache.back() / cache.size();\n            cache.push_back(next);\n        }\n        return cache[n];\n    }\n\n    static modint<mod> combination(const long long n, const long long k) {\n        if (k < 0 || n < k) {\n            return modint<mod>(0);\n        }\n\n        if (n < 1e6) {\n            return factorial(n) * invfact(k) * invfact(n - k);\n        }\n\n        modint<mod> ret = invfact(k);\n        for (int i = 1; i <= k; ++i) {\n            ret = ret * modint<mod>(n - i + 1);\n        }\n        return ret;\n    }\n};\n\ntypedef modint<998244353> mint;\n\n\nli n;\nvector<li> calc_graph() {\n    li m;\n    cin >> m;\n    vector<vector<li>> graph(n);\n    for (int i = 0; i < m; ++i) {\n        li a, b;\n        cin >> a >> b;\n        a--; b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    vector<li> use(n, 2);\n    for (int i = n - 1; i >= 0; --i) {\n        bool has[3] = {};\n        for (int j = 0; j < graph[i].size(); ++j) {\n            const li next = graph[i][j];\n            has[use[next]] = true;\n        }\n        for (int k = 0; k < 2; ++k) {\n            if (not has[k]) {\n                use[i] = k;\n                break;\n            }\n        }\n    }\n    return use;\n}\n\nvector<li> first(vector<li> v) {\n    for (int i = 0; i < v.size(); ++i) {\n        v[i] = v[i] == 0 ? 1 : 0;\n    }\n    return v;\n}\nvector<li> second(vector<li> v) {\n    for (int i = 0; i < v.size(); ++i) {\n        v[i] = v[i] == 1 ? 1 : 0;\n    }\n    return v;\n}\n\nmint vecsum(const vector<li> &v) {\n    const mint bpow = mint(10).pow(18);\n    mint pow = bpow;\n    mint sum = 0;\n    for (int i = 0; i < v.size(); ++i) {\n        sum += mint(v[i]) * pow;\n        pow *= bpow;\n    }\n    return sum;\n}\nmint calc_ans(const vector<li> &v1, const vector<li> &v2, const vector<li> &v3) {\n    return vecsum(v1) * vecsum(v2) * vecsum(v3);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    vector<li> a_mis = calc_graph();\n    vector<li> b_mis = calc_graph();\n    vector<li> c_mis = calc_graph();\n\n    mint ans = 0;\n    ans += calc_ans(first(a_mis), first(b_mis), first(c_mis));\n\n    ans += calc_ans(second(a_mis), second(b_mis), first(c_mis));\n    ans += calc_ans(first(a_mis), second(b_mis), second(c_mis));\n    ans += calc_ans(second(a_mis), first(b_mis), second(c_mis));\n\n    cout << ans.x << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconstexpr long long MOD = 998244353;\nconstexpr long long U = 1000000000000000000 % MOD;\n\nvoid input(vector<vector<int> >& V) {\n\tint M;\n\tcin >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint A, B;\n\t\tcin >> A >> B;\n\t\tA--, B--;\n\t\tif (A > B) swap(A, B);\n\t\tV[A].push_back(B);\n\t}\n}\n\nvoid Grundy(vector<int>& G, vector<vector<int> >& V) {\n\tfor (int i = (int)V.size() - 1; i >= 0; i--) {\n\t\tif (V[i].empty()) {\n\t\t\tG[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> Gs;\n\t\tfor (int j : V[i]) {\n\t\t\tGs.push_back(G[j]);\n\t\t}\n\t\tsort(Gs.begin(), Gs.end());\n\t\tGs.erase(unique(Gs.begin(), Gs.end()), Gs.end());\n\t\tif (Gs[Gs.size() - 1] == Gs.size() - 1) {\n\t\t\tG[i] = Gs.size();\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < Gs.size(); j++) {\n\t\t\tif (Gs[j] != j) {\n\t\t\t\tGs[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long Pow(int A) {\n\tif (A == 0) return 1;\n\tif (A % 2 == 0) {\n\t\tlong long B = Pow(A / 2);\n\t\treturn (B * B) % MOD;\n\t}\n\treturn (U * Pow(A - 1)) % MOD;\n}\n\nvoid Count(vector<long long>& C, vector<int>& G) {\n\tfor (int i = 0; i < G.size(); i++) {\n\t\tC[G[i]] += Pow(i + 1);\n\t\tC[G[i]] %= MOD;\n\t}\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<vector<int> > X(N), Y(N), Z(N);\n\tvector<int> GX(N), GY(N), GZ(N);\n\tvector<long long> CX(1024, 0), CY(1024, 0), CZ(1024, 0);\n\tinput(X), input(Y), input(Z);\n\tGrundy(GX, X), Grundy(GY, Y), Grundy(GZ, Z);\n\tCount(CX, GX), Count(CY, GY), Count(CZ, GZ);\n\tlong long ANS = 0;\n\tfor (int i = 0; i < 1024; i++) {\n\t\tfor (int j = 0; j < 1024; j++) {\n\t\t\tlong long MUL = (CX[i] * CY[j]) % MOD;\n\t\t\tMUL *= CZ[i ^ j];\n\t\t\tMUL %= MOD;\n\t\t\tANS += MUL;\n\t\t\tANS %= MOD;\n\t\t}\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int S = 500, SSS = S * S * S, N = 1e5 + 5, mod = 998244353;\n \nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n \nconst int base = powmod(10, 18);\n \nvector<int> g[N];\n \nvector<pair<int, int>> independent(int n, vector<pair<int ,int>> & edges) {\n  for (int i = 0; i < n; ++i)\n    g[i].clear();\n  for (auto e : edges) {\n    g[e.first].push_back(e.second);\n    g[e.second].push_back(e.first);\n  }\n  vector<bool> done(n, false), mark(n);\n  int cnt = 0;\n  vector<pair<int, int>> res;\n  while (cnt < n) {\n    mark = done;\n    int hig = -1, sum = 0;\n    for (int v = n-1; v >= 0; --v) {\n      if (mark[v]) continue;\n      ++cnt;\n      done[v] = 1;\n      hig = max(hig, v+1);\n      sum = (sum + powmod(base, v+1)) % mod;\n      for (int u : g[v]) {\n        mark[u] = 1;\n      }\n    }\n    res.emplace_back(hig, sum);\n  }\n  return res;\n}\n \nvector<pair<int, int>> read_edges() {\n  int m;\n  scanf(\"%d\", &m);\n  vector<pair<int, int>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &edges[i].first, &edges[i].second);\n    --edges[i].first;\n    --edges[i].second;\n  }\n  return edges;\n}\n \nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> ex = read_edges();\n  vector<pair<int, int>> ey = read_edges();\n  vector<pair<int, int>> ez = read_edges();\n  vector<pair<int, int>> rx = independent(n, ex);\n  vector<pair<int, int>> ry = independent(n, ey);\n  vector<pair<int, int>> rz = independent(n, ez);\n  assert(rx.size() < S);\n  assert(ry.size() < S);\n  assert(rz.size() < S);\n  long long ans = 0;\n  for (int i = 0; i < (int)rx.size(); ++i) {\n    for (int j = 0; j < (int)ry.size(); ++j) {\n      int k = i^j;\n      if (k < (int)ry.size()) {\n        long long cur = rx[i].second * (long long)ry[j].second % mod;\n        ans = (ans + cur * rz[k].second) % mod;\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define Mp make_pair\n#define pb push_back\n\nusing ll = long long;\nusing db = double;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nmt19937 mrand(time(0));\nll get(ll r) { return ((ll)mrand() * mrand() % r + r) % r; }\nll get(ll l, ll r) { return get(r - l + 1) + l; }\n\nconst int P = 998244353;\nint n, m, po[200100], sg[3][200100], f[3][200100];\nsigned main() {\n\tscanf(\"%d\", &n);\n\tll nw = (ll)(1e18) % P; po[0] = 1;\n\tfor(int i = 1; i <= n; i++) po[i] = po[i - 1] * nw % P;\n\tfor(int o = 0; o < 3; o++) {\n\t\tscanf(\"%d\", &m);\n\t\tvector<vi> G(n + 1);\n\t\tfor(int i = 1; i <= m; i++) {\n\t\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\t\tx > y ? swap(x, y) : void();\n\t\t\tG[x].pb(y);\n\t\t}\n\t\tfor(int i = n; i; i--) {\n\t\t\tset<int> mex;\n\t\t\tfor(int j : G[i])\n\t\t\t\tmex.insert(sg[o][j]);\n\t\t\twhile(mex.count(sg[o][i]))\n\t\t\t\tsg[o][i]++;\n\t\t}\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\t(f[o][sg[o][i]] += po[i]) %= P;\n\t}\n\n\tll ans = 0;\n\tfor(int i = 0; i < 500; i++)\n\t\tfor(int j = 0; j < 500; j++)\n\t\t\t(ans += 1ll * f[0][i] * f[1][j] % P * f[2][i ^ j] % P) %= P;\n\tprintf(\"%lld\\n\", ans);\n\tfprintf(stderr, \"time=%.4f\\n\", (db)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n\t/* 取模直接除，爆零两行泪\n\t * 不开ll见祖宗\n\t */\n}"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10, mod = 998244353;\nconst ll base = ll(1e18) % mod;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= mod) a -= mod;\n\treturn a;\n}\n\nint mul(ll a, int b) {\n\ta *= b;\n\treturn a % mod;\n} \n\nint pbase[N];\n\nvector<pii> get(int n);\n\nint main() {\n\tfast_cin();\n\tint n; cin >> n;\n\tpbase[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpbase[i] = mul(pbase[i - 1], base);\n\t}\n\tvector<vector<pii>> g(3);\n\tfor (auto& v : g) {\n\t\tv = get(n);\n\t}\n\tvector<int> sum(g[0].back().first + g[1].back().first + 1, 0);\n\tfor (auto& p1 : g[0]) {\n\t\tfor (auto& p2 : g[1]) {\n\t\t\tsum[p1.first ^ p2.first] = add(sum[p1.first ^ p2.first], mul(p1.second, p2.second));\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (auto& p : g[2]) {\n\t\tans = add(ans, mul(p.second, sum[p.first]));\n\t}\n\tcout << ans << endl;\n}\n\nvector<pii> get(int n) {\n\tvector<vector<int>> g(n + 1);\n\tint m; cin >> m;\n\twhile (m--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[min(u, v)].pb(max(u, v));\n\t}\n\tvector<int> v(n + 1, 0);\n\tmap<int, int> temp;\n\tfor (int i = n; i >= 1; --i) {\n\t\tset<int> seen;\n\t\tfor (auto& j : g[i]) {\n\t\t\tseen.insert(v[j]);\n\t\t}\n\t\twhile (seen.count(v[i])) {\n\t\t\t++v[i];\n\t\t}\n\t\ttemp[v[i]] = add(temp[v[i]], pbase[i]);\n\t}\n\tvector<pii> ans(temp.begin(), temp.end());\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 100005\n#define MAXM 525\n#define INF 1000000000000000000\n#define MOD 998244353\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,m[3];\nvector<int> G[MAXN];\nint sg[3][MAXN];\nint weight[3][MAXM];\nbool has[MAXM];\nint p[3*MAXN];\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nvoid dec(int &a,int b) {a-=b; if(a<MOD) a+=MOD;}\nint main()\n{\n    ll x=INF%MOD;\n    p[0]=1;\n    for(int i=1;i<=300000;i++) p[i]=1LL*p[i-1]*x%MOD;\n    scanf(\"%d\",&n);\n    for(int i=0;i<3;i++)\n    {\n        scanf(\"%d\",&m[i]);\n        for(int j=1;j<=n;j++) G[j].clear();\n        for(int j=0;j<m[i];j++)\n        {\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            if(x>y) swap(x,y);\n            G[x].push_back(y);\n        }\n        for(int j=n;j>=1;j--)\n        {\n            memset(has,false,sizeof(has));\n            for(auto to:G[j]) has[sg[i][to]]=true;\n            int k=0;\n            for(;has[k];k++);\n            sg[i][j]=k;\n            add(weight[i][k],p[j]);\n        }\n    }\n    int ans=0;\n    for(int i=0;i<512;i++)\n        for(int j=0;j<512;j++)\n        {\n            int k=i^j;\n            add(ans,1LL*weight[0][i]*weight[1][j]%MOD*weight[2][k]%MOD);\n        }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10, mod = 998244353;\nconst ll base = ll(1e18) % mod;\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= mod) a -= mod;\n\treturn a;\n}\n\nint mul(ll a, int b) {\n\ta *= b;\n\treturn a % mod;\n}\n\nint pbase[N];\n\nvector<pii> get(int n);\n\nint main() {\n\tfast_cin();\n\tint n; cin >> n;\n\tpbase[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpbase[i] = mul(pbase[i - 1], base);\n\t}\n\tvector<vector<pii>> g(3);\n\tfor (auto& v : g) {\n\t\tv = get(n);\n\t}\n\tvector<int> sum(2 * n + 1, 0);\n\tfor (auto& p1 : g[0]) {\n\t\tfor (auto& p2 : g[1]) {\n\t\t\tsum[p1.first ^ p2.first] = add(sum[p1.first ^ p2.first], mul(p1.second, p2.second));\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (auto& p : g[2]) {\n\t\tans = add(ans, mul(p.second, sum[p.first]));\n\t}\n\tcout << ans << endl;\n}\n\nvector<pii> get(int n) {\n\tvector<vector<int>> g(n + 1);\n\tint m; cin >> m;\n\twhile (m--) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tg[min(u, v)].pb(max(u, v));\n\t}\n\tvector<int> v(n + 1, 0);\n\tmap<int, int> temp;\n\tfor (int i = n; i >= 1; --i) {\n\t\tset<int> seen;\n\t\tfor (auto& j : g[i]) {\n\t\t\tseen.insert(v[j]);\n\t\t}\n\t\twhile (seen.count(v[i])) {\n\t\t\t++v[i];\n\t\t}\n\t\ttemp[v[i]] = add(temp[v[i]], pbase[i]);\n\t}\n\tvector<pii> ans(temp.begin(), temp.end());\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nmt19937 mt(736);\n\nconst int mod = 998244353;\n\n\nint powmod10(int n)\n{\n\tstatic vector<int> dp = {1};\n\n\twhile (n >= dp.size())\n\t\tdp.push_back((10ll * dp.back()) % mod);\n\n\treturn dp[n];\n}\n\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint n;\n\n\tcin >> n;\n\n\tarray<vector<vector<int>>, 3> xyz;\n\n\tfor (auto &gr : xyz)\n\t{\n\t\tgr.resize(n);\n\n\t\tint m;\n\n\t\tcin >> m;\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\n\t\t\tcin >> a >> b;\n\t\t\ta--;\n\t\t\tb--;\n\n\t\t\tgr[a].push_back(b);\n\t\t\tgr[b].push_back(a);\n\t\t}\n\t}\n\n\tarray<vector<bool>, 3> good, used, block;\n\n\tarray<ll, 3> wm{}, bm{};\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tauto get = [&]() {\n\t\t\tgood[i].clear();\n\t\t\tused[i].clear();\n\t\t\tblock[i].resize(n);\n\t\t\tgood[i].resize(n);\n\t\t\tused[i].resize(n);\n\n\t\t\tll white = 0;\n\n\t\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t\t\tif (!used[i][j] && !block[i][j])\n\t\t\t\t{\n\t\t\t\t\tgood[i][j] = true;\n\t\t\t\t\twhite += powmod10(18 * (j + 1));\n\n\t\t\t\t\tfor (auto it : xyz[i][j])\n\t\t\t\t\t\tused[i][it] = true;\n\t\t\t\t}\n\n\t\t\treturn white % mod;\n\t\t};\n\n\t\twm[i] = get();\n\t\tblock[i] = good[i];\n\t\tbm[i] = get();\n\t}\n\n\tll ans = wm[0] * wm[1] % mod * wm[2] % mod;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tll mult = 1;\n\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tmult = mult * (i == j ? wm[j] : bm[j]) % mod;\n\n\t\tans += mult;\n\t}\n\n\tcout << ans % mod << endl;\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcout << fixed;\n\n#ifdef LOCAL\n\tauto st = clock();\n\n\tifstream fin(\"../input.txt\");\n\n\tsolve(fin);\n\n\tcout << \"clock: \" << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tsolve();\n#endif\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<array>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\nvoid visit(const Graph& g, int v, Matrix& scc, stack<ll>& S, Array& inS, Array& low, Array& num, int& time) {\n\tlow[v] = num[v] = ++time;\n\tS.push(v); inS[v] = true;\n\tFOR(e, g[v]) {\n\t\tint w = e->to;\n\t\tif (num[w] == 0) {\n\t\t\tvisit(g, w, scc, S, inS, low, num, time);\n\t\t\tlow[v] = min(low[v], low[w]);\n\t\t}\n\t\telse if (inS[w])\n\t\t\tlow[v] = min(low[v], num[w]);\n\t}\n\tif (low[v] == num[v]) {\n\t\tscc.push_back(Array());\n\t\twhile (1) {\n\t\t\tint w = S.top(); S.pop(); inS[w] = false;\n\t\t\tscc.back().push_back(w);\n\t\t\tif (v == w) break;\n\t\t}\n\t}\n}\nvoid stronglyConnectedComponents(const Graph& g, Matrix& scc) {//強連結成分分解 O(E+V)\n\tconst int n = g.size();\n\tArray num(n), low(n);\n\tstack<ll> S;\n\tArray inS(n);\n\tint time = 0;\n\tREP(u, n) if (num[u] == 0)\n\t\tvisit(g, u, scc, S, inS, low, num, time);\n}\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを加算\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\nbool z_algorithm(string& str, vector<int>& z, ll s) {//s&tを渡してtにsが含まれるかを返す\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\tif (z[i] == s)return true;\n\t}\n\treturn false;\n}\nbool z_algorithm(string& str, vector<int>& z) {//z[i]==|s|のときstr[i]からsが含まれる\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n// ローリングハッシュ\n// 二分探索で LCP を求める機能つき\nstruct RollingHash {\n\tstatic const int base1 = 1007, base2 = 2009;\n\tstatic const int mod1 = 1000000007, mod2 = 1000000009;\n\tvector<long long> hash1, hash2, power1, power2;\n\n\t// construct\n\tRollingHash(const string& S) {\n\t\tint n = (int)S.size();\n\t\thash1.assign(n + 1, 0);\n\t\thash2.assign(n + 1, 0);\n\t\tpower1.assign(n + 1, 1);\n\t\tpower2.assign(n + 1, 1);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\thash1[i + 1] = (hash1[i] * base1 + S[i]) % mod1;\n\t\t\thash2[i + 1] = (hash2[i] * base2 + S[i]) % mod2;\n\t\t\tpower1[i + 1] = (power1[i] * base1) % mod1;\n\t\t\tpower2[i + 1] = (power2[i] * base2) % mod2;\n\t\t}\n\t}\n\n\t// get hash of S[left:right]\n\tinline pair<long long, long long> get(int l, int r) const {\n\t\tlong long res1 = hash1[r] - hash1[l] * power1[r - l] % mod1;\n\t\tif (res1 < 0) res1 += mod1;\n\t\tlong long res2 = hash2[r] - hash2[l] * power2[r - l] % mod2;\n\t\tif (res2 < 0) res2 += mod2;\n\t\treturn { res1, res2 };\n\t}\n\n\t// get lcp of S[a:] and T[b:]\n\tinline int getLCP(int a, int b) const {\n\t\tint len = min((int)hash1.size() - a, (int)hash1.size() - b);\n\t\tint low = 0, high = len;\n\t\twhile (high - low > 1) {\n\t\t\tint mid = (low + high) >> 1;\n\t\t\tif (get(a, a + mid) != get(b, b + mid)) high = mid;\n\t\t\telse low = mid;\n\t\t}\n\t\treturn low;\n\t}\n};\n\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tinv[n] = mod_inv(fact[n]);\n\t\tfor (int i = n; i > 0; i--) {\n\t\t\tinv[i - 1] = inv[i] * i % mod;\n\t\t}\n\t}\n};\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix& A, const Matrix& B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix& A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>>& s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n//NTT\nll _garner(Array& xs, Array& mods) {\n\tint M = xs.size();\n\n\tArray coeffs(M, 1), constants(M, 0);\n\n\tfor (int i = 0; i < M - 1; ++i) {\n\t\tll mod_i = mods[i];\n\t\t// coffs[i] * v + constants[i] == mr[i].val (mod mr[i].first) を解く\n\t\tll v = (xs[i] - constants[i] + mod_i) % mod_i;\n\t\tv = (v * mod_pow(coeffs[i], mod_i - 2, mod_i)) % mod_i;\n\n\t\tfor (int j = i + 1; j < M; j++) {\n\t\t\tll mod_j = mods[j];\n\t\t\tconstants[j] = (constants[j] + coeffs[j] * v) % mod_j;\n\t\t\tcoeffs[j] = (coeffs[j] * mod_i) % mod_j;\n\t\t}\n\t}\n\n\treturn constants.back();\n}\n\n\ntemplate<typename T>\ninline void bit_reverse(vector<T>& a) {\n\tint n = a.size();\n\tint i = 0;\n\tfor (int j = 1; j < n - 1; ++j) {\n\t\tfor (int k = n >> 1; k > (i ^= k); k >>= 1);\n\t\tif (j < i) swap(a[i], a[j]);\n\t}\n}\n\ntemplate<long long mod, long long primitive_root>\nclass NTT {\npublic:\n\tlong long get_mod() { return mod; }\n\n\tvoid _ntt(vector<long long>& a, int sign) {\n\t\tconst int n = a.size();\n\t\tassert((n ^ (n & -n)) == 0); //n = 2^k\n\n\t\tconst long long g = primitive_root; // g is primitive root of mod\n\n\t\tlong long tmp = (mod - 1) * mod_pow(n, mod - 2, mod) % mod; // -1/n\n\t\tlong long h = mod_pow(g, tmp, mod); // ^n√g\n\t\tif (sign == -1) h = mod_pow(h, mod - 2, mod);\n\n\t\tbit_reverse(a);\n\n\t\tfor (int m = 1; m < n; m <<= 1) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tlong long _base = mod_pow(h, n / m2, mod);\n\t\t\tlong long _w = 1;\n\t\t\tfor (int x = 0; x < m; ++x) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tlong long u = a[s];\n\t\t\t\t\tlong long d = (a[s + m] * _w) % mod;\n\t\t\t\t\ta[s] = (u + d) % mod;\n\t\t\t\t\ta[s + m] = (u - d + mod) % mod;\n\t\t\t\t}\n\t\t\t\t_w = (_w * _base) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tvoid ntt(vector<long long>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<long long>& input) {\n\t\t_ntt(input, -1);\n\n\t\tconst long long n_inv = mod_pow(input.size(), mod - 2, mod);\n\t\tfor (auto& x : input) x = (x * n_inv) % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<long long> convolution(const vector<long long>& a, const vector<long long>& b) {\n\t\tint result_size = a.size() + b.size() - 1;\n\t\tint n = 1; while (n < result_size) n <<= 1;\n\n\t\tvector<long long> _a = a, _b = b;\n\t\t_a.resize(n, 0);\n\t\t_b.resize(n, 0);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\t\tfor (int i = 0; i < n; ++i) _a[i] = (_a[i] * _b[i]) % mod;\n\t\tintt(_a);\n\n\t\t_a.resize(result_size);\n\t\treturn _a;\n\t}\n};\n\nvector<long long> convolution_ntt(vector<long long>& a, vector<long long>& b, long long mod = 1224736769LL) {\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\n\tll maxval = max(a.size(), b.size()) * *max_element(a.begin(), a.end()) * *max_element(b.begin(), b.end());\n\tif (maxval < 1224736769) {\n\t\tNTT<1224736769, 3> ntt3;\n\t\treturn ntt3.convolution(a, b);\n\t}\n\n\tNTT<167772161, 3> ntt1;\n\tNTT<469762049, 3> ntt2;\n\tNTT<1224736769, 3> ntt3;\n\n\tvector<long long> x1 = ntt1.convolution(a, b);\n\tvector<long long> x2 = ntt2.convolution(a, b);\n\tvector<long long> x3 = ntt3.convolution(a, b);\n\n\tvector<long long> ret(x1.size());\n\tvector<long long> mods{ 167772161, 469762049, 1224736769, mod };\n\tfor (int i = 0; i < x1.size(); ++i) {\n\t\tvector<long long> xs{ x1[i], x2[i], x3[i], 0 };\nret[i] = _garner(xs, mods);\n\t}\n\n\treturn ret;\n}\n\nint popcount3(int x) {\n\tx = (x & 0x55555555) + (x >> 1 & 0x55555555);\n\tx = (x & 0x33333333) + (x >> 2 & 0x33333333);\n\tx = (x & 0x0F0F0F0F) + (x >> 4 & 0x0F0F0F0F);\n\tx = (x & 0x00FF00FF) + (x >> 8 & 0x00FF00FF);\n\tx = (x & 0x0000FFFF) + (x >> 16 & 0x0000FFFF);\n\n\treturn x;\n}\n\ntemplate<typename T>\nvoid rowReduction(vector<T> mat, vector<T>& basis) {//掃き出し法\n\tfor (auto e : mat) {\n\t\tfor (auto b : basis)\n\t\t\tchmin(e, e ^ b);\n\t\tif (e)\n\t\t\tbasis.push_back(e);\n\t}\n\tsort(all(basis), greater<T>());\n}\n\n\nstruct SegT {\nprivate:\n\tint n; vector<ll> node, lazy;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int sz) {\n\t\tn = 1;\n\t\twhile (n < sz)n <<= 1;\n\t\tnode.resize(2 * n - 1, 0);\n\t\tlazy.resize(2 * n - 1, 0);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn max(a, b);\n\t}\n\tvoid eval(int k, int l, int r) {\n\t\tnode[k] += lazy[k];\n\t\tif (r - l > 1) {\n\t\t\tlazy[2 * k + 1] += lazy[k];\n\t\t\tlazy[2 * k + 2] += lazy[k];\n\t\t}\n\t\tlazy[k] = 0;\n\t}\n\tvoid add(ll x, int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = n;\n\t\teval(k, l, r);\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += x; eval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tadd(x, a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tadd(x, a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = n;\n\t\teval(k, l, r);\n\t\tif (r <= a || b <= l)return init_c;\n\t\tif (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n};\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tconstexpr ll mod = 998244353;\n\n\tll n;\n\tcin >> n;\n\tMatrix grundy(3, Array(2000, 0));\n\tREP(i, 3) {\n\t\tll m;\n\t\tcin >> m;\n\t\tGraph g(n);\n\t\tREP(j, m) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tadd_edge(g, a, b, 1, true, 1);\n\t\t}\n\t\tArray temp(n, 0);\n\t\tfor(int j=g.size()-1;j>=0;j--) {\n\t\t\tset<ll> st;\n\t\t\tll now = 0;\n\t\t\tREP(k, g[j].size()) {\n\t\t\t\tll to = g[j][k].to;\n\t\t\t\tif (to < j)continue;\n\t\t\t\tst.insert(temp[to]);\n\t\t\t\twhile (st.count(now))now++;\n\t\t\t}\n\t\t\ttemp[j] = now;\n\t\t\t(grundy[i][now] += mod_pow(10, 18*(j + 1), mod)) %= mod;\n\t\t}\n\t}\n\tll ans = 0;\n\tREP(i, 1000) {\n\t\tREP(j, 1000) {\n\t\t\tll temp = grundy[0][i] * grundy[1][j] % mod;\n\t\t\t(temp *= grundy[2][(i ^ j)]) %= mod;\n\t\t\t(ans += temp )%= mod;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 100007\n#define modp 998244353\nusing namespace std;\nint base=1;\nint n,m1,m2,m3;\nint n1,n2,n3,val1[Maxn],val2[Maxn],val3[Maxn],val[3*Maxn];\nvector<int> e1[Maxn],e2[Maxn],e3[Maxn];\nbool vis[Maxn],flag[Maxn];\nbool vis1[2007][2007],vis2[2007][2007],vis3[2007][2007];\nvoid solve1()\n{\n    n1=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val1[++n1]=val[i];\n                } else val1[n1]=(val1[n1]+val[i])%modp;\n                for (int j=0;j<(int)e1[i].size();j++)\n                    flag[e1[i][j]]=false;\n            }\n    }\n}\nvoid solve2()\n{\n    n2=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val2[++n2]=val[i];\n                } else val2[n2]=(val2[n2]+val[i])%modp;\n                for (int j=0;j<(int)e2[i].size();j++)\n                    flag[e2[i][j]]=false;\n            }\n    }\n}\nvoid solve3()\n{\n    n3=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val3[++n3]=val[i];\n                } else val3[n3]=(val3[n3]+val[i])%modp;\n                for (int j=0;j<(int)e3[i].size();j++)\n                    flag[e3[i][j]]=false;\n            }\n    }\n}\nint main()\n{\n    for (int i=1;i<=18;i++)\n        base=(10LL*base)%modp;\n    scanf(\"%d\",&n);\n    val[0]=1;\n    for (int i=1;i<=3*n;i++)\n        val[i]=(1LL*val[i-1]*base)%modp;\n    scanf(\"%d\",&m1);\n    for (int i=1;i<=m1;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e1[u].push_back(v);\n        e1[v].push_back(u);\n    }\n    scanf(\"%d\",&m2);\n    for (int i=1;i<=m2;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e2[u].push_back(v);\n        e2[v].push_back(u);\n    }\n    scanf(\"%d\",&m3);\n    for (int i=1;i<=m3;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e3[u].push_back(v);\n        e3[v].push_back(u);\n    }\n    solve1();\n    solve2();\n    solve3();\n    int ans=0;\n    memset(vis1,true,sizeof(vis1));\n    memset(vis2,true,sizeof(vis2));\n    memset(vis3,true,sizeof(vis3));\n    for (int x=3;x<=n1+n2+n3;x++)\n        for (int i=1;i<=n1;i++)\n            for (int j=1;j<=n2;j++)\n            {\n                int k=x-i-j;\n                if (k>=1&&k<=n3)\n                {\n                    if (vis1[i][j]&&vis2[j][k]&&vis3[k][i])\n                    {\n                        vis1[i][j]=false;\n                        vis2[j][k]=false;\n                        vis3[k][i]=false;\n                        int tmp=(1LL*val1[i]*val2[j])%modp;\n                        tmp=(1LL*tmp*val3[k])%modp;\n                        ans=(ans+tmp)%modp;\n                    }\n                }\n            }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define oo 1000000010\n#define mod  998244353\nconst int N = 200010;\nconst int M = 3 * N;\n\nint n , m , u , v;\n\nint po[M] , mx;\n\nvector< vector< int > > g[3];\n\nvector< int > arr[3];\n\n\nbool has[N];\n\nvoid make(vector< vector< int > > &g , vector< int > &v){\n\tv.resize(n);\n\tfor(int i = n - 1; i >= 0;i--){\n\t\tfor(int j = 0 ;j <= (int)g[i].size() + 2;j++) has[j] = false;\n\t\tfor(int j = 0 ;j < (int)g[i].size();j++){\n\t\t\thas[v[g[i][j]]] = true;\n\t\t}\n\t\twhile(has[v[i]]) v[i]++;\n\t\tmx = max(mx , v[i]);\n\t}\n}\n\nint dp[4][N];\n\n\n\nint main(){\n\tpo[0] = 1;\n\tpo[1] = ((long long)1e18) % mod;\n\tfor(int i = 2;i < M;i++){\n\t\tpo[i] = (long long)po[i - 1] * po[1] % mod;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i = 0 ;i < 3;i++){\n\t\tg[i].resize(n);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j = 0 ;j < m;j++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--,v--;\n\t\t\tif(u > v) swap(u , v);\n\t\t\tg[i][u].push_back(v);\n\t\t}\n\t\tmake(g[i] , arr[i]);\n\t}\n\tdp[3][0] = 1;\n\tfor(int j = 25;j >= 0;j--){\n\t\tif(((mx >> j) & 1) == 1){\n\t\t\tmx = (1 << (j + 1)) - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 2;i >= 0;i--){\n\t\tfor(int x = 0 ; x <= mx;x++){\n\t\t\tdp[i][x] = 0;\n\t\t\tfor(int j = 0 ;j < (int)arr[i].size();j++){\n\t\t\t\tdp[i][x] += (long long)dp[i + 1][(x ^ arr[i][j])] * po[j + 1] % mod;\n\t\t\t\tif(dp[i][x] >= mod) \n\t\t\t\t\tdp[i][x] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[0][0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define MOD 1000000007\n#define MOD 998244353\n\nclass mint {\n\tpublic:\n\t\tint i;\n\n\t\tmint() : i(0) {}\n\n\t\ttemplate<class T>\n\t\t\tmint(T x) {\n\t\t\t\ti = int(x % MOD);\n\t\t\t\tif (i < 0) i += MOD;\n\t\t\t}\n\n\t\tmint operator+(mint x) {\n\t\t\treturn i + x.i;\n\t\t}\n\n\t\tmint operator-(mint x) {\n\t\t\treturn i - x.i;\n\t\t}\n\n\t\tmint operator*(mint x) {\n\t\t\treturn (long long)i * x.i;\n\t\t}\n\n\t\tmint operator/(mint x) {\n\t\t\treturn (long long)i * x.pow(MOD - 2).i;\n\t\t}\n\n\t\tmint inv() {\n\t\t\treturn pow(MOD - 2);\n\t\t}\n\n\t\ttemplate<class T>\n\t\t\tmint pow(T p) {\n\t\t\t\tlong long r = 1;\n\t\t\t\tlong long t = i;\n\t\t\t\tfor(; p > 0; p >>= 1) {\n\t\t\t\t\tif (p & 1) r = r * t % MOD;\n\t\t\t\t\tt = t * t % MOD;\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\ttemplate<class T1, class T2>\n\t\t\tstatic mint pow(T1 a, T2 b) {\n\t\t\t\tlong long r = 1;\n\t\t\t\tlong long t = (long long)(a % MOD);\n\t\t\t\tfor(; b > 0; b >>= 1) {\n\t\t\t\t\tif (b & 1) r = r * t % MOD;\n\t\t\t\t\tt = t * t % MOD;\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\tmint& operator+=(mint x) {\n\t\t\ti = (i + x.i) % MOD;\n\t\t\treturn *this;\n\t\t}\n\n\t\tmint& operator-=(mint x) {\n\t\t\ti = i - x.i;\n\t\t\tif (i < 0) i += MOD;\n\t\t\treturn *this;\n\t\t}\n\n\t\tmint& operator*=(mint x) {\n\t\t\ti = (int)((long long)i * x.i % MOD);\n\t\t\treturn *this;\n\t\t}\n\n\t\tmint& operator/=(mint x) {\n\t\t\ti = (long long)i * x.pow(MOD - 2).i % MOD;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream& os, const mint& m) {\n\treturn os << m.i;\n}\n\nstd::vector<std::vector<int>> iig(int vn, int en) { \n        std::vector<std::vector<int>> res(vn); \n        for(int i = 0; i < en; i++) { \n                int s, t; \n                std::cin >> s >> t; \n                s--; t--; \n\t\tif (s > t) swap(s, t);\n                res[t].push_back(s); \n        } \n        return res; \n}\n\nstd::vector<int> assign_grundy(std::vector<std::vector<int>>& dg) {\n\tint gsize = dg.size();\n\tstd::vector<int> incomings(gsize);\n\tfor(int i = 0; i < gsize; i++) {\n\t\tfor(int j: dg[i]) {\n\t\t\tincomings[j]++;\n\t\t}\n\t}\n\tstd::vector<int> vs_ready;\n\tfor(int i = 0; i < gsize; i++) {\n\t\tif (incomings[i] == 0) vs_ready.push_back(i);\n\t}\n\tstd::vector<std::set<int>> prohibited_grundy(gsize);\n\tstd::vector<int> grundy(gsize);\n\twhile(!vs_ready.empty()) {\n\t\tint i = vs_ready.back();\n\t\tvs_ready.pop_back();\n\t\tint g = 0;\n\t\tfor(int pg: prohibited_grundy[i]) {\n\t\t\tif (g == pg) g++;\n\t\t\telse break;\n\t\t}\n\t\tgrundy[i] = g;\n\t\tfor(int j: dg[i]) {\n\t\t\tprohibited_grundy[j].insert(g);\n\t\t\tif ((--incomings[j]) == 0) vs_ready.push_back(j);\n\t\t}\n\t}\n\treturn grundy;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n;\n\tcin >> m;\n\tauto g1 = iig(n, m);\n\tcin >> m;\n\tauto g2 = iig(n, m);\n\tcin >> m;\n\tauto g3 = iig(n, m);\n\t// assume that each edge direction is reversed\n\tauto grn1 = assign_grundy(g1);\n\tauto grn2 = assign_grundy(g2);\n\tauto grn3 = assign_grundy(g3);\t\n\t// gmax * (gmax + 1) <= E * 2\n\n\tvector<mint> w(n + 1);\n\tmint step = mint::pow(10, 18);\n\tw[0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tw[i] = w[i-1] * step;\n\t}\n\n\tvector<mint> gcount1(500), gcount2(500), gcount3(500);\n\tfor(int i = 0; i < n; i++) {\n\t\tgcount1[grn1[i]] += w[i+1];\n\t\tgcount2[grn2[i]] += w[i+1];\n\t\tgcount3[grn3[i]] += w[i+1];\n\t}\n\n\tmint res = 0;\n\n\tfor(int i = 0; i < 500; i++)\n\t\tfor(int j = 0; j < 500; j++) {\n\t\t\tint k = i ^ j;\n\t\t\tif (k >= 500) continue;\n\t\t\tres += gcount1[i] * gcount2[j] * gcount3[k];\n\t\t}\n\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100010\nconst int p=998244353;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nint n,m,mx,ans,SG[3][maxn],sum[3][maxn],buck[maxn];\nvector<int>G[3][maxn];\nvoid Add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p)\n\t\tx-=p;\n}\nint mul(int x,int y)\n{\n\treturn 1ll*x*y%p;\n}\nint fpow(int x,int y)\n{\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tres=mul(res,x);\n\t\tx=mul(x,x);\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tread(n);\n\tfor(int k=0;k<3;k++)\n\t{\n\t\tread(m);\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tread(x,y);\n\t\t\tif(x>y)swap(x,y);\n\t\t\tG[k][x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i>=1;i--)\n\t\t{\n\t\t\tfor(auto j:G[k][i])\n\t\t\t\tbuck[SG[k][j]]=true;\n\t\t\tfor(int j=0;j<=mx+1;j++)\n\t\t\t{\n\t\t\t\tif(buck[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tSG[k][i]=j;\n\t\t\t\tmx=max(mx,j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAdd(sum[k][SG[k][i]],fpow(10,18*i));\n\t\t\tfor(auto j:G[k][i])\n\t\t\t\tbuck[SG[k][j]]=false;\n\t\t}\n\t}\n\tfor(int a=0;a<=mx;a++)\n\t\tif(sum[0][a])\n\t\t\tfor(int b=0;b<=mx;b++)\n\t\t\t\tif(sum[1][b])\n\t\t\t\t\tAdd(ans,mul(mul(sum[0][a],sum[1][b]),sum[2][a^b]));\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 100007\n#define modp 998244353\nusing namespace std;\nint base=1;\nint n,m1,m2,m3;\nint n1,n2,n3,val1[Maxn],val2[Maxn],val3[Maxn],val[Maxn];\nvector<int> e1[Maxn],e2[Maxn],e3[Maxn];\nbool vis[Maxn],flag[Maxn];\nbool vis1[2007][2007],vis2[2007][2007],vis3[2007][2007];\nvector<pair<pair<int,int>,pair<int,int> > >v;\nvoid solve1()\n{\n    n1=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val1[++n1]=val[i];\n                } else val1[n1]=(val1[n1]+val[i])%modp;\n                for (int j=0;j<(int)e1[i].size();j++)\n                    flag[e1[i][j]]=false;\n            }\n    }\n}\nvoid solve2()\n{\n    n2=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val2[++n2]=val[i];\n                } else val2[n2]=(val2[n2]+val[i])%modp;\n                for (int j=0;j<(int)e2[i].size();j++)\n                    flag[e2[i][j]]=false;\n            }\n    }\n}\nvoid solve3()\n{\n    n3=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val3[++n3]=val[i];\n                } else val3[n3]=(val3[n3]+val[i])%modp;\n                for (int j=0;j<(int)e3[i].size();j++)\n                    flag[e3[i][j]]=false;\n            }\n    }\n}\nint main()\n{\n    for (int i=1;i<=18;i++)\n        base=(10LL*base)%modp;\n    scanf(\"%d\",&n);\n    val[0]=1;\n    for (int i=1;i<=n;i++)\n        val[i]=(1LL*val[i-1]*base)%modp;\n    scanf(\"%d\",&m1);\n    for (int i=1;i<=m1;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e1[u].push_back(v);\n        e1[v].push_back(u);\n    }\n    scanf(\"%d\",&m2);\n    for (int i=1;i<=m2;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e2[u].push_back(v);\n        e2[v].push_back(u);\n    }\n    scanf(\"%d\",&m3);\n    for (int i=1;i<=m3;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e3[u].push_back(v);\n        e3[v].push_back(u);\n    }\n    solve1();\n    solve2();\n    solve3();\nreturn 0;\n    for (int i=1;i<=n1;i++)\n        for (int j=1;j<=n2;j++)\n            for (int k=1;k<=n3;k++)\n                v.push_back(make_pair(make_pair(i+j+k,i),make_pair(j,k)));\n    sort(v.begin(),v.end());\n    int ans=0;\n    memset(vis1,true,sizeof(vis1));\n    memset(vis2,true,sizeof(vis2));\n    memset(vis3,true,sizeof(vis3));\n    for (int id=0;id<v.size();id++)\n    {\n        int i=v[id].first.second;\n        int j=v[id].second.first;\n        int k=v[id].second.second;\n        if (vis1[i][j]&&vis2[j][k]&&vis3[k][i])\n        {\n            vis1[i][j]=false;\n            vis2[j][k]=false;\n            vis3[k][i]=false;\n            int tmp=(1LL*val1[i]*val2[j])%modp;\n            tmp=(1LL*tmp*val3[k])%modp;\n            ans=(ans+tmp)%modp;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nconst int MAXN = 100000;\nconst ll MOD = 998244353;\nconst ll PO = 1000000000000000000LL%MOD;\nconst int SQ = 450;\n\nint n;\nvector<int> lis[3][100100];\nll an1[100100];\nll anv[SQ+10];\nint an2[100100];\nll anv2[SQ+10];\nint an3[100100];\nll po[300100];\nint nxt[100100][SQ+10];\nbool av[100100][SQ+10];\n\nint chk[100100];\nint chk2[100100][SQ+10];\n\nint fin(int i, int t) {\n\tif (!av[i][t]) return t;\n\treturn nxt[i][t] = (fin(i,nxt[i][t]));\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tint m;\n\tfor (int t=0;t<3;t++) {\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b); a--; b--;\n\t\t\tif (a>b) swap(a,b);\n\t\t\tlis[t][a].push_back(b);\n\t\t}\n\t}\n\tpo[0] = 1;\n\tfor (int i=1;i<=3*n;i++) po[i] = po[i-1]*PO%MOD;\n\tfor (int i=n-1;i>=0;i--) {\n\t\tfor (int &j : lis[0][i]) chk[an1[j]] = 1;\n\t\tint t;\n\t\tfor (t=0;chk[t];t++);\n\t\tan1[i] = t;\n\t\tanv[t] = (anv[t]+po[i])%MOD;\n\t\tfor (int &j : lis[0][i]) chk[an1[j]] = 0;\n\t}\n\tfor (int i=0;i<n;i++) {\n\t\tfor (int j=0;j<SQ;j++) nxt[i][j] = j+1;\n\t}\n\tfor (int j=0;j<SQ;j++) {\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int &k : lis[1][i]) chk2[i][an2[k]]++;\n\t\t\tint t;\n\t\t\tfor (t = fin(i,0); t<SQ&&chk2[i][t]; t = fin(i,nxt[i][t]));\n\t\t\tan2[i] = t;\n\t\t\tanv2[j] = (anv2[j] + anv[t]*po[i]) % MOD;\n\t\t\tfor (int &k : lis[1][i]) chk2[i][an2[k]]--;\n\t\t}\n\t\t//printf(\"%d : %lld\\n\",j,anv2[j]);\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tav[i][an2[i]] = 1;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i=n-1;i>=0;i--) {\n\t\tfor (int &j : lis[2][i]) chk[an3[j]] = 1;\n\t\tint t;\n\t\tfor (t=0;chk[t];t++);\n\t\tan3[i] = t;\n\t\tans = (ans+anv2[t]*po[i])%MOD;\n\t\tfor (int &j : lis[2][i]) chk[an3[j]] = 0;\n\t}\n\tprintf(\"%lld\\n\",ans*po[3]%MOD);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define P 998244353\n#define B ((ll)1e18%P)\n#define MAX 500005\nusing namespace std;\n\nint n, m, cnt, id;\nint head[MAX], vet[MAX], Next[MAX], sg[3][MAX];\nll p[MAX], f[3][MAX];\n\nvoid add(int x, int y){\n    cnt++;\n    Next[cnt] = head[x];\n    head[x] = cnt;\n    vet[cnt] = y;\n}\n\nint dfs(int x){\n    if(sg[id][x] != -1) return sg[id][x];\n    sg[id][x] = 0;\n    map<int, bool> mp;\n    for(int i = head[x]; i; i = Next[i]){\n        int v = vet[i];\n        mp[dfs(v)] = true;\n    }\n    while(mp[sg[id][x]]) sg[id][x]++;\n    return sg[id][x];\n}\n\nint main()\n{\n    cin >> n;\n    p[0] = 1;\n    for(int i = 1; i < MAX; i++){\n        p[i] = p[i-1]*B%P;\n    }\n    memset(sg, -1, sizeof(sg));\n    for(id = 0; id < 3; id++){\n        memset(head, 0, sizeof(head));\n        cnt = 0;\n        cin >> m;\n        int x, y;\n        for(int i = 1; i <= m; i++){\n            scanf(\"%d%d\", &x, &y);\n            if(x > y) swap(x, y);\n            add(x, y);\n        }\n        for(int i = 1; i <= n; i++){\n            if(sg[id][i] == -1) dfs(i);\n        }\n        for(int i = 1; i <= n; i++){\n            (f[id][sg[id][i]] += p[i]) %= P;\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i < 400; i++){\n        for(int j = 0; j < 400; j++){\n            ans = (ans + f[0][i]*f[1][j]%P*f[2][i^j]%P)%P;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nusing uint = unsigned;\nconst uint MOD = 998244353;\nstruct Z {\n    uint v;\n\n    Z(uint v = 0) : v(v) {}\n\n    Z& operator += (const Z &z) {\n        v += z.v;\n        if (v >= MOD) v -= MOD;\n        return *this;\n    }\n\n    Z& operator -= (const Z &z) {\n        if (v < z.v) v += MOD;\n        v -= z.v;\n        return *this;\n    }\n\n    Z& operator *= (const Z &z) {\n        v = static_cast<uint64_t>(v) * z.v % MOD;\n        return *this;\n    }\n\n    void div2() {\n        if (v & 1) v += MOD;\n        v >>= 1;\n    }\n};\n\nostream& operator << (ostream &os, const Z &z) {\n    return os << z.v;\n}\n\nZ operator + (const Z &x, const Z &y) {\n    return Z(x.v + y.v >= MOD ? x.v + y.v - MOD : x.v + y.v);\n}\n\nZ operator - (const Z &x, const Z &y) {\n    return Z(x.v < y.v ? x.v + MOD - y.v : x.v - y.v);\n}\n\nZ operator * (const Z &x, const Z &y) {\n    return Z(static_cast<uint64_t>(x.v) * y.v % MOD);\n}\n\nZ qpow(Z base, uint e) {\n    Z ret(1);\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret *= base;\n        }\n        base *= base;\n    }\n    return ret;\n}\n\nconst size_t N = 1 << 17;\n\nvector<int> g[3][N];\nint sg[3][N];\nZ pw[N];\n\nvoid dfs(int id, int u) {\n    if (~sg[id][u]) return;\n    sg[id][u] = 0;\n    for (int v : g[id][u]) {\n        dfs(id, v);\n    }\n    static int lst[N], tot = 0;\n    ++tot;\n    for (int v : g[id][u]) {\n        lst[sg[id][v]] = tot;\n    }\n    while (lst[sg[id][u]] == tot) {\n        ++sg[id][u];\n    }\n}\n\nvoid fwt_xor(Z a[], int n, int flag) {\n    for (int m = 1, l = 2; m < n; m <<= 1, l <<= 1) {\n        Z *x = a, *y = a + m;\n        for (int i = 0; i < n; i += l) {\n            for (int j = 0; j < m; ++j, ++x, ++y) {\n                Z tmp = *y;\n                *y = *x;\n                *x += tmp;\n                *y -= tmp;\n                if (flag == 2) {\n                    x->div2();\n                    y->div2();\n                }\n            }\n            x += m;\n            y += m;\n        }\n    }\n}\n\nint main() {\n    memset(sg, -1, sizeof sg);\n    int n = read();\n    for (int i = 0; i < 3; ++i) {\n        for (int m = read(); m--; ) {\n            int u = read(), v = read();\n            if (u > v) swap(u, v);\n            g[i][u].emplace_back(v);\n        }\n        for (int j = 1; j <= n; ++j) {\n            dfs(i, j);\n        }\n    }\n\n    pw[0] = 1;\n    Z mul = (LL) 1E18 % MOD;\n    for (int i = 1; i <= n; ++i) {\n        pw[i] = pw[i - 1] * mul;\n    }\n\n    static Z f[3][N];\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            f[i][sg[i][j]] += pw[j];\n        }\n    }\n    fwt_xor(f[0], N, 1);\n    fwt_xor(f[1], N, 1);\n    for (uint i = 0; i < N; ++i) {\n        f[0][i] *= f[1][i];\n    }\n    fwt_xor(f[0], N, 2);\n    Z ans = 0;\n    for (uint i = 0; i < N; ++i) {\n        ans += f[0][i] * f[2][i];\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define so(a) ((int)((a).size()))\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007 , D = 3 , __ = _ * D , LIM = 512 , mo = 998244353;\nconst lint linf = 1000000000000000000;\n\ntemplate<typename T1,typename T2> inline T1 ad(T1 &a,T2 b){return a=a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 dl(T1 &a,T2 b){return a=a>=b?a-b:a-b+mo;}\ntemplate<typename T1,typename T2> inline T1 add(T1 a,T2 b){return a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 del(T1 a,T2 b){return a>=b?a-b:a-b+mo;}\n\nlint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a){return powa(a,mo-2);}\n\nvector<int> e[_];\nlint bas[__];\nint n,sg[_];\n\nvoid makef(lint f[])\n{\n\tint m=ty();\n\tfor(int i=1;i<=n;i++)sg[i]=0,e[i].clear();\n\tfor(int i=1,a,b;i<=m;i++)a=ty(),b=ty(),e[min(a,b)].emplace_back(max(a,b));\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tunordered_set<int> hav;\n\t\tfor(auto b:e[i])hav.emplace(sg[b]);\n\t\tsg[i]=0;\n\t\twhile(hav.count(sg[i]))sg[i]++;\n\t}\n\tfor(int i=0;i<LIM;i++)f[i]=0;\n\tfor(int i=1;i<=n;i++)ad(f[sg[i]],bas[i]);\t\n}\n\nlint f[D][LIM];\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tbas[0]=1;\n\tfor(int i=1;i<__;i++)bas[i]=bas[i-1]*(linf%mo)%mo;\n\tfor(int i=0;i<D;i++)makef(f[i]);\n\n\tlint ans=0;\n\tfor(int i=0;i<LIM;i++)\n\t\tfor(int j=0;j<LIM;j++)\n\t\t\tad(ans,f[0][i]*f[1][j]%mo*f[2][i^j]%mo);\n\tcout<<ans<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Fi first\n#define Se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\ntypedef tuple<int, int, int> t3;\n\nint N;\nint color[3][100010];\nvector <int> E[3][100010];\n\nconst int mod = 998244353;\nll V[3][100010];\nll rp[300010];\n\nint main() {\n\tll r = 1;\n\trep(i, 18) r = r * 10 % mod;\n\trp[0] = 1;\n\tfor(int i=1;i<300010;i++) rp[i] = rp[i-1] * r % mod;\n\tscanf(\"%d\", &N);\n\trep(v, 3) {\n\t\tint m; scanf(\"%d\", &m);\n\t\twhile(m--) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tE[v][x].pb(y);\n\t\t\tE[v][y].pb(x);\n\t\t}\n\t\tfor(int i=N;i;i--) {\n\t\t\tset <int> x;\n\t\t\tfor(int e : E[v][i]) if(e > i) x.insert(color[v][e]);\n\t\t\tfor(int j=0;;j++) if(x.find(j) == x.end()) {\n\t\t\t\tcolor[v][i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=N;i++) {\n\t\t\tint c = color[v][i];\n\t\t\tV[v][c] = (V[v][c] + rp[i]) % mod;\n\t\t}\n\t}\n\tll ans = V[0][0] * V[1][0] % mod * V[2][0] % mod;\n\tfor(int i=1;i<=N;i++) {\n\t\tll val = V[0][0] * V[1][i] % mod * V[2][i];\n\t\tans = (ans + val) % mod;\n\t\tval = V[0][i] * V[1][0] % mod * V[2][i];\n\t\tans = (ans + val) % mod;\n\t\tval = V[0][i] * V[1][i] % mod * V[2][0];\n\t\tans = (ans + val) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nconst ll mod = 998244353;\nconst ll x = 716070898;\n\nvector <int> G[101010];\nvector <ll> V[3];\nset <int> S1, S2;\nll C[101010], ans;\nint n;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint m, u, v, i, j;\n\tll t, s;\n\n\tcin >> n;\n\n\tfor(i = 1, t = x; i <= n; i ++){\n\t\tC[i] = t; t = t * x % mod;\n\t}\n\n\tfor(i = 0; i < 3; i ++){\n\t\tfor(j = 1; j <= n; j ++){\n\t\t\tG[j].clear();\n\t\t\tS1.insert(j);\n\t\t}\n\t\tcin >> m;\n\t\tfor(; m --; ){\n\t\t\tcin >> u >> v;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tfor(; !S1.empty(); ){\n\t\t\tfor(s = 0; !S1.empty(); ){\n\t\t\t\tu = *prev(S1.end()); S1.erase(u);\n\t\t\t\ts = (s + C[u]) % mod;\n\t\t\t\tfor(int &t: G[u]){\n\t\t\t\t\tif(S1.find(t) != S1.end()){\n\t\t\t\t\t\tS1.erase(t);\n\t\t\t\t\t\tS2.insert(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tV[i].push_back(s);\n\t\t\tswap(S1, S2);\n\t\t}\n\t}\n\n\tans = (ans + V[0][0] * V[1][0] % mod * V[2][0]) % mod;\n\tfor(i = 1; ; i ++){\n\t\tif(i == V[0].size() || i == V[1].size() || i == V[2].size()) break;\n\t\tans = (ans + V[0][0] * V[1][i] % mod * V[2][i]) % mod;\n\t\tans = (ans + V[0][i] * V[1][0] % mod * V[2][i]) % mod;\n\t\tans = (ans + V[0][i] * V[1][i] % mod * V[2][0]) % mod;\n\t}\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\n\nint n,m[3],gr[3][100005];\nvi g[3][100005];\nMint sum[3][450],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,3){\n\t\tcin>>m[i];\n\t\trep(j,m[i]){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tg[i][--a].pb(--b);\n\t\t\tg[i][b].pb(a);\n\t\t}\n\t\tvi p;\n\t\trrep(j,n){\n\t\t\tp.clear();\n\t\t\tfor(auto &k:g[i][j]){\n\t\t\t\tif(j<k){\n\t\t\t\t\tp.pb(gr[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(p));\n\t\t\tp.erase(unique(all(p)),p.end());\n\t\t\tgr[i][j]=-1;\n\t\t\trep(k,si(p)){\n\t\t\t\tif(k!=p[k]){\n\t\t\t\t\tgr[i][j]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(gr[i][j]==-1)gr[i][j]=si(p);\n\t\t\tsum[i][gr[i][j]]+=Mint(10).pow(18*(j+1));\n\t\t}\n\t}\n\trep(i,450){\n\t\trep(j,450){\n\t\t\trep(k,450){\n\t\t\t\tif(i^j^k==0){\n\t\t\t\t\tans+=sum[0][i]*sum[1][j]*sum[2][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    const auto& modpow = [](unsigned long n, unsigned long b = 1, unsigned long a = 716070898) -> unsigned long {\n        unsigned long r{b % MOD};\n        while(n){\n            if(n & 1)(r *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return r;\n    };\n    unsigned long N;\n    cin >> N;\n    vector<unsigned long> indpX, indpY, indpZ;\n    for(unsigned long _{0}; _ < 3; ++_){\n        swap(indpX, indpY);\n        swap(indpZ, indpY);\n        unsigned long M;\n        cin >> M;\n        vector<vector<unsigned long>> edge(N);\n        for(unsigned long i{0}, a, b; i < M; ++i){\n            cin >> a >> b;\n            if(a < b)swap(a, b);\n            edge[--a].push_back(--b);\n        }\n        vector<unsigned long> id(N, N - 1);\n        for(unsigned long i{N}; i--; )for(const auto& j : edge[i])id[j] -= id[j] == id[i];\n        map<unsigned long, pair<unsigned long, unsigned long>> mp;\n        for(unsigned long i{0}; i < N; ++i){\n            mp[id[i]].first = i + 1;\n            (mp[id[i]].second += modpow(i + 1)) %= MOD;\n        }\n        vector<pair<unsigned long, unsigned long>> Z;\n        for(const auto& i : mp)Z.emplace_back(i.second);\n        sort(Z.begin(), Z.end(), greater<>());\n        for(const auto& i : Z){\n            //cout << i.first << \" \" << i.second << \"] \";\n            indpZ.emplace_back(i.second);\n        }\n        //cout << endl;\n    }\n    /*for(const auto& i : indpX)cout << i << \" \";cout << endl;\n    for(const auto& i : indpY)cout << i << \" \";cout << endl;\n    for(const auto& i : indpZ)cout << i << \" \";cout << endl;*/\n    if(indpX.size() > indpZ.size())swap(indpX, indpZ);\n    if(indpY.size() > indpZ.size())swap(indpY, indpZ);\n    if(indpX.size() > indpY.size())swap(indpX, indpY);\n    unsigned long MX{indpX.size()}, MY{indpY.size()};\n    string al{string(500, '1')};\n    vector<bitset<500>> usedY(MY, bitset<500>(al));\n    unsigned long ans{0};\n    for(const auto& i : indpZ){\n        bitset<500> used{al};\n        unsigned long tmp{0};\n        for(unsigned long j{0}; j < MY; ++j){\n            unsigned long k{(usedY[j] & used)._Find_first()};\n            if(k < MX){\n                //cout << j << \" : \" << k << endl;\n                used[k] = false;\n                usedY[j][k] = false;\n                (tmp += indpY[j] * indpX[k] % MOD) %= MOD;\n            }\n        }\n        //cout << endl;\n        tmp %= MOD;\n        (ans += i * tmp % MOD) %= MOD;\n    }\n    cout << ans % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,popcnt,sse4.1,sse4.2,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\n//using arr = array;\nusing pi = pair<int, int>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vpi = vector<pi>;\nusing ld = long double;\nconst int maxn = 1<<17, mod = 119<<23|1;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint n, m;\nll res[3][2], p[maxn];\n#define mul(x, y) ((x)*1ll*(y)%mod)\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tp[0] = 1;\n\tfor(int i = 1; i < maxn; i++) p[i] = p[i-1]*716070898ll%mod;\n\tcin >> n;\n\tfor(int i = 0; i < 3; i++) {\n\t\tcin >> m;\n\t\tvvi g(n+1);\n\t\tfor(int f, t, j = 0; j < m; j++) {\n\t\t\tcin >> f >> t;\n\t\t\tg[f].pb(t);\n\t\t\tg[t].pb(f);\n\t\t}\n\t\tvi rem(n+1, 0);\n\t\tfor(int v = n; v; v--) {\n\t\t\tif(rem[v]) {\n\t\t\t\t(res[i][0] += p[v]) %= mod;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(res[i][1] += p[v]) %= mod;\n\t\t\tfor(auto &u : g[v]) rem[u] = 1;\n\t\t}\n\t}\n\tll ans = mul(res[0][1], mul(res[1][1], res[2][1]));\n\tans += mul(res[0][1], mul(res[1][0], res[2][0]));\n\tans += mul(res[0][0], mul(res[1][1], res[2][0]));\n\tans += mul(res[0][0], mul(res[1][0], res[2][1]));\n\tcout << ans%mod << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i=(a); i<(int)(b); i++)\n#define FORD(i, a, b) for (int i=a; i>(int)(b); i--)\n#define PPC(x) __builtin_popcount(x)\n#define SZ(x) ((int)(x).size())\n#define MSB(x) (31 - __builtin_clz(x))\n#define pb push_back\n#define ALL(x) (x).begin(), (x).end()\n#define ithBit(m, i) ((m) >> (i) & 1)\n#define ft first\n#define sd second\n#ifdef DEBUG\n#include \"debug.h\"\n#else\n#define dbg(...) 0\n#endif\nusing namespace std;\n \nconst int maxN = 1 << 19, maxS = 513, mod = 998244353;\nconst long long INF = 1000000000000000000ll;\n\ntemplate <class T1, class T2> inline void addMod(T1& a, T2 b)\t{   a = (a + b) % mod;  }\ntemplate <class T1, class T2> inline void multMod(T1& a, T2 b)\t{   a = a * b % mod;    }\n\nlong long pows[maxN], T[3][maxS];\nvector <int> graph[3][maxN];\nint mex[maxN], vis[maxN];\n \nint main()\n{\n\tint n;\n\tscanf (\"%d\", &n);\n\tpows[1] = INF % mod;\n\tFOR(i, 2, n+1)\n\t\tpows[i] = pows[i-1] * pows[1] % mod;\n\tFOR(s, 0, 3)\n\t{\n\t\tvector <int>* G = graph[s];\n\t\tint m;\n\t\tscanf (\"%d\", &m);\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf (\"%d%d\", &a, &b);\n\t\t\tif (a > b)\n\t\t\t\tswap(a, b);\n\t\t\tG[a].pb(b);\n\t\t}\n\t\t\n\t\tFORD(v, n, 0)\n\t\t{\n\t\t\tfor (int u : G[v])\n\t\t\t\tvis[mex[u]] = v;\n\t\t\tfor (mex[v] = 0; vis[mex[v]] == v; mex[v]++) ;\n\t\t\taddMod(T[s][mex[v]], pows[v]);\n\t\t}\n\t\t\n\t\tfill(vis, vis+n+1, 0);\n\t}\n\t\n\tlong long res = 0;\n\tFOR(a, 0, maxS) FOR(b, 0, maxS) FOR(c, 0, maxS) if ((a^b^c) == 0)\n\t{\n\t\tlong long tak = T[0][a];\n\t\tmultMod(tak, T[1][b]);\n\t\tmultMod(tak, T[2][c]);\n\t\taddMod(res, tak);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nconst int MOD = 998244353;\nvector<int> powers;\n\nint n;\nstruct Graph {\n\tvector<vector<int>> edges;\n\tvector<int> nimber;\n\tvector<int> groups;\n\t// vector<int> good, worse;\n\t// vector<bool> forbidden;\n\t// void forbid_nei(int a) {\n\t\t// for(int b : edges[a]) {\n\t\t\t// forbidden[b] = true;\n\t\t// }\n\t\t// edges[a].clear();\n\t// }\n\tvoid read() {\n\t\tedges.resize(n + 1);\n\t\tnimber.resize(n + 1);\n\t\t// forbidden.resize(n + 1);\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tedges[a].push_back(b);\n\t\t\tedges[b].push_back(a);\n\t\t}\n\t\tfor(int a = n; a >= 1; --a) {\n\t\t\tset<int> nei;\n\t\t\tfor(int b : edges[a]) {\n\t\t\t\tif(b > a) {\n\t\t\t\t\tnei.insert(nimber[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int value = 0; true; ++value) {\n\t\t\t\tif(!nei.count(value)) {\n\t\t\t\t\tnimber[a] = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint i = nimber[a];\n\t\t\twhile((int) groups.size() <= i) {\n\t\t\t\tgroups.push_back(0);\n\t\t\t}\n\t\t\tgroups[i] += powers[a];\n\t\t\tgroups[i] %= MOD;\n\t\t}\n\t\t// debug() << imie(good) imie(worse);\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tpowers.resize(n + 1);\n\tpowers[0] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tpowers[i] = (long long) 1'000'000'000'000'000'000 % MOD * powers[i-1] % MOD;\n\t}\n\t\n\tGraph graphs[3];\n\tfor(int i : {0, 1, 2}) {\n\t\tgraphs[i].read();\n\t}\n\tint hope = 0;\n\t// int hope = graphs[0].good.size() * graphs[1].good.size() * graphs[2].good.size();\n\t// for(int i : {0, 1, 2}) {\n\t\t// hope += graphs[i].good.size() * graphs[(i+1)%3].worse.size() * graphs[(i+2)%3].worse.size();\n\t// }\n\tset<vector<int>> forbidden;\n\tint count = 0;\n\tfor(int a = 0; a < (int) graphs[0].groups.size(); ++a) {\n\t\tfor(int b = 0; b < (int) graphs[1].groups.size(); ++b) {\n\t\t\tint c = a ^ b;\n\t\t\tif(c < (int) graphs[2].groups.size()) {\n\t\t\t// for(int c = 0; c < (int) graphs[2].groups.size(); ++c) {\n\t\t\t\tif((a ^ b ^ c) == 0) {\n\t\t\t\t\thope += (long long) graphs[0].groups[a] * graphs[1].groups[b] % MOD * graphs[2].groups[c] % MOD;\n\t\t\t\t\thope %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", hope);\n\treturn 0;\n\t\n\t\n\t\n\t\n\t\n\t\n\tfor(int s = 3 * n; s >= 0; --s) {\n\t\tfor(int a = 1; a <= n; ++a) {\n\t\t\tfor(int b = 1; b <= n; ++b) {\n\t\t\t\tfor(int c = 1; c <= n; ++c) {\n\t\t\t\t\tif(a + b + c == s) {\n\t\t\t\t\t\tvector<int> triple{a, b, c};\n\t\t\t\t\t\tif(!forbidden.count(triple)) {\n\t\t\t\t\t\t\tif(a <= b && b <= c) { \n\t\t\t\t\t\t\t\tfor(int x : triple) {\n\t\t\t\t\t\t\t\t\tcerr << n-x;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcerr << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint my_xor = 0;\n\t\t\t\t\t\t\tfor(int i : {0, 1, 2}) {\n\t\t\t\t\t\t\t\tmy_xor ^= graphs[i].nimber[triple[i]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(my_xor == 0) {\n\t\t\t\t\t\t\t\thope++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t++count;\n\t\t\t\t\t\t\t// debug() << imie(triple);\n\t\t\t\t\t\t\tfor(int a2 : graphs[0].edges[a]) {\n\t\t\t\t\t\t\t\tforbidden.insert({a2, b, c});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int b2 : graphs[1].edges[b]) {\n\t\t\t\t\t\t\t\tforbidden.insert({a, b2, c});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor(int c2 : graphs[2].edges[c]) {\n\t\t\t\t\t\t\t\tforbidden.insert({a, b, c2});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// bool ok = true;\n\t\t\t\t\t\t// for(int i : {0, 1, 2}) {\n\t\t\t\t\t\t\t// if(graphs[i].forbidden[triple[i]]) {\n\t\t\t\t\t\t\t\t// ok = false;\n\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// if(!ok) {\n\t\t\t\t\t\t\t// continue;\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// debug() << imie(a) imie(b) imie(c);\n\t\t\t\t\t\t// for(int i : {0, 1, 2}) {\n\t\t\t\t\t\t\t// graphs[i].forbid_nei(triple[i]);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdebug() << imie(count);\n\tdebug() << imie(hope);\n\tassert(count == hope);\n}\n\n// 2 -- 5 in the first graph\n\n// (2, 8, 10) -- (5, 8, 10)\n// (2, 8, 10) !- (2, 4, 8)\n\n\n// N = 5\n\n\n// (2, 5, 5)\n// (5, 5, 5)\n\n\n// (3, 8, 6) <- when should we take this?  there is edge 3--7\n// (7, 8, 6) <- not taken\n// (3, 10, 6) <- not taken\n// (7, 10, 6) <- taken\n\n\n// (7, 8, 9) - TAKE\n// (9, 8, 9) - NO\n// (4, 9, 9) - NO\n// (7, 9, 9) - NO\n// (9, 9, 9) - TAKE\n\n\n// (8, 8, 8) - NO\n// (9, 8, 8) - TAKE\n// (8, 9, 8) - TAKE\n// (8, 8, 9) - TAKE\n// (9, 9, 8) - NO\n// (9, 8, 9) - NO\n// (8, 9, 9) - NO\n// (9, 9, 9) - TAKE\n\n\n// 888 - TAKE ? \n// 898 - NO\n// 988 - NO\n// 998 - TAKE\n// 999 - TAKE\n\n\n\n// 998 - TAKE\n// 999 - TAKE\n\n// in a graph, I have merged group 987, then there is 6\n\n// 9875\n// 6      5--6\n\n\n\n// ab9   NOT\n// ab5   if 5--9\n\n\n// 987\n// 6\n// 5\n\n\n// 36 + 6 + 8 + 3 = 53\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\n//const int MOD = (int) 1e9 + 7;\nconst int MOD = 119 << 23 | 1;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-6;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\ninline int mrand(int k) {return abs((int) mt()) % k;}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nvoid XORFFT(vi& a, int n, int p, int invert) {\n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j += i << 1) {\n            for (int k = 0; k < i; k++) {\n                int u = a[j + k], v = a[i + j + k];\n                a[j + k] = u + v;\n                if (a[j + k] >= p) a[j + k] -= p;\n                a[i + j + k] = u - v;\n                if (a[i + j + k] < 0) a[i + j + k] += p;\n            }\n        }\n    }\n    if (invert) {\n        long long inv = fpow(n, p - 2, p);\n        for (int i = 0; i < n; i++) a[i] = a[i] * inv % p;\n    }\n}\n\nvoid XOR(vi& a, vi& b, int p) {\n    XORFFT(a, sz(a), p, 0);\n    XORFFT(b, sz(b), p, 0);\n    for (int i = 0; i < sz(a); i++) a[i] = (long long) a[i] * b[i] % p;\n    XORFFT(a, sz(a), p, 1);\n}\n\nvoid chemthan() {\n    int n; cin >> n;\n    auto calc = [&] () {\n        int m; cin >> m;\n        vector<vi> adj(n);\n        FOR(i, 0, m) {\n            int u, v; cin >> u >> v; u--, v--;\n            if (v < u) swap(u, v);\n            adj[u].pb(v);\n        }\n        vi f(n);\n        vi a(n, 0);\n        vi b(n, 0);\n        int K = isqrt(n) + 1;\n        vi c(K, 0);\n        FORd(u, n, 0) {\n            for (int v : adj[u]) {\n                if (!a[f[v]]) {\n                    b[f[v]] = 1;\n                    c[f[v] / K] += 1;\n                }\n                a[f[v]]++;\n            }\n            FOR(i, 0, K) if (c[i] < K) {\n                for (int j = i * K; ; j++) {\n                    if (!b[j]) {\n                        f[u] = j;\n                        break;\n                    }\n                }\n                break;\n            }\n            for (int v : adj[u]) {\n                if (a[f[v]] == 1) {\n                    b[f[v]] = 0;\n                    c[f[v] / K] -= 1;\n                }\n                a[f[v]]--;\n            }\n        }\n        vi res(1 << 17);\n        FOR(i, 0, n) {\n            addmod(res[f[i]], fpow(10, 18 * (i + 1)));\n        }\n        return res;\n    };\n    auto g1 = calc();\n    auto g2 = calc();\n    auto g3 = calc();\n    XOR(g1, g2, MOD);\n    XOR(g1, g3, MOD);\n    cout << g1[0] << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    const auto& modpow = [](unsigned long n, unsigned long b = 1, unsigned long a = 716070898) -> unsigned long {\n        unsigned long r{b % MOD};\n        while(n){\n            if(n & 1)(r *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return r;\n    };\n    unsigned long N;\n    cin >> N;\n    vector<unsigned long> indpX, indpY, indpZ;\n    for(unsigned long _{0}; _ < 3; ++_){\n        swap(indpX, indpY);\n        swap(indpZ, indpY);\n        unsigned long M;\n        cin >> M;\n        vector<vector<unsigned long>> edge(N);\n        for(unsigned long i{0}, a, b; i < M; ++i){\n            cin >> a >> b;\n            if(a < b)swap(a, b);\n            edge[--a].push_back(--b);\n        }\n        vector<unsigned long> id(N, N - 1);\n        for(unsigned long i{N}; i--; )for(const auto& j : edge[i])id[j] -= id[j] == id[i];\n        map<unsigned long, pair<unsigned long, unsigned long>> mp;\n        for(unsigned long i{0}; i < N; ++i){\n            mp[id[i]].first = i + 1;\n            (mp[id[i]].second += modpow(i + 1)) %= MOD;\n        }\n        vector<pair<unsigned long, unsigned long>> Z;\n        for(const auto& i : mp)Z.emplace_back(i.second);\n        sort(Z.begin(), Z.end(), greater<>());\n        for(const auto& i : Z)indpZ.emplace_back(i.second);\n    }\n    if(indpX.size() > indpZ.size())swap(indpX, indpZ);\n    if(indpY.size() > indpZ.size())swap(indpY, indpZ);\n    if(indpX.size() > indpY.size())swap(indpX, indpY);\n    indpY.resize(indpX.size());\n    assert(indpX.size() < 500);\n    unsigned long MX{indpX.size()}, MY{indpY.size()};\n    string al{string(MX, '1')};\n    vector<bitset<500>> usedY(MY, bitset<500>(al));\n    unsigned long ans{0};\n    for(const auto& i : indpZ){\n        bitset<500> used{al};\n        unsigned long tmp{0};\n        for(unsigned long j{0}; j < MY; ++j){\n            unsigned long k{(usedY[j] & used)._Find_first()};\n            if(k < MX){\n                used[k] = false;\n                usedY[j][k] = false;\n                tmp += indpY[j] * indpX[k] % MOD;\n            }\n        }\n        tmp %= MOD;\n        ans += i * tmp % MOD;\n    }\n    cout << ans % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n \n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,tune=native\")\n \nusing namespace __gnu_pbds;\nusing namespace std;\n     \n#define mp make_pair\n#define sz(x) (int)((x).size())\n#define all(x) (x).begin(),(x).end()\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define eb emplace_back\n \ntypedef pair< int, int > pii;\ntypedef pair< long long, long long > pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector< int > vi;\ntypedef vector< vi > vvi;\ntypedef vector< ll > vll;\ntypedef vector< vll > vvll;\ntypedef vector< pii > vpii;\ntypedef vector< vpii > vvpii;\ntypedef vector< pll > vpll;\ntypedef long double ld;\ntypedef vector< ld > vld;\ntypedef unsigned int uint;\n \nconst ll MOD2 = 1e9 + 7;\nconst int MOD = 1e9 + 7;\n \nconst ull infull = numeric_limits<unsigned long long>::max();\n \nvoid fix(int &x, ll MOD) {\n    x = (x % MOD);\n    if(x < 0) x += MOD;\n    return;\n}\n \nll lgput(ll a, ll b, ll MOD) {\n    ll ret = 1;\n    a %= MOD;\n    while(b) {\n        if(b&1) ret = ret*a % MOD;\n        a = a*a % MOD;\n        b >>= 1;\n    }\n \n    return ret;\n}\n \nll inv(ll a, ll MOD) {\n    return lgput(a, MOD-2, MOD);\n}\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n\nusing Mint = ModInt<998244353>;\n\nconst Mint base = Mint(1e18);\n\nint main() { \n    #ifdef BLAT\n        freopen(\"stdin\", \"r\", stdin);\n        freopen(\"stderr\", \"w\", stderr);\n    #endif\n \n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(12);\n    srand(time(NULL));\n        \n    int n;\n    cin >> n;\n\n    vector< vector< Mint > > ans(3);\n    for(int i = 0; i < 3; ++i) {\n        int m;\n        cin >> m;\n        vvi gr(n);\n\n        for(int j = 0; j < m; ++ j) {\n            int a, b;\n            cin >> a >> b;\n\n            --a, --b;\n            if(a > b) swap(a, b);\n\n            gr[a].emplace_back(b);\n        }\n\n        vector< int > grundy(n, 0);\n        vector< int > used(n, -1);\n\n        for(int j = n-1; j >= 0; --j) {\n            for(auto &x : gr[j]) {\n                used[grundy[x]] = j;\n            }\n\n            while(used[grundy[j]] == j) ++grundy[j];\n            while(ans[i].size() <= grundy[j]) ans[i].emplace_back(0);\n\n            ans[i][grundy[j]] += base.pow(j + 1);\n        }\n    }\n\n    Mint ret = 0;\n    for(int i = 0; i < ans[0].size(); ++i) {\n        for(int j = 0; j < ans[1].size(); ++j) {\n            int k = i ^ j;\n            if(k < ans[2].size()) ret += ans[0][i]*ans[1][j]*ans[2][k];\n        }\n    }\n\n    cout << ret << '\\n';\n    return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 200003, M = 500, mod = 998244353, X = (LL) 1e18 % mod;\ntemplate<typename T>\ninline void read(T &x){\n    int ch = getchar(); x = 0;\n    for(;ch < '0' || ch > '9';ch = getchar());\n    for(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';\n}\ntemplate<typename T>\ninline bool chkmax(T &a, const T &b){if(a < b) return a = b, 1; return 0;}\ninline void qmo(int &x){x += (x >> 31) & mod;}\nint n, m, r, f[3][M], sg[N], po[N], vis[N], ans;\nvector<int> E[N];\nint main(){\n    read(n); po[0] = 1;\n    for(Rint i = 1;i <= n;++ i) po[i] = (LL) po[i - 1] * X % mod;\n    for(Rint t = 0, x, y;t < 3;++ t){\n        read(m);\n        for(Rint i = 1;i <= n;++ i) E[i].clear();\n        while(m --){\n            read(x); read(y);\n            if(x > y) swap(x, y);\n            E[x].push_back(y);\n        }\n        for(Rint i = n;i;-- i){\n            int id = t * n + i;\n            for(Rint j : E[i]) vis[sg[j]] = id;\n            for(sg[i] = 0;vis[sg[i]] == id;++ sg[i]);\n            qmo(f[t][sg[i]] += po[i] - mod); chkmax(r, sg[i]);\n        }\n    }\n    for(Rint i = 0;i <= r;++ i)\n        for(Rint j = 0;j <= r;++ j)\n            qmo(ans += (LL) f[0][i] * f[1][j] % mod * f[2][i ^ j] % mod - mod);\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define re register\n#define LL long long\n#define MOD 998244353\n#define MAXN 300005\nusing namespace std;\nLL n,ans,bs[3*MAXN];\nLL rd(){\n\tLL x=0,tp=1;char c;c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')tp=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=(x*10+c-'0');c=getchar();}\n\treturn x*tp;\n}\nstruct Graph{\n\tLL m,sg[MAXN],f[MAXN];\n\tvector<int>e[MAXN];\n\tvoid work(){\n\t\tint x,y;\n\t\tm=rd();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tx=rd(),y=rd();\n\t\t\tif(x>y)swap(x,y);\n\t\t\te[x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tset<int>s;\n\t\t\tint sz=e[i].size();\n\t\t\tfor(int j=0;j<sz;j++)s.insert(sg[e[i][j]]);\n\t\t\twhile(s.count(sg[i]))sg[i]++;\n\t\t\t(f[sg[i]]+=bs[i])%=MOD;\n\t\t\t// printf(\"sg[%d]=%d\\n\",i,sg[i]);\n\t\t}\n\t}\n}g[3];\nint main(){\n\t// freopen(\"testdata.in\",\"r\",stdin);\n\t// freopen(\"shit.out\",\"w\",stdout);\n\tn=rd();int Sqr=sqrt(n);\n\tbs[0]=1;LL fuck=1000000000000000000ll%MOD;\n\tfor(int i=1;i<=3*n;i++)bs[i]=bs[i-1]*fuck%MOD;\n\tfor(int i=0;i<3;i++)g[i].work();\n\tfor(int i=0;i<=Sqr;i++)\n\t\tfor(int j=0;j<=Sqr;j++)\n\t\t\t(ans+=g[0].f[i]*g[1].f[j]%MOD*g[2].f[i^j]%MOD)%=MOD;\n\tprintf(\"%lld\\n\",ans);\n\t// printf(\"%.2lf\\n\",(double)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n\n#ifdef LOCAL\n#include \"debug.h\"\n#endif\n\nconst int N = int(1e5) + 10;\nconst int SQRTN = 500;\nconst int MOD = 998244353;\n\nint n;\nint m[3];\nvector<int> adj[3][N];\nint g[3][N];\nint ans_g[4][SQRTN];\nint mod[N];\n\nint main() {\n\t#ifdef LOCAL\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\t#endif\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 3; i++) {\n\t\tscanf(\"%d\", &m[i]);\n\t\tfor (int j = 0; j < m[i]; j++) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tadj[i][u].push_back(v);\n\t\t\tadj[i][v].push_back(u);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = n; j >= 1; j--) {\n\t\t\tvector<int> gs;\n\t\t\tfor (int to : adj[i][j]) if (to > j) gs.push_back(g[i][to]);\n\t\t\tsort(gs.begin(), gs.end());\n\t\t\tgs.resize(unique(gs.begin(), gs.end()) - gs.begin());\n\t\t\tg[i][j] = 0;\n\t\t\twhile (g[i][j] < gs.size() && gs[g[i][j]] == g[i][j]) g[i][j]++;\n\t\t}\n\t}\n\n\tint p = 1;\n\tfor (int i = 0; i < 18; i++) p = p * 10LL % MOD;\n\tmod[0] = 1;\n\tfor (int i = 1; i < N; i++) mod[i] = mod[i - 1] * 1LL * p % MOD;\n\n\tans_g[3][0] = 1;\n\tfor (int i = 2; i >= 0; i--) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tfor (int _g = 0; _g < SQRTN; _g++) {\n\t\t\t\tint ig = _g ^ g[i][j];\n\t\t\t\tif (ig < SQRTN) {\n\t\t\t\t\t(ans_g[i][_g] += mod[j] * 1LL * ans_g[i + 1][ig] % MOD) %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans_g[0][0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\tfor(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n  using value_type = ::std::uint_fast64_t;\n  value_type n;\npublic:\n  ModInt() : n(0) {}\n  ModInt(value_type n_) : n(n_ % mod) {}\n  ModInt(const ModInt& m) : n(m.n) {}\n\n  template<typename T>\n  explicit operator T() const { return static_cast<T>(n); }\n  value_type get() const { return n; }\n\n  friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n    return os << a.n;\n  }\n\n  friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n    value_type x;\n    is >> x;\n    a = ModInt<mod>(x);\n    return is;\n  }\n\n  bool operator==(const ModInt& m) const { return n == m.n; }\n  bool operator!=(const ModInt& m) const { return n != m.n; }\n  ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n  ModInt pow(value_type b) const{\n    ModInt ans = 1, m = ModInt(*this);\n    while(b){\n      if(b & 1) ans *= m;\n      m *= m;\n      b >>= 1;\n    }\n    return ans;\n  }\n\n  ModInt inv() const { return (*this).pow(mod-2); }\n  ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n  ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n  ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n  ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n  ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n  ModInt& operator++(){ n += 1; return *this; }\n  ModInt& operator--(){ n -= 1; return *this; }\n  ModInt operator++(int){\n    ModInt old(n);\n    n += 1;\n    return old;\n  }\n  ModInt operator--(int){\n    ModInt old(n);\n    n -= 1;\n    return old;\n  }\n  ModInt operator-() const { return ModInt(mod-n); }\n};\n\nconstexpr int64 mod = 998244353;\nusing Mint = ModInt<mod>;\n\nint64 N, M[3];\nvector<vector<int64>> G[3];\nvector<int64> gr[3];\n\nvoid calc(const vector<vector<int64>>& G, vector<int64>& gr) {\n  for (int64 i = N-1; i >= 0; i--) {\n    set<int64> st;\n    for (auto &u : G[i]) {\n      if (gr[u] != -1) st.insert(gr[u]);\n    }\n    int64 x = 0;\n    while (st.size() && *(st.begin()) == x) {\n      x++;\n      st.erase(st.begin());\n    }\n    gr[i] = x;\n  }\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> N;\n  vector<Mint> grsum[3];\n  REP(i, 3) {\n    cin >> M[i];\n    G[i].resize(N);\n    gr[i].resize(N, -1);\n    REP(j, M[i]) {\n      int64 a, b;\n      cin >> a >> b; a--; b--;\n      G[i][a].push_back(b);\n      G[i][b].push_back(a);\n    }\n    calc(G[i], gr[i]);\n    grsum[i].resize(sqrt(M[i])+1, 0);\n    REP(j, N) {\n      grsum[i][gr[i][j]] += Mint(INF_LL).pow(j+1);\n    }\n  }\n  vector<Mint> sum(M[2]+1, 0);\n  REP(i, grsum[0].size()) {\n    REP(j, grsum[1].size()) {\n      if ((i^j) <= M[2])\n        sum[i^j] += grsum[0][i] * grsum[1][j];\n    }\n  }\n  Mint res = 0;\n  REP(i, grsum[2].size()) {\n    res += grsum[2][i] * sum[i];\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\ntemplate <int32_t P>\nstruct ModInt_t {\n  int32_t value;\n\n  static_assert(P < (1 << 30) - 1, \"2xP must fit into 32-bit signed integer\");\n\n  ModInt_t() : value{0} {};\n\n  explicit ModInt_t(int32_t v) : value(v) {\n    if (value >= P || value <= -P) value %= P;\n    if (value < 0) value += P;\n  };\n\n  explicit operator bool() const { return value != 0; }\n  explicit operator int32_t() const { return value; }\n\n  ModInt_t& operator+=(const ModInt_t& other) {\n    value += other.value;\n    if (value >= P) value -= P;\n    return *this;\n  }\n\n  ModInt_t& operator-=(const ModInt_t& other) {\n    value -= other.value;\n    if (value < 0) value += P;\n    return *this;\n  }\n\n  ModInt_t& operator*=(const ModInt_t& other) {\n    int64_t result = static_cast<int64_t>(value) * other.value;\n    value = static_cast<int32_t>(result % P);\n    return *this;\n  }\n\n  static ModInt_t inverse(ModInt_t x) { return ModInt_t{inverse(x.value)}; }\n\n private:\n  static int32_t inverse(int32_t a) {\n    int32_t b = P, x = 1, y = 0;\n    while (b != 0) {\n      auto k = a / b;\n      a -= k * b;\n      std::swap(a, b);\n      x -= k * y;\n      std::swap(x, y);\n    }\n    assert(a == 1);\n    if (x < 0) x += P;\n    return x;\n  }\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator+(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res += b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator-(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res -= b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator*(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res *= b;\n};\n\ntemplate <int32_t P>\nbool operator==(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  return a.value == b.value;\n};\n\ntemplate <int32_t P>\nstd::ostream& operator<<(std::ostream& os, const ModInt_t<P>& a) {\n  os << a.value;\n  return os;\n}\n\ntemplate <typename T>\nstruct MulMonoid {\n  using value_type = T;\n  constexpr static T identity() { return T{1}; }\n  constexpr static T op(const T& a, const T& b) { return a * b; }\n};\n\ntemplate <typename T, typename U, typename Monoid = MulMonoid<T>>\nT power(T a, U n) {\n  T r{Monoid::identity()};\n  while (n > 0) {\n    if (n % 2) r = Monoid::op(r, a);\n    a = Monoid::op(a, a);\n    n /= 2;\n  }\n  return r;\n}\n\nusing ModInt = ModInt_t<998244353>;\n\nconst int L = 500;\n\nvector<ModInt> read(int N) {\n  int M;\n  cin >> M;\n  vector<vector<int>> E(N);\n  for (int i = 0; i < M; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    E[a].push_back(b);\n    E[b].push_back(a);\n  }\n\n  vector<int> g(N);\n\n  for (int x = N - 1; x >= 0; --x) {\n    set<int> S;\n    for (int y : E[x])\n      if (y > x) S.insert(g[y]);\n    for (g[x] = 0; S.count(g[x]); g[x]++)\n      ;\n  }\n\n  vector<ModInt> ret(L);\n  for (int i = 0; i < N; ++i) {\n    ModInt w = power(ModInt{10}, 18 * (i + 1));\n    ret[g[i]] += w;\n  }\n  return ret;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n\n  auto A = read(N);\n  auto B = read(N);\n  auto C = read(N);\n\n  ModInt ret{0};\n  for (int x = 0; x < L; ++x) {\n    for (int y = 0; y < L; ++y) {\n      int z = x ^ y;\n      ret += A[x] * B[y] * C[z];\n    }\n  }\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2\")\n#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst ld eps=1e-7;\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod = 998244353;\nconst int MAXN = 100010, LOG=20;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll sum[3][MAXN], tav[MAXN];\nint mark[MAXN];\nint g[MAXN];\nvector<int> G[MAXN];\n\nvoid Solve(int id){\n\tmemset(mark, 0, sizeof(mark));\n\tmemset(g, 0, sizeof(g));\n\tmemset(G, 0, sizeof(G));\n\tcin>>m;\n\twhile (m--){\n\t\tcin>>u>>v;\n\t\tif (u>v) swap(u, v);\n\t\tG[u].pb(v);\n\t}\n\t\n\tfor (int i=n-1; i; i--){\n\t\tfor (int v:G[i]) mark[g[v]]=i;\n\t\twhile (mark[g[i]]==i) g[i]++;\n\t}\n\tfor (int i=1; i<=n; i++) sum[id][g[i]]=(sum[id][g[i]] + tav[i])%mod;\n\t\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\ttav[0]=1;\n\ttav[1]=1000000000000000000ll%mod;\n\tfor (int i=2; i<MAXN; i++) tav[i]=tav[i-1]*tav[1]%mod;\n\tcin>>n;\n\tSolve(0);\n\tSolve(1);\n\tSolve(2);\n\tfor (int i=0; sum[0][i]; i++)\n\t\tfor (int j=0; sum[1][j]; j++)\n\t\t\tans=(ans + sum[0][i]*sum[1][j]%mod*sum[2][i^j])%mod;\n\t\n\tcout<<ans<<'\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nlong long p[100010];\n\nvoid init() {\n    p[0] = p[1] = 1;\n    for (int i = 0; i < 18; i++) {\n        p[1] = p[1] * 10 % mod;\n    }\n    for (int i = 1; i <= 100000; i++) {\n        p[i+1] = p[i] * p[1] % mod;\n    }\n}\n\nvoid calc(int n, vector<long long> &v) {\n    int m; cin >> m;\n    vector<int> e[n+1];\n    vector<int> g(n+1, -1);\n    for (int i = 0; i < m; i++) {\n        int a, b; cin >> a >> b;\n        e[a].emplace_back(b);\n        e[b].emplace_back(a);\n    }\n    for (int i = n; i > 0; i--) {\n        set<int> s;\n        for (auto &to: e[i]) {\n            s.emplace(g[to]);\n        }\n        int t = 0;\n        for (auto &x: s) {\n            if (x == -1) continue;\n            if (x != t) break;\n            t++;\n        }\n        g[i] = t;\n    }\n    for (int i = 1; i <= n; i++) {\n        v[g[i]] = (v[g[i]] + p[i]) % mod;\n    }\n}\n\nvector<long long> mul(vector<long long> &x, vector<long long> &y, int n) {\n    vector<long long> d(n+1, 0), ret(n, 0);\n    for (int i = n-1; i >= 0; i--) {\n        d[i] = x[i] * y[i] % mod;\n        if (i != n-1) d[i] = (d[i] + d[i+1]) % mod;\n    }\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        ret[i] = (d[i+1] + x[i] * y[0] % mod + sum) % mod;\n        if (i != n-1) sum += x[i] * y[i+1] % mod; sum %= mod;\n    }\n    return ret;\n}\n\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    init();\n    int n; cin >> n;\n    vector<long long> x(n, 0), y(n, 0), z(n, 0);\n    calc(n, x); calc(n, y); calc(n, z);\n    auto r = mul(x, y, n);\n    auto q = mul(r, z, n);\n    cout << q[0] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 3;\nconst int mod = 998244353;\n\nint n, m[4];\nvector <int> adj[4][maxn];\nvoid read()\n{\n    cin >> n;\n    for (int i = 1; i <= 3; i++)\n    {\n        cin >> m[i];\n        for (int j = 1; j <= m[i]; j++)\n        {\n            int a, b;\n            cin >> a >> b;\n\n            adj[i][a].push_back(b);\n            adj[i][b].push_back(a);\n        }\n    }\n}\n\nlong long add(long long a, long long b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n\n    return a;\n}\n\nlong long pow10[maxn*2];\nint gr[4][maxn];\nmap <int, long long> mp[4];\nvoid solve()\n{\n    pow10[0] = 1;\n    for (int i = 1; i <= 2 * n; i++)\n        pow10[i] = pow10[i-1] * 1000000000 % mod;\n\n    for (int i = 1; i <= 3; i++)\n    {\n        mp[i][0] = add(mp[i][0], pow10[n*2]);\n        for (int j = n-1; j >= 1; j--)\n        {\n            set <int> s;\n            for (auto k: adj[i][j])\n                if (k > j)\n                s.insert(gr[i][k]);\n\n            while (s.find(gr[i][j]) != s.end())\n                gr[i][j]++;\n\n            mp[i][gr[i][j]] = add(mp[i][gr[i][j]], pow10[j*2]);\n        }\n    }\n\n    int p = sqrt(max({m[1], m[2], m[3]})) + 10;\n    long long ans = 0;\n    for (int i = 0; i <= p; i++)\n        if (mp[1].count(i))\n        for (int j = 0; j <= p; j++)\n        if (mp[2].count(j))\n            ans = add(ans, mp[1][i] * mp[2][j] % mod * mp[3][i^j] % mod);\n\n    cout << ans << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    read();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\ntypedef long long LL;\nconst int Mod = 998244353;\nconst int MN = 100005, MS = 1 << 9;\n\ninline void Add(int &x, int y) { x -= (x += y) >= Mod ? Mod : 0; }\n\nint N, f1[MN], f2[MN], f3[MN];\nstd::vector<int> G1[MN], G2[MN], G3[MN];\n\ninline void ReadGraph(std::vector<int> *G) {\n\tint M;\n\tscanf(\"%d\", &M);\n\twhile (M--) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif (x > y) std::swap(x, y);\n\t\tG[x].push_back(y);\n\t}\n}\ninline void SolveSG(std::vector<int> *G, int *f) {\n\tstatic int buk[MN];\n\tfor (int i = N; i >= 1; --i) {\n\t\tfor (int x : G[i]) buk[f[x]] = 1;\n\t\tf[i] = 0;\n\t\twhile (buk[f[i]]) ++f[i];\n\t\tfor (int x : G[i]) buk[f[x]] = 0;\n\t}\n}\n\nint pw[MN];\nint b1[MS], b2[MS], b3[MS], Ans;\n\nint main() {\n\tscanf(\"%d\", &N);\n\tReadGraph(G1);\n\tReadGraph(G2);\n\tReadGraph(G3);\n\tSolveSG(G1, f1);\n\tSolveSG(G2, f2);\n\tSolveSG(G3, f3);\n\tpw[0] = 1;\n\tfor (int i = 1; i <= N; ++i) pw[i] = pw[i - 1] * 716070898ll % Mod;\n\tfor (int i = 1; i <= N; ++i) Add(b1[f1[i]], pw[i]);\n\tfor (int i = 1; i <= N; ++i) Add(b2[f2[i]], pw[i]);\n\tfor (int i = 1; i <= N; ++i) Add(b3[f3[i]], pw[i]);\n\tfor (int i = 0; i < MS; ++i)\n\t\tfor (int j = 0; j < MS; ++j)\n\t\t\tAns = (Ans + (LL)b1[i] * b2[j] % Mod * b3[i ^ j]) % Mod;\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n} // vjudge pink_rabbit"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,abm,mmx,popcnt,avx,avx2,tune=native\")\n           \n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n           \n//#define int long long\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pld;\n\ntemplate<typename T>\nusing kawaii_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n  \nvoid FAST_IO() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.setf(ios::fixed);\n    //cout.precision(20);\n    #ifndef _offline\n    //freopen(\"mincost.in\", \"r\", stdin);\n    //freopen(\"mincost.out\", \"w\", stdout);\n    #endif\n}\n\nconst ll mod = 998244353;\nconst ll kek = 716070898;\nconst int K = 500;\nconst int MAXN = 1e5 + 100;\nvector<int> g1[MAXN], g2[MAXN], g3[MAXN];\nint v1[MAXN], v2[MAXN], v3[MAXN];\nll s1[K], s2[K], s3[K];\nbool xy[K][K], xz[K][K], yz[K][K];\n\nll binpow(ll a, ll n) {\n    ll res = 1;\n    while (n) {\n        if (n & 1) {\n            res = (res * a) % mod;\n        }\n        a = (a * a) % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nvoid relax1(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g1[u]) {\n        bs[v1[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v1[u] = i;\n            break;\n        }\n    }\n    s1[v1[u]] += binpow(kek, u + 1);\n    if (s1[v1[u]] >= mod) {\n        s1[v1[u]] -= mod;\n    }\n}\n\nvoid relax2(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g2[u]) {\n        bs[v2[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v2[u] = i;\n            break;\n        }\n    }\n    s2[v2[u]] += binpow(kek, u + 1);\n    if (s2[v2[u]] >= mod) {\n        s2[v2[u]] -= mod;\n    }\n}\n\nvoid relax3(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g3[u]) {\n        bs[v3[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v3[u] = i;\n            break;\n        }\n    }\n    s3[v3[u]] += binpow(kek, u + 1);\n    if (s3[v3[u]] >= mod) {\n        s3[v3[u]] -= mod;\n    }\n}\n\nsigned main() {\n    FAST_IO();\n    int n;\n    cin >> n;\n    int m1;\n    cin >> m1;\n    for (int i = 0; i < m1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g1[u].push_back(v);\n    }\n    int m2;\n    cin >> m2;\n    for (int i = 0; i < m2; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g2[u].push_back(v);\n    }\n    int m3;\n    cin >> m3;\n    for (int i = 0; i < m3; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g3[u].push_back(v);\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        relax1(i);\n        relax2(i);\n        relax3(i);\n    }\n    ll ans = 0;\n    for (int i = 0; i < K; ++i) {\n        if (s1[i] == 0) {\n            continue;\n        }\n        for (int j = 0; j < K; ++j) {\n            if (s2[j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < K; ++k) {\n                if (s3[k] == 0) {\n                    continue;\n                }\n                int x = i, y = j, z = k;\n                if (xy[x][y] || xz[x][z] || yz[y][z]) {\n                    continue;\n                }\n                ll val = (s1[x] * s2[y]) % mod;\n                val = (val * s3[z]) % mod;\n                ans += val;\n                if (ans >= mod) {\n                    ans -= mod;\n                }\n                xy[x][y] = true;\n                xz[x][z] = true;\n                yz[y][z] = true;\n            }\n        }\n    }\n    cout << ans << '\\n';\n}  "
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n//THE BEST PROBLEM EVER\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 2 * (int)1e5 + 10;\nvector < int > g[maxN];\nint m;\nint gr[maxN];\nconst int mod = 998244353;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nconst int T = pw(10, 18);\nint f[3][maxN];\nconst int LOG = 17;\nvoid go(int v) {\n    for (int i = 1; i <= n; i++) {\n        g[i].clear();\n    }\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        if (a > b) swap(a, b);\n        g[a].emplace_back(b);\n    }\n    for (int i = n; i >= 1; i--) {\n        gr[i] = 0;\n        set < int > s;\n        for (int p : g[i]) {\n            s.insert(gr[p]);\n        }\n        while (s.count(gr[i])) gr[i]++;\n    }\n    for (int i = 1; i <= n; i++) {\n        f[v][gr[i]] = sum(f[v][gr[i]], pw(T, i));\n    }\n    for (int bit = 0; bit < LOG; bit++) {\n        for (int i = 0; i < (1 << LOG); i++) {\n            if (i & (1 << bit)) {\n                int a = f[v][i ^ (1 << bit)];\n                int b = f[v][i];\n                f[v][i ^ (1 << bit)] = sum(a, b);\n                f[v][i] = sub(a, b);\n            }\n        }\n    }\n}\nint tot[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 0; i < 3; i++) {\n        go(i);\n    }\n    for (int i = 0; i < (1 << LOG); i++) {\n        tot[i] = 1;\n        for (int j = 0; j < 3; j++) {\n            tot[i] = mult(tot[i], f[j][i]);\n        }\n    }\n    for (int bit = 0; bit < LOG; bit++) {\n        for (int i = 0; i < (1 << LOG); i++) {\n            if (i & (1 << bit)) {\n                int a = tot[i ^ (1 << bit)];\n                int b = tot[i];\n                tot[i ^ (1 << bit)] = sum(a, b);\n                tot[i] = sub(a, b);\n            }\n        }\n    }\n    cout << mult(tot[0], pw((mod + 1) / 2, LOG));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst int MOD=998244353;\n#define SZ 666666\nint n;\nstruct G\n{\nvector<int> v[SZ];\nint sg[SZ];\nbool b[SZ];\nvoid dfs(int x)\n{\n\tif(b[x]) return;\n\tb[x]=1;\n\tset<int> sp;\n\tfor(auto bb:v[x])\n\t{\n\t\tdfs(bb);\n\t\tsp.insert(sg[bb]);\n\t}\n\tsg[x]=0;\n\twhile(sp.count(sg[x]))\n\t\t++sg[x];\n}\nvoid ip()\n{\n\tint m;\n\tscanf(\"%d\",&m);\n\twhile(m--)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif(a>b) swap(a,b);\n\t\tv[a].pb(b);\n\t}\n\tfor(int i=n;i>=1;--i) dfs(i);\n}\n}T[3];\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nmap<int,int> c[3];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tll x[2]={1,0};\n\tfor(int i=0;i<3;++i)\n\t{\n\t\tT[i].ip();\n\t\tfor(int j=1;j<=n;++j) (c[i][T[i].sg[j]]+=qp(1e18,j))%=MOD;\n\t}\n\tll ans=0;\n\tfor(auto i_:c[0])\n\t\tfor(auto j_:c[1])\n\t\t{\n\t\t\tint i=i_.fi,j=j_.fi;\n\t\t\tans+=c[0][i]*(ll)c[1][j]%MOD*c[2][i^j]%MOD;\n\t\t}\n\tcout<<(ans%MOD+MOD)%MOD<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nmt19937 mt(736);\n\nconst int mod = 998244353;\n\n\nint powmod10(int n)\n{\n\tstatic vector<int> dp = {1};\n\n\twhile (n >= dp.size())\n\t\tdp.push_back((10ll * dp.back()) % mod);\n\n\treturn dp[n];\n}\n\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint n;\n\n\tcin >> n;\n\n\tarray<vector<vector<int>>, 3> xyz;\n\n\tfor (auto &gr : xyz)\n\t{\n\t\tgr.resize(n);\n\n\t\tint m;\n\n\t\tcin >> m;\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\n\t\t\tcin >> a >> b;\n\t\t\ta--;\n\t\t\tb--;\n\n\t\t\tgr[a].push_back(b);\n\t\t\tgr[b].push_back(a);\n\t\t}\n\t}\n\n\tarray<vector<int>, 3> mex;\n\n\tarray<ll, 3> wm{}, bm{};\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tmex[i].resize(n, -1);\n\n\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t{\n\t\t\tunordered_set<int> neigh;\n\n\t\t\tfor (auto it : xyz[i][j])\n\t\t\t\tneigh.insert(mex[i][it]);\n\n\t\t\tfor (mex[i][j] = 0; neigh.count(mex[i][j]); mex[i][j]++);\n\t\t}\n\t}\n\n\tarray<vector<ll>, 3> grundy;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tgrundy[i].resize(*max_element(mex[i].begin(), mex[i].end()) + 1);\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tgrundy[i][mex[i][j]] += powmod10(18 * (j + 1));\n\n\t\tfor (auto &it : grundy[i])\n\t\t\tit %= mod;\n\t}\n\n\tll ans = 0;\n\n\tfor (int x = 0; x < grundy[0].size(); x++)\n\t\tfor (int y = 0; y < grundy[1].size(); y++)\n\t\t{\n\t\t\tauto z = x ^y;\n\n\t\t\tif (z < grundy[2].size())\n\t\t\t\tans += grundy[0][x] * grundy[1][y] % mod * grundy[2][z] % mod;\n\t\t}\n\n\tcout << ans % mod << endl;\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcout << fixed;\n\n#ifdef LOCAL\n\tauto st = clock();\n\n\tifstream fin(\"../input.txt\");\n\n\tsolve(fin);\n\n\tcout << \"clock: \" << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tsolve();\n#endif\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\n#include<vector>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nvector<int>p[100010];\nconst int mod=998244353;\ninline int ad(int x){return x>=mod?x-mod:x;}\nint pw[100010],sum[3][100010],sg[100010],mx[3];\nbool v[100010];\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    pw[1]=1;\n    for(int i=1;i<=18;i++)pw[1]=1LL*pw[1]*10%mod;\n   \tint n=read(),ans=0;\n   \tfor(int i=2;i<=n;i++)pw[i]=1LL*pw[i-1]*pw[1]%mod;\n\tfor(int T=0;T<3;T++)\n\t{\n\t\tint m=read();\n\t\tfor(int i=1;i<=n;i++)p[i].clear(),sg[i]=0;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x=read(),y=read();if(x>y)swap(x,y);\n\t\t\tp[x].push_back(y);\n\t\t}sum[T][0]=ad(sum[T][0]+pw[n]);\n\t\tfor(int i=n-1;i>=1;i--)\n\t\t{\n\t\t\tint now=0;\n\t\t\tfor(int j=0;j<p[i].size();j++)v[sg[p[i][j]]]=true;\n\t\t\twhile(v[now]==true)now++;mx[T]=max(mx[T],now),sg[i]=now;sum[T][now]=ad(sum[T][now]+pw[i]);\n\t\t\tfor(int j=0;j<p[i].size();j++)v[sg[p[i][j]]]=false;\n\t\t}\n\t}\n\tfor(int i=0;i<=mx[0];i++)\n\t{\n\t\tfor(int j=0;j<=mx[1];j++)ans=ad(ans+1LL*sum[0][i]*sum[1][j]%mod*sum[2][i^j]%mod);\n\t}pr2(ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int BBB = 1e9;\nconst int P = 998244353;\nconst int B = BBB * BBB % P;\nconst int MOD = P;\nconst int N = 1e6 + 6;\nint ppow[N];\nvoid SelfMod(int& a) {\n  while (a >= MOD) {\n    a -= MOD;\n  }\n}\nvoid Dziel(int& a) {\n  if (a % 2 == 0) {\n    a /= 2;\n  } else {\n    a = (a + MOD) / 2;\n  }\n}\nvoid transform(int x, int y, int* a)\n{\n  if ( x == y - 1) {\n    return;\n  }\n  int l2 = ( y - x ) / 2;\n  int z = x + l2;\n  transform(x, z, a);\n  transform(z, y, a);\n  for (int i=x; i<z; i++) {\n    int x1 = a[i];\n    int x2 = a[i+l2];\n    a[i] = (x1 - x2 + MOD);\n    a[i+l2] = (x1 + x2);\n    SelfMod(a[i]);\n    SelfMod(a[i + l2]);\n  }\n}\n// Reverses the transform in\n// the interval [x, y) in a.\nvoid untransform(int x, int y, int* a)\n{\n  if ( x == y - 1) {\n    return;\n  }\n  int l2 = ( y - x ) / 2;\n  int z = x + l2;\n  for (int i=x; i<z; i++) {\n    long long y1 = a[i];\n    long long y2 = a[i+l2];\n    // x1 - x2 = y1\n    // x1 + x2 = y2\n    // 2 * x1  = y1 + y2\n    // 2 * x2  = y2 - y1\n    \n    // In order to solve those equations, we need to divide by 2\n    // But we are performing operations modulo 1000000007\n    // that needs us to find the modular multiplicative inverse of 2.\n    // That is saved in the INV2 variable.\n    \n    a[i] = (y1 + y2);\n    a[i+l2] = (y2 - y1 + MOD);\n    SelfMod(a[i]);\n    SelfMod(a[i + l2]);\n    Dziel(a[i]);\n    Dziel(a[i + l2]);\n  }\n  untransform(x, z, a);\n  untransform(z, y, a);\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  ppow[0] = 1;\n  RE (i, N - 2) {\n    ppow[i] = ppow[i - 1] * B % P;\n  }\n  \n  int n;\n  cin>>n;\n  int M = 1 << 17;\n  VVI layers(4, VI(M));\n  REP (tr, 3) {\n    int m;\n    cin>>m;\n    VVI slo(n + 2);\n    RE (i, m) {\n      int a, b;\n      cin>>a>>b;\n      if (a > b) {\n        swap(a, b);\n      }\n      slo[a].PB(b);\n    }\n    //VI vals(n + 2);\n    VI which_layer(n + 2);\n    FORD (i, n, 1) {\n      set<int> zioms;\n      for (auto nei : slo[i]) {\n        zioms.insert(which_layer[nei]);\n      }\n      for (int mex = 0; ; mex++){\n        if (zioms.count(mex) == 0) {\n          layers[tr][mex] = (layers[tr][mex] + ppow[i]) % P;\n          which_layer[i] = mex;\n          break;\n        }\n      }\n    }\n    transform(0, M, &layers[tr][0]);\n  }\n  //int res = 0;\n  REP (i, M) {\n    int prod = 1;\n    REP (tr, 3) {\n      prod = prod * layers[tr][i] % P;\n    }\n    layers[3][i] = prod;\n    //res = (res + prod) % P;\n  }\n  untransform(0, M, &layers[3][0]);\n  cout<<layers[3][0]<<endl;\n    \n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n        #define int long long\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int  Inv2 = (MOD+1)/2;\ntemplate <typename T>\nvoid fwt(vector<T>& f) {\n    int n = f.size();\n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD, f[j | i] = (x+MOD - y)%MOD;\n            }\n        }\n    }\n}\ntemplate <typename T>\nvoid ifwt(vector<T>& f) {\n    int n = f.size();\n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD *Inv2 %MOD, f[j | i] = (x+MOD - y) %MOD *Inv2 %MOD;\n            }\n        }\n    }\n}\n     signed main(){\n   int n,nn=1,t=1,m,a,b;\n   for(int i=0;i<18;i++)t=(t*10)%MOD;\n   cin>>n;\n   while(nn<n)nn*=2;\n vector<int> p(nn,0),q(nn,0),r(nn,0),ban(n,0),henp[n],henq[n],henr[n];\n cin>>m;\n for(int i=0;i<m;i++){\n         cin>>a>>b;a--;b--;\n         if(a>b)swap(a,b);\n         henp[a].push_back(b);\n }\n        cin>>m;\n for(int i=0;i<m;i++){\n         cin>>a>>b;a--;b--;\n         if(a>b)swap(a,b);\n         henq[a].push_back(b);\n }\n cin>>m;\n for(int i=0;i<m;i++){\n         cin>>a>>b;a--;b--;\n         if(a>b)swap(a,b);\n         henr[a].push_back(b);\n }\n\npriority_queue<int,vector<int>,greater<int>> que;\n for(int i=n-1;i>=0;i--){\n         ban[i]=0;\n         for(int j=0;j<henp[i].size();j++)que.push(ban[henp[i][j]]);\n         while(!que.empty()){\n                 if(ban[i]==que.top())ban[i]++;\n                 que.pop();\n         }\n }\n a=1;\n for(int i=0;i<n;i++){\n         a=(a*t)%MOD;\n        p[ban[i]]=(p[ban[i]]+a)%MOD;\n }\n for(int i=n-1;i>=0;i--){\n         ban[i]=0;\n         for(int j=0;j<henq[i].size();j++)que.push(ban[henq[i][j]]);\n         while(!que.empty()){\n                 if(ban[i]==que.top())ban[i]++;\n                 que.pop();\n         }\n }\n a=1;\n for(int i=0;i<n;i++){\n         a=(a*t)%MOD;\n        q[ban[i]]=(q[ban[i]]+a)%MOD;\n }\n for(int i=n-1;i>=0;i--){\n         ban[i]=0;\n         for(int j=0;j<henr[i].size();j++)que.push(ban[henr[i][j]]);\n         while(!que.empty()){\n                 if(ban[i]==que.top())ban[i]++;\n                 que.pop();\n         }\n }\n a=1;\n for(int i=0;i<n;i++){\n         a=(a*t)%MOD;\n        r[ban[i]]=(r[ban[i]]+a)%MOD;\n }\n fwt(p);fwt(q);\n for(int i=0;i<nn;i++)q[i]=(q[i]*p[i])%MOD;\n ifwt(q);\n int ans=0;\n for(int i=0;i<nn;i++)ans=(ans+(q[i]*r[i])%MOD)%MOD;\n cout<<ans<<endl;\n\n\n         \n}\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nconstexpr int P = 998244353 , V = 1000000000000000000 % P, INV2 = (P + 1) / 2;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n;\n    std::cin >> n;\n    std::vector<int> f{1};\n    auto work = [&]() {\n        std::vector<std::vector<int>> e(n);\n        std::vector<int> c(n);\n        int m;\n        std::cin >> m;\n        for (int i = 0; i < m; ++i) {\n            int u, v;\n            std::cin >> u >> v;\n            --u;\n            --v;\n            if (u > v)\n                std::swap(u, v);\n            e[u].push_back(v);\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            std::vector<bool> vis(e[i].size() + 1);\n            for (int v : e[i])\n                if (c[v] <= int(e[i].size()))\n                    vis[c[v]] = true;\n            while (vis[c[i]])\n                ++c[i];\n        }\n        std::vector<int> g;\n        for (int i = 0, j = V; i < n; ++i, j = 1ll * j * V % P) {\n            if (c[i] >= int(g.size()))\n                g.resize(c[i] + 1);\n            g[c[i]] = (g[c[i]] + j) % P;\n        }\n        std::vector<int> h;\n        for (int i = 0; i < int(f.size()); ++i) {\n            for (int j = 0; j < int(g.size()); ++j) {\n                if ((i ^ j) >= int(h.size()))\n                    h.resize((i ^ j) + 1);\n                h[i ^ j] = (h[i ^ j] + 1ll * f[i] * g[j]) % P;\n            }\n        }\n        f = h;\n    };\n    work();\n    work();\n    work();\n    std::cout << f[0] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int N = 3e5 + 1, mod = 998244353;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nstruct edge {\n\tint x, y, next;\n} e[N * 2]; int cnt, last[N];\nint n, v[N], z[N];\nint y[3][N];\nLL A[N * 2], B[N * 2], C[N * 2], D[N * 2];\nint R[N * 2];\n\nLL pow_mod(LL a, LL k) {\n\tLL ans = 1;\n\tk %= (mod - 1);\n\twhile(k) {\n\t\tif(k & 1) (ans *= a) %= mod;\n\t\t(a *= a) %= mod; k /= 2;\n\t} return ans;\n}\n\nvoid NTT(LL y[], int len, int on) {\n\tfor(int i = 0; i < len; i++) if(i < R[i]) swap(y[i], y[R[i]]);\n\tfor(int i = 1; i < len; i *= 2) {\n\t\tLL wn = pow_mod(3, (LL)(mod - 1) / (i * 2)); if(on == -1) wn = pow_mod(wn, mod - 2);\n\t\tfor(int j = 0; j < len; j += i * 2) {\n\t\t\tLL w = 1;\n\t\t\tfor(int k = 0; k < i; k++, (w *= wn) %= mod) {\n\t\t\t\tLL u = y[j + k], v = y[j + k + i] * w % mod;\n\t\t\t\ty[j + k] = (u + v) % mod, y[j + k + i] = (u - v + mod) % mod;\n\t\t\t}\n\t\t}\n\t} if(on == -1) {\n\t\tLL gg = pow_mod(len, mod - 2);\n\t\tfor(int i = 0; i < len; i++) (y[i] *= gg) %= mod;\n\t}\n}\n\nI void ins(cr x, cr y) {e[++cnt] = edge{x, y, last[x]}, last[x] = cnt;}\n\nint len;\n\nI void gao(cr o) {\n\treg m = read();\n\tcnt = 0, memset(last, 0, sizeof(last));\n\tfo(i, 1, m) {\n\t\treg x = read(), y = read();\n\t\tins(x, y), ins(y, x);\n\t} memset(v, 0, sizeof(v));\n\tmemset(C, 0, sizeof(C)), memset(D, 0, sizeof(D));\n\tfd(i, n, 1) {\n\t\tbool h1 = 0, h2 = 0;\n\t\tfor(reg k = last[i]; k; k = e[k].next) {\n\t\t\tif(v[e[k].y] == 1) h1 |= 1;\n\t\t\tif(v[e[k].y] == 2) h2 |= 1;\n\t\t} if(h1 && h2) continue;\n\t\tif(!h1) C[i] = 1, v[i] = 1;\n\t\telse D[i] = 1, v[i] = 2;\n\t}\n\tNTT(C, len, 1), NTT(D, len, 1);\n\tfo(i, 0, len - 1) {\n\t\treg a = A[i], b = B[i], c = C[i], d = D[i];\n\t\tA[i] = ((LL)a * c % mod + (LL)b * d) % mod;\n\t\tB[i] = ((LL)a * d % mod + (LL)b * c) % mod;\n\t}\n}\n\nint main() {\n\tn = read();\n\tlen = 1;\n\tfor(; len <= n * 3; len <<= 1);\n\tfo(i, 0, len - 1) R[i] = (R[i >> 1] >> 1) | ((i & 1) * (len >> 1));\n\tfo(i, 0, len - 1) A[i] = 1;\n\tgao(0), gao(1), gao(2);\n\tNTT(A, len, -1);\n\treg s = 1, w = pow_mod(10, 18), ans = 0;\n\tfo(i, 1, 3 * n) {\n\t\ts = (LL)s * w % mod;\n\t\tans = (ans + (LL)s * A[i]) % mod;\n\t} pr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Fi first\n#define Se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\ntypedef tuple<int, int, int> t3;\n\nint N;\nint color[3][100010];\nvector <int> E[3][100010];\nconst int mod = 998244353;\n\nll pw(ll x, ll y = mod - 2) {\n\tll res = 1;\n\twhile(y) {\n\t\tif(y & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nconst int L = 1<<17;\nvoid FFT_XOR(ll A[], int rev) {\n\tfor(int len=1;len<L;len<<=1) {\n\t\tfor(int i=0;i<L;i+=len*2) {\n\t\t\tfor(int j=0;j<len;j++) {\n\t\t\t\tll x = A[i+j];\n\t\t\t\tll y = A[i+j+len];\n\t\t\t\tA[i+j] = (x + y) % mod;\n\t\t\t\tA[i+j+len] = (x - y + mod) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tif(rev) rep(i, L) A[i] = A[i] * pw(L) % mod;\n}\n\nll V[3][L];\nll rp[300010];\n\nint main() {\n\tll r = 1;\n\trep(i, 18) r = r * 10 % mod;\n\trp[0] = 1;\n\tfor(int i=1;i<300010;i++) rp[i] = rp[i-1] * r % mod;\n\tscanf(\"%d\", &N);\n\trep(v, 3) {\n\t\tint m; scanf(\"%d\", &m);\n\t\twhile(m--) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tE[v][x].pb(y);\n\t\t\tE[v][y].pb(x);\n\t\t}\n\t\tfor(int i=N;i;i--) {\n\t\t\tset <int> x;\n\t\t\tfor(int e : E[v][i]) if(e > i) x.insert(color[v][e]);\n\t\t\tfor(int j=0;;j++) if(x.find(j) == x.end()) {\n\t\t\t\tcolor[v][i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=N;i++) {\n\t\t\tint c = color[v][i];\n\t\t\tV[v][c] = (V[v][c] + rp[i]) % mod;\n\t\t}\n\t\tFFT_XOR(V[v], 0);\n\t}\n\trep(i, L) {\n\t\tV[0][i] = V[0][i] * V[1][i] % mod * V[2][i] % mod;\n\t}\n\tFFT_XOR(V[0], 1);\n\n\tprintf(\"%lld\\n\", V[0][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e5+10, P = 998244353;\nint n, m, vis[N], sg[N], h[N], f[3][N];\nvector<int> g[N];\nvoid add(int &a, ll b) {a=(a+b)%P;}\n\nint main() {\n\th[0] = 1;\n\th[1] = 1000000000000000000ll%P;\n\tREP(i,2,N-1) h[i] = (ll)h[i-1]*h[1]%P;\n\tscanf(\"%d\", &n);\nint mx = 0;\n\tREP(i,0,2) {\n\t\tscanf(\"%d\", &m);\nmx = max(mx, int(sqrt(1+4*m)/2));\n\t\tREP(j,1,n) g[j].clear();\n\t\tREP(j,1,m) {\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif (u>v) swap(u,v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tPER(j,1,n) {\n\t\t\tint sz = g[j].size();\n\t\t\tREP(k,0,sz) vis[k] = 0;\n\t\t\tfor (int k:g[j]) vis[sg[k]] = 1;\n\t\t\tREP(k,0,sz) if (!vis[k]) {\n\t\t\t\tsg[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(f[i][sg[j]],h[j]);\n\t\t}\n\t}\nmx=500;\n\tint ans = 0;\n\tREP(i,0,mx) REP(j,0,mx) {\n\t\tadd(ans, (ll)f[0][i]*f[1][j]%P*f[2][i^j]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+10, P = 998244353;\nint n, m, vis[N], sg[N], h[N], f[3][N];\nvector<int> g[N];\nvoid add(int &a, ll b) {a=(a+b)%P;}\n\nint main() {\n\th[1] = 1000000000000000000ll%P;\n\tREP(i,2,N-1) h[i] = (ll)h[i-1]*h[1]%P;\n\tscanf(\"%d\", &n);\n\tREP(i,0,2) {\n\t\tscanf(\"%d\", &m);\n\t\tREP(j,1,n) g[i].clear();\n\t\tREP(j,1,m) {\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif (u>v) swap(u,v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tPER(j,1,n) {\n\t\t\tint sz = g[j].size();\n\t\t\tREP(k,0,sz) vis[k] = 0;\n\t\t\tfor (int k:g[j]) vis[sg[k]] = 1;\n\t\t\tREP(k,0,sz) if (!vis[k]) {\n\t\t\t\tsg[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(f[i][sg[j]],h[j]);\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i,0,400) REP(j,0,400) {\n\t\t\tadd(ans, (ll)f[0][i]*f[1][j]%P*f[2][i^j]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\n\ntemplate <long long mod>\nstruct modint {\n    long long x;\n\n    modint<mod>(): x(0LL) {}\n    modint<mod>(const long long _data) {\n        if (_data < 0) {\n            x = (_data % mod + mod) % mod;\n        } else if (_data >= mod) {\n            x = _data % mod;\n        } else {\n            x = _data;\n        }\n    }\n\n    bool operator==(const modint<mod>& op) const {\n        return x == op.x;\n    }\n\n    bool operator!=(const modint<mod>& op) const {\n        return !((*this) == op);\n    }\n\n    modint<mod> operator-() const {\n        if (x == 0) {\n            return modint(0);\n        }\n        return modint(mod - x);\n    }\n\n    modint<mod> operator+(const modint<mod>& op) const {\n        const long long newdata = x + op.x;\n        if (newdata >= mod) {\n            return modint<mod>(newdata - mod);\n        } else {\n            return modint<mod>(newdata);\n        }\n    }\n\n    modint<mod>& operator+=(const modint<mod>& op) {\n        x = (*this + op).x;\n        return *this;\n    }\n\n    modint<mod> operator-(const modint<mod>& op) const {\n        return *this + (-op);\n    }\n\n    modint<mod>& operator-=(const modint<mod>& op) {\n        x = (*this - op).x;\n        return *this;\n    }\n\n    modint<mod> operator*(const modint<mod>& op) const {\n        return modint<mod>(x * op.x % mod);\n    }\n\n    modint<mod>& operator*=(const modint<mod>& op) {\n        x = (*this * op).x;\n        return *this;\n    }\n\n    modint<mod> pow(const long long n) const {\n        if (n == 0) {\n            return modint<mod>(1);\n        }\n        modint<mod> sq = pow(n / 2);\n        if (n & 1) {\n            return (*this) * sq * sq;\n        } else {\n            return sq * sq;\n        }\n    }\n\n    modint<mod> inverse() const {\n        return pow(mod - 2);\n    }\n\n    modint<mod> operator/(const modint<mod>& op) const {\n        return (*this) * op.inverse();\n    }\n\n    modint<mod>& operator/=(const modint<mod>& op) {\n        x = (*this / op).x;\n        return *this;\n    }\n\n    friend modint<mod> operator/(const long long dividend, const modint<mod>& divisor) {\n        return modint<mod>(dividend) / divisor;\n    }\n\n    static modint<mod> factorial(const long long n) {\n        static std::vector<modint<mod>> cache(1, 1);\n\n        while (cache.size() <= n) {\n            modint<mod> next = cache.back() * cache.size();\n            cache.push_back(next);\n        }\n        return cache[n];\n    }\n\n    static modint<mod> invfact(const long long n) {\n        static std::vector<modint<mod>> cache(1, 1);\n\n        while (cache.size() <= n) {\n            modint<mod> next = cache.back() / cache.size();\n            cache.push_back(next);\n        }\n        return cache[n];\n    }\n\n    static modint<mod> combination(const long long n, const long long k) {\n        if (k < 0 || n < k) {\n            return modint<mod>(0);\n        }\n\n        if (n < 1e6) {\n            return factorial(n) * invfact(k) * invfact(n - k);\n        }\n\n        modint<mod> ret = invfact(k);\n        for (int i = 1; i <= k; ++i) {\n            ret = ret * modint<mod>(n - i + 1);\n        }\n        return ret;\n    }\n};\n\ntypedef modint<998244353> mint;\n\n\nli n;\nvector<li> calc_graph() {\n    li m;\n    cin >> m;\n    vector<vector<li>> graph(n);\n    for (int i = 0; i < m; ++i) {\n        li a, b;\n        cin >> a >> b;\n        a--; b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    vector<li> use(n, n + 1);\n    for (int i = n - 1; i >= 0; --i) {\n        set<li> used;\n        for (int j = 0; j < graph[i].size(); ++j) {\n            const li next = graph[i][j];\n            used.insert(use[next]);\n        }\n        for (int k = 0; k < used.size() + 1; ++k) {\n            if (used.find(k) == used.end()) {\n                use[i] = k;\n                break;\n            }\n        }\n\n    }\n    return use;\n}\n\nvector<li> first(vector<li> v) {\n    for (int i = 0; i < v.size(); ++i) {\n        v[i] = v[i] == 0 ? 1 : 0;\n    }\n    return v;\n}\nvector<li> second(vector<li> v) {\n    for (int i = 0; i < v.size(); ++i) {\n        v[i] = v[i] != 0 ? 1 : 0;\n    }\n    return v;\n}\n\nmint vecsum(const vector<li> &v) {\n    const mint bpow = mint(10).pow(18);\n    mint pow = bpow;\n    mint sum = 0;\n    for (int i = 0; i < v.size(); ++i) {\n        sum += mint(v[i]) * pow;\n        pow *= bpow;\n    }\n    return sum;\n}\nmint calc_ans(const vector<li> &v1, const vector<li> &v2, const vector<li> &v3) {\n    return vecsum(v1) * vecsum(v2) * vecsum(v3);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    vector<li> a_mis = calc_graph();\n    vector<li> b_mis = calc_graph();\n    vector<li> c_mis = calc_graph();\n\n    vector<li> all(n, 1);\n    vector<mint> a_iws(n, 0);\n    vector<mint> b_iws(n, 0);\n    vector<mint> c_iws(n, 0);\n    for (int i = 0; i < n; ++i) {\n        auto pow = mint(10).pow(18 * (i + 1));\n        a_iws[a_mis[i]] += pow;\n        b_iws[b_mis[i]] += pow;\n        c_iws[c_mis[i]] += pow;\n    }\n\n    vector<mint> ab_iws(n, 0);\n    vector<mint> bc_iws(n, 0);\n    vector<mint> ca_iws(n, 0);\n    for (int i = 0; i < n; ++i) {\n        ab_iws[i] = a_iws[i] * b_iws[i];\n        bc_iws[i] = c_iws[i] * b_iws[i];\n        ca_iws[i] = a_iws[i] * c_iws[i];\n    }\n\n    mint ab_sum = 0;\n    mint bc_sum = 0;\n    mint ca_sum = 0;\n    for (int i = 1; i < n; ++i) {\n        ab_sum += ab_iws[i];\n        bc_sum += bc_iws[i];\n        ca_sum += ca_iws[i];\n    }\n\n\n    mint ans = 0;\n    ans += calc_ans(first(a_mis), first(b_mis), first(c_mis));\n    ans += a_iws[0] * bc_sum;\n    ans += b_iws[0] * ca_sum;\n    ans += c_iws[0] * ab_sum;\n\n\n    cout << ans.x << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nconst int MOD = 998244353;\nvector<int> powers;\n\nint n;\nstruct Graph {\n\tvector<vector<int>> edges;\n\tvector<int> nimber;\n\tvector<int> groups;\n\tvoid read() {\n\t\tedges.resize(n + 1);\n\t\tnimber.resize(n + 1);\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tedges[a].push_back(b);\n\t\t\tedges[b].push_back(a);\n\t\t}\n\t\tfor(int a = n; a >= 1; --a) {\n\t\t\tset<int> nei;\n\t\t\tfor(int b : edges[a]) {\n\t\t\t\tif(b > a) {\n\t\t\t\t\tnei.insert(nimber[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int value = 0; true; ++value) {\n\t\t\t\tif(!nei.count(value)) {\n\t\t\t\t\tnimber[a] = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint i = nimber[a];\n\t\t\twhile((int) groups.size() <= i) {\n\t\t\t\tgroups.push_back(0);\n\t\t\t}\n\t\t\tgroups[i] += powers[a];\n\t\t\tgroups[i] %= MOD;\n\t\t}\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tpowers.resize(n + 1);\n\tpowers[0] = 1;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tpowers[i] = (long long) 1'000'000'000'000'000'000 % MOD * powers[i-1] % MOD;\n\t}\n\t\n\tGraph graphs[3];\n\tfor(int i : {0, 1, 2}) {\n\t\tgraphs[i].read();\n\t}\n\tint hope = 0;\n\tfor(int a = 0; a < (int) graphs[0].groups.size(); ++a) {\n\t\tfor(int b = 0; b < (int) graphs[1].groups.size(); ++b) {\n\t\t\tint c = a ^ b;\n\t\t\tif(c < (int) graphs[2].groups.size()) {\n\t\t\t// for(int c = 0; c < (int) graphs[2].groups.size(); ++c) {\n\t\t\t\tif((a ^ b ^ c) == 0) {\n\t\t\t\t\thope += (long long) graphs[0].groups[a] * graphs[1].groups[b] % MOD * graphs[2].groups[c] % MOD;\n\t\t\t\t\thope %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", hope);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i=(a); i<(int)(b); i++)\n#define FORD(i, a, b) for (int i=a; i>(int)(b); i--)\n#define PPC(x) __builtin_popcount(x)\n#define SZ(x) ((int)(x).size())\n#define MSB(x) (31 - __builtin_clz(x))\n#define pb push_back\n#define ALL(x) (x).begin(), (x).end()\n#define ithBit(m, i) ((m) >> (i) & 1)\n#define ft first\n#define sd second\n#ifdef DEBUG\n#include \"debug.h\"\n#else\n#define dbg(...) 0\n#endif\nusing namespace std;\n \nconst int maxN = 1 << 19, maxS = 400, mod = 998244353;\nconst long long INF = 1000000000000000000ll;\n\ntemplate <class T1, class T2> inline void addMod(T1& a, T2 b)\t{   a = (a + b) % mod;  }\ntemplate <class T1, class T2> inline void multMod(T1& a, T2 b)\t{   a = a * b % mod;    }\n\nlong long pows[maxN], T[3][maxS];\nvector <int> graph[3][maxN];\nint mex[maxN], vis[maxN];\n \nint main()\n{\n\tint n;\n\tscanf (\"%d\", &n);\n\tpows[1] = INF % mod;\n\tFOR(i, 2, n+1)\n\t\tpows[i] = pows[i-1] * pows[1] % mod;\n\tFOR(s, 0, 3)\n\t{\n\t\tvector <int>* G = graph[s];\n\t\tint m;\n\t\tscanf (\"%d\", &m);\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf (\"%d%d\", &a, &b);\n\t\t\tif (a > b)\n\t\t\t\tswap(a, b);\n\t\t\tG[a].pb(b);\n\t\t}\n\t\t\n\t\tFORD(v, n, 0)\n\t\t{\n\t\t\tfor (int u : G[v])\n\t\t\t\tvis[mex[u]] = v;\n\t\t\tfor (mex[v] = 0; vis[mex[v]] == v; mex[v]++) ;\n\t\t\taddMod(T[s][mex[v]], pows[v]);\n\t\t}\n\t\t\n\t\tfill(vis, vis+n+1, 0);\n\t}\n\t\n\tlong long res = 0;\n\tFOR(a, 0, maxS) FOR(b, 0, maxS) FOR(c, 0, maxS) if ((a^b^c) == 0)\n\t{\n\t\tlong long tak = T[0][a];\n\t\tmultMod(tak, T[1][b]);\n\t\tmultMod(tak, T[2][c]);\n\t\taddMod(res, tak);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct SumNode { UL a, b, c; };\n\nstruct Problem {\n\n\tvoid Solve() {\n\t\tconst ULL M = 998244353;\n\t\tconst ULL Z = 1000000000000000000 % 998244353;\n\n\t\tUL N; cin >> N;\n\t\tUL S[3];\n\t\tvector<vector<UL>> E[3];\n\t\trep(i, 3) {\n\t\t\tcin >> S[i];\n\t\t\tE[i].resize(N);\n\t\t\trep(j, S[i]) {\n\t\t\t\tUL u, v; cin >> u >> v; u--; v--;\n\t\t\t\tE[i][u].push_back(v);\n\t\t\t\tE[i][v].push_back(u);\n\t\t\t}\n\t\t}\n\t\tvector<UL> POWZ(N * 3 + 1); POWZ[0] = 1;\n\t\trep(i, N * 3) POWZ[i + 1] = POWZ[i] * Z % M;\n\t\tvector<ULL> A[3] = {};\n\t\tvector<UL> B[3] = {};\n\t\trep(t, 3) {\n\t\t\tA[t].resize(min(N, 450u));\n\t\t\tB[t].resize(min(N, 450u));\n\t\t\tvector<UL> F(N);\n\t\t\tfor (UL v = N - 1; v != -1; v--) {\n\t\t\t\tA[t][F[v]] = (A[t][F[v]] + POWZ[v + 1]) % M;\n\t\t\t\tB[t][F[v]] = max(B[t][F[v]], v + 1);\n\t\t\t\tfor (UL e : E[t][v]) {\n\t\t\t\t\tif (F[e] == F[v]) F[e] = F[v] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tULL ans = 0;\n\t\t{\n\t\t\trep(a, A[0].size()) rep(b, A[1].size()) {\n\t\t\t\tUL c = a ^ b; if (c >= A[2].size()) continue;\n\t\t\t\tans += A[0][a] * A[1][b] % M * A[2][c] % M;\n\t\t\t\tans %= M;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 998244353;\nconst int inv2 = (mod + 1) / 2;\n\nint n, base, ans;\n\nint qpow(int x, int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1LL * ret * x % mod;\n\t\tx = 1LL * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\nstruct Graph {\n\tint m;\n\tint tag[maxn], vis[maxn], l[maxn], sg[maxn], e;\n\tstruct Edge {\n\t\tint v, x;\n\t} E[maxn];\n\tinline void addEdge(int u, int v) {\n\t\tE[e].v = v, E[e].x = l[u], l[u] = e++;\n\t}\n\tint sum[1<<17];\n\tvoid dfs(int u) {\n\t\tvis[u] = 1;\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tint v = E[p].v;\n\t\t\tif (!vis[v]) {\n\t\t\t\tdfs(v);\n\t\t\t}\n\t\t}\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tint v = E[p].v;\n\t\t\ttag[sg[v]] = 1;\n\t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (!tag[i]) {\n\t\t\t\tsg[u] = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tint v = E[p].v;\n\t\t\ttag[sg[v]] = 0;\n\t\t}\n\t}\n\tvoid read() {\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\t\tif (u > v) swap(u, v);\n\t\t\taddEdge(u, v);\n\t\t}\n\t}\n\tvoid init() {\n\t\tmemset(l, -1, sizeof(l));\n\t}\n\tvoid solve() {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t\t(sum[sg[i]] += qpow(base, i)) %= mod;\n\t\t}\n\t}\n} G1, G2, G3;\n\nvoid fwt(int *a, int l, int r) {\n\tif (l == r) return;\n\tint m = (l + r) >> 1;\n\tfwt(a, l, m), fwt(a, m+1, r);\n\tfor (int i = 0; i <= m-l; i++) {\n\t\tint v1 = (a[l+i] + a[m+1+i]) % mod, v2 = (a[l+i] + mod - a[m+1+i]) % mod;\n\t\ta[l+i] = v1, a[m+1+i] = v2;\n\t}\n}\n\nvoid ifwt(int *a, int l, int r) {\n\tif (l == r) return;\n\tint m = (l + r) >> 1;\n\tifwt(a, l, m), ifwt(a, m+1, r);\n\tfor (int i = 0; i <= m-l; i++) {\n\t\tint v1 = (a[l+i] + a[m+1+i]) % mod, v2 = (a[l+i] + mod - a[m+1+i]) % mod;\n\t\ta[l+i] = 1LL * inv2 * v1 % mod, a[m+1+i] = 1LL * inv2 * v2 % mod;\n\t}\n}\n\nint res[1<<17];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tG1.init(), G2.init(), G3.init();\n\tG1.read(), G2.read(), G3.read();\n\tbase = qpow(10, 18);\n\tG1.solve(), G2.solve(), G3.solve();\n\tfwt(G1.sum, 0, (1<<17)-1), fwt(G2.sum, 0, (1<<17)-1), fwt(G3.sum, 0, (1<<17)-1);\n\tfor (int i = 0; i < (1<<17); i++) res[i] = 1LL * G1.sum[i] * G2.sum[i] % mod * G3.sum[i] % mod;\n\tifwt(res, 0, (1<<17)-1);\n\tprintf(\"%d\\n\", res[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>X(N);\n\tvector<int>Y(N);\n\tvector<int>Z(N);\n\tint XE, YE, ZE;\n\tcin >> XE;\n\tvector<vector<int>>Xedge(N);\n\tfor (int i = 0; i < XE; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tXedge[L].push_back(R);\n\t\tXedge[R].push_back(L);\n\t}\n\tcin >> YE;\n\tvector<vector<int>>Yedge(N);\n\tfor (int i = 0; i < YE; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tYedge[L].push_back(R);\n\t\tYedge[R].push_back(L);\n\t}\n\tcin >> ZE;\n\tvector<vector<int>>Zedge(N);\n\tfor (int i = 0; i < ZE; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tZedge[L].push_back(R);\n\t\tZedge[R].push_back(L);\n\t}\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tset<int>s;\n\t\tfor (auto j : Xedge[i]) {\n\t\t\tif (j > i)s.insert(X[j]);\n\t\t}\n\t\tfor (auto j : s) {\n\t\t\tif (X[i] == j)X[i]++;\n\t\t}\n\t}\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tset<int>s;\n\t\tfor (auto j : Yedge[i]) {\n\t\t\tif (j > i)s.insert(Y[j]);\n\t\t}\n\t\tfor (auto j : s) {\n\t\t\tif (Y[i] == j)Y[i]++;\n\t\t}\n\t}\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tset<int>s;\n\t\tfor (auto j : Zedge[i]) {\n\t\t\tif (j > i)s.insert(Z[j]);\n\t\t}\n\t\tfor (auto j : s) {\n\t\t\tif (Z[i] == j)Z[i]++;\n\t\t}\n\t}\n\n\t/////////////\n\tunordered_map<long long int, long long int>Xbox(2 * N + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tXbox[X[i]] += power(10, 18 * (i + 1), MOD);\n\t}\n\tunordered_map<long long int, long long int>Ybox(2 * N + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tYbox[Y[i]] += power(10, 18 * (i + 1), MOD);\n\t}\n\tunordered_map<long long int, long long int>Zbox(2 * N + 1);\n\tfor (int i = 0; i < N; i++) {\n\t\tZbox[Z[i]] += power(10, 18 * (i + 1), MOD);\n\t}\n\t/*\n\tcout << \"X \" << endl;\n\tfor (auto i : Xbox) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\tcout << \"Y \" << endl;\n\tfor (auto i : Ybox) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\tcout << \"Z \" << endl;\n\tfor (auto i : Zbox) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\t*/\n\tlong long int ans = 0;\n\tfor(auto i:Xbox){\n\t\tfor (auto j : Ybox) {\n\t\t\tans += i.second%MOD*(j.second%MOD)%MOD*(Zbox[i.first^j.first] % MOD)%MOD;\n\t\t}\n\t}\n\tcout << ans % MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nusing M9 = IntMod<998244353>;\n\nint N, A, B, C;\nvector<int> G[100000];\nvector<int> H[100000];\nvector<int> I[100000];\n\nvoid input() {\n\tcin >> N;\n\tcin >> A;\n\tREP(z, 0, A) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tcin >> B;\n\tREP(z, 0, B) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tH[a].push_back(b);\n\t\tH[b].push_back(a);\n\t}\n\tcin >> C;\n\tREP(z, 0, C) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tI[a].push_back(b);\n\t\tI[b].push_back(a);\n\t}\n}\n\nint GQ[100000];\nint HQ[100000];\nint IQ[100000];\n\nvoid calc(vector<int>* g, int* gq) {\n\tREM(from, 0, N) {\n\t\tvector<int> st;\n\t\tfor (int to : g[from]) {\n\t\t\tif (to < from) continue;\n\t\t\tst.push_back(gq[to]);\n\t\t}\n\t\tsort(st.begin(), st.end());\n\t\tst.push_back(INF);\n\n\t\tint mn = 0;\n\t\twhile (st[mn] == mn) {\n\t\t\t++mn;\n\t\t}\n\t\tgq[from] = mn;\n\t}\n}\n\nint main() {\n\tinput();\n\tcalc(G, GQ);\n\tcalc(H, HQ);\n\tcalc(I, IQ);\n\n\tmap<int, M9> mg, mh, mi;\n\tM9 c = 0;\n\tREP(i, 0, N) {\n\t\tc += M9(10)[18 * (i + 1)];\n\t\tmg[GQ[i]] += M9(10)[18 * (i + 1)];\n\t\tmh[HQ[i]] += M9(10)[18 * (i + 1)];\n\t\tmi[IQ[i]] += M9(10)[18 * (i + 1)];\n\t}\n\n\tM9 sum = 0;\n\tfor (auto&& p : mg) {\n\t\tfor (auto&& q : mh) {\n\t\t\tsum += p.second * q.second * mi[p.first ^ q.first];\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M[3];\nvector<int> E[3][101010];\nconst ll mo=998244353;\nll p10[20];\nll pv[303030];\n\nint ok[3][303030];\n\nll comb(ll N_, ll C_) {\n\tconst int NUM_=1400001;\n\tif(C_==3) return N_*(N_-1)*(N_-2)/6;\n\t\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\nll hcomb(int P_,int Q_) { return (P_==0&&Q_==0)?1:comb(P_+Q_-1,Q_);}\n\nll pat(ll num) {\n\tif(num<0) return 0;\n\treturn (num+2)*(num+1)/2;\n}\n\n\nll num(ll tot) {\n\tll ret=pat(tot);\n\tret-=3*pat(tot-N);\n\tret+=3*pat(tot-2*N);\n\tret-=3*pat(tot-3*N);\n\treturn ret;\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tll sum=0;\n\n\tp10[0]=1;\n\tFOR(i,19) p10[i+1]=p10[i]*10%mo;\n\tpv[0]=p10[18]*p10[18]%mo*p10[18]%mo;\n\tFOR(i,302020) pv[i+1]=pv[i]*p10[18]%mo;\n\t\n\tll from[3]={};\n\tFOR(i,3) {\n\t\tcin>>M[i];\n\t\tFOR(j,M[i]) {\n\t\t\tcin>>x>>y;\n\t\t\tE[i][x-1].push_back(y-1);\n\t\t\tE[i][y-1].push_back(x-1);\n\t\t}\n\t\tfor(j=N-1;j>=0;j--) {\n\t\t\tset<int> S;\n\t\t\tFORR(e,E[i][j]) if(e>j) S.insert(ok[i][e]);\n\t\t\twhile(S.count(ok[i][j])) ok[i][j]++;\n\t\t\tif(ok[i][j]<=2) {\n\t\t\t\tll to[3]={};\n\t\t\t\tll pat=pv[j];\n\t\t\t\tFOR(x,3) (to[(x+ok[i][j])%3]+=pat*from[x])%=mo;\n\t\t\t\tswap(from,to);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<from[0]<<endl;\n\t/*\n\t\n\tll ret=0;\n\tfor(i=0;i<=3*(N-1);i++) ret+=pv[i]*num(i)%mo;\n\t\n\tll dp[3]={1,0,0};\n\tFOR(i,3) {\n\t\tfor(j=N-1;j>=0;j--) {\n\t\t\tif(ok[i][j]>=3) {\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t*/\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e5+10, P = 998244353;\nint n, m, vis[N], sg[N], h[N], f[3][N];\nvector<int> g[N];\nvoid add(int &a, ll b) {a=(a+b)%P;}\n\nint main() {\n\th[0] = 1;\n\th[1] = 1000000000000000000ll%P;\n\tREP(i,2,N-1) h[i] = (ll)h[i-1]*h[1]%P;\n\tscanf(\"%d\", &n);\nint mx = 0;\n\tREP(i,0,2) {\n\t\tscanf(\"%d\", &m);\nmx = max(mx, int(sqrt(1+4*m)/2));\n\t\tREP(j,1,n) g[j].clear();\n\t\tREP(j,1,m) {\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif (u>v) swap(u,v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tPER(j,1,n) {\n\t\t\tint sz = g[j].size();\n\t\t\tREP(k,0,sz) vis[k] = 0;\n\t\t\tfor (int k:g[j]) vis[sg[k]] = 1;\n\t\t\tREP(k,0,sz) if (!vis[k]) {\n\t\t\t\tsg[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(f[i][sg[j]],h[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i,0,mx) REP(j,0,mx) {\n\t\tadd(ans, (ll)f[0][i]*f[1][j]%P*f[2][i^j]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nconstexpr auto pow(long long x, long long n, const long long mod) {\n    long long ret = 1;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint main() {\n    constexpr i64 mod = 998244353, base = pow(10, 18, mod), lim = 320;\n    int n;\n    std::cin >> n;\n\n    auto f = [=](int n) { return pow(base, n, mod); };\n\n    std::vector<i64> used(lim);\n    std::vector<std::vector<i64>> ss(3, std::vector<i64>(lim));\n    for (int i = 0; i < 3; i++) {\n        int m;\n        std::cin >> m;\n        std::vector<std::vector<int>> g(n + 1);\n        std::vector<int> par(n + 1);\n        for (int j = 0; j < m; j++) {\n            int u, v;\n            std::cin >> u >> v;\n            if (u < v) std::swap(u, v);\n            g[v].push_back(u);\n        }\n\n        for (int j = n; j > 0; j--) {\n            if (g[j].size() >= lim) std::fill(used.begin(), used.end(), 0ll);\n            else std::fill(used.begin(), used.begin() + g[j].size() + 1, 0ll);\n\n            for (int p : g[j]) used[par[p]] = 1;\n\n            par[j] = std::find(used.begin(), used.end(), 0ll) - used.begin();\n            ss[i][par[j]] = (ss[i][par[j]] + f(j)) % mod;\n        }\n    }\n\n    i64 ret = 0;\n    for (int i = 0; i < lim; i++) for (int j = 0; j < lim; j++) {\n        if ((i ^ j) < lim) ret = (ret + ss[0][i] * ss[1][j] % mod * ss[2][i ^ j] % mod) % mod;\n    }\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair \n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class A> str ts(complex<A> c) { return ts(mp(c.real(),c.imag())); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(char c) { str s = \"\"; s += c; return s; }\nstr ts(str s) { return s; }\nstr ts(const char* s) { return (str)s; }\nstr ts(vector<bool> v) { \n\tbool fst = 1; str res = \"{\";\n\tF0R(i,sz(v)) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(v[i]);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class T> str ts(T v) {\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << to_string(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T; \n \t/// don't silently convert to T\n\tT v; explicit operator T() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend str to_string(mi a) { return to_string(a.v); }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nmi base = INF;\nint N;\nvi adj[3][MX];\n\nvpi inp() {\n\tint M; re(M);\n\tvpi v(M); re(v);\n\treturn v;\n}\n\nmap<int,mi> comb(map<int,mi> a, map<int,mi> b) {\n\tmap<int,mi> c;\n\ttrav(x,a) trav(y,b) c[x.f^y.f] += x.s*y.s;\n\treturn c;\n}\n\nint main() {\n\tsetIO(); re(N);\n\tF0R(i,3) {\n\t\tvpi v = inp();\n\t\ttrav(t,v) adj[i][min(t.f,t.s)].pb(max(t.f,t.s));\n\t}\n\tmap<int,mi> cand[3];\n\tF0R(i,3) {\n\t\tvi nim(N+1);\n\t\tROF(j,1,N+1) {\n\t\t\tset<int> bad;\n\t\t\ttrav(t,adj[i][j]) bad.insert(nim[t]);\n\t\t\twhile (bad.count(nim[j])) nim[j] ++;\n\t\t\tcand[i][nim[j]] += pow(base,j);\n\t\t}\n\t}\n\tauto x = comb(cand[0],cand[1]);\n\tauto y = comb(x,cand[2]);\n\tps(y[0]);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\nconst int N=100007,M=512,P=998244353,base=1000000000000000000%P;\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nvoid inc(int&a,int b){a+=b-P,a+=a>>31&P;}\nint mul(int a,int b){return 1ll*a*b%P;}\nint n;\nstruct graph\n{\n    int f[N],g[M],vis[M];std::vector<int>e[N];\n    void input()\n    {\n\tfor(int m=read(),u,v;m;--m) u=read(),v=read(),e[std::min(u,v)].push_back(std::max(u,v));\n\tfor(int u=n;u;--u)\n\t{\n\t    for(int v:e[u]) vis[f[v]]=1;\n\t    while(vis[f[u]]) ++f[u];\n\t    for(int v:e[u]) vis[f[v]]=0;\n\t}\n\tfor(int i=1,x=1;i<=n;++i) x=mul(x,base),inc(g[f[i]],x);\n    }\n}a[3];\nint main()\n{\n    n=read();int ans=0;\n    for(int i=0;i<3;++i) a[i].input();\n    for(int i=0;i<512;++i) for(int j=0;j<512;++j) inc(ans,1ll*a[0].g[i]*a[1].g[j]%P*a[2].g[i^j]%P);\n    printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 555555;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nint n;\nvector<vii> G(3);\nvector<vii> num(3, vii(1000));\n\nvoid solve(int idx, vii G) {\n    vi g(n);\n    rrep (u, n) {\n        set<int> st;\n        for (int v: G[u]) {\n            if (v > u) st.insert(g[v]);\n        }\n\n        rep (gl, 50000) {\n            if (not st.count(gl)) {\n                g[u] = gl;\n                num[idx][gl].push_back(u);\n                break;\n            }\n        }\n    }\n}\n\nsigned main() {\n    cin >> n;\n    rep (i, 3) {\n        G[i].resize(n);\n        int m;\n        cin >> m;\n        rep (j, m) {\n            int u, v;\n            cin >> u >> v;\n            u--; v--;\n            G[i][u].push_back(v);\n            G[i][v].push_back(u);\n        }\n    }\n\n    rep (i, 3) {\n        solve(i, G[i]);\n        // DEBUG(i);\n        // rep (j, 3) {\n        //     rep (k, num[i][j].size()) {\n        //         cout << num[i][j][k] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n    }\n\n    ll base = mod_pow(10, 18);\n    vll sum(3, vl(1000));\n    rep (i, 3) {\n        rep (j, 1000) {\n            for (int u: num[i][j]) {\n                (sum[i][j] += mod_pow(base, u + 1)) %= MOD;\n            }\n        }\n    }\n\n    ll ans = 0;\n    rep (x, 1000) {\n        rep (y, 1000) {\n            int z = x ^ y;\n            if (z >= 1000) continue;\n            ll mul2 = sum[2][z];\n            ll mul1 = sum[1][y];\n            ll mul0 = sum[0][x];\n            (ans += mul0 * mul1 % MOD * mul2 % MOD) %= MOD;\n            // if (mul0 * mul1 % MOD * mul2 % MOD != 0) {\n            //     DEBUG_VEC(vi({z, y, x}));\n            //     DEBUG_VEC(vl({mul2, mul1, mul0}));\n            // }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nusing graph=vector<vector<int>>;\n\nclass mint{\n\tstatic const int MOD=998244353;\n\tint x;\npublic:\n\tmint():x(0){}\n\tmint(long long y){ x=y%MOD; if(x<0) x+=MOD; }\n\n\tmint& operator+=(const mint& m){ x+=m.x; if(x>=MOD) x-=MOD; return *this; }\n\tmint& operator-=(const mint& m){ x-=m.x; if(x<   0) x+=MOD; return *this; }\n\tmint& operator*=(const mint& m){ x=1LL*x*m.x%MOD; return *this; }\n\tmint& operator/=(const mint& m){ return *this*=inverse(m); }\n\tmint operator+(const mint& m)const{ return mint(*this)+=m; }\n\tmint operator-(const mint& m)const{ return mint(*this)-=m; }\n\tmint operator*(const mint& m)const{ return mint(*this)*=m; }\n\tmint operator/(const mint& m)const{ return mint(*this)/=m; }\n\tmint operator-()const{ return mint(-x); }\n\n\tfriend mint inverse(const mint& m){\n\t\tint a=m.x,b=MOD,u=1,v=0;\n\t\twhile(b>0){ int t=a/b; a-=t*b; swap(a,b); u-=t*v; swap(u,v); }\n\t\treturn u;\n\t}\n\n\tfriend istream& operator>>(istream& is,mint& m){ long long t; is>>t; m=mint(t); return is; }\n\tfriend ostream& operator<<(ostream& os,const mint& m){ return os<<m.x; }\n\tint to_int()const{ return x; }\n};\n\nmint operator+(long long y,const mint& m){ return m+y; }\nmint operator*(long long y,const mint& m){ return m*y; }\n\nmint pow(mint m,long long k){\n\tmint res=1;\n\tfor(;k>0;k>>=1,m*=m) if(k&1) res*=m;\n\treturn res;\n}\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tvector<graph> G(3,graph(n));\n\trep(i,3){\n\t\tint m; scanf(\"%d\",&m);\n\t\trep(j,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tif(u>v) swap(u,v);\n\t\t\tG[i][u].emplace_back(v);\n\t\t}\n\t}\n\n\tvector<vector<int>> grundy(3,vector<int>(n));\n\trep(i,3){\n\t\tvector<int> used(1e5+1,-1);\n\t\tfor(int u=n-1;u>=0;u--){\n\t\t\tfor(int v:G[i][u]){\n\t\t\t\tused[grundy[i][v]]=u;\n\t\t\t\twhile(used[grundy[i][u]]==u) grundy[i][u]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint g_max=0;\n\trep(i,3) rep(u,n) g_max=max(g_max,grundy[i][u]);\n\n\tvector<vector<mint>> wt(3,vector<mint>(g_max+1));\n\trep(i,3) rep(u,n) wt[i][grundy[i][u]]+=pow(mint(10),18*(u+1));\n\n\tmint ans=0;\n\trep(g0,g_max+1) rep(g1,g_max+1) {\n\t\tint g2=g0^g1;\n\t\tif(g2>g_max) continue;\n\t\tans+=wt[0][g0]*wt[1][g1]*wt[2][g2];\n\t}\n\tcout<<ans<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "f"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll p=998244353;\nvector<ll>zh[100010];\nll n,m,i,j,k,x,y,ans,hh,f[3][100010],fac[500010],sg[3][100010];\nint main(){\n\tscanf(\"%lld\",&n);\n\tfac[0]=1;\n\thh=1000000000000000000%p;\n\tfor(i=1;i<=n*3;i++)fac[i]=fac[i-1]*hh%p;\n\tfor(k=0;k<3;k++){\n\t\tscanf(\"%lld\",&m);\n\t\tfor(i=1;i<=n;i++)zh[i].clear();\n\t\tfor(i=1;i<=m;i++){\n\t\t\tscanf(\"%lld%lld\",&x,&y);\n\t\t\tif(x>y)swap(x,y);\n\t\t\tzh[x].push_back(y);\n\t\t}\n\t\tfor(i=n;i;i--){\n\t\t\tstd::set<ll>mex;\n\t\t\tfor(j=0;j<zh[i].size();j++)mex.insert(sg[k][zh[i][j]]);\n\t\t\twhile(mex.count(sg[k][i]))sg[k][i]++;\n\t\t\t(f[k][sg[k][i]]+=fac[i])%=p;\n\t\t}\n\t}\n\tfor(i=0;i<500;i++)\n\t for(j=0;j<500;j++)ans=(ans+f[0][i]*f[1][j]%p*f[2][i^j])%p;\n\tprintf(\"%lld\",ans);\n}\n/*\n观察转移公式，发现跟博弈游戏一样。。\norz \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr LL mod = 998244353;\nconstexpr int maxn = 100000 + 1;\nLL p[maxn], ans = 1, sum = 1;\nint N, rm[maxn], de[maxn];\nset<int, greater<int>> G[maxn];\nvoid build(){\n    int M;\n    cin >> M;\n    for(int i = 1; i <= N; i += 1){\n        G[i].clear();\n        rm[i] = 0;\n        de[i] = 0;\n    }\n    for(int i = 0, u, v; i < M; i += 1){\n        cin >> u >> v;\n        if(u < v) swap(u, v);\n        G[u].insert(v);\n    }\n    LL psum = 0, pans = 0;\n    for(int i = N; i; i -= 1){\n        if(not de[i]){\n            if(rm[i] == 1) pans += mod - p[i];\n            else if(rm[i] == 0){\n                pans += p[i];\n                for(int v : G[i]) rm[v] += 1;\n                if(not G[i].empty()) for(int v : G[*G[i].begin()]) if(G[i].count(v)) de[v] = 1;\n            } \n            psum += p[i];\n        }\n    }\n    ans = pans % mod * ans % mod;\n    sum = psum % mod * sum % mod;\n}\nconstexpr LL B = 1000000000000000000LL;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cin >> N;\n    for(int i = 0; i <= N; i += 1) p[i] = i ? p[i - 1] * (B % mod) % mod : 1;\n    for(int i = 0; i < 3; i += 1) build();\n    cout << (sum + ans) * (mod + 1) / 2 % mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register int\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline int\n#define C(x,y) memset(x,y,sizeof(x))\n#define STS system(\"pause\")\ntemplate<class D>I read(D &res){\n\tres=0;register D g=1;register char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')g=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\tres*=g;\n}\nconst int P=716070898,Mod=998244353;\nvector<int>e[101000];\nint n,m,X,Y,fac[303000],f[3][101000],sg[101000],ans;\nmap<int,int>mp;\nI add(int &x,int y){\n\t(x+=y)>=Mod?x-=Mod:0;\n}\nint main(){\n\tread(n);\n\tfac[0]=1;\n\tF(i,1,n*3)fac[i]=(ll)fac[i-1]*P%Mod;\n\tF(c,0,2){\n\t\tread(m);\n\t\tF(i,1,n)e[i].clear(),sg[i]=0;\n\t\tF(i,1,m){\n\t\t\tread(X);read(Y);\n\t\t\tif(X>Y)swap(X,Y);\n\t\t\te[X].emplace_back(Y);\n\t\t}\n\t\tFOR(i,n,1){\n\t\t\tmp.clear();\n\t\t\tfor(auto d:e[i])mp[sg[d]]=1;\n\t\t\tsg[i]=0;\n\t\t\twhile(mp[sg[i]])sg[i]++;\n\t\t\tadd(f[c][sg[i]],fac[i]);\n\t\t}\n\t}\n\tF(i,0,500){\n\t\tF(j,0,500){\n\t\t\tadd(ans,(ll)f[0][i]*f[1][j]%Mod*f[2][i^j]%Mod);\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 100003, M = 450, mod = 998244353, X = (LL) 1e18 % mod;\ntemplate<typename T>\ninline void read(T &x){\n    int ch = getchar(); x = 0;\n    for(;ch < '0' || ch > '9';ch = getchar());\n    for(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';\n}\ntemplate<typename T>\ninline bool chkmax(T &a, const T &b){if(a < b) return a = b, 1; return 0;}\ninline void qmo(int &x){x += (x >> 31) & mod;}\nint n, m, r, f[3][M], sg[N], po[N], vis[N], ans;\nvector<int> E[N];\nint main(){\n    read(n); po[0] = 1;\n    for(Rint i = 1;i <= n;++ i) po[i] = (LL) po[i - 1] * X % mod;\n    for(Rint t = 0, x, y;t < 3;++ t){\n        read(m);\n        for(Rint i = 1;i <= n;++ i) E[i].clear();\n        while(m --){\n            read(x); read(y);\n            if(x > y) swap(x, y);\n            E[x].push_back(y);\n        }\n        for(Rint i = n;i;-- i){\n            int id = t * n + i;\n            for(Rint j : E[i]) vis[sg[j]] = id;\n            for(sg[i] = 0;vis[sg[i]] == id;++ sg[i]);\n            qmo(f[t][sg[i]] += po[i] - mod); chkmax(r, sg[i]);\n        }\n    }\n    for(Rint i = 0;i <= r;++ i)\n        for(Rint j = 0;j <= r;++ j)\n            qmo(ans += (LL) f[0][i] * f[1][j] % mod * f[2][i ^ j] % mod - mod);\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int, int> P;\ntypedef pair<P, int>PP;\nconst long long mod = 998244353;\nvector<int>G[3][100005];\nint G2[3][500];\nint grundy[3][100005];\nint n;\n\nint modpow(int a, int x) {\n\tint res = 1;\n\twhile (x) {\n\t\tif (x & 1)res = res*a%mod;\n\t\ta = a*a%mod;\n\t\tx >>= 1;\n\t}\n\treturn res;\n}\n\nsigned main() {\n\t cin >> n;\n\n\t rep(i, 3) {\n\t\t int m; cin >> m;\n\t\t rep(j, m) {\n\t\t\t int a, b; cin >> a >> b; a--; b--;\n\t\t\t if (a > b)swap(a, b);\n\t\t\t G[i][a].push_back(b);\n\t\t }\n\t\t rep(j, n)grundy[i][j] = -1;\n\t\t for (int j = n - 1; j >= 0; j--) {\n\t\t\t set<int>S;\n\t\t\t for (int k : G[i][j])S.insert(grundy[i][k]);\n\t\t\t int a = 0;\n\t\t\t while (S.count(a))a++;\n\t\t\t grundy[i][j] = a;\n\t\t }\n\t\t rep(j, n) {\n\t\t\t G2[i][grundy[i][j]] += modpow(10, 18*(j + 1));\n\t\t\t G2[i][grundy[i][j]] %= mod;\n\t\t }\n\t }\n\n\tint ans = 0;\n\n\trep(i, 500) {\n\t\trep(j, 500) {\n\t\t\tint k = i^j;\n\t\t\tans += G2[0][i] * G2[1][j] %mod* G2[2][k]%mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \n// Abbreviations\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ft front()\n#define bk back()\n#define lb lower_bound\n#define ub upper_bound\n#define pq priority_queue\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define ff(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n#define FF(i, a, b) for (int i = (int)(b); i >= (int)(a); --i)\n#define trav(a, x) for (auto &a: x)\n#define sz(a) (int)((a).size())\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\n#define upper_bound upb\n#define lower_bound lwb\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n// Constants\nconst int ooi = 2e9;\nconst long long ool = 1e18 + 5;\nconst int mod = 998244353;\nconst double PI = acos(-1);\nconst long double eps = 1e-9;\n \n// Abbreviations\ntypedef pair<int, int> pii;\ntypedef map<int, int> mii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef set<int> si;\ntypedef queue<int> qi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\ntypedef long double lld;\ntypedef unsigned long long ui64;\n \n// Min - max\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\n// Fast IO\ntemplate<typename T> inline void read(T &x) {\n\tchar c;\n\tbool neg = false;\n\twhile ((!isdigit(c = getchar())) && c != '-');\n\tif (c == '-') {\n\t\tc = getchar(); neg = true;\n\t}\n\tx = c - 48;\n\twhile (isdigit(c = getchar())) {\n\t\tx = x * 10 + (c - 48);\n\t}\n\tif (neg) x = -x;\n}\ntemplate<typename T> inline void Write(T x) {\n\tif (x > 9) Write(x / 10);\n\tputchar(x % 10 + 48);\n}\ntemplate<typename T> inline void write(T x) {\n\tif (x < 0) {\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tWrite(x);\n}\n\n// Debug\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n\treturn '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n\treturn to_string((string) s);\n}\n\nstring to_string(bool b) {\n\treturn (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n\tbool first = true;\n\tstring res = \"{\";\n\tfor (int i = 0; i < static_cast<int>(v.size()); i++) {\n\t\tif (!first) {\n\t\t\tres += \", \";\n\t\t}\n\t\tfirst = false;\n\t\tres += to_string(v[i]);\n\t}\n\tres += \"}\";\n\treturn res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n\tstring res = \"\";\n\tfor (size_t i = 0; i < N; i++) {\n\t\tres += static_cast<char>('0' + v[i]);\n\t}\n\treturn res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n\tbool first = true;\n\tstring res = \"{\";\n\tfor (const auto &x : v) {\n\t\tif (!first) {\n\t\t\tres += \", \";\n\t\t}\n\t\tfirst = false;\n\t\tres += to_string(x);\n\t}\n\tres += \"}\";\n\treturn res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n\treturn \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n\treturn \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n\treturn \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n\tcerr << \" \" << to_string(H);\n\tdebug_out(T...);\n}\n \n#ifdef LOCAL_DEFINE\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// Tree-order statistics\ntypedef tree<\nint,\nnull_type,\nless<int>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n\n// Commonly used functions\ninline i64 gcd(i64 a, i64 b) { // Use __gcd(a, b) instead for int\n\ti64 r;\n\twhile (b) {\n\t\tr = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\n\ninline i64 lcm(i64 a, i64 b) {\n\treturn (a / gcd(a, b) * b);\n}\n\ninline i64 fpow(i64 a, i64 b, i64 m = mod) {\n\ti64 r = 1;\n\tfor (; b > 0; b >>= 1) {\n\t\tif (b & 1) r = r * a % m;\n\t\ta = a * a % m;\n\t}\n\treturn r;\n}\n\ninline void addmod(int &a, int val, int m = mod) {\n\tif ((a = a + val) >= m) a -= m;\n}\n\ninline void submod(int &a, int val, int m = mod) {\n\tif ((a = a + val) < 0) a += m;\n}\n\ninline int mult(int a, int b, int m = mod) {\n\treturn (i64) a * b % m;\n}\n\ninline int inv(int a, int m = mod) {\n\treturn fpow(a, m - 2, m);\n}\n\ninline bool isPrime(i64 x) {\n\tif (x <= 3) return (x >= 2);\n\tif (x % 2 == 0 || x % 3 == 0) return false;\n\tfor (i64 i = 5; i * i <= x; i += 6) {\n\t\tif (x % i == 0 || x % (i + 2) == 0) return false;\n\t}\n\treturn true;\n}\n\n#ifdef LOCAL_DEFINE\n  mt19937 rnd(42); // Seed 42, output 1608637542\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\ninline int mrand() {\n\treturn abs((int) rnd());\n}\n\n// Main program starts here\n\nvi g[200005];\n\nint main(void) {\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcout.precision(10); cout << fixed;\n#ifdef LOCAL_DEFINE\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\n\tint n;\n\tcin >> n;\n\n\tauto cal = [&]() {\n\t\tint m;\n\t\tcin >> m;\n\t\tset<int> S, R;\n\t\tfor1(i, n) {\n\t\t\tg[i].clear();\n\t\t\tS.insert(i);\n\t\t}\n\t\tfor1(i, m) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tg[x].pb(y); g[y].pb(x);\n\t\t}\n\t\tvi res;\n\t\twhile (sz(S) || sz(R)) {\n\t\t\tint val = 0;\n\t\t\twhile (sz(S)) {\n\t\t\t\tint x = *S.rbegin();\n\t\t\t\tS.erase(x);\n\t\t\t\taddmod(val, fpow(10, 18 * x));\n\t\t\t\ttrav(u, g[x]) {\n\t\t\t\t\tif (S.count(u)) {\n\t\t\t\t\t\tS.erase(u); R.insert(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.pb(val);\n\t\t\tS.swap(R);\n\t\t}\n\t\treturn res;\n\t};\n\n\tvi v1 = cal(), v2 = cal(), v3 = cal();\n\tint S = max({sz(v1), sz(v2), sz(v3)});\n\tv1.resize(S), v2.resize(S), v3.resize(S);\n\n\tvvi ok(S, vi(S, 1));\n\tint ans = 0;\n\tforn(i, S) {\n\t\tvector<bool> used(S, 0);\n\t\tforn(j, S) forn(k, S) {\n\t\t\tif (ok[j][k] && !used[k]) {\n\t\t\t\tint val = 1;\n\t\t\t\tval = mult(val, v3[i]);\n\t\t\t\tval = mult(val, v2[j]);\n\t\t\t\tval = mult(val, v1[k]);\n\t\t\t\taddmod(ans, val);\n\t\t\t\tok[j][k] = 0;\n\t\t\t\tused[k] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n\tcerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*temp*/\n//\n//\n//\n//\n//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/type.hpp>\n#ifdef _DEBUG\n#include \"template.h\"\n#else\n#if __cplusplus >= 201703L\n/*Atcoderでしか使えない(c++17 && このテンプレートが使えるならAtcoder)*/\n#include <boost/sort/pdqsort/pdqsort.hpp>\n#define fast_sort boost::sort::pdqsort\n#endif\n#endif\n\n\n#ifndef _DEBUG\n#ifndef UNTITLED15_TEMPLATE_H\n#define UNTITLED15_TEMPLATE_H\n\n#ifdef _DEBUG\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#ifndef fast_sort\n#define fast_sort sort\n#endif\n\n\n//#define use_pq\n#define use_for\n#define use_for_each\n#define use_sort\n#define use_fill\n#define use_rand\n#define use_mgr\n#define use_rui\n#define use_compress\n//\n//\n//\n//\n//\n//\n#define use_pbds\n#ifdef use_pbds\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate<class T, class U, class W, class X> auto count(__gnu_pbds::gp_hash_table<T, U, W> &a, X k) { return a.find(k) != a.end(); }\n#endif\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*@formatter:off*/\n#define ll long long\nusing sig_dou = double;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define mt make_tuple\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n\n\ntemplate<class T,class U> auto max(T a, U b){return a>b ? a: b;}\ntemplate<class T,class U> auto min(T a, U b){return a<b ? a: b;}\n//optional<T>について下でオーバーロード(nullopt_tを左辺右辺について単位元として扱う)\ntemplate<class T, class U> bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U> bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\n\n//メタ系 meta\ntemplate<typename T, typename U = typename T::value_type>std::true_type value_type_tester(signed);\ntemplate<typename T>std::false_type value_type_tester(long);\n\ntemplate<typename T>struct has_value_type: decltype(value_type_tester<T>(0)){};\n\n\n//A<T>でTを返す\ntemplate<class T>using decl_t = typename T::value_type;\n//A<B<.....T>>でTを返す\ntemplate<class T, bool end = !has_value_type<T>::value> struct decl2_ {typedef T type;};\ntemplate<class T> struct decl2_<T, false> {typedef typename decl2_<decl_t<T>>::type type;};\ntemplate<class T> using decl2_t = typename decl2_<T>::type;\n//#define decl_max(a, b) decltype(max(MAX<decltype(a)>(), MAX<decltype(b)>()))\n#define is_same2(T, U) is_same<T, U>::value\ntemplate<class T>struct is_vector : std::false_type{};\ntemplate<class T>struct is_vector<std::vector<T>> : std::true_type{};\n\n//大きい型を返す max_type<int, char>::type\n//todo mintがlong long より小さいと判定されるためバグる\ntemplate<class T1, class T2, bool t1_bigger = (sizeof(T1) > sizeof(T2))>struct max_type{typedef T1 type;};\ntemplate<class T1, class T2> struct max_type<T1, T2, false>{typedef T2 type;};\n\ntemplate<class T> struct vec_rank : integral_constant<int, 0> {};\ntemplate<class T> struct vec_rank<vector<T>> : integral_constant<int, vec_rank<T>{} + 1> {};\n\n//N個のTを並べたtupleを返す\n//tuple_n<3, int>::type  tuple<int, int, int>\ntemplate<size_t N, class T, class... Arg> struct tuple_n{typedef typename tuple_n<N-1, T, T,  Arg...>::type type;};\ntemplate<class T, class...Arg> struct tuple_n<0, T, Arg...>{typedef tuple<Arg...> type;};\n\nstruct dummy_t1{};struct dummy_t2{};\nstruct dummy_t3{};struct dummy_t4{};\nstruct dummy_t5{};struct dummy_t6{};\n//template<class T, require(is_integral<T>::value)>など\n#define require_t(bo) enable_if_t<bo>* = nullptr\n\n//複数でオーバーロードする場合、引数が同じだとうまくいかないため\n//require_arg(bool, dummy_t1)\n//require_arg(bool, dummy_t2)等とする\n#define require_arg1(bo) enable_if_t<bo> * = nullptr\n#define require_arg2(bo, dummy_type) enable_if_t<bo, dummy_type> * = nullptr\n#define require_arg(...) over2(__VA_ARGS__,require_arg2,require_arg1)(__VA_ARGS__)\n//->//enable_if_tのtを書き忘れそうだから\n#define require_ret(bo, ret_type) enable_if_t<bo, ret_type>\n\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\nvoid assert2(bool b,const string& s = \"\"){    if(!b){        cerr<<s<<endl;        exit(1);/*assert(0);*/    }}\n\n//my_nulloptをあらゆる操作の単位元的な物として扱う\n//vectorの参照外時に返したり、右辺値として渡されたときに何もしないなど\nstruct my_nullopt_t {} my_nullopt;\n#define nullopt_t my_nullopt_t\n#define nullopt my_nullopt\n/*@formatter:off*/\n//値が無いときは、setを使わない限り代入できない\n//=を使っても無視される\ntemplate<class T> struct my_optional {\nprivate:\n    bool is_null;\n    T v;\npublic:\n    typedef T value_type ;\n    my_optional() : is_null(true) {}\n    my_optional(const nullopt_t&) : is_null(true) {}\n    my_optional(const T& v) : v(v), is_null(false) {}\n    bool has_value() const { return !is_null; }\n    T &value() { static string mes = \"optional has no value\";assert2(!is_null, mes);return v;}\n    const T &value() const { static string mes = \"optional has no value\";assert2(!is_null, mes);return v;}\n    void set(const T &nv) {is_null = false;v = nv;}\n    template<class U> void operator=(const U &v) {\n        set(v);//null状態でも代入出来るようにした\n//        if (has_value())value() = v; else return;\n    }\n    template<class U> void operator=(const my_optional<U> &v) {\n        if (/*has_value() && */v.has_value())(*this) = v; else return;\n    }\n    /*@formatter:off*/\n    void reset() { is_null = true; }\n    void operator=(const nullopt_t &) { reset(); }\n    template<require_t(!is_same2(T, bool))>\n    explicit operator bool(){return !is_null;}\n    //nullの時はエラー\n    operator T&(){return value();}\n    operator const T&()const {return value();}\n    my_optional<T> operator++() {        if (this->has_value()) {            this->value()++;            return *this;        } else {            return *this;        }    }\n    my_optional<T> operator++(signed) {        if (this->has_value()) {            auto tem = *this;            this->value()++;            return tem;        } else {            return *this;        }    }\n    my_optional<T> operator--() {        if (this->has_value()) {            this->value()--;            return *this;        } else {            return *this;        }    }\n    my_optional<T> operator--(signed) {        if (this->has_value()) {            auto tem = *this;            this->value()--;            return tem;        } else {            return *this;        }    }\n};\ntemplate<class T>istream &operator>>(istream &iss, my_optional<T>& v) {    T val;    iss>>val;    v.set(val);    return iss;}\n\n\n#define optional my_optional\ntemplate<class T>\nusing opt = my_optional<T>;\n//template<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\ntemplate<class Key, class T, class Compare = less<Key>, class Allocator = allocator<pair<const Key, T> >>\nstruct o_map : std::map<Key, optional<T>, Compare, Allocator> {\n    optional<T> emp;\n    o_map() : std::map<Key, optional<T>, Compare, Allocator>() {}\n    auto operator()(const nullopt_t&) {return nullopt;}\n    optional<T> &operator()(const optional<Key> &k) {if (k.has_value()) {return std::map<Key, optional<T>, Compare, Allocator>::operator[](k.value());} else {emp.reset();return emp;}}\n    optional<T> &operator()(const Key &k) {        auto &v = std::map<Key, optional<T>, Compare, Allocator>::operator[](k);        if (v.has_value())return v;        else {            v.set(0);            return v;        }    }\n    template<class U> void operator[](U){static string mes = \"s_map cant []\";assert2(0, mes);}\n};\n//以下、空のoptionalをnulloptと書く\n//ov[-1(参照外)] でnulloptを返す\n//ov[nullopt] で nulloptをかえす\n\ntemplate<class T> struct ov{\n    optional<T> emp;\n    vector<optional<T>> v;\n    ov(int i = 0, T val = 0):v(i, val){}\n    template<class U>ov(const U& rhs){v.resize(sz(rhs));for (int i  = 0; i  < sz(rhs); i ++)v[i].set(rhs[i]);}\n    optional<T> &operator()(int i) {if (i < 0 || sz(v) <= i) {emp.reset();return emp;} else { return v[i]; }}\n    optional<T> &operator()(const nullopt_t &) {        return operator()(-1);    }\n    optional<T> &operator()(const optional<T> &i) {        if (i.has_value())return operator()(i.value());        else {            return operator()(-1);        }    }\n/*@formatter:off*/\n};\ntemplate<class T>string deb_tos(const ov<T>& v){\n    return deb_tos(v.v);\n}\n\n//vectorに対しての処理は.vを呼ぶ\ntemplate<class T> class ovv{\n    optional<T> emp;\npublic:\n    vector<vector<optional<T>> > v ;\n    ovv(int i=0, int j=0, T val = 0) : v(i, vector<optional<T>>(j, val) ){}\n    optional<T> &operator()(int i, int j) {        if (i < 0 || j < 0 || sz(v) <= i || sz(v[i]) <= j) {            emp.reset();return emp;        }        else { return v[i][j]; }    }\n    //再帰ver 遅いと思う\n//    optional<T>& gets(optional<T>& v){return v;}\n//    template<class V, class H, class... U> optional<T>& gets(V& v, H i, U... tail){        if constexpr(is_same2(H, nullopt_t))return operator()(-1,-1);        else if constexpr(is_same2(H, optional<int>)){            if(i.has_value())return gets(v[(int)i], tail...);            else return operator()(-1,-1);        }else if constexpr(is_integral<H>::value){            return gets(v[(int)i], tail...);        }else{            assert(0);            return emp;        }    }\n#if __cplusplus >= 201703L\n    //if constexprバージョン 上が遅かったらこれで\n    template<class U, class V> optional<T> &operator()(const U &i, const V &j) {        /*駄目な場合を除外*/        if constexpr(is_same2(U, nullopt_t) || is_same2(U, nullopt_t)) {            return operator()(-1, -1);            /* o, o*/        } else if constexpr(is_same2(U, optional<int>) && is_same2(V, optional<int>)) {            return operator()(i.has_value() ? (int) i : -1, j.has_value() ? (int) j : -1);            /* o, x*/        } else if constexpr(is_same2(U, optional<int>)) {            return operator()(i.has_value() ? (int) i : -1, (int) j);            /* x, o*/        } else if constexpr(is_same2(V, optional<int>)) {            return operator()((int) i, j.has_value() ? (int) j : -1);            /* x, x*/        } else {            return operator()((int) i, (int) j);        }    }\n#endif\n    operator const vector<vector<optional<T>> >&(){\n        return v;\n    }\n};\ntemplate<class T>istream &operator>>(istream &iss, ovv<T> &a) {    for (int h  = 0; h  < sz(a); h ++){        for (int w  = 0; w  < sz(a[h]); w ++){            iss>>a.v[h][w ];        }    }    return iss;}\n\ntemplate<class T>string deb_tos(const ovv<T>& v){\n    return deb_tos(v.v);\n}\ntemplate<class T> struct ov3{\n    optional<T> emp;\n    vector<vector<vector<optional<T>>> > v ;\n    ov3(int i, int j, int k, T val = 0) : v(i, vector<vector<optional<T>>>(j, vector<optional<T>>(k, val) ) ){}\n    optional<T> &operator()(int i, int j, int k) {        if (i < 0 || j < 0 || sz(v) <= i || sz(v[i]) <= j) {            if(k < 0 || sz(v[i][j]) <= k){                emp.reset();                return emp;            }        }        return v[i][j][k];    }\nprivate:\n#if __cplusplus >= 201703L\n    //再帰ver 遅いと思う\n    template<class V, class H> optional<T> &gets(V &nowv, H i) {        if constexpr(is_same2(H, nullopt_t)) {            emp.reset(); return emp;        } else if constexpr(is_same2(H, optional<int>)) {            if (i.has_value()) {                return nowv[(int) i];            } else {                emp.reset();return emp;            }        } else if constexpr(is_integral<H>::value) {            return nowv[(int) i];        } else {            static string mes = \"ov3 error not index\";assert2(0, mes);            emp.reset();return emp;        }    }\n    //todo const &消した\n    template<class V, class H, class... U> optional<T> &gets(V &nowv, H i, U... tail) {        if constexpr(is_same2(H, nullopt_t)) {            emp.reset();return emp;        } else if constexpr(is_same2(H, optional<int>)) {            if (i.has_value()) {                return gets(nowv[(int) i], tail...);            } else {                emp.reset();return emp;            }        } else if constexpr(is_integral<H>::value) {            return gets(nowv[(int) i], tail...);        } else {            static string mes = \"ov3 error not index\";assert2(0, mes);            emp.reset();return emp;        }    }\n#endif\npublic:\n    template<class U, class V, class W> optional<T> &operator()(U i, V j, W k) {        return gets(v, i, j, k);    }\n/*@formatter:off*/\n};\ntemplate<class T>string deb_tos(const ov3<T>& v){\n    return deb_tos(v.v);\n}\n//nullopt_t\n//優先順位\n//null, [opt, tem]\n\n// + と += は違う意味を持つ\n//val+=null : val\n//val+null  : null\n//\n//+は途中計算\n//+=は最終的に格納したい値にだけ持たせる\n//+=がvoidを返すのは、途中計算で使うのを抑制するため\n\n//nulloptを考慮する際、計算途中では+を使ってnulloptを作り\n//格納する際は+=で無効にする必要がある\n\n//演算子==\n//optional<int>(10) == 10\n\n//全ての型に対応させ、value_typeが等しいかを見るようにするのもありかも\n\n//null同士を比較する状況はおかしいのではないか\nbool operator==(const nullopt_t &, const nullopt_t&){assert2(0, \"nul == null  cant hikaku\");return false;}\ntemplate<class T> bool operator==(const nullopt_t &, const T&){return false;}\ntemplate<class T> bool operator!=(const nullopt_t &, const T&){return true;}\ntemplate<class T> bool operator==(const T&, const nullopt_t &){return false;}\ntemplate<class T> bool operator!=(const T&, const nullopt_t &){return true;}\n//nullを\n\nnullopt_t& operator +(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator -(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator *(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator /(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator +=(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator -=(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator *=(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator /=(const nullopt_t &, const nullopt_t&) {return nullopt;}\n\ntemplate<class ANY> nullopt_t operator+(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator-(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator*(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator/(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator+(const ANY &, const nullopt_t &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator-(const ANY &, const nullopt_t &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator*(const ANY &, const nullopt_t &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator/(const ANY &, const nullopt_t &) {return nullopt;}\n\ntemplate<class ANY> void operator+=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator-=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator*=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator/=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator+=(ANY &, const nullopt_t &) {}\ntemplate<class ANY> void operator-=(ANY &, const nullopt_t &) {}\ntemplate<class ANY> void operator*=(ANY &, const nullopt_t &) {}\ntemplate<class ANY> void operator/=(ANY &, const nullopt_t &) {}\n\ntemplate<class T>struct is_optional:false_type{};\ntemplate<class T>struct is_optional<optional<T>>:true_type{};\ntemplate<class T, class U>\ntrue_type both_optional(optional<T> t, optional<U> u);\nfalse_type both_optional(...);\n\ntemplate<class T, class U> class opt_check : public decltype(both_optional(declval<T>(), declval<U>())) {};\n\n//optionalは同じ型同士しか足せない\n//(o, t), (t, o), (o, o)\n#define opt_tem(op) \\\ntemplate<class O, class O_ret = decltype(declval<O>() op declval<O>())>optional<O_ret> operator op(const optional<O> &opt1, const optional<O> &opt2) {    if (!opt1.has_value() || !opt2.has_value()) { return optional<O_ret>(); }    else {        return optional<O_ret>(opt1.value() op opt2.value());    }}\\\ntemplate<class O, class T, class O_ret = decltype(declval<O>() op declval<O>())> auto operator op(const optional<O> &opt, const T &tem) -> require_ret(!(opt_check<optional<O>, T>::value), optional<O_ret>) {    if (!opt.has_value()) { return optional<O_ret>(); }    else {        return optional<O_ret>(opt.value() op tem);    }}\\\ntemplate<class O, class T, class O_ret = decltype(declval<O>() op declval<O>())> auto operator op(const T &tem, const optional<O> &opt) -> require_ret(!(opt_check<optional<O>, T>::value), optional<O_ret>) {    if (!opt.has_value()) { return optional<O_ret>(); }    else {        return optional<O_ret>(opt.value() op tem);    }}\n/*@formatter:off*/\nopt_tem(+)opt_tem(-)opt_tem(*)opt_tem(/)\n//比較はoptional<bool>を返す\nopt_tem(<)opt_tem(>)opt_tem(<=)opt_tem(>=)\n\n/*@formatter:on*//*@formatter:off*/\n\ntemplate<class O, class T> bool operator==(const optional<O>& opt, const T& tem){if(opt.has_value()){return opt.value()==tem;}else return nullopt == tem;}\ntemplate<class O, class T> bool operator!=(const optional<O>& opt, const T& tem){if(opt.has_value()){return opt.value()!=tem;}else return nullopt != tem;}\ntemplate<class O, class T> bool operator==(const T& tem, const optional<O>& opt){if(opt.has_value()){return opt.value()==tem;}else return nullopt == tem;}\ntemplate<class O, class T> bool operator!=(const T& tem, const optional<O>& opt){if(opt.has_value()){return opt.value()!=tem;}else return nullopt != tem;}\n\n\ntemplate<class O> bool operator==(const optional<O>& opt1, const optional<O>& opt2){    if(opt1.has_value() != opt2.has_value()){        return false;    }else if(opt1.has_value()){        return opt1.value() == opt2.value();    }else {        return nullopt == nullopt;    }}\ntemplate<class O> bool operator!=(const optional<O>& opt1, const optional<O>& opt2){return !(opt1 == opt2);}\n\n//(a+=null) != (a=a+null)\n// a            null\ntemplate<class T, class O> void operator+=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem += opt.value(); }}\ntemplate<class T, class O> void operator-=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem -= opt.value(); }}\ntemplate<class T, class O> void operator*=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem *= opt.value(); }}\ntemplate<class T, class O> void operator/=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem /= opt.value(); }}\n\ntemplate<class T, class O> void operator+=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() += tem; }}\ntemplate<class T, class O> void operator-=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() -= tem; }}\ntemplate<class T, class O> void operator*=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() *= tem; }}\ntemplate<class T, class O> void operator/=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() /= tem; }}\n//\ntemplate<class Ol, class Or> void operator+=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl += opr.value(); }}\ntemplate<class Ol, class Or> void operator-=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl -= opr.value(); }}\ntemplate<class Ol, class Or> void operator*=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl *= opr.value(); }}\ntemplate<class Ol, class Or> void operator/=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl /= opr.value(); }}\n\n/*@formatter:off*/\n\ntemplate<class U> auto max(const nullopt_t &, const U &val) { return val; }\ntemplate<class U> auto max(const U &val, const nullopt_t &) { return val; }\ntemplate<class U> auto min(const nullopt_t &, const U &val) { return val; }\ntemplate<class U> auto min(const U &val, const nullopt_t &) { return val; }\n\ntemplate<class T, class U> auto max(const optional<T> &opt, const U &val) { if (opt.has_value())return max(opt.value(), val); else return val; }\ntemplate<class T, class U> auto max(const U &val, const optional<T> &opt) { if (opt.has_value())return max(opt.value(), val); else return val; }\ntemplate<class T, class U> auto min(const optional<T> &opt, const U &val) { if (opt.has_value())return min(opt.value(), val); else return val; }\ntemplate<class T, class U> auto min(const U &val, const optional<T> &opt) { if (opt.has_value())return min(opt.value(), val); else return val; }\n\n//null , optional, T\nbool chma(nullopt_t &, const nullopt_t &) { return false; }\ntemplate<class T> bool chma(T &opt, const nullopt_t &) { return false; }\ntemplate<class T> bool chma(nullopt_t &, const T &opt) { return false; }\ntemplate<class T> bool chma(optional<T> &olv, const optional<T> &orv) { if (orv.has_value()) { return chma(olv, orv.value()); } else return false; }\ntemplate<class T, class U> bool chma(optional<T> &opt, const U &rhs) { if (opt.has_value()) { return chma(opt.value(), rhs); } else return false; }\ntemplate<class T, class U> bool chma(T &lhs, const optional<U> &opt) { if (opt.has_value()) { return chma(lhs, opt.value()); } else return false; }\n\nbool chmi(nullopt_t &, const nullopt_t &) { return false; }\ntemplate<class T> bool chmi(T &opt, const nullopt_t &) { return false; }\ntemplate<class T> bool chmi(nullopt_t &, const T &opt) { return false; }\ntemplate<class T> bool chmi(optional<T> &olv, const optional<T> &orv) { if (orv.has_value()) { return chmi(olv, orv.value()); } else return false; }\ntemplate<class T, class U> bool chmi(optional<T> &opt, const U &rhs) { if (opt.has_value()) { return chmi(opt.value(), rhs); } else return false; }\ntemplate<class T, class U> bool chmi(T &lhs, const optional<U> &opt) { if (opt.has_value()) { return chmi(lhs, opt.value()); } else return false; }\n\n\ntemplate<class T> ostream &operator<<(ostream &os, optional<T> p) {    if (p.has_value())os << p.value(); else os << \"e\";    return os;}\ntemplate<class T>using opt = my_optional<T>;\nstruct xorshift {\n    /*@formatter:on*/\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    /*@formatter:off*/\n    size_t operator()(const uint64_t& x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }\n    size_t operator()(const std::pair<ll, ll>& x) const {        ll v = ((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }\n    template<class T, class U> size_t operator()(const std::pair<T, U>& x) const{        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        uint64_t hasx = splitmix64(x.first);        uint64_t hasy = splitmix64(x.second + FIXED_RANDOM);        return hasx ^ hasy;    }\n    template<class T> size_t operator()(const vector<T> &x) const {        uint64_t has = 0;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        uint64_t rv = splitmix64(FIXED_RANDOM);        for (int i  = 0; i  < sz(x); i ++){            uint64_t v = splitmix64(x[i] + rv);            has ^= v;            rv = splitmix64(rv);        }        return has;    }\n};\n\n#ifdef _DEBUG\nstring message;\nstring res_mes;\n//#define use_debtor\n//template<class T, class U, class X> auto count(unordered_map<T, U> &a, X k) { return a.find(k) != a.end(); }\n\n#ifdef use_debtor\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {        cerr << a.size() << \" \";        return deb_v(a.at(0), v + 1);    }\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {        for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }        if ((int) a.size() > 15) { cerr << \"...\"; }        cerr << endl;    }\n    typename std::vector<T>::reference my_at(typename std::vector<T>::size_type n, vector<int> &ind) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            ind.push_back(n);            cerr << \"out index at  \";            for (auto &&i: ind) {                cerr << i << \" \";            }            cerr << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n};\n#define vector debtor\n#endif\n#ifdef use_pbds\ntemplate<class T> struct my_pbds_tree {\n    set<T> s;\n    auto begin() { return s.begin(); }\n    auto end() { return s.end(); }\n    auto rbegin() { return s.rbegin(); }\n    auto rend() { return s.rend(); }\n    auto empty() { return s.empty(); }\n    auto size() { return s.size(); }\n    void clear() { s.clear(); }\n    template<class U> void insert(U v) { s.insert(v); }\n    template<class U> void operator+=(U v) { insert(v); }\n    template<class F> auto erase(F v) { return s.erase(v); }\n    template<class U> auto find(U v) { return s.find(v); }\n    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }\n    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }\n    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }\n    auto order_of_key(ll v) {        auto it = s.begin();        ll i = 0;        for (; it != s.end() && *it < v; i++)it++;        return i;    }\n};\n#define pbds(T) my_pbds_tree<T>\n#endif\n\n//区間削除は出来ない\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T, class U> struct my_unordered_map { unordered_map<T, U> m; my_unordered_map() {}; auto begin() { return m.begin(); } auto end() { return m.end(); } auto cbegin() { return m.cbegin(); } auto cend() { return m.cend(); } template<class V> auto erase(V v) { return m.erase(v); } void clear() { m.clear(); }    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V> auto find(V v) { return m.find(v); } template<class V> auto &operator[](V n) { return m[n]; }};\ntemplate<class K, class V>using umap_f = my_unordered_map<K, V>;\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\ntemplate<class K, class V>using umap_f = __gnu_pbds::gp_hash_table<K, V, xorshift>;\n#endif\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umappp unordered_map<P,P>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\n\ntemplate<class T, class U, class X> auto count(unordered_map<T, U> &a, X k) { return a.find(k) != a.end(); }\n/*@formatter:off*/\n#ifdef use_pbds\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n#endif\n//衝突対策\n#define ws ws_\n\n//todo 要らないと思う\ntemplate<class A, class B, class C> struct T2 { A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const { return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   } bool operator>(const T2 &r) const { return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   } bool operator==(const T2 &r) const { return f == r.f && s == r.s && t == r.t; } bool operator!=(const T2 &r) const { return f != r.f || s != r.s || t != r.t; }};\ntemplate<class A, class B, class C, class D> struct F2 {\n    A a;B b;C c;D d;\n    F2() { a = 0, b = 0, c = 0, d = 0; }\n    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F2 &r) const { return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }\n    bool operator>(const F2 &r) const { return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }\n    bool operator==(const F2 &r) const { return a == r.a && b == r.b && c == r.c && d == r.d; }\n    bool operator!=(const F2 &r) const { return a != r.a || b != r.b || c != r.c || d != r.d; }\n    ll operator[](ll i) {assert(i < 4);return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;}\n};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\n//T mt(ll a, ll b, ll c) { return T(a, b, c); }\n//F mf(ll a, ll b, ll c, ll d) { return F(a, b, c, d); }\n\n//関数内をまとめる\n//初期値l=-1, r=-1\nvoid set_lr12(int &l, int &r, int n) {    /*r==-1*/    if (r == -1) {        if (l == -1) {            l = 0;            r = n;        } else {            r = l;            l = 0;        }    }}\n//@マクロ省略系 型,構造\n//using で元のdoubleを同時に使えるはず\n#define double_big\n\n#ifdef double_big\n#define double long double\n//#define pow powl\n#endif\nusing dou = double;\n\n/*@formatter:off*/\ntemplate<class T> T MAX() { return numeric_limits<T>::max(); }\ntemplate<class T> T MIN() { return numeric_limits<T>::min(); }\nconstexpr ll inf = (ll) 1e9 + 100;\nconstexpr ll linf = (ll) 1e18 + 100;\nconstexpr dou dinf = (dou) linf * linf;\nconstexpr char infc = '{';\nconst string infs = \"{\";\n\ntemplate<class T> T INF() { return MAX<T>() / 2; }\ntemplate<> signed INF() { return inf; }\ntemplate<> ll INF() { return linf; }\ntemplate<> double INF() { return dinf; }\ntemplate<> char INF() { return infc; }\ntemplate<> string INF() { return infs; }\n\nconst double eps = 1e-9;\n\n//#define use_epsdou\n#ifdef use_epsdou\n//基本コメントアウト\nstruct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) {auto r = (double)b;        return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};\ntemplate<>epsdou MAX(){return MAX<double>();}\ntemplate<>epsdou MIN(){return MIN<double>();}\n//priqrity_queue等で使うのに必要\nbool operator<(const epsdou &a, const epsdou &b) {return a.v < b.v;}\nbool operator>(const epsdou &a, const epsdou &b) {return a.v > b.v;}\nistream &operator>>(istream &iss, epsdou &a) {iss >> a.v;return iss;}\nostream &operator<<(ostream &os, epsdou &a) {os << a.v;return os;}\n#define eps_conr_t(o) template<class T> epsdou operator o(T a, epsdou b) {return (dou) a o b.v;}\n#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b) {return a.v o (dou) b;}\neps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\n//template<class U> epsdou max(epsdou a, U b){return a.v>b ? a.v: b;}\n//template<class U> epsdou max(U a, epsdou b){return a>b.v ? a: b.v;}\n//template<class U> epsdou min(epsdou a, U b){return a.v<b ? a.v: b;}\n//template<class U> epsdou min(U a, epsdou b){return a<b.v ? a: b.v;}\n#undef double\n#define double epsdou\n#undef dou\n#define dou epsdou\n#endif\n\ntemplate<class T = int, class A, class B = int> T my_pow(A a, B b = 2) {\n    if(b < 0)return (T)1 / my_pow<T>(a, -b);\n#if __cplusplus >= 201703L\n    if constexpr(is_floating_point<T>::value) { return pow((T) a, (T) b); }\n    else if constexpr(is_floating_point<A>::value) { assert2(0, \"pow <not dou>(dou, )\");/*return 0;しない方がコンパイル前に(voidを受け取るので)エラーが出ていいかも*/}\n    else if constexpr(is_floating_point<B>::value) { assert2(0, \"pow <not dou>(, dou)\");/*return 0;しない方がコンパイル前に(voidを受け取るので)エラーが出ていいかも*/}\n    else {\n#endif\n        T ret = 1;        T bek = a;        while (b) {            if (b & 1)ret *= bek;            bek *= bek;            b >>= 1;        }        return ret;\n#if __cplusplus >= 201703L\n    }\n#endif\n}\n#define pow my_pow\n\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto&& v){return ret;}\n#define lam2(v, ret) [&](auto&& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto&& p){return p right;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t, a) vector<vector<t>>a\n#define vvt2(t, a, b) vector<vector<t>>a(b)\n#define vvt3(t, a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t, a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type, ...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type, name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_, v1_, v2_, v3_;\n\n/*@formatter:off*/\nstring to_string(char c) {    string ret = \"\";    ret += c;    return ret;}\ntemplate<class T> class pq_min_max {    vector<T> d;    void make_heap() {        for (int i = d.size(); i--;) {            if (i & 1 && d[i - 1] < d[i]) swap(d[i - 1], d[i]);            int k = down(i);            up(k, i);        }    }    inline int parent(int k) const { return ((k >> 1) - 1) & ~1; }    int down(int k) {        int n = d.size();        if (k & 1) { /* min heap*/            while (2 * k + 1 < n) {                int c = 2 * k + 3;                if (n <= c || d[c - 2] < d[c]) c -= 2;                if (c < n && d[c] < d[k]) {                    swap(d[k], d[c]);                    k = c;                }                else break;            }        }        else { /* max heap*/            while (2 * k + 2 < n) {                int c = 2 * k + 4;                if (n <= c || d[c] < d[c - 2]) c -= 2;                if (c < n && d[k] < d[c]) {                    swap(d[k], d[c]);                    k = c;                }                else break;            }        }        return k;    }    int up(int k, int root = 1) {        if ((k | 1) < (int) d.size() && d[k & ~1] < d[k | 1]) {            swap(d[k & ~1], d[k | 1]);            k ^= 1;        }        int p;        while (root < k && d[p = parent(k)] < d[k]) { /*max heap*/            swap(d[p], d[k]);            k = p;        }        while (root < k && d[k] < d[p = parent(k) | 1]) { /* min heap*/            swap(d[p], d[k]);            k = p;        }        return k;    }public:    pq_min_max() {}    pq_min_max(const vector<T> &d_) : d(d_) { make_heap(); }    template<class Iter> pq_min_max(Iter first, Iter last) : d(first, last) { make_heap(); }    void operator+=(const T &x) {        int k = d.size();        d.push_back(x);        up(k);    }    void pop_min() {        if (d.size() < 3u) { d.pop_back(); }        else {            swap(d[1], d.back());            d.pop_back();            int k = down(1);            up(k);        }    }    void pop_max() {        if (d.size() < 2u) { d.pop_back(); }        else {            swap(d[0], d.back());            d.pop_back();            int k = down(0);            up(k);        }    }    const T &get_min() const { return d.size() < 2u ? d[0] : d[1]; }    const T &get_max() const { return d[0]; }    int size() const { return d.size(); }    bool empty() const { return d.empty(); }};\n//小さいほうからM個取得するpq\ntemplate<class T> struct helper_pq_size {    pq_min_max<T> q;    T su = 0;    int max_size = 0;    helper_pq_size() {}    helper_pq_size(int max_size) : max_size(max_size) {}    void clear() {        q = pq_min_max<T>();        su = 0;    }    void operator+=(T v) {        su += v;        q += (v);        if (sz(q) > max_size) {            su -= q.get_max();            q.pop_max();        }    }    T sum() { return su; }    T top() { return q.get_min(); }    void pop() {        su -= q.get_min();        q.pop_min();    }    T poll() {        T ret = q.get_min();        su -= ret;        q.pop_min();        return ret;    }    ll size() { return q.size(); }};\n//大きいほうからM個取得するpq\ntemplate<class T> struct helper_pqg_size {    pq_min_max<T> q;    T su = 0;    int max_size = 0;    helper_pqg_size() {}    helper_pqg_size(int max_size) : max_size(max_size) {}    void clear() {        q = pq_min_max<T>();        su = 0;    }    void operator+=(T v) {        su += v;        q += (v);        if (sz(q) > max_size) {            su -= q.get_min();            q.pop_min();        }    }    T sum() { return su; }    T top() { return q.get_max(); }    void pop() {        su -= q.get_max();        q.pop_max();    }    T poll() {        T ret = q.get_max();        su -= ret;        q.pop_min();        return ret;    }    ll size() { return q.size(); }};;\n\ntemplate<class T, class Container = vector<T>,class Compare = std::less<typename Container::value_type>>\nstruct helper_pqg {    priority_queue<T, Container, Compare> q;/*小さい順*/    T su = 0;    helper_pqg() {}    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }    void operator+=(T v) {        su += v;        q.push(v);    }    T sum() { return su; }    T top() { return q.top(); }    void pop() {        su -= q.top();        q.pop();    }    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }    ll size() { return q.size(); }};\ntemplate<class T>\nusing  helper_pq = helper_pqg<T, vector<T>, greater<T>>;\n#if __cplusplus >= 201703L\n\n//小さいほうからsize個残る\n//Tがoptionalなら空の時nullを返す\ntemplate<class T> struct pq {\n    helper_pq<T> a_q;/*大きい順*/    helper_pq_size<T> b_q;/*大きい順*/    bool aquery;\n    T su = 0;\n    pq(int size = inf) {aquery = size == inf;if (!aquery) { b_q = helper_pq_size<T>(size); }}\n    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }\n    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }\n    //optionalなら空の時nullを返す\n    T top() {        if constexpr(is_optional<T>::value) {            if (aquery) {                if (sz(a_q) == 0)return T();                return a_q.top();            }            else {                if (sz(b_q) == 0)return T();                return b_q.top();            }        }        else { if (aquery)return a_q.top(); else return b_q.top(); }    }\n    T sum() { if (aquery) return a_q.sum(); else return b_q.sum(); }\n    //optionalなら空の時何もしない\n    void pop() { if constexpr(is_optional<T>::value) { if (aquery) { if (sz(a_q))a_q.pop(); } else { if (sz(b_q))b_q.pop(); }} else { if (aquery)a_q.pop(); else b_q.pop(); }}    /*T*/\n    T poll() {        if constexpr(is_optional<T>::value) {            if (aquery) {                if (sz(a_q) == 0)return T();                return a_q.poll();            }            else {                if (sz(b_q) == 0)return T();                return b_q.poll();            }        }        else { if (aquery)return a_q.poll(); else return b_q.poll(); }    }\n    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }\n    /*@formatter:off*/\n};\ntemplate<class T> struct pqg {    helper_pqg<T> a_q;/*大きい順*/    helper_pqg_size<T> b_q;/*大きい順*/    bool aquery;    T su = 0;    pqg(int size = inf) {        aquery = size == inf;        if (!aquery) { b_q = helper_pqg_size<T>(size); }    }    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }    T sum() { if (aquery)return a_q.sum(); else return b_q.sum(); }    T top() { if (aquery) return a_q.top(); else return b_q.top(); }    void pop() { if (aquery) a_q.pop(); else b_q.pop(); }    T poll() { if (aquery) return a_q.poll(); else return b_q.poll(); }    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }};\n#else\n//小さいほうからsize個残る\ntemplate<class T> struct pq {    helper_pq<T> a_q;/*大きい順*/    helper_pq_size<T> b_q;/*大きい順*/    bool aquery;    T su = 0;    pq(int size = inf) {        aquery = size == inf;        if (!aquery) { b_q = helper_pq_size<T>(size); }    }    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }    T sum() { if (aquery)return a_q.sum(); else return b_q.sum(); }    T top() { if (aquery) return a_q.top(); else return b_q.top(); }    void pop() { if (aquery) a_q.pop(); else b_q.pop(); }    T poll() { if (aquery) return a_q.poll(); else return b_q.poll(); }    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }};\n//大きいほうからsize個残る\ntemplate<class T> struct pqg {    helper_pqg<T> a_q;/*大きい順*/    helper_pqg_size<T> b_q;/*大きい順*/    bool aquery;    T su = 0;    pqg(int size = inf) {        aquery = size == inf;        if (!aquery) { b_q = helper_pqg_size<T>(size); }    }    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }    T sum() { if (aquery)return a_q.sum(); else return b_q.sum(); }    T top() { if (aquery) return a_q.top(); else return b_q.top(); }    void pop() { if (aquery) a_q.pop(); else b_q.pop(); }    T poll() { if (aquery) return a_q.poll(); else return b_q.poll(); }    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }};\n#endif\n#define pqi pq<ll>\n#define pqgi pqg<ll>\ntemplate<class T> string deb_tos(pq<T> &q) {    vector<T> res;    auto temq = q;    while (sz(temq))res.push_back(temq.top()), temq.pop();    stringstream ss;    ss<< res;    return ss.str();}\ntemplate<class T> string deb_tos(pqg<T> &q) {    vector<T> res;    auto temq = q;    while (sz(temq))res.push_back(temq.top()), temq.pop();    stringstream ss;    ss<< res;    return ss.str();}\n\n/*@formatter:off*/\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n//todo 使わないもの非表示\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n\n#ifdef use_for\n\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\ntemplate<class T> void nex_repv2(int &i, int &j, int &I, int &J, vector<vector<T>> &s) {    while (1) {        j++;        if (j >= J) {            j = 0;            i++;            if (i < I) { J = (int) s[i].size(); }        }        if (i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i, a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), i = 0, j = 0; i < repvI; nex_repv2(i,j,repvI,repvJ,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), repvK =(int)a[0][0].size(), i = 0, j = 0, k=0; i < repvI; nex_repv3(i,j,k,repvI,repvJ,repvK,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n#endif\n\ntemplate<typename T> struct has_rbegin_rend { private:template<typename U> static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value; };\ntemplate<typename T> constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;\ntemplate<typename Iterator> class Range { public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept { return m_begin; }Iterator end() const noexcept { return m_end; }private:const Iterator m_begin;const Iterator m_end; };\ntemplate<typename Iterator> static inline Range<Iterator> makeRange(Iterator &&begin, Iterator &&end) noexcept { return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)}; }\ntemplate<typename T> static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept { return makeRange(std::rbegin(iniList), std::rend(iniList)); }\ntemplate<typename T, typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr> static inline decltype(auto) makeReversedRange(T &&c) noexcept { return makeRange(std::rbegin(c), std::rend(c)); }/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T, typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr> static inline void makeReversedRange(T &&) noexcept { static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\"); }\n\n//#define use_for\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define forrm1(st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n#define forrm3(k, v, st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n\n//向こう側で\n// ++itか it = st.erase(it)とする\n#define fors1(st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors2(v, st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors3(v, st, r) for (auto &&it = st.begin(); it != st.end() && (*it) < r; )\n#define fors4(v, st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r; )\n\n#ifdef use_for\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n\n#define fora_f_init_2(a, A) ;\n#define fora_f_init_3(fora_f_i, a, A) auto &&a = A[fora_f_i];\n#define fora_f_init_4(a, b, A, B) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i];\n#define fora_f_init_5(fora_f_i, a, b, A, B) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i];\n#define fora_f_init_6(a, b, c, A, B, C) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i];\n#define fora_f_init_7(fora_f_i, a, b, c, A, B, C) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i];\n#define fora_f_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i]; auto && d = D[fora_f_i];\n#define fora_f_init_9(fora_f_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i]; auto && d = D[fora_f_i];\n#define fora_f_init(...) over9(__VA_ARGS__,fora_f_init_9, fora_f_init_8, fora_f_init_7, fora_f_init_6, fora_f_init_5, fora_f_init_4, fora_f_init_3, fora_f_init_2)(__VA_ARGS__)\n\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n#define forp_init3(k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init4(forp_i, k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init(...) over4(__VA_ARGS__,forp_init4,forp_init3,forp_init2,forp_init1)(__VA_ARGS__)\n\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define forrm_init(k, v, ...) auto &&k = (*forrm_it).fi;auto &&v = (*forrm_it).se;\n#define fors_init(v, ...) auto &&v = (*it);\n\n#define forlr_init(a, A, ngl, ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n\n//こうしないとmapがおかしくなる\n#define fora_f_2(a, A) for(auto&& a : A)\n#define fora_f_3(fora_f_i, a, A) rep(fora_f_i, sz(A))\n#define fora_f_4(a, b, A, B) rep(fora_f_i, sz(A))\n#define fora_f_5(fora_f_i, a, b, A, B) rep(fora_f_i, sz(A))\n#define fora_f_6(a, b, c, A, B, C) rep(fora_f_i, sz(A))\n#define fora_f_7(fora_f_i, a, b, c, A, B, C) rep(fora_f_i, sz(A))\n#define fora_f_8(a, b, c, d, A, B, C, D) rep(fora_f_i, sz(A))\n#define fora_f_9(fora_f_i, a, b, c, d, A, B, C, D) rep(fora_f_i, sz(A))\n\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#endif\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n\n//自分込みで残りがREM以上の間ループを回す\n#define rem(i, N, REM) for (int i = 0; i < N - REM + 1; i++)\n\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n#ifdef use_for\n#define fora_f(...) over9(__VA_ARGS__, fora_f_9, fora_f_8, fora_f_7, fora_f_6, fora_f_5, fora_f_4, fora_f_3, fora_f_2)(__VA_ARGS__)\n#endif\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n//0~N-2まで見る\n\n#define forar_init(v, rv, A) auto &&v = A[forar_i]; auto && rv = A[forar_i+1];\n#define forar(v, rv, A) rep(forar_i, sz(A) - 1)\n\n#if __cplusplus >= 201703L\ntemplate<size_t M_SZ, bool indexed, class Iterator, class T, class U=T, class V=T, class W=T>\nclass ite_vec_merge : public Iterator {    std::size_t i = 0;    vector<T> &A;    vector<U> &B;    vector<V> &C;    vector<W> &D;public :    ite_vec_merge(Iterator ita, vector<T> &A) : Iterator(ita), A(A), B(A), C(A), D(A) {}    ite_vec_merge(Iterator ita, vector<T> &A, vector<U> &B) : Iterator(ita), A(A), B(B), C(A), D(A) {}    ite_vec_merge(Iterator ita, vector<T> &A, vector<U> &B, vector<V> &C) : Iterator(ita), A(A), B(B), C(C), D(A) {}    ite_vec_merge(Iterator ita, vector<T> &A, vector<U> &B, vector<V> &C, vector<W> &D) : Iterator(ita), A(A), B(B), C(C), D(D) {}    auto &operator++() {        ++i;        this->Iterator::operator++();        return *this;    }    auto operator*() const noexcept {        if constexpr(!indexed && M_SZ == 1) { return tuple<T &>(A[i]); }        else if constexpr(!indexed && M_SZ == 2) { return tuple<T &, U &>(A[i], B[i]); }        else if constexpr(!indexed && M_SZ == 3) { return tuple<T &, U &, V &>(A[i], B[i], C[i]); }        else if constexpr(!indexed && M_SZ == 4) { return tuple<T &, U &, V &, W &>(A[i], B[i], C[i], D[i]); }        else if constexpr(indexed && M_SZ == 1) { return tuple<int, T &>(i, A[i]); }        else if constexpr(indexed && M_SZ == 2) { return tuple<int, T &, U &>(i, A[i], B[i]); }        else if constexpr(indexed && M_SZ == 3) { return tuple<int, T &, U &, V &>(i, A[i], B[i], C[i]); }        else if constexpr(indexed && M_SZ == 4) { return tuple<int, T &, U &, V &, W &>(i, A[i], B[i], C[i], D[i]); }        else {            assert(0);            return tuple<int>(i);        }    }};\ntemplate<size_t M_SZ, bool indexed, class T, class U=T, class V=T, class W=T>\nclass vec_merge {    vector<T> &a;    vector<U> &b;    vector<V> &c;    vector<W> &d;public :    vec_merge(vector<T> &a) : a(a), b(a), c(a), d(a) {}    vec_merge(vector<T> &a, vector<U> &b) : a(a), b(b), c(a), d(a) {}    vec_merge(vector<T> &a, vector<U> &b, vector<V> &c) : a(a), b(b), c(c), d(a) {}    vec_merge(vector<T> &a, vector<U> &b, vector<V> &c, vector<W> &d) : a(a), b(b), c(c), d(d) {}    auto begin() const {        if constexpr(M_SZ == 1) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a}; }        else if constexpr(M_SZ == 2) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a, b}; }        else if constexpr(M_SZ == 3) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a, b, c}; }        else if constexpr(M_SZ == 4) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a, b, c, d}; }        else {            assert(0);            return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a};        }    }    auto end() const {        if constexpr(M_SZ == 1) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a}; }        else if constexpr(M_SZ == 2) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a, b}; }        else if constexpr(M_SZ == 3) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a, b, c}; }        else if constexpr(M_SZ == 4) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a, b, c, d}; }        else {            assert(0);            return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a};        }    }};\n#endif\n#define fora_2(a, A) for(auto&& a : A)\n\n#if __cplusplus >= 201703L\n#define fora_3(i, a, A) for(auto[i, a] : vec_merge<1, true, decl_t<decltype(A)>>(A))\n#define fora_4(a, b, A, B) for(auto[a, b] : vec_merge<2, false, decl_t<decltype(A)>, decl_t<decltype(B)>>(A, B))\n#define fora_5(i, a, b, A, B)  for(auto[i, a, b] : vec_merge<2, true, decl_t<decltype(A)>, decl_t<decltype(B)>>(A, B))\n#define fora_6(a, b, c, A, B, C)  for(auto[a, b, c] : vec_merge<3, false, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>>(A, B, C))\n#define fora_7(i, a, b, c, A, B, C)  for(auto[i, a, b, c] : vec_merge<3, true, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>>(A, B, C))\n#define fora_8(a, b, c, d, A, B, C, D) for(auto[a, b, c, d] : vec_merge<4, false, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>, decl_t<decltype(D)>>(A, B, C, D))\n#define fora_9(i, a, b, c, d, A, B, C, D) for(auto[i, a, b, c, d] : vec_merge<4, true, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>, decl_t<decltype(D)>>(A, B, C, D))\n#endif\n//構造化束縛ver\n//1e5要素で40ms程度\n//遅いときはfora_fを使う\n#define fora(...) over9(__VA_ARGS__, fora_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n/*@formatter:off*/\n#ifdef use_for\ntemplate<class U> vector<U> to1d(vector<U> &a) { return a; }\ntemplate<class U> auto to1d(vector<vector<U>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)res.push_back(a2);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<U>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) res.push_back(a3);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<vector<U>>>> &a) {vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)res.push_back(a4);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<vector<vector<U>>>>> &a) {vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)res.push_back(a5);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<vector<vector<vector<U>>>>>> &a) {vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)for (auto &&a6 : a5)res.push_back(a6);    return res;}\n#define forv(a, b) for(auto a : to1d(b))\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n#endif\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forrm(...) over5(__VA_ARGS__,forrm5,forrm4,forrm3,forrm2,forrm1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp3(k, v, st)  rep(forp_i,sz(st))\n#define forp4(forp_i, k, v, st) rep(forp_i,sz(st))\n#define forp(...) over4(__VA_ARGS__,forp4,forp3)(__VA_ARGS__)\n\n//to_vec(rep(i, N))のように使い\n//iが走査した値を持つvectorを返す\n#define to_vec2(type, my_for) \\\n    [&](){                    \\\n        vector<type> ret;     \\\n        my_for{               \\\n            ret.push_back(i); \\\n        }                     \\\n        return ret;           \\\n    }()\n#define to_vec1(my_for) to_vec2(int, my_for)\n#define to_vec(...) over2(__VA_ARGS__,to_vec2,to_vec1)(__VA_ARGS__)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nconst double PI = 3.1415926535897932384626433832795029L;\n\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\n/*@formatter:off*/\nistream &operator>>(istream &iss, P &a) {iss >> a.first >> a.second;return iss;}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec_) {for (T &x: vec_) iss >> x;return iss;}\ntemplate<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {os << p.fi << \" \" << p.se;return os;}\nostream &operator<<(ostream &os, T p) {os << p.f << \" \" << p.s << \" \" << p.t;return os;}\nostream &operator<<(ostream &os, F p) {os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;return os;}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &vec_) {for (ll i = 0; i < vec_.size(); ++i)os << vec_[i] << (i + 1 == vec_.size() ? \"\" : \" \");return os;}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec_) {for (ll i = 0; i < vec_.size(); ++i) {for (ll j = 0; j < vec_[i].size(); ++j) { os << vec_[i][j] << \" \"; }os << endl;}return os;}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {os << endl;for (auto &&v:m) os << v << endl;return os;}\ntemplate<class T> ostream &operator<<(ostream &os, set<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}\ntemplate<class T> ostream &operator<<(ostream &os, mset<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}\ntemplate<class T> ostream &operator<<(ostream &os, deque<T> a) {    fora(v, a) { os << v << \" \"; }    return os;}\nostream &operator<<(ostream &os, vector<vector<char>> &vec_) {    rep(h, sz(vec_)) {        rep(w, sz(vec_[0])) { os << vec_[h][w]; }        os << endl;    }    return os;}\n\ntemplate<class T> struct range_now {\n    int l;\n    vector<T> A;\n    range_now(vector<T>&& A, int l) : A(A), l(l){}\n};\n/*@formatter:off*/\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora_f(v,a)os<<v<<endl;return os;}\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n//#define use_for_each  //_each _all_of _any_of _none_of _find_if _rfind_if _contains _count_if _erase_if _entry_if\n\n#ifdef use_for_each\n//todo Atcoderの過去問がc++17に対応したら\n#if __cplusplus >= 201703L\n//for_each以外はconst & (呼び出し側のラムダも)\ntemplate<typename T, typename F> bool all_of2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : v) { if (!all_of2(v_, f))return false; }        return true;    } else { return f(v); }}\ntemplate<typename T, typename F> bool any_of2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : v) { if (!any_of2(v_, f))return true; }        return false;    } else { return f(v); }}\ntemplate<typename T, typename F> bool none_of2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : v) { if (none_of2(v_, f))return false; }        return true;    } else { return f(v); }}\n\n//存在しない場合\n//1次元 Nを返す\n//多次元-1を返す\ntemplate<typename T, typename F> ll find_if2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (f(v[i]))return i; }    return sz(v);}\ntemplate<typename T, typename F> tuple<int, int> find_if2(const vector<vector<T> > &v, F f) {    rep(i, sz(v)) { rep(j, sz(v[i])) { if (f(v[i][j])) { return tuple<int, int>(i, j); }}}    return tuple<int, int>(-1, -1);}\ntemplate<typename T, typename F> auto find_if2(const vector<vector<vector<T> > > &v, F f) {    rep(i, sz(v)) { if (auto ret = find_if2(v[i], f); get<0>(ret) != -1) { return tuple_cat(tuple<int>(i), ret); }}    auto bad = tuple_cat(tuple<int>(-1), find_if2(v[0], f));    return bad;}\ntemplate<class T, class F> auto find_if2(const range_now<T> &v, F f) {return find_if2(v.A, f) + v.l;}\n//存在しない場合\n//1次元 -1を返す\n//多次元-1を返す\ntemplate<typename T, typename F> ll rfind_if2(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> tuple<int, int> rfind_if2(const vector<vector<T> > &v, F f) {    rer(i, sz(v) - 1) { rer(j, sz(v[i]) - 1) { if (f(v[i][j])) { return tuple<int, int>(i, j); }}}    return tuple<int, int>(-1, -1);}\ntemplate<typename T, typename F> auto rfind_if2(const vector<vector<vector<T> > > &v, F f) {    rer(i, sz(v) - 1) { if (auto ret = rfind_if2(v[i], f); get<0>(ret) != -1) { return tuple_cat(tuple<int>(i), ret); }}    auto bad = tuple_cat(tuple<int>(-1), rfind_if2(v[0], f));    return bad;}\n\n//todo まとめられそう string,vector全般\ntemplate<class T> bool contains(const string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(const vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(const vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        ll ret = 0;        for (auto &&v_ : v) { ret += count_if2(v_, f); }        return ret;    } else { return f(v); }}\ntemplate<typename T, typename F> void for_each2(T &a, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : a)for_each2(v_, f);    } else {        f(a);    }}\n#else\ntemplate<typename T, typename F> bool all_of2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(const string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(const vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(const vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(const vector<T> &vec_, F f) {    ll ret = 0;    fora(v, vec_) { ret += count_if2(v, f); }    return ret;}\n\ntemplate<typename T, typename F> void for_each2(T &a, F f) {\n    f(a);\n}\ntemplate<typename T, typename F> void for_each2(vector<T>  &a, F f) {\n    for (auto &&v_ : a)for_each2(v_, f);\n}\n#endif\ntemplate<typename W> ll count_od(const vector<W> &a) { return count_if2(a, [](ll v) { return v & 1; }); }\ntemplate<typename W> ll count_ev(const vector<W> &a) { return count_if2(a, [](ll v) { return !(v & 1); }); }\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(const vector<T> &v, F f) {    vector<T> nv;    rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}    return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(const vector<vector<T>> &v, F f) {    vector<vector<T>> res;    rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }    return res;}\n\ntemplate<typename T, typename F> vector<T> entry_if2(const vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (f(v[i])) { nv.push_back(v[i]); }}return nv;}\ntemplate<typename T, typename F> vector<vector<T>> entry_if2(const vector<vector<T>> &v, F f) {vector<vector<T>> res;rep(i, sz(v)) { res[i] = entry_if2(v[i], f); }return res;}\n\ntemplate<typename T, typename F> ll l_rfind_if(const vector<T> &v, F f) {rer(i, sz(v) - 1) { if (f(v[i]))return i; }return -1;}\ntemplate<typename T, typename F> bool l_contains_if(const vector<T> &v, F f) {rer(i, sz(v) - 1) { if (f(v[i]))return true; }return false;}\ntemplate<class A, class B, class C> auto t_all_of(A a, B b, C c) { return std::all_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_any_of(A a, B b, C c) { return std::any_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_none_of(A a, B b, C c) { return std::none_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_find_if(A a, B b, C c) { return std::find_if(a, b, c); }\ntemplate<class A, class B, class C> auto t_count_if(A a, B b, C c) { return std::count_if(a, b, c); }\n\n#define all_of_s__2(a, right) (t_all_of(ALL(a),lamr(right)))\n#define all_of_s__3(a, v, siki) (t_all_of(ALL(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a, right) all_of2(a,lamr(right))\n#define all_of__3(a, v, siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a, f) all_of2(a,f)\n\n#define any_of_s__2(a, right) (t_any_of(ALL(a),lamr(right)))\n#define any_of_s__3(a, v, siki) (t_any_of(ALL(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a, right) any_of2(a,lamr(right))\n#define any_of__3(a, v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a, f) any_of2(a,f)\n\n#define none_of_s__2(a, right) (t_none_of(ALL(a),lamr(right)))\n#define none_of_s__3(a, v, siki) (t_none_of(ALL(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a, right) none_of2(a,lamr(right))\n#define none_of__3(a, v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a, f) none_of2(a,f)\n\n#define find_if_s__2(a, right) (t_find_if(ALL(a),lamr(right))-a.begin())\n#define find_if_s__3(a, v, siki) (t_find_if(ALL(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a, right) find_if2(a,lamr(right))\n#define find_if__3(a, v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if__4(a, l, v, siki) (find_if2(decltype(a)(a.begin()+l , a.end()),[&](auto v){return siki;}) + l)\n#define find_if(...) over4(__VA_ARGS__,find_if__4, find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a, f) find_if2(a,f)\n\n#define rfind_if_s__2(a, right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a, v, siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a, right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a, v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a, f) rfind_if2(a,f)\n\n#define contains_if_s__2(a, right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a, v, siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a, right) contains_if2(a,lamr(right))\n#define contains_if__3(a, v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a, f) contains_if2(a,f)\n\n#define count_if_s__2(a, right) (t_count_if(ALL(a),lamr(right)))\n#define count_if_s__3(a, v, siki) (t_count_if(ALL(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a, right) count_if2(a,lamr(right))\n#define count_if__3(a, v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a, f) count_if2(a,f)\n\n//vector<vi>で、viに対して操作\n#define for_each_s__2(a, right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a, v, shori) do{fora(v,a){shori;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n//vector<vi>で、intに対して操作\n#define for_each__2(a, right) for_each2(a,lamr(right))\n#define for_each__3(a, v, shori) for_each2(a,[&](auto& v){shori;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\ntemplate<class T, class F> vector<T> help_for_eached(const vector<T> &A, F f) {    vector<T> ret = A;    for_each(ret, v, f(v));    return ret;}\n#define for_eached__2(a, right) help_for_eached(a, lamr(right))\n#define for_eached__3(a, v, shori) help_for_eached(a, lam(v, shori))\n#define for_eached(...) over3(__VA_ARGS__,for_eached__3,for_eached__2)(__VA_ARGS__)\n#define for_eached_f(a, f) for_eached2(a, f);\n\n#define each for_each\n#define eached for_eached\n\n\n//#define erase_if_s__2(a, right) l_erase_if2(a,lamr(right))\n//#define erase_if_s__3(a, v, siki) l_erase_if2(a,[&](auto v){return siki;})\n//#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a, right) erase_if2(a,lamr(right))\n#define erase_if__3(a, v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a, f) erase_if2(a,f)\n\n//#define entry_if_s__2(a, right) l_entry_if2(a,lamr(right))\n//#define entry_if_s__3(a, v, siki) l_entry_if2(a,[&](auto v){return siki;})\n//#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a, right) entry_if2(a,lamr(right))\n#define entry_if__3(a, v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a, f) entry_if2(a,f)\n\n#endif\n\n/*@formatter:off*/\ntemplate<class T, class U, class W> void replace(vector<W> &a, T key, U v) { rep(i, sz(a))if (a[i] == key)a[i] = v; }\ntemplate<class T, class U, class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i, sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(ALL(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(ALL(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\nvoid replace(str &a) {    int dec = 0;    if ('a' <= a[0] && a[0] <= 'z')dec = 'a';    if ('A' <= a[0] && a[0] <= 'Z')dec = 'A';    fora(v, a) { v -= dec; }}\nvoid replace(str &a, str key, str v) {    stringstream t;    ll kn = sz(key);    std::string::size_type Pos(a.find(key));    ll l = 0;    while (Pos != std::string::npos) {        t << a.substr(l, Pos - l);        t << v;        l = Pos + kn;        Pos = a.find(key, Pos + kn);    }    t << a.substr(l, sz(a) - l);    a = t.str();}\n\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(ALL(a), ALL(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(ALL(a)); }\nvi iota(ll s, ll len) {vi ve(len);iota(ALL(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);    return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\n\n/*@formatter:off*/\ntemplate<class T> void sort(vector<T> &a, int l = -1, int r = -1) {    set_lr12(l, r, sz(a));    fast_sort(a.begin() + l, a.begin() + r);}\ntemplate<class T> void rsort(vector<T> &a, int l = -1, int r = -1) {    set_lr12(l, r, sz(a));    fast_sort(a.begin() + l, a.begin() + r, greater<T>());};\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class... T, class U> auto sorted(U head, T... a) {    sort(head, a...);    return head;}\ntemplate<class... T, class U> auto rsorted(U head, T... a) {rsort(head, a...);return head;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}\n//#define use_sort\n#ifdef use_sort\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti,    fisitd,    fisdti,    fisdtd,    fdsiti,    fdsitd,    fdsdti,    fdsdtd,    fitisi,    fitisd,    fitdsi,    fitdsd,    fdtisi,    fdtisd,    fdtdsi,    fdtdsd,    sifiti,    sifitd,    sifdti,    sifdtd,    sdfiti,    sdfitd,    sdfdti,    sdfdtd,    sitifi,    sitifd,    sitdfi,    sitdfd,    sdtifi,    sdtifd,    sdtdfi,    sdfdfd,    tifisi,    tifisd,    tifdsi,    tifdsd,    tdfisi,    tdfisd,    tdfdsi,    tdfdsd,    tisifi,    tisifd,    tisdfi,    tisdfd,    tdsifi,    tdsifd,    tdsdfi,    tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {typedef pair<A, B> U;if (type == fisi) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; }); else if (type == fisd) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; }); else if (type == fdsi) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; }); else if (type == fdsd) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; }); else if (type == sifi) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; }); else if (type == sifd) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; }); else if (type == sdfi) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; }); else if (type == sdfd) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};\ntemplate<class U> void sort(vector<U> &a, pcomparator type) { if (type == fisi) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; }); else if (type == fisd) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; }); else if (type == fdsi) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; }); else if (type == fdsd) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; }); else if (type == sifi) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == sifd) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == sdfi) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == sdfd) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; }); };\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {typedef F2<A, B, C, D> U;if (type == fisi) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; }); else if (type == fisd) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; }); else if (type == fdsi) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; }); else if (type == fdsd) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; }); else if (type == sifi) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == sifd) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == sdfi) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == sdfd) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};\ntemplate<class U> void sort(vector<U> &a, tcomparator type) {if (type == 0) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 41) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 42) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 43) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; }); else if (type == 44) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 45) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 46) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 47) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 41) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 42) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 43) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; }); else if (type == 44) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 45) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 46) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 47) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\n/*@formatter:off*/\nvoid sort(string &a) { sort(ALL(a)); }\nvoid rsort(string &a) { sort(RALL(a)); }\nvoid sort(int &a, int &b) { if (a > b)swap(a, b); }\nvoid sort(int &a, int &b, int &c) {    sort(a, b);    sort(a, c);    sort(b, c);}\nvoid rsort(int &a, int &b) { if (a < b)swap(a, b); }\nvoid rsort(int &a, int &b, int &c) {    rsort(a, b);    rsort(a, c);    rsort(b, c);}\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(ALL(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(ALL(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n/*indexの分で型が変わるためpcomparatorが必要*/\ntemplate<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}\ntemplate<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}\ntemplate<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}\ntemplate<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}\ntemplate<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };\ntemplate<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}\ntemplate<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };\ntemplate<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] < c[y]; else return b[x] < b[y]; } else { return a[x] < a[y]; }});    return ind;}\ntemplate<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] > c[y]; else return b[x] > b[y]; } else { return a[x] > a[y]; }});    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\n#endif\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {    vi c = a;    vi d = b;    sort(c);    sort(d);    return includes(ALL(c), ALL(d));}\ntemplate<class T> bool distinct(const vector<T> &A) {    if ((int) (A).size() == 1)return true;    if ((int) (A).size() == 2)return A[0] != A[1];    if ((int) (A).size() == 3)return (A[0] != A[1] && A[1] != A[2] && A[0] != A[2]);    auto B = A;    sort(B);    int N = (B.size());    unique(B);    return N == (int) (B.size());}\ntemplate<class H, class... T> bool distinct(const H &a, const T &...b) { return distinct(vector<H>{a, b...}); }\n\n/*@formatter:off*/\ntemplate<class T, class U> void inc(pair<T, U> &a, U v = 1) { a.first += v, a.second += v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U = int> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U = int> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, W v = 1) {for (auto &u :a)dec(u, v);for (auto &u :b)dec(u, v);}\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, vector<W> &c) {    for (auto &u :a)dec(u, 1);    for (auto &u :b)dec(u, 1);    for (auto &u :c)dec(u, 1);}\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool san(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return san(0, i, sz(a)) && san(0, j, sz(a)); }\n#define inside ins\nll u0(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u0(vector<T> &a) {    vector<T> ret = a;    fora(v, ret) { v = u(v); }    return ret;}\n//todo 名前\nbool d_(int a, int b) {if (b == 0)return false;return (a % b) == 0;}\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    cerr << \"ole\" << endl;exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;exit(0);\n}\nvoid re(string s = \"\") {cerr << s << endl;assert(0 == 1);exit(0);}\n\nvoid tle() { while (inf)cout << inf << endl; }\n\n\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\ntemplate<class T> T in() {    T ret;    cin >> ret;    return ret;}\nstring sin() {    string ret;    cin >> ret;    return ret;}\ntemplate<class T> void in(T &head) { cin >> head; }\ntemplate<class T, class... U> void in(T &head, U &... tail) {    cin >> head;    in(tail...);}\n\n\n//value_typeを持つ場合呼べる\n//len回要素を追加する\ntemplate<class Iterable, class T = typename Iterable::value_type> Iterable tin(int len) {    Iterable ret;    T tem;    while (len--) {        cin >> tem;        ret += tem;    }    return ret;}\ntemplate<class T> T tin() {    T ret;    cin >> ret;    return ret;}\ntemplate<class T> T tind(int len = 0) {    auto ret = tin<T>(len);    dec(ret, 1);    return ret;}\n#define din_t2(type, a) type a;cin>>a\n#define din_t3(type, a, b) type a,b;cin>>a>> b\n#define din_t4(type, a, b, c) type a,b,c;cin>>a>>b>>c\n#define din_t5(type, a, b, c, d) type a,b,c,d;cin>>a>>b>>c>>d\n#define din_t6(type, a, b, c, d, e) type a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din_t7(type, a, b, c, d, e, f) type a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din_t(...) over7(__VA_ARGS__,din_t7,din_t6,din_t5,din_t4,din_t3 ,din_t2)(__VA_ARGS__)\n\n#define din(...) din_t(int,__VA_ARGS__)\n#define d_in\n#define dsig(...) din_t(signed,__VA_ARGS__)\n\n#define dst(...) din_t(string,__VA_ARGS__)\n#define dstr dst\n#define d_str dst\n\n#define dcha(...) din_t(char,__VA_ARGS__)\n#define dchar dcha\n\n#define ddou(...) din_t(double,__VA_ARGS__)\n\n\n#define din1d(a) din_t2(int, a);a--\n#define din2d(a, b) din_t3(int, a,b);a--,b--\n#define din3d(a, b, c) din_t4(int, a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din_t5(int, a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n/*@formatter:off*/\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) { cerr << head << endl; }\nvoid err() { cerr << \"\" << endl; }\n//debで出力する最大長\nconstexpr int DEB_LEN = 20;\nconstexpr int DEB_LEN_H = 12;\nstring deb_tos(const int &v) { if (abs(v) == inf || abs(v) == linf)return \"e\"; else return to_string(v); }\ntemplate<class T> string deb_tos(const T &a) {stringstream ss;ss << a;return ss.str();}\n#ifdef use_epsdou\nstring deb_tos(const epsdou &a) {return deb_tos(a.v);}\n#endif\ntemplate<class T> string deb_tos(const optional<T> &a) { if (a.has_value()) { return deb_tos(a.value()); } else return \"e\"; }\ntemplate<class T> string deb_tos(const vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), DEB_LEN);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << deb_tos(a[i]);        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            lens[wi] = max(lens[wi], sz(deb_tos(a[h][W[wi]])) + 1);            lens[wi] = max(lens[wi], sz(deb_tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(lens[i])ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            ss << std::right << std::setw(lens[wi]) << deb_tos(a[h][w]);            wi++;        }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), DEB_LEN_H});    W = min({W, sz(a[0]), DEB_LEN_H});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    return deb_tos(a, hs, ws, key);}\ntemplate<class T> string deb_tos(const vector<vector<vector<T> > > &a, ll H = inf) {    stringstream ss;    if (H == inf)H = DEB_LEN_H;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << deb_tos(a[i], inf, inf, i);    }    return ss.str();}\ntemplate<class T> string deb_tos(vector<set<T> > &a, ll H = inf, ll W = inf, int key = -1) {    vector<vector<T> > b(sz(a));    rep(i, sz(a)) { fora(v, a[i]) { b[i].push_back(v); }}    return deb_tos(b, H, W, key);}\ntemplate<class T, size_t A> string deb_tos(T (&a)[A]) { return deb_tos(vector<T>(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B> string deb_tos(T (&a)[A][B]) { return deb_tos(vector<vector<T> >(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B, size_t C> string deb_tos(T (&a)[A][B][C]) { return deb_tos(vector<vector<vector<T> > >(begin(a), end(a))); }\n/*@formatter:off*/\ntemplate<class T> void out2(T head) {    cout << head;    res_mes += deb_tos(head);}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";    res_mes += deb_tos(head) + \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";    res_mes += deb_tos(head) + \" \";    out2(tail...);    cout << \"\" << endl;    res_mes += \"\\n\";}\ntemplate<class T> void out(T head) {    cout << head << endl;    res_mes += deb_tos(head) + \"\\n\";}\nvoid out() { cout << \"\" << endl; }\n\n#else\n#define err(...);\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n#endif\n\n\ntemplate<class T> void outl(const vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {    rep(i, sz(a)) {        rep(j, sz(a[i])) { cout << a[i][j]; }        cout << endl;    }}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\n\n/*@formatter:off*/\ntemplate<class T> void na(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i];}\ntemplate<class T> void na(set<T> &a, ll n) { rep(i, n)a.insert(in()); }\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\ntemplate<class T> void nao(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T> void nad(set<T> &a, ll n) { rep(i, n)a.insert(in() - 1); }\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {    rep(i, n) {        a.insert(in());        b.insert(in());    }}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\n#define dna2d(a, b, n) vi a,b; na2d(a,b,n);\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a,b,c; na3(a,b,c,n);\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a,b,c; na3d(a,b,c,n);\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    d.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n)  vi a,b,c,d; na4(a,b,c,d,n);\n#define dna4d(a, b, c, d, n)  vi a,b,c,d; na4d(a,b,c,d,n);\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\n/*@formatter:off*/\n#define deb1(x)  debugName(x)<<\" = \"<<deb_tos(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n//#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n//#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n//#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n//#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n/*@formatter:off*/\n#ifdef _DEBUG\nbool was_deb = false;\n#define deb(...)  do{was_deb=true;cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl;}while(0)\n\n#define base_keta 8\nvoid print_n_base(int x, int base) { cerr << bitset<base_keta>(x) << endl; }\ntemplate<class T> void print_n_base(vector<T> X, int base) {cerr << endl;    for (auto &&x:X) { print_n_base(x, base); }    cerr << endl;}\n\n//n進数\n#define deb2(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#define deb_ex_deb(x, len)  debugName(x)<<\" = \"<<deb_tos(x, len)\n#define call_deb_ex_deb(x, len) deb_ex_deb(x, len)\n//要素が存在する行だけ出力(vvt)\n#define deb_ex(v) do {int N = sz(v);int s = N;int t = 0;rep(i, N) {if (sz(v[i])) {chmi(s, i);chma(t, i);}}auto ex_v = sub(v, s, N);str S = deb_tos(ex_v, sz(ex_v));debugName(v);cerr<<\" = \"<<endl;cerr << S << endl;} while (0);\n#define debi(A) {int len=min(sz(A),20); was_deb=true;cerr<<debugName(A)<<\" = \"<<endl;rep(i, len)cerr<<std::right << std::setw((int)(sz(tos(A[i]))+(i ? 1 : 0)))<<(i%10);cerr<<endl;rep(i, len)cerr<<std::right << std::setw((int)(sz(tos(A[i]))+(i ? 1 : 0)))<<A[i];cerr<<endl;}\n\ntemplate<class T, class F> string deb_tos_f(vector<vector<T> > &a, F f, int key = -1) {vi hs, ws_;    int H = sz(a), W = sz(a[0]);    vi exh(H), exw(W);    rep(h, H) {        rep(w, W) {            if (f(a[h][w])) {                exh[h] = true;                exw[w] = true;            }        }    }    rep(h, H) if (exh[h])hs.push_back(h);    rep(w, W) if (exw[w])ws_.push_back(w);    return deb_tos(a, hs, ws_, key);}\ntemplate<class T, class F> string deb_tos_f(vector<vector<vector<T>>> &a, F f) {stringstream ss;    int H = sz(a);    if (sz(a) == 0)return ss.str();    rep(i, H) { ss << deb_tos_f(a[i], f, i); }    ss << \"\" << endl;    return ss.str();}\n#define debf_normal(tab, f) do{cerr<<debugName(tab)<<\" = \"<<endl;cerr<< deb_tos_f(tab, f)<<endl;}while(0);\n#define debf2(tab, siki_r) debf_normal(tab, lamr(siki_r))\n#define debf3(tab, v, siki)  debf_normal(tab, lam(siki))\n//S, sikir\n//S, v, siki\n#define debf(...) over3(__VA_ARGS__,debf3,debf2,debf1)(__VA_ARGS__)\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#define deb_ex(...) ;\n#define debf(...) ;\n#define debi(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n/*@formatter:off*/\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {std::ostream::sentry s(dest);if (s) {__uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }return dest;}\n__int128 to_bint(string &s) {__int128 ret = 0;    for (ll i = 0; i < (ll) s.length(); ++i) if ('0' <= s[i] && s[i] <= '9') ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {string S;    iss >> S;    v = 0;    rep(i, sz(S)) {        v *= 10;        v += S[i] - '0';    }}\n\n//便利関数\n/*@formatter:off*/\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void) {static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;    unsigned long t;    t = (x ^ (x << 11));    x = y;    y = z;    z = w;    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max) { return rand(0, max); }\ntemplate<class T> T rand(vector<T> &A) { return A[rand(sz(A) - 1)]; }\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T> &A, int N) {vector<T> ret(N);    rep(i, N) { ret[i] = rand(A); }    return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T> &A, int N) {vector<T> ret(N);    umapi was;    rep(j, N) {        int i;        while (1) {            i = rand(sz(A) - 1);            if (was.find(i) == was.end())break;        }        ret[j] = A[i];        was[i] = 1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\n\n/*@formatter:off*/\n#ifdef _DEBUG\nbool timeup(int time) {static bool never = true;    if (never)message += \"may timeup, because slow\";    never = false;    auto end_time = system_clock::now();    auto part = duration_cast<milliseconds>(end_time - start_time);    auto lim = milliseconds(time);    return part >= lim;}\n#else\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n\n#endif\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {auto dec = duration_cast<nanoseconds>(past_time - start_time);    auto part = calc_time_nano();    auto can_time = nanoseconds(milli * 1000 * 1000);    can_time -= part;    can_time -= dec;    return div(can_time, part);}\n\n/*@formatter:off*/\n//#define use_rand\n#ifdef use_rand\nstr ransu(ll n) {str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n#endif\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class Iterable, class T = typename Iterable::value_type> vector<pair<T, int>> run_length(const Iterable &a) {vector<pair<T, int>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\n\n/*@formatter:off*/\n//#define use_mgr //_goldd _goldt\n#ifdef use_mgr\n//->[i, f(i)]\ntemplate<class T, class U, class F> auto mgr(T ok, U ng, const F &f, require_arg(is_integral<T>::value &&is_integral<U>::value)) {    auto mid = (ok + ng);    if (ok < ng)        while (ng - ok > 1) {            mid = (ok + ng) >> 1;            if (f(mid))ok = mid; else ng = mid;        }    else        while (ok - ng > 1) {            mid = (ok + ng) >> 1;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\n//[l, r)の中で,f(i)がtrueとなる範囲を返す okはそこに含まれる\ntemplate<class F> P mgr_range(int l, int r, F f, int ok) {if (f(ok) == 0) {        out(\"f(ok) must true\");        re();    }    return mp(mgr(ok, l - 1, f), mgr(ok, r, f) + 1);}\ntemplate<class F> auto mgrd(dou ok, dou ng, F f, int kai = 100) {if (ok < ng)        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    else        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\ntemplate<class F> dou mgrd_time(dou ok, dou ng, F f, int time = 1980) {bool han = true;    if (ok < ng)        while (1) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);            if (timeup(time)) { break; }        }    else        while (1) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);            if (timeup(time)) { break; }        }    return ok;}\n//todo 減らす\ntemplate<class F> auto goldd_l(ll left, ll right, F calc) {double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return make_tuple(resIndex, calc(resIndex));}\ntemplate<class F> auto goldt_l(ll left, ll right, F calc) {double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return make_tuple(resIndex, calc(resIndex));}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> auto goldd_d(dou left, dou right, F calc, ll loop = 200) {dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return make_tuple(left, calc(left));}\ntemplate<class F> auto goldt_d(dou left, dou right, F calc, ll loop = 200) {double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return make_tuple(left, calc(left));}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> auto goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(mini, calc(mini));}\ntemplate<class F> auto goldt_ls(ll l, ll r, F calc, ll time = 2000) {auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(maxi, calc(maxi));}\ntemplate<class F> auto goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(mini, calc(mini));}\ntemplate<class F> auto goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(maxi, calc(maxi));}\n#endif\n\n//strを整数として比較\nstring smax(str &a, str b) { if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else if (a < b)return b; else return a; }\n//strを整数として比較\nstring smin(str &a, str b) { if (sz(a) > sz(b)) { return b; } else if (sz(a) < sz(b)) { return a; } else if (a > b)return b; else return a; }\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {rep(i, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i * sz(a[0]) + j;return -1;}\ntemplate<typename W, typename U> tuple<int, int, int> find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return tuple<int, int, int>(i, j, k);    return tuple<int, int, int>(-1, -1, -1);}\n//無ければ-1\nint find(string &s, const string key) {    int klen = sz(key);    rep(i, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }return -1;}\nint find(string &s, int l, const string key) {    int klen = sz(key);    rep(i, l, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }    return -1;}\nint find(string &s, const char key) {    rep(i, sz(s)) { if (s[i] == key)return i; }    return -1;}\nint find(string &s, int l, const char key) {    rep(i, l, sz(s)) { if (s[i] == key)return i; }    return -1;}\n//N箇所について右のkeyの場所を返す\ntemplate<typename W, typename T> vi finds(const W &a, const T& key) {    int n = sz(a);    vi rpos(n, -1);    rer(i, n-1){        if(i<n-1){            rpos[i] = rpos[i+1];        }        if(a[i]==key)rpos[i] = i;    }    return rpos;}\ntemplate<typename W, typename T> vi rfinds(const W &a, const T& key) {    int n = sz(a);    vi lpos(n, -1);    rep(i, n){        if(i> 0){            lpos[i] = lpos[i-1];        }        if(a[i]==key)lpos[i] = i;    }    return lpos;}\n//todoz\n#if __cplusplus >= 201703L\ntemplate<typename W, typename T, class Iterable = typename W::value_type>\nll count(const W &a, const T &k) { return count_if(a, ==k); }\ntemplate<typename W, class Iterable = typename W::value_type> vi count(const W &a) {\n    vi res;\n    for_each(a, v, if (sz(res) <= (int) v)res.resize((int) v + 1);\n            res[v]++;);\n    return res;\n}\n#endif\nll count(const str &a, const str &k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\n/*@formatter:off*/\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l, int r) {    vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> auto rev(const vector<T> &a) {    auto b = a;    reverse(ALL(b));    return b;}\n/* ＼反転  */                                                                                        template<class U>\nauto rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    return b;}\n/* ｜反転  */                                                                                        template<class U>\nauto revw(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0])) { b[h][W - 1 - w] = a[h][w]; }    return b;}\n\n/* ー反転  */                                                                                        template<class U>\nauto revh(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int H = sz(a);    rep(h, sz(a)) rep(w, sz(a[0])) { b[H - 1 - h][w] = a[h][w]; }    return b;}\n\n/* ／反転  */                                                                                        template<class U>\nauto revr(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    int H = sz(a);    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[H - 1 - h][W - 1 - w];    return b;}\n\nauto rev(const string &a) {    string b = a;    reverse(ALL(b));    return b;}\ntemplate<class T> auto rev(const T &v, int i) {return v[sz(v) - 1 - i];}\nint rev(int N, int i) {return N-1-i;}\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v, int if_zero_res) { if(!v)return if_zero_res;if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else return 15; } else { if (v < p10[17]) { if (v < p10[16]) return 16; else return 17; } else { if (v < p10[18])return 18; else return 19; }}}}}\n#if __cplusplus >= 201703L\nll getr(ll a, ll keta) { return (a / pow<ll>(10, keta)) % 10; }\n#else\nll getr(ll a, ll keta) { return (a / (int)pow(10, keta)) % 10; }\n#endif\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a, 1);return getr(a, sketa - 1 - ket);}\nll dsum(ll v, ll sin = 10) {ll ret = 0;for (; v; v /= sin)ret += v % sin;return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n\ntemplate<class T, class U> auto to_v1(vector<reference_wrapper<U>>& ret, vector<T> &A) {    rep(i, sz(A))ret.push_back(A[i]);    return ret;}\ntemplate<class T, class U> auto to_v1(vector<reference_wrapper<U>>& ret, vector<vector<T> > &A) {rep(i, sz(A))to_v1(ret, A[i]);return ret;}\n//参照付きで1次元に起こす\ntemplate<class T> auto to_v1(vector<vector<T> > &A) {    vector<reference_wrapper<decl2_t<decltype(A)>>> ret;    rep(i, sz(A))to_v1(ret, A[i]);    return ret;}\n\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\n//空でも動く(なぜか)\ntemplate<class T> auto keys(const T &a) {vector<decltype((a.begin())->fi)> res;for (auto &&k :a)res.push_back(k.fi);return res;}\ntemplate<class T> auto values(const T &a) {vector<decltype((a.begin())->se)> res;for (auto &&k :a)res.push_back(k.se);return res;}\n//todo 可変長で\ntemplate<class T> constexpr T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\n//1次元のコンテナ\ntemplate<class T> int mini(const vector<T> &a) { return min_element(ALL(a)) - a.begin(); }\ntemplate<class T> int maxi(const vector<T> &a) { return max_element(ALL(a)) - a.begin(); }\ntemplate<class T> T sum(const T &A) {return A;}\ntemplate<class T> T sum(const vector<T> &A, int l = -1, int r = -1) {T s = 0;set_lr12(l, r, sz(A));rep(i, l, r)s += sum(A[i]);return s;}\n//1次元のIterableに使える\ntemplate<class T, require_t(!has_value_type<T>::value)>T min(T &a) { return a; }\ntemplate<class V, require_t(has_value_type<V>::value)>auto min(V &a, ll s = -1, ll n = -1) {    using Ret_t = decl2_t<V>;    auto ret = MAX<Ret_t>();    set_lr12(s, n, sz(a));    if (s == n) {        return INF<Ret_t>();    } else {        rep(i, s, n) {            ret = min(ret, min(a[i]));        }        return ret;    }}\ntemplate<class T, require_t(!has_value_type<T>::value)> T max(T &a) { return a; }\ntemplate<class V, require_t(has_value_type<V>::value)> auto max(V &a, ll s = -1, ll n = -1) {    using Ret_t = decl2_t<V>;    auto ret = MIN<Ret_t>();    set_lr12(s, n, sz(a));    if (s == n) { return -INF<Ret_t>(); }    else {        rep(i, s, n) { ret = max(ret, max(a[i])); }        return ret;    }}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {T ret = v[0];rep(i, 1, min(t, sz(v)))ret *= v[i];return ret;}\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\n//indexを持つvectorを返す\n\n/*@formatter:off*/\ntemplate<typename W, typename T> void fill(W &xx, const T vall) { xx = vall; }\ntemplate<typename W, typename T> void fill(vector<W> &vecc, const T vall) { for (auto &&vx     : vecc)fill(vx, vall); }\ntemplate<typename W, typename T> void fill(vector<W> &xx, const T v, ll len) { rep(i, len)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<W> &xx, const T v, int s, ll t) { rep(i, s, t)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, T v, int sh, int th, int sw, int tw) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\n//#define use_fill //_sum _array _max _min\n#ifdef use_fill\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N){fill(a[i], v);}}\ntemplate<class T, class U> void fill(vector<T> &a, const vi &ind, U val) { fora(v, ind) { a[v] = val; }}\ntemplate<typename A, size_t N> auto sum(A (&a)[N], int l = -1, int r = -1) {set_lr12(l, r, N);auto res = sum(a[l]);if (l == r) {return res - res;}rep(i, l + 1, r)res += sum(a[i]);return res;}\ntemplate<typename A, size_t N> auto max(A (&a)[N], int l = -1, int r = -1) {    set_lr12(l, r, N);    auto res = max(a[l]);    if (l == r) {        return -INF<decltype(res)>();    }    rep(i, l + 1, r)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> auto min(A (&a)[N], int l = -1, int r = -1) {    set_lr12(l, r, N);    auto res = min(a[l]);    if (l == r) {        return INF<decltype(res)>();    }    rep(i, l + 1, r)res = min(res, min(a[i]));    return res;}\n#endif\n\n\nvi inds_(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) { assert(ret[a[i]] ==-1);ret[a[i]] = i; }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int> &q) { q = priority_queue<int>(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\n//template<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\n//template<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n\n\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, sz(rui) - 1)); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin() { return rui.begin(); }\n    auto end() { return rui.end(); }\n};\ntemplate<class T> string deb_tos(const ruiC<T> &a) {return deb_tos(a.rui);}\ntemplate<class T> ostream &operator<<(ostream &os, ruiC<T> a) {    fora(v, a.rui){os << v << \" \"; }   return os;}\ntemplate<class T> vector<T> ruiv(const vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(const vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\ntemplate<class T> ruiC<T> ruic() { return ruiC<T>(); }\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n\n//#define use_rui //_imo _ruic _ruiv\n#ifdef use_rui\n//kと同じものの数\ntemplate<class T, class U> vi imo(const vector<T> &a, U k) {    vi equ(sz(a));    rep(i, sz(a)){        equ[i] = a[i]==k;    }    return imo(equ);}\ntemplate<class T> vector<T> imox(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(const vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(const vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruimax {\n    template<typename Monoid> struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN<T>(), -1);        Monoid f(Monoid a, Monoid b) { return max(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<int> ri;\n    bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        T ma = MIN<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -INF<T>();        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) { index = i; }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    int geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    int geti(int r = inf) { return geti(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> struct ruimin {\n    template<typename Monoid> struct SegmentTree {  /*pairで処理*/         int sz;vector<Monoid> seg;        const Monoid M1 = mp(MAX<T>(), -1);        Monoid f(Monoid a, Monoid b) { return min(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<int> ri;\n    bool build = false;\n    int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        T mi = MAX<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = INF<T>();        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) { index = i; }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    int geti(int l, int r) {        {            assert(l <= r && 0 <= l && r <= n);            if (l == 0) { return ri[r]; }            else {                if (!build)seg.build(ve), build = true;                return seg.query(l, r).second;            }        }        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    int geti(int r = inf) { return geti(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};/*@formatter:off*/\n\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) { rep(i, sz(a)) { res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1); }}    return res;}\nvector<ruiC<int>> ruibc(vi &a) {vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) { res[k][i] = (a[i] >> k) & 1; }        ret[k] = ruic(res[k]);    }    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC<T> dummy;//変なのをよばれたときはこれを返す//todo\n    ruiC2(const vector<vector<T>> &ru) : rui(sz(ru)), H(sz(ru)) {            for (int h = 0; h < H; h++) {                if (sz(ru[h]) == 0)continue;                if (sz(dummy) == 1) dummy = ruic(vector<T>(sz(ru[h])));                rui[h] = ruic(ru[h]);            }        }\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {            if (l > r) {                cerr << \"ruic \";                deb(l, r);                assert(0);            }            vector<T> res(H);            for (int h = 0; h < H; h++)res[h] = rui[h](l, r);            return res;        }\n    //HについてWを返す\n    ruiC<T> &operator[](ll h) {\n#ifdef _DEBUG\n        if (h >= H) {message += \"warning ruiC h >= H\";}\n#endif\n        if (h >= H || sz(rui[h]) == 1)return dummy;else return rui[h];\n    }\n    /*@formatter:off*/\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\ntemplate<class T, class U> ruiC<ll> ruicou(vector<T> &a, U b) {    vi cou(sz(a));    rep(i, sz(a)) { cou[i] = a[i] == b; }    return ruic(cou);}\n\n//メモリは形式によらず(26*N)\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\n// 添え字は'a', 'A'のまま扱う (予め-='a','A'されているものが渡されたらそれに従う)\ntemplate<typename Iterable, class is_Iterable = typename Iterable::value_type>\nruiC2<ll> ruicou(const Iterable &a) {        int H = max(a) + 1;        vvi(cou, H);        rep(i, sz(a)) {            if (sz(cou[a[i]]) == 0)cou[a[i]].resize(sz(a));            cou[a[i]][i] = 1;        }        return ruiC2<ll>(cou);    }\n\n\n/*@formatter:off*/\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v));    rep(h, sz(ret)) { ret[h] = v[h][w]; }    rep(i, sz(ret) - 1) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v) + 1);    rep(h, sz(v)) { ret[h + 1] = v[h][w]; }    rep(i, sz(v)) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {    vector<T> ret = ruih(a, w);    return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {\n    vector<T> rui;\n    ruixC(vector<T> &ru) : rui(ru) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }\n    T operator[](ll i) { return rui[i]; }\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T> &a) {    vi ret = ruix(a);    return ruixC<ll>(ret);}\n//差分を返す(累積を取ると元に戻る)\n//101なら\n//1111を返す\n//元の配列で[l, r)へのxorは\n//[l]と[r]へのxorになる https://atcoder.jp/contests/abc155/tasks/abc155_f\nvi ruix_diff(vi &A) {    int N = sz(A);    assert(N);    vi res(N + 1);    res[0] = A[0];    rep(i, 1, N) { res[i] = A[i - 1] ^ A[i]; }    res[N] = A[N - 1];    return res;}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {        rui.resize(n + 1);        rer(i, n - 1) { rui[i] = rui[i + 1] + a[i]; }    }\n    /*[r l)*/\n    T operator()(int r, int l) {        r++;        l++;        assert(l <= r && l >= 0 && r <= n);        return rui[l] - rui[r];    }\n    T operator()(int l) { return operator()(n - 1, l); }\n    T operator[](int i) { return operator()(i); }\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {    fora(v, a.rui){os << v << \" \"; }   return os;}\ntemplate<class T> string deb_tos(rruiC<T> &a) {return deb_tos(a.rui);}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {        rv.resize(n + 1);        rv[0] = 1;        rep(i, n) { rv[i + 1] = a[i] * rv[i]; }    }\n    ruimulC() : n(0) {        rv.resize(n + 1);        rv[0] = 1;    }\n    void operator+=(T v) {        rv.push_back(rv.back() * v);        n++;    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        return rv[r] / rv[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {    vector<T> a;    return ruimulC<T>(a);}\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U, class W> T lowerBound(ruiC <T> &a, U v, W banpei) { return lowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T upperBound(ruiC <T> &a, U v, W banpei) { return upperBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rlowerBound(ruiC <T> &a, U v, W banpei) { return rlowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rupperBound(ruiC <T> &a, U v, W banpei) { return rupperBound(a.rui, v, banpei); }\n#endif\n\nconstexpr bool bget(ll m, ll keta) {\n#ifdef _DEBUG\n    assert(keta <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (m >> keta) & 1;\n}\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi &a, int keta_size) {    vvi(res, keta_size, sz(a));    rep(k, keta_size) { rep(i, sz(a)) { res[k][i] = bget(a[i], k); }}    return res;}\nvi bget1(vi &a, int keta) {    vi res(sz(a));    rep(i, sz(a)) { res[i] = bget(a[i], keta); }    return res;}\n#if __cplusplus >= 201703L\nll bget(ll m, ll keta, ll sinsuu) {    m /= pow<ll>(sinsuu, keta);    return m % sinsuu;}\n#else\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll)pow(sinsuu, keta);    return m % sinsuu;}\n#endif\nconstexpr ll bit(ll n) {\n#ifdef _DEBUG\n    assert(n <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (1LL << (n));\n}\n#if __cplusplus >= 201703L\nll bit(ll n, ll sinsuu) { return pow<ll>(sinsuu, n); }\n#else\nll bit(ll n, ll sinsuu) { return (ll)pow(sinsuu, n); }\n#endif\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(const vi &a) {    int m = 0;    for (auto &&v:a) m |= bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bit_bool(vi &a) {    int m = 0;    rep(i, sz(a)) if (a[i])m |= bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { assert(n);return n & -n; }\nll lbiti(ll n) { assert(n);return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    assert(n);n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n) { assert(n);return log2(hbit(n)); }\n//ll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n/*over*/#define forbit1_2(i, mas) for (int forbitj = !mas ? 0 : lbit(mas), forbitm = mas, i = !mas ? 0 :log2(forbitj); forbitm; forbitm = forbitm ^ forbitj, forbitj = !forbitm ? 1 : lbit(forbitm), i = log2(forbitj))\n/*over*/#define forbit1_3(i, N, mas) for (int forbitj = !mas ? 0 : lbit(mas), forbitm = mas, i = !mas ? 0 :log2(forbitj); forbitm  && i < N; forbitm = forbitm ^ forbitj, forbitj = !forbitm ? 1 : lbit(forbitm), i = log2(forbitj))\n//masの立ってるindexを見る\n//              i, [N], mas\n#define forbit1(...) over3(__VA_ARGS__, forbit1_3, forbit1_2)(__VA_ARGS__)\n//masが立っていないindexを見る\n//              i, N, mas\n#define forbit0(i, N, mas) forbit1(i, mask(N) & (~(mas)))\n\n//forsubをスニペットして使う\n//Mの部分集合(0,M含む)を見る 3^sz(S)個ある\n#define forsub_all(m, M) for (int m = M; m != -1; m = m == 0 ? -1 : (m - 1) & M)\n//BASE進数\ntemplate<size_t BASE> class base_num {\n    int v;\npublic:\n    base_num(int v = 0) : v(v) {};\n    int operator[](int i) { return bget(v, i, BASE); }\n    void operator++() { v++; }\n    void operator++(signed) { v++; }\n    operator int() { return v; }\n};\n#define base3(mas, lim, BASE) for (base_num<BASE> mas; mas < lim; mas++)\n#define base2(mas, lim) base3(mas, lim, 2)\n#define base(...) over3(__VA_ARGS__,base3,base2,base1)(__VA_ARGS__)\n\n\n//aにある物をtrueとする\nvb bool_(vi a, int n) {    vb ret(max(max(a) + 1, n));    rep(i, sz(a))ret[a[i]] = true;    return ret;}\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    res = rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n//#define use_compress\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(ALL(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\n#ifdef use_compress\n//ind[i] := i番目に小さい数\n//map[v] := vは何番目に小さいか\nvi compress(vi &a, umapi &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(ALL(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a){b.push_back(v);}    fora(v, r){b.push_back(v);}    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(ALL(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(ALL(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a){b.push_back(v);}    fora(v, r){b.push_back(v);}    fora(v, s){b.push_back(v); }   sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(ALL(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(ALL(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(ALL(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a){fora(v, vv){b.push_back(v);}}    sort(b);    unique(b);    fora(vv, a){fora(v, vv){v = lower_bound(ALL(b), v) - b.begin(); }}   ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a){fora(vv, vvv){fora(v, vv){b.push_back(v);}}}    sort(b);    unique(b);   fora(vvv, a){fora(vv, vvv){fora(v, vv){v = lower_bound(ALL(b), v) - b.begin();}}}    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(ALL(b), a[i]) - b.begin(); }}\n#endif\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(ALL(a),v))\n#define lowerIndex(a, v) (lower_bound(ALL(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(ALL(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(ALL(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(ALL(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\n//todo 消せないか\ntemplate<class T, class U, class W> T lowerBound(set<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(set<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n\ntemplate<class T, class U, class W> T lowerBound(mset<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(mset<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\n//ll pow(ll a) { return a * a; };\ntemplate<class T> T fact(int v) {    static vector<T> fact(2, 1);    if (sz(fact) <= v) { rep(i, sz(fact), v + 1) { fact.emplace_back(fact.back() * i); }}    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\n//二項係数の偶奇を返す\nint com_mod2(int n,int r){return n == ( r | (n - r) );}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\n#define gcd my_gcd\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\n#define lcm my_lcm\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n#define hypot my_hypot\ndouble hypot(double dx, double dy){return std::sqrt(dx*dx+ dy*dy);}\n\nll sig0(int t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\nbint sig0(bint t) {return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n//b * res <= aを満たす [l, r)を返す div\nP drange_ika(int a, int b) {    P null_p = mp(linf, linf);    if (b == 0) {        if (a >= 0) {            return mp(-linf, linf + 1)/*全て*/;        } else {            return null_p/*無い*/;        }    } else {        if (a >= 0) {            if (b > 0) {                return mp(-linf, a / b + 1);            } else {                return mp(-(a / -b), linf + 1);            }        } else {            if (b > 0) {                return mp(-linf, -ceil(-a, b) + 1);            } else {                return mp(ceil(-a, -b), linf + 1);            }        }    }}\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n//todo stringもセットで\ntemplate<class T> vector<T> sub(const vector<T> &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    vector<T> ret(r - l);    std::copy(A.begin() + l, A.begin() + r, ret.begin());    return ret;}\ntemplate<class T> vector<T> sub(const vector<T> &A, int r) { return sub(A, 0, r); }\ntemplate<class T> vector<T> subn(const vector<T> &A, int l, int len) { return sub(A, l, l + len); }\nstring sub(string &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    return A.substr(l, r - l);}\ntemplate<class T, class F>\n//sub2で呼ぶ\nvector<T> sub(const vector<vector<T> >& A, int h, int w, int ah,int aw, F f){    vector<T> res;    while(0<= h && h < sz(A) && 0 <= w && w < sz(A[h]) && f(A[h][w])){        res.emplace_back(A[h][w]);        h += ah;        w += aw;    }    return res;}\ntemplate<class T> vector<T>sub(const vector<vector<T> >& A, int h, int w, int ah,int aw){return sub(A, h, w, ah, aw, [&](T v){return true;});}\n//range_nowを返す(find_ifでしか使われない)\n#if __cplusplus >= 201703L\ntemplate<class T> auto subr(const vector<T> &A, int l) {return range_now(vector<T>(A.begin()+l, A.end()), l);}\n#endif\n#define sub25(A, h, w, ah, aw) sub(A, h, w, ah, aw)\n#define sub26(A, h, w, ah, aw, siki_r) sub(A, h, w, ah, aw, [&](auto v){return v siki_r;})\n#define sub27(A, h, w, ah, aw, v, siki) sub(A, h, w, ah, aw, [&](auto v){return siki;})\n#define sub2(...) over7(__VA_ARGS__,sub27,sub26,sub25)(__VA_ARGS__)\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\ntemplate<class T> int count(set<T> &S, T l, T r) {    assert(l < r);    auto it = S.lower_bound(l);    return it != S.end() && (*it) < r;}\n\n//template<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\ntemplate<class T> vector<T> geth(vector<vector<T>> &S, int w) {    assert(w < sz(S[0]));    vector<T> ret(sz(S));    rep(h, sz(S)) { ret[h] = S[h][w]; }    return ret;}\n//vector<bool>[i]は参照を返さないため、こうしないとvb[i] |= trueがコンパイルエラー\nvb::reference operator|=(vb::reference a, bool b){return a = a | b;}\nvb::reference operator&=(vb::reference a, bool b){return a = a & b;}\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T, U> operator+(const pair<T, U> &a, const pair<T, U> &b) { return pair<T, U>(a.fi + b.fi, a.se + b.se); }\ntemplate<class T, class U> pair<T,U> operator-(const pair<T,U> &a, const pair<T,U> & b) {return pair<T,U>(a.fi-b.fi,a.se-b.se);}\ntemplate<class T, class U> pair<T,U> operator-(const pair<T, U>& a){return pair<T, U>(-a.first, -a.second);}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {\n#ifdef _DEBUG\n    static bool was = false;if (!was)message += \"str += 65  is  'A'  not \\\"65\\\" \";was = true;\n#endif\n    return lhs + (char) rv;\n}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs = lhs + rv;}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    const int rv2 = rv;    return lhs + rv2;}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {const int v = rv; lhs += v; }\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {    auto bek = s;    s = \"\";    for (; num; num >>= 1) {        if (num & 1) { s += bek; }        bek += bek;    }}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v){a.push(d);}    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v){a.insert(d);}    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(U v,const vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(const vector<T>& a, const vector<T>& b) {    vector<T> ret;    ret = a;    fora(v, b){ret += v; }   return ret;}template<class T> vector<T> &operator+=(vector<T> &a,const vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    for(auto&& bv : b) { a[bv.first] += bv.second; }    return a;}template<class T, class U> vector<T> operator+(const vector<T> &a, const U& v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> auto operator+=(uset<T> &a, U v) { return a.insert(v); }\ntemplate<class T> vector<T> operator%(vector<T>& a, int v){    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = a[i] % v;    }    return ret;}\ntemplate<class T> vector<T> operator%=(vector<T>& a, int v){    rep(i,sz(a)){        a[i] %= v;    }    return a;}\nvi operator&(vi& a, vi& b){    assert(sz(a)==sz(b));    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = min(a[i],b[i]);    }    return ret;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\n//template<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<typename T> void pop_front(vector<T> &v) { erase(v, 0); }\ntemplate<typename T> void entry(vector<T> &v, unsigned ll s, unsigned ll e) { erase(v, e, sz(v));erase(v,0,s);}\n\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\nvector<string> split(const string &a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string &a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nll stoi(string& s){return stol(s);}\n#define assert_yn(yn_v, v); assert(yn_v == 0 || yn_v == v);yn_v = v;\n//不完全な対策、現状はautohotkeyで対応\nint yn_v = 0;\nvoid yn(bool a) { assert_yn(yn_v, 1);if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid fyn(bool a) {    assert_yn(yn_v, 1);yn(a);    exit(0);}\n\nvoid Yn(bool a) { assert_yn(yn_v, 2);if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid fYn(bool a) {    assert_yn(yn_v, 2);Yn(a);    exit(0);}\n\nvoid YN(bool a) { assert_yn(yn_v, 3);if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fYN(bool a) {    assert_yn(yn_v, 3);YN(a);    exit(0);}\nint ab_v = 0;\nvoid fAb(bool a) { assert_yn(ab_v, 1);if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid fAB(bool a) { assert_yn(yn_v, 2);if(a)cout<<\"ALICE\"<<endl;else cout<<\"BOB\";}\nint pos_v = 0;\nvoid Possible(bool a) {    assert_yn(pos_v, 1);if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    assert_yn(pos_v, 2);if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\nvoid fPossible(bool a) {    assert_yn(pos_v, 1)Possible(a);exit(0);}\nvoid fPOSSIBLE(bool a) {    assert_yn(pos_v, 2)POSSIBLE(a);exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename Iterable> vector<Iterable> table(const Iterable &a, int tou = 2) {int N = sz(a);    vector<Iterable> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename Iterable> vector<Iterable> table_n(const Iterable &a, int len) {    int N = sz(a);    vector<Iterable> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//縦を返す\nvi& geth(vvi()& a, int w){    static vi ret; ret.resize(sz(a));   rep(i,sz(a)){        ret[i] = a[i][w];    }    return ret;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n//#define pre prev\n//#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\nvc atoz = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x','y', 'z'};\nvc AtoZ = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z'};\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))return i;    }    return i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))return i; }    return i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\n\n//H*Wのグリッドを斜めに分割する\n//右上\nvector<vp> naname_list_ne(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[sh] += mp(nh, nw);            }else{                break;            }        }    }    rep(sw, 1, W) {        int sh = H - 1;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[H + sw-1] += mp(nh, nw);            }else{                break;            }        }    }    return res;}\n//右下\nvector<vp> naname_list_se(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh< H && nw < W) { res[sh] += mp(nh, nw); } else { break; }        }    }    rep(sw, 1, W) {        int sh = 0;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh < H && nw < W) { res[H + sw - 1] += mp(nh, nw); } else { break; }        }    }    return res;}\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) ((h) * (W) + (w))\n#define getid_1(p) ((p).first * W + (p).second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nvb bit_bool(int v, int len) {    assert(bit(len) > v);    vb ret(len);    rep(i, len) { ret[i] = bget(v, i); }    return ret;}\nvi range(int l, int r) {vi ret;ret.resize(r - l);rep(v, l, r) {ret[v - l] = v;}return ret;}\nvi range(int r) {return range(0, r);}\nvi tov(vb& a){    vi ret;    rep(i,sz(a)){        if(a[i])ret.push_back(i);    }    return ret;}\nbool kaibun(const str& S){return S==rev(S);}\ntemplate<class T> vector<T> repeat(const vector<T> &A, int kaisu) {    vector<T> ret;    while (kaisu--) {        ret += A;    }    return ret;}\n#define rge range\n#define upd update\n//S[{s, t, d}]\n#define strs slice_str\nstruct slice_str {\n    string S;\n    slice_str() {}\n    slice_str(const string &S) : S(S) {}\n    slice_str(int len, char c) : S(len, c) {}\n    auto size(){return S.size();}\n    char& operator[](int p) {        return S[p]; }\n    string operator[](initializer_list<int> p) {        if (sz(p) == 1) {            return S.substr(0, *(p.begin()));        } else if (sz(p) == 2) {            int l = *(p.begin());            int r = *(next(p.begin()));            return S.substr(l, r - l);        } else {            auto it = p.begin();            int s = *(it++);            int t = *(it++);            int d = *(it);            if (d == -1) {                int s_ = sz(S) - s - 1;                int t_ = sz(S) - t - 1;                return rev(S).substr(s_, t_ - s_);            } else if (d < 0) {                t = max(-1ll, t);                string ret;                while (s > t) {                    ret += S[s];                    s += d;                }                return ret;            } else {                t = min(sz(S), t);                string ret;                while (s < t) {                    ret += S[s];                    s += d;                }                return ret;            }        }    }\n    operator string &() {        return S;    }\n    template<class T> void operator+=(const T &a) { S += a; }\n    bool operator==(const slice_str& rhs){return S==rhs.S;}\n};\nostream &operator<<(ostream &os, const slice_str &a) {    os << a.S;    return os;}\nistream &operator>>(istream &iss, const slice_str &a) {    iss >> a.S;    return iss;}\ntemplate<class T> bool can(const T &v, int i) { return 0 <= i && i < sz(v); }\n#if __cplusplus >= 201703L\n//template<class T> auto sum(int a, T  v...) {return (v + ... + 0);}\n#endif\n#define VEC vector\n#endif /*UNTITLED15_TEMPLATE_H*/\n\n#endif\n\n//† ←template終了\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n#ifndef MINT\n#define MINT\n/*@formatter:off*/\ntemplate<typename T> T minv(T a, T m);\ntemplate<typename T> T minv(T a);\n\nusing Type = std::uint_fast64_t;\ntemplate <typename Mod_t> class modint {\n    constexpr static auto mod() { return Mod_t::value; }\npublic:\n    Type value;\n    constexpr modint() : value(){}\n    constexpr modint(const Type &x) noexcept {\n        if (-mod() <= x && x < mod()) value = static_cast<Type>(x); else value = static_cast<Type>(x % mod());\n        if (value < 0) value += mod();\n    }\n    const Type &operator()() const { return value; }\n    template<typename U> explicit operator U() const { return static_cast<U>(value); }\n\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        value += rhs.value;\n        if (value >= mod()) {\n            value -= mod();\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (value < rhs.value) {\n            value += mod();\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        value = value * rhs.value % mod();\n        return *this;\n    }\n    constexpr modint &operator/=(const modint& rhs) noexcept {\n        return operator*=(minv(rhs.value));\n    }\n    modint &operator++() { return *this += 1; }\n    modint &operator--() { return *this -= 1; }\n    modint operator++(signed) {\n        modint result(*this);\n        *this += 1;\n        return result;\n    }\n    modint operator--(signed) {\n        modint result(*this);\n        *this -= 1;\n        return result;\n    }\n    modint operator-() const { return modint(-value); }\n    template<typename U> friend bool operator==(const modint<U> &lhs, const modint<U> &rhs);\n    template<typename U> friend bool operator<(const modint<U> &lhs, const modint<U> &rhs);\n    template<typename U> friend std::istream &operator>>(std::istream &stream, modint<U> &number);\n    operator int() { return value; }\n};\n/*@formatter:off*/\ntemplate<typename T> bool operator==(const modint<T> &lhs, const modint<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const modint<T> &lhs, U rhs) { return lhs == modint<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const modint<T> &rhs) { return modint<T>(lhs) == rhs; }\ntemplate<typename T> bool operator!=(const modint<T> &lhs, const modint<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const modint<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const modint<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T> bool operator<(const modint<T> &lhs, const modint<T> &rhs) { return lhs.value < rhs.value; }\ntemplate<typename T> modint<T> operator+(const modint<T> &lhs, const modint<T> &rhs) { return modint<T>(lhs) += rhs; }\ntemplate<typename T, typename U> modint<T> operator+(const modint<T> &lhs, U rhs) { return modint<T>(lhs) += rhs; }\ntemplate<typename T, typename U> modint<T> operator+(U lhs, const modint<T> &rhs) { return modint<T>(lhs) += rhs; }\ntemplate<typename T> modint<T> operator-(const modint<T> &lhs, const modint<T> &rhs) { return modint<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> modint<T> operator-(const modint<T> &lhs, U rhs) { return modint<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> modint<T> operator-(U lhs, const modint<T> &rhs) { return modint<T>(lhs) -= rhs; }\ntemplate<typename T> modint<T> operator*(const modint<T> &lhs, const modint<T> &rhs) { return modint<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> modint<T> operator*(const modint<T> &lhs, U rhs) { return modint<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> modint<T> operator*(U lhs, const modint<T> &rhs) { return modint<T>(lhs) *= rhs; }\ntemplate<typename T> modint<T> operator/(const modint<T> &lhs, const modint<T> &rhs) { return modint<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> modint<T> operator/(const modint<T> &lhs, U rhs) { return modint<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> modint<T> operator/(U lhs, const modint<T> &rhs) { return modint<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> modint<T> operator%(const modint<T> &lhs, U rhs) {    cerr << \"can't  mint % int\" << endl;    assert(0);    exit(0);    return 0;}\n\nconstexpr signed MOD =\n        998244353;\n//        1e9 + 7;//MOD\nusing mint = modint<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n#ifdef optional\ntemplate<class T> optional<mint> operator+(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv + opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator-(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator*(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator/(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv / opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator+(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv + opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator-(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator*(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator/(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv / opt.value(); else return optional<mint>(); }\ntemplate<class T> void operator+=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv += opt.value(); }\ntemplate<class T> void operator-=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv -= opt.value(); }\ntemplate<class T> void operator*=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv *= opt.value(); }\ntemplate<class T> void operator/=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv /= opt.value(); }\ntemplate<class T> void operator+=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value += mv;}\ntemplate<class T> void operator-=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value -= mv;}\ntemplate<class T> void operator*=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value *= mv;}\ntemplate<class T> void operator/=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value /= mv;}\n#endif\n//constexpr int mint_len = std::min(1400001, MOD);\nvi fac, finv, inv;\nvi p2;\nvoid setmod_resize(int mint_len) {\n//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n    int tn = sz(fac);\n    fac.resize(mint_len);\n    finv.resize(mint_len);\n    inv.resize(mint_len);\n    inv[1] = fac[0] = finv[0] = 1;\n    for (int i = tn; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    for (int i = tn; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n}\n//4e6 >= n なら O(r)で計算する\nmint com_big(int n, int r) {    int fa = finv[r];    rep(i, r)fa *= n - i, fa %= MOD;    return mint(fa);}\nmint com(int n, int r) {if (r < 0 || r > n) return 0;    /*nが大きくてrが小さい場合、nを上からr個掛ける*/    if (n >= sz(fac)) { if (n <= 4e6)setmod_resize(n + 1000); else return com_big(n, r); }return mint(finv[r] * fac[n] % MOD * finv[n - r]);}\nmint pom(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;return mint(fac[n] * finv[n - r]);}\nmint npr(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;return mint(fac[n] * finv[n - r]);}\nmint com_grid(int n, int r) {assert(r);return com(n + r - 2, n - 1);}\nint nprin(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;return fac[n] * finv[n - r] % MOD;}\nint icom(int n, int r) {    const int NUM_ = 1400001;    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];    if (fac[0] == 0) {        inv[1] = fac[0] = finv[0] = 1;        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;    }    if (r < 0 || r > n) return 0;    return ((finv[r] * fac[n] % MOD) * finv[n - r]) % MOD;}\n#define ncr com\n#define ncri icom\n//n種類でr個選ぶ\n//n個の場所にr個の物を置く\n//負が渡された場合もcomが処理出来る\nmint nhr(int n, int r) { if (n == 0 && r == 0)return 1; else return com(n + r - 1, r); }\n//n種類でそれぞれ少なくとも1つは選び、r個揃える\nmint nhr1(int n, int r) { return nhr(n, r - n); }\nmint hom(int n, int r) { if (n == 0 && r == 0)return 1; else return com(n + r - 1, r); }\nint nhri(int n, int r) { if (n == 0 && r == 0)return 1; else return icom(n + r - 1, r); }\n//グリッドで0-indexedの最短経路 pascal\nmint pas(int h, int w) { return com(h + w, w); }\ntemplate<typename T> T minv(T a, T m) {    T u = 0, v = 1;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T> T minv(T a) {    if (a < sz(fac)){        return inv[a];    }    T u = 0, v = 1;    T m = MOD;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\n//int型 mod m\ntemplate<typename T, typename U, typename V> int mpow(const T a, const U b, const V m) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U> modint<T> mpow(const modint<T> &a, const U &b) {    assert(b >= 0);    int x = a(), res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\n//-k乗出来る\ntemplate<typename T, typename U> mint mpow(const T a, const U b) {/*    assert(b >= 0);*/    if (b < 0) { return minv(mpow(a, -b)); }    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<class T> mint mpow(bint a, const T b) { return mpow((mint) a, b); }\ntemplate<typename T, typename U, typename V> int mpowi(const T &a, const U &b, const V &m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T> string to_string(const modint<T> &number) { return to_string(number()); }\n#ifdef _DEBUG\nvoid yuri(const mint &a) {    stringstream st;    rep(i, 300) {        rep(j, 300) {            if ((mint) i / j == a) {                st << i << \" / \" << j;                i = 2000;                break;            }        }    }    string val = st.str();    if (val != \"\") {        deb(val);        return;    }    rep(i, 1000) {        rep(j, 1000) {            if ((mint) i / j == a) {                st << i << \" / \" << j;                i = 2000;                break;            }        }    }    val = st.str();    deb(val);}\n#else\n#define yuri(...) ;\n#endif\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const modint<T> &number) {\n    stream << number();\n#ifdef _DEBUG\n//    stream << \" -> \" << yuri(number);\n#endif\n    return stream;\n}\n//@formatter:off\ntemplate<typename T> std::istream &operator>>(std::istream &stream, modint<T> &number) {    typename common_type<typename modint<T>::Type, int64_t>::type x;    stream >> x;    number.value = modint<T>::normalize(x);    return stream;}\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\nusing mapm = map<int, mint>;\nusing umapm = umap<int, mint>;\n#define vvm(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(mint,__VA_ARGS__)\n#define vnm(name, ...) auto name = make_v<mint>(__VA_ARGS__)\nstring out_m2(mint a) {    stringstream st;    st<<(int)a ;    rep(i, 300) {        rep(j, 2, 300) {            if ((i%j)&&(mint) i / j == a) {                st <<\"(\"<< i << \"/\" << j<<\")\";                i = 2000;                break;            }        }    }    return st.str();}\n//nhr n個の場所にr個の物を分ける\nmint m1 = (mint) 1;\nmint half = (mint) 1 / 2;\nstruct setmod{\n    //comで長さが足りない場合はsetmod_resizeでリサイズする\n    int mint_len =1.4*1e6;\n    setmod() {\n    //p2を使う場合setmod_resizeも変える\n//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n        fac.resize(mint_len);    finv.resize(mint_len);    inv.resize(mint_len);    inv[1] = fac[0] = finv[0] = 1;    for (int i = 2; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;    for (int i = 1; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n}}setmodv;\ntemplate<signed S> using mint_ = modint<std::integral_constant<decay<signed>::type, S>>;\n#endif\n/*@formatter:on*/\n\nvoid solve() {\n    using Mint = mint;\n    int n;\n    cin >> n;\n    vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n    for (int r = 0; r < 3; r++) {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            --x; --y;\n            if (x > y) {\n                swap(x, y);\n            }\n            g[r][x].push_back(y);\n        }\n    }\n    Mint p = (long long) 1e18;\n    vector<Mint> pw(n);\n    pw[0] = p;\n    for (int i = 1; i < n; i++) {\n        pw[i] = pw[i - 1] * p;\n    }\n    const int MAX = 512;\n    vector<vector<Mint>> cnt(3, vector<Mint>(MAX));\n    for (int r = 0; r < 3; r++) {\n        vector<int> gr(n);\n        for (int i = n - 1; i >= 0; i--) {\n            set<int> s;\n            for (int j : g[r][i]) {\n                s.insert(gr[j]);\n            }\n            while (s.find(gr[i]) != s.end()) {\n                ++gr[i];\n            }\n            cnt[r][gr[i]] += pw[i];\n        }\n    }\n    Mint ans = 0;\n    for (int x = 0; x < MAX; x++) {\n        for (int y = 0; y < MAX; y++) {\n            ans += cnt[0][x] * cnt[1][y] * cnt[2][x ^ y];\n        }\n    }\n    cout << ans << '\\n';\n}\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n        //solveを書き直す\n        //solveを呼び出す\n    }\n    if (was_deb && sz(res_mes)) {\n        cerr << \"result = \" << endl << res_mes << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << \"Note.\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nconst int mod = 998244353;\nint m[3];\nint g[3][100000];\nint p[3];\nlong long sum[3][100000];\nvector <int> v[3][100000];\n\nlong long powmod(long long x, long long y) {\n    long long ans = 1;\n    \n    while (y > 0) {\n        if (y & 1) ans = ans * x % mod;\n        x = x * x % mod;\n        y >>= 1;\n    }\n    \n    return ans;\n}\n\nint main() {\n    int n, i, j, k;\n    long long ans = 0;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < 3; i++) {\n        scanf(\"%d\", &m[i]);\n        \n        for (j = 0; j < m[i]; j++) {\n            int x, y;\n            \n            scanf(\"%d %d\", &x, &y);\n            \n            x--;\n            y--;\n            \n            if (x > y) swap(x, y);\n            \n            v[i][x].push_back(y);\n        }\n    }\n    \n    for (i = 0; i < 3; i++) {\n        for (j = n - 1; j >= 0; j--) {\n            set <int> s;\n            \n            for (k = 0; k < v[i][j].size(); k++) s.insert(g[i][v[i][j][k]]);\n            \n            for (k = 0; ; k++) {\n                if (!s.count(k)) {\n                    g[i][j] = k;\n                    break;\n                }\n            }\n            \n            p[i] = max(p[i], g[i][j]);\n            sum[i][g[i][j]] += powmod(10, 18 * (j + 1));\n            if (sum[i][g[i][j]] >= mod) sum[i][g[i][j]] -= mod;\n        }\n    }\n    \n    for (i = 0; i <= p[0]; i++) {\n        for (j = 0; j <= p[1]; j++) {\n            int x = i ^ j;\n            \n            if (x <= p[2]) ans += sum[0][i] * sum[1][j] % mod * sum[2][x] % mod;\n        }\n    }\n    \n    printf(\"%lld\\n\", ans % mod);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+7,p=998244353; bool fl[N];\nint n,m,l,f1[N],f2[N],f3[N],g1[N],g2[N],g3[N]; long long g[N]; vector<int>v1[N],v2[N],v3[N];\ninline int read(){\n\tint num=0; char g=getchar(); while(g<48||57<g) g=getchar();\n\twhile(47<g&&g<58) num=(num*10)+g-48,g=getchar(); return num;\n}\ninline void fwt(int *s){\n\tfor(int d=1;d<l;d=d<<1)\n\t\tfor(int i=0,r=d<<1;i<l;i+=r)\n\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\tint a=s[i+j],b=s[i+j+d];\n\t\t\t\ts[i+j]=(a+b)%p,s[i+j+d]=(a-b+p)%p;\n\t\t\t}\n}\ninline void twf(int *s){\n\tfor(int d=1;d<l;d=d<<1)\n\t\tfor(int i=0,r=d<<1;i<l;i+=r)\n\t\t\tfor(int j=0;j<d;j++){\n\t\t\t\tint a=s[i+j],b=s[i+j+d];\n\t\t\t\ts[i+j]=1ll*(a+b)%p*((p+1)/2)%p,s[i+j+d]=1ll*(a-b+p)%p*((p+1)/2)%p;\n\t\t\t}\n}\nint main(){\n\tg[0]=1,g[1]=716070898,cin>>n; int u,t;\n\tfor(int i=2;i<=n;i++) g[i]=g[i-1]*g[1]%p;\n\tm=read();\n\tfor(int i=1;i<=m;i++){\n\t\tu=read(),t=read(); if(u>t) swap(u,t); v1[u].push_back(t);\n\t}\n\tm=read();\n\tfor(int i=1;i<=m;i++){\n\t\tu=read(),t=read(); if(u>t) swap(u,t); v2[u].push_back(t);\n\t}\n\tm=read();\n\tfor(int i=1;i<=m;i++){\n\t\tu=read(),t=read(); if(u>t) swap(u,t); v3[u].push_back(t);\n\t}\n\tfor(int i=n-1;i>=1;i--){\n\t\tfor(int x=0;x<v1[i].size();x++){\n\t\t\tint u=v1[i][x]; fl[f1[u]]=1;\n\t\t}\n\t\twhile(fl[f1[i]]) f1[i]++;\n\t\tfor(int x=0;x<v1[i].size();x++){\n\t\t\tint u=v1[i][x]; fl[f1[u]]=0;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=1;i--){\n\t\tfor(int x=0;x<v2[i].size();x++){\n\t\t\tint u=v2[i][x]; fl[f2[u]]=1;\n\t\t}\n\t\twhile(fl[f2[i]]) f2[i]++;\n\t\tfor(int x=0;x<v2[i].size();x++){\n\t\t\tint u=v2[i][x]; fl[f2[u]]=0;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=1;i--){\n\t\tfor(int x=0;x<v3[i].size();x++){\n\t\t\tint u=v3[i][x]; fl[f3[u]]=1;\n\t\t}\n\t\twhile(fl[f3[i]]) f3[i]++;\n\t\tfor(int x=0;x<v3[i].size();x++){\n\t\t\tint u=v3[i][x]; fl[f3[u]]=0;\n\t\t}\n\t}\n\tl=1; while(l<=n) l=l*2;\n\t\n\tfor(int i=1;i<=n;i++) g1[f1[i]]=(g1[f1[i]]+g[i])%p,g2[f2[i]]=(g2[f2[i]]+g[i])%p,g3[f3[i]]=(g3[f3[i]]+g[i])%p;\n\tfwt(g1),fwt(g2),fwt(g3);\n\tfor(int i=0;i<l;i++) g1[i]=1ll*g1[i]*g2[i]%p*g3[i]%p; twf(g1);\n\tcout<<g1[0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=100005;\nconst int mod=998244353;\nnamespace {\n    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}\n    inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}\n    inline int Mul(int x,int y) {return 1ll*x*y%mod;}\n    inline int Pow(int x,int y=mod-2){if(y==0)return 1;int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}\n}\nint n,m;\nvector<int> G[max_n];\nvector<int> solve(vector<int> a,vector<int> b){\n    vector<int> c;\n    c.assign(1024,0);\n    for(int i=0;i<1024;i++){\n        for(int j=0;j<1024;j++)c[i^j]=Add(c[i^j],Mul(a[i],b[j]));\n    }\n    return c;\n}\nint p[max_n];\nint sg[max_n];\nint SG(int u){\n    if(~sg[u])return sg[u];\n    set<int> s;\n    for(auto v:G[u]){\n        if(v>u)s.insert(SG(v));\n    }\n    for(int i=0;;i++)if(s.count(i)==0)return sg[u]=i;\n}\nint main(){\n    p[0]=1,p[1]=Pow(10,18);\n    for(int i=2;i<max_n;i++)p[i]=Mul(p[i-1],p[1]);\n    scanf(\"%d\",&n);\n    vector<int> f;f.assign(1024,0);f[0]=1;\n    vector<int> a;\n    scanf(\"%d\",&m);\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        assert(x<1024);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        assert(x<1024);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        assert(x<1024);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    printf(\"%d\\n\",f[0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<cstring>\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\ntypedef long long ll;\nconst ll INF=1e18;\nconst int Mod=998244353;\n\nint n,m; int p[100010];\nstruct Edge{\n\tint to,nxt;\n}edge[100010];\nint cnt,last[100010];\ninline void addedge(int x,int y){\n\tif (x>y) swap(x,y);\n\tedge[++cnt]=(Edge){y,last[x]},last[x]=cnt;\n}\nint mxa=-1,mxb=-1,mxc=-1;\nint a[100010],b[100010],c[100010];\nbool mrk[100010]; int sg[100010];\nint main()\n{\n\tn=read();\n\tp[0]=1; p[1]=INF%Mod; for (int i=2;i<=n;i++) p[i]=1LL*p[i-1]*p[1]%Mod;\n\t\n\tm=read();\n\tcnt=0; memset(last+1,0,n*sizeof(int));\n\tfor (int i=1;i<=m;i++) addedge(read(),read());\n\tfor (int i=n;i;i--){\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt) mrk[sg[v=edge[j].to]]=1;\n\t\tfor (sg[i]=0;mrk[sg[i]];sg[i]++);\n\t\ta[sg[i]]=(a[sg[i]]+p[i])%Mod; mxa=max(mxa,sg[i]);\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt) mrk[sg[v=edge[j].to]]=0;\n\t}\n\t\n\tm=read();\n\tcnt=0; memset(last+1,0,n*sizeof(int));\n\tfor (int i=1;i<=m;i++) addedge(read(),read());\n\tfor (int i=n;i;i--){\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt) mrk[sg[v=edge[j].to]]=1;\n\t\tfor (sg[i]=0;mrk[sg[i]];sg[i]++);\n\t\tb[sg[i]]=(b[sg[i]]+p[i])%Mod; mxb=max(mxb,sg[i]);\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt) mrk[sg[v=edge[j].to]]=0;\n\t}\n\t\n\tm=read();\n\tcnt=0; memset(last+1,0,n*sizeof(int));\n\tfor (int i=1;i<=m;i++) addedge(read(),read());\n\tfor (int i=n;i;i--){\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt) mrk[sg[v=edge[j].to]]=1;\n\t\tfor (sg[i]=0;mrk[sg[i]];sg[i]++);\n\t\tc[sg[i]]=(c[sg[i]]+p[i])%Mod; mxc=max(mxc,sg[i]);\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt) mrk[sg[v=edge[j].to]]=0;\n\t}\n\t\n\tint ans=0;\n\tfor (int i=0;i<=mxa;i++)\n\t\tfor (int j=0;j<=mxb;j++)\n\t\t\tif ((i^j)<=mxc)\n\t\t\t\tans=(ans+1LL*a[i]*b[j]%Mod*c[i^j])%Mod;\n\tprintf(\"%d\\n\",(ans+Mod)%Mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint operator~() const { return mint(1) / *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.pow(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint pow(ll t) const {\n    if(!t) return 1;\n    mint res = pow(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.pow(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].pow(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint operator()(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  mint ten = ex(10,18);\n  vm ts(n*3+1);\n  ts[0] = 1;\n  rep(i,n*3) ts[i+1] = ts[i]*ten;\n  vm dp(2); dp[0] = 1;\n  rep(gi,3) {\n    int m;\n    scanf(\"%d\",&m);\n    vvi to(n);\n    rep(i,m) {\n      int a,b;\n      scanf(\"%d%d\",&a,&b);\n      --a; --b;\n      if (a > b) swap(a,b);\n      to[a].pb(b);\n    }\n    vi c(n);\n    drep(i,n) {\n      for (int u : to[i]) {\n        c[i] |= !c[u];\n      }\n    }\n    vm d(2);\n    rep(i,n) {\n      d[c[i]] += ts[i+1];\n    }\n    vm p(2);\n    swap(dp,p);\n    rep(i,2)rep(j,2) {\n      dp[i^j] += p[i]*d[j];\n    }\n  }\n  cout<<dp[0]<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\n#define P 998244353\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nll perm(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (fac[n]*finv[n-k])%P;\n}\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\n\ntypedef vector<set<ll>> graph;\nll n;\n\nvvl get(graph g){\n  //なるべく大きい要素を取る独立集合\n  //現在とったものに隣接していない最大の要素を貪欲に取っていく\n  vvl dat;\n  vll go(n+1, 0);\n\n  for(int i=n;i>0;i--){\n    //iが何番目の集合に入るか\n    if(dat.size()<=go[i]) dat.push_back(vll());\n    dat[go[i]].push_back(i);\n    for(auto to:g[i]){\n      if(go[to]==go[i]) go[to]++;\n      g[to].erase(i);\n    }\n  }\n  return dat;\n}\n\n\nvector<ll> cost(400000, 1);\n\n\n//独立集合の重み\nll get_cost(vll v){\n  ll ret = 0;\n  for(int i=0;i<v.size();i++) ret = (ret + cost[v[i]])%P;\n  return ret;\n}\n\nint main(int argc, char const *argv[]) {\n  init();\n  ll x = 1000000000000000000%P;\n  for(int i=1;i<400000;i++) cost[i] = (cost[i-1] * x)%P;\n\n  // X, Y, Zの独立集合からそれぞれ一つ選び大きいもの同士で合わせていく\n  // 1でも大きい方が良い\n  std::cin >> n;\n\n  vvl d = VV(3, 0, 0, ll);\n  for(int i=0;i<3;i++){\n    ll m;std::cin >> m;\n    graph g(n+1);\n    for(int j=0;j<m;j++){\n      ll a, b;scanf(\"%lld %lld\", &a, &b);\n      g[a].insert(b);\n      g[b].insert(a);\n    }\n    vvl x = get(g);\n    for(int j=0;j<x.size();j++) {\n      d[i].push_back(get_cost(x[j]));\n    }\n  }\n\n  ll ans = pp(pp(d[0][0], d[1][0]), d[2][0]);\n\n\n  //0\n  for(int j=1;j<n;j++){\n    if(j>=d[1].size()||j>=d[2].size()) break;\n    ans = (ans + pp(d[0][0], pp(d[1][j], d[2][j])))%P;\n  }\n  //1\n  for(int j=1;j<n;j++){\n    if(j>=d[2].size()||j>=d[0].size()) break;\n    ans = (ans + pp(d[1][0], pp(d[0][j], d[2][j])))%P;\n  }\n  //2\n  for(int j=1;j<n;j++){\n    if(j>=d[1].size()||j>=d[0].size()) break;\n    ans = (ans + pp(d[2][0], pp(d[0][j], d[1][j])))%P;\n  }\n\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define cs const\n#define re register\n#define pb push_back\n#define pii pair<int,int>\n#define ll long long\n#define fi first\n#define se second\n#define bg begin\ncs int RLEN=1<<20|1;\ninline char gc(){\n    static char ibuf[RLEN],*ib,*ob;\n    (ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n    return (ib==ob)?EOF:*ib++;\n}\ninline int read(){\n    char ch=gc();\n    int res=0;bool f=1;\n    while(!isdigit(ch))f^=ch=='-',ch=gc();\n    while(isdigit(ch))res=(res+(res<<2)<<1)+(ch^48),ch=gc();\n    return f?res:-res;\n}\ninline ll readll(){\n    char ch=gc();\n    ll res=0;bool f=1;\n    while(!isdigit(ch))f^=ch=='-',ch=gc();\n    while(isdigit(ch))res=(res+(res<<2)<<1)+(ch^48),ch=gc();\n    return f?res:-res;\n}\ninline int readstring(char *s){\n\tint top=0;char ch=gc();\n\twhile(isspace(ch))ch=gc();\n\twhile(!isspace(ch)&&ch!=EOF)s[++top]=ch,ch=gc();\n\treturn top;\n}\ntemplate<typename tp>inline void chemx(tp &a,tp b){a<b?a=b:0;}\ntemplate<typename tp>inline void chemn(tp &a,tp b){a>b?a=b:0;}\ncs int mod=998244353;\ninline int add(int a,int b){return (a+=b)>=mod?(a-mod):a;}\ninline int dec(int a,int b){a-=b;return a+(a>>31&mod);}\ninline int mul(int a,int b){static ll r;r=1ll*a*b;return (r>=mod)?(r%mod):r;}\ninline void Add(int &a,int b){(a+=b)>=mod?(a-=mod):0;}\ninline void Dec(int &a,int b){a-=b,a+=a>>31&mod;}\ninline void Mul(int &a,int b){static ll r;r=1ll*a*b;a=(r>=mod)?(r%mod):r;}\ninline int ksm(int a,int b,int res=1){for(;b;b>>=1,Mul(a,a))(b&1)&&(Mul(res,a),1);return res;}\ninline int Inv(int x){return ksm(x,mod-2);}\ninline int fix(int x){return (x<0)?x+mod:x;}\ncs int N=100005;\nint *f,ft[3][N],n,m,mx,lim;\nint pw[N],vis[N],sg[N];\nvector<int> e[N];\nvoid dfs(int u){\n\tif(sg[u]!=-1)return;\n\tsg[u]=0;\n\tfor(int &v:e[u])dfs(v);\n\tfor(int &v:e[u])vis[sg[v]]=1;\n\twhile(vis[sg[u]])sg[u]++;\n\tfor(int &v:e[u])vis[sg[v]]=0;\n\tAdd(f[sg[u]],pw[u]);\n}\ninline void fwt(int *f,int lim){\n\tfor(int mid=1,a0,a1;mid<lim;mid<<=1)\n\tfor(int i=0;i<lim;i+=mid<<1)\n\tfor(int j=0;j<mid;j++)\n\ta0=f[i+j],a1=f[i+j+mid],f[i+j]=add(a0,a1),f[i+j+mid]=dec(a0,a1);\n}\ninline void ifwt(int *f,int lim){\n\tfor(int mid=1,a0,a1;mid<lim;mid<<=1)\n\tfor(int i=0;i<lim;i+=mid<<1)\n\tfor(int j=0;j<mid;j++)\n\ta0=f[i+j],a1=f[i+j+mid],f[i+j]=add(a0,a1),f[i+j+mid]=dec(a0,a1);\n\tfor(int i=0,iv=Inv(lim);i<lim;i++)Mul(f[i],iv);\n}\nint main(){\n\t#ifdef Stargazer\n\tfreopen(\"lx.in\",\"r\",stdin);\n\t#endif\n\tn=read();\n\tpw[0]=1;\n\tfor(int i=1,mt=(ll)(1e18)%mod;i<N;i++)pw[i]=mul(pw[i-1],mt);\n\tfor(int t=0;t<3;t++){\n\t\tm=read();chemx(mx,m);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint u=read(),v=read();\n\t\t\tif(u>v)swap(u,v);\n\t\t\te[u].pb(v);\n\t\t}\n\t\tf=ft[t];\n\t\tmemset(sg,-1,sizeof(sg));\n\t\tfor(int i=1;i<=n;i++)if(sg[i]==-1)dfs(i);\n\t\tfor(int i=1;i<=n;i++)e[i].clear();\n\t}\n\tlim=1;\n\twhile(lim*(lim/2)<mx)lim<<=1;\n\tfwt(ft[0],lim),fwt(ft[1],lim),fwt(ft[2],lim);\n\tfor(int i=0;i<lim;i++)Mul(ft[0][i],mul(ft[1][i],ft[2][i]));\n\tifwt(ft[0],lim);\n\tcout<<ft[0][0]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nconst int mod=998244353;\nint h[N],e[N],ne[N],idx;\nint f[N],g[N];\nll sum[3][N];\nint sz[3];\nvoid add(int a,int b)\n{\n    e[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\nint inv;\nll qmi(int a,int b)\n{\n    ll ans=1;\n    while(b)\n    {\n        if(b&1)ans=(ans*a)%mod;\n        a=((ll)a*a)%mod;\n        b>>=1;\n    }\n    return ans;\n}\nll gs(int a,int b)\n{\n    return qmi(a,b);\n}\nint main()\n{\n    int n;\n    cin>>n;\n    inv=qmi(qmi(10,18),mod-2);\n    for(int i=0;i<3;i++)\n    {\n        int m;\n        cin>>m;\n        memset(h,-1,sizeof h);\n        idx=0;\n        for(int j=0;j<m;j++)\n        {\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            if(a>b)swap(a,b);\n            add(a,b);\n        }\n        memset(g,0,sizeof g);\n        ll now=gs(10,18*n);\n        int num=0;\n        for(int j=n;j>=1;j--)\n        {\n            num++;\n            for(int k=h[j];k!=-1;k=ne[k])\n            {\n                g[f[e[k]]]=num;\n            }\n            f[j]=0;\n            while(g[f[j]]==num)f[j]++;\n            // cout<<f[j]<<endl;\n            sz[i]=max(sz[i],f[j]);\n            ll&v=sum[i][f[j]];\n            // cout<<now<<endl;\n            v=(v+now)%mod;\n            now=(now*inv)%mod;\n        }\n    }\n    ll ans=0;\n    // cout<<sz[1]<<endl;\n    for(int i=0;i<=sz[0];i++)\n    {\n        for(int j=0;j<=sz[1];j++)\n        {\n            int k=i^j;\n            ans=(ans+sum[0][i]*sum[1][j]%mod*sum[2][k]%mod)%mod;\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = 998244353;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 100 * 1000 + 13;\nconst int P = 1000;\n\nint n;\nvector<int> g[3][N];\n\nbool read(){\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\tforn(i, n) forn(j, 3)\n\t\tg[j][i].clear();\n\tforn(j, 3){\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tforn(i, m){\n\t\t\tint v, u;\n\t\t\tscanf(\"%d%d\", &v, &u);\n\t\t\t--v, --u;\n\t\t\tif (v > u) swap(v, u);\n\t\t\tg[j][v].pb(u);\n\t\t}\n\t}\n\treturn true;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * li(b) % MOD;\n}\n\nint gr[3][N];\nint cnt[3][P];\nint pw[N];\n\nint calc(int i, int v){\n\tif (gr[i][v] != -1)\n\t\treturn gr[i][v];\n\tvector<int> tmp;\n\tfor (auto u : g[i][v])\n\t\ttmp.pb(calc(i, u));\n\tsort(all(tmp));\n\ttmp.resize(unique(all(tmp)) - tmp.begin());\n\tforn(j, sz(tmp)) if (tmp[j] != j)\n\t\treturn gr[i][v] = j;\n\treturn gr[i][v] = sz(tmp);\n}\n\nvoid solve() {\n\tmemset(gr, -1, sizeof(gr));\n\tmemset(cnt, 0, sizeof(cnt));\n\tpw[0] = 1;\n\tpw[1] = INF64 % MOD;\n\tfore(i, 2, N) pw[i] = mul(pw[i - 1], pw[1]);\n\tforn(j, 3) forn(i, n) cnt[j][calc(j, i)] = add(cnt[j][calc(j, i)], pw[i + 1]);\n\tint ans = 0;\n\tforn(i, P) forn(j, P) if ((i ^ j) < P && cnt[0][i] && cnt[1][j] && cnt[2][i ^ j])\n\t\tans = add(ans, mul(mul(cnt[0][i], cnt[1][j]), cnt[2][i ^ j]));\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n#ifdef _DEBUG\n\twhile(read()) {\t\n#else\n\tif(read()) {\n#endif\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\ntypedef long long LL;\nconst int Mod = 998244353;\nconst int MN = 100005, MS = 1 << 9;\n\ninline void Add(int &x, int y) { x -= (x += y) >= Mod ? Mod : 0; }\n\nint N, f1[MN], f2[MN], f3[MN];\nstd::vector<int> G1[MN], G2[MN], G3[MN];\n\ninline void ReadGraph(std::vector<int> *G) {\n\tint M;\n\tscanf(\"%d\", &M);\n\twhile (M--) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif (x > y) std::swap(x, y);\n\t\tG[x].push_back(y);\n\t}\n}\ninline void SolveSG(std::vector<int> *G, int *f) {\n\tstatic int buk[MN];\n\tfor (int i = N; i >= 1; --i) {\n\t\tfor (int x : G[i]) buk[f[x]] = 1;\n\t\tf[i] = 0;\n\t\twhile (buk[f[i]]) ++f[i];\n\t\tfor (int x : G[i]) buk[f[x]] = 0;\n\t}\n}\n\nint pw[MN];\nint b1[MS], b2[MS], b3[MS], Ans;\n\nint main() {\n\tscanf(\"%d\", &N);\n\tReadGraph(G1);\n\tReadGraph(G2);\n\tReadGraph(G3);\n\tSolveSG(G1, f1);\n\tSolveSG(G2, f2);\n\tSolveSG(G3, f3);\n\tpw[0] = 1;\n\tfor (int i = 1; i <= N; ++i) pw[i] = pw[i - 1] * 716070898ll % Mod;\n\tfor (int i = 1; i <= N; ++i) Add(b1[f1[i]], pw[i]);\n\tfor (int i = 1; i <= N; ++i) Add(b2[f2[i]], pw[i]);\n\tfor (int i = 1; i <= N; ++i) Add(b3[f3[i]], pw[i]);\n\tfor (int i = 0; i < MS; ++i)\n\t\tfor (int j = 0; j < MS; ++j)\n\t\t\tAns = (Ans + (LL)b1[i] * b2[j] % Mod * b3[i ^ j]) % Mod;\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint N;\nint M[3];\nvector<int>G[3][100001];\nbool used[3][100001];\nLL gra[3][100001];\nLL ans[3][100001];\n\nLL MOD=998244353;\nLL MM(LL x){\n\tLL answer=1;\n\tLL now=10;\n\twhile(x!=0){\n\t\tif(x%2==1){\n\t\t\tanswer*=now;\n\t\t\tanswer%=MOD;\n\t\t}\n\t\tnow*=now;\n\t\tnow%=MOD;\n\t\tx/=2;\n\t}\n\treturn answer;\n}\n\nvoid calc(int x){\n\tfor(int i=N-1;i>=0;i--){\n\t\tint now=0;\n\t\tvector<int>v;\n\t\tREP(j,G[x][i].size()){\n\t\t\tif(G[x][i][j]>i){\n\t\t\t\tv.push_back(gra[x][G[x][i][j]]);\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tREP(j,v.size()){\n\t\t\tif(v[j]==now)now++;\n\t\t}\n\t\tgra[x][i]=now;\n\t\tans[x][now]+=MM(18*(i+1));\n\t\tans[x][now]%=MOD;\n\t}\n}\n\n\n\nint main(){\n\tcin>>N;\n\tREP(i,3){\n\t\tcin>>M[i];\n\t\tREP(j,M[i]){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[i][a].push_back(b);\n\t\t\tG[i][b].push_back(a);\n\t\t}\n\t}\n\tREP(i,3){\n\t\tREP(j,N){\n\t\t\tused[i][j]=false;\n\t\t}\n\t}\n\tREP(i,3){\n\t\tcalc(i);\n\t}\n\t/*REP(i,3){\n\t\tREP(j,N){\n\t\t\tcout<<ans[i][j]<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tLL answer=0;\n\tREP(i,1001){\n\t\tREP(j,1001){\n\t\t\tint now=i^j;\n\t\t\tLL temp=ans[0][i];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=ans[1][j];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=ans[2][now];\n\t\t\ttemp%=MOD;\n\t\t\t//LL temp=18*(ans[0][i]*ans[1][j]*ans[2][now]);\n\t\t\t/*if(temp!=0){\n\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<now<<\" \"<<temp<<endl;\n\t\t\t\tcout<<ans[0][i]<<\"ans \"<<ans[1][j]<<\" \"<<ans[2][now]<<\" \"<<temp<<endl;\n\t\t\t}*/\n\t\t\tanswer+=temp;\n\t\t\tanswer%=MOD;\n\t\t}\n\t}\n\tcout<<answer<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// -----------------------------------\n// Author     : MatsuTaku\n// Affiliation: Tokushima University\n// Country    : Japan\n// Date       : 03/21/2020\n// -----------------------------------\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 998244353;\nconstexpr ll MAX_GRANDY = 512;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n\n  int N; cin>>N;\n  vector<int> graph[3][N+1];\n  for (int i = 0; i < 3; i++) {\n    int M; cin>>M;\n    for (int m = 0; m < M; m++) {\n      int a,b; cin>>a>>b;\n      if (a > b) swap(a,b);\n      graph[i][a].push_back(b);\n    }\n  }\n\n  vector<ll> pw(N+1);\n  pw[0] = 1;\n  constexpr ll p = ll(1e18)%MOD;\n  for (int i = 1; i <= N; i++) {\n    pw[i] = pw[i-1]*p%MOD;\n  }\n\n  array<array<ll, MAX_GRANDY>, 3> cnt={};\n  for (int i = 0; i < 3; i++) {\n    vector<int> gr(N+1, 0);\n    for (int v = N; v >= 1; v--) {\n      bitset<MAX_GRANDY> ps;\n      for (auto t : graph[i][v])\n        ps[gr[t]] = true;\n      while (ps[gr[v]])\n        ++gr[v];\n      cnt[i][gr[v]] += pw[v];\n      cnt[i][gr[v]] %= MOD;\n    }\n  }\n\n  ll ans = 0;\n  for (int i = 0; i < MAX_GRANDY; i++) for (int j = 0; j < MAX_GRANDY; j++) {\n    ans += cnt[0][i] * cnt[1][j] % MOD * cnt[2][i^j] % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#include<unordered_set>\n#include<unordered_map>\n#include<random>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = (ll)(998'244'353);\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int (i)=0; (i)<(n); (i)++)\nint dx[4]={ 1,0,-1,0 };\nint dy[4]={ 0,1,0,-1 };\n\ntemplate<typename T>\nT power(T x, long long n, const T &m){\n    if(n == 0) return 1;\n    if(n == 1) return x;\n    T tmp = power(x, n/2, m);\n    if(n%2 == 0) return tmp * tmp % m;\n    else return tmp * tmp % m * x % m;\n}\n\nint N;\nint M[3];\nvector<int> e[3][100000];\nint use1[3][100000] ={};\nint use2[3][100000] ={};\nll ans1, ans2;\n\nsigned main(){\n    cin >> N;\n    rep(i, 3){\n        cin >> M[i];\n        rep(j, M[i]){\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            e[i][a].pb(b);\n            e[i][b].pb(a);\n        }\n        ll tmp1 = 0;\n        ll tmp2 = 0;\n        for(int j=N-1; j>=0; j--){\n            bool ok1 = true;\n            rep(k, e[i][j].size()){\n                ok1 &= !use1[i][e[i][j][k]];\n            }\n            if(ok1){\n                use1[i][j] = true;\n                tmp1 += power(10LL, 18*(j+1), MOD);\n            }\n            else{\n                bool ok2 = true;\n                rep(k, e[i][j].size()){\n                    ok2 &= !use2[i][e[i][j][k]];\n                }\n                if(ok2){\n                    use2[i][j] = true;\n                    tmp2 += power(10LL, 18*(j+1), MOD);\n                }\n            }\n        }\n        tmp1 %= MOD;\n        tmp2 %= MOD;\n        //cout << tmp1 % MOD << \" \" << tmp2 % MOD << endl;\n        if(i == 0){\n            ans1 = tmp1;\n            ans1 %= MOD;\n            ans2 = tmp2;\n            ans2 %= MOD;\n        }\n        else{\n            ll a1 = ans1;\n            ll a2 = ans2;\n            ans1 = a1*tmp1 + a2*tmp2;\n            ans1 %= MOD;\n            ans2 = a1*tmp2 + a2*tmp1;\n            ans2 %= MOD;\n        }\n        //cout << ans1 << \" \" << ans2 << endl;\n    }\n    cout << ans1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n#include<vector>\n\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int library\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\nclass CGiantGraph {\npublic:\n\n    vector<vector<int>> ga, gb, gc;\n    vector<int> gra, grb, grc;\n    vector<int> tmp;\n    void func(vector<vector<int>>& g, vector<int>& gr, int n) {\n      gr[n-1] = 0;\n      for(int i=n-2; i>=0; i--) {\n        vector<int> v;\n        for(auto e : g[i]) {\n          if (e > i) {\n            tmp[gr[e]]++;\n            v.push_back(gr[e]);\n          }\n        }\n        rep(j, 1000) {\n          if (tmp[j] == 0) {\n            gr[i] = j;\n            break;\n          }\n        }\n        for(auto e: v) {\n          tmp[e]--;\n        }\n      }\n    }\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      mod = mod9;\n      int n; cin >> n;\n      tmp.resize(1000);\n      ga.resize(n, vector<int>());\n      gb.resize(n, vector<int>());\n      gc.resize(n, vector<int>());\n      gra.resize(n);\n      grb.resize(n);\n      grc.resize(n);\n      vector<mint> suma(1000), sumb(1000), sumc(1000);\n      int m; cin >> m;\n      rep(i, m) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        ga[a].push_back(b);\n        ga[b].push_back(a);\n      }\n      cin >> m;\n      rep(i, m) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        gb[a].push_back(b);\n        gb[b].push_back(a);\n      }\n      cin >> m;\n      rep(i, m) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        gc[a].push_back(b);\n        gc[b].push_back(a);\n      }\n      func(ga, gra, n);\n      func(gb, grb, n);\n      func(gc, grc, n);\n\n\n      mint base = mod_pow(mint(10), 18);\n      rep(i, n) {\n        suma[gra[i]] += mod_pow(base, i+1);\n        sumb[grb[i]] += mod_pow(base, i+1);\n        sumc[grc[i]] += mod_pow(base, i+1);\n      }\n\n      mint ans = 0;\n      rep(i, 1000) {\n        rep(j, 1000) {\n          int k = i^j;\n          if (k >= 1000) continue;\n          ans += suma[i]*sumb[j]*sumc[k];\n        }\n      }\n      cout << ans.x << endl;\n    }\n};\n\nsigned main() {\n  CGiantGraph solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\nnamespace IO{\n\tcs int Rlen=1<<22|1;\n\tinline char gc(){\n\t\tstatic char buf[Rlen],*p1,*p2;\n\t\t(p1==p2)&&(p2=(p1=buf)+fread(buf,1,Rlen,stdin));\n\t\treturn (p1==p2)?EOF:*p1++;\n\t}\n\tint read(){\n\t\tint x=0; bool f=false; char c=gc();\n\t\twhile(!isdigit(c)) f=(c=='-'), c=gc();\n\t\twhile(isdigit(c)) x=(((x<<2)+x)<<1)+(c^48), c=gc(); \n\t\treturn f?-x:x;\n\t}\n} using namespace IO;\ntypedef long long ll;\ncs int Mod = 998244353;\nint add(int a, int b){ return a + b >= Mod ? a + b - Mod : a + b; }\nint dec(int a, int b){ return a - b < 0 ? a - b + Mod : a - b; }\nint mul(int a, int b){ return 1ll * a * b % Mod; }\nvoid Add(int &a, int b){ a = add(a,b); }\nvoid Mul(int &a, int b){ a = mul(a,b); }\nvoid Dec(int &a, int b){ a = dec(a,b); }\nint ksm(int a, int b){ int as=1; for(;b;b>>=1,Mul(a,a)) if(b&1) Mul(as,a); return as; }\nint fx(ll a){ return a % Mod; }\ncs int N = 1e5 + 50;\nint n, a, b, c, up;\nvector<int> A[N], B[N], C[N];\nint af[N], bf[N], cf[N], SG[3][N];\nint clc(int t, cs vector<int> &S){\n\tvector<int> T;\n\tfor(int c : S) T.pb(SG[t][c]); \n\tsort(T.begin(),T.end()); int as=0;\n\tfor(int i=0; i<(int)T.size(); i++)\n\tif(T[i]==as) ++as; else if(T[i]>as) break;\n\treturn as;\n}\nvoid FWT(int *a){\n\tfor(int i=1; i<up; i<<=1)\n\tfor(int j=0; j<up; j+=(i<<1))\n\tfor(int k=0; k<i; k++){\n\t\tint x=a[k+j], y=a[k+j+i];\n\t\ta[k+j]=add(x,y); a[k+j+i]=dec(x,y);\n\t}\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tn=read(), a=read();\n\tfor(int i=1,x,y; i<=a; i++){\n\t\tx=read(), y=read();\n\t\tif(x>y) swap(x,y); A[x].pb(y);\n\t} b=read();\n\tfor(int i=1,x,y; i<=b; i++){\n\t\tx=read(), y=read();\n\t\tif(x>y) swap(x,y); B[x].pb(y);\n\t} c=read();\n\tfor(int i=1,x,y; i<=c; i++){\n\t\tx=read(), y=read();\n\t\tif(x>y) swap(x,y); C[x].pb(y);\n\t}\n\tstatic int pw[N]; pw[0]=1; pw[1]=fx(1e18);\n\tfor(int i=2; i<=n; i++) pw[i]=mul(pw[i-1],pw[1]);\n\tint mx=0;\n\tfor(int i=n,x; i>=1; i--){\n\t\tSG[0][i]=x=clc(0,A[i]); Add(af[x],pw[i]); mx=max(mx,x);\n\t\tSG[1][i]=x=clc(1,B[i]); Add(bf[x],pw[i]); mx=max(mx,x);\n\t\tSG[2][i]=x=clc(2,C[i]); Add(cf[x],pw[i]); mx=max(mx,x);\n\t} up=1; while(up<mx+1) up<<=1;\n\tFWT(af); FWT(bf); FWT(cf);\n\tfor(int i=0; i<up; i++) Mul(af[i],mul(bf[i],cf[i]));\n\tFWT(af); cout<<mul(ksm(up,Mod-2),af[0]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int P = 998244353;\nint base = 1e9;\nint mul(int a,int b){\n  return a * b % P;\n}\nint mul(int a,int b,int c){\n  return a * b % P * c % P;\n}\nvoid add(int &a,int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\n\nint n,m;\nvector<int> licz(){\n  cin >> m;\n  vector<vector<int>> d;\n  d.resize(n);\n  R(i,m){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    if(a > b)swap(a,b);\n    d[a].PB(b);\n  }\n  vector<int> val(n);\n  for(int i = n-1; i>=0;i--){\n    vector<int> pom;\n    for(int el:d[i]){\n      pom.PB(val[el]);\n    }\n    sort(ALL(pom));\n    val[i] = 0;\n    R(j,SZ(pom)){\n      if(pom[j] == val[i])val[i]++;\n    }\n  }\n  int mn = base;\n  vector<int> res(n);\n  R(i,n){\n    add(res[val[i]],mn);\n    mn = mul(mn, base);\n  }\n  return res;\n}\n\nint32_t main() {\n  base = mul(base,base);\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  vector<int> a = licz();\n  vector<int> b = licz();\n  vector<int> c = licz();\n  int res = mul(a[0], b[0], c[0]);\n  for(int i = 1; i < n; i++){\n    add(res, mul(a[0], b[i], c[i]));\n    add(res, mul(a[i], b[0], c[i]));\n    add(res, mul(a[i], b[i], c[0]));\n  }\n  cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    const auto& modpow = [](unsigned long n, unsigned long b = 1, unsigned long a = 716070898) -> unsigned long {\n        unsigned long r{b % MOD};\n        while(n){\n            if(n & 1)(r *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return r;\n    };\n    string al{string(500, '1')};\n    unsigned long N;\n    cin >> N;\n    vector<unsigned long> indpX, indpY, indpZ;\n    for(unsigned long _{0}; _ < 3; ++_){\n        swap(indpX, indpY);\n        swap(indpZ, indpY);\n        unsigned long M;\n        cin >> M;\n        vector<vector<unsigned long>> edge(N);\n        for(unsigned long i{0}, a, b; i < M; ++i){\n            cin >> a >> b;\n            if(a < b)swap(a, b);\n            edge[--a].push_back(--b);\n        }\n        vector<unsigned long> id(N, N - 1);\n        vector<bitset<500>> c(N, bitset<500>{al});\n        map<unsigned long, unsigned long> m;\n        for(unsigned long i{N}; i--; ){\n            id[i] = c[i]._Find_first();\n            m[id[i]] += modpow(i + 1);\n            for(const auto& j : edge[i])c[j][id[i]] = false;\n        }\n        for(const auto& i : m)indpZ.emplace_back(i.second % MOD);\n    }\n    if(indpX.size() > indpZ.size())swap(indpX, indpZ);\n    if(indpY.size() > indpZ.size())swap(indpY, indpZ);\n    if(indpX.size() > indpY.size())swap(indpX, indpY);\n    unsigned long MX{indpX.size()}, MY{indpY.size()};\n    vector<bitset<500>> usedY(MY, bitset<500>(al));\n    unsigned long ans{0};\n    for(const auto& i : indpZ){\n        bitset<500> used{al};\n        unsigned long tmp{0};\n        for(unsigned long j{0}; j < MY; ++j){\n            unsigned long k{(usedY[j] & used)._Find_first()};\n            if(k < MX){\n                used[k] = false;\n                usedY[j][k] = false;\n                tmp += indpY[j] * indpX[k] % MOD;\n            }\n        }\n        tmp %= MOD;\n        ans += i * tmp % MOD;\n    }\n    cout << ans % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nll mod = 998244353;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> M(3);\n    vector<vector<vector<int>>> edge(3, vector<vector<int>>(N+1));\n    for (int i = 0; i < 3; i++) {\n        cin >> M[i];\n        for (int j = 0; j < M[i]; j++) {\n            int a, b;\n            cin >> a >> b;\n            edge[i][b].push_back(a);\n            edge[i][a].push_back(b);\n        }\n    }\n    \n    ll q = 1e18;\n    q %= mod;\n    vector<ll> pow10(N+1, 1);\n    for (int i = 1; i <= N; i++) {\n        pow10[i] = pow10[i-1] * q % mod;\n    }\n    \n    vector<vector<int>> grundy(3, vector<int>(N+1, 0));\n    vector<vector<ll>> gsum(3, vector<ll>(512, 0));\n    for (int i = 0; i < 3; i++) {\n        for (int j = N; j >= 1; j--) {\n            vector<bool> check(N, false);\n            for (int nxt : edge[i][j]) {\n                if (nxt < j) continue;\n                check[grundy[i][nxt]] = true;\n            }\n            int pos = 0;\n            while (check[pos]) pos++;\n            grundy[i][j] = pos;\n            gsum[i][pos] = (gsum[i][pos] + pow10[j])%mod;\n        }\n    }\n    \n    ll ans = 0;\n    for (int i = 0; i < 512; i++) {\n        for (int j = 0; j < 512; j++) {\n            ans += gsum[0][i]*gsum[1][j]%mod*gsum[2][i^j]%mod;\n            ans %= mod;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T, class Op = multiplies<T>>\nconstexpr T power(T a, long long n, Op op = Op(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  static constexpr unsigned mod = M;\n  unsigned v;\n  modular(long long x = 0) : v((x %= mod) < 0 ? x + mod : x) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m b) { if ((int)(v += b.v - mod) < 0) v += mod; return *this; }\n  m& operator-=(m b) { if ((int)(v -= b.v) < 0) v += mod; return *this; }\n  m& operator*=(m b) { v = (uint64_t)v * b.v % mod; return *this; }\n  m& operator/=(m b) { return *this *= power(b, mod - 2); }\n  friend m operator+(m a, m b) { return a += b; }\n  friend m operator-(m a, m b) { return a -= b; }\n  friend m operator*(m a, m b) { return a *= b; }\n  friend m operator/(m a, m b) { return a /= b; }\n  friend bool operator==(m a, m b) { return a.v == b.v; }\n};\n\nusing mint = modular<998244353>;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector a(3, vector<mint>(512));\n  for (int t = 0; t < 3; ++t) {\n    int m;\n    cin >> m;\n    vector<vector<int>> g(n);\n    while (m--) {\n      int u, v;\n      cin >> u >> v;\n      --u, --v;\n      tie(u, v) = minmax({u, v});\n      g[u].push_back(v);\n    }\n    vector<int> gr(n);\n    for (int v = n; v--; ) {\n      set<int> se;\n      for (int to : g[v]) {\n        se.insert(gr[to]);\n      }\n      for (int x = 0; ; ++x) {\n        if (not se.count(x)) {\n          gr[v] = x;\n          break;\n        }\n      }\n      a[t][gr[v]] += power<mint>(10, 18 * (v + 1));\n    }\n  }\n  mint res;\n  for (int i = 0; i < 512; ++i) {\n    for (int j = 0; j < 512; ++j) {\n      int k = i ^ j;\n      res += a[0][i] * a[1][j] * a[2][k];\n    }\n  }\n  cout << res.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile (ch<'0'||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst ll mod=998244353;\nconst int maxn=(1e5)+10;\nint n,mi[maxn],ans;\nvoid update(int &x,int y) {\n\tx+=y; if (x>=mod) x-=mod;\n}\nstruct Graph {\n\tint tot,m,head[maxn],nxt[maxn*2],to[maxn*2];\n\tint sg[maxn],vis[maxn],cnt[maxn];\n\tvoid add(int x,int y) {\n\t\ttot++; nxt[tot]=head[x];\n\t\thead[x]=tot; to[tot]=y;\n\t}\n\tvoid init() {\n\t\tread(m);\n\t\tint x,y;\n\t\twhile (m--) {\n\t\t\tread(x); read(y);\n\t\t\tif (x>y) swap(x,y);\n\t\t\tadd(x,y);\n\t\t}\n\t\ttot=0;\n\t\tfor (int i=n;i>=1;i--) {\n\t\t\ttot++;\n\t\t\tfor (int j=head[i];j;j=nxt[j]) vis[sg[to[j]]]=tot;\n\t\t\tfor (;vis[sg[i]]==tot;sg[i]++);\n\t\t\tupdate(cnt[sg[i]],mi[i]);\n\t\t}\n\t}\n} T[3];\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tmi[0]=1; mi[1]=(ll)(1e18)%mod;\n\tread(n);\n\tfor (int i=2;i<=n;i++) mi[i]=(ll)mi[i-1]*mi[1]%mod;\n\tfor (int i=0;i<3;i++) T[i].init();\n\tfor (int i=0;i<=1000;i++)\n\tfor (int j=0;j<=1000;j++)\n\t\tupdate(ans,(ll)T[0].cnt[i]*T[1].cnt[j]%mod*T[2].cnt[i^j]%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n/*\n  0. Enough array size? Enough array size? Enough array size? Interger overflow?\n  \n  1. Think TWICE, Code ONCE!\n  Are there any counterexamples to your algo?\n    \n  2. Be careful about the BOUNDARIES!\n  N=1? P=1? Something about 0?\n    \n  3. Do not make STUPID MISTAKES!\n  Time complexity? Memory usage? Precision error?\n*/"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: C.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nvector<int> to[100005];\nint sg[100005];\nint pw[100005],cnt[100005];\nconst int p=998244353;\nint s[3][1<<18|5],mx[3];\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"C.in\",\"r\",stdin);\n\tfreopen(\"C.out\",\"w\",stdout);\n#endif\n\tint n,u,v,m;\n\tread(n);\n\tpw[1]=(ll)(1e18+0.5)%p;\n\tfor(int i=2;i<=n;++i)pw[i]=pw[i-1]*pw[1]%p;\n\tfor(int id=0;id<3;++id){\n\t\tread(m);\n\t\tfor(int i=1;i<=n;++i)to[i].clear();\n\t\tfor(int i=1;i<=m;++i){\n\t\t\tread(u,v);\n\t\t\tif(u>v)swap(u,v);\n\t\t\tto[u].push_back(v);\n\t\t}\n\t\tfor(int i=n;i;--i){\n\t\t\tsg[i]=0;\n\t\t\tfor(auto j:to[i])++cnt[sg[j]];\n\t\t\twhile(cnt[sg[i]])++sg[i];\n\t\t\tfor(auto j:to[i])--cnt[sg[j]];\n\t\t\tchkmax(mx[id],sg[i]);\n\t\t\t(s[id][sg[i]]+=pw[i])%=p;\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=mx[0];++i)for(int j=0;j<=mx[1];++j)ans=(ans+s[0][i]*s[1][j]%p*s[2][i^j])%p;\n//\tfor(int i=0;i<8;++i)if(!__builtin_parity(i))ans=(ans+s[0][i&1]*s[1][i&2]%p*s[2][i&4])%p;\n\twrite(ans,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <set>\n#define MOD 998244353\n\nint a;\nlong long int power(long long int a, long long int b)\n{\n\tlong long int s = 1;\n\tlong long int t = a;\n\twhile(b)\n\t{\n\t\tif(b%2==1) s *= t, s%=MOD;\n\t\tt*=t, t%=MOD;\n\t\tb/=2;\n\t}\n\treturn s;\n}\n\nstd::vector<int> ans[5];\nstd::set<int> V[5][100010];\nint check[100010];\nstd::pair<int,int> edge[5][100010];\nvoid func(int C)\n{\n\tstd::vector<int> V2,V3,V4;\n\tfor(int i=a;i>=1;i--) V2.push_back(i);\n\twhile(V2.size()>0)\n\t{\n\t\tV4.clear();\n\t\tV3.clear();\n\t\tfor(int i=0;i<V2.size();i++) check[V2[i]] = 0;\n\t\tfor(int i=0;i<V2.size();i++)\n\t\t{\n\t\t\tif(check[V2[i]]==0)\n\t\t\t{\n\t\t\t\tcheck[V2[i]] = 1;\n\t\t\t\tV4.push_back(V2[i]);\n\t\t\t\tstd::set<int> ::iterator it;\n\t\t\t\tfor(it=V[C][V2[i]].begin();it!=V[C][V2[i]].end();it++)\n\t\t\t\t{\n\t\t\t\t\tint v;\n\t\t\t\t\tif(edge[C][*it].first!=V2[i]) v = edge[C][*it].first;\n\t\t\t\t\telse v = edge[C][*it].second;\n\t\t\t\t\tcheck[v] = 1;\n\t\t\t\t\tV[C][v].erase(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse V3.push_back(V2[i]);\n\t\t}\n\t\t\n\t\tlong long int sum = 0;\n\t\tfor(int i=0;i<V4.size();i++)\n\t\t{\n\t\t\tsum += power(10,18*V4[i]);\n\t\t\tsum %= MOD;\n\t\t}\n\t\tans[C].push_back(sum);\n\t\t\n\t\tV2.clear();\n\t\tV2 = V3;\n\t}\n}\n\nint main()\n{\n\tint b,c,d;\n\tscanf(\"%d\",&a);\n\tscanf(\"%d\",&b);\n\tfor(int i=1;i<=b;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tedge[1][i] = std::make_pair(s,t);\n\t\tV[1][s].insert(i);\n\t\tV[1][t].insert(i);\n\t}\n\tscanf(\"%d\",&c);\n\tfor(int i=1;i<=c;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tedge[2][i] = std::make_pair(s,t);\n\t\tV[2][s].insert(i);\n\t\tV[2][t].insert(i);\n\t}\n\tscanf(\"%d\",&d);\n\tfor(int i=1;i<=d;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tedge[3][i] = std::make_pair(s,t);\n\t\tV[3][s].insert(i);\n\t\tV[3][t].insert(i);\n\t}\n\tfunc(1);\n\tfunc(2);\n\tfunc(3);\n\t\n\tlong long int sum = 0;\n\tfor(int i=0;i<ans[2].size() && i<ans[3].size();i++)\n\t{\n\t\tlong long int s = ans[1][0];\n\t\ts *= ans[2][i], s%=MOD;\n\t\ts *= ans[3][i], s%=MOD;\n\t\tsum += s, sum %= MOD;\n\t}\n\tfor(int i=1;i<ans[1].size() && i<ans[3].size();i++)\n\t{\n\t\tlong long int s = ans[2][0];\n\t\ts *= ans[1][i], s%=MOD;\n\t\ts *= ans[3][i], s%=MOD;\n\t\tsum += s, sum %= MOD;\n\t}\n\tfor(int i=1;i<ans[1].size() && i<ans[2].size();i++)\n\t{\n\t\tlong long int s = ans[3][0];\n\t\ts *= ans[1][i], s%=MOD;\n\t\ts *= ans[2][i], s%=MOD;\n\t\tsum += s, sum %= MOD;\n\t}\n\tprintf(\"%lld\",sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;    \n    vector<vector<int>> E[3];\n    for (int i=0; i<3; i++)\n    {\n        int M;\n        cin>>M;\n        E[i].resize(N);\n        for (int j=0; j<M; j++)\n        {\n            int a, b;\n            cin>>a>>b;\n            E[i][a-1].push_back(b-1);\n            E[i][b-1].push_back(a-1);\n        }\n    }\n\n    vector<int> G[3];\n    set<int> S;\n    for (int i=0; i<3; i++)\n    {\n        G[i] = vector<int>(N);\n        for (int j=N-1; j>=0; j--)\n        {\n            S.clear();\n            for (int e: E[i][j])\n                if (e>j)\n                    S.insert(G[i][e]);\n            for (int k=0; ; k++)\n                if (S.count(k)==0)\n                {\n                    G[i][j] = k;\n                    break;\n                }\n        }\n    }\n\n    long long M = 998244353LL;\n    vector<long long> P10(N+1);\n    P10[0] = 1;\n    for (int i=1; i<=N; i++)\n        P10[i] = P10[i-1]*(1000000000000000000%M)%M;\n\n    vector<long long> GS[3];\n    int MG[3] = {};\n    for (int i=0; i<3; i++)\n    {\n        GS[i] = vector<long long>(N);\n        for (int j=0; j<N; j++)\n        {\n            GS[i][G[i][j]] += P10[j+1];\n            GS[i][G[i][j]] %= M;\n            MG[i] = max(MG[i], G[i][j]);\n        }\n    }\n\n    long long ans = 0;\n    for (int i=0; i<=MG[0]; i++)\n        for (int j=0; j<=MG[1]; j++)\n        {\n            int k = i^j;\n            if (k<=MG[2])\n            {\n                ans += GS[0][i]*GS[1][j]%M*GS[2][k]%M;\n                ans %= M;\n            }\n        }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 3;\nconst int mod = 998244353;\n\nint n, m[4];\nvector <int> adj[4][maxn];\nvoid read()\n{\n    cin >> n;\n    for (int i = 1; i <= 3; i++)\n    {\n        cin >> m[i];\n        for (int j = 1; j <= m[i]; j++)\n        {\n            int a, b;\n            cin >> a >> b;\n\n            adj[i][a].push_back(b);\n            adj[i][b].push_back(a);\n        }\n    }\n}\n\nlong long add(long long a, long long b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n\n    return a;\n}\n\nlong long st[maxn*2];\nint gr[4][maxn];\nmap <int, long long> mp[4];\nvoid solve()\n{\n    st[0] = 1;\n    for (int i = 1; i <= 2 * n; i++)\n        st[i] = st[i-1] * 1000000000 % mod;\n\n    for (int i = 1; i <= 3; i++)\n    {\n        mp[i][0] = add(mp[i][0], st[n*2]);\n        for (int j = n-1; j >= 1; j--)\n        {\n            set <int> s;\n            for (auto k: adj[i][j])\n                if (k > j)\n                s.insert(gr[i][k]);\n\n            while (s.find(gr[i][j]) != s.end())\n                gr[i][j]++;\n\n            mp[i][gr[i][j]] = add(mp[i][gr[i][j]], st[j*2]);\n        }\n    }\n\n    int p = sqrt(max({m[1], m[2], m[3]})) + 10;\n    long long ans = 0;\n    for (int i = 0; i <= p; i++)\n        if (mp[1].count(i))\n        for (int j = 0; j <= p; j++)\n        if (mp[2].count(j))\n            ans = add(ans, mp[1][i] * mp[2][j] % mod * mp[3][i^j] % mod);\n\n    cout << ans << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    read();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define y1 Lorem_ipsum_dolor\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 1<<17;\nconst int P = 998244353;\nconst llong Inv2 = 499122177ll;\nconst llong W = 716070898ll;\nint sg[mxN+3];\nllong pwW[mxN+3];\nllong f[3][mxN+3],g[mxN+3];\nvector<int> adj[mxN+3]; vector<int> vec;\nint n,m,dgr;\n\nint get_mex()\n{\n\tint ret = 0; sort(vec.begin(),vec.end());\n\tfor(int i=0; i<vec.size(); i++)\n\t{\n\t\tif(vec[i]==ret) {ret++;}\n\t\telse if(vec[i]>ret) {break;}\n\t}\n\tvec.clear(); return ret;\n}\n\nvoid fwt(int dgr,int coe,llong poly[],llong ret[])\n{\n\tfor(int i=0; i<(1<<dgr); i++) ret[i] = poly[i];\n\tfor(int i=1; i<(1<<dgr); i<<=1)\n\t{\n\t\tfor(int j=0; j<(1<<dgr); j+=(i<<1))\n\t\t{\n\t\t\tfor(int k=0; k<i; k++)\n\t\t\t{\n\t\t\t\tllong x = ret[j+k],y = ret[j+i+k];\n\t\t\t\tret[j+k] = (x+y)%P,ret[j+i+k] = (x-y+P)%P;\n\t\t\t\tif(coe==-1) {ret[j+k] = ret[j+k]*Inv2%P,ret[j+i+k] = ret[j+i+k]*Inv2%P;}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n); while((1<<dgr)<=n) dgr++;\n\tpwW[0] = 1ll; for(int i=1; i<=n; i++) pwW[i] = pwW[i-1]*W%P;\n\tfor(int T=0; T<3; T++)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=1; i<=m; i++)\n\t\t{\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v);\n\t\t\tif(u>v) {swap(u,v);} adj[u].push_back(v);\n\t\t}\n\t\tfor(int i=n; i>=1; i--)\n\t\t{\n\t\t\tfor(int o=0; o<adj[i].size(); o++)\n\t\t\t{\n\t\t\t\tvec.push_back(sg[adj[i][o]]);\n\t\t\t}\n\t\t\tsg[i] = get_mex();\n//\t\t\tprintf(\"sg[%d]=%d\\n\",i,sg[i]);\n\t\t\tf[T][sg[i]] = (f[T][sg[i]]+pwW[i])%P;\n\t\t}\n\t\tfor(int i=1; i<=n; i++) adj[i].clear(),sg[i] = 0;\n\t\tfwt(dgr,1,f[T],f[T]);\n\t}\n\tfor(int i=0; i<(1<<dgr); i++) {g[i] = f[0][i]*f[1][i]%P*f[2][i]%P;}\n\tfwt(dgr,-1,g,g);\n\tprintf(\"%lld\\n\",g[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  vector< int > rev, rts;\n  int base, max_base, root;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n};\n\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vec d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,3100000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        D1[d1[i]] += P[i];\n        for(auto e:g1[i]){\n            if(d1[e]==d1[i])d1[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D2[d2[i]]+=P[i];\n        for(auto e:g2[i]){\n            if(d2[e]==d2[i])d2[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D3[d3[i]]+=P[i];\n        for(auto e:g3[i]){\n            if(d3[e]==d3[i])d3[e]++;\n        }\n    }\n    vec a,b;\n    mint ans;\n    ans+=D1[0]*D2[0]*D3[0];\n    rep(i,n){\n        ans+=D1[i]*D2[i+1]*D3[i+1];\n        ans+=D1[i+1]*D2[i]*D3[i+1];\n        ans+=D1[i+1]*D2[i+1]*D3[i];\n        if(i%3==0 and i){\n            ans+=D1[i]*D2[i-1]*D3[i-2];\n            ans+=D1[i]*D2[i-2]*D3[i-1];\n            ans+=D1[i-1]*D2[i-2]*D3[i];\n            ans+=D1[i-1]*D2[i]*D3[i-2];\n            ans+=D1[i-2]*D2[i]*D3[i-1];\n            ans+=D1[i-2]+D2[i-1]*D3[i];\n        }\n    }\n\n\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// BEGIN CUT HERE\ntemplate <typename T>\nclass Vector : public vector<T> {\n    using parent = vector<T>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const T& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<T> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    const T& operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    T& operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<T>& operator=(Vector<T>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<T>& operator=(const Vector<T>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\ntemplate <>\nclass Vector<bool> : public vector<bool> {\n    using parent = vector<bool>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<bool> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    parent::const_reference operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    parent::reference operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<bool>& operator=(const Vector<bool>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\n#ifdef LOCAL\n#define vec Vector\n#else\n// END CUT HERE\n#define vec vector\n// BEGIN CUT HERE\n#endif\n// END CUT HERE\n\nusing vi = vec<int>;\n\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) {\n        allocate(n);\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i = 0; i < n; ++i) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr3d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int shift;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    const T& operator()(int i1, int i2, int i3) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    arr2d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr2d<T>(b + at * shift, d2, d3);\n    }\n\n    vector<vector<vector<T>>> view() {\n        vector<vector<vector<T>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr4d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int d4;\n    int shift1;\n    int shift2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n    }\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    int dim4() const {\n        return d4;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3, int i4) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    const T& operator()(int i1, int i2, int i3, int i4) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    arr3d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr3d<T>(b + at * shift1, d2, d3, d4);\n    }\n\n    vector<vector<vector<vector<T>>>> view() {\n        vector<vector<vector<vector<T>>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n);\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vec<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vec<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        if (c == EOF) {\n            exhausted = true;\n        }\n        return c;\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    ll readLong() {\n        return readInteger<ll>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return string(all(res));\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i = 0; i < n; i++) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return string(all(res));\n    }\n\n    double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    bool isExhausted() { return exhausted; }\n\n    void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ndouble Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\nint Input::readType() {\n    return readInt();\n}\n\ntemplate <>\nll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\nchar Input::readType() {\n    return readChar();\n}\n\ntemplate <>\nstring Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream& out = cout;\n\n    template <typename T>\n    void printSingle(const T& value) {\n        out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vec<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                out << array(i, j);\n                if (j + 1 != m) {\n                    out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    void printSingle(const pair<T, U>& value) {\n        out << value.first << ' ' << value.second;\n    }\n\npublic:\n    Output() {//ostream& out) : out(out) {\n        out << fixed << setprecision(20);\n    }\n\n    void print() {}\n\n    template <typename T, typename...Targs>\n    void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            out << ' ';\n            print(args...);\n        }\n    }\n\n    template <typename...Targs>\n    void printLine(const Targs... args) {\n        print(args...);\n        out << '\\n';\n    }\n\n    void flush() {\n        out.flush();\n    }\n};\n\nOutput out;\n\n\ntemplate <typename W, typename C>\nclass WeightedFlowEdge {\nprivate:\n    WeightedFlowEdge<W, C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    C capacity;\n    int id;\n\n    WeightedFlowEdge(int from, int to, W weight, C capacity) : from(from), to(to), weight(weight), capacity(capacity) {\n        reverseEdge = new WeightedFlowEdge(this);\n    }\n\n    WeightedFlowEdge<W, C>* transposed() { return nullptr; }\n\n    WeightedFlowEdge<W, C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    WeightedFlowEdge(WeightedFlowEdge<W, C>* reverse) : from(reverse->to), to(reverse->from), weight(-reverse->weight),\n                                                        capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename C>\nclass FlowEdge {\nprivate:\n    FlowEdge<C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    C capacity;\n    int id;\n\n    FlowEdge(int from, int to, C capacity) : from(from), to(to), capacity(capacity) {\n        reverseEdge = new FlowEdge(this);\n    }\n\n    FlowEdge<C>* transposed() { return nullptr; }\n\n    FlowEdge<C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    FlowEdge(FlowEdge<C>* reverse) : from(reverse->to), to(reverse->from), capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename W>\nclass WeightedEdge {\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    WeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n    }\n\n    WeightedEdge<W>* transposed() { return nullptr; }\n\n    WeightedEdge<W>* reverse() { return nullptr; }\n};\n\ntemplate <typename W>\nclass BiWeightedEdge {\nprivate:\n    BiWeightedEdge<W>* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    BiWeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n        transposedEdge = new BiWeightedEdge(this);\n    }\n\n    BiWeightedEdge<W>* transposed() { return transposedEdge; }\n\n    BiWeightedEdge<W>* reverse() { return nullptr; }\n\nprivate:\n    BiWeightedEdge(BiWeightedEdge<W>* transposed) : from(transposed->to), to(transposed->from),\n                                                    weight(transposed->weight) {\n        transposedEdge = transposed;\n    }\n};\n\nclass BaseEdge {\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BaseEdge(int from, int to) : from(from), to(to) {\n    }\n\n    BaseEdge* transposed() { return nullptr; }\n\n    BaseEdge* reverse() { return nullptr; }\n};\n\nclass BiEdge {\nprivate:\n    BiEdge* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BiEdge(int from, int to) : from(from), to(to) {\n        transposedEdge = new BiEdge(this);\n    }\n\n    BiEdge* transposed() { return transposedEdge; }\n\n    BiEdge* reverse() { return nullptr; }\n\nprivate:\n    BiEdge(BiEdge* transposed) : from(transposed->to), to(transposed->from) {\n        transposedEdge = transposed;\n    }\n};\n\ntemplate <class Edge>\nclass Graph {\npublic:\n    int vertexCount;\n    int edgeCount = 0;\nprivate:\n    vec<vec<Edge*>> edges;\n\npublic:\n    Graph(int vertexCount) : vertexCount(vertexCount), edges(vertexCount, vec<Edge*>()) {}\n\n    void addEdge(Edge* edge) {\n#ifdef LOCAL\n        if (edge->from < 0 || edge->to < 0 || edge->from >= vertexCount || edge->to >= vertexCount) {\n            throw \"Out of bounds\";\n        }\n#endif\n        edge->id = edgeCount;\n        edges[edge->from].push_back(edge);\n        Edge* reverse = edge->reverse();\n        if (reverse != nullptr) {\n            reverse->id = edgeCount;\n            edges[reverse->from].push_back(reverse);\n        }\n        Edge* transposed = edge->transposed();\n        if (transposed != nullptr) {\n            edges[transposed->from].push_back(transposed);\n            transposed->id = edgeCount;\n            Edge* transRev = transposed->reverse();\n            if (transRev != nullptr) {\n                edges[transRev->from].push_back(transRev);\n                transRev->id = edgeCount;\n            }\n        }\n        edgeCount++;\n    }\n\n    template <typename...Ts>\n    void addEdge(Ts...args) {\n        addEdge(new Edge(args...));\n    }\n\n    vec<Edge*>& operator[](int at) {\n        return edges[at];\n    }\n\n    void addVertices(int count) {\n        vertexCount += count;\n        edges.resize(vertexCount);\n    }\n};\n\n\nconst int MOD7 = 1000000007;\nconst int MOD9 = 1000000009;\nconst int MODF = 998244353;\n\nint mod = MOD7;\n\ntemplate <typename T>\nT gcd(T a, T b, T& x, T& y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int d = gcd(b % a, a, y, x);\n    x -= (b / a) * y;\n    return d;\n}\n\nclass modint {\npublic:\n    int n;\n\n    modint() : n(0) {}\n\n    modint(ll n) {\n        if (n >= 0 && n < mod) {\n            this->n = n;\n            return;\n        }\n        n %= mod;\n        if (n < 0) {\n            n += mod;\n        }\n        this->n = n;\n    }\n\n    modint& operator+=(const modint& other) {\n        n += other.n;\n        if (n >= mod) {\n            n -= mod;\n        }\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        n -= other.n;\n        if (n < 0) {\n            n += mod;\n        }\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        n = ll(n) * other.n % mod;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n#ifdef LOCAL\n        if (other.n == 0) {\n            throw \"Division by zero\";\n        }\n#endif\n        return *this *= other.inverse();\n    }\n\n    modint operator-() {\n        if (n == 0) {\n            return 0;\n        }\n        return modint(mod - n);\n    }\n\n    modint inverse() const {\n        ll x, y;\n        ll g = gcd(ll(n), ll(mod), x, y);\n#ifdef LOCAL\n        if (g != 1) {\n            throw \"not inversable\";\n        }\n#endif\n        return x;\n    }\n\n    int log(modint alpha);\n};\n\nmodint operator+(const modint& a, const modint& b) {\n    return modint(a) += b;\n}\n\nmodint operator-(const modint& a, const modint& b) {\n    return modint(a) -= b;\n}\n\nmodint operator*(const modint& a, const modint& b) {\n    return modint(a) *= b;\n}\n\nmodint operator/(const modint& a, const modint& b) {\n    return modint(a) /= b;\n}\n\nostream& operator<<(ostream& out, const modint& val) {\n    return out << val.n;\n}\n\nbool operator==(const modint& a, const modint& b) {\n    return a.n == b.n;\n}\n\nbool operator!=(const modint& a, const modint& b) {\n    return a.n != b.n;\n}\n\nnamespace std {\n    template <>\n    struct hash<modint> {\n        size_t operator()(const modint& n) const {\n            return n.n;\n        }\n    };\n}\n\nint modint::log(modint alpha) {\n    unordered_map<modint, int> base;\n    int exp = 0;\n    modint pow = 1;\n    modint inv = *this;\n    modint alInv = alpha.inverse();\n    while (exp * exp < mod) {\n        if (inv == 1) {\n            return exp;\n        }\n        base[inv] = exp++;\n        pow *= alpha;\n        inv *= alInv;\n    }\n    modint step = pow;\n    for (int i = 1;; i++) {\n        if (base.count(pow)) {\n            return exp * i + base[pow];\n        }\n        pow *= step;\n    }\n}\n\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        a = a % b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T>\nT lcm(T a, T b) {\n    return a / gcd(a, b) * b;\n}\n\ntemplate <typename T>\nT power(const T& a, ll b) {\n    if (b == 0) {\n        return 1;\n    }\n    if ((b & 1) == 0) {\n        T res = power(a, b >> 1);\n        return res * res;\n    } else {\n        return power(a, b - 1) * a;\n    }\n}\n\ntemplate <typename T>\nT factorial(int n) {\n    T result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> factorials(int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> powers(T base, int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * base;\n    }\n    return result;\n}\n\n\nclass ReverseNumberIterator : public NumberIterator {\npublic:\n    ReverseNumberIterator(int v) : NumberIterator(v) {}\n\n    ReverseNumberIterator& operator++() {\n        --v;\n        return *this;\n    }\n};\n\nclass RevRange : pii {\npublic:\n    RevRange(int begin, int end) : pii(begin - 1, min(begin, end) - 1) {}\n\n    RevRange(int n) : pii(n - 1, min(n, 0) - 1) {}\n\n    ReverseNumberIterator begin() {\n        return first;\n    }\n\n    ReverseNumberIterator end() {\n        return second;\n    }\n};\n\n\nclass CGiantGraph {\npublic:\n    void solve() {\n        int n = in.readInt();\n        arr<Graph<BaseEdge>> graphs(3, Graph<BaseEdge>(n));\n        for (int i : range(3)) {\n            int m = in.readInt();\n            arri u, v;\n            in.readArrays(m, u, v);\n            decreaseByOne(u, v);\n            for (int j : range(m)) {\n                graphs[i].addEdge(min(u[j], v[j]), max(u[j], v[j]));\n            }\n        }\n\n        mod = MODF;\n        auto p = powers(modint(1000000000000000000ll), n + 1);\n        arr2d<modint> levels(3, n, 0);\n        arri level(n);\n        int maxLevel = 0;\n        for (int i : range(3)) {\n            for (int j : RevRange(n)) {\n                unordered_set<int> bad;\n                for (auto* e : graphs[i][j]) {\n                    bad.insert(level[e->to]);\n                }\n                for (int k : range(n)) {\n                    if (!bad.count(k)) {\n                        level[j] = k;\n                        levels(i, k) += p[j + 1];\n                        break;\n                    }\n                }\n                maxim(maxLevel, level[j]);\n            }\n        }\n        maxLevel++;\n        modint answer = levels(0, 0) * levels(1, 0) * levels(2, 0);\n        for (int i : range(3)) {\n            for (int j : range(i)) {\n                for (int k : range(1, maxLevel)) {\n                    answer += levels(i, k) * levels(j, k) * levels(3 - i - j, 0);\n                }\n            }\n        }\n        set<pii> bad;\n        for (int i : range(1, maxLevel)) {\n/*            for (int j = 2 * i; j < maxLevel; j += 2 * i) {\n                for (int k : range(i)) {\n                    if (j + i + k >= maxLevel) {\n                        break;\n                    }\n                    for (int a : range(3)) {\n                        for (int b : range(3)) {\n                            if (a == b) {\n                                continue;\n                            }\n                            answer += levels(a, i) * levels(b, j + k) * levels(3 - a - b, j + i + k);\n                        }\n                    }\n                }\n            }*/\n            for (int j : range(i + 1, maxLevel)) {\n                if (bad.count({i, j})) {\n                    continue;\n                }\n                for (int k : range(j + 1, maxLevel)) {\n                    if (bad.count({i, k}) || bad.count({j, k})) {\n                        continue;\n                    }\n                    for (int a : range(3)) {\n                        for (int b : range(3)) {\n                            if (a == b) {\n                                continue;\n                            }\n                            answer += levels(a, i) * levels(b, j) * levels(3 - a - b, k);\n                        }\n                    }\n                    bad.emplace(j, k);\n                    bad.emplace(i, k);\n                    break;\n                }\n            }\n        }\n        out.printLine(answer);\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    CGiantGraph solver;\n\n\n    solver.solve();\n    fflush(stdout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a; swap(a, m);\n        u -= t * v; swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n    using u64 = std::uint_fast64_t;\n\npublic:\n    u64 a;\n\n    constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n};\nint main() {\n    using Mint = modint<998244353>;\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n    for (int r = 0; r < 3; r++) {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            --x; --y;\n            if (x > y) {\n                swap(x, y);\n            }\n            g[r][x].push_back(y);\n        }\n    }\n    Mint p = (long long) 1e18;\n    vector<Mint> pw(n);\n    pw[0] = p;\n    for (int i = 1; i < n; i++) {\n        pw[i] = pw[i - 1] * p;\n    }\n    const int MAX = 512;\n    vector<vector<Mint>> cnt(3, vector<Mint>(MAX));\n    for (int r = 0; r < 3; r++) {\n        vector<int> gr(n);\n        for (int i = n - 1; i >= 0; i--) {\n            set<int> s;\n            for (int j : g[r][i]) {\n                s.insert(gr[j]);\n            }\n            while (s.find(gr[i]) != s.end()) {\n                ++gr[i];\n            }\n            cnt[r][gr[i]] += pw[i];\n        }\n    }\n    Mint ans = 0;\n    for (int x = 0; x < MAX; x++) {\n        for (int y = 0; y < MAX; y++) {\n            ans += cnt[0][x] * cnt[1][y] * cnt[2][x ^ y];\n        }\n    }\n    cout << ans.a << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cctype>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++)\n#define mk make_pair\n#define pi pair<int,int>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int N=1e5+10,size=1<<20,mod=998244353;\n\nchar buf[size],*p1=buf,*p2=buf;\ntemplate<class o> void qr(o &x) {\n\tchar c=gc; x=0; int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=gc;}\n\twhile(isdigit(c)) x=x*10+c-'0',c=gc;\n\tx*=f;\n}\ntemplate<class o> void qw(o x) {\n\tif(x/10) qw(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class o> void pr1(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x); putchar(' ');\n}\ntemplate<class o> void pr2(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x); puts(\"\");\n}\n\nstruct edge{int y,next;}a[N];int len,last[N];\nvoid ins(int x,int y) {a[++len]=(edge){y,last[x]};last[x]=len;}\n\nvoid upd(int &x) {x+=x>>31&mod;}\n\nll power(ll a,ll b=mod-2) {\n\tll c=1;\n\tfor(   ;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) c=c*a%mod;\n\treturn c;\n}\n\nint n,m,f[N],sum[3][N],sz[3],g[N],num,ans,fir,inv=power(fir=power(10,18));\n\nint main() {\n\tqr(n);\n\tfor(int graph=0;graph<3;graph++) {\n\t\tif(len) memset(last+1,0,n<<2),len=0;\n\t\tqr(m); for(int j=1,x,y;j<=m;j++) {\n\t\t\tqr(x),qr(y);\n\t\t\tif(x>y) swap(x,y);\n\t\t\tins(x,y);\n\t\t}\n\t\tint now=power(fir,n);\n\t\tfor(int i=n; i;i--) {\n\t\t\t//求sg函数(f)\n\t\t\t++num;\n\t\t\tfor(int k=last[i];k;k=a[k].next)\n\t\t\t\tg[f[a[k].y]]=num;\n\t\t\tf[i]=0;\n\t\t\twhile(g[f[i]]==num) f[i]++;\n\t\t\tsz[graph]=max(sz[graph],f[i]);\n\t\t\tupd(sum[graph][f[i]]+=now-mod);\n\t\t\tnow=(ll)now*inv%mod;\n\t\t}\n\t}\n\tfor(int i=0;i<=sz[0];i++)\n\t\tfor(int j=0,k;j<=sz[1];j++) {\n\t\t\tk=i^j;\n\t\t\tupd(ans+=(ll)sum[0][i]*sum[1][j]%mod*sum[2][k]%mod-mod);\n\t\t}\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 500010;\nconst int MOD = 998244353;\nconst ll INF = 1000000LL * 1000000LL * 1000000LL % MOD;\n\nvector <int> g[N];\nll pwr[N], sum[3][N];\nint n, m, grundy[N], lim;\n\nint main() {\n  pwr[0] = 1;\n  for (int i = 1; i < N; ++i) pwr[i] = INF * pwr[i - 1] % MOD;\n  cin >> n;\n  for (int it = 0; it < 3; ++it) {\n    cin >> m;\n    while (m--) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      g[u].emplace_back(v);\n      g[v].emplace_back(u);\n    }\n    for (int i = n; i >= 1; --i) {\n      set <int> nei;\n      for (int j : g[i]) if (j > i) nei.emplace(grundy[j]);\n      grundy[i] = 0;\n      for (int x : nei) {\n        if (x == grundy[i]) ++grundy[i]; \n        else break;\n      }\n      lim = max(lim, grundy[i]);\n      sum[it][grundy[i]] += pwr[i], sum[it][grundy[i]] %= MOD;\n    }\n    for (int i = 1; i <= n; ++i) g[i].clear();\n  }\n  ll ans = 0;\n  for (int i = 0; i <= lim; ++i) {\n    for (int j = 0; j <= lim; ++j) {\n      ll cur = (sum[0][i] * sum[1][j] % MOD) * sum[2][i ^ j] % MOD;\n      ans += cur, ans %= MOD;\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define re register\n#define LL long long\n#define MOD 998244353\n#define MAXN 100005\nusing namespace std;\nLL n,ans,bs[3*MAXN];\nLL rd(){\n\tLL x=0,tp=1;char c;c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')tp=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=(x*10+c-'0');c=getchar();}\n\treturn x*tp;\n}\nstruct Graph{\n\tLL m,sqr,sg[MAXN],f[MAXN];\n\tvector<int>e[MAXN];\n\tvoid work(){\n\t\tint x,y;\n\t\tm=rd();sqr=sqrt(m);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tx=rd(),y=rd();\n\t\t\tif(x>y)swap(x,y);\n\t\t\te[x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tset<int>s;\n\t\t\tint sz=e[i].size();\n\t\t\tfor(int j=0;j<sz;j++)s.insert(sg[e[i][j]]);\n\t\t\twhile(s.count(sg[i]))sg[i]++;\n\t\t\t(f[sg[i]]+=bs[i])%=MOD;\n\t\t\t// printf(\"sg[%d]=%d\\n\",i,sg[i]);\n\t\t}\n\t}\n}g[3];\nint main(){\n\t// freopen(\"testdata.in\",\"r\",stdin);\n\t// freopen(\"shit.out\",\"w\",stdout);\n\tn=rd();\n\tbs[0]=1;LL fuck=1000000000000000000ll%MOD;\n\tfor(int i=1;i<=3*n;i++)bs[i]=bs[i-1]*fuck%MOD;\n\tfor(int i=0;i<3;i++)g[i].work();\n\tfor(int i=0;i<=g[0].sqr;i++)\n\t\tfor(int j=0;j<=g[1].sqr;j++)\n\t\t\t(ans+=g[0].f[i]*g[1].f[j]%MOD*g[2].f[i^j]%MOD)%=MOD;\n\tprintf(\"%lld\\n\",ans);\n\t// printf(\"%.2lf\\n\",(double)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct Problem {\n\t/*\n\tUL F[4][4] = {\n\t\t{0, 1, 2, 3},\n\t\t{1, 0, 1, 2},\n\t\t{2, 1, 0, 1},\n\t\t{3, 2, 1, 0}\n\t};\n\n\tUL V[1000000];*/\n\n\tvoid Solve() {\n\t\t/*\n\t\tUL N; cin >> N; N--;\n\t\t{\n\t\t\tUL a; cin >> a;\n\t\t\trep(i, N) {\n\t\t\t\tUL t; cin >> t;\n\t\t\t\tV[i] = F[a][t];\n\t\t\t\ta = t;\n\t\t\t}\n\t\t}*/\n\t\tconst ULL M = 998244353;\n\t\tconst ULL Z = 1000000000000000000 % 998244353;\n\n\t\tUL N; cin >> N;\n\t\tUL S[3];\n\t\tvector<vector<UL>> E[3];\n\t\trep(i, 3) {\n\t\t\tcin >> S[i];\n\t\t\tE[i].resize(N);\n\t\t\trep(j, S[i]) {\n\t\t\t\tUL u, v; cin >> u >> v; u--; v--;\n\t\t\t\tE[i][u].push_back(v);\n\t\t\t\tE[i][v].push_back(u);\n\t\t\t}\n\t\t}\n\t\tvector<UL> POWZ(N * 3 + 1); POWZ[0] = 1;\n\t\trep(i, N * 3) POWZ[i + 1] = POWZ[i] * Z % M;\n\t\tvector<ULL> A[3] = {};\n\t\trep(t, 3) {\n\t\t\t//cout << \"t = \" << t << endl;\n\t\t\tA[t].resize(N);\n\t\t\tvector<UL> F(N);\n\t\t\tfor (UL v = N - 1; v != -1; v--) {\n\t\t\t\tA[t][F[v]] = (A[t][F[v]] + POWZ[v + 1]) % M;\n\t\t\t\tfor (UL e : E[t][v]) {\n\t\t\t\t\tif (F[e] == F[v]) F[e] = F[v] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//rep(i, N) cout << F[i] << \" \"; cout << endl;\n\t\t}\n\n\t\tULL ans = 0;\n\t\trep(i, N) {\n\t\t\tif (i == 0) {\n\t\t\t\tans += A[0][0] * A[1][0] % M * A[2][0] % M;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += A[0][0] * A[1][i] % M * A[2][i] % M;\n\t\t\t\tans += A[0][i] * A[1][0] % M * A[2][i] % M;\n\t\t\t\tans += A[0][i] * A[1][i] % M * A[2][0] % M;\n\t\t\t}\n\t\t\tans %= M;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\n\nconst int mod = 998244353;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\n\n\nvoid FWT(ll a[],int n,int coef)\n{\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<(1<<n);j++)\n\t\t{\n\t\t\tif(!((j>>i)&1))\n\t\t\t{\n\t\t\t\tll tmp=a[j+(1<<i)];\n\t\t\t\ta[j+(1<<i)]=(a[j]-a[j+(1<<i)]+mod)%mod;\n\t\t\t\ta[j]=(a[j]+tmp)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tll inv=qpow(1<<n,mod-2);\n\tif(coef==-1)for(int i=0;i<(1<<n);i++)a[i]=a[i]*inv%mod;\n}\n\nconst int maxn = 1<<17;\nconst int P = 1000000000ll*1000000000ll%mod;\nint n;\nll A[maxn], B[maxn], C[maxn];\nvoid calc(ll A[])\n{\n\tint m;\n\tgeti(m);\n\tstatic vector<int> con[maxn];\n\tfor (int i=1; i<=n; i++) con[i].clear();\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint x, y;\n\t\tgetii(x, y);\n\t\tif (x>y) swap(x, y);\n\t\tcon[x].PB(y);\n\t}\n\tstatic int dp[maxn];\n\tfor (int i=n; i>=1; i--)\n\t{\n\t\tstatic bool f[maxn];\n\t\tfor (auto u : con[i])\n\t\t{\n\t\t\tf[dp[u]] = true;\n\t\t}\n\t\tint &x = dp[i];\n\t\tx = 0;\n\t\twhile (f[x]) x++;\n\t\tfor (auto u : con[i])\n\t\t{\n\t\t\tf[dp[u]] = false;\n\t\t}\n\t\tA[dp[i]] = (A[dp[i]]+qpow(P, i))%mod;\n\t}\n}\nint main()\n{\n\tgeti(n);\n\tcalc(A);\n\tcalc(B);\n\tcalc(C);\n\tFWT(A, 17, 1);\n\tFWT(B, 17, 1);\n\tFWT(C, 17, 1);\n\tfor (int i=0; i<maxn; i++) A[i] = A[i]*B[i]%mod*C[i]%mod;\n\tFWT(A, 17, -1);\n\tcout<<A[0]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int size=1<<20,mod=998244353;\nstruct nobe\n{\n\tint to,ne;\n}e[400400];\nint len=0,hea[400400];\ninline void adde(int x,int y)\n{\n\te[++len]=(nobe){y,hea[x]};\n\thea[x]=len;\n}\ninline void upd(int &x)\n{\n\tx+=x>>31&mod;\n}\ninline long long poww(long long a,long long b=mod-2)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%mod;\n\t\tb>>=1;\n\t\ta=a*a%mod;\n\t}\n\treturn res;\n}\nint n,m,f[100100],sum[3][100100],sz[3],g[100100],num,ans,fir,inv=poww(fir=poww(10,18));\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tint graph=0,i=1,j=1,k=0;\n\twhile(graph<3)\n\t{\n\t\tif(len)\n\t\t{\n\t\t\tmemset(hea,0,sizeof(hea));\n\t\t\tlen=0;\n\t\t}\n\t\tscanf(\"%d\",&m);\n\t\tj=1;\n\t\tint x,y;\n\t\twhile(j<=m)\n\t\t{\n\t\t\tscanf(\"%lld%lld\",&x,&y);\n\t\t\tif(x>y) swap(x,y);\n\t\t\tadde(x,y);\n\t\t\t++j;\n\t\t}\n\t\tint now=poww(fir,n);\n\t\ti=n;\n\t\twhile(i)\n\t\t{\n\t\t\t++num;\n\t\t\tk=hea[i];\n\t\t\twhile(k)\n\t\t\t{\n\t\t\t\tg[f[e[k].to]]=num;\n\t\t\t\tk=e[k].ne;\n\t\t\t}\n\t\t\tf[i]=0;\n\t\t\twhile(g[f[i]]==num) ++f[i];\n\t\t\tsz[graph]=max(sz[graph],f[i]);\n\t\t\tsum[graph][f[i]]+=now-mod;\n\t\t\tsum[graph][f[i]]%=mod;\n\t\t\tnow=(long long)now*inv%mod;\n\t\t\t--i;\n\t\t}\n\t\t++graph;\n\t}\n\ti=0;\n\twhile(i<=sz[0])\n\t{\n\t\tj=0;\n\t\tk=0;\n\t\twhile(j<=sz[1])\n\t\t{\n\t\t\tk=i^j;\n\t\t\tans+=(long long)sum[0][i]*sum[1][j]%mod*sum[2][k]%mod-mod;\n\t\t\tans%=mod;\n\t\t\t++j;\n\t\t}\n\t\t++i;\n\t}\n\tans+=mod;\n\tans%=mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdio>\n#include <complex>\n#include <numeric>\n#include <string.h>\n#include <random>\n#include <cmath>\n#include <unordered_map>\n#include <unordered_set>\n#include <chrono>\n#include <cassert>\n#define rep(i,n) for (ll i = 0; i < (ll)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\ndouble PI = 3.141592653589793238462643383279;\nconst double EPS = 1e-9;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate< int mod >\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n         return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt< MOD >;\n\nint n;\nint m[3];\nvector<vector<int>> e[3];\nbool done[3][100000];\nbool done2[3][100000];\nmint val[3];\nmint val2[3];\nmint ten = 10;\nmint ans;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i,3) {\n        e[i].resize(n);\n        cin >> m[i];\n        rep(j,m[i]) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            e[i][a].push_back(b);\n            e[i][b].push_back(a);\n        }\n    }\n    rep(i,3) {\n        for (int j = n-1; j >= 0; j--) {\n            if (done[i][j]) continue;\n            val[i] += ten.pow(18*(j+1));\n            for (int to : e[i][j]) {\n                done[i][to] = true;\n            }\n        }\n    }\n    ans = val[0]*val[1]*val[2];\n    while (true) {\n        rep(i,3) val2[i] = 0;\n        memset(done2, 0, sizeof(done2));\n        bool end = true;\n        rep(i,3) {\n            for (int j = n-1; j >= 0; j--) {\n                if (!done[i][j]) continue;\n                if (done2[i][j]) continue;\n                done[i][j] = false;\n                val2[i] += ten.pow(18*(j+1));\n                end = false;\n                for (int to : e[i][j]) {\n                    if (to > j) continue;\n                    done2[i][to] = true;\n                }\n            }\n        }\n        if (end) break;\n        ans += val2[0]*val2[1]*val[2];\n        ans += val2[0]*val[1]*val2[2];\n        ans += val[0]*val2[1]*val2[2];\n        // rep(i,3) val[i] += val2[i];\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 7, mod = 998244353, base = 716070898, sz = 400;\nvector<int> g[3][N], m(3), power(N);\n\nint n, grundy[3][N], sum[4][1005]; // sum of powers of each grundy value\n\nvoid dfs(int idx, int u){\n\tif(g[idx][u].empty()) {\n\t\tgrundy[idx][u] = 0;\n\t\treturn;\n\t}\n\tset<int> num;\n\tfor(auto v : g[idx][u]){\n\t\tif(grundy[idx][v] == -1) dfs(idx, v);\n\t\tnum.insert(grundy[idx][v]);\n\t}\n\tint mex = 0;\n\twhile(num.count(mex)) ++mex;\n\tgrundy[idx][u] = mex;\n}\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tcin >> n;\n\tfor(int i = 0; i < 3; ++i){\n\t\tcin >> m[i];\n\t\tfor(int j = 0; j < m[i]; ++j){\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tif(u > v) swap(u, v);\n\t\t\tg[i][u].push_back(v);\n\t\t}\n\t}\n\tpower[0] = 1;\n\tfor(int i = 1; i < N; ++i) power[i] = (power[i - 1] * base) % mod;\n\tmemset(grundy, -1, sizeof(grundy));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\tif(grundy[i][j] == -1) dfs(i, j);\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\t(sum[i][grundy[i][j]] += power[j]) %= mod;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < sz; ++i){\n\t\tfor(int j = 0; j < sz; ++j){\n\t\t\t(sum[3][i ^ j] += sum[0][i] * sum[1][j]) %= mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < sz; ++i) (ans += sum[2][i] * sum[3][i]) %= mod;\n\tcout << ans;\n\t\n\t\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define re register\n#define LL long long\n#define MOD 998244353\n#define MAXN 100005\nusing namespace std;\nLL n,ans,bs[3*MAXN];\nLL rd(){\n\tLL x=0,tp=1;char c;c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')tp=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=(x*10+c-'0');c=getchar();}\n\treturn x*tp;\n}\nstruct Graph{\n\tLL m,sg[MAXN],f[MAXN];\n\tvector<int>e[MAXN];\n\tvoid work(){\n\t\tint x,y;\n\t\tm=rd();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tx=rd(),y=rd();\n\t\t\tif(x>y)swap(x,y);\n\t\t\te[x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tset<int>s;\n\t\t\tint sz=e[i].size();\n\t\t\tfor(int j=0;j<sz;j++)s.insert(sg[e[i][j]]);\n\t\t\twhile(s.count(sg[i]))sg[i]++;\n\t\t\t(f[sg[i]]+=bs[i])%=MOD;\n\t\t\t// printf(\"sg[%d]=%d\\n\",i,sg[i]);\n\t\t}\n\t}\n}g[3];\nint main(){\n\t// freopen(\"testdata.in\",\"r\",stdin);\n\t// freopen(\"shit.out\",\"w\",stdout);\n\tn=rd();int Sqr=sqrt(n);\n\tbs[0]=1;LL fuck=1000000000000000000ll%MOD;\n\tfor(int i=1;i<=3*n;i++)bs[i]=bs[i-1]*fuck%MOD;\n\tfor(int i=0;i<3;i++)g[i].work();\n\tfor(int i=0;i<=500;i++)\n\t\tfor(int j=0;j<=500;j++)\n\t\t\t(ans+=g[0].f[i]*g[1].f[j]%MOD*g[2].f[i^j]%MOD)%=MOD;\n\tprintf(\"%lld\\n\",ans);\n\t// printf(\"%.2lf\\n\",(double)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 100000\n#define X 998244353\n#define Inc(x,y) ((x+=(y))>=X&&(x-=X))\nusing namespace std;\nint n,pw[N+5];\nclass FastIO\n{\n\tprivate:\n\t\t#define FS 100000\n\t\t#define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)\n\t\t#define D isdigit(c=tc())\n\t\tchar c,*A,*B,FI[FS];\n\tpublic:\n\t\tI FastIO() {A=B=FI;}\n\t\tTp I void read(Ty& x) {x=0;W(!D);W(x=(x<<3)+(x<<1)+(c&15),D);}\n}F;\nclass Graph\n{\n\tprivate:\n\t\t#define add(x,y) (e[++ee].nxt=lnk[x],e[lnk[x]=ee].to=y)\n\t\tint m,ee,lnk[N+5],SG[N+5],vis[N+5];struct edge {int to,nxt;}e[2*N+5];\n\t\tI void dfs(CI x)\n\t\t{\n\t\t\tRI i;for(i=lnk[x];i;i=e[i].nxt) x<e[i].to&&!~SG[e[i].to]&&(dfs(e[i].to),0);\n\t\t\tfor(i=lnk[x];i;i=e[i].nxt) x<e[i].to&&(vis[SG[e[i].to]]=x);\n\t\t\tfor(SG[x]=0;vis[SG[x]]==x;++SG[x]);\n\t\t}\n\tpublic:\n\t\tint Mx,tot[N+5];\n\t\tI void Init()\n\t\t{\n\t\t\tRI i,x,y;for(F.read(m),i=1;i<=m;++i) F.read(x),F.read(y),add(x,y),add(y,x);\n\t\t\tfor(i=1;i<=n;++i) SG[i]=-1;for(i=1;i<=n;++i)\n\t\t\t\t!~SG[i]&&(dfs(i),0),Mx<SG[i]&&(Mx=SG[i]),Inc(tot[SG[i]],pw[i]);\n\t\t}\n}G1,G2,G3;\nint main()\n{\n\tRI i,j,ans=0;F.read(n);\n\tfor(pw[0]=1,pw[1]=(long long)1e18%X,i=2;i<=n;++i) pw[i]=1LL*pw[i-1]*pw[1]%X;\n\tfor(G1.Init(),G2.Init(),G3.Init(),i=0;i<=G1.Mx;++i)\n\t\tfor(j=0;j<=G2.Mx;++j) ans=(1LL*G1.tot[i]*G2.tot[j]%X*G3.tot[i^j]+ans)%X;\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nnamespace my_std {\nusing namespace std;\n#define reg register\n#define Rint register int\n#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i <= ed_##i; ++i)\n#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i >= ed_##i; --i)\n#define pb push_back\ntypedef long long i64;\n#define Templ(T) template <typename T>\ninline int read() {\n    reg int ans = 0, f = 1;\n    reg char c = getchar();\n    while (!isdigit(c)) f ^= (c == '-'), c = getchar();\n    for (; isdigit(c); c = getchar()) ans = (ans << 1) + (ans << 3) + (c ^ 48);\n    return f ? ans : -ans;\n}\nTempl(_Tp) inline int chkmin(_Tp &x, _Tp y) { return x > y ? x = y, 1 : 0; }\nTempl(_Tp) inline int chkmax(_Tp &x, _Tp y) { return x < y ? x = y, 1 : 0; }\n#define mod 998244353\ninline void inc(int &x, const int &y) { x += y; if (x >= mod) x -= mod; }\ninline void dec(int &x, const int &y) { x -= y; if (x < 0) x += mod; }\ninline void qmo(int &x){ x += (x >> 31) & mod; }\n} // namespace my_std\nusing namespace my_std;\n\n#define N 100010\n#define BN 610\nconst i64 V = i64(1e18) % mod;\n\nint n;\nstruct Graph{\n    vector<int> E[N];\n    int sg[N], n, m, val[BN], mxsg;\n    inline void build(){\n        n = ::n, m = read();\n        Rint u, v;\n        FOR(i, 1, m){\n            u = read(), v = read();\n            if(u > v) u ^= v ^= u ^= v;\n            E[u].pb(v);\n        }\n    }\n    inline void topo(){\n        int *c = new int[BN];\n        mxsg = 0;\n        memset(c, 0, sizeof(int) * BN);\n        ROF(u, n, 1){\n            for(Rint v: E[u]) c[sg[v]] = 1;\n            Rint t(0);\n            while(c[t]) ++t;\n            chkmax(mxsg, sg[u] = t);\n            for(Rint v: E[u]) c[sg[v]] = 0;\n        }\n        delete c;\n        Rint x(V);\n        FOR(i, 1, n){\n            qmo(val[sg[i]] += x - mod);\n            x = V * x % mod;\n        }\n    }\n}G[3];\n\nint main() {\n    n = read();\n    FOR(i, 0, 2) G[i].build(), G[i].topo();\n    Rint ans(0);\n    FOR(i, 0, G[0].mxsg) FOR(j, 0, G[1].mxsg){\n        qmo(ans += ((i64)G[0].val[i] * G[1].val[j] % mod\n            * G[2].val[i ^ j] % mod) - mod);\n    }\n    printf(\"%d\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nconst int64 MODULO = 998244353;\nconst int64 BASE = ((int64) 1e18) % MODULO;\n\nclass TaskC {\n public:\n  vector<vector<int>> readGraph(int n, istream& in) {\n    int m;\n    in >> m;\n    vector<vector<int>> res(n);\n    for (int i = 0; i < m; ++i) {\n      int a;\n      int b;\n      in >> a;\n      in >> b;\n      --a;\n      --b;\n      if (a < b) {\n        res[a].push_back(b);\n      } else {\n        res[b].push_back(a);\n      }\n    }\n    return res;\n  }\n\n  int64 mypow(int64 a, int64 k) {\n    int64 r = 1;\n    while (k > 0) {\n      if (k & 1) {\n        r = r * a % MODULO;\n      }\n      a = a * a % MODULO;\n      k >>= 1;\n    }\n    return r;\n  }\n\n  void FWHT(vector<int>& P, bool inverse) {\n    for (int len = 1; 2 * len <= P.size(); len <<= 1) {\n      for (int i = 0; i < P.size(); i += 2 * len) {\n        for (int j = 0; j < len; j++) {\n          int u = P[i + j];\n          int v = P[i + len + j];\n          P[i + j] = u + v;\n          if (P[i + j] >= MODULO) P[i + j] -= MODULO;\n          P[i + len + j] = u - v;\n          if (P[i + len + j] < 0) P[i + len + j] += MODULO;\n        }\n      }\n    }\n\n    if (inverse) {\n      int64 inv = mypow(P.size(), MODULO - 2);\n      for (int i = 0; i < P.size(); i++)\n        P[i] = P[i] * inv % MODULO;\n    }\n  }\n\n  void solveOne(istream &in, ostream &out) {\n    int n;\n    in >> n;\n    vector<int> prod(1 << 17, 1);\n    vector<int> count(n + 5);\n    for (int step = 0; step < 3; ++step) {\n      auto g = readGraph(n, in);\n      vector<int> grundy(n);\n      for (int i = n - 1; i >= 0; --i) {\n        for (int x : g[i]) {\n          ++count[grundy[x]];\n        }\n        int j = 0;\n        while (count[j] > 0) ++j;\n        grundy[i] = j;\n        for (int x : g[i]) {\n          --count[grundy[x]];\n        }\n      }\n      vector<int> poly(1 << 17);\n      int64 pow = 1;\n      for (int i = 0; i < n; ++i) {\n        pow = pow * BASE % MODULO;\n        poly[grundy[i]] = (poly[grundy[i]] + pow) % MODULO;\n      }\n      FWHT(poly, false);\n      for (int i = 0; i < poly.size(); ++i) {\n        prod[i] = prod[i] * int64(poly[i]) % MODULO;\n      }\n    }\n    FWHT(prod, true);\n    out << prod[0] << \"\\n\";\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskC solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M =  998244353;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nvoid insum(int & a, int b) {\n    a = (a + b) % M;\n}\n\nmap<int, int> conv(map<int, int> a, map<int, int> b) {\n    map<int, int> ret;\n    for (auto x : a) {\n        for (auto y : b) {\n            insum(ret[x.first ^ y.first], (ll) x.second * y.second % M);\n        }\n    }\n    return ret;\n}\n\nvoid smain() {\n\n    int n;\n    cin >> n;\n    vvvi g(3, vvi(n + 1));\n    fori (z, 3) {\n        int m;\n        cin >> m;\n        fori (_, m) {\n            int u, v;\n            cin >> u >> v;\n            if (u > v)\n                swap(u, v);\n            g[z][u].push_back(v);\n        }\n    }\n\n    vector<map<int, int>> grs(3);\n    fori (z, 3) {\n        vi dp(n + 1, 0);\n        for (int v = n; v >= 1; --v) {\n            set<int> mex;\n            for (int to : g[z][v]) {\n                mex.insert(dp[to]);\n            }\n            int i = 0;\n            while (mex.count(i))\n                ++i;\n            dp[v] = i;\n            insum(grs[z][dp[v]], pw(10, 18 * v));\n        }\n    }\n    map<int, int> res;\n    res[0] = 1;\n    fori (z, 3) {\n        res = conv(res, grs[z]);\n    }\n    cout << res[0];\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nconst int N = 1e5 + 7, mod = 998244353, base = 716070898, sz = 1005;\nvector<int> g[3][N], m(3), power(N);\n\nint n, grundy[3][N], sum[4][sz]; // sum of powers of each grundy value\n\nvoid dfs(int idx, int u){\n\tif(g[idx][u].empty()) {\n\t\tgrundy[idx][u] = 0;\n\t\treturn;\n\t}\n\tset<int> num;\n\tfor(auto v : g[idx][u]){\n\t\tif(grundy[idx][v] == -1) dfs(idx, v);\n\t\tnum.insert(grundy[idx][v]);\n\t}\n\tint mex = 0;\n\twhile(num.count(mex)) ++mex;\n\tgrundy[idx][u] = mex;\n}\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tcin >> n;\n\tfor(int i = 0; i < 3; ++i){\n\t\tcin >> m[i];\n\t\tfor(int j = 0; j < m[i]; ++j){\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tif(u > v) swap(u, v);\n\t\t\tg[i][u].push_back(v);\n\t\t}\n\t}\n\tpower[0] = 1;\n\tfor(int i = 1; i < N; ++i) power[i] = (power[i - 1] * base) % mod;\n\tmemset(grundy, -1, sizeof(grundy));\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\tif(grundy[i][j] == -1) dfs(i, j);\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < 3; ++i){\n\t\tfor(int j = 1; j <= n; ++j){\n\t\t\t(sum[i][grundy[i][j]] += power[j]) %= mod;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < sz; ++i){\n\t\tfor(int j = 0; j < sz; ++j){\n\t\t\tif((i ^ j) < sz) (sum[3][i ^ j] += sum[0][i] * sum[1][j]) %= mod;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 0; i < sz; ++i) (ans += sum[2][i] * sum[3][i]) %= mod;\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nconst int MOD = 998244353;\nconst int BASE = 716070898;\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   int N;\n   cin >> N;\n   vector<int> pw(N + 1);\n   pw[0] = 1;\n   for (int i = 0; i < N; ++i) {\n      pw[i + 1] = ll(pw[i]) * BASE % MOD;\n   }\n   vector<array<int, 512>> cnts;\n   for (int z = 0; z < 3; ++z) {\n      int M;\n      cin >> M;\n      vector<vector<int>> adj(N);\n      for (int i = 0; i < M; ++i) {\n         int v, u;\n         cin >> v >> u;\n         --v, --u;\n         if (v > u) swap(v, u);\n         adj[v].emplace_back(u);\n      }\n      array<int, 512> cnt = {};\n      vector<int> sg(N);\n      for (int v = N - 1; v >= 0; --v) {\n         set<int> nxts;\n         for (int u : adj[v]) {\n            nxts.emplace(sg[u]);\n         }\n         sg[v] = 0;\n         while (nxts.count(sg[v])) sg[v]++;\n         cnt[sg[v]] += pw[v + 1];\n         if (cnt[sg[v]] >= MOD) cnt[sg[v]] -= MOD;\n      }\n      cnts.emplace_back(cnt);\n   }\n   int ans = 0;\n   for (int x = 0; x < 512; ++x) {\n      for (int y = 0; y < 512; ++y) {\n         ans += ll(cnts[0][x]) * cnts[1][y] % MOD * cnts[2][x ^ y] % MOD;\n         if (ans >= MOD) ans -= MOD;\n      }\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(a) int(a.size())\nconst int N=1e5+10;\nconst int M=500;\nconst int mod=998244353;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nvoid inc(int &a,int b) {\n\ta=a+b>=mod?a+b-mod:a+b;\n}\n\nint pw[N],n;\n\nstruct graph {\n\tvi E[N];\n\tint vis[N],sg[N];\n\n\tvoid adde(int u,int v) {\n\t\tE[u].pb(v);E[v].pb(u);\n\t}\n\n\tvi cal() {\n\t\tint m=gi();\n\t\tvi ret;\n\t\tfor(int i=1,u,v;i<=m;i++) u=gi(),v=gi(),adde(u,v);\n\t\tfor(int u=n;u;u--) {\n\t\t\tfor(auto v:E[u]) if(u<v) vis[sg[v]]=u;\n\t\t\tfor(int i=0;;i++)\n\t\t\t\tif(vis[i]!=u) { sg[u]=i;break; }\n\t\t\twhile(sz(ret)<=sg[u]) ret.pb(0);\n\t\t\tinc(ret[sg[u]],pw[u]);\n\t\t}\n\t\treturn ret;\n\t}\n} G1,G2,G3;\n\nint main() {\n\tpw[0]=1;\n\tpw[1]=1;for(int i=1;i<=18;i++) pw[1]=10ll*pw[1]%mod;\n\tfor(int i=2;i<N;i++) pw[i]=1ll*pw[i-1]*pw[1]%mod;\n\tcin>>n;\n\tvi v1=G1.cal(),v2=G2.cal(),v3=G3.cal();\n\tint ans=0;\n\tfor(int i=0;i<sz(v1);i++)\n\t\tfor(int j=0;j<sz(v2);j++) {\n\t\t\tint k=i^j;\n\t\t\tif(k<sz(v3)) inc(ans,1ll*v1[i]*v2[j]%mod*v3[k]%mod);\n\t\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n\nusing ll = long long;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nint const nmax = 100000;\nint const rad = 400;\nint const modulo = 998244353;\nstd::vector<int> g[3][1 + nmax];\nint nimber[3][1 + nmax];\n\nint lgpow(int a, int b) {\n  if(b == 0)\n    return 1;\n  else if(b == 1)\n    return a;\n  else {\n    int result = lgpow(a, b / 2);\n    if(b % 2 == 0)\n      return 1LL * result * result % modulo;\n    else\n      return 1LL * result * result % modulo * a % modulo;\n  }\n}\n\nint mex(std::vector<int> v) {\n  std::sort(v.begin(), v.end());\n  v.erase(std::unique(v.begin(), v.end()), v.end());\n  for(int i = 0; i < v.size(); i++)\n    if(i != v[i])\n      return i;\n  return v.size();\n}\n\nint sum[3][5 + nmax];\n\nint main() {\n  int n, m[3];\n  std::cin >> n;\n  for(int h = 0; h < 3; h++) {\n    std::cin >> m[h];\n    for(int i = 1;i <= m[h]; i++){\n      int x, y;\n      std::cin >> x >> y;\n      if(y < x)\n        std::swap(x, y);\n      g[h][x].push_back(y);\n    }\n    std::vector<int> cand;\n    for(int i = n; 1 <= i; i--) {\n      cand.clear();\n      for(int h_ = 0; h_ < g[h][i].size(); h_++){\n        int to = g[h][i][h_];\n        cand.push_back(nimber[h][to]);\n      }\n      nimber[h][i] = mex(cand);\n      sum[h][nimber[h][i]] = (sum[h][nimber[h][i]] + lgpow(10, 18 * i)) % modulo;\n    }\n  }\n\n  int result = 0;\n  \n  for(int i = 0; i < rad; i++)\n    for(int j = 0; j < rad; j++)\n      if((i ^ j) < rad) { \n        result = (result + 1LL * sum[0][i] * sum[1][j] % modulo * sum[2][i ^ j]) % modulo;\n      }\n  std::cout << result;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\nusing MF = IntMod<998244353>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n\n#ifndef __VECTOR_UTIL_H__\n#define __VECTOR_UTIL_H__\n\n/* updated: 2020-03-22 */\n\n#include <cassert>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n\ntemplate <class T>\nstd::vector<T> inputVector(int size, std::istream& ist = std::cin);\ntemplate <class T>\nstd::vector<std::vector<T>> inputVector2D(int height, int width, std::istream& ist = std::cin);\ntemplate <class T>\nvoid outputVector(const std::vector<T>& vec, const std::string& delimiter = \" \", std::ostream& ost = std::cout);\ntemplate <class T>\nstd::vector<T> makeVector(int size, const T& value);\ntemplate <class T, class Func>\nvoid apply(std::vector<T>& vec, Func func);\ntemplate <class T, class BinaryFunc>\nstd::vector<T> elementwise(std::vector<T>& a, std::vector<T>& b, BinaryFunc func);\ntemplate <class T>\nvoid sortAndUnique(std::vector<T>& vec);\ntemplate <class T>\nint mex(const std::vector<T>& vec);\n\n/* 標準入力から値を受け取り vector を生成 */\ntemplate <class T>\nstd::vector<T> inputVector(int size, std::istream& ist) {\n\tstd::vector<T> ret(size);\n\tfor (int i = 0; i < size; ++i) {\n\t\tist >> ret[i];\n\t}\n\treturn ret;\n}\n\n/* 標準入力から値を受け取り2次元 vector を生成 */\ntemplate <class T>\nstd::vector<std::vector<T>> inputVector2D(int height, int width, std::istream& ist) {\n\tstd::vector<std::vector<T>> ret(height, std::vector<T>(width));\n\tfor (int i = 0; i < height; ++i) {\n\t\tfor (int j = 0; j < width; ++j) {\n\t\t\tist >> ret[i][j];\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* vector の内容を delimiter 区切りで出力 */\ntemplate <class T>\nvoid outputVector(const std::vector<T>& vec, const std::string& delimiter, std::ostream& ost) {\n\tint size = vec.size();\n\tfor (int i = 0; i < size; ++i) {\n\t\tost << vec[i];\n\t\tif (i == size - 1) {\n\t\t\tost << std::endl;\n\t\t} else {\n\t\t\tost << delimiter;\n\t\t}\n\t}\n}\n\n/* vector 生成のヘルパー関数(主に多次元配列用) */\ntemplate <class T>\nstd::vector<T> makeVector(int size, const T& value) {\n\treturn std::vector<T>(size, value);\n}\n\n/* vector の各要素に関数を適用する */\ntemplate <class T, class Func>\nvoid apply(std::vector<T>& vec, Func func) {\n\tstd::transform(vec.begin(), vec.end(), vec.begin(), func);\n}\n\n/* 2つの vector に対して要素ごとの演算を行って1つの vector を生成する */\ntemplate <class T, class BinaryFunc>\nstd::vector<T> elementwise(std::vector<T>& a, std::vector<T>& b, BinaryFunc func) {\n\tassert(a.size() == b.size());\n\t\n\tconst int size = a.size();\n\tstd::vector<T> ret(size);\n\tfor (int i = 0; i < size; ++i) {\n\t\tret[i] = func(a[i], b[i]);\n\t}\n\treturn ret;\n}\n\n/* sort + unique O(n log n) */\ntemplate <class T>\nvoid sortAndUnique(std::vector<T>& vec) {\n\tsort(vec.begin(), vec.end());\n\tauto it = unique(vec.begin(), vec.end());\n\tvec.erase(it, vec.end());\n}\n\n/* vector に含まれない非負整数のうち、最小のもの (minimum excluded) を得る O(n log n) */\n/* template である必要ないかも */\ntemplate <class T>\nint mex(const std::vector<T>& vec) {\n\tstd::vector<int> copied(vec);\n\tsortAndUnique(copied);\n\t\n\tint value = 0;\n\twhile (value < copied.size() && copied[value] == value) {\n\t\t++value;\n\t}\n\treturn value;\n}\n\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n\nusing Grph = vector<vector<int>>;\nGrph in(int N) {\n\tint M = Next<int>();\n\tGrph G(N);\n\tREP(z, 0, M) {\n\t\tint a = Next<int>() - 1;\n\t\tint b = Next<int>() - 1;\n\t\tif (a > b) swap(a, b);\n\t\tG[a].push_back(b);\n\t}\n\treturn G;\n}\n\nmap<int, MF> grundy(const Grph& G) {\n\tint N = G.size();\n\tvector<int> v(N);\n\tREM(from, 0, N) {\n\t\tvector<int> nxt;\n\t\tfor (int to : G[from]) {\n\t\t\tnxt.push_back(v[to]);\n\t\t}\n\t\tv[from] = mex(nxt);\n\t}\n\n\tmap<int, MF> ret;\n\tREP(i, 0, N) {\n\t\tret[v[i]] += MF(10)[18][i + 1];\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint N = Next<int>();\n\tvector<Grph> G;\n\tREP(z, 0, 3) G.push_back(in(N));\n\tauto A = grundy(G[0]);\n\tauto B = grundy(G[1]);\n\tauto C = grundy(G[2]);\n\n\tMF sum = 0;\n\tfor (auto p : A) {\n\t\tfor (auto q : B) {\n\t\t\tsum += p.second * q.second * C[p.first ^ q.first];\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 0;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  vector<long long> ary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    set<int> usable;\n    for(int i = 1; i<N+1; ++i) {\n      usable.insert(i);\n    }\n    while(!usable.empty()) {\n      set<int> u = usable;\n      long long curr = 0;\n      while(!u.empty()) {\n        auto it = u.end();\n        it--;\n        int next = *it;\n        curr = (curr + pows[next]) % MOD;\n        for(int i = 0; i<adj[next].size(); ++i) {\n          u.erase(adj[next][i]);\n        }\n        u.erase(next);\n        usable.erase(next);\n      }\n      ary[graph].push_back(curr);\n    }\n  }\n\n  for(int i = 0; i<min(min(ary[0].size(), ary[1].size()), ary[2].size()); ++i) {\n    long long add = 0;\n    if(i == 0) {\n      add = ((ary[0][i] * ary[1][i]) % MOD) * ary[2][i];\n    }\n    else {\n      add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0] + ((ary[0][i] * ary[1][0])%MOD) * ary[2][i] + ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n      ary[0][0] += ary[0][i];\n      ary[1][0] += ary[1][i];\n      ary[2][0] += ary[2][i];\n    }\n    ret = (ret + add) % MOD;\n  }\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ui unsigned int\n#define ull unsigned long long\n#define db long double\n#define pii pair<int,ll>\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define vi vector<int>\n#define lb lower_bound\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,b,a) for(int i=(b);i>=(a);--i)\n#define rep0(i,a,b) for(int i=(a);i<(b);++i)\n#define fore(i,a) for(int i=0;i<a.size();++i)\n#define ls x<<1,l,m\n#define rs x<<1|1,m+1,r\n#define gc() getchar()\ninline int rd()\n{\n\tint x=0,w=1;char c=gc();while(!isdigit(c)&&c!='-')c=gc();\n\tif(c=='-')w=-1,c=gc();while(isdigit(c))x=x*10+c-48,c=gc();return x*w;\n}\nconst int N=100005,M=1<<19,P=998244353,iv2=(P+1)/2;\nint n,s[N],sg[N],a[M],b[M],c[M],d[M];vi g[N];\ninline int pw(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%P)if(b&1)r=1ll*r*a%P;return r;}\ninline void fwt(int n,int*a,int o)\n{\n\tfor(int i=2;i<=n;i<<=1)for(int j=0;j<n;j+=i)rep0(k,0,(i>>1))\n\t{\n\t\tint x=a[j+k],y=a[j+k+(i>>1)];\n\t\ta[j+k]=(x+y)%P;a[j+k+(i>>1)]=(x+P-y)%P;\n\t\tif(o==-1)\n\t\t{\n\t\t\ta[j+k]=1ll*a[j+k]*iv2%P;\n\t\t\ta[j+k+(i>>1)]=1ll*a[j+k+(i>>1)]*iv2%P;\n\t\t}\n\t}\n}\nvoid calc(int n,int*a)\n{\n\tint m=rd();rep(i,1,n)g[i].clear();\n\trep(i,1,m){int u=rd(),v=rd();if(u>v)swap(u,v);g[u].pb(v);}\n\tper(i,n,1)\n\t{\n\t\tfor(int x:g[i])s[sg[x]]++;\n\t\tsg[i]=0;while(s[sg[i]])sg[i]++;\n\t\tfor(int x:g[i])s[sg[x]]--;\n\t\ta[sg[i]]=(a[sg[i]]+pw(10,18*i))%P;\n\t}\n}\nint main()\n{\n\tn=rd();calc(n,a);calc(n,b);calc(n,c);\n\tfwt(M,a,1);fwt(M,b,1);fwt(M,c,1);\n\trep0(i,0,M)d[i]=1ll*a[i]*b[i]%P*c[i]%P;\n\tfwt(M,d,-1);printf(\"%d\\n\",d[0]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 998244353;\nll beki[100100];\nll N;\nvector<ll> paths[3][100000];\nll Grundy[3][100000];\nbool checked[3][100000];\nll M[3];\nvector<ll> mex[3][100000];\n\nll sum[3][500];\nll ans;\n\nvoid f(int idx, int now) {\n    if(checked[idx][now]) return;\n    checked[idx][now] = true;\n    for(auto to : paths[idx][now]) {\n        if(to > now) f(idx, to);\n    }\n    sort(mex[idx][now].begin(), mex[idx][now].end());\n    mex[idx][now].erase(unique(mex[idx][now].begin(), mex[idx][now].end()), mex[idx][now].end());\n    mex[idx][now].push_back(1e9);\n    for(int i = 0; i < mex[idx][now].size(); i++) {\n        if(mex[idx][now][i] != i) {\n            Grundy[idx][now] = i;\n            break;\n        }\n    }\n    for(auto to : paths[idx][now]) {\n        if(to < now) {\n            mex[idx][to].push_back(Grundy[idx][now]);\n        }\n    }\n}\n\nint main() {\n    beki[0] = 1;\n    beki[1] = 1e18;\n    beki[1] %= mod;\n    for(ll i = 2; i <= 1e5; i++) {\n        beki[i] = beki[i-1] * beki[1] % mod;\n    }\n    cin >> N;\n    for(int i = 0; i < 3; i++) {\n        cin >> M[i];\n        for(int j = 0; j < M[i]; j++) {\n            ll a, b;\n            cin >> a >> b;\n            a--;\n            b--;\n            paths[i][a].push_back(b);\n            paths[i][b].push_back(a);\n        }\n    }\n    for(int t = 0; t < 3; t++) {\n        for(int i = 0; i < N; i++) {\n            f(t, i);\n        }\n    }\n    /*\n    for(int t = 0; t < 3; t++) {\n        for(int i = 0; i < N; i++) {\n            cerr << t << \" \" << i << \" \" << Grundy[t][i] << endl;\n        }\n    }\n    */\n    for(int t = 0; t < 3; t++) {\n        for(int i = 0; i < N; i++) {\n            sum[t][Grundy[t][i]] += beki[i+1];\n            sum[t][Grundy[t][i]] %= mod;\n        }\n    }\n    for(int i = 0; i < 500; i++) {\n        for(int j = 0; j < 500; j++) {\n            for(int k = 0; k < 500; k++) {\n                if((i^j^k) != 0) continue;\n                ll tmp = sum[0][i] * sum[1][j] % mod;\n                tmp = tmp * sum[2][k] % mod;\n                ans += tmp;\n                ans %= mod;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 100007\n#define modp 998244353\nusing namespace std;\nint base=1;\nint n,m1,m2,m3;\nint n1,n2,n3,val1[Maxn],val2[Maxn],val3[Maxn],val[Maxn];\nvector<int> e1[Maxn],e2[Maxn],e3[Maxn];\nbool vis[Maxn],flag[Maxn];\nbool vis1[2007][2007],vis2[2007][2007],vis3[2007][2007];\nvector<pair<pair<int,int>,pair<int,int> > >v;\nvoid solve1()\n{\n    n1=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val1[++n1]=val[i];\n                } else val1[n1]=(val1[n1]+val[i])%modp;\n                for (int j=0;j<(int)e1[i].size();j++)\n                    flag[e1[i][j]]=false;\n            }\n    }\n}\nvoid solve2()\n{\n    n2=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val2[++n2]=val[i];\n                } else val2[n2]=(val2[n2]+val[i])%modp;\n                for (int j=0;j<(int)e2[i].size();j++)\n                    flag[e2[i][j]]=false;\n            }\n    }\n}\nvoid solve3()\n{\n    n3=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val3[++n3]=val[i];\n                } else val3[n3]=(val3[n3]+val[i])%modp;\n                for (int j=0;j<(int)e3[i].size();j++)\n                    flag[e3[i][j]]=false;\n            }\n    }\n}\nint main()\n{\n    for (int i=1;i<=18;i++)\n        base=(10LL*base)%modp;\n    scanf(\"%d\",&n);\n    val[0]=1;\n    for (int i=1;i<=n;i++)\n        val[i]=(1LL*val[i-1]*base)%modp;\n    scanf(\"%d\",&m1);\n    for (int i=1;i<=m1;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e1[u].push_back(v);\n        e1[v].push_back(u);\n    }\n    scanf(\"%d\",&m2);\n    for (int i=1;i<=m2;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e2[u].push_back(v);\n        e2[v].push_back(u);\n    }\n    scanf(\"%d\",&m3);\n    for (int i=1;i<=m3;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e3[u].push_back(v);\n        e3[v].push_back(u);\n    }\n    solve1();\n    solve2();\n    solve3();\n    for (int i=1;i<=n1;i++)\n        for (int j=1;j<=n2;j++)\n            for (int k=1;k<=n3;k++)\n                v.push_back(make_pair(make_pair(i+j+k,i),make_pair(j,k)));\n    sort(v.begin(),v.end());\n    int ans=0;\n    memset(vis1,true,sizeof(vis1));\n    memset(vis2,true,sizeof(vis2));\n    memset(vis3,true,sizeof(vis3));\n    for (int id=0;id<v.size();id++)\n    {\n        int i=v[id].first.second;\n        int j=v[id].second.first;\n        int k=v[id].second.second;\n        if (vis1[i][j]&&vis2[j][k]&&vis3[k][i])\n        {\n            vis1[i][j]=false;\n            vis2[j][k]=false;\n            vis3[k][i]=false;\n            int tmp=(1LL*val1[i]*val2[j])%modp;\n            tmp=(1LL*tmp*val3[k])%modp;\n            ans=(ans+tmp)%modp;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int S = 500, SSS = S * S * S, N = 1e5 + 5, mod = 998244353;\n \nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n \nconst int base = powmod(10, 18);\n \nvector<int> g[N];\n \nvector<pair<int, int>> independent(int n, vector<pair<int ,int>> & edges) {\n  for (int i = 0; i < n; ++i)\n    g[i].clear();\n  for (auto e : edges) {\n    g[e.first].push_back(e.second);\n    g[e.second].push_back(e.first);\n  }\n  vector<bool> done(n, false), mark(n);\n  int cnt = 0;\n  vector<pair<int, int>> res;\n  while (cnt < n) {\n    mark = done;\n    int hig = -1, sum = 0;\n    for (int v = n-1; v >= 0; --v) {\n      if (mark[v]) continue;\n      ++cnt;\n      done[v] = 1;\n      hig = max(hig, v+1);\n      sum = (sum + powmod(base, v+1)) % mod;\n      for (int u : g[v]) {\n        mark[u] = 1;\n      }\n    }\n    res.emplace_back(hig, sum);\n  }\n  return res;\n}\n \nvector<pair<int, int>> read_edges() {\n  int m;\n  scanf(\"%d\", &m);\n  vector<pair<int, int>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &edges[i].first, &edges[i].second);\n    --edges[i].first;\n    --edges[i].second;\n  }\n  return edges;\n}\n \nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> ex = read_edges();\n  vector<pair<int, int>> ey = read_edges();\n  vector<pair<int, int>> ez = read_edges();\n  vector<pair<int, int>> rx = independent(n, ex);\n  vector<pair<int, int>> ry = independent(n, ey);\n  vector<pair<int, int>> rz = independent(n, ez);\n  assert(rx.size() < S);\n  assert(ry.size() < S);\n  assert(rz.size() < S);\n  long long ans = 0;\n  for (int i = 0; i < (int)rx.size(); ++i) {\n    for (int j = 0; j < (int)ry.size(); ++j) {\n      int k = i^j;\n      if (k < (int)rz.size()) {\n        long long cur = rx[i].second * (long long)ry[j].second % mod;\n        ans = (ans + cur * rz[k].second) % mod;\n      }\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\n\nint n,m[3],gr[3][100005];\nvi g[3][100005];\nMint sum[3][350],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,3){\n\t\tcin>>m[i];\n\t\trep(j,m[i]){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tg[i][--a].pb(--b);\n\t\t\tg[i][b].pb(a);\n\t\t}\n\t\tvi p;\n\t\trrep(j,n){\n\t\t\tp.clear();\n\t\t\tfor(auto &k:g[i][j]){\n\t\t\t\tif(j<k){\n\t\t\t\t\tp.pb(gr[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(p));\n\t\t\tp.erase(unique(all(p)),p.end());\n\t\t\tgr[i][j]=-1;\n\t\t\trep(k,si(p)){\n\t\t\t\tif(k!=p[k]){\n\t\t\t\t\tgr[i][j]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(gr[i][j]==-1)gr[i][j]=si(p);\n\t\t\tsum[i][gr[i][j]]+=Mint(10).pow(18*(j+1));\n\t\t}\n\t}\n\trep(i,340){\n\t\trep(j,340){\n\t\t\trep(k,340){\n\t\t\t\tif(i^j^k==0){\n\t\t\t\t\tans+=sum[0][i]*sum[1][j]*sum[2][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\n\nconst int LOG = 17;\nconst int N = 1 << LOG;\nll p[N + 3];\nint n, m;\nvector<int> g[N + 3];\nvector<int> a[N + 3];\nll B[3][N];\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tp[0] = 1;\n\tp[1] = bin_pow(10, 18);\n\tfor (int i = 2; i < N; i++)\n\t\tp[i] = mult(p[i - 1], p[1]);\n\n\tscanf(\"%d\", &n);\n\tfor (int it = 0; it < 3; it++) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tg[i].clear();\n\t\t\ta[i].clear();\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\twhile(m--) {\n\t\t\tint v, u;\n\t\t\tscanf(\"%d%d\", &v, &u);\n\t\t\tif (v < u) swap(v, u);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tfor (int i = n; i > 0; i--) {\n\t\t\tsort(a[i].begin(), a[i].end());\n\t\t\tint z = 0, pos = 0;\n\t\t\twhile(true) {\n\t\t\t\twhile(pos < (int)a[i].size() && a[i][pos] < z) pos++;\n\t\t\t\tif (pos == (int)a[i].size() || a[i][pos] > z) break;\n\t\t\t\tz++;\n\t\t\t}\n\t\t\tB[it][z] = add(B[it][z], p[i]);\n\t\t\t//B[it][z] = add(B[it][z], 1);\n\t\t\t//printf(\"%d \", z);\n\t\t\tfor (int v : g[i])\n\t\t\t\ta[v].push_back(z);\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n\n\tfor (int it = 0; it < 3; it++) {\n\t\tfor (int k = 0; k < LOG; k++) {\n\t\t\tfor (int mask = 0; mask < N; mask++) {\n\t\t\t\tif ((mask >> k) & 1) continue;\n\t\t\t\tll x = B[it][mask], y = B[it][mask ^ (1 << k)];\n\t\t\t\t//B[it][mask] = sub(x, y);\n\t\t\t\t//B[it][mask ^ (1 << k)] = add(x, y);\n\t\t\t\tB[it][mask] = add(x, y);\n\t\t\t\tB[it][mask ^ (1 << k)] = sub(x, y);\n\t\t\t}\n\t\t}\n\t}\n/*\n\tfor (int it = 0; it < 3; it++) {\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tprintf(\"%lld \", B[it][i]);\n\t\tprintf(\"\\n\");\n\t}\n*/\n\tfor (int mask = 0; mask < N; mask++)\n\t\tfor (int i = 1; i < 3; i++)\n\t\t\tB[0][mask] = mult(B[0][mask], B[i][mask]);\n\n\tfor (int k = 0; k < LOG; k++) {\n\t\tfor (int mask = 0; mask < N; mask++) {\n\t\t\tif ((mask >> k) & 1) continue;\n\t\t\tll x = B[0][mask], y = B[0][mask ^ (1 << k)];\n\t\t\t//B[0][mask] = sub(x, y);\n\t\t\t//B[0][mask ^ (1 << k)] = add(x, y);\n\t\t\tB[0][mask] = add(x, y);\n\t\t\tB[0][mask ^ (1 << k)] = sub(x, y);\n\t\t}\n\t}\n\tll ans = mult(B[0][0], rev(N));\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <set>\n#include <queue>\n#define MOD 998244353\n\nstruct str{\n\tint x0;\n\tint y0;\n\tint z0;\n\tlong long int value;\n};\nbool operator<(str a, str b)\n{\n\treturn a.x0+a.y0+a.z0>b.x0+b.y0+b.z0;\n}\nstd::priority_queue<str> Q;\nint a;\nlong long int power(long long int a, long long int b)\n{\n\tlong long int s = 1;\n\tlong long int t = a;\n\twhile(b)\n\t{\n\t\tif(b%2==1) s *= t, s%=MOD;\n\t\tt*=t, t%=MOD;\n\t\tb/=2;\n\t}\n\treturn s;\n}\n\nstd::vector<int> ans[5];\nstd::set<int> V[5][100010];\nint check[100010];\nstd::pair<int,int> edge[5][100010];\nvoid func(int C)\n{\n\tstd::vector<int> V2,V3,V4;\n\tfor(int i=a;i>=1;i--) V2.push_back(i);\n\twhile(V2.size()>0)\n\t{\n\t\tV4.clear();\n\t\tV3.clear();\n\t\tfor(int i=0;i<V2.size();i++) check[V2[i]] = 0;\n\t\tfor(int i=0;i<V2.size();i++)\n\t\t{\n\t\t\tif(check[V2[i]]==0)\n\t\t\t{\n\t\t\t\tcheck[V2[i]] = 1;\n\t\t\t\tV4.push_back(V2[i]);\n\t\t\t\tstd::set<int> ::iterator it;\n\t\t\t\tfor(it=V[C][V2[i]].begin();it!=V[C][V2[i]].end();it++)\n\t\t\t\t{\n\t\t\t\t\tint v;\n\t\t\t\t\tif(edge[C][*it].first!=V2[i]) v = edge[C][*it].first;\n\t\t\t\t\telse v = edge[C][*it].second;\n\t\t\t\t\tcheck[v] = 1;\n\t\t\t\t\tV[C][v].erase(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse V3.push_back(V2[i]);\n\t\t}\n\t\t\n\t\tlong long int sum = 0;\n\t\tfor(int i=0;i<V4.size();i++)\n\t\t{\n\t\t\tsum += power(10,18*V4[i]);\n\t\t\tsum %= MOD;\n\t\t}\n\t\tans[C].push_back(sum);\n\t\t\n\t\tV2.clear();\n\t\tV2 = V3;\n\t}\n}\n\nint check1[410][410],check2[410][410],check3[410][410];\nint main()\n{\n\tint b,c,d;\n\tscanf(\"%d\",&a);\n\tscanf(\"%d\",&b);\n\tfor(int i=1;i<=b;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tedge[1][i] = std::make_pair(s,t);\n\t\tV[1][s].insert(i);\n\t\tV[1][t].insert(i);\n\t}\n\tscanf(\"%d\",&c);\n\tfor(int i=1;i<=c;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tedge[2][i] = std::make_pair(s,t);\n\t\tV[2][s].insert(i);\n\t\tV[2][t].insert(i);\n\t}\n\tscanf(\"%d\",&d);\n\tfor(int i=1;i<=d;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tedge[3][i] = std::make_pair(s,t);\n\t\tV[3][s].insert(i);\n\t\tV[3][t].insert(i);\n\t}\n\tfunc(1);\n\tfunc(2);\n\tfunc(3);\n\tfor(int i=0;i<ans[1].size();i++)\n\t{\n\t\tfor(int j=0;j<ans[2].size();j++)\n\t\t{\n\t\t\tfor(int k=0;k<ans[3].size();k++)\n\t\t\t{\n\t\t\t\tlong long int s = ans[1][i];\n\t\t\t\ts *= ans[2][j], s%=MOD;\n\t\t\t\ts *= ans[3][k], s%=MOD;\n\t\t\t\tQ.push({i,j,k,s});\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong long int sum = 0;\n\twhile(!Q.empty())\n\t{\n\t\tint s1 = Q.top().x0;\n\t\tint s2 = Q.top().y0;\n\t\tint s3 = Q.top().z0;\n\t\tlong long int value = Q.top().value;\n\t\tQ.pop();\n\t\tif(check1[s1][s2]) continue;\n\t\tif(check2[s2][s3]) continue;\n\t\tif(check3[s1][s3]) continue;\n\t\tcheck1[s1][s2] = check2[s2][s3] = check3[s1][s3] = 1;\n\t\t//printf(\"%d %d %d!!\\n\",s1,s2,s3);\n\t\tsum += value, sum %= MOD;\n\t}\n\t\n\tprintf(\"%lld\",sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\nint read();\nint n;\nint m1, m2, m3;\nvoid Add(int& x, int y) { (x += y) >= mod ? x -= mod : x; }\n\nvector<int> e[3][100005];\nvoid add(int f, int t, int d) { e[d][f].push_back(t), e[d][t].push_back(f); }\nint sg[3][100005];\nvector<int> nx[100005];\nvoid solve(int d) {\n    for (int i = 1; i <= n; ++i) nx[i].clear();\n    for (int u = n; u >= 1; --u) {\n        sort(nx[u].begin(), nx[u].end());\n        for (int v : nx[u]) {\n            if (sg[d][u] == v) sg[d][u]++;\n            if (sg[d][u] < v) break;\n        }\n        for (int v : e[d][u]) nx[v].push_back(sg[d][u]);\n    }\n}\n\nint fsp(int base, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = 1ll * rt * base % mod;\n        base = 1ll * base * base % mod, p >>= 1;\n    }\n    return rt;\n}\nint M(int x) { return x + (x >> 31 & mod); }\nstruct Poly {\n    int x[300005];\n    int& operator[](int p) { return x[p]; }\n    void fwt(int len) {\n        for (int l = 2; l <= len; l <<= 1)\n            for (int i = 0, m = l >> 1; i < len; i += l)\n                for (int j = i, t; j < i + m; ++j)\n                    t = x[j + m], x[j + m] = M(x[j] - t), Add(x[j], t);\n    }\n} F[3];\n\nint main() {\n    n = read(), m1 = read();\n    for (int i = 1; i <= m1; ++i) add(read(), read(), 0);\n    m2 = read();\n    for (int i = 1; i <= m2; ++i) add(read(), read(), 1);\n    m3 = read();\n    for (int i = 1; i <= m3; ++i) add(read(), read(), 2);\n    for (int i = 0; i < 3; ++i) {\n        solve(i);\n        for (int j = 1, t = 1, p = fsp(10, 18); j <= n; ++j)\n            t = 1ll * t * p % mod, Add(F[i][sg[i][j]], t);\n    }\n    int len = 1;\n    while (len <= n) len <<= 1;\n    F[0].fwt(len), F[1].fwt(len), F[2].fwt(len);\n    for (int i = 0; i < len; ++i)\n        F[0][i] = 1ll * F[0][i] * F[1][i] % mod * F[2][i] % mod;\n\n    F[0].fwt(len);\n    printf(\"%d\\n\", 1ll * F[0][0] * fsp(len, mod - 2) % mod);\n    return 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 100005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nnamespace ModCalculator {\n\tconst int MOD = 998244353;\n\tinline void Inc(int &x, int y) {\n\t\tx += y; if (x >= MOD) x -= MOD;\n\t}\n\tinline void Dec(int &x, int y) {\n\t\tx -= y; if (x < 0) x += MOD;\n\t}\n\tinline int Add(int x, int y) {\n\t\tInc(x, y); return x;\n\t}\n\tinline int Sub(int x, int y) {\n\t\tDec(x, y); return x;\n\t}\n\tinline int Mul(int x, int y) {\n\t\treturn 1LL * x * y % MOD;\n\t}\n}\nusing namespace ModCalculator;\n \ninline int ksm(int x, int k) {\n    int ret = 1;\n   \tfor (; k; k >>= 1) {\n        if (k & 1) ret = Mul(ret, x);\n        x = Mul(x, x);\n    }\n    return ret;\n}\n\nint n, tim, vis[MAXN], pw[MAXN];\n\nstruct Graph {\n\tvector<int> e[MAXN];\n\tint m, sg[MAXN], mxsg, sum[MAXN];\n\t\n\tvoid build() {\n\t\tread(m);\n\t\tfor (int i = 1, u, v; i <= m; ++i) {\n\t\t\tread(u); read(v);\n\t\t\te[min(u, v)].push_back(max(u, v));\n\t\t}\n\t\tfor (int u = n; u >= 1; --u) {\n\t\t\t++tim;\n\t\t\tfor (auto v : e[u]) {\n\t\t\t\tvis[sg[v]] = tim;\n\t\t\t}\n\t\t\twhile (vis[sg[u]] == tim) {\n\t\t\t\t++sg[u];\n\t\t\t}\n\t\t\tInc(sum[sg[u]], pw[u]);\n\t\t\tmxsg = max(mxsg, sg[u]);\n\t\t}\n\t}\n} g1, g2, g3;\n\nvoid init() {\n\tread(n);\n\tint p18 = ksm(10, 18);\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpw[i] = Mul(pw[i - 1], p18);\n\t}\n\tg1.build();\n\tg2.build();\n\tg3.build();\n}\n\nvoid solve() {\n\tint ans = 0;\n\tfor (int i = 0; i <= g1.mxsg; ++i) {\n\t\tfor (int j = 0; j <= g2.mxsg; ++j) {\n\t\t\tInc(ans, Mul(Mul(g1.sum[i], g2.sum[j]), g3.sum[i ^ j]));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int maxn=512;\nconst int mod=998244353;\nint n,m,sg[200005];\nlong long f[3][1005],pw[100005],h[1005],B=1e18;\nvector<int> G[100005];\nlong long ksm(long long x,long long n)\n{\n\tlong long ans=1;\n\twhile(n)\n\t{\n\t\tif(n&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn ans;\n}\nvoid FWT(long long a[],int n,int ty)\n{\n\tfor(int i=1;i<n;i<<=1)\n\tfor(int j=0;j<n;j++)\n\t{\n\t\tif(j&i)\n\t\t{\n\t\t\tlong long t0=a[j-i],t1=a[j];\n\t\t\ta[j-i]=(t0+t1)%mod;a[j]=(t0-t1+mod)%mod;\n\t\t}\n\t}\n\tif(ty==-1)\n\t{\n\t\tlong long rev=ksm(n,mod-2);\n\t\tfor(int i=0;i<n;i++) a[i]=a[i]*rev%mod;\n\t}\n}\nint dfs(int x)\n{\n\tif(sg[x]!=-1) return sg[x];\n\tint g[405]={0};\n\tint sz=G[x].size();\n\tfor(int i=0;i<sz;i++) g[dfs(G[x][i])]=1;\n\tint now=0;\n\twhile(g[now]) now++;\n\treturn sg[x]=now;\n}\nint main()\n{\n\tB%=mod;\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++) pw[i]=pw[i-1]*B%mod;\n\tfor(int t=0;t<3;t++)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tmemset(sg,-1,sizeof(sg));\n\t\tfor(int i=1;i<=n;i++) G[i].clear();\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tif(x>y) swap(x,y);\n\t\t\tG[x].push_back(y);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) if(sg[i]==-1) dfs(i);\n\t\tfor(int i=1;i<=n;i++) f[t][sg[i]]=(f[t][sg[i]]+pw[i])%mod;\n\t\tFWT(f[t],maxn,1);\n\t}\n\tfor(int i=0;i<maxn;i++) h[i]=1;\n\tfor(int t=0;t<3;t++)\n\tfor(int i=0;i<maxn;i++) h[i]=h[i]*f[t][i]%mod;\n\tFWT(h,maxn,-1);\n\tprintf(\"%lld\\n\",(h[0]%mod+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005,E=262144;\nconst int M=998244353;\nint n,m,i,j,s,u,v,head[N],Next[N*2],adj[N*2],k,a[N],d[N],q[N];\nlong long w[3][5];\nvoid Push(int u,int v)\n{\n\tNext[++k]=head[u];\n\thead[u]=k;\n\tadj[k]=v;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tlong long e=1000000000000000000ll%M;\n\tq[0]=1;\n\tfor(i=1;i<=n;++i)\n\t\tq[i]=q[i-1]*e%M;\n\tfor(i=0;i<3;++i)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tmemset(head,0,sizeof(head));\n\t\tmemset(d,0,sizeof(d));\n\t\tk=0;\n\t\tfor(j=1;j<=m;++j)\n\t\t{\n\t\t\tscanf(\"%d %d\",&u,&v);\n\t\t\tPush(u,v);\n\t\t\tPush(v,u);\n\t\t}\n\t\tfor(j=n;j>=1;--j)\n\t\t{\n\t\t\tint p=0;\n\t\t\tfor(k=head[j];k!=0;k=Next[k])\n\t\t\t\tif(d[adj[k]])\n\t\t\t\t\ta[++p]=d[adj[k]];\n\t\t\tsort(a+1,a+1+p);\n\t\t\tint l=1;\n\t\t\tfor(k=1;;++k)\n\t\t\t{\n\t\t\t\twhile(l<=p&&a[l]<k)\n\t\t\t\t\t++l;\n\t\t\t\tif(l>p||a[l]!=k)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\td[j]=k;\n\t\t\tif(k<=2)\n\t\t\t\tw[i][(k+1)%2]=(w[i][(k+1)%2]+q[j])%M;\n\t\t}\n\t}\n\tcout<<((w[0][0]*w[1][0]%M*w[2][0]%M+w[0][1]*w[1][1]%M*w[2][0]%M+w[0][0]*w[1][1]%M*w[2][1]%M+w[0][1]*w[1][0]%M*w[2][1]%M)%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\n\n\nint xy[410][410],xz[410][410],yz[410][410];\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vector<int> d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,3100000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g1[i]){\n            if(e>i)se.insert(d1[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d1[i]=gr;\n        D1[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g2[i]){\n            if(e>i)se.insert(d2[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d2[i]=gr;\n        D2[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g3[i]){\n            if(e>i)se.insert(d3[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d3[i]=gr;\n        D3[gr] += P[i];\n    }\n    vec a,b;\n    mint ans;\n    int k1=0,k2=0,k3=0;\n    rep(i,4){\n        rep(j,4){\n            rep(k,4){\n                if(i>=n or j>=n or k>=n)break;\n                if(xy[i][j]==0 and xz[i][k]==0 and yz[j][k]==0) {\n                    ans+=D1[i]*D2[j]*D3[k];\n                    xy[i][j]=1;\n                    xz[i][k]=1;\n                    yz[j][k]=1;\n                } \n            }\n        }\n    }\n\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define maxn 100005 /*rem*/\n#define mod 998244353\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\nusing namespace std;\nint n;\nll qs = 1; \nll pw[maxn];\nvi eg[maxn];\nbool fl[3][1005][1005];\nint main() {\n\tfor (int i = 0; i < 18; i++) qs *= 10;\n\tqs %= mod;\n\tpw[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tpw[i] = pw[i - 1] * qs % mod;\n\tint n;\n\tcin >> n;\n\tll mt = 1;\n\tvector<ll> u[3];\n\tfor (int s = 0; s < 3; s++) {\n\t\tint m;\n\t\tcin >> m;\n\t\tfor (int i = 1; i <= n; i++) eg[i].clear();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\teg[u].pb(v), eg[v].pb(u);\n\t\t}\n\t\tset<int> x;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tx.insert(i);\n\t\twhile (1) {\n\t\t\tll cu = 0;\n\t\t\tif (!x.size()) break;\n\t\t\tset<int> y;\n\t\t\twhile (x.size()) {\n\t\t\t\tint r = *(--x.end());\n\t\t\t\tcu = (cu + pw[r]) % mod;\n\t\t\t\tx.erase(r);\n\t\t\t\tfor (auto v : eg[r]) {\n\t\t\t\t\tif (x.find(v) != x.end()) {\n\t\t\t\t\t\ty.insert(v);\n\t\t\t\t\t\tx.erase(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\t\t\tu[s].pb(cu);\n\t\t\tx = y;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < u[0].size(); i++)\n\t\tfor (int j = 0; j < u[1].size(); j++)\n\t\t\tfor (int k = 0; k < u[2].size(); k++) {\n\t\t\t\tif (fl[0][i][j] || fl[1][j][k] || fl[2][k][i]) continue;\n\t\t\t\tfl[0][i][j] = fl[1][j][k] = fl[2][k][i] = 1;\n\t\t\t\tll cur = u[0][i] * u[1][j] % mod * u[2][k] % mod;\n\t\t\t\tans = (ans + cur) % mod;\n\t\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long //data types used often, but you don't want to type them time by time\n#define ull unsigned long long\n#define ui unsigned int\n\n#define us unsigned short\n#define IOS ios_base::sync_with_stdio(0); //to synchronize the input of cin and scanf\n#define INF LONG_MAX\n#define PI 3.1415926535897932384626\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define rep(x,j,n)for(ll x=j;x<n;x++)\n#define repr(x,j,n)for(ll x=j;x>n;x--)\ntypedef vector<pair<ll,ll>> vpi;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\n#define mod 998244353\nll modexp(ll a,ll b,ll m)\n{\n    ll r=1;\n    a=a%m;\n    while(b>0)\n    {\n    if(b&1)\n    r=(r*a)%m;\n    b=b/2;\n    a=(a*a)%m;\n    }\n    return r%m;\n}\n\nvvi bit;//1-based indexing\nvoid bit_updatey(ll x,ll y,ll m,ll val)\n{\n    while(y<m)\n    {\n        bit[x][y]+=val;\n        y+=(y&(~y+1));\n    }\n}\nvoid bit_update(ll x,ll y,ll m,ll val)\n{\n    while(x<m)\n    {\n\n        bit_updatey(x,y,m,val);\n        x+=(x&(~x+1));\n    }\n}\n\n\nll bit_sum(ll x,ll y)\n{\n    ll s=0;\n    ll y1=y;\n    while(x>0)\n    {\n        y=y1;\n        while(y>0)\n         {\n            s+=(bit[x][y]);\n            y-=(y&(~y+1));\n        }\n        x-=(x&(~x+1));\n    }\n    return s;\n}\n\nll cal(vi &a)\n{\n    ll n=a.size();\n    ll s=0;\n    rep(i,1,n)\n    {\n        if(a[i]==1)\n        {\n            ll p=18*1LL*i;\n            s+=modexp(10,p,mod);\n            s=s%mod;\n        }\n    }\n    return s;\n}\n\n\n\n\nint main()\n{\n    ll n,m;\n\n    cin>>n;vi x(n+1,1),y(n+1,1),z(n+1,1);\n    cin>>m;\n    ll u,v;\n    rep(i,0,m)\n    {\n        cin>>u>>v;\n        if(u==n||v==n)\n        {\n            if(u!=n)x[u]=0;\n            else x[v]=0;\n        }\n    }\n    cin>>m;\n    rep(i,0,m)\n    {\n        cin>>u>>v;\n        if(u==n||v==n)\n        {\n            if(u!=n)y[u]=0;\n            else y[v]=0;\n        }\n    }\n    cin>>m;\n    rep(i,0,m)\n    {\n        cin>>u>>v;\n        if(u==n||v==n)\n        {\n            if(u!=n)z[u]=0;\n            else z[v]=0;\n        }\n    }\n    ll sx=cal(x);\n    ll sy=cal(y);\n    ll sz=cal(z);\n    ll temp=(sx*1LL*sy)%mod;\n    temp*=(sz)%mod;\n    temp=temp%mod;\n    cout<<temp;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ███▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓╬╬╬╬╬╬▓█\n// ███▓███████▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▓▓▓█▓╬╬╬▓█\n// ███████▓█████▓▓╬╬╬╬╬╬╬╬▓███▓╬╬╬╬╬╬╬▓╬╬▓█\n// ████▓▓▓▓╬╬▓█████╬╬╬╬╬╬███▓╬╬╬╬╬╬╬╬╬╬╬╬╬█\n// ███▓▓▓▓╬╬╬╬╬╬▓██╬╬╬╬╬╬▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬╬╬╬▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓███████▓▓███▓╬╬╬╬╬╬▓███████▓╬╬╬╬▓█\n// ████████████████▓█▓╬╬╬╬╬▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬█\n// ███▓▓▓▓▓▓▓╬╬▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬▓▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓▓█▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓██▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// █████▓▓▓▓▓████▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓█▓▓▓▓██▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓▓███▓▓▓▓▓▓▓██▓╬╬╬╬╬╬╬╬╬╬╬╬█▓╬▓╬╬▓██\n// █████▓███▓▓▓▓▓▓▓▓████▓▓╬╬╬╬╬╬╬█▓╬╬╬╬╬▓██\n// █████▓▓█▓███▓▓▓████╬▓█▓▓╬╬╬▓▓█▓╬╬╬╬╬╬███\n// ██████▓██▓███████▓╬╬╬▓▓╬▓▓██▓╬╬╬╬╬╬╬▓███\n// ███████▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬████\n// ███████▓▓██▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓████\n// ████████▓▓▓█████▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█████\n// █████████▓▓▓█▓▓▓▓▓███▓╬╬╬╬╬╬╬╬╬╬╬▓██████\n// ██████████▓▓▓█▓▓▓╬▓██╬╬╬╬╬╬╬╬╬╬╬▓███████\n// ███████████▓▓█▓▓▓▓███▓╬╬╬╬╬╬╬╬╬▓████████\n// ██████████████▓▓▓███▓▓╬╬╬╬╬╬╬╬██████████\n// ███████████████▓▓▓██▓▓╬╬╬╬╬╬▓███████████\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst int M = 998244353;\n\nstring to_string(string s)\n{\n    return '\"' + s + '\"';\n}\nstring to_string(const char* s)\n{\n    return to_string((string) s);\n}\nstring to_string(bool b)\n{\n    return (b ? \"true\" : \"false\");\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p)\n{\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v)\n{\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v)\n    {\n        if (!first)\n        {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\nvoid debug_out()\n{\n    cerr << endl;\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T)\n{\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n//#define LOCAL\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main()\n{\n    ios::sync_with_stdio(0),cin.tie(0);\n\n    // total O(M)\n    int n, m;\n    cin>>n;\n\n    vector<long long> pw(n);\n    pw[0] = 1000000000000000000 % M;\n    for(int i=1;i<n;i++){\n        pw[i] = pw[i-1] * pw[0] % M;\n    }\n\n\n\n    int u, v;\n    vector<vector<vector<int>>> mex;\n\n    vector<int> p(3);\n\n    vector<vector<int>> g(n, vector<int>());\n    vector<int> rk(n);\n\n\n    for(int j=0; j<3; j++)\n    {\n        for(int i=0; i<n; i++)\n        {\n            g[i].clear();\n        }\n        cin>>m;\n        for(int i=0; i<m; i++)\n        {\n            cin>>u>>v;\n            u--,v--;\n            if(u>v)\n            {\n                swap(u,v);\n            }\n            g[u].push_back(v);\n        }\n\n//    debug(g);\n        mex.push_back(vector<vector<int>>());\n\n\n        vector<int> nums(n);\n\n        for(int i=n-1; i>=0; i--)\n        {\n            int num=0;\n            int sz = mex[j].size();\n\n            for(int j : g[i])\n            {\n                nums[rk[j]]=i;\n            }\n\n//            debug(nums);\n            num=sz;\n            for(int j=0;j<sz;j++){\n                if(nums[j]!=i){\n                    num=j;\n                    break;\n                }\n            }\n            if(num == sz)\n            {\n                mex[j].push_back(vector<int>());\n            }\n            mex[j][num].push_back(i);\n            rk[i]=num;\n        }\n        p[j]=mex[j].size();\n    }\n\n    debug(mex);\n\n    long long ans=0;\n    for(int i=0; i<p[0]; i++)\n        for(int j=0; j<p[1]; j++)\n        {\n            int k=i^j;\n            if(k>=p[2])\n                continue;\n            if(mex[0][i].size()==0)\n                continue;\n            if(mex[1][j].size()==0)\n                continue;\n            if(mex[2][k].size()==0)\n                continue;\n            //i,j,k\n            long long sum=0, tmp=1;\n//    debug(mex[0][i]);\n            for(int a1 : mex[0][i])\n            {\n                sum = sum + tmp * pw[a1] % M;\n                sum %= M;\n            }\n            tmp = sum;\n\n            sum = 0 ;\n\n//    debug(mex[1][j]);\n            for(int a2 : mex[1][j])\n            {\n                sum = sum + tmp * pw[a2] % M;\n                sum %= M;\n            }\n            tmp = sum;\n\n            sum = 0;\n//    debug(mex[2][k]);\n\n            for(int a3 : mex[2][k])\n            {\n                sum = sum + tmp * pw[a3] % M;\n                sum %= M;\n            }\n//    debug(sum);\n            ans = ans + sum;\n            ans %= M;\n        }\n    debug(ans);\n    cout << ans << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <memory.h>\n#include <cmath>\n#include <array>\n\nusing namespace std;\n\nvoid re(int& x);\n\ntemplate<class T, class... Ts> void re(T& t, Ts&... ts);\n\nvoid pr(long long x);\n\nvoid pr(const char *x);\n\nvoid ps();\ntemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts);\n\n#ifdef FFDBG\n\n#else\n#define dbg(x...) dsfdsfsdfasd\n#endif\n\n#define sz(x) (int)(x).size()\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n\nconst int mod = 998244353;\nconst long long base = 1000000000000000000 % mod;\n\nint n,m;\nvector<int> g[3][110000];\nint seen[3][110000];\nvector<long long> vals[3];\nlong long pot[110000];\n\n// int dfs(int v) {\n//     if (seen[v]) return -1;\n//     seen[v] = 1;\n//     int ans = v;\n//     for (int x : g[v]) ans = max(v, dfs(x));\n//     return ans;\n// }\n\nvoid solve()\n{\n    pot[0] = 1;\n    rep(i,1,100010) pot[i] = (pot[i-1] * 1ll * base) % mod;\n\n    // dbg(base);\n\n    re(n);\n    rep(iter,0,3) {\n        re(m);\n\n        rep(i,0,m) {\n            int u,v; re(u,v); u--; v--;\n            g[iter][u].push_back(v);\n            g[iter][v].push_back(u);\n        }\n\n        int taken = 0, cc = 0;\n        while (taken < n) {\n            long long cur = 0;\n            cc++;\n            for (int i = n-1; i >= 0; i--) if (seen[iter][i]!=-1 && seen[iter][i] != cc) {\n                seen[iter][i]=-1;\n                taken++;\n                cur = (cur + pot[i+1]) % mod;\n                for (int x : g[iter][i]) if (seen[iter][x]!=-1) seen[iter][x] = cc;\n            }\n            vals[iter].push_back(cur);\n        }\n    }\n\n    long long ans = 0;\n\n    // dbg(vals[0][0], vals[0][1]);\n\n    rep(i,0,min(sz(vals[1]), sz(vals[2]))) {\n        long long th = vals[0][0];\n        th = (th * 1ll * vals[1][i]) % mod;\n        th = (th * 1ll * vals[2][i]) % mod;\n        ans = (ans + th) % mod;\n    }\n    rep(i,1,min(sz(vals[0]), sz(vals[2]))) {\n        long long th = vals[1][0];\n        th = (th * 1ll * vals[0][i]) % mod;\n        th = (th * 1ll * vals[2][i]) % mod;\n        ans = (ans + th) % mod;\n    }\n    rep(i,1,min(sz(vals[0]), sz(vals[1]))) {\n        long long th = vals[2][0];\n        th = (th * 1ll * vals[0][i]) % mod;\n        th = (th * 1ll * vals[1][i]) % mod;\n        ans = (ans + th) % mod;\n    }\n\n    ps(ans);\n}\n\nint main() {\n\n    solve();\n}\n\nvoid re(int& x) { scanf(\"%d\", &x); }\n\ntemplate<class T, class... Ts> void re(T& t, Ts&... ts) { \n    re(t); re(ts...); \n}\n\nvoid pr(long long x) { printf(\"%lld\", x); }\n\nvoid pr(const char *x) { printf(\"%s\", x); }\n\nvoid ps() { pr(\"\\n\"); }\ntemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n    pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long arr[100010];\nlong long g1[100010]={0,},g2[100010]={0,},g3[100010]={0,};\nlong long f1[100010]={0,},f2[100010]={0,},f3[100010]={0,};\nlong long var[100010]={0,};\nvector<long long>G1[100010],G2[100010],G3[100010];\nlong long pw10[100010];\nlong long mod=998244353;\nint main(){\n\tlong long a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,tmp,ans,cnt,max1=0,max2=0,max3=0;\n\tscanf(\"%lld\",&n);\n\tscanf(\"%lld\",&tmp);\n\tfor(i=0;i<tmp;i++){\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\tG1[a].push_back(b);\n\t\tG1[b].push_back(a);\n\t}\n\tscanf(\"%lld\",&tmp);\n\tfor(i=0;i<tmp;i++){\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\tG2[a].push_back(b);\n\t\tG2[b].push_back(a);\n\t}\n\tscanf(\"%lld\",&tmp);\n\tfor(i=0;i<tmp;i++){\n\t\tscanf(\"%lld %lld\",&a,&b);\n\t\tG3[a].push_back(b);\n\t\tG3[b].push_back(a);\n\t}\n\tpw10[0]=1;\n\tz=1000000000000000000%mod;\n\tfor(i=1;i<100010;i++) pw10[i]=(pw10[i-1]*z)%mod;\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=0; j<G1[i].size(); j++) if(G1[i][j]>i) var[g1[G1[i][j]]]=1;\n\t\tfor(j=0;j<100010;j++) if(var[j]==0) {\n\t\t\tg1[i]=j;\n\t\t\tif(max1<j) max1=j;\n\t\t\tbreak;\n\t\t}\n\t\tfor(j=0; j<G1[i].size(); j++) if(G1[i][j]>i) var[g1[G1[i][j]]]=0;\n\t}\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=0; j<G2[i].size(); j++) if(G2[i][j]>i) var[g2[G2[i][j]]]=1;\n\t\tfor(j=0;j<100010;j++) if(var[j]==0) {\n\t\t\tg2[i]=j;\n\t\t\tif(max2<j) max2=j;\n\t\t\tbreak;\n\t\t}\n\t\tfor(j=0; j<G2[i].size(); j++) if(G2[i][j]>i) var[g2[G2[i][j]]]=0;\n\t}\n\tfor(i=n;i>=1;i--){\n\t\tfor(j=0; j<G3[i].size(); j++) if(G3[i][j]>i) var[g3[G3[i][j]]]=1;\n\t\tfor(j=0;j<100010;j++) if(var[j]==0) {\n\t\t\tg3[i]=j;\n\t\t\tif(max3<j) max3=j;\n\t\t\tbreak;\n\t\t}\n\t\tfor(j=0; j<G3[i].size(); j++) if(G3[i][j]>i) var[g3[G3[i][j]]]=0;\n\t}\n\t//for(i=1;i<=n;i++)printf(\"%lld \",g1[i]);\n\t//for(i=1;i<=n;i++)printf(\"%lld \",g2[i]);\n\t//for(i=1;i<=n;i++)printf(\"%lld \",g3[i]);\n\tfor(i=1;i<=n;i++){\n\t\tf1[g1[i]]=(f1[g1[i]]+pw10[i])%mod;\n\t\tf2[g2[i]]=(f2[g2[i]]+pw10[i])%mod;\n\t\tf3[g3[i]]=(f3[g3[i]]+pw10[i])%mod;\n\t}\n\tans=0;\n\tfor(a=0;a<=max1;a++)\n\tfor(b=0;b<=max2;b++)\n\tfor(c=0;c<=max3;c++){\n\t\tif(((a^b)^c)==0) ans=(ans+(((f1[a]*f2[b])%mod)*f3[c])%mod)%mod;\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  vvi g[3];\n  cin >> n;\n  ll res = 0, all = 0;\n  vl pw(n + 1, 1);\n  ll r0 = 1000000000000000000LL % mod;\n  for (int i = 1; i < pw.size(); ++i) pw[i] = pw[i-1] * r0 % mod;\n  for (int i = 0; i < n; ++i) all = (all + pw[i + 1]) % mod;\n  ll prod = 1, sum = 0;\n  vl x[3];\n  for (int t = 0; t < 3; ++t) {\n    int m;\n    cin >> m;\n    g[t].resize(n);\n    for (int i = 0; i < m; ++i) {\n      int a, b;\n      cin >> a >> b;\n      --a; --b;\n      g[t][a].push_back(b);\n      g[t][b].push_back(a);\n    }\n    ll s = 0;\n    vi was(n);\n    for (int i = n-1; i >= 0; --i) if (!was[i]) {\n      s += pw[i + 1];\n      for (int j : g[t][i]) was[j] = 1;\n    }\n    s %= mod;\n//    sum = (sum + s) % mod;\n    prod = prod * s % mod;\n    x[t].push_back(s);\n    set<int> rem;\n    for (int i = 0; i < n; ++i) if (was[i]) rem.insert(i);\n    while (!rem.empty()) {\n      set<int> nrem;\n      ll s = 0;\n      while (!rem.empty()) {\n        auto it = rem.end(); --it;\n        int v = *it;\n        s += pw[v + 1];\n        for (int x : g[t][v]) if (rem.count(x)) {\n          rem.erase(x);\n          nrem.insert(x);\n        }\n        rem.erase(v);\n      }\n      x[t].push_back(s % mod);\n      rem.swap(nrem);\n    }\n  }\n  res = prod;\n  for (int t = 0; t < 3; ++t) {\n    int t1 = (t + 1) % 3, t2 = (t + 2) % 3;\n    for (int i = 1; i < min(x[t1].size(), x[t2].size()); ++i) {\n      res = (res + x[t][0] * x[t1][i] % mod * x[t2][i]) % mod;\n    }\n  }\n  cout << (res % mod + mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  vector< int > rev, rts;\n  int base, max_base, root;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n};\n\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vec d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,3100000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        D1[d1[i]] += P[i];\n        for(auto e:g1[i]){\n            if(d1[e]==d1[i])d1[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D2[d2[i]]+=P[i];\n        for(auto e:g2[i]){\n            if(d2[e]==d2[i])d2[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D3[d3[i]]+=P[i];\n        for(auto e:g3[i]){\n            if(d3[e]==d3[i])d3[e]++;\n        }\n    }\n    reverse(all(D2));\n    vec a,b;\n    rep(i,n+1)a.pb(D2[i].a);\n    rep(i,n+1)b.pb(D3[i].a);\n    NumberTheoreticTransform<998244353> ntt;\n    auto C = ntt.multiply(a,b);\n    mint ans;\n    rep(i,n+1){\n        if(i)\n        ans+=D1[i]*(C[n-i]+C[n+i]);\n        else\n        ans+=D1[i]*(C[n]);\n    }\n\n\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n/*#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n#pragma GCC option(\"arch=native\",\"tune=native\",\"no-zero-upper\") //Enable AVX\n#pragma GCC target(\"avx2\")  //Enable AVX*/\n\nusing namespace std;\n\nusing ll = long long;\n\n#define mp make_pair\n\nconst int p = 998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+p-b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n/*struct DSU {\n    vector<int> sz;\n    vector<int> parent;\n\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU(int n) {\n        sz.resize(n);\n        parent.resize(n);\n        for (int i = 0; i < n; i++) make_set(i);\n    }\n};*/\n\n/*const int N = 1000000;\n\nvector<int> facs(N), invfacs(N);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<N; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[N-1] = inv(facs[N-1]);\n    for (int i = N-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\nint n;\n\nconst int N = 1<<17;\n\nconst int K = po(10, 18);\n\n\nvector<int> process()\n{\n    vector<vector<int>> G(n+1);\n    int m;\n    cin>>m;\n    int a, b;\n    for (int i = 0; i<m; i++){\n        cin>>a>>b;\n        if (a>b) swap(a, b);\n        G[a].push_back(b);\n    }\n\n    vector<int> ans(n+1);\n    for (int i = n; i>=1; i--)\n    {\n        set<int> nims;\n        for (auto it: G[i]) nims.insert(ans[it]);\n        while (nims.find(ans[i])!=nims.end()) ans[i]++;\n    }\n\n    vector<int> gopa(N);\n\n    for (int i = 1; i<=n; i++) gopa[ans[i]] = add(gopa[ans[i]], po(K, i));\n    return gopa;\n}\n\nvector<int> FWHT(vector<int> P, bool inverse) {\n    for (int len = 1; 2 * len <= P.size(); len <<= 1) {\n        for (int i = 0; i < P.size(); i += 2 * len) {\n            for (int j = 0; j < len; j++) {\n                int u = P[i + j];\n                int v = P[i + len + j];\n                P[i + j] = add(u, v);\n                P[i + len + j] = sub(u, v);\n            }\n        }\n    }\n\n    if (inverse) {\n        for (int i = 0; i < P.size(); i++)\n            P[i] = mul(P[i], inv(P.size()));\n    }\n    return P;\n}\n\nvector<int> mult(vector<int> P, vector<int> Q)\n{\n    P = FWHT(P, false);\n    Q = FWHT(Q, false);\n    for (int i = 0; i<N; i++) P[i] = mul(P[i], Q[i]);\n    P = FWHT(P, true);\n    return P;\n}\n\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    cin>>n;\n    vector<vector<int>> answer(3);\n    for (int i = 0; i<3; i++) answer[i] = process();\n\n    vector<int> res1 = mult(answer[0], answer[1]);\n    res1 = mult(res1, answer[2]);\n    cout<<res1[0];\n\n\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nlong long T=1000000000000000000LL%mod;\nvector<int>g[3][110000];\nint s[3];\nint f[3][110000];\nint f2[3][110000];\nint dp[3][110000];\nlong long gr[3][110000];\nint calc(int a,int b){\n\tif(dp[a][b]>=0)return dp[a][b];\n\tvector<int>t;\n\tfor(int i=0;i<g[a][b].size();i++){\n\t\tt.push_back(calc(a,g[a][b][i]));\n\t}\n\tstd::sort(t.begin(),t.end());\n\tint ret=0;\n\tfor(int i=0;i<t.size();i++){\n\t\tif(ret<t[i])break;\n\t\tif(ret==t[i])ret++;\n\t}\n\treturn dp[a][b]=ret;\n}\nlong long pT[110000];\nlong long key[3];\npair<int,int>q[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<3;i++)for(int j=0;j<a;j++)dp[i][j]=-1;\n\n\tpT[0]=1;\n\tfor(int i=1;i<110000;i++){\n\t\tpT[i]=pT[i-1]*T%mod;\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tscanf(\"%d\",&s[j]);\n\t\tfor(int i=0;i<s[j];i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\tif(p>q)swap(p,q);\n\t\t\tg[j][p].push_back(q);\n\t\t}\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint at=calc(j,i);\n\t\t\t// printf(\"%d %d: %d\\n\",j,i,at);\n\t\t\tgr[j][at]=(gr[j][at]+pT[i])%mod;\n\t\t}\n\t}\n\n\tlong long ret=0;\n\tint M=sqrt(a)+1;\n\tfor(int i=0;i<=M;i++){\n\t\tfor(int j=0;j<=M;j++)for(int k=0;k<=M;k++){\n\t\t\tif(i^j^k)continue;\n\t\t\tret=(ret+gr[0][i]*gr[1][j]%mod*gr[2][k])%mod;\n\t\t}}\n\n\tret=ret*T%mod;\n\tret=ret*T%mod;\n\tret=ret*T%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\nconst int MAX = 510000;\n\nusing Graph = vector<vector<int>>;\nint N;\nvector<int> M;\nvector<Graph> G;\n\nvector<mint> ten;\nvector<vector<bool>> ok;\n\nvoid pre() {\n    ten.assign(MAX, 1);\n    mint fac = modpow(mint(10), 18);\n    for (int i = 1; i <= MAX; ++i) ten[i] = ten[i-1] * fac;\n}\n\nmint solve() {\n    vector<vector<int>> grundy(3, vector<int>(N, -1));\n    vector<vector<mint>> memo(3, vector<mint>(1000, 0));\n    for (int iter = 0; iter < 3; ++iter) {\n        for (int v = N-1; v >= 0; --v) {\n            set<int> gse;\n            for (auto e : G[iter][v]) gse.insert(grundy[iter][e]);\n            int gres = 0;\n            while (gse.count(gres)) ++gres;\n            grundy[iter][v] = gres;\n            memo[iter][gres] += ten[v+1];\n        }\n    }\n    mint res = 0;\n    for (int a = 0; a < 1000; ++a) {\n        if (memo[0][a] == 0) break;\n        for (int b = 0; b < 1000; ++b) {\n            if (memo[1][b] == 0) break;\n            int c = a^b;\n            res += memo[0][a] * memo[1][b] * memo[2][c];\n        }\n    }\n    return res;\n}\n\nint main() {\n    bc.init(MAX);\n    pre();\n    while (cin >> N) {\n        M.assign(3, 0);\n        G.assign(3, Graph(N, vector<int>()));\n        for (int iter = 0; iter < 3; ++iter) {\n            cin >> M[iter];\n            for (int i = 0; i < M[iter]; ++i) {\n                int a, b; cin >> a >> b; --a, --b;\n                G[iter][a].push_back(b);\n                G[iter][b].push_back(a);\n            }\n        }\n        cout << solve() << endl;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO\n{\nchar gc()\n{\n#ifdef FREAD\n\tstatic char buf[1<<21], *P1 = buf, *P2 = buf;\n\tif(P1 == P2)\n\t{\n\t\tP1 = buf;\n\t\tP2 = buf + fread(buf, 1, 1<<21, stdin);\n\t\tif(P1 == P2) return EOF;\n\t}\n\treturn *(P1++);\n#else\n\treturn getchar();\n#endif\n}\ntemplate<typename Tp> bool get1(Tp &x)\n{\n\tbool neg = 0;\n\tchar c = gc();\n\twhile( c != EOF && (c < '0' || c > '9') && c != '-' ) c = gc();\n\tif(c == '-') c = gc(), neg = 1;\n\tif(c == EOF) return false;\n\tx = 0;\n\tfor(; c>='0' && c<='9'; c = gc()) x = x*10 + c - '0';\n\tif(neg) x = -x;\n\treturn true;\n}\ntemplate<typename Tp> void printendl(Tp x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tstatic short a[40], sz;\n\tsz = 0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n\tputs(\"\");\n}\n} // namespace IO\nusing IO::get1;\nusing IO::printendl;\n#define get2(x,y) get1(x) && get1(y)\n#define get3(x,y,z) get2(x,y) && get1(z)\n#define get4(x,y,z,w) get3(x,y,z) && get1(w)\n#define pb push_back\n#define mp std::make_pair\n#define ff first\n#define ss second\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef std::pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\nconst LL Linf = 1ll<<61;\n\nconst int maxn = 100111;\nconst int mod = 998244353;\nconst int val = 1000000000000000000ll % mod;\nint qpow(int x, int y)\n{\n\tint ret = 1;\n\twhile(y)\n\t{\n\t\tif(y&1) ret = 1ll * ret * x % mod;\n\t\tx = 1ll * x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ret;\n}\n\n//Fast Walsh transform : used in xor-convolution\nvoid FWT(int *a, int n)\n{\n\tint sz = (1<<n);\n\tfor(int k=1; k<sz; k<<=1)\n\t{\n\t\tfor(int i=0; i<sz; i+=(k<<1))for(int j=0; j<k; j++)\n\t\t{\n\t\t\tregister int u=a[i+j], v=a[i+j+k];\n\t\t\ta[i+j]=u+v;if(a[i+j]>=mod)a[i+j]-=mod;\n\t\t\ta[i+j+k]=u-v;if(a[i+j+k]<0)a[i+j+k]+=mod;\n\t\t}\n\t}\n}\nvoid iFWT(int *a,int n)\n{\n\tFWT(a,n);\n\tint inv = qpow((mod+1)/2,n);\n\tfor(int i=0; i<(1<<n); i++) a[i] = 1ll*a[i]*inv % mod;\n}\n\nint n, power[maxn];\nstruct graph\n{\n\tint sg[maxn], m;\n\tstd::vector<int> g[maxn];\n\tvoid init(int *a)\n\t{\n\t\tget1(m);\n\t\tfor(int i=1, u, v; i<=m; i++)\n\t\t{\n\t\t\tget2(u, v);\n\t\t\tif(u > v) std::swap(u, v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tfor(int i=n; i>=1; i--)\n\t\t{\n\t\t\tstd::set<int> qq;\n\t\t\tfor(auto v:g[i]) qq.insert(sg[v]);\n\t\t\twhile(qq.count(sg[i])) sg[i]++;\n\t\t\ta[sg[i]] = (a[sg[i]] + power[i]) % mod;\n\t\t}\n\t}\n};\ngraph G1, G2, G3;\nint a[1<<17], b[1<<17], c[1<<17];\nint main()\n{\n\tpower[0] = 1;\n\tfor(int i=1; i<maxn; i++) power[i] = 1ll * val * power[i-1] % mod;\n\tget1(n);\n\tG1.init(a);\n\tG2.init(b);\n\tG3.init(c);\n\tFWT(a, 17);\n\tFWT(b, 17);\n\tfor(int i=0; i<(1<<17); i++) a[i] = 1ll * a[i] * b[i] % mod;\n\tiFWT(a, 17);\n\tint ans = 0;\n\tfor(int i=0; i<=n; i++) ans = (ans + 1ll * a[i] * c[i]) % mod;\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <set>\n#include <queue>\n#define MOD 998244353\n\nstruct str{\n\tint x0;\n\tint y0;\n\tint z0;\n\tlong long int value;\n};\nbool operator<(str a, str b)\n{\n\treturn a.x0+a.y0+a.z0>b.x0+b.y0+b.z0;\n}\nstd::priority_queue<str> Q;\nint a;\nlong long int power(long long int a, long long int b)\n{\n\tlong long int s = 1;\n\tlong long int t = a;\n\twhile(b)\n\t{\n\t\tif(b%2==1) s *= t, s%=MOD;\n\t\tt*=t, t%=MOD;\n\t\tb/=2;\n\t}\n\treturn s;\n}\n\nstd::vector<int> ans[5];\nstd::set<int> V[5][100010];\nint check[100010];\nstd::pair<int,int> edge[5][100010];\nvoid func(int C)\n{\n\tstd::vector<int> V2,V3,V4;\n\tfor(int i=a;i>=1;i--) V2.push_back(i);\n\twhile(V2.size()>0)\n\t{\n\t\tV4.clear();\n\t\tV3.clear();\n\t\tfor(int i=0;i<V2.size();i++) check[V2[i]] = 0;\n\t\tfor(int i=0;i<V2.size();i++)\n\t\t{\n\t\t\tif(check[V2[i]]==0)\n\t\t\t{\n\t\t\t\tcheck[V2[i]] = 1;\n\t\t\t\tV4.push_back(V2[i]);\n\t\t\t\tstd::set<int> ::iterator it;\n\t\t\t\tfor(it=V[C][V2[i]].begin();it!=V[C][V2[i]].end();it++)\n\t\t\t\t{\n\t\t\t\t\tint v;\n\t\t\t\t\tif(edge[C][*it].first!=V2[i]) v = edge[C][*it].first;\n\t\t\t\t\telse v = edge[C][*it].second;\n\t\t\t\t\tcheck[v] = 1;\n\t\t\t\t\tV[C][v].erase(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse V3.push_back(V2[i]);\n\t\t}\n\t\t\n\t\tlong long int sum = 0;\n\t\tfor(int i=0;i<V4.size();i++)\n\t\t{\n\t\t\tsum += power(10,18*V4[i]);\n\t\t\tsum %= MOD;\n\t\t}\n\t\tans[C].push_back(sum);\n\t\t\n\t\tV2.clear();\n\t\tV2 = V3;\n\t}\n}\n\nint check1[510][510],check2[510][510],check3[510][510];\nint main()\n{\n\tint b,c,d;\n\tscanf(\"%d\",&a);\n\tscanf(\"%d\",&b);\n\tfor(int i=1;i<=b;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tedge[1][i] = std::make_pair(s,t);\n\t\tV[1][s].insert(i);\n\t\tV[1][t].insert(i);\n\t}\n\tscanf(\"%d\",&c);\n\tfor(int i=1;i<=c;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tedge[2][i] = std::make_pair(s,t);\n\t\tV[2][s].insert(i);\n\t\tV[2][t].insert(i);\n\t}\n\tscanf(\"%d\",&d);\n\tfor(int i=1;i<=d;i++)\n\t{\n\t\tint s,t;\n\t\tscanf(\"%d%d\",&s,&t);\n\t\tedge[3][i] = std::make_pair(s,t);\n\t\tV[3][s].insert(i);\n\t\tV[3][t].insert(i);\n\t}\n\tfunc(1);\n\tfunc(2);\n\tfunc(3);\n\t\n\tlong long int sum = 0;\n\tfor(int i=0;i<ans[1].size()+ans[2].size()-1;i++)\n\t{\n\t\tfor(int j=0;j<ans[1].size();j++)\n\t\t{\n\t\t\t//j, i-j\n\t\t\tif(i-j<0) continue;\n\t\t\tif(i-j>=ans[2].size()) continue;\n\t\t\tfor(int k=0;k<ans[3].size();k++)\n\t\t\t{\n\t\t\t\tif(check1[j][k]) continue;\n\t\t\t\tif(check2[i-j][k]) continue;\n\t\t\t\tlong long int s = ans[1][j];\n\t\t\t\ts *= ans[2][i-j], s%=MOD;\n\t\t\t\ts *= ans[3][k], s %= MOD;\n\t\t\t\tsum +=s, sum%=MOD;\n\t\t\t\tcheck1[j][k] = check2[i-j][k] = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long\n//#define MOD 1000000007\n#define MOD 998244353\n\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\n//const int mod = 1000000007;\nconst int mod = 998244353;\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n\nstd::vector<std::vector<int>> iig(int vn, int en) { \n        std::vector<std::vector<int>> res(vn); \n        for(int i = 0; i < en; i++) { \n                int s, t; \n                std::cin >> s >> t; \n                s--; t--; \n\t\tif (s > t) swap(s, t);\n                res[t].push_back(s); \n        } \n        return res; \n}\n\nstd::vector<int> assign_grundy(std::vector<std::vector<int>>& dg) {\n\tint gsize = dg.size();\n\tstd::vector<int> incomings(gsize);\n\tfor(int i = 0; i < gsize; i++) {\n\t\tfor(int j: dg[i]) {\n\t\t\tincomings[j]++;\n\t\t}\n\t}\n\tstd::vector<int> vs_ready;\n\tfor(int i = 0; i < gsize; i++) {\n\t\tif (incomings[i] == 0) vs_ready.push_back(i);\n\t}\n\tstd::vector<std::set<int>> prohibited_grundy(gsize);\n\tstd::vector<int> grundy(gsize);\n\twhile(!vs_ready.empty()) {\n\t\tint i = vs_ready.back();\n\t\tvs_ready.pop_back();\n\t\tint g = 0;\n\t\tfor(int pg: prohibited_grundy[i]) {\n\t\t\tif (g == pg) g++;\n\t\t\telse break;\n\t\t}\n\t\tgrundy[i] = g;\n\t\tfor(int j: dg[i]) {\n\t\t\tprohibited_grundy[j].insert(g);\n\t\t\tif ((--incomings[j]) == 0) vs_ready.push_back(j);\n\t\t}\n\t}\n\treturn grundy;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n;\n\tcin >> m;\n\tauto g1 = iig(n, m);\n\tcin >> m;\n\tauto g2 = iig(n, m);\n\tcin >> m;\n\tauto g3 = iig(n, m);\n\t// assume that each edge direction is reversed\n\tauto grn1 = assign_grundy(g1);\n\tauto grn2 = assign_grundy(g2);\n\tauto grn3 = assign_grundy(g3);\t\n\t// gmax * (gmax + 1) <= E * 2\n\n\tvector<mint> w(n + 1);\n\tmint step = mint(10).pow(18);\n\tw[0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tw[i] = w[i-1] * step;\n\t}\n\n\tvector<mint> gcount1(500), gcount2(500), gcount3(500);\n\tfor(int i = 0; i < n; i++) {\n\t\tgcount1[grn1[i]] += w[i+1];\n\t\tgcount2[grn2[i]] += w[i+1];\n\t\tgcount3[grn3[i]] += w[i+1];\n\t}\n\n\tmint res = 0;\n\n\tfor(int i = 0; i < 500; i++)\n\t\tfor(int j = 0; j < 500; j++) {\n\t\t\tint k = i ^ j;\n\t\t\tres += gcount1[i] * gcount2[j] * gcount3[k];\n\t\t}\n\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ff first\n#define ss second\n#define pii pair<int, int>\n#define pb emplace_back\n#define pf emplace_front\n#define mp make_pair\n#define ld long double\n#define all(x) x.begin(), x.end()\n#define uniq(x) sort(all(x)), x.resize(unique(all(x)) - x.begin())\n\n//random_device rd;\n//mt19937_64 gen(rd());\n//\n//template<typename T>\n//T rand(T l, T r) {\n//    uniform_int_distribution<T> uid(l, r);\n//    return uid(gen);\n//}\n\nconst int maxn = 1e5 + 9;\nvector<int> g[3][maxn];\nint c[3][maxn];\nint n;\nint mod = 998244353;\nint p[maxn];\nvector<int> w[3];\nint ans;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    p[0] = 1;\n    p[1] = ((int)1e18) % mod;\n    for (int i = 2; i < maxn; i++)\n        p[i] = (p[i - 1] * p[1]) % mod;\n    cin >> n;\n    for (int j = 0; j < 3; j++)\n    {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++)\n        {\n            int a, b;\n            cin >> a >> b;\n            a--, b--;\n            g[j][a].pb(b);\n            g[j][b].pb(a);\n        }\n        int kek = 0;\n        int t = 0;\n        while (kek != n)\n        {\n            t++;\n            for (int i = n - 1; i >= 0; i--)\n            {\n                if (c[j][i])\n                    continue;\n                bool fl = 0;\n                for (int to : g[j][i])\n                {\n                    if (c[j][to] == t)\n                        fl = 1;\n                }\n                if (!fl)\n                {\n                    c[j][i] = t;\n                    if (w[j].size() < t + 1)\n                        w[j].resize(t + 1, 0);\n                    w[j][t] = (w[j][t] + p[i + 1]) % mod;\n                    kek++;\n                }\n            }\n        }\n//        for (int i = 0; i < n; i++)\n//            cout << c[j][i] << \" \";\n//        cout << \"\\n\";\n    }\n    vector<vector<int> > q;\n    for (int a = 0; a < 3; a++)\n        for (int b = 0; b < 3; b++)\n            for (int c = 0; c < 3; c++)\n    {\n        if (a != b && b != c && a != c)\n        {\n            vector<int> cur = {a, b, c};\n            q.pb(cur);\n        }\n    }\n    set<pii> used;\n    int sz = max(max(w[0].size(), w[1].size()), w[2].size());\n    for (int a = 1; a < sz; a++)\n    {\n        for (int b = 1; b <= a; b++)\n        {\n            if (used.find(mp(a, b)) != used.end())\n                continue;\n            for (int c = 1; c <= b; c++)\n            {\n                if (used.find(mp(a, c)) != used.end())\n                    continue;\n                if (used.find(mp(b, c)) != used.end())\n                    continue;\n\n                set<vector<int> > U;\n                bool fl = 0;\n                for (auto u : q)\n                {\n                    vector<int> polina;\n                    for (int r = 0; r < 3; r++)\n                    {\n                        if (u[r] == 0)\n                            polina.pb(a);\n                        else if (u[r] == 1)\n                            polina.pb(b);\n                        else\n                            polina.pb(c);\n                    }\n                    if (U.find(polina) != U.end())\n                        continue;\n                    U.insert(polina);\n                    int cur = 1;\n                    bool fll = 1;\n\n                    if ((int)w[0].size() > polina[0])\n                        cur = (cur * w[0][polina[0]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[1].size() > polina[1])\n                        cur = (cur * w[1][polina[1]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[2].size() > polina[2])\n                        cur = (cur * w[2][polina[2]]) % mod;\n                    else\n                        fll = 0;\n\n                    if (fll)\n                    {\n                        ans = (ans + cur) % mod;\n                        fl = 1;\n                    }\n                }\n                if (fl)\n                {\n//                    cout << a << \" \" << b << \" \" << c << \"\\n\";\n                    used.emplace(a, b);\n                    used.emplace(a, c);\n                    used.emplace(b, c);\n                }\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100100,mod=998244353;\ninline void Add(int &a,int b){a=a+b>=mod?a+b-mod:a+b;}\ninline int ksm(int a,int b)\n{\n\tint res=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) res=1ll*res*a%mod;\n\treturn res;\n}\nint N;\nstruct Graph\n{\n\tvector<int> V[maxn];int M,sg[maxn],sum[512];\n\tinline void read()\n\t{\n\t\tscanf(\"%d\",&M);\n\t\tfor(int i=1,A,B;i<=M;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&A,&B);\n\t\t\tif(A>B) swap(A,B);\n\t\t\tV[A].push_back(B);\n\t\t}\n\t}\n\tinline void Getsg()\n\t{\n\t\tfor(int i=N;i;i--)\n\t\t{\n\t\t\tset<int> S;\n\t\t\tfor(int j=0;j<(int)V[i].size();j++) S.insert(sg[V[i][j]]);\n\t\t\twhile(S.count(sg[i])) sg[i]++;\n\t\t\tAdd(sum[sg[i]],ksm(10,i*18));\n\t\t}\n\t}\n}G[3];\nint main()\n{\n\tscanf(\"%d\",&N);\n\tG[0].read();G[1].read();G[2].read();\n\tG[0].Getsg();G[1].Getsg();G[2].Getsg();\n\tint ans=0;\n\tfor(int A=0;A<512;A++) for(int B=0;B<512;B++)\n\t\tAdd(ans,1ll*G[0].sum[A]*G[1].sum[B]%mod*G[2].sum[A^B]%mod);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long int\nstatic const long MOD = 998244353;\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n    for (int t = 0; t < 3; t++) {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            if (x > y) swap(x, y);\n            g[t][x].push_back(y);\n        }\n    }\n    vector<vector<int>> gr(3, vector<int>(n));\n    int mx = 0;\n    for (int t = 0; t < 3; t++) {\n        vector<int> z(n + 1);\n        int zz = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            zz++;\n            for (int j : g[t][i]) {\n                z[gr[t][j]] = zz;\n            }\n            while (z[gr[t][i]] == zz) gr[t][i]++;\n            mx = max(mx, gr[t][i]);\n        }\n    }\n    vector<vector<long>> ss(3, vector<long>(mx + 1));\n    vector<long> pw(n + 1);\n    pw[0] = 1;\n    for (int i = 0; i < n; i++) {\n        pw[i + 1] = pw[i] * 716070898 % MOD;\n    }\n    for (int t = 0; t < 3; t++) {\n        for (int i = 0; i < n; i++) {\n            ss[t][gr[t][i]] += pw[i + 1];\n            ss[t][gr[t][i]] %= MOD;\n        }\n    }\n    long res = 0;\n    for (int i = 0; i <= mx; i++) {\n        for (int j = 0; j <= mx; j++) {\n            long s = ss[0][i];\n            s *= ss[1][j];\n            s %= MOD;\n            s *= ss[2][i ^ j];\n            s %= MOD;\n            res += s;\n            res %= MOD;\n        }\n    }\n    cout << res << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 998244353;\nconst int N = 1e5 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nvector<ll> G[N];\n\nll n, mex[N], ps[N], cnt[4][N];\nset<ll> st;\nll Solve(int idx){\n\tll m;\n\tcin >> m;\n\tfor(int i = 1; i <= n; i++) G[i].clear();\n\t//memset(mk, 0, sizeof mk);\n\tll u, v;\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> u >> v;\n\t\tG[u].pb(v);\n\t\tG[v].pb(u);\n\t}\n\tll ans = 0;\n\tfor(int i = n; i >= 1; i--){\n\t\tmex[i] = 0;\n\t\tst.clear();\n\t\tfor(auto adj : G[i]) if(adj > i) st.insert(mex[adj]);\n\t\tfor(auto x : st) if(x == mex[i]) mex[i] ++;\n\t\t(cnt[idx][mex[i]] += ps[i]) %= Mod;\n\t}\n\treturn ans % Mod;\n}\nll mul(ll a, ll b){\n\treturn (a * b) % Mod;\n}\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll X = 716070898;\n\tps[0] = 1;\n\tfor(int i = 1; i < N; i++) ps[i] = (ps[i - 1] * X) % Mod;\n\tcin >> n;\n\tll res = 0;\n\tfor(int i = 0; i < 3; i++) Solve(i);\n\tfor(int i = 0; i < 1000; i++){\n\t\tfor(int j = 0; j < 1000; j++) res += mul(cnt[0][i], mul(cnt[1][j], cnt[2][i ^ j]));\n\n\t}\ncout << res % Mod << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long int\nstatic const long MOD = 998244353;\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n    for (int t = 0; t < 3; t++) {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            if (x > y) swap(x, y);\n            g[t][x].push_back(y);\n        }\n    }\n    vector<vector<int>> gr(3, vector<int>(n));\n    int mx = 0;\n    for (int t = 0; t < 3; t++) {\n        vector<int> z(n + 1);\n        int zz = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            zz++;\n            for (int j : g[t][i]) {\n                z[gr[t][j]] = zz;\n            }\n            while (z[gr[t][i]] == zz) gr[t][i]++;\n            mx = max(mx, gr[t][i]);\n        }\n    }\n    vector<vector<long>> ss(3, vector<long>(mx + 1));\n    vector<long> pw(n + 1);\n    pw[0] = 1;\n    for (int i = 0; i < n; i++) {\n        pw[i + 1] = pw[i] * 716070898 % MOD;\n    }\n    for (int t = 0; t < 3; t++) {\n        for (int i = 0; i < n; i++) {\n            ss[t][gr[t][i]] += pw[i + 1];\n            ss[t][gr[t][i]] %= MOD;\n        }\n    }\n    long res = 0;\n    for (int i = 0; i <= mx; i++) {\n        for (int j = 0; j <= mx; j++) {\n            if ((i ^ j) >= mx) continue;\n            long s = ss[0][i];\n            s *= ss[1][j];\n            s %= MOD;\n            s *= ss[2][i ^ j];\n            s %= MOD;\n            res += s;\n            res %= MOD;\n        }\n    }\n    cout << res << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ███▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓╬╬╬╬╬╬▓█\n// ███▓███████▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▓▓▓█▓╬╬╬▓█\n// ███████▓█████▓▓╬╬╬╬╬╬╬╬▓███▓╬╬╬╬╬╬╬▓╬╬▓█\n// ████▓▓▓▓╬╬▓█████╬╬╬╬╬╬███▓╬╬╬╬╬╬╬╬╬╬╬╬╬█\n// ███▓▓▓▓╬╬╬╬╬╬▓██╬╬╬╬╬╬▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬╬╬╬▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓███████▓▓███▓╬╬╬╬╬╬▓███████▓╬╬╬╬▓█\n// ████████████████▓█▓╬╬╬╬╬▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬█\n// ███▓▓▓▓▓▓▓╬╬▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬▓▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓▓█▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓██▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// █████▓▓▓▓▓████▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓█▓▓▓▓██▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓▓███▓▓▓▓▓▓▓██▓╬╬╬╬╬╬╬╬╬╬╬╬█▓╬▓╬╬▓██\n// █████▓███▓▓▓▓▓▓▓▓████▓▓╬╬╬╬╬╬╬█▓╬╬╬╬╬▓██\n// █████▓▓█▓███▓▓▓████╬▓█▓▓╬╬╬▓▓█▓╬╬╬╬╬╬███\n// ██████▓██▓███████▓╬╬╬▓▓╬▓▓██▓╬╬╬╬╬╬╬▓███\n// ███████▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬████\n// ███████▓▓██▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓████\n// ████████▓▓▓█████▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█████\n// █████████▓▓▓█▓▓▓▓▓███▓╬╬╬╬╬╬╬╬╬╬╬▓██████\n// ██████████▓▓▓█▓▓▓╬▓██╬╬╬╬╬╬╬╬╬╬╬▓███████\n// ███████████▓▓█▓▓▓▓███▓╬╬╬╬╬╬╬╬╬▓████████\n// ██████████████▓▓▓███▓▓╬╬╬╬╬╬╬╬██████████\n// ███████████████▓▓▓██▓▓╬╬╬╬╬╬▓███████████\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst int M = 998244353;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n//#define LOCAL\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nlong long pw(long long a, long long b){\n  long long t=1;\n  while(b){\n    if(b&1){\n      t = t * a % M;\n    }\n    a = a * a % M;\n    b >>= 1;\n  }\n  return t;\n}\n\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0);\n\n\t// total O(M)\n\tint n, m;\n\tcin>>n;\n\tint u, v;\n  vector<vector<vector<int>>> mex;\n\n  vector<int> p(3);\n\n  vector<vector<int>> g(n, vector<int>());\n  vector<int> rk(n);\n\n\n  for(int j=0;j<3;j++){\n    for(int i=0;i<n;i++){\n      g[i].clear();\n    }\n    cin>>m;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      u--,v--;\n      if(u>v){\n        swap(u,v);\n      }\n      g[u].push_back(v);\n    }\n\n//    debug(g);\n    mex.push_back(vector<vector<int>>());\n\n    for(int i=n-1;i>=0;i--){\n      int num=0;\n      vector<int> nums;\n      for(int j : g[i]){\n        nums.push_back(rk[j]);\n      }\n      sort(nums.begin(),nums.end());\n//      debug(nums);\n      for(int j : nums){\n        if(num == j){\n          num++;\n        } else{\n          break;\n        }\n      }\n      if(num == mex[j].size()){\n        mex[j].push_back(vector<int>());\n      }\n      mex[j][num].push_back(i);\n      rk[i]=num;\n    }\n    p[j]=mex[j].size();\n  }\n\n  debug(mex);\n\n  long long ans=0;\n  for(int i=0;i<p[0];i++)\n  for(int j=0;j<p[1];j++){\n    int k=i^j;\n    if(k>=p[2])continue;\n    if(mex[0][i].size()==0)continue;\n    if(mex[1][j].size()==0)continue;\n    if(mex[2][k].size()==0)continue;\n    //i,j,k\n    long long sum=0, tmp=1;\n//    debug(mex[0][i]);\n    for(int a1 : mex[0][i]){\n      sum = sum + tmp * pw(10, (a1+1) * 18) % M;\n      sum %= M;\n    }\n    tmp = sum;\n\n    sum = 0 ;\n\n//    debug(mex[1][j]);\n    for(int a2 : mex[1][j]){\n      sum = sum + tmp * pw(10, (a2+1) * 18) % M;\n      sum %= M;\n    }\n    tmp = sum;\n\n    sum = 0;\n//    debug(mex[2][k]);\n\n    for(int a3 : mex[2][k]){\n      sum = sum + tmp * pw(10, (a3+1) * 18) % M;\n      sum %= M;\n    }\n//    debug(sum);\n    ans = ans + sum;\n    ans %= M;\n  }\n  debug(ans);\n  cout << ans << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=100005;\nconst int mod=998244353;\nnamespace {\n    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}\n    inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}\n    inline int Mul(int x,int y) {return 1ll*x*y%mod;}\n    inline int Pow(int x,int y=mod-2){if(y==0)return 1;int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}\n}\nint n,m;\nvector<int> G[max_n];\nvector<int> solve(vector<int> a,vector<int> b){\n    vector<int> c;\n    c.assign(1024,0);\n    for(int i=0;i<1024;i++){\n        for(int j=0;j<1024;j++)c[i^j]=Add(c[i^j],Mul(a[i],b[j]));\n    }\n    return c;\n}\nint p[max_n];\nint sg[max_n];\nint SG(int u){\n    if(~sg[u])return sg[u];\n    set<int> s;\n    for(auto v:G[u]){\n        if(v>u)s.insert(SG(v));\n    }\n    for(int i=0;;i++)if(s.count(i)==0)return i;\n}\nint main(){\n    p[0]=1,p[1]=Pow(10,18);\n    for(int i=2;i<1024;i++)p[i]=Mul(p[i-1],p[1]);\n    scanf(\"%d\",&n);\n    vector<int> f;f.assign(1024,0);f[0]=1;\n    vector<int> a;\n    scanf(\"%d\",&m);\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    //for(int i=n;i>=1;i--)\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    printf(\"%d\\n\",f[0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int mod=998244353;\nint n,pw[300005];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nstruct Graph{\n\tint m,sg[100005],vis[100005],val[100005];\n\tvector<int> E[100005];\n\tvoid dfs(int u){\n\t\tfor(int v:E[u])if(!~sg[v])dfs(v);\n\t\tfor(int v:E[u])vis[sg[v]]=1;\n\t\tsg[u]=0;\n\t\twhile(vis[sg[u]])++sg[u];\n\t\tfor(int v:E[u])vis[sg[v]]=0;\n\t}\n\tvoid calSG(){\n\t\tmemset(sg,-1,sizeof sg);\n\t\tREP(i,1,n)if(!~sg[i])dfs(i);\n\t\tREP(i,1,n)inc(val[sg[i]],pw[i]);\n\t}\n} G[3];\n\nint main(){\n\t// freopen(\"in.in\",\"r\",stdin);\n\tint b=((ll)1e18)%mod;\n\tREP(i,pw[0]=1,300001)pw[i]=1ll*pw[i-1]*b%mod;\n\tn=read();\n\tREP(t,0,2){\n\t\tG[t].m=read();\n\t\tREP(i,1,G[t].m){\n\t\t\tint u=read(),v=read();\n\t\t\tif(u>v)swap(u,v);\n\t\t\tG[t].E[u].pb(v);\n\t\t}\n\t\tG[t].calSG();\n\t}\n\tint ans=0;\n\tREP(a,0,sqrt(G[0].m)*2)REP(b,0,sqrt(G[1].m)*2){\n\t\tint c=a^b;\n\t\tinc(ans,1ll*G[0].val[a]*G[1].val[b]%mod*G[2].val[c]%mod);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\nint read();\nint n;\nint m1, m2, m3;\nvoid Add(int& x, int y) { (x += y) >= mod ? x -= mod : x; }\n\nvector<int> e[3][100005];\nvoid add(int f, int t, int d) { e[d][f].push_back(t), e[d][t].push_back(f); }\nint sg[3][100005];\nvector<int> nx[100005];\nvoid solve(int d) {\n    for (int i = 1; i <= n; ++i) nx[i].clear();\n    for (int u = n; u >= 1; --u) {\n        sort(nx[u].begin(), nx[u].end());\n        for (int v : nx[u]) {\n            if (sg[d][u] == v) sg[d][u]++;\n            if (sg[d][u] < v) break;\n        }\n        for (int v : e[d][u]) nx[v].push_back(sg[d][u]);\n    }\n}\n\nint fsp(int base, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = 1ll * rt * base % mod;\n        base = 1ll * base * base % mod, p >>= 1;\n    }\n    return rt;\n}\nint M(int x) { return x + (x >> 31 & mod); }\nstruct Poly {\n    int x[300005];\n    int& operator[](int p) { return x[p]; }\n    void fwt(int len) {\n        for (int l = 2; l <= len; l <<= 1)\n            for (int i = 0, m = l >> 1; i < len; i += l)\n                for (int j = i, t; j < i + m; ++j)\n                    t = x[j + m], x[j + m] = M(x[j] - t), Add(x[j], t);\n    }\n} F[3];\n\nint main() {\n    n = read(), m1 = read();\n    for (int i = 1; i <= m1; ++i) add(read(), read(), 0);\n    m2 = read();\n    for (int i = 1; i <= m2; ++i) add(read(), read(), 1);\n    m3 = read();\n    for (int i = 1; i <= m3; ++i) add(read(), read(), 2);\n    for (int i = 0; i < 3; ++i) {\n        solve(i);\n        for (int j = 1, t = 1, p = fsp(10, 18); j <= n; ++j)\n            t = 1ll * t * p % mod, Add(F[i][sg[i][j]], t);\n    }\n    int len = 1;\n    while (len <= n) len <<= 1;\n    F[0].fwt(len), F[1].fwt(len), F[2].fwt(len);\n    for (int i = 0; i < len; ++i)\n        F[0][i] = 1ll * F[0][i] * F[1][i] % mod * F[2][i] % mod;\n\n    F[0].fwt(len);\n    printf(\"%d\\n\", 1ll * F[0][0] * fsp(len, mod - 2) % mod);\n    return 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 33; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long mod = 998244353;\nlong long N;\nlong long M1, A1[1 << 18], B1[1 << 18]; vector<int> X1[1 << 18];\nlong long M2, A2[1 << 18], B2[1 << 18]; vector<int> X2[1 << 18];\nlong long M3, A3[1 << 18], B3[1 << 18]; vector<int> X3[1 << 18];\nlong long C1[1 << 18], cnt1[1 << 18];\nlong long C2[1 << 18], cnt2[1 << 18];\nlong long C3[1 << 18], cnt3[1 << 18];\n\nint main() {\n\tcin >> N;\n\tcin >> M1; for (int i = 1; i <= M1; i++) cin >> A1[i] >> B1[i];\n\tcin >> M2; for (int i = 1; i <= M2; i++) cin >> A2[i] >> B2[i];\n\tcin >> M3; for (int i = 1; i <= M3; i++) cin >> A3[i] >> B3[i];\n\tfor (int i = 1; i <= M1; i++) { if (A1[i] > B1[i]) swap(A1[i], B1[i]); X1[A1[i]].push_back(B1[i]); }\n\tfor (int i = 1; i <= M2; i++) { if (A2[i] > B2[i]) swap(A2[i], B2[i]); X2[A2[i]].push_back(B2[i]); }\n\tfor (int i = 1; i <= M3; i++) { if (A3[i] > B3[i]) swap(A3[i], B3[i]); X3[A3[i]].push_back(B3[i]); }\n\tfor (int i = N; i >= 1; i--) {\n\t\tbool cp[500]; for (int j = 0; j < 500; j++) cp[j] = false;\n\t\tfor (int j : X1[i]) { cp[C1[j]] = true; }\n\t\tfor (int j = 0; j < 500; j++) { if (cp[j] == true) continue; C1[i] = j; break; }\n\t\tcnt1[C1[i]] += modpow(10, 18 * i, mod);\n\t\tcnt1[C1[i]] %= mod;\n\t}\n\tfor (int i = N; i >= 1; i--) {\n\t\tbool cp[500]; for (int j = 0; j < 500; j++) cp[j] = false;\n\t\tfor (int j : X2[i]) { cp[C2[j]] = true; }\n\t\tfor (int j = 0; j < 500; j++) { if (cp[j] == true) continue; C2[i] = j; break; }\n\t\tcnt2[C2[i]] += modpow(10, 18 * i, mod);\n\t\tcnt2[C2[i]] %= mod;\n\t}\n\tfor (int i = N; i >= 1; i--) {\n\t\tbool cp[500]; for (int j = 0; j < 500; j++) cp[j] = false;\n\t\tfor (int j : X3[i]) { cp[C3[j]] = true; }\n\t\tfor (int j = 0; j < 500; j++) { if (cp[j] == true) continue; C3[i] = j; break; }\n\t\tcnt3[C3[i]] += modpow(10, 18 * i, mod);\n\t\tcnt3[C3[i]] %= mod;\n\t}\n\n\tlong long Answer = 0;\n\tfor (int i = 0; i < 500; i++) {\n\t\tfor (int j = 0; j < 500; j++) {\n\t\t\tAnswer += (cnt1[i] * cnt2[j] % mod) * cnt3[i ^ j] % mod;\n\t\t\tAnswer %= mod;\n\t\t}\n\t}\n\tcout << Answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nvoid exgcd(int a, int b, int& x, int& y) {\n\tif (!b) {\n\t\tx = 1, y = 0;\n\t} else {\n\t\texgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}\n}\n\nint inv(int a, int n) {\n\tint x, y;\n\texgcd(a, n, x, y);\n\treturn (x < 0) ? (x + n) : (x);\n}\n\nconst int Mod = 998244353;\n\ntemplate <const int Mod = :: Mod>\nclass Z {\n\tpublic:\n\t\tint v;\n\n\t\tZ() : v(0) {\t}\n\t\tZ(int x) : v(x){\t}\n\t\tZ(ll x) : v(x % Mod) {\t}\n\n\t\tfriend Z operator + (const Z& a, const Z& b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = a.v + b.v) >= Mod) ? (x - Mod) : (x));\n\t\t}\n\t\tfriend Z operator - (const Z& a, const Z& b) {\n\t\t\tint x;\n\t\t\treturn Z(((x = a.v - b.v) < 0) ? (x + Mod) : (x));\n\t\t}\n\t\tfriend Z operator * (const Z& a, const Z& b) {\n\t\t\treturn Z(a.v * 1ll * b.v);\n\t\t}\n\t\tfriend Z operator ~(const Z& a) {\n\t\t\treturn inv(a.v, Mod);\n\t\t}\n\t\tfriend Z operator - (const Z& a) {\n\t\t\treturn Z(0) - a;\n\t\t}\n\t\tZ& operator += (Z b) {\n\t\t\treturn *this = *this + b;\n\t\t}\n\t\tZ& operator -= (Z b) {\n\t\t\treturn *this = *this - b;\n\t\t}\n\t\tZ& operator *= (Z b) {\n\t\t\treturn *this = *this * b;\n\t\t}\n\t\tfriend bool operator == (const Z& a, const Z& b) {\n\t\t\treturn a.v == b.v;\n\t\t} \n};\n\nZ<> qpow(Z<> a, int p) {\n\tZ<> rt = Z<>(1), pa = a;\n\tfor ( ; p; p >>= 1, pa = pa * pa) {\n\t\tif (p & 1) {\n\t\t\trt = rt * pa;\n\t\t}\n\t}\n\treturn rt;\n}\n\ntypedef Z<> Zi;\n\nconst int N = 1e5 + 5;\n\nZi base (1000000000000000000ll);\nZi pw[N];\n\nvoid init_pw(int n) {\n\tpw[0] = 1;\n\tpw[1] = base;\n\tfor (int i = 2; i <= n; i++) {\n\t\tpw[i] = pw[i - 1] * base;\n\t}\n}\n\nint n;\n\ntypedef class Graph {\n\tpublic:\n\t\tbitset<512> vis;\n\t\tint SG[N];\n    Zi buk[512];\n    vector<int> G[N];\n\n\t\tZi* solve() {\n      int u, v, m;\n      scanf(\"%d\", &m);\n\t\t\twhile (m--) {\n\t\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\t  if (u > v) {\n          swap(u, v);\n        }\n        G[u].push_back(v);\n      }\n      for (int i = n; i; i--) {\n        for (auto e : G[i]) {\n          vis.set(SG[e]);\n        }\n        while (vis.test(SG[i]))\n          SG[i]++;\n        for (auto e : G[i]) {\n          vis.reset(SG[e]);\n        }\n      }\n      for (int i = 1; i <= n; i++) {\n        buk[SG[i]] += pw[i];\n      }\n      return buk;\n\t\t}\n} Graph;\n\nGraph g1, g2, g3;\n\nvoid fwt(Zi* f, int n) {\n  int N = 1 << n;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < N; j++) {\n      if ((j >> i) & 1) {\n        Zi a = f[j ^ (1 << i)], b = f[j];\n        f[j ^ (1 << i)] = a + b;\n        f[j] = a - b;\n      }\n    }\n  }\n}\nvoid ifwt(Zi* f, int n) {\n  fwt(f, n);\n  int N = 1 << n;\n  Zi invlen = ~Zi(N);\n  for (int i = 0; i < N; i++) {\n    f[i] *= invlen;\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  init_pw(n);\n  Zi* b1 = g1.solve();\n  Zi* b2 = g2.solve();\n  Zi* b3 = g3.solve();\n  fwt(b1, 9);\n  fwt(b2, 9);\n  fwt(b3, 9);\n  for (int i = 0; i < 512; i++) {\n    b1[i] = b1[i] * b2[i] * b3[i];\n  }\n  ifwt(b1, 9);\n  printf(\"%d\\n\", b1->v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline int fastpo(int x, int n, int mod) {\n\tint res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\n\nconst int N = 100033;\nconst int LOG = 20;\nconst int mod = 998244353;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nvector<int> e[N];\nint vst[N], par[N];\nstruct M {\n\tLL a;\n\tM operator + (const M & b) const {\n\t\tM res;\n\t\tres.a = a + b.a;\n\t\tif(res.a >= mod) res.a -= mod;\n\t\treturn res;\n\t}\n\tM operator * (const M & b) const {\n\t\treturn M{a * b.a % mod};\n\t}\n};\nM s[3][3];\nM pw[N];\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tpw[0] = M{1};\n\tint bs = 1000000000000000000ll % mod;\n\tfor(int i = 1; i <= n; i++) pw[i] = pw[i - 1] * M{bs};\n\tfor(int d = 0; d < 3; d++) {\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i = 1; i <= n; i++) e[i].clear();\n\t\tfor(int i = 1; i <= m; i++) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tif(y < x) swap(x, y);\n//\t\t\te[x].push_back(y);\n\t\t\te[y].push_back(x);\n\t\t}\n\t\tmemset(vst, 0, sizeof(vst));\n\t\tmemset(par, 0, sizeof(par));\n\t\tfor(int i(n); i >= 1; i--) {\n\t\t\t/*if(vst[i]) continue;\n\t\t\tstatic vector<int> q;\n\t\t\tq.clear();\n\t\t\tvst[i] = 1;\n\t\t\tq.push_back(i);\n\t\t\tpar[i] = 0;\n\t\t\tfor(int op = 0; op < (int)q.size(); op++) {\n\t\t\t\tint v = q[op];\n\t\t\t\ts[d][par[v]] = s[d][par[v]] + pw[v];\n\t\t\t\tfor(int y : e[v]) {\n\t\t\t\t\tif(!vst[y]) {\n\t\t\t\t\t\tvst[y] = 1;\n\t\t\t\t\t\tpar[y] = par[v] ^ 1;\n\t\t\t\t\t\tq.push_back(y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tint v = i;\n\t\t\tif(vst[i] == 0 || vst[i] == 2){\n\t\t\t\tpar[i] = 0;\n\t\t\t}else if(vst[i] == 1) {\n\t\t\t\tpar[i] = 1;\n\t\t\t}else {\n\t\t\t\tpar[i] = 2;\n\t\t\t}\n\t\t\tif(par[i] !=  2) {\n\t\t\t\ts[d][par[v]] = s[d][par[v]] + pw[v];\n\t\t\t\tfor(int y : e[v]) {\n\t\t\t\t\tvst[y] |= 1 << par[v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tM ans{0};\n\tfor(int i = 0; i < 2; i++) {\n\t\tfor(int j = 0; j < 2; j++) {\n\t\t\tfor(int k = 0; k < 2; k++) {\n\t\t\t\tif((i + j + k) % 2 == 0) {\n\t\t\t\t\tans = ans + s[0][i] * s[1][j] * s[2][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans.a << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  vector< int > rev, rts;\n  int base, max_base, root;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n};\n\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vec d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,3100000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        D1[d1[i]] += P[i];\n        for(auto e:g1[i]){\n            if(d1[e]==d1[i])d1[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D2[d2[i]]+=P[i];\n        for(auto e:g2[i]){\n            if(d2[e]==d2[i])d2[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D3[d3[i]]+=P[i];\n        for(auto e:g3[i]){\n            if(d3[e]==d3[i])d3[e]++;\n        }\n    }\n    vec a,b;\n    mint ans;\n    ans+=D1[0]*D2[0]*D3[0];\n    rep(i,n){\n        ans+=D1[i]*D2[i+1]*D3[i+1];\n        ans+=D1[i+1]*D2[i]*D3[i+1];\n        ans+=D1[i+1]*D2[i+1]*D3[i];\n        D1[i+1]+=D1[i];\n        D2[i+1]+=D2[i];\n        D3[i+1]+=D3[i];\n    }\n\n\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 998244353;\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 1 << 17;\n\nint mex (const vector<int> &v) {\n  set<int> sp;\n  for (int i = 0; i < (int) v.size() + 1; i++) {\n    sp.insert(i);\n  }\n\n  for (auto u : v) {\n    sp.erase(u);\n  }\n\n  return *sp.begin();\n}\n\nModint p1e18 [MAX_N];\n\nclass Graph {\n  int n;\n  vector<vector<int>> adj;\n\npublic:\n  Graph (int _n) : n(_n), adj(vector<vector<int>> (n + 1, vector<int> (0))) {}\n\n  void add_edge (int u, int v) {\n    if (u > v) swap(u, v);\n    adj[u].push_back(v);\n  }\n\n  vector<Modint> summary () {\n    vector<int> grundy (n + 1);\n    for (int u = n; u >= 1; u--) {\n      vector<int> v;\n      for (int nxt : adj[u]) {\n        v.push_back(grundy[nxt]);\n      }\n      grundy[u] = mex(v);\n    }\n\n    vector<Modint> ans (MAX_N, Modint(0));\n    for (int u = 1; u <= n; u++) {\n      ans[grundy[u]] += p1e18[u];\n    }\n    return ans;\n  }\n};\n\nvoid FST (vector<Modint> &a, bool invert) {\n  for (int n = (int) a.size(), step = 1; step < n; step *= 2) {\n    for (int i = 0; i < n; i += 2 * step) {\n      for (int j = i; j < i + step; j++) {\n        Modint &u = a[j], &v = a[j + step];\n        tie(u, v) = make_pair(u + v, u - v);\n      }\n    }\n  }\n\n  if (invert) {\n    Modint div = inv(Modint((int) a.size()));\n    for (int i = 0; i < (int) a.size(); i++) {\n      a[i] *= div;\n    }\n  }\n}\n\nvector<Modint> conv (vector<Modint> a, vector<Modint> b) {\n  FST(a, 0);\n  FST(b, 0);\n  for (int i = 0; i < (int) a.size(); i++) {\n    a[i] *= b[i];\n  }\n  FST(a, 1);\n  return a;\n}\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  p1e18[0] = 1;\n  Modint bas = exp(Modint(10), 18);\n  for (int i = 1; i < MAX_N; i++) {\n    p1e18[i] = p1e18[i - 1] * bas;\n  }\n\n  int n;\n  cin >> n;\n\n  Graph g1 (n);\n  int m1;\n  cin >> m1;\n  for (int i = 0; i < m1; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    g1.add_edge(u, v);\n  }\n  vector<Modint> a1 = g1.summary();\n\n  Graph g2 (n);\n  int m2;\n  cin >> m2;\n  for (int i = 0; i < m2; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    g2.add_edge(u, v);\n  }\n  vector<Modint> a2 = g2.summary();\n\n  Graph g3 (n);\n  int m3;\n  cin >> m3;\n  for (int i = 0; i < m3; i++) {\n    int u, v;\n    cin >> u >> v;\n\n    g3.add_edge(u, v);\n  }\n  vector<Modint> a3 = g3.summary();\n\n  vector<Modint> a1a2 = conv(a1, a2);\n  vector<Modint> ans = conv(a1a2, a3);\n\n  cout << ans[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int N = 3e5 + 1, mod = 998244353;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nstruct edge {\n\tint x, y, next;\n} e[N * 2]; int cnt, last[N];\nint n, v[N], z[N];\nint y[3][N];\nLL A[N * 2], B[N * 2], C[N * 2], D[N * 2];\nint R[N * 2];\n\nLL pow_mod(LL a, LL k) {\n\tLL ans = 1;\n\tk %= (mod - 1);\n\twhile(k) {\n\t\tif(k & 1) (ans *= a) %= mod;\n\t\t(a *= a) %= mod; k /= 2;\n\t} return ans;\n}\n\nvoid NTT(LL y[], int len, int on) {\n\tfor(int i = 0; i < len; i++) if(i < R[i]) swap(y[i], y[R[i]]);\n\tfor(int i = 1; i < len; i *= 2) {\n\t\tLL wn = pow_mod(3, (LL)(mod - 1) / (i * 2)); if(on == -1) wn = pow_mod(wn, mod - 2);\n\t\tfor(int j = 0; j < len; j += i * 2) {\n\t\t\tLL w = 1;\n\t\t\tfor(int k = 0; k < i; k++, (w *= wn) %= mod) {\n\t\t\t\tLL u = y[j + k], v = y[j + k + i] * w % mod;\n\t\t\t\ty[j + k] = (u + v) % mod, y[j + k + i] = (u - v + mod) % mod;\n\t\t\t}\n\t\t}\n\t} if(on == -1) {\n\t\tLL gg = pow_mod(len, mod - 2);\n\t\tfor(int i = 0; i < len; i++) (y[i] *= gg) %= mod;\n\t}\n}\n\nI void ins(cr x, cr y) {e[++cnt] = edge{x, y, last[x]}, last[x] = cnt;}\n\nvoid dfs(cr x, cr o) {\n\tv[x] = 1, z[x] = o;\n\tfor(reg k = last[x]; k; k = e[k].next) {\n\t\treg y = e[k].y;\n\t\tif(!v[y]) dfs(y, o ^ 1);\n\t}\n}\n\nint len;\n\nI void gao(cr o) {\n\treg m = read();\n\tcnt = 0, memset(last, 0, sizeof(last));\n\tfo(i, 1, m) {\n\t\treg x = read(), y = read();\n\t\tins(x, y), ins(y, x);\n\t} memset(v, 0, sizeof(v));\n\tfd(i, n, 1) if(!v[i]) dfs(i, 0);\n\tmemset(v, 0, sizeof(v));\n\tmemset(C, 0, sizeof(C)), memset(D, 0, sizeof(D));\n\tfd(i, n, 1) {\n\t\tbool h1 = 0, h2 = 0;\n\t\tfor(reg k = last[i]; k; k = e[k].next) if(v[e[k].y]){\n\t\t\tif(z[e[k].y]) h2 |= 1;\n\t\t\tif(!z[e[k].y]) h1 |= 1;\n\t\t} if(h1 && h2) continue; v[i] = 1;\n\t\tif(!z[i]) C[i] = 1;\n\t\telse D[i] = 1;\n\t}\n\tNTT(C, len, 1), NTT(D, len, 1);\n\tfo(i, 0, len - 1) {\n\t\treg a = A[i], b = B[i], c = C[i], d = D[i];\n\t\tA[i] = ((LL)a * c % mod + (LL)b * d) % mod;\n\t\tB[i] = ((LL)a * d % mod + (LL)b * c) % mod;\n\t}\n}\n\nint main() {\n\tn = read();\n\tlen = 1;\n\tfor(; len <= n * 3; len <<= 1);\n\tfo(i, 0, len - 1) R[i] = (R[i >> 1] >> 1) | ((i & 1) * (len >> 1));\n\tfo(i, 0, len - 1) A[i] = 1;\n\tgao(0), gao(1), gao(2);\n\tNTT(A, len, -1);\n\treg s = 1, w = pow_mod(10, 18), ans = 0;\n\tfo(i, 1, 3 * n) {\n\t\ts = (LL)s * w % mod;\n\t\tans = (ans + (LL)s * A[i]) % mod;\n\t} pr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 0;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  vector<long long> ary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    set<int> usable;\n    for(int i = 1; i<N+1; ++i) {\n      usable.insert(i);\n    }\n    while(!usable.empty()) {\n      set<int> u = usable;\n      long long curr = 0;\n      while(!u.empty()) {\n        auto it = u.end();\n        it--;\n        int next = *it;\n        curr = (curr + pows[next]) % MOD;\n        for(int i = 0; i<adj[next].size(); ++i) {\n          u.erase(adj[next][i]);\n        }\n        u.erase(next);\n        usable.erase(next);\n      }\n      ary[graph].push_back(curr);\n    }\n  }\n\n  ret = ((ary[0][0] * ary[1][0]) % MOD) * ary[2][0];\n  ret = (ret % MOD);\n  for(int i = 1; i<min(ary[0].size(), ary[1].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0];\n    ret = (ret + add) % MOD;\n  }\n  for(int i = 1; i<min(ary[0].size(), ary[2].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][i] * ary[1][0])%MOD) * ary[2][i];\n    ret = (ret + add) % MOD;\n  }\n  for(int i = 1; i<min(ary[1].size(), ary[2].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n    ret = (ret + add) % MOD;\n  }\n\n  for(int i = 1; i<ary[0].size(); ++i) {\n    set<int> kk;\n    for(int k = 1; k<ary[2].size(); ++k) kk.insert(k);\n    for(int j = 1; j<ary[1].size(); ++j) {\n      for(auto k : kk) {\n        if(i == j || j == k || i ==k) continue;\n        long long add = ((ary[0][i] * ary[1][j]) % MOD) * ary[2][k];\n        ret = (ret + add) % MOD;\n        kk.erase(k);\n        break;\n      }\n    }\n  }\n\n  /*\n  for(int i = 0; i<min(min(ary[0].size(), ary[1].size()), ary[2].size()); ++i) {\n    long long add = 0;\n    if(i == 0) {\n      add = ((ary[0][i] * ary[1][i]) % MOD) * ary[2][i];\n    }\n    else {\n      //add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0] + ((ary[0][i] * ary[1][0])%MOD) * ary[2][i] + ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n      add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][i-1] + ((ary[0][i] * ary[1][i-1])%MOD) * ary[2][i] + ((ary[0][i-1] * ary[1][i])%MOD) * ary[2][i];\n    }\n    ret = (ret + add) % MOD;\n  }\n  */\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 1e5 + 10, mod = 998244353, lim = 1 << 10;\n\nint n, m;\nint ans[maxN + 1], g[maxN + 1], pw[maxN + 1];\nint flag[maxN + 1], t[maxN + 1], s[maxN + 1];\nbool vis[maxN + 1];\n\nvector<int> nxt[maxN + 1];\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\ninline int read()\n{\n\tint num = 0, f = 1;\n\tchar ch = getchar();\n\twhile( !isdigit( ch ) ) { if(ch == '-') f = -1; ch = getchar(); }\n\twhile( isdigit( ch ) ) num = (num << 3) + (num << 1) + (ch ^ 48), ch = getchar();\n\treturn num * f;\n}\n\ninline void dfs(int u)\n{\n\tvis[u] = true;\n\tfor(int i = 0; i < nxt[u].size(); i++) \n\t\tif(!vis[ nxt[u][i] ]) dfs(nxt[u][i]);\n\tfor(int i = 0; i < nxt[u].size(); i++) flag[ g[ nxt[u][i] ] ] = u;\n\n\tg[u] = 0;\n\twhile(flag[ g[u] ] == u) g[u] ++;\n}\n\ninline void work()\n{\n\tm = read();\n\tfor(int i = 1; i <= n; i++) vis[i] = false, nxt[i].clear();\n\tfor(int i = 0; i < lim; i++) flag[i] = s[i] = 0;\n\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint x = read(), y = read();\n\t\tif(x > y) swap(x, y);\n\t\tnxt[x].push_back(y);\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(!vis[i]) dfs(i);\n\t\n\tfor(int i = 1; i <= n; i++) s[ g[i] ] = ADD(s[ g[i] ], pw[i]);\n\n\tfor(int i = 0; i < lim; i++) t[i] = ans[i], ans[i] = 0;\n\tfor(int i = 0; i < lim; i++)\n\t\tfor(int j = 0; j < lim; j++)\n\t\t\tans[i ^ j] = ADD(ans[i ^ j], 1ll * t[i] * s[j] % mod);\n}\n\nint main()\n{\n\tint base = 1;\n\tfor(int i = 1; i <= 18; i++) base = 10ll * base % mod;\n\n\tn = read();\n\tpw[0] = 1;\n\tfor(int i = 1; i <= n; i++) pw[i] = 1ll * base * pw[i - 1] % mod;\n\t\n\tans[0] = 1;\n\tfor(int i = 1; i <= 3; i++) work();\n\n\tprintf(\"%d\", ans[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 998244353;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\ntypedef struct UnionFind_ {\n  vector<int> par, rank_, siz;\n  UnionFind_(){}\n  explicit UnionFind_(int n): rank_(n, 0), siz(n, 1) {\n    par.resize(n);\n    for(int i = 0; i < n; i++)par[i] = i;\n  }\n  int find(int x) {\n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n  }\n  bool same(int x, int y) {\n    if(find(x) == find(y))return true;\n    else return false;\n  }\n  bool unite(int x, int y){\n    int xp = find(x);\n    int yp = find(y);\n    if(xp == yp)return false;\n    if(rank_[xp] > rank_[yp]){\n      par[yp] = xp;\n      siz[xp] += siz[yp];\n    }\n    else if(rank_[xp] < rank_[yp]){\n      par[xp] = yp;\n      siz[yp] += siz[xp];\n    }\n    else {\n      par[yp] = xp;\n      siz[xp] += siz[yp];\n      rank_[xp]++;\n    }\n    return true;\n  }\n  int size(int i){\n    return siz[find(i)];\n  }\n} UnionFind;\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)(res * curr % mod);\n    }\n    curr = (T)(curr * curr % mod);\n    tmp >>= 1;\n  }\n\n  return res;\n}\n\nvector<int> edge1[100010], edge2[100010], edge3[100010];\nint n, m1, m2, m3;\n\nint main(int argc, char const* argv[])\n{\n  cin >> n >> m1;\n  UnionFind uf1(n), uf2(n), uf3(n);\n  rep(i, m1){\n    int u, v; cin >> u >> v, u--, v--;\n    uf1.unite(u, v);\n    edge1[u].pb(v);\n    edge1[v].pb(u);\n  }\n  cin >> m2;\n  rep(i, m2){\n    int u, v; cin >> u >> v, u--, v--;\n    uf2.unite(u, v);\n    edge2[u].pb(v);\n    edge2[v].pb(u);\n  }\n  cin >> m3;\n  rep(i, m3){\n    int u, v; cin >> u >> v, u--, v--;\n    uf3.unite(u, v);\n    edge3[u].pb(v);\n    edge3[v].pb(u);\n  }\n  vector<vector<int>> v1(n), v2(n), v3(n);\n  vector<bool> used1(n, false);\n  vector<bool> used2(n, false);\n  vector<bool> used3(n, false);\n  vector<bool> ued1(n, false);\n  vector<bool> ued2(n, false);\n  vector<bool> ued3(n, false);\n  rep(i, n)v1[uf1.find(i)].pb(i);\n  rep(i, n)v2[uf2.find(i)].pb(i);\n  rep(i, n)v3[uf3.find(i)].pb(i);\n  ll res11 = 0, res12 = 0;\n  rep(i, n){\n    if(sz(v1[i]) == 0)continue;\n    sort(whole(v1[i])); reverse(whole(v1[i]));\n    for(auto e: v1[i]){\n      bool ok = true;\n      for(auto e1: edge1[e]){\n        if(used1[e1])ok = false;\n      }\n      if(ok){\n        used1[e] = true;\n        (res11 += power<ll>(10, (ll)18 * (e + 1), mod)) %= mod;\n      }\n    }\n    for(auto e: v1[i]){\n      if(used1[e])continue;\n      bool ok = true;\n      for(auto e1: edge1[e]){\n        if(ued1[e1])ok = false;\n      }\n      if(ok){\n        ued1[e] = true;\n        (res12 += power<ll>(10, (ll)18 * (e + 1), mod)) %= mod;\n      }\n    }\n  }\n  ll res21 = 0, res22 = 0;\n  rep(i, n){\n    if(sz(v2[i]) == 0)continue;\n    sort(whole(v2[i])); reverse(whole(v2[i]));\n    for(auto e: v2[i]){\n      bool ok = true;\n      for(auto e2: edge2[e]){\n        if(used2[e2])ok = false;\n      }\n      if(ok){\n        used2[e] = true;\n        (res21 += power<ll>(10, (ll)18 * (e + 1), mod)) %= mod;\n      }\n    }\n    for(auto e: v2[i]){\n      if(used2[e])continue;\n      bool ok = true;\n      for(auto e2: edge2[e]){\n        if(ued2[e2])ok = false;\n      }\n      if(ok){\n        ued2[e] = true;\n        (res22 += power<ll>(10, (ll)18 * (e + 1), mod)) %= mod;\n      }\n    }\n  }\n  ll res31 = 0, res32 = 0;\n  rep(i, n){\n    if(sz(v3[i]) == 0)continue;\n    sort(whole(v3[i])); reverse(whole(v3[i]));\n    for(auto e: v3[i]){\n      bool ok = true;\n      for(auto e3: edge3[e]){\n        if(used3[e3])ok = false;\n      }\n      if(ok){\n        used3[e] = true;\n        (res31 += power<ll>(10, (ll)18 * (e + 1), mod)) %= mod;\n      }\n    }\n    for(auto e: v3[i]){\n      if(used3[e])continue;\n      bool ok = true;\n      for(auto e3: edge3[e]){\n        if(ued3[e3])ok = false;\n      }\n      if(ok){\n        ued3[e] = true;\n        (res32 += power<ll>(10, (ll)18 * (e + 1), mod)) %= mod;\n      }\n    }\n  }\n  ll res = 0;\n  /*\n  cerr << res11 << \" \" << res12 << endl;\n  cerr << res21 << \" \" << res22 << endl;\n  cerr << res31 << \" \" << res32 << endl;\n  */\n  (res += (res11 * (res21 * res31 % mod) % mod)) %= mod;\n  (res += (res11 * (res22 * res32 % mod) % mod)) %= mod;\n  (res += (res12 * (res22 * res31 % mod) % mod)) %= mod;\n  (res += (res12 * (res21 * res32 % mod) % mod)) %= mod;\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ri register int\nusing namespace std;\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef vector<int> poly;\n#define pb push_back\nconst int rlen=1<<18|1,inf=0x3f3f3f3f;\nconst ll Inf=1e18;\nchar buf[rlen],*ib=buf,*ob=buf;\n#define gc() (((ib==ob)&&(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)\ninline int read() {\n  int ans=0;\n  bool f=1;\n  char ch=gc();\n  while(!isdigit(ch)) f^=ch=='-',ch=gc();\n  while(isdigit(ch)) ans=((ans<<2)+ans<<1)+(ch^48),ch=gc();\n  return f?ans:-ans;\n}\ninline ll readl() {\n  ll ans=0;\n  bool f=1;\n  char ch=gc();\n  while(!isdigit(ch)) f^=ch=='-',ch=gc();\n  while(isdigit(ch)) ans=((ans<<2)+ans<<1)+(ch^48),ch=gc();\n  return f?ans:-ans;\n}\ninline int Read(char*s) {\n  int tp=0;\n  char ch=gc();\n  while(!isdigit(ch)&&!isalpha(ch)) ch=gc();\n  while(isdigit(ch)||isalpha(ch)) s[++tp]=ch,ch=gc();\n  return tp;\n}\nnamespace modular {\n  const int mod=998244353,iv2=(mod+1)>>1;\n  inline int add(int a,int b) { return a+b<mod?a+b:a+b-mod; }\n  inline int dec(int a,int b) { return a<b?a-b+mod:a-b; }\n  inline int mul(int a,int b) { return (ll)a*b%mod; }\n  inline void Add(int&a,int b) { a=a+b<mod?a+b:a+b-mod; }\n  inline void Dec(int&a,int b) { a=a<b?a-b+mod:a-b; }\n  inline void Mul(int&a,int b) { a=(ll)a*b%mod; }\n  inline int ksm(int a,int p) { int ret=1;for(;p;p>>=1,Mul(a,a)) (p&1)&&(Mul(ret,a),1);return ret; }\n  inline int Inv(int a) { return ksm(a,mod-2); }\n  inline int sqr(int a) { return mul(a,a); }\n  inline int cub(int a) { return (ll)a*a%mod*a%mod; }\n}\nusing namespace modular;\ntemplate<typename T> inline void ckmax(T&a,T b) { a<b?a=b:0; }\ntemplate<typename T> inline void ckmin(T&a,T b) { a>b?a=b:0; }\ntemplate<typename T> inline T gcd(T a,T b) { T t;while(b)t=a,a=b,b=t-t/a*a;return a; }\ntemplate<typename T> inline T Abs(T x) { return x<0?-x:x; }\nconst int N=1e6+5,lm=1<<10;\nvector<int>e[N];\nbool vs[lm+5];\nint n,m,sg[N],pw[N],f[lm+5],g[3][lm+5];\ninline void fwt(int*a,int typ) {\n  for(ri i=1,a0,a1;i<lm;i<<=1) for(ri j=0;j<lm;j+=i<<1) for(ri k=0;k<i;++k) {\n    a0=a[j+k],a1=a[j+k+i];\n    a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1);\n    if(typ==-1) Mul(a[j+k],iv2),Mul(a[j+k+i],iv2);\n  }\n}\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\",\"r\",stdin);\n  #endif\n  n=read(),pw[0]=1,pw[1]=Inf%mod;\n  for(ri i=2;i<=n;++i) pw[i]=mul(pw[i-1],pw[1]);\n  for(ri tt=0;tt<3;++tt) {\n    m=read();\n    for(ri i=1;i<=n;++i) e[i].clear(),sg[i]=0;\n    for(ri i=1,u,v;i<=m;++i) {\n      u=read(),v=read();\n      e[min(u,v)].pb(max(u,v));\n    }\n    for(ri i=n;i;--i) {\n      for(ri j=0;j<e[i].size();++j) vs[sg[e[i][j]]]=1;\n      for(sg[i]=0;vs[sg[i]];++sg[i]);\n      Add(g[tt][sg[i]],pw[i]);\n      for(ri j=0;j<e[i].size();++j) vs[sg[e[i][j]]]=0;\n    }\n    fwt(g[tt],1);\n  }\n  for(ri i=0;i<lm;++i) f[i]=mul(mul(g[0][i],g[1][i]),g[2][i]);\n  fwt(f,-1);\n  cout<<f[0];\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\ntemplate <int32_t P>\nstruct ModInt_t {\n  int32_t value;\n\n  static_assert(P < (1 << 30) - 1, \"2xP must fit into 32-bit signed integer\");\n\n  ModInt_t() : value{0} {};\n\n  explicit ModInt_t(int32_t v) : value(v) {\n    if (value >= P || value <= -P) value %= P;\n    if (value < 0) value += P;\n  };\n\n  explicit operator bool() const { return value != 0; }\n  explicit operator int32_t() const { return value; }\n\n  ModInt_t& operator+=(const ModInt_t& other) {\n    value += other.value;\n    if (value >= P) value -= P;\n    return *this;\n  }\n\n  ModInt_t& operator-=(const ModInt_t& other) {\n    value -= other.value;\n    if (value < 0) value += P;\n    return *this;\n  }\n\n  ModInt_t& operator*=(const ModInt_t& other) {\n    int64_t result = static_cast<int64_t>(value) * other.value;\n    value = static_cast<int32_t>(result % P);\n    return *this;\n  }\n\n  static ModInt_t inverse(ModInt_t x) { return ModInt_t{inverse(x.value)}; }\n\n private:\n  static int32_t inverse(int32_t a) {\n    int32_t b = P, x = 1, y = 0;\n    while (b != 0) {\n      auto k = a / b;\n      a -= k * b;\n      std::swap(a, b);\n      x -= k * y;\n      std::swap(x, y);\n    }\n    assert(a == 1);\n    if (x < 0) x += P;\n    return x;\n  }\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator+(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res += b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator-(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res -= b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator*(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res *= b;\n};\n\ntemplate <int32_t P>\nbool operator==(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  return a.value == b.value;\n};\n\ntemplate <int32_t P>\nstd::ostream& operator<<(std::ostream& os, const ModInt_t<P>& a) {\n  os << a.value;\n  return os;\n}\n\ntemplate <typename T>\nstruct MulMonoid {\n  using value_type = T;\n  constexpr static T identity() { return T{1}; }\n  constexpr static T op(const T& a, const T& b) { return a * b; }\n};\n\ntemplate <typename T, typename U, typename Monoid = MulMonoid<T>>\nT power(T a, U n) {\n  T r{Monoid::identity()};\n  while (n > 0) {\n    if (n % 2) r = Monoid::op(r, a);\n    a = Monoid::op(a, a);\n    n /= 2;\n  }\n  return r;\n}\n\nusing ModInt = ModInt_t<998244353>;\n\nconst int L = 512;\n\nvector<ModInt> read(int N) {\n  int M;\n  cin >> M;\n  vector<vector<int>> E(N);\n  for (int i = 0; i < M; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    E[a].push_back(b);\n    E[b].push_back(a);\n  }\n\n  vector<int> g(N);\n\n  for (int x = N - 1; x >= 0; --x) {\n    set<int> S;\n    for (int y : E[x])\n      if (y > x) S.insert(g[y]);\n    for (g[x] = 0; S.count(g[x]); g[x]++)\n      ;\n  }\n\n  vector<ModInt> ret(L);\n  for (int i = 0; i < N; ++i) {\n    ModInt w = power(ModInt{10}, 18 * (i + 1));\n    ret[g[i]] += w;\n  }\n  return ret;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n\n  auto A = read(N);\n  auto B = read(N);\n  auto C = read(N);\n\n  ModInt ret{0};\n  for (int x = 0; x < L; ++x) {\n    for (int y = 0; y < L; ++y) {\n      int z = x ^ y;\n      ret += A[x] * B[y] * C[z];\n    }\n  }\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst ll M=100;\nconst ll val=(1000000000000000000)%mod;\nint n;\nint tmp[100000][M];\n\nvvi f(){\n\tvvi g(n);\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tg[u].push_back(v);\n\t}\n\treturn g;\n}\n\nint main(){\n\tcin>>n;\n\tvvi g1=f(),g2=f(),g3=f();\n\tvi used(n),gra(n);\n\tvl c,cost(M);\n\twhile(used!=vi(n,1)){\n\t\tvi b(n);\n\t\tfor(int i=n-1;i>=0;i--) if(!used[i]){\n\t\t\tbool flag=1;\n\t\t\tfor(auto j:g1[i]) if(b[j]) flag=0;\n\t\t\tif(flag){\n\t\t\t\tb[i]++;\n\t\t\t\tused[i]++;\n\t\t\t}\n\t\t}\n\t\tll t=1,s=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t(t*=val)%=mod;\n\t\t\t(s+=t*b[i])%=mod;\n\t\t}\n\t\tc.push_back(s);\n\t}\n\tfor(int i=0;i<M;i++){\n\t\ttmp[n-1][i]=1;\n\t\tvi a(n);\n\t\ta[n-1]=i;\n\t\tfor(int j=n-2;j>=0;j--){\n\t\t\tfor(auto k:g2[j]) tmp[j][a[k]]++;\n\t\t\tfor(int k=0;k<M;k++) if(!tmp[j][k]){\n\t\t\t\ttmp[j][k]++;\n\t\t\t\ta[j]=k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(auto k:g2[j]) tmp[j][a[k]]--;\n\t\t}\n\t\tll t=1;\n\t\tfor(int j=0;j<n;j++){\n\t\t\t(t*=val)%=mod;\n\t\t\tif(a[j]<c.size()) (cost[i]+=c[a[j]]*t)%=mod;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=0;i--){\n\t\tset<int> st;\n\t\tfor(auto j:g3[i]) st.insert(gra[j]);\n\t\tfor(int j=0;;j++) if(st.find(j)==st.end()){\n\t\t\tgra[i]=j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tll t=1,res=0;\n\tfor(int i=0;i<n;i++){\n\t\t(t*=val)%=mod;\n\t\t(res+=cost[gra[i]]*t)%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nconstexpr int MOD = 998244353;\nusing mint = ModInt<MOD>;\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nvoid brute() {\n    int n;\n    std::cin >> n;\n\n    std::vector<mint> tens(n + 1);\n    {\n        mint ten = 1;\n        for (int i = 0; i < 18; ++i) ten *= 10;\n\n        tens[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            tens[i] = tens[i - 1] * ten;\n        }\n    }\n\n    std::vector<Graph<>> graphs(3);\n    std::vector<mint> iss, dss;\n    for (auto& graph : graphs) {\n        graph.resize(n);\n\n        int m;\n        std::cin >> m;\n\n        while (m--) {\n            int u, v;\n            std::cin >> u >> v;\n            --u, --v;\n            graph[u].emplace_back(u, v);\n            graph[v].emplace_back(v, u);\n        }\n    }\n\n    mint ans = 0;\n    auto used = vec(n, vec(n, vec(n, false)));\n    for (int s = (n - 1) * 3; s >= 0; --s) {\n        for (int i = 0; i < n && i <= s; ++i) {\n            for (int j = 0; j < n && i + j <= s; ++j) {\n                int k = s - i - j;\n                if (k >= n || used[i][j][k]) continue;\n\n                std::cerr << i + 1 << \" \" << j + 1 << \" \" << k + 1 << std::endl;\n                ans += tens[i + 1] * tens[j + 1] * tens[k + 1];\n\n                for (auto e : graphs[0][i]) {\n                    used[e.dst][j][k] = true;\n                }\n                for (auto e : graphs[1][j]) {\n                    used[i][e.dst][k] = true;\n                }\n                for (auto e : graphs[2][k]) {\n                    used[i][j][e.dst] = true;\n                }\n            }\n        }\n    }\n    std::cout << ans << std::endl;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<mint> tens(n + 1);\n    {\n        mint ten = 1;\n        for (int i = 0; i < 18; ++i) ten *= 10;\n\n        tens[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            tens[i] = tens[i - 1] * ten;\n        }\n    }\n\n    std::vector<Graph<>> graphs(3);\n    std::vector<std::vector<mint>> iss;\n    for (auto& graph : graphs) {\n        graph.resize(n);\n\n        int m;\n        std::cin >> m;\n\n        while (m--) {\n            int u, v;\n            std::cin >> u >> v;\n            --u, --v;\n            graph[u].emplace_back(u, v);\n            graph[v].emplace_back(v, u);\n        }\n\n        std::vector<bool> used(n, false);\n        iss.push_back(std::vector<mint>());\n\n        while (std::any_of(used.begin(), used.end(), [](auto b) { return !b; })) {\n            std::vector<bool> out = used;\n            mint score = 0;\n            for (int v = n - 1; v >= 0; --v) {\n                if (out[v]) continue;\n\n                used[v] = true;\n                score += tens[v + 1];\n                for (auto e : graph[v]) {\n                    out[e.dst] = true;\n                }\n            }\n\n            iss.back().push_back(score);\n        }\n    }\n\n    auto dp = vec(iss[0].size(), vec(iss[1].size(), vec(iss[2].size(), true)));\n    mint ans = 0;\n    for (int i = 0; i < (int)iss[0].size(); ++i) {\n        for (int j = 0; j < (int)iss[1].size(); ++j) {\n            for (int k = 0; k < (int)iss[2].size(); ++k) {\n                if (!dp[i][j][k]) continue;\n                ans += iss[0][i] * iss[1][j] * iss[2][k];\n\n                for (int l = i; l < (int)iss[0].size(); ++l) {\n                    dp[l][j][k] = false;\n                }\n                for (int l = j; l < (int)iss[1].size(); ++l) {\n                    dp[i][l][k] = false;\n                }\n                for (int l = k; l < (int)iss[2].size(); ++l) {\n                    dp[i][j][l] = false;\n                }\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    // brute();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nint LOG;\nclass Hadamard\n{\npublic:\n\tll d[2][1 << 19];\n\tvector<ll>conv(vector<ll>v)\n\t{\n\t\tfor (int i = 0; i < v.size(); i++)d[0][i] = v[i];\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < LOG; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < (1 << LOG); j += (1 << (LOG - i)))\n\t\t\t{\n\t\t\t\tint s = 1 << (LOG - i - 1);\n\t\t\t\tfor (int k = 0; k < s; k++)d[1 - cur][j + k] = (d[cur][j + k] + d[cur][j + s + k]) % mod, d[1 - cur][j + s + k] = d[cur][j + s + k];\n\t\t\t}\n\t\t\tcur = 1 - cur;\n\t\t}\n\t\tfor (int i = LOG - 1; i >= 0; i--)\n\t\t{\n\t\t\tfor (int j = 0; j < (1 << LOG); j += (1 << (LOG - i)))\n\t\t\t{\n\t\t\t\tint s = 1 << (LOG - i - 1);\n\t\t\t\tfor (int k = 0; k < s; k++)d[1 - cur][j + k] = d[cur][j + k], d[1 - cur][j + s + k] = (d[cur][j + k] + mod + mod - d[cur][j + s + k] * 2) % mod;\n\t\t\t}\n\t\t\tcur = 1 - cur;\n\t\t}\n\t\tvector<ll>r;\n\t\tfor (int i = 0; i < (1 << LOG); i++)r.push_back(d[cur][i]);\n\t\treturn r;\n\t}\n};\nHadamard had;\nvector<int>pat[3][101010];\nint gr[101010];\nll p10[555555];\nvector<ll>calc(int t, int n)\n{\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tint s = 0;\n\t\tvector<int>f;\n\t\tf.resize(pat[t][i].size() + 3);\n\t\tfor (int j = 0; j < pat[t][i].size(); j++)\n\t\t{\n\t\t\tint v = pat[t][i][j];\n\t\t\tf[gr[v]] = 1;\n\t\t}\n\t\tfor (int j = 0; j < f.size(); j++)\n\t\t{\n\t\t\tif (f[j] == 0)\n\t\t\t{\n\t\t\t\tgr[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ll>r;\n\tr.resize(2000);\n\tfor (int i = 0; i < n; i++)r[gr[i]] = (r[gr[i]] + p10[i + 1]) % mod;\n\treturn r;\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tint w;\n\t\tscanf(\"%d\", &w);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tint za, zb;\n\t\t\tscanf(\"%d%d\", &za, &zb);\n\t\t\tza--, zb--;\n\t\t\tif (za > zb)swap(za, zb);\n\t\t\tpat[i][za].push_back(zb);\n\t\t}\n\t}\n\tp10[0] = 1;\n\tfor (int i = 0; i < 505050; i++)p10[i + 1] = p10[i] * (1000000000000000000LL % mod) % mod;\n\t//for (int i = 0; i < 505050; i++)p10[i + 1] = p10[i] * (10LL % mod) % mod;\n\tvector<ll>v[3];\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tvector<ll>z = calc(i, num);\n\t\t//for (int k = 0; k < z.size(); k++)printf(\"%lld \", z[k]); printf(\"\\n\");\n\t\tv[i] = z;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < min(num, 1000); i++)\n\t{\n\t\tfor (int j = 0; j < min(num, 1000); j++)\n\t\t{\n\t\t\tif ((i^j) < num)\n\t\t\t{\n\t\t\t\t//printf(\"%d %d %d\\n\", i, j, i^j);\n\t\t\t\tans = (ans + v[0][i] * v[1][j] % mod*v[2][i^j]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define LL long long\n#define ULL unsigned long long \n#define y second\n#define sqr(x) ((x)*(x))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pdd pair<double,double>\n#define MEM(x) memset(x,0,sizeof(x))\n#define pi acos(-1)\n#define MEMS(x) memset(x,-1,sizeof(x))\nusing namespace std;\nint val[3][100005];\nvector<int> v[3][100005];\nvector<int> num[3][2];\nint number=716070898;\nint mod=998244353;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nint main(){ \n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 0;i<3;i++){\n        int m;\n        scanf(\"%d\",&m);\n        for(int j =0;j<m;j++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            if(x>y)swap(x,y);\n            v[i][x].pb(y);\n        }\n        for(int j = n;j>=1;j--){\n            vector<int> arr;\n            for(auto it:v[i][j]){\n                arr.pb(val[i][it]);\n            }\n            sort(arr.begin(),arr.end());\n            arr.resize(unique(arr.begin(),arr.end())-arr.begin());\n            val[i][j]=arr.size();\n            for(int k = 0;k<arr.size();k++){\n                if(arr[k]!=k){\n                    val[i][j]=k;\n                    break;\n                }\n            }\n            if(val[i][j]<2){\n                num[i][val[i][j]].pb(j);\n            }\n        }\n    }\n    LL ans=0;\n    LL val[3][2];//,b[2]={0,0},c[2]={0,0};\n    MEM(val);\n    for(int i =0;i<3;i++){\n        for(int j=0;j<2;j++){\n            for(auto it:num[i][j]){\n                val[i][j]+=f_pow(number,it);\n                val[i][j]%=mod;\n            }\n        }\n    }\n    ans+=val[0][0]*val[1][0]%mod*val[2][0]%mod;\n    ans+=val[0][0]*val[1][1]%mod*val[2][1]%mod;\n    ans+=val[0][1]*val[1][0]%mod*val[2][1]%mod;\n    ans+=val[0][1]*val[1][1]%mod*val[2][0]%mod;\n    ans%=mod;\n    printf(\"%lld\\n\",ans);\n    /*\n    for(int i = 0;i<num[0][0].size();i++){\n        a[0]+=f_pow(number,num[0][0][i]);\n        a[0]%=mod;\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][0][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][1][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][0][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][1][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }*/\n    //printf(\"%lld\\n\",ans);\n}\n/*\n\n5\nAACCMMAA\nA\nAA\nMM\nACA\nACMAA\n\n\n5\n0 9 7 1 100\n-1 0 -1 -1 91\n-1 5 0 -1 96\n-1 8 9 0 99\n-1 -1 -1 -1 0\n3 4\n3 5\n5 6\n5 7\n3 or 4\n3 or 5\n5 or 6\n5 or 7\n\ndp[x]=max(dp[x-w_i*j]+j*t_i-delta t_i*j*(j-1)/2)\ndp[x]=max(dp[j]+x*t_i-j*t_i-delta t_i*(x-j)*(x-j-1)/2)\ndp[x]=max(dp[j]-j*t_i-delta t_i *(j^2/2+j/2) - \n        delta t_i * xj + x*t_i + delta t_i * (x^2/2-x/2))\ndp[x]=max(dp[j] + g(j) - delta t_i *xj + w(i) )\ng(j)= dp[j]-j*t_i-delta t_i *(j^2/2+j/2)\nw(i)=  x*t_i + delta t_i * (x^2/2-x/2)\nx^2/2 -xj -x/2  +j^2/2 +j/2\n*/\n\n/*\n \n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 100007\n#define modp 998244353\nusing namespace std;\nint base=1;\nint n,m1,m2,m3;\nint n1,n2,n3,val1[Maxn],val2[Maxn],val3[Maxn],val[Maxn];\nvector<int> e1[Maxn],e2[Maxn],e3[Maxn];\nbool vis[Maxn],flag[Maxn];\nbool vis1[2007][2007],vis2[2007][2007],vis3[2007][2007];\nvector<pair<pair<int,int>,pair<int,int> > >v;\nvoid solve1()\n{\n    n1=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val1[++n1]=val[i];\n                } else val1[n1]=(val1[n1]+val[i])%modp;\n                for (int j=0;j<(int)e1[i].size();j++)\n                    flag[e1[i][j]]=false;\n            }\n    }\n}\nvoid solve2()\n{\n    n2=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val2[++n2]=val[i];\n                } else val2[n2]=(val2[n2]+val[i])%modp;\n                for (int j=0;j<(int)e2[i].size();j++)\n                    flag[e2[i][j]]=false;\n            }\n    }\n}\nvoid solve3()\n{\n    n3=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val3[++n3]=val[i];\n                } else val3[n3]=(val3[n3]+val[i])%modp;\n                for (int j=0;j<(int)e3[i].size();j++)\n                    flag[e3[i][j]]=false;\n            }\n    }\n}\nint main()\n{\n    for (int i=1;i<=18;i++)\n        base=(10LL*base)%modp;\n    scanf(\"%d\",&n);\n    val[0]=1;\n    for (int i=1;i<=n;i++)\n        val[i]=(1LL*val[i-1]*base)%modp;\n    scanf(\"%d\",&m1);\n    for (int i=1;i<=m1;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e1[u].push_back(v);\n        e1[v].push_back(u);\n    }\n    scanf(\"%d\",&m2);\n    for (int i=1;i<=m2;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e2[u].push_back(v);\n        e2[v].push_back(u);\n    }\n    scanf(\"%d\",&m3);\n    for (int i=1;i<=m3;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e3[u].push_back(v);\n        e3[v].push_back(u);\n    }\n    solve1();\n    solve2();\n    solve3();\n    for (int x=3;x<=n1+n2+n3;x++)\n        for (int i=1;i<=n1;i++)\n            for (int j=1;j<=n2;j++)\n            {\n                int k=x-i-j;\n                if (k>=1&&k<=n3) v.push_back(make_pair(make_pair(i+j+k,i),make_pair(j,k)));\n            }\n    int ans=0;\n    memset(vis1,true,sizeof(vis1));\n    memset(vis2,true,sizeof(vis2));\n    memset(vis3,true,sizeof(vis3));\n    for (int id=0;id<v.size();id++)\n    {\n        int i=v[id].first.second;\n        int j=v[id].second.first;\n        int k=v[id].second.second;\n        if (vis1[i][j]&&vis2[j][k]&&vis3[k][i])\n        {\n            vis1[i][j]=false;\n            vis2[j][k]=false;\n            vis3[k][i]=false;\n            int tmp=(1LL*val1[i]*val2[j])%modp;\n            tmp=(1LL*tmp*val3[k])%modp;\n            ans=(ans+tmp)%modp;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    const auto& modpow = [](unsigned long n, unsigned long b = 1, unsigned long a = 716070898) -> unsigned long {\n        unsigned long r{b % MOD};\n        while(n){\n            if(n & 1)(r *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return r;\n    };\n    unsigned long N;\n    cin >> N;\n    vector<unsigned long> indpX, indpY, indpZ;\n    for(unsigned long _{0}; _ < 3; ++_){\n        swap(indpX, indpY);\n        swap(indpZ, indpY);\n        unsigned long M;\n        cin >> M;\n        vector<vector<unsigned long>> edge(N);\n        for(unsigned long i{0}, a, b; i < M; ++i){\n            cin >> a >> b;\n            if(a < b)swap(a, b);\n            edge[--a].push_back(--b);\n        }\n        vector<unsigned long> id(N, N - 1);\n        for(unsigned long i{N}; i--; )for(const auto& j : edge[i])id[j] -= id[j] == id[i];\n        map<unsigned long, pair<unsigned long, unsigned long>> mp;\n        for(unsigned long i{0}; i < N; ++i){\n            mp[id[i]].first = i + 1;\n            (mp[id[i]].second += modpow(i + 1)) %= MOD;\n        }\n        vector<pair<unsigned long, unsigned long>> Z;\n        for(const auto& i : mp)Z.emplace_back(i.second);\n        sort(Z.begin(), Z.end(), greater<>());\n        for(const auto& i : Z)indpZ.emplace_back(i.second);\n    }\n    if(indpX.size() > indpZ.size())swap(indpX, indpZ);\n    if(indpY.size() > indpZ.size())swap(indpY, indpZ);\n    if(indpX.size() > indpY.size())swap(indpX, indpY);\n    unsigned long MX{indpX.size()}, MY{indpY.size()};\n    string al{string(MX, '1')};\n    vector<bitset<500>> usedY(MY, bitset<500>(al));\n    unsigned long ans{0};\n    for(const auto& i : indpZ){\n        bitset<500> used{al};\n        unsigned long tmp{0};\n        for(unsigned long j{0}; j < MY; ++j){\n            unsigned long k{(usedY[j] & used)._Find_first()};\n            if(k < MX){\n                used[k] = false;\n                usedY[j][k] = false;\n                tmp += indpY[j] * indpX[k] % MOD;\n            }\n        }\n        tmp %= MOD;\n        ans += i * tmp % MOD;\n    }\n    cout << ans % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*temp*/\n//\n//\n//\n//\n//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/type.hpp>\n#ifdef _DEBUG\n#include \"template.h\"\n#else\n#if __cplusplus >= 201703L\n/*Atcoderでしか使えない(c++17 && このテンプレートが使えるならAtcoder)*/\n#include <boost/sort/pdqsort/pdqsort.hpp>\n#define fast_sort boost::sort::pdqsort\n#endif\n#endif\n\n\n#ifndef _DEBUG\n#ifndef UNTITLED15_TEMPLATE_H\n#define UNTITLED15_TEMPLATE_H\n\n#ifdef _DEBUG\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#ifndef fast_sort\n#define fast_sort sort\n#endif\n\n\n//#define use_pq\n#define use_for\n#define use_for_each\n#define use_sort\n#define use_fill\n#define use_rand\n#define use_mgr\n#define use_rui\n#define use_compress\n//\n//\n//\n//\n//\n//\n#define use_pbds\n#ifdef use_pbds\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate<class T, class U, class W, class X> auto count(__gnu_pbds::gp_hash_table<T, U, W> &a, X k) { return a.find(k) != a.end(); }\n#endif\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*@formatter:off*/\n#define ll long long\nusing sig_dou = double;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define mt make_tuple\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n\n\ntemplate<class T,class U> auto max(T a, U b){return a>b ? a: b;}\ntemplate<class T,class U> auto min(T a, U b){return a<b ? a: b;}\n//optional<T>について下でオーバーロード(nullopt_tを左辺右辺について単位元として扱う)\ntemplate<class T, class U> bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U> bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\n\n//メタ系 meta\ntemplate<typename T, typename U = typename T::value_type>std::true_type value_type_tester(signed);\ntemplate<typename T>std::false_type value_type_tester(long);\n\ntemplate<typename T>struct has_value_type: decltype(value_type_tester<T>(0)){};\n\n\n//A<T>でTを返す\ntemplate<class T>using decl_t = typename T::value_type;\n//A<B<.....T>>でTを返す\ntemplate<class T, bool end = !has_value_type<T>::value> struct decl2_ {typedef T type;};\ntemplate<class T> struct decl2_<T, false> {typedef typename decl2_<decl_t<T>>::type type;};\ntemplate<class T> using decl2_t = typename decl2_<T>::type;\n//#define decl_max(a, b) decltype(max(MAX<decltype(a)>(), MAX<decltype(b)>()))\n#define is_same2(T, U) is_same<T, U>::value\ntemplate<class T>struct is_vector : std::false_type{};\ntemplate<class T>struct is_vector<std::vector<T>> : std::true_type{};\n\n//大きい型を返す max_type<int, char>::type\n//todo mintがlong long より小さいと判定されるためバグる\ntemplate<class T1, class T2, bool t1_bigger = (sizeof(T1) > sizeof(T2))>struct max_type{typedef T1 type;};\ntemplate<class T1, class T2> struct max_type<T1, T2, false>{typedef T2 type;};\n\ntemplate<class T> struct vec_rank : integral_constant<int, 0> {};\ntemplate<class T> struct vec_rank<vector<T>> : integral_constant<int, vec_rank<T>{} + 1> {};\n\n//N個のTを並べたtupleを返す\n//tuple_n<3, int>::type  tuple<int, int, int>\ntemplate<size_t N, class T, class... Arg> struct tuple_n{typedef typename tuple_n<N-1, T, T,  Arg...>::type type;};\ntemplate<class T, class...Arg> struct tuple_n<0, T, Arg...>{typedef tuple<Arg...> type;};\n\nstruct dummy_t1{};struct dummy_t2{};\nstruct dummy_t3{};struct dummy_t4{};\nstruct dummy_t5{};struct dummy_t6{};\n//template<class T, require(is_integral<T>::value)>など\n#define require_t(bo) enable_if_t<bo>* = nullptr\n\n//複数でオーバーロードする場合、引数が同じだとうまくいかないため\n//require_arg(bool, dummy_t1)\n//require_arg(bool, dummy_t2)等とする\n#define require_arg1(bo) enable_if_t<bo> * = nullptr\n#define require_arg2(bo, dummy_type) enable_if_t<bo, dummy_type> * = nullptr\n#define require_arg(...) over2(__VA_ARGS__,require_arg2,require_arg1)(__VA_ARGS__)\n//->//enable_if_tのtを書き忘れそうだから\n#define require_ret(bo, ret_type) enable_if_t<bo, ret_type>\n\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\nvoid assert2(bool b,const string& s = \"\"){    if(!b){        cerr<<s<<endl;        exit(1);/*assert(0);*/    }}\n\n//my_nulloptをあらゆる操作の単位元的な物として扱う\n//vectorの参照外時に返したり、右辺値として渡されたときに何もしないなど\nstruct my_nullopt_t {} my_nullopt;\n#define nullopt_t my_nullopt_t\n#define nullopt my_nullopt\n/*@formatter:off*/\n//値が無いときは、setを使わない限り代入できない\n//=を使っても無視される\ntemplate<class T> struct my_optional {\nprivate:\n    bool is_null;\n    T v;\npublic:\n    typedef T value_type ;\n    my_optional() : is_null(true) {}\n    my_optional(const nullopt_t&) : is_null(true) {}\n    my_optional(const T& v) : v(v), is_null(false) {}\n    bool has_value() const { return !is_null; }\n    T &value() { static string mes = \"optional has no value\";assert2(!is_null, mes);return v;}\n    const T &value() const { static string mes = \"optional has no value\";assert2(!is_null, mes);return v;}\n    void set(const T &nv) {is_null = false;v = nv;}\n    template<class U> void operator=(const U &v) {\n        set(v);//null状態でも代入出来るようにした\n//        if (has_value())value() = v; else return;\n    }\n    template<class U> void operator=(const my_optional<U> &v) {\n        if (/*has_value() && */v.has_value())(*this) = v; else return;\n    }\n    /*@formatter:off*/\n    void reset() { is_null = true; }\n    void operator=(const nullopt_t &) { reset(); }\n    template<require_t(!is_same2(T, bool))>\n    explicit operator bool(){return !is_null;}\n    //nullの時はエラー\n    operator T&(){return value();}\n    operator const T&()const {return value();}\n    my_optional<T> operator++() {        if (this->has_value()) {            this->value()++;            return *this;        } else {            return *this;        }    }\n    my_optional<T> operator++(signed) {        if (this->has_value()) {            auto tem = *this;            this->value()++;            return tem;        } else {            return *this;        }    }\n    my_optional<T> operator--() {        if (this->has_value()) {            this->value()--;            return *this;        } else {            return *this;        }    }\n    my_optional<T> operator--(signed) {        if (this->has_value()) {            auto tem = *this;            this->value()--;            return tem;        } else {            return *this;        }    }\n};\ntemplate<class T>istream &operator>>(istream &iss, my_optional<T>& v) {    T val;    iss>>val;    v.set(val);    return iss;}\n\n\n#define optional my_optional\ntemplate<class T>\nusing opt = my_optional<T>;\n//template<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\ntemplate<class Key, class T, class Compare = less<Key>, class Allocator = allocator<pair<const Key, T> >>\nstruct o_map : std::map<Key, optional<T>, Compare, Allocator> {\n    optional<T> emp;\n    o_map() : std::map<Key, optional<T>, Compare, Allocator>() {}\n    auto operator()(const nullopt_t&) {return nullopt;}\n    optional<T> &operator()(const optional<Key> &k) {if (k.has_value()) {return std::map<Key, optional<T>, Compare, Allocator>::operator[](k.value());} else {emp.reset();return emp;}}\n    optional<T> &operator()(const Key &k) {        auto &v = std::map<Key, optional<T>, Compare, Allocator>::operator[](k);        if (v.has_value())return v;        else {            v.set(0);            return v;        }    }\n    template<class U> void operator[](U){static string mes = \"s_map cant []\";assert2(0, mes);}\n};\n//以下、空のoptionalをnulloptと書く\n//ov[-1(参照外)] でnulloptを返す\n//ov[nullopt] で nulloptをかえす\n\ntemplate<class T> struct ov{\n    optional<T> emp;\n    vector<optional<T>> v;\n    ov(int i = 0, T val = 0):v(i, val){}\n    template<class U>ov(const U& rhs){v.resize(sz(rhs));for (int i  = 0; i  < sz(rhs); i ++)v[i].set(rhs[i]);}\n    optional<T> &operator()(int i) {if (i < 0 || sz(v) <= i) {emp.reset();return emp;} else { return v[i]; }}\n    optional<T> &operator()(const nullopt_t &) {        return operator()(-1);    }\n    optional<T> &operator()(const optional<T> &i) {        if (i.has_value())return operator()(i.value());        else {            return operator()(-1);        }    }\n/*@formatter:off*/\n};\ntemplate<class T>string deb_tos(const ov<T>& v){\n    return deb_tos(v.v);\n}\n\n//vectorに対しての処理は.vを呼ぶ\ntemplate<class T> class ovv{\n    optional<T> emp;\npublic:\n    vector<vector<optional<T>> > v ;\n    ovv(int i=0, int j=0, T val = 0) : v(i, vector<optional<T>>(j, val) ){}\n    optional<T> &operator()(int i, int j) {        if (i < 0 || j < 0 || sz(v) <= i || sz(v[i]) <= j) {            emp.reset();return emp;        }        else { return v[i][j]; }    }\n    //再帰ver 遅いと思う\n//    optional<T>& gets(optional<T>& v){return v;}\n//    template<class V, class H, class... U> optional<T>& gets(V& v, H i, U... tail){        if constexpr(is_same2(H, nullopt_t))return operator()(-1,-1);        else if constexpr(is_same2(H, optional<int>)){            if(i.has_value())return gets(v[(int)i], tail...);            else return operator()(-1,-1);        }else if constexpr(is_integral<H>::value){            return gets(v[(int)i], tail...);        }else{            assert(0);            return emp;        }    }\n#if __cplusplus >= 201703L\n    //if constexprバージョン 上が遅かったらこれで\n    template<class U, class V> optional<T> &operator()(const U &i, const V &j) {        /*駄目な場合を除外*/        if constexpr(is_same2(U, nullopt_t) || is_same2(U, nullopt_t)) {            return operator()(-1, -1);            /* o, o*/        } else if constexpr(is_same2(U, optional<int>) && is_same2(V, optional<int>)) {            return operator()(i.has_value() ? (int) i : -1, j.has_value() ? (int) j : -1);            /* o, x*/        } else if constexpr(is_same2(U, optional<int>)) {            return operator()(i.has_value() ? (int) i : -1, (int) j);            /* x, o*/        } else if constexpr(is_same2(V, optional<int>)) {            return operator()((int) i, j.has_value() ? (int) j : -1);            /* x, x*/        } else {            return operator()((int) i, (int) j);        }    }\n#endif\n    operator const vector<vector<optional<T>> >&(){\n        return v;\n    }\n};\ntemplate<class T>istream &operator>>(istream &iss, ovv<T> &a) {    for (int h  = 0; h  < sz(a); h ++){        for (int w  = 0; w  < sz(a[h]); w ++){            iss>>a.v[h][w ];        }    }    return iss;}\n\ntemplate<class T>string deb_tos(const ovv<T>& v){\n    return deb_tos(v.v);\n}\ntemplate<class T> struct ov3{\n    optional<T> emp;\n    vector<vector<vector<optional<T>>> > v ;\n    ov3(int i, int j, int k, T val = 0) : v(i, vector<vector<optional<T>>>(j, vector<optional<T>>(k, val) ) ){}\n    optional<T> &operator()(int i, int j, int k) {        if (i < 0 || j < 0 || sz(v) <= i || sz(v[i]) <= j) {            if(k < 0 || sz(v[i][j]) <= k){                emp.reset();                return emp;            }        }        return v[i][j][k];    }\nprivate:\n#if __cplusplus >= 201703L\n    //再帰ver 遅いと思う\n    template<class V, class H> optional<T> &gets(V &nowv, H i) {        if constexpr(is_same2(H, nullopt_t)) {            emp.reset(); return emp;        } else if constexpr(is_same2(H, optional<int>)) {            if (i.has_value()) {                return nowv[(int) i];            } else {                emp.reset();return emp;            }        } else if constexpr(is_integral<H>::value) {            return nowv[(int) i];        } else {            static string mes = \"ov3 error not index\";assert2(0, mes);            emp.reset();return emp;        }    }\n    //todo const &消した\n    template<class V, class H, class... U> optional<T> &gets(V &nowv, H i, U... tail) {        if constexpr(is_same2(H, nullopt_t)) {            emp.reset();return emp;        } else if constexpr(is_same2(H, optional<int>)) {            if (i.has_value()) {                return gets(nowv[(int) i], tail...);            } else {                emp.reset();return emp;            }        } else if constexpr(is_integral<H>::value) {            return gets(nowv[(int) i], tail...);        } else {            static string mes = \"ov3 error not index\";assert2(0, mes);            emp.reset();return emp;        }    }\n#endif\npublic:\n    template<class U, class V, class W> optional<T> &operator()(U i, V j, W k) {        return gets(v, i, j, k);    }\n/*@formatter:off*/\n};\ntemplate<class T>string deb_tos(const ov3<T>& v){\n    return deb_tos(v.v);\n}\n//nullopt_t\n//優先順位\n//null, [opt, tem]\n\n// + と += は違う意味を持つ\n//val+=null : val\n//val+null  : null\n//\n//+は途中計算\n//+=は最終的に格納したい値にだけ持たせる\n//+=がvoidを返すのは、途中計算で使うのを抑制するため\n\n//nulloptを考慮する際、計算途中では+を使ってnulloptを作り\n//格納する際は+=で無効にする必要がある\n\n//演算子==\n//optional<int>(10) == 10\n\n//全ての型に対応させ、value_typeが等しいかを見るようにするのもありかも\n\n//null同士を比較する状況はおかしいのではないか\nbool operator==(const nullopt_t &, const nullopt_t&){assert2(0, \"nul == null  cant hikaku\");return false;}\ntemplate<class T> bool operator==(const nullopt_t &, const T&){return false;}\ntemplate<class T> bool operator!=(const nullopt_t &, const T&){return true;}\ntemplate<class T> bool operator==(const T&, const nullopt_t &){return false;}\ntemplate<class T> bool operator!=(const T&, const nullopt_t &){return true;}\n//nullを\n\nnullopt_t& operator +(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator -(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator *(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator /(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator +=(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator -=(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator *=(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator /=(const nullopt_t &, const nullopt_t&) {return nullopt;}\n\ntemplate<class ANY> nullopt_t operator+(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator-(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator*(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator/(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator+(const ANY &, const nullopt_t &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator-(const ANY &, const nullopt_t &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator*(const ANY &, const nullopt_t &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator/(const ANY &, const nullopt_t &) {return nullopt;}\n\ntemplate<class ANY> void operator+=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator-=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator*=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator/=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator+=(ANY &, const nullopt_t &) {}\ntemplate<class ANY> void operator-=(ANY &, const nullopt_t &) {}\ntemplate<class ANY> void operator*=(ANY &, const nullopt_t &) {}\ntemplate<class ANY> void operator/=(ANY &, const nullopt_t &) {}\n\ntemplate<class T>struct is_optional:false_type{};\ntemplate<class T>struct is_optional<optional<T>>:true_type{};\ntemplate<class T, class U>\ntrue_type both_optional(optional<T> t, optional<U> u);\nfalse_type both_optional(...);\n\ntemplate<class T, class U> class opt_check : public decltype(both_optional(declval<T>(), declval<U>())) {};\n\n//optionalは同じ型同士しか足せない\n//(o, t), (t, o), (o, o)\n#define opt_tem(op) \\\ntemplate<class O, class O_ret = decltype(declval<O>() op declval<O>())>optional<O_ret> operator op(const optional<O> &opt1, const optional<O> &opt2) {    if (!opt1.has_value() || !opt2.has_value()) { return optional<O_ret>(); }    else {        return optional<O_ret>(opt1.value() op opt2.value());    }}\\\ntemplate<class O, class T, class O_ret = decltype(declval<O>() op declval<O>())> auto operator op(const optional<O> &opt, const T &tem) -> require_ret(!(opt_check<optional<O>, T>::value), optional<O_ret>) {    if (!opt.has_value()) { return optional<O_ret>(); }    else {        return optional<O_ret>(opt.value() op tem);    }}\\\ntemplate<class O, class T, class O_ret = decltype(declval<O>() op declval<O>())> auto operator op(const T &tem, const optional<O> &opt) -> require_ret(!(opt_check<optional<O>, T>::value), optional<O_ret>) {    if (!opt.has_value()) { return optional<O_ret>(); }    else {        return optional<O_ret>(opt.value() op tem);    }}\n/*@formatter:off*/\nopt_tem(+)opt_tem(-)opt_tem(*)opt_tem(/)\n//比較はoptional<bool>を返す\nopt_tem(<)opt_tem(>)opt_tem(<=)opt_tem(>=)\n\n/*@formatter:on*//*@formatter:off*/\n\ntemplate<class O, class T> bool operator==(const optional<O>& opt, const T& tem){if(opt.has_value()){return opt.value()==tem;}else return nullopt == tem;}\ntemplate<class O, class T> bool operator!=(const optional<O>& opt, const T& tem){if(opt.has_value()){return opt.value()!=tem;}else return nullopt != tem;}\ntemplate<class O, class T> bool operator==(const T& tem, const optional<O>& opt){if(opt.has_value()){return opt.value()==tem;}else return nullopt == tem;}\ntemplate<class O, class T> bool operator!=(const T& tem, const optional<O>& opt){if(opt.has_value()){return opt.value()!=tem;}else return nullopt != tem;}\n\n\ntemplate<class O> bool operator==(const optional<O>& opt1, const optional<O>& opt2){    if(opt1.has_value() != opt2.has_value()){        return false;    }else if(opt1.has_value()){        return opt1.value() == opt2.value();    }else {        return nullopt == nullopt;    }}\ntemplate<class O> bool operator!=(const optional<O>& opt1, const optional<O>& opt2){return !(opt1 == opt2);}\n\n//(a+=null) != (a=a+null)\n// a            null\ntemplate<class T, class O> void operator+=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem += opt.value(); }}\ntemplate<class T, class O> void operator-=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem -= opt.value(); }}\ntemplate<class T, class O> void operator*=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem *= opt.value(); }}\ntemplate<class T, class O> void operator/=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem /= opt.value(); }}\n\ntemplate<class T, class O> void operator+=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() += tem; }}\ntemplate<class T, class O> void operator-=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() -= tem; }}\ntemplate<class T, class O> void operator*=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() *= tem; }}\ntemplate<class T, class O> void operator/=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() /= tem; }}\n//\ntemplate<class Ol, class Or> void operator+=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl += opr.value(); }}\ntemplate<class Ol, class Or> void operator-=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl -= opr.value(); }}\ntemplate<class Ol, class Or> void operator*=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl *= opr.value(); }}\ntemplate<class Ol, class Or> void operator/=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl /= opr.value(); }}\n\n/*@formatter:off*/\n\ntemplate<class U> auto max(const nullopt_t &, const U &val) { return val; }\ntemplate<class U> auto max(const U &val, const nullopt_t &) { return val; }\ntemplate<class U> auto min(const nullopt_t &, const U &val) { return val; }\ntemplate<class U> auto min(const U &val, const nullopt_t &) { return val; }\n\ntemplate<class T, class U> auto max(const optional<T> &opt, const U &val) { if (opt.has_value())return max(opt.value(), val); else return val; }\ntemplate<class T, class U> auto max(const U &val, const optional<T> &opt) { if (opt.has_value())return max(opt.value(), val); else return val; }\ntemplate<class T, class U> auto min(const optional<T> &opt, const U &val) { if (opt.has_value())return min(opt.value(), val); else return val; }\ntemplate<class T, class U> auto min(const U &val, const optional<T> &opt) { if (opt.has_value())return min(opt.value(), val); else return val; }\n\n//null , optional, T\nbool chma(nullopt_t &, const nullopt_t &) { return false; }\ntemplate<class T> bool chma(T &opt, const nullopt_t &) { return false; }\ntemplate<class T> bool chma(nullopt_t &, const T &opt) { return false; }\ntemplate<class T> bool chma(optional<T> &olv, const optional<T> &orv) { if (orv.has_value()) { return chma(olv, orv.value()); } else return false; }\ntemplate<class T, class U> bool chma(optional<T> &opt, const U &rhs) { if (opt.has_value()) { return chma(opt.value(), rhs); } else return false; }\ntemplate<class T, class U> bool chma(T &lhs, const optional<U> &opt) { if (opt.has_value()) { return chma(lhs, opt.value()); } else return false; }\n\nbool chmi(nullopt_t &, const nullopt_t &) { return false; }\ntemplate<class T> bool chmi(T &opt, const nullopt_t &) { return false; }\ntemplate<class T> bool chmi(nullopt_t &, const T &opt) { return false; }\ntemplate<class T> bool chmi(optional<T> &olv, const optional<T> &orv) { if (orv.has_value()) { return chmi(olv, orv.value()); } else return false; }\ntemplate<class T, class U> bool chmi(optional<T> &opt, const U &rhs) { if (opt.has_value()) { return chmi(opt.value(), rhs); } else return false; }\ntemplate<class T, class U> bool chmi(T &lhs, const optional<U> &opt) { if (opt.has_value()) { return chmi(lhs, opt.value()); } else return false; }\n\n\ntemplate<class T> ostream &operator<<(ostream &os, optional<T> p) {    if (p.has_value())os << p.value(); else os << \"e\";    return os;}\ntemplate<class T>using opt = my_optional<T>;\nstruct xorshift {\n    /*@formatter:on*/\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    /*@formatter:off*/\n    size_t operator()(const uint64_t& x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }\n    size_t operator()(const std::pair<ll, ll>& x) const {        ll v = ((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }\n    template<class T, class U> size_t operator()(const std::pair<T, U>& x) const{        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        uint64_t hasx = splitmix64(x.first);        uint64_t hasy = splitmix64(x.second + FIXED_RANDOM);        return hasx ^ hasy;    }\n    template<class T> size_t operator()(const vector<T> &x) const {        uint64_t has = 0;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        uint64_t rv = splitmix64(FIXED_RANDOM);        for (int i  = 0; i  < sz(x); i ++){            uint64_t v = splitmix64(x[i] + rv);            has ^= v;            rv = splitmix64(rv);        }        return has;    }\n};\n\n#ifdef _DEBUG\nstring message;\nstring res_mes;\n//#define use_debtor\n//template<class T, class U, class X> auto count(unordered_map<T, U> &a, X k) { return a.find(k) != a.end(); }\n\n#ifdef use_debtor\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {        cerr << a.size() << \" \";        return deb_v(a.at(0), v + 1);    }\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {        for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }        if ((int) a.size() > 15) { cerr << \"...\"; }        cerr << endl;    }\n    typename std::vector<T>::reference my_at(typename std::vector<T>::size_type n, vector<int> &ind) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            ind.push_back(n);            cerr << \"out index at  \";            for (auto &&i: ind) {                cerr << i << \" \";            }            cerr << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n};\n#define vector debtor\n#endif\n#ifdef use_pbds\ntemplate<class T> struct my_pbds_tree {\n    set<T> s;\n    auto begin() { return s.begin(); }\n    auto end() { return s.end(); }\n    auto rbegin() { return s.rbegin(); }\n    auto rend() { return s.rend(); }\n    auto empty() { return s.empty(); }\n    auto size() { return s.size(); }\n    void clear() { s.clear(); }\n    template<class U> void insert(U v) { s.insert(v); }\n    template<class U> void operator+=(U v) { insert(v); }\n    template<class F> auto erase(F v) { return s.erase(v); }\n    template<class U> auto find(U v) { return s.find(v); }\n    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }\n    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }\n    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }\n    auto order_of_key(ll v) {        auto it = s.begin();        ll i = 0;        for (; it != s.end() && *it < v; i++)it++;        return i;    }\n};\n#define pbds(T) my_pbds_tree<T>\n#endif\n\n//区間削除は出来ない\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T, class U> struct my_unordered_map { unordered_map<T, U> m; my_unordered_map() {}; auto begin() { return m.begin(); } auto end() { return m.end(); } auto cbegin() { return m.cbegin(); } auto cend() { return m.cend(); } template<class V> auto erase(V v) { return m.erase(v); } void clear() { m.clear(); }    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V> auto find(V v) { return m.find(v); } template<class V> auto &operator[](V n) { return m[n]; }};\ntemplate<class K, class V>using umap_f = my_unordered_map<K, V>;\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\ntemplate<class K, class V>using umap_f = __gnu_pbds::gp_hash_table<K, V, xorshift>;\n#endif\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umappp unordered_map<P,P>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\n\ntemplate<class T, class U, class X> auto count(unordered_map<T, U> &a, X k) { return a.find(k) != a.end(); }\n/*@formatter:off*/\n#ifdef use_pbds\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n#endif\n//衝突対策\n#define ws ws_\n\n//todo 要らないと思う\ntemplate<class A, class B, class C> struct T2 { A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const { return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   } bool operator>(const T2 &r) const { return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   } bool operator==(const T2 &r) const { return f == r.f && s == r.s && t == r.t; } bool operator!=(const T2 &r) const { return f != r.f || s != r.s || t != r.t; }};\ntemplate<class A, class B, class C, class D> struct F2 {\n    A a;B b;C c;D d;\n    F2() { a = 0, b = 0, c = 0, d = 0; }\n    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F2 &r) const { return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }\n    bool operator>(const F2 &r) const { return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }\n    bool operator==(const F2 &r) const { return a == r.a && b == r.b && c == r.c && d == r.d; }\n    bool operator!=(const F2 &r) const { return a != r.a || b != r.b || c != r.c || d != r.d; }\n    ll operator[](ll i) {assert(i < 4);return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;}\n};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\n//T mt(ll a, ll b, ll c) { return T(a, b, c); }\n//F mf(ll a, ll b, ll c, ll d) { return F(a, b, c, d); }\n\n//関数内をまとめる\n//初期値l=-1, r=-1\nvoid set_lr12(int &l, int &r, int n) {    /*r==-1*/    if (r == -1) {        if (l == -1) {            l = 0;            r = n;        } else {            r = l;            l = 0;        }    }}\n//@マクロ省略系 型,構造\n//using で元のdoubleを同時に使えるはず\n#define double_big\n\n#ifdef double_big\n#define double long double\n//#define pow powl\n#endif\nusing dou = double;\n\n/*@formatter:off*/\ntemplate<class T> T MAX() { return numeric_limits<T>::max(); }\ntemplate<class T> T MIN() { return numeric_limits<T>::min(); }\nconstexpr ll inf = (ll) 1e9 + 100;\nconstexpr ll linf = (ll) 1e18 + 100;\nconstexpr dou dinf = (dou) linf * linf;\nconstexpr char infc = '{';\nconst string infs = \"{\";\n\ntemplate<class T> T INF() { return MAX<T>() / 2; }\ntemplate<> signed INF() { return inf; }\ntemplate<> ll INF() { return linf; }\ntemplate<> double INF() { return dinf; }\ntemplate<> char INF() { return infc; }\ntemplate<> string INF() { return infs; }\n\nconst double eps = 1e-9;\n\n//#define use_epsdou\n#ifdef use_epsdou\n//基本コメントアウト\nstruct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) {auto r = (double)b;        return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};\ntemplate<>epsdou MAX(){return MAX<double>();}\ntemplate<>epsdou MIN(){return MIN<double>();}\n//priqrity_queue等で使うのに必要\nbool operator<(const epsdou &a, const epsdou &b) {return a.v < b.v;}\nbool operator>(const epsdou &a, const epsdou &b) {return a.v > b.v;}\nistream &operator>>(istream &iss, epsdou &a) {iss >> a.v;return iss;}\nostream &operator<<(ostream &os, epsdou &a) {os << a.v;return os;}\n#define eps_conr_t(o) template<class T> epsdou operator o(T a, epsdou b) {return (dou) a o b.v;}\n#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b) {return a.v o (dou) b;}\neps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\n//template<class U> epsdou max(epsdou a, U b){return a.v>b ? a.v: b;}\n//template<class U> epsdou max(U a, epsdou b){return a>b.v ? a: b.v;}\n//template<class U> epsdou min(epsdou a, U b){return a.v<b ? a.v: b;}\n//template<class U> epsdou min(U a, epsdou b){return a<b.v ? a: b.v;}\n#undef double\n#define double epsdou\n#undef dou\n#define dou epsdou\n#endif\n\ntemplate<class T = int, class A, class B = int> T my_pow(A a, B b = 2) {\n    if(b < 0)return (T)1 / my_pow<T>(a, -b);\n#if __cplusplus >= 201703L\n    if constexpr(is_floating_point<T>::value) { return pow((T) a, (T) b); }\n    else if constexpr(is_floating_point<A>::value) { assert2(0, \"pow <not dou>(dou, )\");/*return 0;しない方がコンパイル前に(voidを受け取るので)エラーが出ていいかも*/}\n    else if constexpr(is_floating_point<B>::value) { assert2(0, \"pow <not dou>(, dou)\");/*return 0;しない方がコンパイル前に(voidを受け取るので)エラーが出ていいかも*/}\n    else {\n#endif\n        T ret = 1;        T bek = a;        while (b) {            if (b & 1)ret *= bek;            bek *= bek;            b >>= 1;        }        return ret;\n#if __cplusplus >= 201703L\n    }\n#endif\n}\n#define pow my_pow\n\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto&& v){return ret;}\n#define lam2(v, ret) [&](auto&& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto&& p){return p right;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t, a) vector<vector<t>>a\n#define vvt2(t, a, b) vector<vector<t>>a(b)\n#define vvt3(t, a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t, a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type, ...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type, name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_, v1_, v2_, v3_;\n\n/*@formatter:off*/\nstring to_string(char c) {    string ret = \"\";    ret += c;    return ret;}\ntemplate<class T> class pq_min_max {    vector<T> d;    void make_heap() {        for (int i = d.size(); i--;) {            if (i & 1 && d[i - 1] < d[i]) swap(d[i - 1], d[i]);            int k = down(i);            up(k, i);        }    }    inline int parent(int k) const { return ((k >> 1) - 1) & ~1; }    int down(int k) {        int n = d.size();        if (k & 1) { /* min heap*/            while (2 * k + 1 < n) {                int c = 2 * k + 3;                if (n <= c || d[c - 2] < d[c]) c -= 2;                if (c < n && d[c] < d[k]) {                    swap(d[k], d[c]);                    k = c;                }                else break;            }        }        else { /* max heap*/            while (2 * k + 2 < n) {                int c = 2 * k + 4;                if (n <= c || d[c] < d[c - 2]) c -= 2;                if (c < n && d[k] < d[c]) {                    swap(d[k], d[c]);                    k = c;                }                else break;            }        }        return k;    }    int up(int k, int root = 1) {        if ((k | 1) < (int) d.size() && d[k & ~1] < d[k | 1]) {            swap(d[k & ~1], d[k | 1]);            k ^= 1;        }        int p;        while (root < k && d[p = parent(k)] < d[k]) { /*max heap*/            swap(d[p], d[k]);            k = p;        }        while (root < k && d[k] < d[p = parent(k) | 1]) { /* min heap*/            swap(d[p], d[k]);            k = p;        }        return k;    }public:    pq_min_max() {}    pq_min_max(const vector<T> &d_) : d(d_) { make_heap(); }    template<class Iter> pq_min_max(Iter first, Iter last) : d(first, last) { make_heap(); }    void operator+=(const T &x) {        int k = d.size();        d.push_back(x);        up(k);    }    void pop_min() {        if (d.size() < 3u) { d.pop_back(); }        else {            swap(d[1], d.back());            d.pop_back();            int k = down(1);            up(k);        }    }    void pop_max() {        if (d.size() < 2u) { d.pop_back(); }        else {            swap(d[0], d.back());            d.pop_back();            int k = down(0);            up(k);        }    }    const T &get_min() const { return d.size() < 2u ? d[0] : d[1]; }    const T &get_max() const { return d[0]; }    int size() const { return d.size(); }    bool empty() const { return d.empty(); }};\n//小さいほうからM個取得するpq\ntemplate<class T> struct helper_pq_size {    pq_min_max<T> q;    T su = 0;    int max_size = 0;    helper_pq_size() {}    helper_pq_size(int max_size) : max_size(max_size) {}    void clear() {        q = pq_min_max<T>();        su = 0;    }    void operator+=(T v) {        su += v;        q += (v);        if (sz(q) > max_size) {            su -= q.get_max();            q.pop_max();        }    }    T sum() { return su; }    T top() { return q.get_min(); }    void pop() {        su -= q.get_min();        q.pop_min();    }    T poll() {        T ret = q.get_min();        su -= ret;        q.pop_min();        return ret;    }    ll size() { return q.size(); }};\n//大きいほうからM個取得するpq\ntemplate<class T> struct helper_pqg_size {    pq_min_max<T> q;    T su = 0;    int max_size = 0;    helper_pqg_size() {}    helper_pqg_size(int max_size) : max_size(max_size) {}    void clear() {        q = pq_min_max<T>();        su = 0;    }    void operator+=(T v) {        su += v;        q += (v);        if (sz(q) > max_size) {            su -= q.get_min();            q.pop_min();        }    }    T sum() { return su; }    T top() { return q.get_max(); }    void pop() {        su -= q.get_max();        q.pop_max();    }    T poll() {        T ret = q.get_max();        su -= ret;        q.pop_min();        return ret;    }    ll size() { return q.size(); }};;\n\ntemplate<class T, class Container = vector<T>,class Compare = std::less<typename Container::value_type>>\nstruct helper_pqg {    priority_queue<T, Container, Compare> q;/*小さい順*/    T su = 0;    helper_pqg() {}    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }    void operator+=(T v) {        su += v;        q.push(v);    }    T sum() { return su; }    T top() { return q.top(); }    void pop() {        su -= q.top();        q.pop();    }    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }    ll size() { return q.size(); }};\ntemplate<class T>\nusing  helper_pq = helper_pqg<T, vector<T>, greater<T>>;\n#if __cplusplus >= 201703L\n\n//小さいほうからsize個残る\n//Tがoptionalなら空の時nullを返す\ntemplate<class T> struct pq {\n    helper_pq<T> a_q;/*大きい順*/    helper_pq_size<T> b_q;/*大きい順*/    bool aquery;\n    T su = 0;\n    pq(int size = inf) {aquery = size == inf;if (!aquery) { b_q = helper_pq_size<T>(size); }}\n    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }\n    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }\n    //optionalなら空の時nullを返す\n    T top() {        if constexpr(is_optional<T>::value) {            if (aquery) {                if (sz(a_q) == 0)return T();                return a_q.top();            }            else {                if (sz(b_q) == 0)return T();                return b_q.top();            }        }        else { if (aquery)return a_q.top(); else return b_q.top(); }    }\n    T sum() { if (aquery) return a_q.sum(); else return b_q.sum(); }\n    //optionalなら空の時何もしない\n    void pop() { if constexpr(is_optional<T>::value) { if (aquery) { if (sz(a_q))a_q.pop(); } else { if (sz(b_q))b_q.pop(); }} else { if (aquery)a_q.pop(); else b_q.pop(); }}    /*T*/\n    T poll() {        if constexpr(is_optional<T>::value) {            if (aquery) {                if (sz(a_q) == 0)return T();                return a_q.poll();            }            else {                if (sz(b_q) == 0)return T();                return b_q.poll();            }        }        else { if (aquery)return a_q.poll(); else return b_q.poll(); }    }\n    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }\n    /*@formatter:off*/\n};\ntemplate<class T> struct pqg {    helper_pqg<T> a_q;/*大きい順*/    helper_pqg_size<T> b_q;/*大きい順*/    bool aquery;    T su = 0;    pqg(int size = inf) {        aquery = size == inf;        if (!aquery) { b_q = helper_pqg_size<T>(size); }    }    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }    T sum() { if (aquery)return a_q.sum(); else return b_q.sum(); }    T top() { if (aquery) return a_q.top(); else return b_q.top(); }    void pop() { if (aquery) a_q.pop(); else b_q.pop(); }    T poll() { if (aquery) return a_q.poll(); else return b_q.poll(); }    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }};\n#else\n//小さいほうからsize個残る\ntemplate<class T> struct pq {    helper_pq<T> a_q;/*大きい順*/    helper_pq_size<T> b_q;/*大きい順*/    bool aquery;    T su = 0;    pq(int size = inf) {        aquery = size == inf;        if (!aquery) { b_q = helper_pq_size<T>(size); }    }    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }    T sum() { if (aquery)return a_q.sum(); else return b_q.sum(); }    T top() { if (aquery) return a_q.top(); else return b_q.top(); }    void pop() { if (aquery) a_q.pop(); else b_q.pop(); }    T poll() { if (aquery) return a_q.poll(); else return b_q.poll(); }    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }};\n//大きいほうからsize個残る\ntemplate<class T> struct pqg {    helper_pqg<T> a_q;/*大きい順*/    helper_pqg_size<T> b_q;/*大きい順*/    bool aquery;    T su = 0;    pqg(int size = inf) {        aquery = size == inf;        if (!aquery) { b_q = helper_pqg_size<T>(size); }    }    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }    T sum() { if (aquery)return a_q.sum(); else return b_q.sum(); }    T top() { if (aquery) return a_q.top(); else return b_q.top(); }    void pop() { if (aquery) a_q.pop(); else b_q.pop(); }    T poll() { if (aquery) return a_q.poll(); else return b_q.poll(); }    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }};\n#endif\n#define pqi pq<ll>\n#define pqgi pqg<ll>\ntemplate<class T> string deb_tos(pq<T> &q) {    vector<T> res;    auto temq = q;    while (sz(temq))res.push_back(temq.top()), temq.pop();    stringstream ss;    ss<< res;    return ss.str();}\ntemplate<class T> string deb_tos(pqg<T> &q) {    vector<T> res;    auto temq = q;    while (sz(temq))res.push_back(temq.top()), temq.pop();    stringstream ss;    ss<< res;    return ss.str();}\n\n/*@formatter:off*/\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n//todo 使わないもの非表示\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n\n#ifdef use_for\n\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\ntemplate<class T> void nex_repv2(int &i, int &j, int &I, int &J, vector<vector<T>> &s) {    while (1) {        j++;        if (j >= J) {            j = 0;            i++;            if (i < I) { J = (int) s[i].size(); }        }        if (i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i, a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), i = 0, j = 0; i < repvI; nex_repv2(i,j,repvI,repvJ,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), repvK =(int)a[0][0].size(), i = 0, j = 0, k=0; i < repvI; nex_repv3(i,j,k,repvI,repvJ,repvK,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n#endif\n\ntemplate<typename T> struct has_rbegin_rend { private:template<typename U> static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value; };\ntemplate<typename T> constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;\ntemplate<typename Iterator> class Range { public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept { return m_begin; }Iterator end() const noexcept { return m_end; }private:const Iterator m_begin;const Iterator m_end; };\ntemplate<typename Iterator> static inline Range<Iterator> makeRange(Iterator &&begin, Iterator &&end) noexcept { return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)}; }\ntemplate<typename T> static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept { return makeRange(std::rbegin(iniList), std::rend(iniList)); }\ntemplate<typename T, typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr> static inline decltype(auto) makeReversedRange(T &&c) noexcept { return makeRange(std::rbegin(c), std::rend(c)); }/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T, typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr> static inline void makeReversedRange(T &&) noexcept { static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\"); }\n\n//#define use_for\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define forrm1(st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n#define forrm3(k, v, st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n\n//向こう側で\n// ++itか it = st.erase(it)とする\n#define fors1(st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors2(v, st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors3(v, st, r) for (auto &&it = st.begin(); it != st.end() && (*it) < r; )\n#define fors4(v, st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r; )\n\n#ifdef use_for\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n\n#define fora_f_init_2(a, A) ;\n#define fora_f_init_3(fora_f_i, a, A) auto &&a = A[fora_f_i];\n#define fora_f_init_4(a, b, A, B) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i];\n#define fora_f_init_5(fora_f_i, a, b, A, B) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i];\n#define fora_f_init_6(a, b, c, A, B, C) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i];\n#define fora_f_init_7(fora_f_i, a, b, c, A, B, C) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i];\n#define fora_f_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i]; auto && d = D[fora_f_i];\n#define fora_f_init_9(fora_f_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i]; auto && d = D[fora_f_i];\n#define fora_f_init(...) over9(__VA_ARGS__,fora_f_init_9, fora_f_init_8, fora_f_init_7, fora_f_init_6, fora_f_init_5, fora_f_init_4, fora_f_init_3, fora_f_init_2)(__VA_ARGS__)\n\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n#define forp_init3(k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init4(forp_i, k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init(...) over4(__VA_ARGS__,forp_init4,forp_init3,forp_init2,forp_init1)(__VA_ARGS__)\n\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define forrm_init(k, v, ...) auto &&k = (*forrm_it).fi;auto &&v = (*forrm_it).se;\n#define fors_init(v, ...) auto &&v = (*it);\n\n#define forlr_init(a, A, ngl, ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n\n//こうしないとmapがおかしくなる\n#define fora_f_2(a, A) for(auto&& a : A)\n#define fora_f_3(fora_f_i, a, A) rep(fora_f_i, sz(A))\n#define fora_f_4(a, b, A, B) rep(fora_f_i, sz(A))\n#define fora_f_5(fora_f_i, a, b, A, B) rep(fora_f_i, sz(A))\n#define fora_f_6(a, b, c, A, B, C) rep(fora_f_i, sz(A))\n#define fora_f_7(fora_f_i, a, b, c, A, B, C) rep(fora_f_i, sz(A))\n#define fora_f_8(a, b, c, d, A, B, C, D) rep(fora_f_i, sz(A))\n#define fora_f_9(fora_f_i, a, b, c, d, A, B, C, D) rep(fora_f_i, sz(A))\n\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#endif\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n\n//自分込みで残りがREM以上の間ループを回す\n#define rem(i, N, REM) for (int i = 0; i < N - REM + 1; i++)\n\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n#ifdef use_for\n#define fora_f(...) over9(__VA_ARGS__, fora_f_9, fora_f_8, fora_f_7, fora_f_6, fora_f_5, fora_f_4, fora_f_3, fora_f_2)(__VA_ARGS__)\n#endif\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n//0~N-2まで見る\n\n#define forar_init(v, rv, A) auto &&v = A[forar_i]; auto && rv = A[forar_i+1];\n#define forar(v, rv, A) rep(forar_i, sz(A) - 1)\n\n#if __cplusplus >= 201703L\ntemplate<size_t M_SZ, bool indexed, class Iterator, class T, class U=T, class V=T, class W=T>\nclass ite_vec_merge : public Iterator {    std::size_t i = 0;    vector<T> &A;    vector<U> &B;    vector<V> &C;    vector<W> &D;public :    ite_vec_merge(Iterator ita, vector<T> &A) : Iterator(ita), A(A), B(A), C(A), D(A) {}    ite_vec_merge(Iterator ita, vector<T> &A, vector<U> &B) : Iterator(ita), A(A), B(B), C(A), D(A) {}    ite_vec_merge(Iterator ita, vector<T> &A, vector<U> &B, vector<V> &C) : Iterator(ita), A(A), B(B), C(C), D(A) {}    ite_vec_merge(Iterator ita, vector<T> &A, vector<U> &B, vector<V> &C, vector<W> &D) : Iterator(ita), A(A), B(B), C(C), D(D) {}    auto &operator++() {        ++i;        this->Iterator::operator++();        return *this;    }    auto operator*() const noexcept {        if constexpr(!indexed && M_SZ == 1) { return tuple<T &>(A[i]); }        else if constexpr(!indexed && M_SZ == 2) { return tuple<T &, U &>(A[i], B[i]); }        else if constexpr(!indexed && M_SZ == 3) { return tuple<T &, U &, V &>(A[i], B[i], C[i]); }        else if constexpr(!indexed && M_SZ == 4) { return tuple<T &, U &, V &, W &>(A[i], B[i], C[i], D[i]); }        else if constexpr(indexed && M_SZ == 1) { return tuple<int, T &>(i, A[i]); }        else if constexpr(indexed && M_SZ == 2) { return tuple<int, T &, U &>(i, A[i], B[i]); }        else if constexpr(indexed && M_SZ == 3) { return tuple<int, T &, U &, V &>(i, A[i], B[i], C[i]); }        else if constexpr(indexed && M_SZ == 4) { return tuple<int, T &, U &, V &, W &>(i, A[i], B[i], C[i], D[i]); }        else {            assert(0);            return tuple<int>(i);        }    }};\ntemplate<size_t M_SZ, bool indexed, class T, class U=T, class V=T, class W=T>\nclass vec_merge {    vector<T> &a;    vector<U> &b;    vector<V> &c;    vector<W> &d;public :    vec_merge(vector<T> &a) : a(a), b(a), c(a), d(a) {}    vec_merge(vector<T> &a, vector<U> &b) : a(a), b(b), c(a), d(a) {}    vec_merge(vector<T> &a, vector<U> &b, vector<V> &c) : a(a), b(b), c(c), d(a) {}    vec_merge(vector<T> &a, vector<U> &b, vector<V> &c, vector<W> &d) : a(a), b(b), c(c), d(d) {}    auto begin() const {        if constexpr(M_SZ == 1) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a}; }        else if constexpr(M_SZ == 2) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a, b}; }        else if constexpr(M_SZ == 3) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a, b, c}; }        else if constexpr(M_SZ == 4) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a, b, c, d}; }        else {            assert(0);            return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a};        }    }    auto end() const {        if constexpr(M_SZ == 1) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a}; }        else if constexpr(M_SZ == 2) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a, b}; }        else if constexpr(M_SZ == 3) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a, b, c}; }        else if constexpr(M_SZ == 4) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a, b, c, d}; }        else {            assert(0);            return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a};        }    }};\n#endif\n#define fora_2(a, A) for(auto&& a : A)\n\n#if __cplusplus >= 201703L\n#define fora_3(i, a, A) for(auto[i, a] : vec_merge<1, true, decl_t<decltype(A)>>(A))\n#define fora_4(a, b, A, B) for(auto[a, b] : vec_merge<2, false, decl_t<decltype(A)>, decl_t<decltype(B)>>(A, B))\n#define fora_5(i, a, b, A, B)  for(auto[i, a, b] : vec_merge<2, true, decl_t<decltype(A)>, decl_t<decltype(B)>>(A, B))\n#define fora_6(a, b, c, A, B, C)  for(auto[a, b, c] : vec_merge<3, false, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>>(A, B, C))\n#define fora_7(i, a, b, c, A, B, C)  for(auto[i, a, b, c] : vec_merge<3, true, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>>(A, B, C))\n#define fora_8(a, b, c, d, A, B, C, D) for(auto[a, b, c, d] : vec_merge<4, false, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>, decl_t<decltype(D)>>(A, B, C, D))\n#define fora_9(i, a, b, c, d, A, B, C, D) for(auto[i, a, b, c, d] : vec_merge<4, true, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>, decl_t<decltype(D)>>(A, B, C, D))\n#endif\n//構造化束縛ver\n//1e5要素で40ms程度\n//遅いときはfora_fを使う\n#define fora(...) over9(__VA_ARGS__, fora_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n/*@formatter:off*/\n#ifdef use_for\ntemplate<class U> vector<U> to1d(vector<U> &a) { return a; }\ntemplate<class U> auto to1d(vector<vector<U>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)res.push_back(a2);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<U>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) res.push_back(a3);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<vector<U>>>> &a) {vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)res.push_back(a4);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<vector<vector<U>>>>> &a) {vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)res.push_back(a5);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<vector<vector<vector<U>>>>>> &a) {vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)for (auto &&a6 : a5)res.push_back(a6);    return res;}\n#define forv(a, b) for(auto a : to1d(b))\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n#endif\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forrm(...) over5(__VA_ARGS__,forrm5,forrm4,forrm3,forrm2,forrm1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp3(k, v, st)  rep(forp_i,sz(st))\n#define forp4(forp_i, k, v, st) rep(forp_i,sz(st))\n#define forp(...) over4(__VA_ARGS__,forp4,forp3)(__VA_ARGS__)\n\n//to_vec(rep(i, N))のように使い\n//iが走査した値を持つvectorを返す\n#define to_vec2(type, my_for) \\\n    [&](){                    \\\n        vector<type> ret;     \\\n        my_for{               \\\n            ret.push_back(i); \\\n        }                     \\\n        return ret;           \\\n    }()\n#define to_vec1(my_for) to_vec2(int, my_for)\n#define to_vec(...) over2(__VA_ARGS__,to_vec2,to_vec1)(__VA_ARGS__)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nconst double PI = 3.1415926535897932384626433832795029L;\n\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\n/*@formatter:off*/\nistream &operator>>(istream &iss, P &a) {iss >> a.first >> a.second;return iss;}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec_) {for (T &x: vec_) iss >> x;return iss;}\ntemplate<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {os << p.fi << \" \" << p.se;return os;}\nostream &operator<<(ostream &os, T p) {os << p.f << \" \" << p.s << \" \" << p.t;return os;}\nostream &operator<<(ostream &os, F p) {os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;return os;}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &vec_) {for (ll i = 0; i < vec_.size(); ++i)os << vec_[i] << (i + 1 == vec_.size() ? \"\" : \" \");return os;}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec_) {for (ll i = 0; i < vec_.size(); ++i) {for (ll j = 0; j < vec_[i].size(); ++j) { os << vec_[i][j] << \" \"; }os << endl;}return os;}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {os << endl;for (auto &&v:m) os << v << endl;return os;}\ntemplate<class T> ostream &operator<<(ostream &os, set<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}\ntemplate<class T> ostream &operator<<(ostream &os, mset<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}\ntemplate<class T> ostream &operator<<(ostream &os, deque<T> a) {    fora(v, a) { os << v << \" \"; }    return os;}\nostream &operator<<(ostream &os, vector<vector<char>> &vec_) {    rep(h, sz(vec_)) {        rep(w, sz(vec_[0])) { os << vec_[h][w]; }        os << endl;    }    return os;}\n\ntemplate<class T> struct range_now {\n    int l;\n    vector<T> A;\n    range_now(vector<T>&& A, int l) : A(A), l(l){}\n};\n/*@formatter:off*/\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora_f(v,a)os<<v<<endl;return os;}\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n//#define use_for_each  //_each _all_of _any_of _none_of _find_if _rfind_if _contains _count_if _erase_if _entry_if\n\n#ifdef use_for_each\n//todo Atcoderの過去問がc++17に対応したら\n#if __cplusplus >= 201703L\n//for_each以外はconst & (呼び出し側のラムダも)\ntemplate<typename T, typename F> bool all_of2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : v) { if (!all_of2(v_, f))return false; }        return true;    } else { return f(v); }}\ntemplate<typename T, typename F> bool any_of2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : v) { if (!any_of2(v_, f))return true; }        return false;    } else { return f(v); }}\ntemplate<typename T, typename F> bool none_of2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : v) { if (none_of2(v_, f))return false; }        return true;    } else { return f(v); }}\n\n//存在しない場合\n//1次元 Nを返す\n//多次元-1を返す\ntemplate<typename T, typename F> ll find_if2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (f(v[i]))return i; }    return sz(v);}\ntemplate<typename T, typename F> tuple<int, int> find_if2(const vector<vector<T> > &v, F f) {    rep(i, sz(v)) { rep(j, sz(v[i])) { if (f(v[i][j])) { return tuple<int, int>(i, j); }}}    return tuple<int, int>(-1, -1);}\ntemplate<typename T, typename F> auto find_if2(const vector<vector<vector<T> > > &v, F f) {    rep(i, sz(v)) { if (auto ret = find_if2(v[i], f); get<0>(ret) != -1) { return tuple_cat(tuple<int>(i), ret); }}    auto bad = tuple_cat(tuple<int>(-1), find_if2(v[0], f));    return bad;}\ntemplate<class T, class F> auto find_if2(const range_now<T> &v, F f) {return find_if2(v.A, f) + v.l;}\n//存在しない場合\n//1次元 -1を返す\n//多次元-1を返す\ntemplate<typename T, typename F> ll rfind_if2(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> tuple<int, int> rfind_if2(const vector<vector<T> > &v, F f) {    rer(i, sz(v) - 1) { rer(j, sz(v[i]) - 1) { if (f(v[i][j])) { return tuple<int, int>(i, j); }}}    return tuple<int, int>(-1, -1);}\ntemplate<typename T, typename F> auto rfind_if2(const vector<vector<vector<T> > > &v, F f) {    rer(i, sz(v) - 1) { if (auto ret = rfind_if2(v[i], f); get<0>(ret) != -1) { return tuple_cat(tuple<int>(i), ret); }}    auto bad = tuple_cat(tuple<int>(-1), rfind_if2(v[0], f));    return bad;}\n\n//todo まとめられそう string,vector全般\ntemplate<class T> bool contains(const string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(const vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(const vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        ll ret = 0;        for (auto &&v_ : v) { ret += count_if2(v_, f); }        return ret;    } else { return f(v); }}\ntemplate<typename T, typename F> void for_each2(T &a, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : a)for_each2(v_, f);    } else {        f(a);    }}\n#else\ntemplate<typename T, typename F> bool all_of2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(const string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(const vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(const vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(const vector<T> &vec_, F f) {    ll ret = 0;    fora(v, vec_) { ret += count_if2(v, f); }    return ret;}\n\ntemplate<typename T, typename F> void for_each2(T &a, F f) {\n    f(a);\n}\ntemplate<typename T, typename F> void for_each2(vector<T>  &a, F f) {\n    for (auto &&v_ : a)for_each2(v_, f);\n}\n#endif\ntemplate<typename W> ll count_od(const vector<W> &a) { return count_if2(a, [](ll v) { return v & 1; }); }\ntemplate<typename W> ll count_ev(const vector<W> &a) { return count_if2(a, [](ll v) { return !(v & 1); }); }\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(const vector<T> &v, F f) {    vector<T> nv;    rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}    return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(const vector<vector<T>> &v, F f) {    vector<vector<T>> res;    rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }    return res;}\n\ntemplate<typename T, typename F> vector<T> entry_if2(const vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (f(v[i])) { nv.push_back(v[i]); }}return nv;}\ntemplate<typename T, typename F> vector<vector<T>> entry_if2(const vector<vector<T>> &v, F f) {vector<vector<T>> res;rep(i, sz(v)) { res[i] = entry_if2(v[i], f); }return res;}\n\ntemplate<typename T, typename F> ll l_rfind_if(const vector<T> &v, F f) {rer(i, sz(v) - 1) { if (f(v[i]))return i; }return -1;}\ntemplate<typename T, typename F> bool l_contains_if(const vector<T> &v, F f) {rer(i, sz(v) - 1) { if (f(v[i]))return true; }return false;}\ntemplate<class A, class B, class C> auto t_all_of(A a, B b, C c) { return std::all_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_any_of(A a, B b, C c) { return std::any_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_none_of(A a, B b, C c) { return std::none_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_find_if(A a, B b, C c) { return std::find_if(a, b, c); }\ntemplate<class A, class B, class C> auto t_count_if(A a, B b, C c) { return std::count_if(a, b, c); }\n\n#define all_of_s__2(a, right) (t_all_of(ALL(a),lamr(right)))\n#define all_of_s__3(a, v, siki) (t_all_of(ALL(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a, right) all_of2(a,lamr(right))\n#define all_of__3(a, v, siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a, f) all_of2(a,f)\n\n#define any_of_s__2(a, right) (t_any_of(ALL(a),lamr(right)))\n#define any_of_s__3(a, v, siki) (t_any_of(ALL(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a, right) any_of2(a,lamr(right))\n#define any_of__3(a, v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a, f) any_of2(a,f)\n\n#define none_of_s__2(a, right) (t_none_of(ALL(a),lamr(right)))\n#define none_of_s__3(a, v, siki) (t_none_of(ALL(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a, right) none_of2(a,lamr(right))\n#define none_of__3(a, v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a, f) none_of2(a,f)\n\n#define find_if_s__2(a, right) (t_find_if(ALL(a),lamr(right))-a.begin())\n#define find_if_s__3(a, v, siki) (t_find_if(ALL(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a, right) find_if2(a,lamr(right))\n#define find_if__3(a, v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if__4(a, l, v, siki) (find_if2(decltype(a)(a.begin()+l , a.end()),[&](auto v){return siki;}) + l)\n#define find_if(...) over4(__VA_ARGS__,find_if__4, find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a, f) find_if2(a,f)\n\n#define rfind_if_s__2(a, right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a, v, siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a, right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a, v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a, f) rfind_if2(a,f)\n\n#define contains_if_s__2(a, right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a, v, siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a, right) contains_if2(a,lamr(right))\n#define contains_if__3(a, v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a, f) contains_if2(a,f)\n\n#define count_if_s__2(a, right) (t_count_if(ALL(a),lamr(right)))\n#define count_if_s__3(a, v, siki) (t_count_if(ALL(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a, right) count_if2(a,lamr(right))\n#define count_if__3(a, v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a, f) count_if2(a,f)\n\n//vector<vi>で、viに対して操作\n#define for_each_s__2(a, right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a, v, shori) do{fora(v,a){shori;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n//vector<vi>で、intに対して操作\n#define for_each__2(a, right) for_each2(a,lamr(right))\n#define for_each__3(a, v, shori) for_each2(a,[&](auto& v){shori;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\ntemplate<class T, class F> vector<T> help_for_eached(const vector<T> &A, F f) {    vector<T> ret = A;    for_each(ret, v, f(v));    return ret;}\n#define for_eached__2(a, right) help_for_eached(a, lamr(right))\n#define for_eached__3(a, v, shori) help_for_eached(a, lam(v, shori))\n#define for_eached(...) over3(__VA_ARGS__,for_eached__3,for_eached__2)(__VA_ARGS__)\n#define for_eached_f(a, f) for_eached2(a, f);\n\n#define each for_each\n#define eached for_eached\n\n\n//#define erase_if_s__2(a, right) l_erase_if2(a,lamr(right))\n//#define erase_if_s__3(a, v, siki) l_erase_if2(a,[&](auto v){return siki;})\n//#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a, right) erase_if2(a,lamr(right))\n#define erase_if__3(a, v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a, f) erase_if2(a,f)\n\n//#define entry_if_s__2(a, right) l_entry_if2(a,lamr(right))\n//#define entry_if_s__3(a, v, siki) l_entry_if2(a,[&](auto v){return siki;})\n//#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a, right) entry_if2(a,lamr(right))\n#define entry_if__3(a, v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a, f) entry_if2(a,f)\n\n#endif\n\n/*@formatter:off*/\ntemplate<class T, class U, class W> void replace(vector<W> &a, T key, U v) { rep(i, sz(a))if (a[i] == key)a[i] = v; }\ntemplate<class T, class U, class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i, sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(ALL(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(ALL(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\nvoid replace(str &a) {    int dec = 0;    if ('a' <= a[0] && a[0] <= 'z')dec = 'a';    if ('A' <= a[0] && a[0] <= 'Z')dec = 'A';    fora(v, a) { v -= dec; }}\nvoid replace(str &a, str key, str v) {    stringstream t;    ll kn = sz(key);    std::string::size_type Pos(a.find(key));    ll l = 0;    while (Pos != std::string::npos) {        t << a.substr(l, Pos - l);        t << v;        l = Pos + kn;        Pos = a.find(key, Pos + kn);    }    t << a.substr(l, sz(a) - l);    a = t.str();}\n\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(ALL(a), ALL(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(ALL(a)); }\nvi iota(ll s, ll len) {vi ve(len);iota(ALL(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);    return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\n\n/*@formatter:off*/\ntemplate<class T> void sort(vector<T> &a, int l = -1, int r = -1) {    set_lr12(l, r, sz(a));    fast_sort(a.begin() + l, a.begin() + r);}\ntemplate<class T> void rsort(vector<T> &a, int l = -1, int r = -1) {    set_lr12(l, r, sz(a));    fast_sort(a.begin() + l, a.begin() + r, greater<T>());};\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class... T, class U> auto sorted(U head, T... a) {    sort(head, a...);    return head;}\ntemplate<class... T, class U> auto rsorted(U head, T... a) {rsort(head, a...);return head;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}\n//#define use_sort\n#ifdef use_sort\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti,    fisitd,    fisdti,    fisdtd,    fdsiti,    fdsitd,    fdsdti,    fdsdtd,    fitisi,    fitisd,    fitdsi,    fitdsd,    fdtisi,    fdtisd,    fdtdsi,    fdtdsd,    sifiti,    sifitd,    sifdti,    sifdtd,    sdfiti,    sdfitd,    sdfdti,    sdfdtd,    sitifi,    sitifd,    sitdfi,    sitdfd,    sdtifi,    sdtifd,    sdtdfi,    sdfdfd,    tifisi,    tifisd,    tifdsi,    tifdsd,    tdfisi,    tdfisd,    tdfdsi,    tdfdsd,    tisifi,    tisifd,    tisdfi,    tisdfd,    tdsifi,    tdsifd,    tdsdfi,    tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {typedef pair<A, B> U;if (type == fisi) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; }); else if (type == fisd) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; }); else if (type == fdsi) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; }); else if (type == fdsd) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; }); else if (type == sifi) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; }); else if (type == sifd) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; }); else if (type == sdfi) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; }); else if (type == sdfd) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};\ntemplate<class U> void sort(vector<U> &a, pcomparator type) { if (type == fisi) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; }); else if (type == fisd) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; }); else if (type == fdsi) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; }); else if (type == fdsd) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; }); else if (type == sifi) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == sifd) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == sdfi) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == sdfd) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; }); };\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {typedef F2<A, B, C, D> U;if (type == fisi) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; }); else if (type == fisd) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; }); else if (type == fdsi) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; }); else if (type == fdsd) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; }); else if (type == sifi) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == sifd) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == sdfi) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == sdfd) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};\ntemplate<class U> void sort(vector<U> &a, tcomparator type) {if (type == 0) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 41) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 42) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 43) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; }); else if (type == 44) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 45) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 46) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 47) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 41) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 42) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 43) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; }); else if (type == 44) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 45) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 46) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 47) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\n/*@formatter:off*/\nvoid sort(string &a) { sort(ALL(a)); }\nvoid rsort(string &a) { sort(RALL(a)); }\nvoid sort(int &a, int &b) { if (a > b)swap(a, b); }\nvoid sort(int &a, int &b, int &c) {    sort(a, b);    sort(a, c);    sort(b, c);}\nvoid rsort(int &a, int &b) { if (a < b)swap(a, b); }\nvoid rsort(int &a, int &b, int &c) {    rsort(a, b);    rsort(a, c);    rsort(b, c);}\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(ALL(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(ALL(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n/*indexの分で型が変わるためpcomparatorが必要*/\ntemplate<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}\ntemplate<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}\ntemplate<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}\ntemplate<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}\ntemplate<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };\ntemplate<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}\ntemplate<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };\ntemplate<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] < c[y]; else return b[x] < b[y]; } else { return a[x] < a[y]; }});    return ind;}\ntemplate<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] > c[y]; else return b[x] > b[y]; } else { return a[x] > a[y]; }});    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\n#endif\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {    vi c = a;    vi d = b;    sort(c);    sort(d);    return includes(ALL(c), ALL(d));}\ntemplate<class T> bool distinct(const vector<T> &A) {    if ((int) (A).size() == 1)return true;    if ((int) (A).size() == 2)return A[0] != A[1];    if ((int) (A).size() == 3)return (A[0] != A[1] && A[1] != A[2] && A[0] != A[2]);    auto B = A;    sort(B);    int N = (B.size());    unique(B);    return N == (int) (B.size());}\ntemplate<class H, class... T> bool distinct(const H &a, const T &...b) { return distinct(vector<H>{a, b...}); }\n\n/*@formatter:off*/\ntemplate<class T, class U> void inc(pair<T, U> &a, U v = 1) { a.first += v, a.second += v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U = int> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U = int> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, W v = 1) {for (auto &u :a)dec(u, v);for (auto &u :b)dec(u, v);}\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, vector<W> &c) {    for (auto &u :a)dec(u, 1);    for (auto &u :b)dec(u, 1);    for (auto &u :c)dec(u, 1);}\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool san(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return san(0, i, sz(a)) && san(0, j, sz(a)); }\n#define inside ins\nll u0(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u0(vector<T> &a) {    vector<T> ret = a;    fora(v, ret) { v = u(v); }    return ret;}\n//todo 名前\nbool d_(int a, int b) {if (b == 0)return false;return (a % b) == 0;}\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    cerr << \"ole\" << endl;exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;exit(0);\n}\nvoid re(string s = \"\") {cerr << s << endl;assert(0 == 1);exit(0);}\n\nvoid tle() { while (inf)cout << inf << endl; }\n\n\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\ntemplate<class T> T in() {    T ret;    cin >> ret;    return ret;}\nstring sin() {    string ret;    cin >> ret;    return ret;}\ntemplate<class T> void in(T &head) { cin >> head; }\ntemplate<class T, class... U> void in(T &head, U &... tail) {    cin >> head;    in(tail...);}\n\n\n//value_typeを持つ場合呼べる\n//len回要素を追加する\ntemplate<class Iterable, class T = typename Iterable::value_type> Iterable tin(int len) {    Iterable ret;    T tem;    while (len--) {        cin >> tem;        ret += tem;    }    return ret;}\ntemplate<class T> T tin() {    T ret;    cin >> ret;    return ret;}\ntemplate<class T> T tind(int len = 0) {    auto ret = tin<T>(len);    dec(ret, 1);    return ret;}\n#define din_t2(type, a) type a;cin>>a\n#define din_t3(type, a, b) type a,b;cin>>a>> b\n#define din_t4(type, a, b, c) type a,b,c;cin>>a>>b>>c\n#define din_t5(type, a, b, c, d) type a,b,c,d;cin>>a>>b>>c>>d\n#define din_t6(type, a, b, c, d, e) type a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din_t7(type, a, b, c, d, e, f) type a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din_t(...) over7(__VA_ARGS__,din_t7,din_t6,din_t5,din_t4,din_t3 ,din_t2)(__VA_ARGS__)\n\n#define din(...) din_t(int,__VA_ARGS__)\n#define d_in\n#define dsig(...) din_t(signed,__VA_ARGS__)\n\n#define dst(...) din_t(string,__VA_ARGS__)\n#define dstr dst\n#define d_str dst\n\n#define dcha(...) din_t(char,__VA_ARGS__)\n#define dchar dcha\n\n#define ddou(...) din_t(double,__VA_ARGS__)\n\n\n#define din1d(a) din_t2(int, a);a--\n#define din2d(a, b) din_t3(int, a,b);a--,b--\n#define din3d(a, b, c) din_t4(int, a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din_t5(int, a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n/*@formatter:off*/\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) { cerr << head << endl; }\nvoid err() { cerr << \"\" << endl; }\n//debで出力する最大長\nconstexpr int DEB_LEN = 20;\nconstexpr int DEB_LEN_H = 12;\nstring deb_tos(const int &v) { if (abs(v) == inf || abs(v) == linf)return \"e\"; else return to_string(v); }\ntemplate<class T> string deb_tos(const T &a) {stringstream ss;ss << a;return ss.str();}\n#ifdef use_epsdou\nstring deb_tos(const epsdou &a) {return deb_tos(a.v);}\n#endif\ntemplate<class T> string deb_tos(const optional<T> &a) { if (a.has_value()) { return deb_tos(a.value()); } else return \"e\"; }\ntemplate<class T> string deb_tos(const vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), DEB_LEN);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << deb_tos(a[i]);        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            lens[wi] = max(lens[wi], sz(deb_tos(a[h][W[wi]])) + 1);            lens[wi] = max(lens[wi], sz(deb_tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(lens[i])ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            ss << std::right << std::setw(lens[wi]) << deb_tos(a[h][w]);            wi++;        }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), DEB_LEN_H});    W = min({W, sz(a[0]), DEB_LEN_H});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    return deb_tos(a, hs, ws, key);}\ntemplate<class T> string deb_tos(const vector<vector<vector<T> > > &a, ll H = inf) {    stringstream ss;    if (H == inf)H = DEB_LEN_H;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << deb_tos(a[i], inf, inf, i);    }    return ss.str();}\ntemplate<class T> string deb_tos(vector<set<T> > &a, ll H = inf, ll W = inf, int key = -1) {    vector<vector<T> > b(sz(a));    rep(i, sz(a)) { fora(v, a[i]) { b[i].push_back(v); }}    return deb_tos(b, H, W, key);}\ntemplate<class T, size_t A> string deb_tos(T (&a)[A]) { return deb_tos(vector<T>(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B> string deb_tos(T (&a)[A][B]) { return deb_tos(vector<vector<T> >(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B, size_t C> string deb_tos(T (&a)[A][B][C]) { return deb_tos(vector<vector<vector<T> > >(begin(a), end(a))); }\n/*@formatter:off*/\ntemplate<class T> void out2(T head) {    cout << head;    res_mes += deb_tos(head);}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";    res_mes += deb_tos(head) + \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";    res_mes += deb_tos(head) + \" \";    out2(tail...);    cout << \"\" << endl;    res_mes += \"\\n\";}\ntemplate<class T> void out(T head) {    cout << head << endl;    res_mes += deb_tos(head) + \"\\n\";}\nvoid out() { cout << \"\" << endl; }\n\n#else\n#define err(...);\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n#endif\n\n\ntemplate<class T> void outl(const vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {    rep(i, sz(a)) {        rep(j, sz(a[i])) { cout << a[i][j]; }        cout << endl;    }}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\n\n/*@formatter:off*/\ntemplate<class T> void na(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i];}\ntemplate<class T> void na(set<T> &a, ll n) { rep(i, n)a.insert(in()); }\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\ntemplate<class T> void nao(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T> void nad(set<T> &a, ll n) { rep(i, n)a.insert(in() - 1); }\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {    rep(i, n) {        a.insert(in());        b.insert(in());    }}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\n#define dna2d(a, b, n) vi a,b; na2d(a,b,n);\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a,b,c; na3(a,b,c,n);\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a,b,c; na3d(a,b,c,n);\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    d.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n)  vi a,b,c,d; na4(a,b,c,d,n);\n#define dna4d(a, b, c, d, n)  vi a,b,c,d; na4d(a,b,c,d,n);\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\n/*@formatter:off*/\n#define deb1(x)  debugName(x)<<\" = \"<<deb_tos(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n//#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n//#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n//#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n//#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n/*@formatter:off*/\n#ifdef _DEBUG\nbool was_deb = false;\n#define deb(...)  do{was_deb=true;cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl;}while(0)\n\n#define base_keta 8\nvoid print_n_base(int x, int base) { cerr << bitset<base_keta>(x) << endl; }\ntemplate<class T> void print_n_base(vector<T> X, int base) {cerr << endl;    for (auto &&x:X) { print_n_base(x, base); }    cerr << endl;}\n\n//n進数\n#define deb2(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#define deb_ex_deb(x, len)  debugName(x)<<\" = \"<<deb_tos(x, len)\n#define call_deb_ex_deb(x, len) deb_ex_deb(x, len)\n//要素が存在する行だけ出力(vvt)\n#define deb_ex(v) do {int N = sz(v);int s = N;int t = 0;rep(i, N) {if (sz(v[i])) {chmi(s, i);chma(t, i);}}auto ex_v = sub(v, s, N);str S = deb_tos(ex_v, sz(ex_v));debugName(v);cerr<<\" = \"<<endl;cerr << S << endl;} while (0);\n#define debi(A) {int len=min(sz(A),20); was_deb=true;cerr<<debugName(A)<<\" = \"<<endl;rep(i, len)cerr<<std::right << std::setw((int)(sz(tos(A[i]))+(i ? 1 : 0)))<<(i%10);cerr<<endl;rep(i, len)cerr<<std::right << std::setw((int)(sz(tos(A[i]))+(i ? 1 : 0)))<<A[i];cerr<<endl;}\n\ntemplate<class T, class F> string deb_tos_f(vector<vector<T> > &a, F f, int key = -1) {vi hs, ws_;    int H = sz(a), W = sz(a[0]);    vi exh(H), exw(W);    rep(h, H) {        rep(w, W) {            if (f(a[h][w])) {                exh[h] = true;                exw[w] = true;            }        }    }    rep(h, H) if (exh[h])hs.push_back(h);    rep(w, W) if (exw[w])ws_.push_back(w);    return deb_tos(a, hs, ws_, key);}\ntemplate<class T, class F> string deb_tos_f(vector<vector<vector<T>>> &a, F f) {stringstream ss;    int H = sz(a);    if (sz(a) == 0)return ss.str();    rep(i, H) { ss << deb_tos_f(a[i], f, i); }    ss << \"\" << endl;    return ss.str();}\n#define debf_normal(tab, f) do{cerr<<debugName(tab)<<\" = \"<<endl;cerr<< deb_tos_f(tab, f)<<endl;}while(0);\n#define debf2(tab, siki_r) debf_normal(tab, lamr(siki_r))\n#define debf3(tab, v, siki)  debf_normal(tab, lam(siki))\n//S, sikir\n//S, v, siki\n#define debf(...) over3(__VA_ARGS__,debf3,debf2,debf1)(__VA_ARGS__)\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#define deb_ex(...) ;\n#define debf(...) ;\n#define debi(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n/*@formatter:off*/\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {std::ostream::sentry s(dest);if (s) {__uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }return dest;}\n__int128 to_bint(string &s) {__int128 ret = 0;    for (ll i = 0; i < (ll) s.length(); ++i) if ('0' <= s[i] && s[i] <= '9') ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {string S;    iss >> S;    v = 0;    rep(i, sz(S)) {        v *= 10;        v += S[i] - '0';    }}\n\n//便利関数\n/*@formatter:off*/\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void) {static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;    unsigned long t;    t = (x ^ (x << 11));    x = y;    y = z;    z = w;    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max) { return rand(0, max); }\ntemplate<class T> T rand(vector<T> &A) { return A[rand(sz(A) - 1)]; }\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T> &A, int N) {vector<T> ret(N);    rep(i, N) { ret[i] = rand(A); }    return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T> &A, int N) {vector<T> ret(N);    umapi was;    rep(j, N) {        int i;        while (1) {            i = rand(sz(A) - 1);            if (was.find(i) == was.end())break;        }        ret[j] = A[i];        was[i] = 1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\n\n/*@formatter:off*/\n#ifdef _DEBUG\nbool timeup(int time) {static bool never = true;    if (never)message += \"may timeup, because slow\";    never = false;    auto end_time = system_clock::now();    auto part = duration_cast<milliseconds>(end_time - start_time);    auto lim = milliseconds(time);    return part >= lim;}\n#else\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n\n#endif\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {auto dec = duration_cast<nanoseconds>(past_time - start_time);    auto part = calc_time_nano();    auto can_time = nanoseconds(milli * 1000 * 1000);    can_time -= part;    can_time -= dec;    return div(can_time, part);}\n\n/*@formatter:off*/\n//#define use_rand\n#ifdef use_rand\nstr ransu(ll n) {str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n#endif\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class Iterable, class T = typename Iterable::value_type> vector<pair<T, int>> run_length(const Iterable &a) {vector<pair<T, int>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\n\n/*@formatter:off*/\n//#define use_mgr //_goldd _goldt\n#ifdef use_mgr\n//->[i, f(i)]\ntemplate<class T, class U, class F> auto mgr(T ok, U ng, const F &f, require_arg(is_integral<T>::value &&is_integral<U>::value)) {    auto mid = (ok + ng);    if (ok < ng)        while (ng - ok > 1) {            mid = (ok + ng) >> 1;            if (f(mid))ok = mid; else ng = mid;        }    else        while (ok - ng > 1) {            mid = (ok + ng) >> 1;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\n//[l, r)の中で,f(i)がtrueとなる範囲を返す okはそこに含まれる\ntemplate<class F> P mgr_range(int l, int r, F f, int ok) {if (f(ok) == 0) {        out(\"f(ok) must true\");        re();    }    return mp(mgr(ok, l - 1, f), mgr(ok, r, f) + 1);}\ntemplate<class F> auto mgrd(dou ok, dou ng, F f, int kai = 100) {if (ok < ng)        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    else        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\ntemplate<class F> dou mgrd_time(dou ok, dou ng, F f, int time = 1980) {bool han = true;    if (ok < ng)        while (1) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);            if (timeup(time)) { break; }        }    else        while (1) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);            if (timeup(time)) { break; }        }    return ok;}\n//todo 減らす\ntemplate<class F> auto goldd_l(ll left, ll right, F calc) {double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return make_tuple(resIndex, calc(resIndex));}\ntemplate<class F> auto goldt_l(ll left, ll right, F calc) {double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return make_tuple(resIndex, calc(resIndex));}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> auto goldd_d(dou left, dou right, F calc, ll loop = 200) {dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return make_tuple(left, calc(left));}\ntemplate<class F> auto goldt_d(dou left, dou right, F calc, ll loop = 200) {double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return make_tuple(left, calc(left));}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> auto goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(mini, calc(mini));}\ntemplate<class F> auto goldt_ls(ll l, ll r, F calc, ll time = 2000) {auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(maxi, calc(maxi));}\ntemplate<class F> auto goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(mini, calc(mini));}\ntemplate<class F> auto goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(maxi, calc(maxi));}\n#endif\n\n//strを整数として比較\nstring smax(str &a, str b) { if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else if (a < b)return b; else return a; }\n//strを整数として比較\nstring smin(str &a, str b) { if (sz(a) > sz(b)) { return b; } else if (sz(a) < sz(b)) { return a; } else if (a > b)return b; else return a; }\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {rep(i, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i * sz(a[0]) + j;return -1;}\ntemplate<typename W, typename U> tuple<int, int, int> find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return tuple<int, int, int>(i, j, k);    return tuple<int, int, int>(-1, -1, -1);}\n//無ければ-1\nint find(string &s, const string key) {    int klen = sz(key);    rep(i, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }return -1;}\nint find(string &s, int l, const string key) {    int klen = sz(key);    rep(i, l, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }    return -1;}\nint find(string &s, const char key) {    rep(i, sz(s)) { if (s[i] == key)return i; }    return -1;}\nint find(string &s, int l, const char key) {    rep(i, l, sz(s)) { if (s[i] == key)return i; }    return -1;}\n//N箇所について右のkeyの場所を返す\ntemplate<typename W, typename T> vi finds(const W &a, const T& key) {    int n = sz(a);    vi rpos(n, -1);    rer(i, n-1){        if(i<n-1){            rpos[i] = rpos[i+1];        }        if(a[i]==key)rpos[i] = i;    }    return rpos;}\ntemplate<typename W, typename T> vi rfinds(const W &a, const T& key) {    int n = sz(a);    vi lpos(n, -1);    rep(i, n){        if(i> 0){            lpos[i] = lpos[i-1];        }        if(a[i]==key)lpos[i] = i;    }    return lpos;}\n//todoz\n#if __cplusplus >= 201703L\ntemplate<typename W, typename T, class Iterable = typename W::value_type>\nll count(const W &a, const T &k) { return count_if(a, ==k); }\ntemplate<typename W, class Iterable = typename W::value_type> vi count(const W &a) {\n    vi res;\n    for_each(a, v, if (sz(res) <= (int) v)res.resize((int) v + 1);\n            res[v]++;);\n    return res;\n}\n#endif\nll count(const str &a, const str &k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\n/*@formatter:off*/\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l, int r) {    vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> auto rev(const vector<T> &a) {    auto b = a;    reverse(ALL(b));    return b;}\n/* ＼反転  */                                                                                        template<class U>\nauto rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    return b;}\n/* ｜反転  */                                                                                        template<class U>\nauto revw(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0])) { b[h][W - 1 - w] = a[h][w]; }    return b;}\n\n/* ー反転  */                                                                                        template<class U>\nauto revh(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int H = sz(a);    rep(h, sz(a)) rep(w, sz(a[0])) { b[H - 1 - h][w] = a[h][w]; }    return b;}\n\n/* ／反転  */                                                                                        template<class U>\nauto revr(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    int H = sz(a);    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[H - 1 - h][W - 1 - w];    return b;}\n\nauto rev(const string &a) {    string b = a;    reverse(ALL(b));    return b;}\ntemplate<class T> auto rev(const T &v, int i) {return v[sz(v) - 1 - i];}\nint rev(int N, int i) {return N-1-i;}\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v, int if_zero_res) { if(!v)return if_zero_res;if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else return 15; } else { if (v < p10[17]) { if (v < p10[16]) return 16; else return 17; } else { if (v < p10[18])return 18; else return 19; }}}}}\n#if __cplusplus >= 201703L\nll getr(ll a, ll keta) { return (a / pow<ll>(10, keta)) % 10; }\n#else\nll getr(ll a, ll keta) { return (a / (int)pow(10, keta)) % 10; }\n#endif\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a, 1);return getr(a, sketa - 1 - ket);}\nll dsum(ll v, ll sin = 10) {ll ret = 0;for (; v; v /= sin)ret += v % sin;return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n\ntemplate<class T, class U> auto to_v1(vector<reference_wrapper<U>>& ret, vector<T> &A) {    rep(i, sz(A))ret.push_back(A[i]);    return ret;}\ntemplate<class T, class U> auto to_v1(vector<reference_wrapper<U>>& ret, vector<vector<T> > &A) {rep(i, sz(A))to_v1(ret, A[i]);return ret;}\n//参照付きで1次元に起こす\ntemplate<class T> auto to_v1(vector<vector<T> > &A) {    vector<reference_wrapper<decl2_t<decltype(A)>>> ret;    rep(i, sz(A))to_v1(ret, A[i]);    return ret;}\n\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\n//空でも動く(なぜか)\ntemplate<class T> auto keys(const T &a) {vector<decltype((a.begin())->fi)> res;for (auto &&k :a)res.push_back(k.fi);return res;}\ntemplate<class T> auto values(const T &a) {vector<decltype((a.begin())->se)> res;for (auto &&k :a)res.push_back(k.se);return res;}\n//todo 可変長で\ntemplate<class T> constexpr T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\n//1次元のコンテナ\ntemplate<class T> int mini(const vector<T> &a) { return min_element(ALL(a)) - a.begin(); }\ntemplate<class T> int maxi(const vector<T> &a) { return max_element(ALL(a)) - a.begin(); }\ntemplate<class T> T sum(const T &A) {return A;}\ntemplate<class T> T sum(const vector<T> &A, int l = -1, int r = -1) {T s = 0;set_lr12(l, r, sz(A));rep(i, l, r)s += sum(A[i]);return s;}\n//1次元のIterableに使える\ntemplate<class T, require_t(!has_value_type<T>::value)>T min(T &a) { return a; }\ntemplate<class V, require_t(has_value_type<V>::value)>auto min(V &a, ll s = -1, ll n = -1) {    using Ret_t = decl2_t<V>;    auto ret = MAX<Ret_t>();    set_lr12(s, n, sz(a));    if (s == n) {        return INF<Ret_t>();    } else {        rep(i, s, n) {            ret = min(ret, min(a[i]));        }        return ret;    }}\ntemplate<class T, require_t(!has_value_type<T>::value)> T max(T &a) { return a; }\ntemplate<class V, require_t(has_value_type<V>::value)> auto max(V &a, ll s = -1, ll n = -1) {    using Ret_t = decl2_t<V>;    auto ret = MIN<Ret_t>();    set_lr12(s, n, sz(a));    if (s == n) { return -INF<Ret_t>(); }    else {        rep(i, s, n) { ret = max(ret, max(a[i])); }        return ret;    }}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {T ret = v[0];rep(i, 1, min(t, sz(v)))ret *= v[i];return ret;}\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\n//indexを持つvectorを返す\n\n/*@formatter:off*/\ntemplate<typename W, typename T> void fill(W &xx, const T vall) { xx = vall; }\ntemplate<typename W, typename T> void fill(vector<W> &vecc, const T vall) { for (auto &&vx     : vecc)fill(vx, vall); }\ntemplate<typename W, typename T> void fill(vector<W> &xx, const T v, ll len) { rep(i, len)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<W> &xx, const T v, int s, ll t) { rep(i, s, t)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, T v, int sh, int th, int sw, int tw) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\n//#define use_fill //_sum _array _max _min\n#ifdef use_fill\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N){fill(a[i], v);}}\ntemplate<class T, class U> void fill(vector<T> &a, const vi &ind, U val) { fora(v, ind) { a[v] = val; }}\ntemplate<typename A, size_t N> auto sum(A (&a)[N], int l = -1, int r = -1) {set_lr12(l, r, N);auto res = sum(a[l]);if (l == r) {return res - res;}rep(i, l + 1, r)res += sum(a[i]);return res;}\ntemplate<typename A, size_t N> auto max(A (&a)[N], int l = -1, int r = -1) {    set_lr12(l, r, N);    auto res = max(a[l]);    if (l == r) {        return -INF<decltype(res)>();    }    rep(i, l + 1, r)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> auto min(A (&a)[N], int l = -1, int r = -1) {    set_lr12(l, r, N);    auto res = min(a[l]);    if (l == r) {        return INF<decltype(res)>();    }    rep(i, l + 1, r)res = min(res, min(a[i]));    return res;}\n#endif\n\n\nvi inds_(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) { assert(ret[a[i]] ==-1);ret[a[i]] = i; }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int> &q) { q = priority_queue<int>(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\n//template<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\n//template<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n\n\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, sz(rui) - 1)); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin() { return rui.begin(); }\n    auto end() { return rui.end(); }\n};\ntemplate<class T> string deb_tos(const ruiC<T> &a) {return deb_tos(a.rui);}\ntemplate<class T> ostream &operator<<(ostream &os, ruiC<T> a) {    fora(v, a.rui){os << v << \" \"; }   return os;}\ntemplate<class T> vector<T> ruiv(const vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(const vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\ntemplate<class T> ruiC<T> ruic() { return ruiC<T>(); }\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n\n//#define use_rui //_imo _ruic _ruiv\n#ifdef use_rui\n//kと同じものの数\ntemplate<class T, class U> vi imo(const vector<T> &a, U k) {    vi equ(sz(a));    rep(i, sz(a)){        equ[i] = a[i]==k;    }    return imo(equ);}\ntemplate<class T> vector<T> imox(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(const vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(const vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruimax {\n    template<typename Monoid> struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN<T>(), -1);        Monoid f(Monoid a, Monoid b) { return max(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<int> ri;\n    bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        T ma = MIN<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -INF<T>();        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) { index = i; }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    int geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    int geti(int r = inf) { return geti(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> struct ruimin {\n    template<typename Monoid> struct SegmentTree {  /*pairで処理*/         int sz;vector<Monoid> seg;        const Monoid M1 = mp(MAX<T>(), -1);        Monoid f(Monoid a, Monoid b) { return min(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<int> ri;\n    bool build = false;\n    int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        T mi = MAX<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = INF<T>();        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) { index = i; }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    int geti(int l, int r) {        {            assert(l <= r && 0 <= l && r <= n);            if (l == 0) { return ri[r]; }            else {                if (!build)seg.build(ve), build = true;                return seg.query(l, r).second;            }        }        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    int geti(int r = inf) { return geti(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};/*@formatter:off*/\n\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) { rep(i, sz(a)) { res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1); }}    return res;}\nvector<ruiC<int>> ruibc(vi &a) {vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) { res[k][i] = (a[i] >> k) & 1; }        ret[k] = ruic(res[k]);    }    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC<T> dummy;//変なのをよばれたときはこれを返す//todo\n    ruiC2(const vector<vector<T>> &ru) : rui(sz(ru)), H(sz(ru)) {            for (int h = 0; h < H; h++) {                if (sz(ru[h]) == 0)continue;                if (sz(dummy) == 1) dummy = ruic(vector<T>(sz(ru[h])));                rui[h] = ruic(ru[h]);            }        }\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {            if (l > r) {                cerr << \"ruic \";                deb(l, r);                assert(0);            }            vector<T> res(H);            for (int h = 0; h < H; h++)res[h] = rui[h](l, r);            return res;        }\n    //HについてWを返す\n    ruiC<T> &operator[](ll h) {\n#ifdef _DEBUG\n        if (h >= H) {message += \"warning ruiC h >= H\";}\n#endif\n        if (h >= H || sz(rui[h]) == 1)return dummy;else return rui[h];\n    }\n    /*@formatter:off*/\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\ntemplate<class T, class U> ruiC<ll> ruicou(vector<T> &a, U b) {    vi cou(sz(a));    rep(i, sz(a)) { cou[i] = a[i] == b; }    return ruic(cou);}\n\n//メモリは形式によらず(26*N)\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\n// 添え字は'a', 'A'のまま扱う (予め-='a','A'されているものが渡されたらそれに従う)\ntemplate<typename Iterable, class is_Iterable = typename Iterable::value_type>\nruiC2<ll> ruicou(const Iterable &a) {        int H = max(a) + 1;        vvi(cou, H);        rep(i, sz(a)) {            if (sz(cou[a[i]]) == 0)cou[a[i]].resize(sz(a));            cou[a[i]][i] = 1;        }        return ruiC2<ll>(cou);    }\n\n\n/*@formatter:off*/\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v));    rep(h, sz(ret)) { ret[h] = v[h][w]; }    rep(i, sz(ret) - 1) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v) + 1);    rep(h, sz(v)) { ret[h + 1] = v[h][w]; }    rep(i, sz(v)) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {    vector<T> ret = ruih(a, w);    return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {\n    vector<T> rui;\n    ruixC(vector<T> &ru) : rui(ru) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }\n    T operator[](ll i) { return rui[i]; }\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T> &a) {    vi ret = ruix(a);    return ruixC<ll>(ret);}\n//差分を返す(累積を取ると元に戻る)\n//101なら\n//1111を返す\n//元の配列で[l, r)へのxorは\n//[l]と[r]へのxorになる https://atcoder.jp/contests/abc155/tasks/abc155_f\nvi ruix_diff(vi &A) {    int N = sz(A);    assert(N);    vi res(N + 1);    res[0] = A[0];    rep(i, 1, N) { res[i] = A[i - 1] ^ A[i]; }    res[N] = A[N - 1];    return res;}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {        rui.resize(n + 1);        rer(i, n - 1) { rui[i] = rui[i + 1] + a[i]; }    }\n    /*[r l)*/\n    T operator()(int r, int l) {        r++;        l++;        assert(l <= r && l >= 0 && r <= n);        return rui[l] - rui[r];    }\n    T operator()(int l) { return operator()(n - 1, l); }\n    T operator[](int i) { return operator()(i); }\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {    fora(v, a.rui){os << v << \" \"; }   return os;}\ntemplate<class T> string deb_tos(rruiC<T> &a) {return deb_tos(a.rui);}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {        rv.resize(n + 1);        rv[0] = 1;        rep(i, n) { rv[i + 1] = a[i] * rv[i]; }    }\n    ruimulC() : n(0) {        rv.resize(n + 1);        rv[0] = 1;    }\n    void operator+=(T v) {        rv.push_back(rv.back() * v);        n++;    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        return rv[r] / rv[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {    vector<T> a;    return ruimulC<T>(a);}\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U, class W> T lowerBound(ruiC <T> &a, U v, W banpei) { return lowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T upperBound(ruiC <T> &a, U v, W banpei) { return upperBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rlowerBound(ruiC <T> &a, U v, W banpei) { return rlowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rupperBound(ruiC <T> &a, U v, W banpei) { return rupperBound(a.rui, v, banpei); }\n#endif\n\nconstexpr bool bget(ll m, ll keta) {\n#ifdef _DEBUG\n    assert(keta <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (m >> keta) & 1;\n}\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi &a, int keta_size) {    vvi(res, keta_size, sz(a));    rep(k, keta_size) { rep(i, sz(a)) { res[k][i] = bget(a[i], k); }}    return res;}\nvi bget1(vi &a, int keta) {    vi res(sz(a));    rep(i, sz(a)) { res[i] = bget(a[i], keta); }    return res;}\n#if __cplusplus >= 201703L\nll bget(ll m, ll keta, ll sinsuu) {    m /= pow<ll>(sinsuu, keta);    return m % sinsuu;}\n#else\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll)pow(sinsuu, keta);    return m % sinsuu;}\n#endif\nconstexpr ll bit(ll n) {\n#ifdef _DEBUG\n    assert(n <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (1LL << (n));\n}\n#if __cplusplus >= 201703L\nll bit(ll n, ll sinsuu) { return pow<ll>(sinsuu, n); }\n#else\nll bit(ll n, ll sinsuu) { return (ll)pow(sinsuu, n); }\n#endif\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(const vi &a) {    int m = 0;    for (auto &&v:a) m |= bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bit_bool(vi &a) {    int m = 0;    rep(i, sz(a)) if (a[i])m |= bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { assert(n);return n & -n; }\nll lbiti(ll n) { assert(n);return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    assert(n);n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n) { assert(n);return log2(hbit(n)); }\n//ll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n/*over*/#define forbit1_2(i, mas) for (int forbitj = !mas ? 0 : lbit(mas), forbitm = mas, i = !mas ? 0 :log2(forbitj); forbitm; forbitm = forbitm ^ forbitj, forbitj = !forbitm ? 1 : lbit(forbitm), i = log2(forbitj))\n/*over*/#define forbit1_3(i, N, mas) for (int forbitj = !mas ? 0 : lbit(mas), forbitm = mas, i = !mas ? 0 :log2(forbitj); forbitm  && i < N; forbitm = forbitm ^ forbitj, forbitj = !forbitm ? 1 : lbit(forbitm), i = log2(forbitj))\n//masの立ってるindexを見る\n//              i, [N], mas\n#define forbit1(...) over3(__VA_ARGS__, forbit1_3, forbit1_2)(__VA_ARGS__)\n//masが立っていないindexを見る\n//              i, N, mas\n#define forbit0(i, N, mas) forbit1(i, mask(N) & (~(mas)))\n\n//forsubをスニペットして使う\n//Mの部分集合(0,M含む)を見る 3^sz(S)個ある\n#define forsub_all(m, M) for (int m = M; m != -1; m = m == 0 ? -1 : (m - 1) & M)\n//BASE進数\ntemplate<size_t BASE> class base_num {\n    int v;\npublic:\n    base_num(int v = 0) : v(v) {};\n    int operator[](int i) { return bget(v, i, BASE); }\n    void operator++() { v++; }\n    void operator++(signed) { v++; }\n    operator int() { return v; }\n};\n#define base3(mas, lim, BASE) for (base_num<BASE> mas; mas < lim; mas++)\n#define base2(mas, lim) base3(mas, lim, 2)\n#define base(...) over3(__VA_ARGS__,base3,base2,base1)(__VA_ARGS__)\n\n\n//aにある物をtrueとする\nvb bool_(vi a, int n) {    vb ret(max(max(a) + 1, n));    rep(i, sz(a))ret[a[i]] = true;    return ret;}\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    res = rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n//#define use_compress\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(ALL(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\n#ifdef use_compress\n//ind[i] := i番目に小さい数\n//map[v] := vは何番目に小さいか\nvi compress(vi &a, umapi &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(ALL(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a){b.push_back(v);}    fora(v, r){b.push_back(v);}    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(ALL(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(ALL(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a){b.push_back(v);}    fora(v, r){b.push_back(v);}    fora(v, s){b.push_back(v); }   sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(ALL(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(ALL(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(ALL(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a){fora(v, vv){b.push_back(v);}}    sort(b);    unique(b);    fora(vv, a){fora(v, vv){v = lower_bound(ALL(b), v) - b.begin(); }}   ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a){fora(vv, vvv){fora(v, vv){b.push_back(v);}}}    sort(b);    unique(b);   fora(vvv, a){fora(vv, vvv){fora(v, vv){v = lower_bound(ALL(b), v) - b.begin();}}}    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(ALL(b), a[i]) - b.begin(); }}\n#endif\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(ALL(a),v))\n#define lowerIndex(a, v) (lower_bound(ALL(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(ALL(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(ALL(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(ALL(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\n//todo 消せないか\ntemplate<class T, class U, class W> T lowerBound(set<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(set<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n\ntemplate<class T, class U, class W> T lowerBound(mset<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(mset<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\n//ll pow(ll a) { return a * a; };\ntemplate<class T> T fact(int v) {    static vector<T> fact(2, 1);    if (sz(fact) <= v) { rep(i, sz(fact), v + 1) { fact.emplace_back(fact.back() * i); }}    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\n//二項係数の偶奇を返す\nint com_mod2(int n,int r){return n == ( r | (n - r) );}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\n#define gcd my_gcd\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\n#define lcm my_lcm\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n#define hypot my_hypot\ndouble hypot(double dx, double dy){return std::sqrt(dx*dx+ dy*dy);}\n\nll sig0(int t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\nbint sig0(bint t) {return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n//b * res <= aを満たす [l, r)を返す div\nP drange_ika(int a, int b) {    P null_p = mp(linf, linf);    if (b == 0) {        if (a >= 0) {            return mp(-linf, linf + 1)/*全て*/;        } else {            return null_p/*無い*/;        }    } else {        if (a >= 0) {            if (b > 0) {                return mp(-linf, a / b + 1);            } else {                return mp(-(a / -b), linf + 1);            }        } else {            if (b > 0) {                return mp(-linf, -ceil(-a, b) + 1);            } else {                return mp(ceil(-a, -b), linf + 1);            }        }    }}\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n//todo stringもセットで\ntemplate<class T> vector<T> sub(const vector<T> &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    vector<T> ret(r - l);    std::copy(A.begin() + l, A.begin() + r, ret.begin());    return ret;}\ntemplate<class T> vector<T> sub(const vector<T> &A, int r) { return sub(A, 0, r); }\ntemplate<class T> vector<T> subn(const vector<T> &A, int l, int len) { return sub(A, l, l + len); }\nstring sub(string &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    return A.substr(l, r - l);}\ntemplate<class T, class F>\n//sub2で呼ぶ\nvector<T> sub(const vector<vector<T> >& A, int h, int w, int ah,int aw, F f){    vector<T> res;    while(0<= h && h < sz(A) && 0 <= w && w < sz(A[h]) && f(A[h][w])){        res.emplace_back(A[h][w]);        h += ah;        w += aw;    }    return res;}\ntemplate<class T> vector<T>sub(const vector<vector<T> >& A, int h, int w, int ah,int aw){return sub(A, h, w, ah, aw, [&](T v){return true;});}\n//range_nowを返す(find_ifでしか使われない)\n#if __cplusplus >= 201703L\ntemplate<class T> auto subr(const vector<T> &A, int l) {return range_now(vector<T>(A.begin()+l, A.end()), l);}\n#endif\n#define sub25(A, h, w, ah, aw) sub(A, h, w, ah, aw)\n#define sub26(A, h, w, ah, aw, siki_r) sub(A, h, w, ah, aw, [&](auto v){return v siki_r;})\n#define sub27(A, h, w, ah, aw, v, siki) sub(A, h, w, ah, aw, [&](auto v){return siki;})\n#define sub2(...) over7(__VA_ARGS__,sub27,sub26,sub25)(__VA_ARGS__)\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\ntemplate<class T> int count(set<T> &S, T l, T r) {    assert(l < r);    auto it = S.lower_bound(l);    return it != S.end() && (*it) < r;}\n\n//template<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\ntemplate<class T> vector<T> geth(vector<vector<T>> &S, int w) {    assert(w < sz(S[0]));    vector<T> ret(sz(S));    rep(h, sz(S)) { ret[h] = S[h][w]; }    return ret;}\n//vector<bool>[i]は参照を返さないため、こうしないとvb[i] |= trueがコンパイルエラー\nvb::reference operator|=(vb::reference a, bool b){return a = a | b;}\nvb::reference operator&=(vb::reference a, bool b){return a = a & b;}\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T, U> operator+(const pair<T, U> &a, const pair<T, U> &b) { return pair<T, U>(a.fi + b.fi, a.se + b.se); }\ntemplate<class T, class U> pair<T,U> operator-(const pair<T,U> &a, const pair<T,U> & b) {return pair<T,U>(a.fi-b.fi,a.se-b.se);}\ntemplate<class T, class U> pair<T,U> operator-(const pair<T, U>& a){return pair<T, U>(-a.first, -a.second);}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {\n#ifdef _DEBUG\n    static bool was = false;if (!was)message += \"str += 65  is  'A'  not \\\"65\\\" \";was = true;\n#endif\n    return lhs + (char) rv;\n}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs = lhs + rv;}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    const int rv2 = rv;    return lhs + rv2;}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {const int v = rv; lhs += v; }\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {    auto bek = s;    s = \"\";    for (; num; num >>= 1) {        if (num & 1) { s += bek; }        bek += bek;    }}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v){a.push(d);}    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v){a.insert(d);}    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(U v,const vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(const vector<T>& a, const vector<T>& b) {    vector<T> ret;    ret = a;    fora(v, b){ret += v; }   return ret;}template<class T> vector<T> &operator+=(vector<T> &a,const vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    for(auto&& bv : b) { a[bv.first] += bv.second; }    return a;}template<class T, class U> vector<T> operator+(const vector<T> &a, const U& v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> auto operator+=(uset<T> &a, U v) { return a.insert(v); }\ntemplate<class T> vector<T> operator%(vector<T>& a, int v){    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = a[i] % v;    }    return ret;}\ntemplate<class T> vector<T> operator%=(vector<T>& a, int v){    rep(i,sz(a)){        a[i] %= v;    }    return a;}\nvi operator&(vi& a, vi& b){    assert(sz(a)==sz(b));    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = min(a[i],b[i]);    }    return ret;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\n//template<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<typename T> void pop_front(vector<T> &v) { erase(v, 0); }\ntemplate<typename T> void entry(vector<T> &v, unsigned ll s, unsigned ll e) { erase(v, e, sz(v));erase(v,0,s);}\n\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\nvector<string> split(const string &a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string &a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nll stoi(string& s){return stol(s);}\n#define assert_yn(yn_v, v); assert(yn_v == 0 || yn_v == v);yn_v = v;\n//不完全な対策、現状はautohotkeyで対応\nint yn_v = 0;\nvoid yn(bool a) { assert_yn(yn_v, 1);if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid fyn(bool a) {    assert_yn(yn_v, 1);yn(a);    exit(0);}\n\nvoid Yn(bool a) { assert_yn(yn_v, 2);if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid fYn(bool a) {    assert_yn(yn_v, 2);Yn(a);    exit(0);}\n\nvoid YN(bool a) { assert_yn(yn_v, 3);if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fYN(bool a) {    assert_yn(yn_v, 3);YN(a);    exit(0);}\nint ab_v = 0;\nvoid fAb(bool a) { assert_yn(ab_v, 1);if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid fAB(bool a) { assert_yn(yn_v, 2);if(a)cout<<\"ALICE\"<<endl;else cout<<\"BOB\";}\nint pos_v = 0;\nvoid Possible(bool a) {    assert_yn(pos_v, 1);if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    assert_yn(pos_v, 2);if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\nvoid fPossible(bool a) {    assert_yn(pos_v, 1)Possible(a);exit(0);}\nvoid fPOSSIBLE(bool a) {    assert_yn(pos_v, 2)POSSIBLE(a);exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename Iterable> vector<Iterable> table(const Iterable &a, int tou = 2) {int N = sz(a);    vector<Iterable> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename Iterable> vector<Iterable> table_n(const Iterable &a, int len) {    int N = sz(a);    vector<Iterable> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//縦を返す\nvi& geth(vvi()& a, int w){    static vi ret; ret.resize(sz(a));   rep(i,sz(a)){        ret[i] = a[i][w];    }    return ret;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n//#define pre prev\n//#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\nvc atoz = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x','y', 'z'};\nvc AtoZ = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z'};\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))return i;    }    return i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))return i; }    return i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\n\n//H*Wのグリッドを斜めに分割する\n//右上\nvector<vp> naname_list_ne(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[sh] += mp(nh, nw);            }else{                break;            }        }    }    rep(sw, 1, W) {        int sh = H - 1;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[H + sw-1] += mp(nh, nw);            }else{                break;            }        }    }    return res;}\n//右下\nvector<vp> naname_list_se(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh< H && nw < W) { res[sh] += mp(nh, nw); } else { break; }        }    }    rep(sw, 1, W) {        int sh = 0;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh < H && nw < W) { res[H + sw - 1] += mp(nh, nw); } else { break; }        }    }    return res;}\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) ((h) * (W) + (w))\n#define getid_1(p) ((p).first * W + (p).second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nvb bit_bool(int v, int len) {    assert(bit(len) > v);    vb ret(len);    rep(i, len) { ret[i] = bget(v, i); }    return ret;}\nvi range(int l, int r) {vi ret;ret.resize(r - l);rep(v, l, r) {ret[v - l] = v;}return ret;}\nvi range(int r) {return range(0, r);}\nvi tov(vb& a){    vi ret;    rep(i,sz(a)){        if(a[i])ret.push_back(i);    }    return ret;}\nbool kaibun(const str& S){return S==rev(S);}\ntemplate<class T> vector<T> repeat(const vector<T> &A, int kaisu) {    vector<T> ret;    while (kaisu--) {        ret += A;    }    return ret;}\n#define rge range\n#define upd update\n//S[{s, t, d}]\n#define strs slice_str\nstruct slice_str {\n    string S;\n    slice_str() {}\n    slice_str(const string &S) : S(S) {}\n    slice_str(int len, char c) : S(len, c) {}\n    auto size(){return S.size();}\n    char& operator[](int p) {        return S[p]; }\n    string operator[](initializer_list<int> p) {        if (sz(p) == 1) {            return S.substr(0, *(p.begin()));        } else if (sz(p) == 2) {            int l = *(p.begin());            int r = *(next(p.begin()));            return S.substr(l, r - l);        } else {            auto it = p.begin();            int s = *(it++);            int t = *(it++);            int d = *(it);            if (d == -1) {                int s_ = sz(S) - s - 1;                int t_ = sz(S) - t - 1;                return rev(S).substr(s_, t_ - s_);            } else if (d < 0) {                t = max(-1ll, t);                string ret;                while (s > t) {                    ret += S[s];                    s += d;                }                return ret;            } else {                t = min(sz(S), t);                string ret;                while (s < t) {                    ret += S[s];                    s += d;                }                return ret;            }        }    }\n    operator string &() {        return S;    }\n    template<class T> void operator+=(const T &a) { S += a; }\n    bool operator==(const slice_str& rhs){return S==rhs.S;}\n};\nostream &operator<<(ostream &os, const slice_str &a) {    os << a.S;    return os;}\nistream &operator>>(istream &iss, const slice_str &a) {    iss >> a.S;    return iss;}\ntemplate<class T> bool can(const T &v, int i) { return 0 <= i && i < sz(v); }\n#if __cplusplus >= 201703L\n//template<class T> auto sum(int a, T  v...) {return (v + ... + 0);}\n#endif\n#define VEC vector\n#endif /*UNTITLED15_TEMPLATE_H*/\n\n#endif\n\n//† ←template終了\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n\n#ifndef MINT\n#define MINT\n/*@formatter:off*/\ntemplate<typename T> T minv(T a, T m);\ntemplate<typename T> T minv(T a);\ntemplate<typename T> class Modular {public:using Type = typename decay<decltype(T::value)>::type;    constexpr Modular() : value() {}    template<typename U> Modular(const U &x) { value = normalize(x); }    template<typename U> static Type normalize(const U &x) {        Type v;        if (-mod() <= x && x < mod()) v = static_cast<Type>(x); else v = static_cast<Type>(x % mod());        if (v < 0) v += mod();        return v;    }    const Type &operator()() const { return value; }    template<typename U> explicit operator U() const { return static_cast<U>(value); }    constexpr static Type mod() { return T::value; }    Modular &operator+=(const Modular &other) {        if ((value += other.value) >= mod()) value -= mod();        return *this;    }    Modular &operator-=(const Modular &other) {        if ((value -= other.value) < 0) value += mod();        return *this;    }    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }    Modular &operator++() { return *this += 1; }    Modular &operator--() { return *this -= 1; }    Modular operator++(signed) {        Modular result(*this);        *this += 1;        return result;    }    Modular operator--(signed) {        Modular result(*this);        *this -= 1;        return result;    }    Modular operator-() const { return Modular(-value); }    template<typename U = T> typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;asm(\"divl %4; \\n\\t\": \"=a\" (d), \"=d\" (m): \"d\" (xh), \"a\" (xl), \"r\" (mod()));value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;    }    template<typename U = T> typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());        value = normalize(value * rhs.value - q * mod());        return *this;    }    template<typename U = T> typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {        value = normalize(value * rhs.value);        return *this;    }    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value)); }    template<typename U> friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend std::istream &operator>>(std::istream &stream, Modular<U> &number);    operator int() { return value; }private:    Type value;\n};\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\ntemplate<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\ntemplate<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator%(const Modular<T> &lhs, U rhs) {    cerr << \"can't  mint % int\" << endl;    assert(0);    exit(0);    return 0;}\n\nconstexpr signed MOD =\n        998244353;\n//        1e9 + 7;//MOD\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n#ifdef optional\ntemplate<class T> optional<mint> operator+(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv + opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator-(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator*(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator/(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv / opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator+(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv + opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator-(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator*(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator/(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv / opt.value(); else return optional<mint>(); }\ntemplate<class T> void operator+=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv += opt.value(); }\ntemplate<class T> void operator-=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv -= opt.value(); }\ntemplate<class T> void operator*=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv *= opt.value(); }\ntemplate<class T> void operator/=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv /= opt.value(); }\ntemplate<class T> void operator+=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value += mv;}\ntemplate<class T> void operator-=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value -= mv;}\ntemplate<class T> void operator*=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value *= mv;}\ntemplate<class T> void operator/=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value /= mv;}\n#endif\n//constexpr int mint_len = std::min(1400001, MOD);\nvi fac, finv, inv;\nvi p2;\nvoid setmod_resize(int mint_len) {\n//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n    int tn = sz(fac);\n    fac.resize(mint_len);\n    finv.resize(mint_len);\n    inv.resize(mint_len);\n    inv[1] = fac[0] = finv[0] = 1;\n    for (int i = tn; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    for (int i = tn; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n}\n//4e6 >= n なら O(r)で計算する\nmint com_big(int n, int r) {    int fa = finv[r];    rep(i, r)fa *= n - i, fa %= MOD;    return mint(fa);}\nmint com(int n, int r) {if (r < 0 || r > n) return 0;    /*nが大きくてrが小さい場合、nを上からr個掛ける*/    if (n >= sz(fac)) { if (n <= 4e6)setmod_resize(n + 1000); else return com_big(n, r); }return mint(finv[r] * fac[n] % MOD * finv[n - r]);}\nmint pom(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;return mint(fac[n] * finv[n - r]);}\nmint npr(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;return mint(fac[n] * finv[n - r]);}\nmint com_grid(int n, int r) {assert(r);return com(n + r - 2, n - 1);}\nint nprin(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;return fac[n] * finv[n - r] % MOD;}\nint icom(int n, int r) {    const int NUM_ = 1400001;    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];    if (fac[0] == 0) {        inv[1] = fac[0] = finv[0] = 1;        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;    }    if (r < 0 || r > n) return 0;    return ((finv[r] * fac[n] % MOD) * finv[n - r]) % MOD;}\n#define ncr com\n#define ncri icom\n//n種類でr個選ぶ\n//n個の場所にr個の物を置く\n//負が渡された場合もcomが処理出来る\nmint nhr(int n, int r) { if (n == 0 && r == 0)return 1; else return com(n + r - 1, r); }\n//n種類でそれぞれ少なくとも1つは選び、r個揃える\nmint nhr1(int n, int r) { return nhr(n, r - n); }\nmint hom(int n, int r) { if (n == 0 && r == 0)return 1; else return com(n + r - 1, r); }\nint nhri(int n, int r) { if (n == 0 && r == 0)return 1; else return icom(n + r - 1, r); }\n//グリッドで0-indexedの最短経路 pascal\nmint pas(int h, int w) { return com(h + w, w); }\ntemplate<typename T> T minv(T a, T m) {    T u = 0, v = 1;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T> T minv(T a) {    if (a < sz(fac))return inv[a];    T u = 0, v = 1;    T m = MOD;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\n//int型 mod m\ntemplate<typename T, typename U, typename V> int mpow(const T a, const U b, const V m) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {    assert(b >= 0);    int x = a(), res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\n//-k乗出来る\ntemplate<typename T, typename U> mint mpow(const T a, const U b) {/*    assert(b >= 0);*/    if (b < 0) { return minv(mpow(a, -b)); }    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<class T> mint mpow(bint a, const T b) { return mpow((mint) a, b); }\ntemplate<typename T, typename U, typename V> int mpowi(const T &a, const U &b, const V &m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T> string to_string(const Modular<T> &number) { return to_string(number()); }\n#ifdef _DEBUG\nvoid yuri(const mint &a) {    stringstream st;    rep(i, 300) {        rep(j, 300) {            if ((mint) i / j == a) {                st << i << \" / \" << j;                i = 2000;                break;            }        }    }    string val = st.str();    if (val != \"\") {        deb(val);        return;    }    rep(i, 1000) {        rep(j, 1000) {            if ((mint) i / j == a) {                st << i << \" / \" << j;                i = 2000;                break;            }        }    }    val = st.str();    deb(val);}\n#else\n#define yuri(...) ;\n#endif\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n    stream << number();\n#ifdef _DEBUG\n//    stream << \" -> \" << yuri(number);\n#endif\n    return stream;\n}\n//@formatter:off\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {    typename common_type<typename Modular<T>::Type, int64_t>::type x;    stream >> x;    number.value = Modular<T>::normalize(x);    return stream;}\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\nusing mapm = map<int, mint>;\nusing umapm = umap<int, mint>;\n#define vvm(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(mint,__VA_ARGS__)\n#define vnm(name, ...) auto name = make_v<mint>(__VA_ARGS__)\nstring out_m2(mint a) {    stringstream st;    st<<(int)a ;    rep(i, 300) {        rep(j, 2, 300) {            if ((i%j)&&(mint) i / j == a) {                st <<\"(\"<< i << \"/\" << j<<\")\";                i = 2000;                break;            }        }    }    return st.str();}\n//nhr n個の場所にr個の物を分ける\nmint m1 = (mint) 1;\nmint half = (mint) 1 / 2;\nstruct setmod{\n    //comで長さが足りない場合はsetmod_resizeでリサイズする\n    int mint_len =1.4*1e6;\n    setmod() {\n    //p2を使う場合setmod_resizeも変える\n//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n        fac.resize(mint_len);    finv.resize(mint_len);    inv.resize(mint_len);    inv[1] = fac[0] = finv[0] = 1;    for (int i = 2; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;    for (int i = 1; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n}}setmodv;\ntemplate<signed S> using mint_ = Modular<std::integral_constant<decay<signed>::type, S>>;\n#endif\n/*@formatter:on*/\n\nvoid solve() {\n    using Mint = mint;\n    int n;\n    cin >> n;\n    vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n    for (int r = 0; r < 3; r++) {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            --x; --y;\n            if (x > y) {\n                swap(x, y);\n            }\n            g[r][x].push_back(y);\n        }\n    }\n    Mint p = (long long) 1e18;\n    vector<Mint> pw(n);\n    pw[0] = p;\n    for (int i = 1; i < n; i++) {\n        pw[i] = pw[i - 1] * p;\n    }\n    const int MAX = 512;\n    vector<vector<Mint>> cnt(3, vector<Mint>(MAX));\n    for (int r = 0; r < 3; r++) {\n        vector<int> gr(n);\n        for (int i = n - 1; i >= 0; i--) {\n            set<int> s;\n            for (int j : g[r][i]) {\n                s.insert(gr[j]);\n            }\n            while (s.find(gr[i]) != s.end()) {\n                ++gr[i];\n            }\n            cnt[r][gr[i]] += pw[i];\n        }\n    }\n    Mint ans = 0;\n    for (int x = 0; x < MAX; x++) {\n        for (int y = 0; y < MAX; y++) {\n            ans += cnt[0][x] * cnt[1][y] * cnt[2][x ^ y];\n        }\n    }\n    cout << ans << '\\n';\n\n}\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n        //solveを書き直す\n        //solveを呼び出す\n    }\n    if (was_deb && sz(res_mes)) {\n        cerr << \"result = \" << endl << res_mes << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << \"Note.\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 555555;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nint n;\nvector<vii> G(3);\nvector<vii> num(3, vii(500));\n\nvoid solve(int idx, vii G) {\n    vi g(n);\n    rrep (u, n) {\n        set<int> st;\n        for (int v: G[u]) {\n            if (v > u) st.insert(g[v]);\n        }\n\n        rep (gl, 50000) {\n            if (not st.count(gl)) {\n                g[u] = gl;\n                num[idx][gl].push_back(u);\n                break;\n            }\n        }\n    }\n}\n\nsigned main() {\n    cin >> n;\n    rep (i, 3) {\n        G[i].resize(n);\n        int m;\n        cin >> m;\n        rep (j, m) {\n            int u, v;\n            cin >> u >> v;\n            u--; v--;\n            G[i][u].push_back(v);\n            G[i][v].push_back(u);\n        }\n    }\n\n    rep (i, 3) {\n        solve(i, G[i]);\n        // DEBUG(i);\n        // rep (j, 5) {\n        //     rep (k, num[i][j].size()) {\n        //         cout << num[i][j][k] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n    }\n\n    ll base = mod_pow(10, 18);\n    vll sum(3, vl(500));\n    rep (i, 3) {\n        rep (j, 500) {\n            for (int u: num[i][j]) {\n                (sum[i][j] += mod_pow(base, u + 1)) %= MOD;\n            }\n        }\n    }\n\n    ll ans = 0;\n    rep (x, 500) {\n        rep (y, 500) {\n            int z = x ^ y;\n            ll mul2 = sum[2][z];\n            ll mul1 = sum[1][y];\n            ll mul0 = sum[0][x];\n            (ans += mul0 * mul1 % MOD * mul2 % MOD) %= MOD;\n            // if (mul0 * mul1 % MOD * mul2 % MOD != 0) {\n            //     DEBUG_VEC(vi({z, y, x}));\n            //     DEBUG_VEC(vl({mul2, mul1, mul0}));\n            // }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nmt19937 mt(736);\n\nconst int mod = 998244353;\n\n\nint powmod10(int n)\n{\n\tstatic vector<int> dp = {1};\n\n\twhile (n >= dp.size())\n\t\tdp.push_back((10ll * dp.back()) % mod);\n\n\treturn dp[n];\n}\n\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint n;\n\n\tcin >> n;\n\n\tarray<vector<vector<int>>, 3> xyz;\n\n\tfor (auto &gr : xyz)\n\t{\n\t\tgr.resize(n);\n\n\t\tint m;\n\n\t\tcin >> m;\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\n\t\t\tcin >> a >> b;\n\t\t\ta--;\n\t\t\tb--;\n\n\t\t\tgr[a].push_back(b);\n\t\t\tgr[b].push_back(a);\n\t\t}\n\t}\n\n\tarray<vector<int>, 3> mex;\n\n\tarray<ll, 3> wm{}, bm{};\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tmex[i].resize(n, -1);\n\n\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t{\n\t\t\tunordered_set<int> neigh;\n\n\t\t\tfor (auto it : xyz[i][j])\n\t\t\t\tneigh.insert(it);\n\n\t\t\tfor (mex[i][j] = 0; neigh.count(mex[i][j]); mex[i][j]++);\n\t\t}\n\t}\n\n\tarray<vector<int>, 3> grundy;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tgrundy[i].resize(*max_element(mex[i].begin(), mex[i].end()) + 1);\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tgrundy[i][mex[i][j]] += powmod10(18 * (j + 1));\n\t}\n\n\tll ans = 0;\n\n\tfor (int x = 0; x < grundy[0].size(); x++)\n\t\tfor (int y = 0; y < grundy[1].size(); y++)\n\t\t{\n\t\t\tauto z = x ^y;\n\n\t\t\tif (z < grundy[2].size())\n\t\t\t\tans += grundy[0][x] * grundy[1][y] % mod * grundy[2][z] % mod;\n\t\t}\n\n\tcout << ans % mod << endl;\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcout << fixed;\n\n#ifdef LOCAL\n\tauto st = clock();\n\n\tifstream fin(\"../input.txt\");\n\n\tsolve(fin);\n\n\tcout << \"clock: \" << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tsolve();\n#endif\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <set>\n#include <chrono>\n#include <string>\n\nusing namespace std;\n\n#define endl '\\n'\n\nconst int mod = 998244353;\n\nint modexp(int a, int n)\n{\n    int b = 1;\n\n    while (n)\n    {\n        if (n & 1)\n        {\n            b = 1LL * a * b % mod;\n        }\n\n        n >>= 1;\n        a = 1LL * a * a % mod;\n    }\n    return b;\n}\n\nvoid add(int &a, int b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t18 = modexp(10, 18);\n\n    int n;\n    cin >> n;\n\n    vector<int> p18(n + 1);\n    p18[0] = 1;\n    for (int i = 1; i <= n; ++i)\n    {\n        p18[i] = 1LL * p18[i - 1] * t18 % mod;\n    }\n\n    vector<int> grundy(1, 1);\n\n    for (int i = 0; i < 3; ++i)\n    {\n        int m;\n        cin >> m;\n\n        vector<vector<int>> adj(n);\n\n        for (int j = 0; j < m; ++j)\n        {\n            int u, v;\n            cin >> u >> v;\n            u--;\n            v--;\n            if (u > v)\n                swap(u, v);\n            adj[u].push_back(v);\n        }\n\n        vector<int> c_grundy(n);\n        vector<int> n_grundy;\n\n        int one = 0, zero = 0;\n\n        for (int j = n - 1; j >= 0; --j)\n        {\n            set<int> s;\n            for (auto u : adj[j])\n                s.insert(c_grundy[u]);\n\n            int g = 0;\n            while (s.count(g))\n                g++;\n\n            c_grundy[j] = g;\n            while (n_grundy.size() <= g)\n                n_grundy.push_back(0);\n            add(n_grundy[g], p18[j + 1]);\n        }\n\n        vector<int> a_grundy;\n\n        for (int u = 0; u < grundy.size(); ++u)\n        {\n            for (int v = 0; v < n_grundy.size(); ++v)\n            {\n                int t = u ^ v;\n                while (a_grundy.size() <= t)\n                    a_grundy.push_back(0);\n\n                add(a_grundy[t], 1LL * grundy[u] * n_grundy[v] % mod);\n            }\n        }\n\n        grundy.swap(a_grundy);\n    }\n\n    cout << grundy[0] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\\n\";\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\\n\"\n#define dbv(a) cerr << #a << \" = \"; for (auto xxxx: a) cerr << xxxx << \" \"; cerr << endl\n\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n    string what;\n    __timestamper(const char* what) : what(what){};\n    __timestamper(const string& what) : what(what){};\n    ~__timestamper(){\n        TIMESTAMPf(\"%s\", what.data());\n    }\n} __TIMESTAMPER(\"end\");\n#else\nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconstexpr int MOD = 998244353;\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\nint mul(int x, int y) {\n    return 1LL * x * y % MOD;\n}\nint bin(int a, int n) {\n    int res = 1;\n    while (n) {\n        if (n & 1) res = mul(res, a);\n        a = mul(a, a);\n        n >>= 1;\n    }\n    return res;\n}\nint inv(int x) {\n    return bin(x, MOD - 2);\n}\n\nint solve(int n, vector<vector<pair<int, int>>> ced) {\n    vector<int> cur(2);\n    cur[1] = 1;\n\n//    int pw = 1;\n    int pw = bin(10, 18);\n\n\n    vector<vector<int>> mex(3, vector<int>(n*2));\n    vector<vector<int>> sum_mex(3, vector<int>(n*2));\n\n    for (int i = 0; i < 3; i++) {\n        vector<vector<int>> e(n);\n        for (auto o : ced[i]) {\n            e[o.first].push_back(o.second);\n        }\n\n        for (int v = n - 1; v >= 0; v--){\n            vector<int> vv;\n            for (int to : e[v]) {\n                vv.push_back(mex[i][to]);\n            }\n            sort(vv.begin(), vv.end());\n            while (binary_search(vv.begin(), vv.end(), mex[i][v])) mex[i][v]++;\n            add(sum_mex[i][mex[i][v]], bin(pw, v + 1));\n        }\n    }\n//    for (auto v : mex) {\n//        dbv(v);\n//    }\n//    exit(0);\n\n//    int ans = 0;\n//    for (int i = 0; i < n; i++) {\n//        int prod = 1;\n//        for (int j = 0; j < 3; j++) prod =mul(prod, sum_mex[j][i]);\n//        add(ans, prod);\n//    }\n//    return ans;\n\n//    vector<int> prod(n);\n//    for (int i = 0; i < n; i++) prod[i] = mul(sum_mex[0][i], sum_mex[1][i]);\n\n//    int ans = 0;\n//    for (int k = 0; k < n; k++) {\n//        if (k % 1000 == 0) db(k);\n//        for (int j = 0; j < n; j++) {\n//            add(ans, mul(sum_mex[2][k], mul(sum_mex[1][j], sum_mex[0][j ^ k])));\n//        }\n//    }\n\n    int N = 1;\n    while (N < n) N <<= 1;\n\n    auto xft = [&](vector<int> &a) {\n        for (int k = 1; k < N; k <<= 1) {\n            for (int i = 0; i < N; i += 2 * k) {\n                for (int j = 0; j < k; j++) {\n                    int u = a[i + j], v = a[i + k + j];\n                    a[i + j] = (u + v) % MOD;\n                    a[i + k + j] = (u - v + MOD) % MOD;\n                }\n            }\n        }\n    };\n    sum_mex[1].resize(N);\n    sum_mex[2].resize(N);\n    xft(sum_mex[1]);\n    xft(sum_mex[2]);\n    for (int i = 0; i < N; i++) sum_mex[1][i] = mul(sum_mex[1][i], sum_mex[2][i]);\n    xft(sum_mex[1]);\n    int oN = inv(N);\n    for (int i = 0; i < N; i++) sum_mex[1][i] = mul(sum_mex[1][i], oN);\n\n    int ans = 0;\n    for (int i =0; i < n; i++) {\n        add(ans, mul(sum_mex[0][i], sum_mex[1][i]));\n    }\n\n\n    return ans;\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"in\", \"r\", stdin);\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<vector<pair<int, int>>> ed(3);\n        for (int i = 0; i < 3; i++) {\n            int m;\n            scanf(\"%d\", &m);\n            ed[i].resize(m);\n            for (int j = 0; j < m; j++) {\n                scanf(\"%d%d\", &ed[i][j].first, &ed[i][j].second);\n                ed[i][j].first--;\n                ed[i][j].second--;\n                if (ed[i][j].first > ed[i][j].second) swap(ed[i][j].first, ed[i][j].second);\n            }\n        }\n\n        printf(\"%d\\n\", solve(n, ed));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 998244353;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint operator^(const ll& t)const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\n///////////////////////////\n\nvector<ll> grundy(vector<vector<ll>> g, ll N) {\n\tvector<ll> ret(N + 1, 0);\n\n\tvector<vector<ll>> s(N + 1);\n\n\tvector<ll> in(N + 1, 0);\n\trepn(v, N) {\n\t\tfor (ll w : g[v]) { in[w]++; }\n\t}\n\n\tqueue<ll> q;\n\trepn(v, N) {\n\t\tif (in[v] == 0) { ret[v] = 0; q.push(v); }\n\t}\n\n\n\twhile (!q.empty()) {\n\t\tll v = q.front();\n\t\tq.pop();\n\n\t\tfor (ll w : g[v]) {\n\t\t\ts[w].push_back(ret[v]);\n\t\t\tin[w]--;\n\n\t\t\tif (in[w] == 0) {\n\t\t\t\tsort(s[w].begin(), s[w].end());\n\n\t\t\t\tfor (ll i = 0; i < s[w].size(); i++) {\n\t\t\t\t\tif (ret[w] < s[w][i]) { break; }\n\t\t\t\t\telse if (ret[w] == s[w][i]) { ret[w]++; }\n\t\t\t\t}\n\n\t\t\t\tq.push(w);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n\n}\n\n\nint main(){\n\n\tll N;\n\tcin >> N;\n\n\tvector<vector<vector<ll>>> g(3, vector<vector<ll>>(N + 1));\n\t\n\trep(i, 3) {\n\t\tll M;\n\t\tcin >> M;\n\n\t\trepn(j, M) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\tif (a < b) { swap(a, b); }\n\t\t\tg[i][a].push_back(b);\n\t\t}\n\t}\n\n\tvector<ll> gr[3];\n\trep(i, 3) gr[i] = grundy(g[i], N);\n\n\tll L=0;\n\trep(i, 3)repn(j, N)L = max(L, gr[i][j]);\n\n\tvector<vector<mint>> s(3, vector<mint>(L + 1,0));\n\n\trep(i, 3)repn(j, N) {\n\t\t//cout << gr[i][j] << endl;\n\t\ts[i][gr[i][j]] += (mint)10 ^ (18 * j);\n\t}\n\n\t\n\tmint ans = 0;\n\n\trep(i, L + 1)rep(j, L + 1) {\n\t\t//cout << i << j << (i ^ j) << endl;\n\n\t\tif ((i^j) <= L) {\n\t\t\tans += s[0][i] * s[1][j] * s[2][i^j];\n\t\t}\n\t}\n\n\tcout << ans;\n\n\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define re register\n#define LL long long\n#define MOD 998244353\n#define MAXN 300005\nusing namespace std;\nLL n,ans,bs[3*MAXN];\nLL rd(){\n\tLL x=0,tp=1;char c;c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')tp=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=(x*10+c-'0');c=getchar();}\n\treturn x*tp;\n}\nstruct Graph{\n\tLL m,sg[MAXN],f[MAXN];\n\tvector<int>e[MAXN];\n\tvoid work(){\n\t\tint x,y;\n\t\tm=rd();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tx=rd(),y=rd();\n\t\t\tif(x>y)swap(x,y);\n\t\t\te[x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tset<int>s;\n\t\t\tint sz=e[i].size();\n\t\t\tfor(int j=0;j<sz;j++)s.insert(sg[e[i][j]]);\n\t\t\twhile(s.count(sg[i]))sg[i]++;\n\t\t\t(f[sg[i]]+=bs[i])%=MOD;\n\t\t\t// printf(\"sg[%d]=%d\\n\",i,sg[i]);\n\t\t}\n\t}\n}g[3];\nint main(){\n\t// freopen(\"testdata.in\",\"r\",stdin);\n\t// freopen(\"shit.out\",\"w\",stdout);\n\tn=rd();int Sqr=sqrt(n);\n\tbs[0]=1;LL fuck=1000000000000000000ll%MOD;\n\tfor(int i=1;i<=3*n;i++)bs[i]=bs[i-1]*fuck%MOD;\n\tfor(int i=0;i<3;i++)g[i].work();\n\tfor(int i=0;i<=500;i++)\n\t\tfor(int j=0;j<=500;j++)\n\t\t\t(ans+=g[0].f[i]*g[1].f[j]%MOD*g[2].f[i^j]%MOD)%=MOD;\n\tprintf(\"%lld\\n\",ans);\n\t// printf(\"%.2lf\\n\",(double)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int N = 3e5 + 1, mod = 998244353;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nstruct edge {\n\tint x, y, next;\n} e[N * 2]; int cnt, last[N];\nint n, v[N], z[N];\nint y[3][N];\nLL A[N * 2], B[N * 2], C[N * 2], D[N * 2];\nint R[N * 2];\n\nLL pow_mod(LL a, LL k) {\n\tLL ans = 1;\n\tk %= (mod - 1);\n\twhile(k) {\n\t\tif(k & 1) (ans *= a) %= mod;\n\t\t(a *= a) %= mod; k /= 2;\n\t} return ans;\n}\n\nvoid NTT(LL y[], int len, int on) {\n\tfor(int i = 0; i < len; i++) if(i < R[i]) swap(y[i], y[R[i]]);\n\tfor(int i = 1; i < len; i *= 2) {\n\t\tLL wn = pow_mod(3, (LL)(mod - 1) / (i * 2)); if(on == -1) wn = pow_mod(wn, mod - 2);\n\t\tfor(int j = 0; j < len; j += i * 2) {\n\t\t\tLL w = 1;\n\t\t\tfor(int k = 0; k < i; k++, (w *= wn) %= mod) {\n\t\t\t\tLL u = y[j + k], v = y[j + k + i] * w % mod;\n\t\t\t\ty[j + k] = (u + v) % mod, y[j + k + i] = (u - v + mod) % mod;\n\t\t\t}\n\t\t}\n\t} if(on == -1) {\n\t\tLL gg = pow_mod(len, mod - 2);\n\t\tfor(int i = 0; i < len; i++) (y[i] *= gg) %= mod;\n\t}\n}\n\nI void ins(cr x, cr y) {e[++cnt] = edge{x, y, last[x]}, last[x] = cnt;}\n\nvoid dfs(cr x, cr o) {\n\tv[x] = 1, z[x] = o;\n\tfor(reg k = last[x]; k; k = e[k].next) {\n\t\treg y = e[k].y;\n\t\tif(!v[y]) dfs(y, o ^ 1);\n\t}\n}\n\nint len;\n\nI void gao(cr o) {\n\treg m = read();\n\tcnt = 0, memset(last, 0, sizeof(last));\n\tfo(i, 1, m) {\n\t\treg x = read(), y = read();\n\t\tins(x, y), ins(y, x);\n\t} memset(v, 0, sizeof(v));\n\tfd(i, n, 1) if(!v[i]) dfs(i, 0);\n\tmemset(v, 0, sizeof(v));\n\tmemset(C, 0, sizeof(C)), memset(D, 0, sizeof(D));\n\tfd(i, n, 1) {\n\t\tbool h1 = 0, h2 = 0;\n\t\tfor(reg k = last[i]; k; k = e[k].next) if(v[e[k].y]){\n\t\t\tif(z[e[k].y]) h2 |= 1;\n\t\t\tif(!z[e[k].y]) h1 |= 1;\n\t\t} if(h1 && h2) continue; v[i] = 1;\n\t\tif(!z[i]) C[i] = 1;\n\t\telse D[i] = 1;\n\t}\n\tNTT(C, len, 1), NTT(D, len, 1);\n\tfo(i, 0, len - 1) {\n\t\treg a = A[i], b = B[i], c = C[i], d = D[i];\n\t\tA[i] = ((LL)a * c + (LL)b * d) % mod;\n\t\tB[i] = ((LL)a * d + (LL)b * c) % mod;\n\t}\n}\n\nint main() {\n\tn = read();\n\tlen = 1;\n\tfor(; len <= n * 3; len <<= 1);\n\tfo(i, 0, len - 1) R[i] = (R[i >> 1] >> 1) | ((i & 1) * (len >> 1));\n\tfo(i, 0, len - 1) A[i] = 1;\n\tgao(0), gao(1), gao(2);\n\tNTT(A, len, -1);\n\treg s = 1, w = pow_mod(10, 18), ans = 0;\n\tfo(i, 1, 3 * n) {\n\t\ts = (LL)s * w % mod;\n\t\tans = (ans + (LL)s * A[i]) % mod;\n\t} pr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n\tnum B = pow(num(10), 18);\n\n\tint n;\n\tcin >> n;\n\n\tvector<num> powB(n+1, 0);\n\tpowB[0] = 1;\n\tfor(int i = 1; i <= n; i++) powB[i] = B * powB[i-1];\n\tvector<num> dp = {1, 0};\n\tvector<map<int, num> > q;\n\tfor(int _ = 0; _ < 3; _++){\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<vector<int> > edges(n);\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif(a < b) swap(a, b);\n\t\t\tedges[b].push_back(a);\n\t\t}\n\t\tvector<int> val(n, 0);\n\t\tmap<int, num> freq;\n\t\tfor(int v = n-1; v >= 0; v--){\n\t\t\tset<int> r;\n\t\t\tfor(int w : edges[v]) r.insert(val[w]);\n\t\t\twhile(r.count(val[v])) val[v]++;\n\t\t\tfreq[val[v]] += powB[v+1];\n\t\t}\n\t\tq.push_back(freq);\n\t}\n\tnum ans = 0;\n\tfor(auto r : q[0]){\n\t\tfor(auto s : q[1]){\n\t\t\tans += q[2][r.first ^ s.first] * r.second * s.second;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <complex>\n#include <vector>\n#include<limits>\n#include<iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\n\nconst long double pi = 3.141592653589793;\n\n#define debug(x) cout << #x << \" = \" << (x) << endl;\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define repi(i, j, n) for(int i = j;i < n;i++)\n#define pb push_back\n#define mp make_pair\n// #define mod 1000000007\n#define mod 998244353\n#define F first\n#define S second\n\n// #define COMMENT\n\n/*\n\nconst int NN = 200090;\nll fact[NN];\nll finv[NN];\nll inv[NN];\n\nvoid inverse_modulao() {\n  fact[0] = fact[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n\n  for(int i = 2;i < NN;i++) {\n    fact[i] = fact[i-1]*i%mod;\n    inv[i] = mod-mod/i*inv[mod%i]%mod;\n    finv[i] = finv[i-1]*inv[i]%mod;\n  }\n}\n\nll nCr(int n, int r) {\n  return fact[n]*finv[r]%mod*finv[n-r]%mod;\n}\n\n*/\n\nint N, M;\nvector<int> g[4][100099];\nint gr[4][100099];\nint h[100099],a,b;\nll ans[4][500];\n\nll pwr[1<<20];\n\nint main() {\n\n//  freopen(\"input.in\",\"r\",stdin);\n//  freopen(\"output.out\",\"w\",stdout);\n  cin>>N;\n  rep(i,3){\n    cin>>M;\n    rep(j,M){\n      cin>>a>>b;\n      g[i][min(a,b)].pb(max(a,b));\n    }\n  }\n  rep(i,3){\n    for(int j=N;j>=1;j--){\n      rep(k,1+g[i][j].size()) h[k]=0;\n      for(int &x:g[i][j]) h[gr[i][x]]=1;\n      rep(k,1+g[i][j].size()) {\n        if(h[k] == 0) {\n          gr[i][j]=k;break;\n        }\n      }\n    }\n  }\n  // rep(i,3){\n  //   rep(j,N){\n  //     cout<<gr[i][j+1]<<\" \";\n  //   }cout<<endl;\n  // }\n\n\n  pwr[0]=1;\n  ll bs = ll(1e18)%mod;\n  for(int i=1;i<=3*N+3;i++) {\n    pwr[i]=pwr[i-1]*bs%mod;\n  }\n  rep(i,3){\n    rep(j,N){\n      (ans[i][gr[i][j+1]] += pwr[j+1])%=mod;\n    }\n  }\n\n  ll tans=0;\n  rep(i,450){\n    rep(j,450){\n      int k = i^j;\n      if(k >= 450) continue;\n      (tans+=ans[0][i]*ans[1][j]%mod*ans[2][k]%mod)%=mod;\n    }\n  }\n  cout<<tans<<endl;\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MaxN = 100000, MaxS = 350;\nconst int Mod = 998244353, base = ((long long) 1e18) % Mod;\n\nint N;\nint Pw[MaxN + 5];\nint Sg[3][MaxN + 5];\nstd::vector<int> Gr[3][MaxN + 5];\nint Buc[3][MaxS + 5];\n\ninline int add(int x, int y) { return (x += y) >= Mod ? x - Mod : x; }\ninline int mul(int x, int y) { return 1LL * x * y % Mod; }\ninline void inc(int &x, int y = 1) { x = add(x, y); }\n\nvoid init() {\n  scanf(\"%d\", &N);\n  Pw[0] = 1;\n  for (int i = 1; i <= N; ++i) Pw[i] = mul(Pw[i - 1], base);\n  for (int k = 0; k < 3; ++k) {\n    int m;\n    scanf(\"%d\", &m);\n    for (int i = 1; i <= m; ++i) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      if (u > v) std::swap(u, v);\n      Gr[k][u].push_back(v);\n    }\n  }\n}\n\nvoid getSg(int k) {\n  static bool buc[MaxN + 5];\n  memset(buc, false, sizeof buc);\n  int mx = 0;\n  for (int u = N; u >= 1; --u) {\n    for (int i = 0; i <= mx; ++i) buc[i] = false;\n    mx = 0;\n    for (int v : Gr[k][u]) {\n      buc[Sg[k][v]] = true;\n      mx = std::max(mx, Sg[k][v]);\n    }\n    for (int i = 0; i <= mx + 1; ++i)\n      if (buc[i] == false) {\n        Sg[k][u] = i;\n        break;\n      }\n  }\n}\n\nvoid solve() {\n  for (int k = 0; k < 3; ++k) getSg(k);\n  for (int k = 0; k < 3; ++k)\n    for (int i = 1; i <= N; ++i)\n      inc(Buc[k][Sg[k][i]], Pw[i]);\n  int ans = 0;\n  for (int i = 0; i <= MaxS; ++i)\n    for (int j = 0; j <= MaxS; ++j) {\n      int k = i ^ j;\n      inc(ans, mul(mul(Buc[0][i], Buc[1][j]), Buc[2][k]));\n    }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  init();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll x,kp,y,n,sg[3][100005],inv2=499122177,qz[100005],mr,ans=0;\nconst ll mx=1<<17,m=17;\nll aq[mx],a[2][mx],ok[mx];\nconst ll mod=998244353;\nvector<int>s[3][100005];\nll M(ll x){return x>=mod?x-mod:x;}\nvoid solve(int ty)\n{\n\tint vis[100005]={0},v;\n\tscanf(\"%lld\",&kp);\n\tfor(int i=1;i<=kp;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tif(x>y)swap(x,y);\n\t\ts[ty][x].push_back(y);\n\t}\n\tfor(int i=n-1;i>0;i--)\n\t{\n\t\tfor(int j=0;j<s[ty][i].size();j++)\n\t\t{\n\t\t\tv=s[ty][i][j];\n\t\t\tvis[sg[ty][v]]=i;\n\t\t}\n\t\tfor(sg[ty][i]=0;vis[sg[ty][i]]==i;sg[ty][i]++);\n\t}\n}\nint main()\n{\n\tqz[0]=1;\n\tmr=1000000000000000000%mod;\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++)qz[i]=qz[i-1]*mr%mod;\n\tsolve(0);\n\tsolve(1);\n\tsolve(2);ok[0]=0;\n\tfor(int i=1;i<mx;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif((1<<j)&i)\n\t\t\t{\n\t\t\t\tok[i]=1-ok[i-(1<<j)];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\taq[sg[0][i]]=(aq[sg[0][i]]+qz[i])%mod;\n\t\ta[0][sg[1][i]]=(a[0][sg[1][i]]+qz[i])%mod;\n\t\ta[1][sg[2][i]]=(a[1][sg[2][i]]+qz[i])%mod;\n\t}\n\tfor(int i=0;i<mx;i++)if(ok[i]==1)a[0][i]=M(mod-a[0][i]),a[1][i]=M(mod-a[1][i]);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=0;j<mx;j++)\n\t\t{\n\t\t\tif(j&(1<<i))\n\t\t\t{\n\t\t\t\tx=a[0][j];y=a[0][j-(1<<i)];\n\t\t\t\ta[0][j]=M(a[0][j]+y);\n\t\t\t\ta[0][j-(1<<i)]=M(a[0][j-(1<<i)]+mod-x);\n\t\t\t\tx=a[1][j];y=a[1][j-(1<<i)];\n\t\t\t\ta[1][j]=M(a[1][j]+y);\n\t\t\t\ta[1][j-(1<<i)]=M(a[1][j-(1<<i)]+mod-x);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j=0;j<mx;j++)a[0][j]=a[0][j]*a[1][j]%mod;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=0;j<mx;j++)\n\t\t{\n\t\t\tif(j&(1<<i))\n\t\t\t{\n\t\t\t\tx=a[0][j];y=a[0][j-(1<<i)];\n\t\t\t\ta[0][j]=(x-y+mod)*inv2%mod;\n\t\t\t\ta[0][j-(1<<i)]=(x+y)*inv2%mod;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<mx;i++)if(ok[i]==1)a[0][i]=M(mod-a[0][i]);\n\tfor(int i=0;i<mx;i++)ans=(ans+aq[i]*a[0][i])%mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\n#define x first\n#define y second\n#define pb push_back\n#define eb emplace_back\n#define rep(i,a,b) for(auto i=(a); i<(b); ++i)\n#define REP(i,n) rep(i,0,n)\n#define all(v) (v).begin(), (v).end()\n#define rs resize\n#define DBG(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n\nconst ld PI = acos(-1.0);\ntemplate<class T> using min_queue =\npriority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> int sz(const T &x) {\n    return (int) x.size(); // copy the ampersand(&)!\n}\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> &v) {\n    os << \"\\n[\";\n    for(T &x : v) os << x << ',';\n    return os << \"]\\n\";\n}\n\nstruct pairhash {\n    public:\n    template<typename T1, typename T2>\n    size_t operator()(const pair<T1, T2> &p) const {\n        size_t lhs = hash<T1>()(p.x);\n        size_t rhs = hash<T2>()(p.y);\n        return lhs ^ (rhs+0x9e3779b9+(lhs<<6)+(lhs>>2));\n    }\n};\n\nconst ll MOD = 998244353;\nconst ll BASE = 1000000000000000000%MOD;\n\nvector<vvi> adj;\nvvi nim;\n\nvoid run() {\n\tll N;\n\tcin >> N;\n\n\tll maxNim = 0;\n\tfor (ll i = 0; i < 3; i++) {\n\t\tadj.pb(vvi(N));\n\t\tnim.pb(vi(N, 0));\n\t\tll M;\n\t\tcin >> M;\n\t\tfor (ll j = 0; j < M; j++) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif (a > b) swap(a, b);\n\t\t\tadj[i][a].pb(b);\n\t\t}\n\n\t\twhile (maxNim*(maxNim+1)/2 <= M) {\n\t\t\tmaxNim++;\n\t\t}\n\t\tmaxNim += 2;\n\n\t\tfor (ll j = N-1; j >= 0; j--) {\n\t\t\tvector<bool> U(adj[i][j].size()+2, false);\n\t\t\tfor (ll k : adj[i][j]) {\n\t\t\t\tU[nim[i][k]] = true;\n\t\t\t}\n\t\t\tfor (ll k = 0; k < U.size(); k++) {\n\t\t\t\tif (!U[k]) {\n\t\t\t\t\t//cout << j << \": \" << k << endl;\n\t\t\t\t\tnim[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvvi nimScore(3, vi(maxNim, 0));\n\tfor (ll i = 0; i < 3; i++) {\n\t\tll p = 1;\n\t\tfor (ll j = 0; j < N; j++) {\n\t\t\tp *= BASE;\n\t\t\tp %= MOD;\n\t\t\tnimScore[i][nim[i][j]] += p;\n\t\t\tnimScore[i][nim[i][j]] %= MOD;\n\t\t}\n\t}\n\t\n\tll res = 0;\n\tfor (ll i1 = 0; i1 < maxNim; i1++) {\n\t\tfor (ll i2 = 0; i2 < maxNim; i2++) {\n\t\t\tif ((i1^i2) < maxNim) {\n\t\t\t\tres += (nimScore[0][i1]*nimScore[1][i2])%MOD*nimScore[2][i1^i2];\n\t\t\t\tres %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << maxNim << endl;\n\tcout << res << endl;\n\t//cout << nimScore[0][0] << \", \" << nimScore[1][0] << \", \" << nimScore[2][0] << endl;\n}\n\nsigned main() {\n    // DON'T MIX \"scanf\" and \"cin\"!\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << fixed << setprecision(20);\n    run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n freopen(\"input\",\"r\",stdin);\n freopen(\"output\",\"w\",stdout);\n*/\n\nll MOD = 998244353;\n\nvector<vector<int>> A, B, C;\nvector<ll> X,Y,Z;\n\nint N, M;\n\nll power(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res *= a;\n            res %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nll cal(const unordered_set<int>& s) {\n    ll v = 0;\n    for (const int t : s) {\n        v += power(10, t * 18);\n        v %= MOD;\n    }\n    return v;\n}\n\nvector<ll> process(const vector<vector<int>>& x) {\n    unordered_set<int> u;\n    vector<ll> res;\n    for (int i = N;i > 0;i--) {\n        if (u.find(i) != u.end()) continue;\n        unordered_set<int> s;\n        s.insert(i);\n        u.insert(i);\n        unordered_set<int> r;\n        r.insert(i);\n        for (auto m : x[i]) r.insert(m);\n        for (int j = i - 1;j > 0;j--) {\n            if (r.find(j) != r.end() || u.find(j) != u.end()) continue;\n            s.insert(j);\n            u.insert(j);\n            r.insert(j);\n            for (auto m : x[j]) r.insert(m);\n        }\n        res.push_back(cal(s));\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> N;\n    A.resize(N+1);\n    B.resize(N+1);\n    C.resize(N+1);\n    int a, b;\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        A[a].push_back(b);\n        A[b].push_back(a);\n    }\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        B[a].push_back(b);\n        B[b].push_back(a);\n    }\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        C[a].push_back(b);\n        C[b].push_back(a);\n    }\n    X = process(A);\n    Y = process(B);\n    Z = process(C);\n    set<pair<int,int>> xy;\n    ll ans = 0;\n    for (int i = 0;i < Z.size();i++) {\n        ll z = Z[i];\n        set<int> u;\n        for (int k = 0;k < X.size();k++) u.insert(k);\n        for (int j = 0;j < Y.size();j++) {\n            ll y = z * Y[j];\n            y %= MOD;\n            for (int k : u) {\n                if (xy.find(make_pair(j,k)) == xy.end()) {\n                    xy.insert(make_pair(j,k));\n                    u.erase(k);\n                    ans += (y * X[k]) % MOD;\n                    ans %= MOD;\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint Power(int n, int x) {\n  if (x == 0) return 1;\n  int res = Power(n, x / 2);\n  res = 1ll * res * res % MOD;\n  if (x & 1) res = 1ll * res * n % MOD;\n  return res;\n}\n\nconst int INV = Power(Power(10, 18), MOD - 2);\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n\n  int N;\n  cin >> N;\n  vector<vector<int>> contrib(3);\n  for (int g = 0; g < 3; g++) {\n    int M;\n    cin >> M;\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < M; i++) {\n      int u, v;\n      cin >> u >> v;\n      u--, v--;\n      if (u > v) {\n        swap(u, v);\n      }\n      adj[u].emplace_back(v);\n    }\n    int cur = Power(10, 18 * N);\n    vector<int> used(N);\n    vector<int> grundy(N);\n    for (int i = N - 1; i >= 0; i--) {\n      for (auto j : adj[i]) {\n        used[grundy[j]] = 1;\n      }\n      while (used[grundy[i]]) grundy[i]++;\n      while (int(contrib[g].size()) <= grundy[i]) {\n        contrib[g].push_back(0);\n      }\n      contrib[g][grundy[i]] += cur;\n      contrib[g][grundy[i]] %= MOD;\n      cur = 1ll * cur * INV % MOD;\n      for (auto j : adj[i]) {\n        used[grundy[j]] = 0;\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < (int) contrib[0].size(); i++) {\n    for (int j = 0; j < (int) contrib[1].size(); j++) {\n      int k = i ^ j;\n      if (k < (int) contrib[2].size()) {\n        ans += 1ll * contrib[0][i] * contrib[1][j] % MOD * contrib[2][k] % MOD;\n        ans %= MOD;\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int MAXN = 1e5 + 11;\nconst int MAXM = 555;\nconst int mod = 998244353;\n#define FOR(i, a, b) for(int i = (a);i <= (b); i++)\n#define ROF(i, a, b) for(int i = (a);i >= (b); i--)\nint n, m;\nint f[3][MAXM], sg[MAXN], mark[MAXM];\nvector<int> G[MAXN];\nvoid Add(int &x, int y){\n    x = x + y - (x + y >= mod ? mod : 0);\n}\nvoid Mu(int &x, int y){\n    x = 1LL * x * y % mod;\n}\nint A(int x, int y){\n    return x + y - (x + y >= mod ? mod : 0);\n}\nint M(int x, int y){\n    return 1LL * x * y % mod;\n}\nint ksm(int base, int x){\n    base %= mod;\n    int ans = 1;\n    while(x){\n        if(x & 1)Mu(ans, base);\n        x >>= 1;\n        Mu(base, base);\n    }\n    return ans;\n}\nint main(){\n    cin>>n;\n    FOR(t, 0, 2){\n        cin>>m;\n        int u, v;\n        memset(sg, -1, sizeof sg);\n        memset(mark, 0, sizeof mark);\n        FOR(i, 1, m){\n            scanf(\"%d%d\", &u, &v);\n            if(u < v)swap(u, v);\n            G[v].push_back(u);\n        }\n        ROF(u, n, 1){\n            for(int v : G[u]){\n                mark[sg[v]] = u;\n            }\n            sg[u] = 0;\n            while(mark[sg[u]] == u)sg[u]++;\n            Add(f[t][sg[u]], ksm((LL)(1e18 + 0) % mod, u));\n            G[u].clear();\n            //printf(\"u=%d sg=%d\\n\", u, sg[u]);\n        }\n    }\n    int ans = 0;\n    FOR(i, 0, 500){\n        FOR(j, 0, 500){\n            Add(ans, M(M(f[0][i],f[1][j]), f[2][i^j]));\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\n#define x first\n#define y second\n#define pb push_back\n#define eb emplace_back\n#define rep(i,a,b) for(auto i=(a); i<(b); ++i)\n#define REP(i,n) rep(i,0,n)\n#define all(v) (v).begin(), (v).end()\n#define rs resize\n#define DBG(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n\nconst ld PI = acos(-1.0);\ntemplate<class T> using min_queue =\npriority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> int sz(const T &x) {\n    return (int) x.size(); // copy the ampersand(&)!\n}\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> &v) {\n    os << \"\\n[\";\n    for(T &x : v) os << x << ',';\n    return os << \"]\\n\";\n}\n\nstruct pairhash {\n    public:\n    template<typename T1, typename T2>\n    size_t operator()(const pair<T1, T2> &p) const {\n        size_t lhs = hash<T1>()(p.x);\n        size_t rhs = hash<T2>()(p.y);\n        return lhs ^ (rhs+0x9e3779b9+(lhs<<6)+(lhs>>2));\n    }\n};\n\nconst ll MOD = 998244353;\nconst ll BASE = 1000000000000000000%MOD;\n\n//vector<vvi> adj;\nvvi nim;\n\nvoid run() {\n\tll N;\n\tcin >> N;\n\n\tll maxNim = 0;\n\tfor (ll i = 0; i < 3; i++) {\n\t\tvvi adj(N);\n\t\tnim.pb(vi(N, 0));\n\t\tll M;\n\t\tcin >> M;\n\t\tfor (ll j = 0; j < M; j++) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif (a > b) swap(a, b);\n\t\t\tadj[a].pb(b);\n\t\t}\n\n\t\tfor (ll j = N-1; j >= 0; j--) {\n\t\t\tvector<bool> U(adj[j].size()+2, false);\n\t\t\tfor (ll k : adj[j]) {\n\t\t\t\tU[nim[i][k]] = true;\n\t\t\t}\n\t\t\tfor (ll k = 0; k < U.size(); k++) {\n\t\t\t\tif (!U[k]) {\n\t\t\t\t\t//cout << j << \": \" << k << endl;\n\t\t\t\t\tnim[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxNim = max(maxNim, nim[i][j]+1);\n\t\t}\n\t}\n\n\tvvi nimScore(3, vi(maxNim, 0));\n\tfor (ll i = 0; i < 3; i++) {\n\t\tll p = 1;\n\t\tfor (ll j = 0; j < N; j++) {\n\t\t\tp *= BASE;\n\t\t\tp %= MOD;\n\t\t\tnimScore[i][nim[i][j]] += p;\n\t\t\tnimScore[i][nim[i][j]] %= MOD;\n\t\t}\n\t}\n\t\n\tll res = 0;\n\tfor (ll i1 = 0; i1 < maxNim; i1++) {\n\t\tfor (ll i2 = 0; i2 < maxNim; i2++) {\n\t\t\tif ((i1^i2) < maxNim && (i1^i2) >= 0) {\n\t\t\t\tres += (nimScore[0][i1]*nimScore[1][i2])%MOD*nimScore[2][i1^i2];\n\t\t\t\tres %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << maxNim << endl;\n\tcout << res << endl;\n\t//cout << nimScore[0][0] << \", \" << nimScore[1][0] << \", \" << nimScore[2][0] << endl;\n}\n\nsigned main() {\n    // DON'T MIX \"scanf\" and \"cin\"!\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << fixed << setprecision(20);\n    run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1LL * ret * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, m;\nint dp[100005];\nbool hv[100005];\nvector<int> G[100005];\nint cur[131072];\nint cnt[131072];\n\nvoid gen_cnt(int x)\n{\n\tscanf(\"%d\", &m);\n\trep1(i, n) G[i].clear();\n\trep(i, m) {\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[min(u, v)].push_back(max(u, v));\n\t}\n\tfor(int i = n; i >= 1; i --) {\n\t\trep(j, G[i].size()) hv[dp[G[i][j]]] = true;\n\t\tfor(dp[i] = 0; hv[dp[i]]; dp[i] ++);\n\t\trep(j, G[i].size()) hv[dp[G[i][j]]] = false;\n\t}\n\t\n\trep(i, 131072) cur[i] = 0;\n\trep1(i, n) cur[dp[i]] = (cur[dp[i]] + power(10, 18 * i)) % MOD;\n\trep(i, 17) rep(j, 131072) if(!(j >> i & 1)) {\n\t\tint ev = cur[j], od = cur[j | 1 << i];\n\t\tcur[j] = (ev + od) % MOD;\n\t\tcur[j | 1 << i] = (ev - od + MOD) % MOD;\n\t}\n\trep(i, 131072) cnt[i] = 1LL * cnt[i] * cur[i] % MOD;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tint ans = 0;\n\trep(i, 131072) cnt[i] = 1;\n\trep(i, 3) gen_cnt(i);\n\trep(i, 131072) ans = (ans + cnt[i]) % MOD;\n\tans = 1LL * ans * power(131072, MOD - 2) % MOD;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate<class T> inline void read(T &x){\n\tx=0; register char c=getchar(); register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\n\nconst int N=1e5+10,M=400,mod=998244353;\nint n,lim,max,m[3],sg[N];\nstd::vector<int> G[3][N];\n\nstruct z {\n\tint x;\n\tz(int x=0):x(x){}\n\tfriend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n\tfriend inline z operator-(z a,z b){return (a.x-=b.x)<0?a.x+mod:a.x;}\n\tfriend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}ans,pw[N],f[3][N],g[N];\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&1)s=s*a;return s;}\n\nvoid SG(int m,std::vector<int> G[N],int sg[N]){\n\tstatic bool vis[N];\n\tfor(int i=n;i>=1;i--){\n\t\tfor(int j:G[i])vis[sg[j]]=1;\n\t\tsg[i]=0;\n\t\twhile(vis[sg[i]])sg[i]++;\n\t\tfor(int j:G[i])vis[sg[j]]=0;\n\t}\n}\n\nvoid fwt(z *a){\n\tfor(int len=1;len<lim;len<<=1)\n\t\tfor(int i=0;i<lim;i+=(len<<1))\n\t\t\tfor(int j=0;j<len;j++){\n\t\t\t\tz x=a[i+j],y=a[i+j+len];\n\t\t\t\ta[i+j]=x+y,a[i+j+len]=x-y;\n\t\t\t}\n}\n\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(n),lim=sqrt(n);\n\tfor(int i=0;i<3;i++){\n\t\tread(m[i]);\n\t\tfor(int u,v,j=1;j<=m[i];j++){\n\t\t\tread(u),read(v);\n\t\t\t// G[i][u].push_back(v);\n\t\t\tG[i][std::min(u,v)].push_back(std::max(u,v));\n\t\t\t// G[i][std::max(u,v)].push_back(std::min(u,v));\n\t\t}\n\t}\n\tpw[0]=1,pw[1]=fpow(10,18);\n\tfor(int i=2;i<=n;i++)pw[i]=pw[i-1]*pw[1];\n\tfor(int i=0;i<3;i++){\n\t\tSG(m[i],G[i],sg);\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmax=std::max(max,sg[j]);\n\t\t\tf[i][sg[j]]=f[i][sg[j]]+pw[j];\n\t\t}\n\t\t// for(int j=1;j<=n;j++){\n\t\t// \tprintf(\"%d%c\",sg[j],\" \\n\"[j==n]);\n\t\t// }\n\t}\n\tlim=1; while(lim<=max)lim<<=1;\n\tfor(int i=0;i<lim;i++)\n\t\tfor(int j=0;j<lim;j++)\n\t\t\tfor(int k=0;k<lim;k++){\n\t\t\t\tg[i^j^k]=g[i^j^k]+f[0][i]*f[1][j]*f[2][k];\n\t\t\t\t// if(f[0][i].x&&f[1][j].x&&f[2][k].x){\n\t\t\t\t// \tprintf(\"%d %d %d : %d\\n\",i,j,k,f[0][i]*f[1][j]*f[2][k]);\n\t\t\t\t// }\n\t\t\t}\n\t// for(int i=0;i<3;i++)fwt(f[i]);\n\t// for(int i=0;i<3;i++)g[i]=f[0][i]*f[1][i]*f[2][i];\n\t// fwt(g);\n\t// z invlim=fpow(lim,mod-2);\n\t// for(int i=0;i<lim;i++)g[i]=g[i]*invlim;\n\t// for(int i=0;i<lim;i++){\n\t// \tprintf(\"%d : %d\\n\",i,g[i]);\n\t// }\n\tprintf(\"%d\\n\",g[0]);\n}\n\tfor(int i=0;i<3;i++){\n\t\tread(m[i]);\n\t\tfor(int u,v,j=1;j<=m[i];j++){\n\t\t\tread(u),read(v);\n\t\t\t// G[i][u].push_back(v);\n\t\t\tG[i][std::min(u,v)].push_back(std::max(u,v));\n\t\t\t// G[i][std::max(u,v)].push_back(std::min(u,v));\n\t\t}\n\t}\n\tpw[0]=1,pw[1]=fpow(10,18);\n\tfor(int i=2;i<=n;i++)pw[i]=pw[i-1]*pw[1];\n\tfor(int i=0;i<3;i++){\n\t\tSG(m[i],G[i],sg);\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmax=std::max(max,sg[j]);\n\t\t\tf[i][sg[j]]=f[i][sg[j]]+pw[j];\n\t\t}\n\t\t// for(int j=1;j<=n;j++){\n\t\t// \tprintf(\"%d%c\",sg[j],\" \\n\"[j==n]);\n\t\t// }\n\t}\n\tlim=1; while(lim<=max)lim<<=1;\n\tfor(int i=0;i<lim;i++)\n\t\tfor(int j=0;j<lim;j++)\n\t\t\tfor(int k=0;k<lim;k++){\n\t\t\t\tg[i^j^k]=g[i^j^k]+f[0][i]*f[1][j]*f[2][k];\n\t\t\t\t// if(f[0][i].x&&f[1][j].x&&f[2][k].x){\n\t\t\t\t// \tprintf(\"%d %d %d : %d\\n\",i,j,k,f[0][i]*f[1][j]*f[2][k]);\n\t\t\t\t// }\n\t\t\t}\n\t// for(int i=0;i<3;i++)fwt(f[i]);\n\t// for(int i=0;i<3;i++)g[i]=f[0][i]*f[1][i]*f[2][i];\n\t// fwt(g);\n\t// z invlim=fpow(lim,mod-2);\n\t// for(int i=0;i<lim;i++)g[i]=g[i]*invlim;\n\t// for(int i=0;i<lim;i++){\n\t// \tprintf(\"%d : %d\\n\",i,g[i]);\n\t// }\n\tprintf(\"%d\\n\",g[0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst ll M=512;\nint n;\n\nvl f(){\n\tvvi g(n);\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tg[u].push_back(v);\n\t}\n\tvl a(n),b(M),c(M);\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(auto j:g[i]) c[a[j]]++;\n\t\tfor(int j=0;;j++) if(!c[j]){\n\t\t\ta[i]=j;\n\t\t\tbreak;\n\t\t}\n\t\tfor(auto j:g[i]) c[a[j]]--;\n\t}\n\tll t=1;\n\tfor(int i=0;i<n;i++){\n\t\t(t*=1000000000000000000%mod)%=mod;\n\t\t(b[a[i]]+=t)%=mod;\n\t}\n\treturn b;\n}\n\nint main(){\n\tcin>>n;\n\tvl a=f(),b=f(),c=f();\n\tll res=0;\n\tfor(int i=0;i<M;i++) for(int j=0;j<M;j++) (res+=a[i]*b[j]%mod*c[i^j])%=mod;\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n} read;\n\nconst int maxn = 200005, mod = 998244353;\nstd::vector<int> G[maxn];\nint sg[3][maxn];\nll f[3][maxn];\nll po[maxn * 3];\n\nint main () {\n\tint n = read, len = 1;\n\twhile (len < n)\n\t\tlen <<= 1;\n\n\tpo[0] = 1;\n\tll bs = 1000000000000000000ll % mod;\n\tfor (int i = 1; i <= n * 3; i ++)\n\t\tpo[i] = po[i - 1] * bs % mod;\n\n\tfor (int o = 0; o < 3; o ++) {\n\t\tint m = read;\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tG[i].clear();\n\t\tfor (int i = 1; i <= m; i ++) {\n\t\t\tint u = read, v = read;\n\t\t\tif (u < v) G[u].push_back(v);\n\t\t\tif (v < u) G[v].push_back(u);\n\t\t}\n\t\tfor (int i = n; i; i --) {\n\t\t\tstd::set<int> mex;\n\t\t\tfor (int j : G[i])\n\t\t\t\tmex.insert(sg[o][j]);\n\t\t\twhile (mex.count(sg[o][i]))\n\t\t\t\t++ sg[o][i];\n\t\t}\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\t(f[o][sg[o][i]] += po[i]) %= mod;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < 500; i ++)\n\t\tfor (int j = 0; j < 500; j ++)\n\t\t\t(ans += f[0][i] * f[1][j] % mod * f[2][i ^ j]) %= mod;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define re register\n#define int long long\n#define pb push_back\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int inf = 1e18 ; \nconst int P = 998244353 ; \nconst int N = 1e5 + 5 ; \nconst int M = 1e5 + 5 ;\nint n, m1, m2, m3, ans[N], h[N], f[N], g[N], f1[N], f2[N], f3[N], Ans ;\nint book[N] ; \nvector<int> G1[N], G2[N], G3[N] ; \nsigned main()\n{\n\tn = gi(), ans[1] = inf % P ; \n\trep( i, 2, n ) ans[i] = ans[i - 1] * ans[1] % P ; \n\t\n\tint x, y ; m1 = gi() ; \n\trep( i, 1, m1 ) x = gi(), y = gi(), ( x < y ) ? G1[x].pb(y) : G1[y].pb(x) ;\n\tm2 = gi() ; \n\trep( i, 1, m2 ) x = gi(), y = gi(), ( x < y ) ? G2[x].pb(y) : G2[y].pb(x) ;\n\tm3 = gi() ; \n\trep( i, 1, m3 ) x = gi(), y = gi(), ( x < y ) ? G3[x].pb(y) : G3[y].pb(x) ;\n\t\n\tfor( re int i = n, l; i >= 1; -- i ) {\n\t\tfor( int j : G1[i] ) book[f1[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f1[i] = l ;\n\t\tfor( int j : G1[i] ) book[f1[j]] = 0 ; \n\t\t\n\t\tfor( int j : G2[i] ) book[f2[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f2[i] = l ;\n\t\tfor( int j : G2[i] ) book[f2[j]] = 0 ; \n\t\t\n\t\tfor( int j : G3[i] ) book[f3[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f3[i] = l ;\n\t\tfor( int j : G3[i] ) book[f3[j]] = 0 ; \n\t\tf[f1[i]] = ( f[f1[i]] + ans[i] ) % P, \n\t\tg[f2[i]] = ( g[f2[i]] + ans[i] ) % P,\n\t\th[f3[i]] = ( h[f3[i]] + ans[i] ) % P ; \n\t}\n\trep( i, 0, 500 ) rep( j, 0, 500 ) rep( k, 0, 500 ) \n\t( ( i ^ j ^ k ) == 0 ) ? Ans = ( Ans + f[i] * g[j] % P * h[k] % P ) % P : Ans = Ans ; \n\t\n\tcout << Ans << endl ; \n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntemplate <class T1, class T2>\nostream& operator << (ostream& out, const pair <T1, T2> p)\n{\n    out << '(' << p.first << ',' << p.second << ')';\n    return out;\n}\n\ntemplate <class T1, class T2>\nistream& operator >> (istream& in, pair<T1, T2> &p)\n{\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate <class T>\nistream& operator >> (istream& in, vector<T> &v)\n{\n    for (T &x : v)\n        in >> x;\n    return in;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<vector<T>> &v)\n{\n    for (const vector<T> &x : v)\n        out << x << '\\n';\n    return out;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<T> &v)\n{\n    for (const T &x : v)\n        out << x << ' ';\n    return out;\n}\n\nlong long gcd (long long a, long long b)\n{\n    if (b > a)\n        swap(a, b);\n    return (b ? gcd(b, a % b) : a);\n}\n\nusing ll   = long long;\nusing pii  = pair<int, int>;\nusing pll  = pair<long long, long long>;\nusing tiii = pair<pair<int, int>, int>;\nusing vi   = vector<int>;\nusing vl   = vector<long long>;\nusing vvi  = vector<vector<int>>;\nusing vvl  = vector<vector<long long>>;\n\n#define F          first\n#define S          second\n#define First      first.first\n#define Second     first.second\n#define Third      second\n#define mp         make_pair\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define per(i,b,a) for (int i = (b); i > (a); i--)\n#define all(x)     x.begin(), x.end()\n#define ret(x)     return cout << x, 0;\n#define throwex    throw runtime_error (\"Found the error.\");\n\nconst int h = 998244353;\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    #ifdef ONLINE_JUDGE\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.setstate(ios::failbit);\n    #endif\n\n    int n;\n    cin >> n;\n    vi m(3);\n    vector<vvi> M(3, vvi(n));\n    vvi grundy(3, vi(n));\n    rep(i,0,3)\n    {\n        cin >> m[i];\n        rep(j,0,m[i])\n        {\n            int x, y;\n            cin >> x >> y;\n            x--, y--;\n            if(y < x)\n                swap(x, y);\n            M[i][x].push_back(y);\n        }\n    }\n    rep(i,0,3)\n    {\n        per(j,n-1,-1)\n        {\n            set<int> s;\n            for(int x : M[i][j])\n                s.insert(grundy[i][x]);\n            while(s.count(grundy[i][j]))\n                grundy[i][j]++;\n        }\n    }\n    // cerr << grundy << '\\n';\n    int base = ll(1e18) % h;\n    ll ans = 0;\n    vector<map<int, int>> v(3);\n    rep(i,0,3)\n    {\n        ll contribution = base;\n        rep(j,0,n)\n        {\n            (v[i][grundy[i][j]] += contribution) %= h;\n            (contribution *= base) %= h;\n        }\n    }\n    for(auto x : v[0])\n        for(auto y : v[1])\n        {\n            ll z = x.S;\n            (((z *= y.S) %= h) *= v[2][x.F ^ y.F]) %= h;\n            (ans += z) %= h;\n        }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 998244353;\nconst int N = 1e6+7;\nconst long long B = 1000000000000000000;\ntypedef long long LL;\n\nLL pb[N];\nvoid pre() {\n    pb[0] = 1;\n    LL b = B%M;\n    for (int i=1; i<N; i++)\n        pb[i] = (pb[i-1]*b)%M;\n}\n\nvector<int> bfs(vector<vector<int>>adj) {\n    int n = adj.size()-1;\n    vector<int> col(n+1, N), in(n+1, 0);\n\n    for (int i=n; i>0; i--) {\n        bool odd = false, even = false;\n        for (int v: adj[i]) {\n            if (v < i)  continue;\n            if (col[v] == 2)    continue;\n            if (col[v] == 1)    odd = true;\n            if (col[v] == 0)    even = true;\n        }\n        if (!even)      col[i] = 0;\n        else if (!odd)  col[i] = 1;\n        else            col[i] = 2;\n    }\n    return col;\n}\n\nint m[3];\nvector<vector<int>> adj[3];\nvector<int> dis[3];\nLL even[3], odd[3];\nint main() {\n    pre();\n\n    int n;\n    cin>>n;\n\n    for (int g=0; g<3; g++) {\n        cin>>m[g];\n        adj[g].resize(n+1);\n        for (int i=0; i<m[g]; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[g][u].push_back(v);\n            adj[g][v].push_back(u);\n        }\n        dis[g] = bfs(adj[g]);\n        for (int i=1; i<=n; i++)    cout<<dis[g][i]<<\" \"; cout<<endl;\n\n        for (int i=1; i<=n; i++) {\n            if (dis[g][i] == 1)        odd[g] = (odd[g] + pb[i])%M;\n            else if (dis[g][i]==0)     even[g] = (even[g] + pb[i])%M;\n        }\n    }\n\n    LL ans = 0;\n    for (int mask = 0; mask < 8; mask ++) {\n        if (__builtin_popcount(mask)%2) continue;\n        long long cur = 1;\n        for (int g=0; g<3; g++)\n            if (mask & (1<<g))      cur = (cur * odd[g])%M;\n            else                    cur = (cur * even[g])%M;\n        ans = (ans + cur)%M;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=100005,mod=998244353,K=512;\nint n;\nstruct data{\n\tll a[N]; int sg[N],to[N];\n\tvector<int> v[N];\n\t\n\tvoid solve(){\n\t\tint m=read();\n\t\tFor(i,0,m-1){\n\t\t\tint s=read(),t=read();\n\t\t\tif(s>t)swap(s,t);\n\t\t\tv[s].pb(t);\n\t\t}\n\t\tRep(i,n,1){\n\t\t\tfor(auto j:v[i])to[sg[j]]=1;\n\t\t\twhile(to[sg[i]])sg[i]++;\n\t\t\tfor(auto j:v[i])to[sg[j]]=0;\n\t\t}\n\t\tll t=1000000000000000000%mod,pw=1;\n\t\tFor(i,1,n){\n\t\t\tpw=pw*t%mod;\n\t\t\ta[sg[i]]=(a[sg[i]]+pw)%mod;\n\t\t}\n\t}\n}T[3];\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tn=read();\n\tFor(i,0,2){\n\t\tT[i].solve();\n\t}\n\tll ans=0;\n\tFor(i,0,K-1)For(j,0,K-1){\n\t\tans+=T[0].a[i]*T[1].a[j]%mod*T[2].a[i^j]%mod;\n\t}\n\tcout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 998244353;\n\nll modAdd(ll a, ll b) {\n\treturn a+b >= MOD ? a+b-MOD : a+b;\n}\nll modSub(ll a, ll b) {\n\treturn a < b ? a-b+MOD : a-b;\n}\nll modPow(ll a, ll b) {\n\tif (b & 1) return a * modPow(a, b-1) % MOD;\n\tif (b == 0) return 1;\n\treturn modPow(a*a % MOD, b / 2);\n}\n\n// res[k] = \\sum_{i,j : i^j == k} a[i] b[j]\n// overflows if n res[i] overflows\nvoid xorTF(vector<ll>& v) {\n\tfor (int b = 1; b < v.size(); b *= 2) {\n\t\tfor (int i = 0; i < v.size(); ++i) {\n\t\t\tif (i & b) continue;\n\t\t\tll ri = v[i^b];\n\t\t\tv[i^b] = modSub(v[i], ri);\n\t\t\tv[i] = modAdd(v[i], ri);\n\t\t}\n\t}\n}\nvector<ll> xorConv(vector<ll> a, vector<ll> b) {\n\txorTF(a); xorTF(b);\n\tfor (int i = 0; i < a.size(); ++i) a[i] = (a[i] * b[i]) % MOD;\n\txorTF(a);\n\n\tll inv = modPow(a.size(), MOD-2);\n\tfor (int i = 0; i < a.size(); ++i) a[i] = (a[i] * inv) % MOD;\n\treturn a;\n}\n\nconst int N = 1e5;\nvector<int> conns[3][N];\nint grundy[3][N];\nvector<ll> vals[3];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tfor (int j = 0; j < 3; ++j) {\n\t\tint m;\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\t--a; --b;\n\t\t\tconns[j][a].push_back(b);\n\t\t\tconns[j][b].push_back(a);\n\t\t}\n\t\tfor (int i = n-1; i >= 0; --i) {\n\t\t\tvector<int> hits;\n\t\t\tfor (auto t : conns[j][i]) {\n\t\t\t\tif (t > i) hits.push_back(grundy[j][t]);\n\t\t\t}\n\t\t\tsort(hits.begin(), hits.end());\n\n\t\t\tfor (auto v : hits) {\n\t\t\t\tif (grundy[j][i] == v) ++grundy[j][i];\n\t\t\t}\n\t\t}\n\t}\n\n\tint h = 1;\n\twhile(h < n) h <<= 1;\n\tfor (int j = 0; j < 3; ++j) vals[j].resize(h, 0);\n\n\tll base = modPow(10, 18);\n\tll cur = base;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tvals[j][grundy[j][i]] = modAdd(vals[j][grundy[j][i]], cur);\n\t\t}\n\t\tcur = (cur * base) % MOD;\n\t}\n\n\tvector<ll> aux = xorConv(vals[0], xorConv(vals[1], vals[2]));\n\tcout << aux[0] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n\nusing ll = long long;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nint const nmax = 100000;\nint const rad = 340;\nint const modulo = 998244353;\nstd::vector<int> g[3][1 + nmax];\nint nimber[3][1 + nmax];\n\nint lgpow(int a, int b) {\n  if(b == 0)\n    return 1;\n  else if(b == 1)\n    return a;\n  else {\n    int result = lgpow(a, b / 2);\n    if(b % 2 == 0)\n      return 1LL * result * result % modulo;\n    else\n      return 1LL * result * result % modulo * a % modulo;\n  }\n}\n\nint mex(std::vector<int> v) {\n  std::sort(v.begin(), v.end());\n  v.erase(std::unique(v.begin(), v.end()), v.end());\n  for(int i = 0; i < v.size(); i++)\n    if(i != v[i])\n      return i;\n  return v.size();\n}\n\nint sum[3][5 + nmax];\n\nint main() {\n  int n, m[3];\n  std::cin >> n;\n  for(int h = 0; h < 3; h++) {\n    std::cin >> m[h];\n    for(int i = 1;i <= m[h]; i++){\n      int x, y;\n      std::cin >> x >> y;\n      if(y < x)\n        std::swap(x, y);\n      g[h][x].push_back(y);\n    }\n    std::vector<int> cand;\n    for(int i = n; 1 <= i; i--) {\n      cand.clear();\n      for(int h_ = 0; h_ < g[h][i].size(); h_++){\n        int to = g[h][i][h_];\n        cand.push_back(nimber[h][to]);\n      }\n      nimber[h][i] = mex(cand);\n      sum[h][nimber[h][i]] = (sum[h][nimber[h][i]] + lgpow(10, 18 * i)) % modulo;\n    }\n  }\n\n  int result = 0;\n  \n  for(int i = 0; i < rad; i++)\n    for(int j = 0; j < rad; j++)\n      if((i ^ j) < rad) { \n        result = (result + 1LL * sum[0][i] * sum[1][j] % modulo * sum[2][i ^ j]) % modulo;\n      }\n  std::cout << result;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*temp*/\n//\n//\n//\n//\n//#undef _DEBUG\n//#pragma GCC optimize(\"Ofast\")\n//不動小数点の計算高速化\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/type.hpp>\n#ifdef _DEBUG\n#include \"template.h\"\n#else\n#if __cplusplus >= 201703L\n/*Atcoderでしか使えない(c++17 && このテンプレートが使えるならAtcoder)*/\n#include <boost/sort/pdqsort/pdqsort.hpp>\n#define fast_sort boost::sort::pdqsort\n#endif\n#endif\n\n\n#ifndef _DEBUG\n#ifndef UNTITLED15_TEMPLATE_H\n#define UNTITLED15_TEMPLATE_H\n\n#ifdef _DEBUG\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#ifndef fast_sort\n#define fast_sort sort\n#endif\n\n\n//#define use_pq\n#define use_for\n#define use_for_each\n#define use_sort\n#define use_fill\n#define use_rand\n#define use_mgr\n#define use_rui\n#define use_compress\n//\n//\n//\n//\n//\n//\n#define use_pbds\n#ifdef use_pbds\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate<class T, class U, class W, class X> auto count(__gnu_pbds::gp_hash_table<T, U, W> &a, X k) { return a.find(k) != a.end(); }\n#endif\n\nusing namespace std;\nusing namespace std::chrono;\n\n/*@formatter:off*/\n#define ll long long\nusing sig_dou = double;\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define mt make_tuple\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n\n\ntemplate<class T,class U> auto max(T a, U b){return a>b ? a: b;}\ntemplate<class T,class U> auto min(T a, U b){return a<b ? a: b;}\n//optional<T>について下でオーバーロード(nullopt_tを左辺右辺について単位元として扱う)\ntemplate<class T, class U> bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class T, class U> bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\n\n//メタ系 meta\ntemplate<typename T, typename U = typename T::value_type>std::true_type value_type_tester(signed);\ntemplate<typename T>std::false_type value_type_tester(long);\n\ntemplate<typename T>struct has_value_type: decltype(value_type_tester<T>(0)){};\n\n\n//A<T>でTを返す\ntemplate<class T>using decl_t = typename T::value_type;\n//A<B<.....T>>でTを返す\ntemplate<class T, bool end = !has_value_type<T>::value> struct decl2_ {typedef T type;};\ntemplate<class T> struct decl2_<T, false> {typedef typename decl2_<decl_t<T>>::type type;};\ntemplate<class T> using decl2_t = typename decl2_<T>::type;\n//#define decl_max(a, b) decltype(max(MAX<decltype(a)>(), MAX<decltype(b)>()))\n#define is_same2(T, U) is_same<T, U>::value\ntemplate<class T>struct is_vector : std::false_type{};\ntemplate<class T>struct is_vector<std::vector<T>> : std::true_type{};\n\n//大きい型を返す max_type<int, char>::type\n//todo mintがlong long より小さいと判定されるためバグる\ntemplate<class T1, class T2, bool t1_bigger = (sizeof(T1) > sizeof(T2))>struct max_type{typedef T1 type;};\ntemplate<class T1, class T2> struct max_type<T1, T2, false>{typedef T2 type;};\n\ntemplate<class T> struct vec_rank : integral_constant<int, 0> {};\ntemplate<class T> struct vec_rank<vector<T>> : integral_constant<int, vec_rank<T>{} + 1> {};\n\n//N個のTを並べたtupleを返す\n//tuple_n<3, int>::type  tuple<int, int, int>\ntemplate<size_t N, class T, class... Arg> struct tuple_n{typedef typename tuple_n<N-1, T, T,  Arg...>::type type;};\ntemplate<class T, class...Arg> struct tuple_n<0, T, Arg...>{typedef tuple<Arg...> type;};\n\nstruct dummy_t1{};struct dummy_t2{};\nstruct dummy_t3{};struct dummy_t4{};\nstruct dummy_t5{};struct dummy_t6{};\n//template<class T, require(is_integral<T>::value)>など\n#define require_t(bo) enable_if_t<bo>* = nullptr\n\n//複数でオーバーロードする場合、引数が同じだとうまくいかないため\n//require_arg(bool, dummy_t1)\n//require_arg(bool, dummy_t2)等とする\n#define require_arg1(bo) enable_if_t<bo> * = nullptr\n#define require_arg2(bo, dummy_type) enable_if_t<bo, dummy_type> * = nullptr\n#define require_arg(...) over2(__VA_ARGS__,require_arg2,require_arg1)(__VA_ARGS__)\n//->//enable_if_tのtを書き忘れそうだから\n#define require_ret(bo, ret_type) enable_if_t<bo, ret_type>\n\n#define int long long //todo 消したら動かない intの代わりにsignedを使う\nauto start_time = system_clock::now();\nauto past_time = system_clock::now();\n\n#define debugName(VariableName) # VariableName\n//最大引数がN\n#define over2(o1, o2, name, ...) name\n#define over3(o1, o2, o3, name, ...) name\n#define over4(o1, o2, o3, o4, name, ...) name\n#define over5(o1, o2, o3, o4, o5, name, ...) name\n#define over6(o1, o2, o3, o4, o5, o6, name, ...) name\n#define over7(o1, o2, o3, o4, o5, o6, o7, name, ...) name\n#define over8(o1, o2, o3, o4, o5, o6, o7, o8, name, ...) name\n#define over9(o1, o2, o3, o4, o5, o6, o7, o8, o9, name, ...) name\n#define over10(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n\nvoid assert2(bool b,const string& s = \"\"){    if(!b){        cerr<<s<<endl;        exit(1);/*assert(0);*/    }}\n\n//my_nulloptをあらゆる操作の単位元的な物として扱う\n//vectorの参照外時に返したり、右辺値として渡されたときに何もしないなど\nstruct my_nullopt_t {} my_nullopt;\n#define nullopt_t my_nullopt_t\n#define nullopt my_nullopt\n/*@formatter:off*/\n//値が無いときは、setを使わない限り代入できない\n//=を使っても無視される\ntemplate<class T> struct my_optional {\nprivate:\n    bool is_null;\n    T v;\npublic:\n    typedef T value_type ;\n    my_optional() : is_null(true) {}\n    my_optional(const nullopt_t&) : is_null(true) {}\n    my_optional(const T& v) : v(v), is_null(false) {}\n    bool has_value() const { return !is_null; }\n    T &value() { static string mes = \"optional has no value\";assert2(!is_null, mes);return v;}\n    const T &value() const { static string mes = \"optional has no value\";assert2(!is_null, mes);return v;}\n    void set(const T &nv) {is_null = false;v = nv;}\n    template<class U> void operator=(const U &v) {\n        set(v);//null状態でも代入出来るようにした\n//        if (has_value())value() = v; else return;\n    }\n    template<class U> void operator=(const my_optional<U> &v) {\n        if (/*has_value() && */v.has_value())(*this) = v; else return;\n    }\n    /*@formatter:off*/\n    void reset() { is_null = true; }\n    void operator=(const nullopt_t &) { reset(); }\n    template<require_t(!is_same2(T, bool))>\n    explicit operator bool(){return !is_null;}\n    //nullの時はエラー\n    operator T&(){return value();}\n    operator const T&()const {return value();}\n    my_optional<T> operator++() {        if (this->has_value()) {            this->value()++;            return *this;        } else {            return *this;        }    }\n    my_optional<T> operator++(signed) {        if (this->has_value()) {            auto tem = *this;            this->value()++;            return tem;        } else {            return *this;        }    }\n    my_optional<T> operator--() {        if (this->has_value()) {            this->value()--;            return *this;        } else {            return *this;        }    }\n    my_optional<T> operator--(signed) {        if (this->has_value()) {            auto tem = *this;            this->value()--;            return tem;        } else {            return *this;        }    }\n};\ntemplate<class T>istream &operator>>(istream &iss, my_optional<T>& v) {    T val;    iss>>val;    v.set(val);    return iss;}\n\n\n#define optional my_optional\ntemplate<class T>\nusing opt = my_optional<T>;\n//template<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\ntemplate<class Key, class T, class Compare = less<Key>, class Allocator = allocator<pair<const Key, T> >>\nstruct o_map : std::map<Key, optional<T>, Compare, Allocator> {\n    optional<T> emp;\n    o_map() : std::map<Key, optional<T>, Compare, Allocator>() {}\n    auto operator()(const nullopt_t&) {return nullopt;}\n    optional<T> &operator()(const optional<Key> &k) {if (k.has_value()) {return std::map<Key, optional<T>, Compare, Allocator>::operator[](k.value());} else {emp.reset();return emp;}}\n    optional<T> &operator()(const Key &k) {        auto &v = std::map<Key, optional<T>, Compare, Allocator>::operator[](k);        if (v.has_value())return v;        else {            v.set(0);            return v;        }    }\n    template<class U> void operator[](U){static string mes = \"s_map cant []\";assert2(0, mes);}\n};\n//以下、空のoptionalをnulloptと書く\n//ov[-1(参照外)] でnulloptを返す\n//ov[nullopt] で nulloptをかえす\n\ntemplate<class T> struct ov{\n    optional<T> emp;\n    vector<optional<T>> v;\n    ov(int i = 0, T val = 0):v(i, val){}\n    template<class U>ov(const U& rhs){v.resize(sz(rhs));for (int i  = 0; i  < sz(rhs); i ++)v[i].set(rhs[i]);}\n    optional<T> &operator()(int i) {if (i < 0 || sz(v) <= i) {emp.reset();return emp;} else { return v[i]; }}\n    optional<T> &operator()(const nullopt_t &) {        return operator()(-1);    }\n    optional<T> &operator()(const optional<T> &i) {        if (i.has_value())return operator()(i.value());        else {            return operator()(-1);        }    }\n/*@formatter:off*/\n};\ntemplate<class T>string deb_tos(const ov<T>& v){\n    return deb_tos(v.v);\n}\n\n//vectorに対しての処理は.vを呼ぶ\ntemplate<class T> class ovv{\n    optional<T> emp;\npublic:\n    vector<vector<optional<T>> > v ;\n    ovv(int i=0, int j=0, T val = 0) : v(i, vector<optional<T>>(j, val) ){}\n    optional<T> &operator()(int i, int j) {        if (i < 0 || j < 0 || sz(v) <= i || sz(v[i]) <= j) {            emp.reset();return emp;        }        else { return v[i][j]; }    }\n    //再帰ver 遅いと思う\n//    optional<T>& gets(optional<T>& v){return v;}\n//    template<class V, class H, class... U> optional<T>& gets(V& v, H i, U... tail){        if constexpr(is_same2(H, nullopt_t))return operator()(-1,-1);        else if constexpr(is_same2(H, optional<int>)){            if(i.has_value())return gets(v[(int)i], tail...);            else return operator()(-1,-1);        }else if constexpr(is_integral<H>::value){            return gets(v[(int)i], tail...);        }else{            assert(0);            return emp;        }    }\n#if __cplusplus >= 201703L\n    //if constexprバージョン 上が遅かったらこれで\n    template<class U, class V> optional<T> &operator()(const U &i, const V &j) {        /*駄目な場合を除外*/        if constexpr(is_same2(U, nullopt_t) || is_same2(U, nullopt_t)) {            return operator()(-1, -1);            /* o, o*/        } else if constexpr(is_same2(U, optional<int>) && is_same2(V, optional<int>)) {            return operator()(i.has_value() ? (int) i : -1, j.has_value() ? (int) j : -1);            /* o, x*/        } else if constexpr(is_same2(U, optional<int>)) {            return operator()(i.has_value() ? (int) i : -1, (int) j);            /* x, o*/        } else if constexpr(is_same2(V, optional<int>)) {            return operator()((int) i, j.has_value() ? (int) j : -1);            /* x, x*/        } else {            return operator()((int) i, (int) j);        }    }\n#endif\n    operator const vector<vector<optional<T>> >&(){\n        return v;\n    }\n};\ntemplate<class T>istream &operator>>(istream &iss, ovv<T> &a) {    for (int h  = 0; h  < sz(a); h ++){        for (int w  = 0; w  < sz(a[h]); w ++){            iss>>a.v[h][w ];        }    }    return iss;}\n\ntemplate<class T>string deb_tos(const ovv<T>& v){\n    return deb_tos(v.v);\n}\ntemplate<class T> struct ov3{\n    optional<T> emp;\n    vector<vector<vector<optional<T>>> > v ;\n    ov3(int i, int j, int k, T val = 0) : v(i, vector<vector<optional<T>>>(j, vector<optional<T>>(k, val) ) ){}\n    optional<T> &operator()(int i, int j, int k) {        if (i < 0 || j < 0 || sz(v) <= i || sz(v[i]) <= j) {            if(k < 0 || sz(v[i][j]) <= k){                emp.reset();                return emp;            }        }        return v[i][j][k];    }\nprivate:\n#if __cplusplus >= 201703L\n    //再帰ver 遅いと思う\n    template<class V, class H> optional<T> &gets(V &nowv, H i) {        if constexpr(is_same2(H, nullopt_t)) {            emp.reset(); return emp;        } else if constexpr(is_same2(H, optional<int>)) {            if (i.has_value()) {                return nowv[(int) i];            } else {                emp.reset();return emp;            }        } else if constexpr(is_integral<H>::value) {            return nowv[(int) i];        } else {            static string mes = \"ov3 error not index\";assert2(0, mes);            emp.reset();return emp;        }    }\n    //todo const &消した\n    template<class V, class H, class... U> optional<T> &gets(V &nowv, H i, U... tail) {        if constexpr(is_same2(H, nullopt_t)) {            emp.reset();return emp;        } else if constexpr(is_same2(H, optional<int>)) {            if (i.has_value()) {                return gets(nowv[(int) i], tail...);            } else {                emp.reset();return emp;            }        } else if constexpr(is_integral<H>::value) {            return gets(nowv[(int) i], tail...);        } else {            static string mes = \"ov3 error not index\";assert2(0, mes);            emp.reset();return emp;        }    }\n#endif\npublic:\n    template<class U, class V, class W> optional<T> &operator()(U i, V j, W k) {        return gets(v, i, j, k);    }\n/*@formatter:off*/\n};\ntemplate<class T>string deb_tos(const ov3<T>& v){\n    return deb_tos(v.v);\n}\n//nullopt_t\n//優先順位\n//null, [opt, tem]\n\n// + と += は違う意味を持つ\n//val+=null : val\n//val+null  : null\n//\n//+は途中計算\n//+=は最終的に格納したい値にだけ持たせる\n//+=がvoidを返すのは、途中計算で使うのを抑制するため\n\n//nulloptを考慮する際、計算途中では+を使ってnulloptを作り\n//格納する際は+=で無効にする必要がある\n\n//演算子==\n//optional<int>(10) == 10\n\n//全ての型に対応させ、value_typeが等しいかを見るようにするのもありかも\n\n//null同士を比較する状況はおかしいのではないか\nbool operator==(const nullopt_t &, const nullopt_t&){assert2(0, \"nul == null  cant hikaku\");return false;}\ntemplate<class T> bool operator==(const nullopt_t &, const T&){return false;}\ntemplate<class T> bool operator!=(const nullopt_t &, const T&){return true;}\ntemplate<class T> bool operator==(const T&, const nullopt_t &){return false;}\ntemplate<class T> bool operator!=(const T&, const nullopt_t &){return true;}\n//nullを\n\nnullopt_t& operator +(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator -(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator *(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator /(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator +=(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator -=(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator *=(const nullopt_t &, const nullopt_t&) {return nullopt;}\nnullopt_t& operator /=(const nullopt_t &, const nullopt_t&) {return nullopt;}\n\ntemplate<class ANY> nullopt_t operator+(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator-(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator*(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator/(const nullopt_t&, const ANY &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator+(const ANY &, const nullopt_t &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator-(const ANY &, const nullopt_t &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator*(const ANY &, const nullopt_t &) {return nullopt;}\ntemplate<class ANY> nullopt_t operator/(const ANY &, const nullopt_t &) {return nullopt;}\n\ntemplate<class ANY> void operator+=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator-=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator*=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator/=(nullopt_t &, const ANY &) {}\ntemplate<class ANY> void operator+=(ANY &, const nullopt_t &) {}\ntemplate<class ANY> void operator-=(ANY &, const nullopt_t &) {}\ntemplate<class ANY> void operator*=(ANY &, const nullopt_t &) {}\ntemplate<class ANY> void operator/=(ANY &, const nullopt_t &) {}\n\ntemplate<class T>struct is_optional:false_type{};\ntemplate<class T>struct is_optional<optional<T>>:true_type{};\ntemplate<class T, class U>\ntrue_type both_optional(optional<T> t, optional<U> u);\nfalse_type both_optional(...);\n\ntemplate<class T, class U> class opt_check : public decltype(both_optional(declval<T>(), declval<U>())) {};\n\n//optionalは同じ型同士しか足せない\n//(o, t), (t, o), (o, o)\n#define opt_tem(op) \\\ntemplate<class O, class O_ret = decltype(declval<O>() op declval<O>())>optional<O_ret> operator op(const optional<O> &opt1, const optional<O> &opt2) {    if (!opt1.has_value() || !opt2.has_value()) { return optional<O_ret>(); }    else {        return optional<O_ret>(opt1.value() op opt2.value());    }}\\\ntemplate<class O, class T, class O_ret = decltype(declval<O>() op declval<O>())> auto operator op(const optional<O> &opt, const T &tem) -> require_ret(!(opt_check<optional<O>, T>::value), optional<O_ret>) {    if (!opt.has_value()) { return optional<O_ret>(); }    else {        return optional<O_ret>(opt.value() op tem);    }}\\\ntemplate<class O, class T, class O_ret = decltype(declval<O>() op declval<O>())> auto operator op(const T &tem, const optional<O> &opt) -> require_ret(!(opt_check<optional<O>, T>::value), optional<O_ret>) {    if (!opt.has_value()) { return optional<O_ret>(); }    else {        return optional<O_ret>(opt.value() op tem);    }}\n/*@formatter:off*/\nopt_tem(+)opt_tem(-)opt_tem(*)opt_tem(/)\n//比較はoptional<bool>を返す\nopt_tem(<)opt_tem(>)opt_tem(<=)opt_tem(>=)\n\n/*@formatter:on*//*@formatter:off*/\n\ntemplate<class O, class T> bool operator==(const optional<O>& opt, const T& tem){if(opt.has_value()){return opt.value()==tem;}else return nullopt == tem;}\ntemplate<class O, class T> bool operator!=(const optional<O>& opt, const T& tem){if(opt.has_value()){return opt.value()!=tem;}else return nullopt != tem;}\ntemplate<class O, class T> bool operator==(const T& tem, const optional<O>& opt){if(opt.has_value()){return opt.value()==tem;}else return nullopt == tem;}\ntemplate<class O, class T> bool operator!=(const T& tem, const optional<O>& opt){if(opt.has_value()){return opt.value()!=tem;}else return nullopt != tem;}\n\n\ntemplate<class O> bool operator==(const optional<O>& opt1, const optional<O>& opt2){    if(opt1.has_value() != opt2.has_value()){        return false;    }else if(opt1.has_value()){        return opt1.value() == opt2.value();    }else {        return nullopt == nullopt;    }}\ntemplate<class O> bool operator!=(const optional<O>& opt1, const optional<O>& opt2){return !(opt1 == opt2);}\n\n//(a+=null) != (a=a+null)\n// a            null\ntemplate<class T, class O> void operator+=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem += opt.value(); }}\ntemplate<class T, class O> void operator-=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem -= opt.value(); }}\ntemplate<class T, class O> void operator*=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem *= opt.value(); }}\ntemplate<class T, class O> void operator/=(T &tem, const optional<O> &opt) { if (opt.has_value()) { tem /= opt.value(); }}\n\ntemplate<class T, class O> void operator+=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() += tem; }}\ntemplate<class T, class O> void operator-=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() -= tem; }}\ntemplate<class T, class O> void operator*=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() *= tem; }}\ntemplate<class T, class O> void operator/=(optional<O> &opt, const T &tem) { if (opt.has_value()) { opt.value() /= tem; }}\n//\ntemplate<class Ol, class Or> void operator+=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl += opr.value(); }}\ntemplate<class Ol, class Or> void operator-=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl -= opr.value(); }}\ntemplate<class Ol, class Or> void operator*=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl *= opr.value(); }}\ntemplate<class Ol, class Or> void operator/=(optional<Ol> &opl, const optional<Or> &opr) { if (opr.has_value()) { return opl /= opr.value(); }}\n\n/*@formatter:off*/\n\ntemplate<class U> auto max(const nullopt_t &, const U &val) { return val; }\ntemplate<class U> auto max(const U &val, const nullopt_t &) { return val; }\ntemplate<class U> auto min(const nullopt_t &, const U &val) { return val; }\ntemplate<class U> auto min(const U &val, const nullopt_t &) { return val; }\n\ntemplate<class T, class U> auto max(const optional<T> &opt, const U &val) { if (opt.has_value())return max(opt.value(), val); else return val; }\ntemplate<class T, class U> auto max(const U &val, const optional<T> &opt) { if (opt.has_value())return max(opt.value(), val); else return val; }\ntemplate<class T, class U> auto min(const optional<T> &opt, const U &val) { if (opt.has_value())return min(opt.value(), val); else return val; }\ntemplate<class T, class U> auto min(const U &val, const optional<T> &opt) { if (opt.has_value())return min(opt.value(), val); else return val; }\n\n//null , optional, T\nbool chma(nullopt_t &, const nullopt_t &) { return false; }\ntemplate<class T> bool chma(T &opt, const nullopt_t &) { return false; }\ntemplate<class T> bool chma(nullopt_t &, const T &opt) { return false; }\ntemplate<class T> bool chma(optional<T> &olv, const optional<T> &orv) { if (orv.has_value()) { return chma(olv, orv.value()); } else return false; }\ntemplate<class T, class U> bool chma(optional<T> &opt, const U &rhs) { if (opt.has_value()) { return chma(opt.value(), rhs); } else return false; }\ntemplate<class T, class U> bool chma(T &lhs, const optional<U> &opt) { if (opt.has_value()) { return chma(lhs, opt.value()); } else return false; }\n\nbool chmi(nullopt_t &, const nullopt_t &) { return false; }\ntemplate<class T> bool chmi(T &opt, const nullopt_t &) { return false; }\ntemplate<class T> bool chmi(nullopt_t &, const T &opt) { return false; }\ntemplate<class T> bool chmi(optional<T> &olv, const optional<T> &orv) { if (orv.has_value()) { return chmi(olv, orv.value()); } else return false; }\ntemplate<class T, class U> bool chmi(optional<T> &opt, const U &rhs) { if (opt.has_value()) { return chmi(opt.value(), rhs); } else return false; }\ntemplate<class T, class U> bool chmi(T &lhs, const optional<U> &opt) { if (opt.has_value()) { return chmi(lhs, opt.value()); } else return false; }\n\n\ntemplate<class T> ostream &operator<<(ostream &os, optional<T> p) {    if (p.has_value())os << p.value(); else os << \"e\";    return os;}\ntemplate<class T>using opt = my_optional<T>;\nstruct xorshift {\n    /*@formatter:on*/\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    /*@formatter:off*/\n    size_t operator()(const uint64_t& x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }\n    size_t operator()(const std::pair<ll, ll>& x) const {        ll v = ((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }\n    template<class T, class U> size_t operator()(const std::pair<T, U>& x) const{        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        uint64_t hasx = splitmix64(x.first);        uint64_t hasy = splitmix64(x.second + FIXED_RANDOM);        return hasx ^ hasy;    }\n    template<class T> size_t operator()(const vector<T> &x) const {        uint64_t has = 0;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        uint64_t rv = splitmix64(FIXED_RANDOM);        for (int i  = 0; i  < sz(x); i ++){            uint64_t v = splitmix64(x[i] + rv);            has ^= v;            rv = splitmix64(rv);        }        return has;    }\n};\n\n#ifdef _DEBUG\nstring message;\nstring res_mes;\n//#define use_debtor\n//template<class T, class U, class X> auto count(unordered_map<T, U> &a, X k) { return a.find(k) != a.end(); }\n\n#ifdef use_debtor\n//https://marycore.jp/prog/cpp/class-extension-methods/ 違うかも\ntemplate<class T, class A = std::allocator<T>> struct debtor : std::vector<T, A> {\n    using std::vector<T, A>::vector;\n    template<class U> int deb_v(U a, int v) { return v; }\n    template<class U> int deb_v(debtor<U> &a, int v = 0) {        cerr << a.size() << \" \";        return deb_v(a.at(0), v + 1);    }\n    template<class U> void deb_o(U a) { cerr << a << \" \"; }\n    template<class U> void deb_o(debtor<U> &a) {        for (int i = 0; i < min((int) a.size(), 15ll); i++) { deb_o(a[i]); }        if ((int) a.size() > 15) { cerr << \"...\"; }        cerr << endl;    }\n    typename std::vector<T>::reference my_at(typename std::vector<T>::size_type n, vector<int> &ind) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            ind.push_back(n);            cerr << \"out index at  \";            for (auto &&i: ind) {                cerr << i << \" \";            }            cerr << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n    typename std::vector<T>::reference operator[](typename std::vector<T>::size_type n) {        if (n < 0 || n >= (int) this->size()) {            int siz = (int) this->size();            cerr << \"vector size = \";            int dim = deb_v((*this));            cerr << endl;            cerr << \"out index at  \" << n << endl;            cerr << endl;            if (dim <= 2) { deb_o((*this)); }            exit(0);        }        return this->at(n);    }\n};\n#define vector debtor\n#endif\n#ifdef use_pbds\ntemplate<class T> struct my_pbds_tree {\n    set<T> s;\n    auto begin() { return s.begin(); }\n    auto end() { return s.end(); }\n    auto rbegin() { return s.rbegin(); }\n    auto rend() { return s.rend(); }\n    auto empty() { return s.empty(); }\n    auto size() { return s.size(); }\n    void clear() { s.clear(); }\n    template<class U> void insert(U v) { s.insert(v); }\n    template<class U> void operator+=(U v) { insert(v); }\n    template<class F> auto erase(F v) { return s.erase(v); }\n    template<class U> auto find(U v) { return s.find(v); }\n    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }\n    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }\n    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }\n    auto order_of_key(ll v) {        auto it = s.begin();        ll i = 0;        for (; it != s.end() && *it < v; i++)it++;        return i;    }\n};\n#define pbds(T) my_pbds_tree<T>\n#endif\n\n//区間削除は出来ない\n//gp_hash_tableでcountを使えないようにするため\ntemplate<class T, class U> struct my_unordered_map { unordered_map<T, U> m; my_unordered_map() {}; auto begin() { return m.begin(); } auto end() { return m.end(); } auto cbegin() { return m.cbegin(); } auto cend() { return m.cend(); } template<class V> auto erase(V v) { return m.erase(v); } void clear() { m.clear(); }    /*countは gp_hash_tableに存在しない*/    /*!= m.end()*/    template<class V> auto find(V v) { return m.find(v); } template<class V> auto &operator[](V n) { return m[n]; }};\ntemplate<class K, class V>using umap_f = my_unordered_map<K, V>;\n#else\n#define endl '\\n'\n//umapはunorderd_mapになる\n//umapiはgp_hash_table\n\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n\ntemplate<class K, class V>using umap_f = __gnu_pbds::gp_hash_table<K, V, xorshift>;\n#endif\n#define umapi unordered_map<ll,ll>\n#define umapp unordered_map<P,ll>\n#define umappp unordered_map<P,P>\n#define umapu unordered_map<uint64_t,ll>\n#define umapip unordered_map<ll,P>\n\ntemplate<class T, class U, class X> auto count(unordered_map<T, U> &a, X k) { return a.find(k) != a.end(); }\n/*@formatter:off*/\n#ifdef use_pbds\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n#endif\n//衝突対策\n#define ws ws_\n\n//todo 要らないと思う\ntemplate<class A, class B, class C> struct T2 { A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const { return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   } bool operator>(const T2 &r) const { return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   } bool operator==(const T2 &r) const { return f == r.f && s == r.s && t == r.t; } bool operator!=(const T2 &r) const { return f != r.f || s != r.s || t != r.t; }};\ntemplate<class A, class B, class C, class D> struct F2 {\n    A a;B b;C c;D d;\n    F2() { a = 0, b = 0, c = 0, d = 0; }\n    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F2 &r) const { return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }\n    bool operator>(const F2 &r) const { return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }\n    bool operator==(const F2 &r) const { return a == r.a && b == r.b && c == r.c && d == r.d; }\n    bool operator!=(const F2 &r) const { return a != r.a || b != r.b || c != r.c || d != r.d; }\n    ll operator[](ll i) {assert(i < 4);return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;}\n};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\n//T mt(ll a, ll b, ll c) { return T(a, b, c); }\n//F mf(ll a, ll b, ll c, ll d) { return F(a, b, c, d); }\n\n//関数内をまとめる\n//初期値l=-1, r=-1\nvoid set_lr12(int &l, int &r, int n) {    /*r==-1*/    if (r == -1) {        if (l == -1) {            l = 0;            r = n;        } else {            r = l;            l = 0;        }    }}\n//@マクロ省略系 型,構造\n//using で元のdoubleを同時に使えるはず\n#define double_big\n\n#ifdef double_big\n#define double long double\n//#define pow powl\n#endif\nusing dou = double;\n\n/*@formatter:off*/\ntemplate<class T> T MAX() { return numeric_limits<T>::max(); }\ntemplate<class T> T MIN() { return numeric_limits<T>::min(); }\nconstexpr ll inf = (ll) 1e9 + 100;\nconstexpr ll linf = (ll) 1e18 + 100;\nconstexpr dou dinf = (dou) linf * linf;\nconstexpr char infc = '{';\nconst string infs = \"{\";\n\ntemplate<class T> T INF() { return MAX<T>() / 2; }\ntemplate<> signed INF() { return inf; }\ntemplate<> ll INF() { return linf; }\ntemplate<> double INF() { return dinf; }\ntemplate<> char INF() { return infc; }\ntemplate<> string INF() { return infs; }\n\nconst double eps = 1e-9;\n\n//#define use_epsdou\n#ifdef use_epsdou\n//基本コメントアウト\nstruct epsdou {    double v;    epsdou(double v = 0) : v(v) {}    template<class T> epsdou &operator+=(T b) {        v += (double) b;        return (*this);    }    template<class T> epsdou &operator-=(T b) {        v -= (double) b;        return (*this);    }    template<class T> epsdou &operator*=(T b) {        v *= (double) b;        return (*this);    }    template<class T> epsdou &operator/=(T b) {        v /= (double) b;        return (*this);    }    epsdou operator+(epsdou b) { return v + (double) b; }    epsdou operator-(epsdou b) { return v - (double) b; }    epsdou operator*(epsdou b) { return v * (double) b; }    epsdou operator/(epsdou b) { return v / (double) b; }    epsdou operator-() const { return epsdou(-v); }    template<class T> bool operator<(T b) { return v < (double) b; }    template<class T> bool operator>(T b) {auto r = (double)b;        return v > (double) b; }    template<class T> bool operator==(T b) { return fabs(v - (double) b) <= eps; }    template<class T> bool operator<=(T b) { return v < (double) b || fabs(v - b) <= eps; }    template<class T> bool operator>=(T b) { return v > (double) b || fabs(v - b) <= eps; }    operator double() { return v; }};\ntemplate<>epsdou MAX(){return MAX<double>();}\ntemplate<>epsdou MIN(){return MIN<double>();}\n//priqrity_queue等で使うのに必要\nbool operator<(const epsdou &a, const epsdou &b) {return a.v < b.v;}\nbool operator>(const epsdou &a, const epsdou &b) {return a.v > b.v;}\nistream &operator>>(istream &iss, epsdou &a) {iss >> a.v;return iss;}\nostream &operator<<(ostream &os, epsdou &a) {os << a.v;return os;}\n#define eps_conr_t(o) template<class T> epsdou operator o(T a, epsdou b) {return (dou) a o b.v;}\n#define eps_conl_t(o) template<class T> epsdou operator o(epsdou a, T b) {return a.v o (dou) b;}\neps_conl_t(+)eps_conl_t(-)eps_conl_t(*)eps_conl_t(/)eps_conr_t(+)eps_conr_t(-)eps_conr_t(*)eps_conr_t(/)\n//template<class U> epsdou max(epsdou a, U b){return a.v>b ? a.v: b;}\n//template<class U> epsdou max(U a, epsdou b){return a>b.v ? a: b.v;}\n//template<class U> epsdou min(epsdou a, U b){return a.v<b ? a.v: b;}\n//template<class U> epsdou min(U a, epsdou b){return a<b.v ? a: b.v;}\n#undef double\n#define double epsdou\n#undef dou\n#define dou epsdou\n#endif\n\ntemplate<class T = int, class A, class B = int> T my_pow(A a, B b = 2) {\n    if(b < 0)return (T)1 / my_pow<T>(a, -b);\n#if __cplusplus >= 201703L\n    if constexpr(is_floating_point<T>::value) { return pow((T) a, (T) b); }\n    else if constexpr(is_floating_point<A>::value) { assert2(0, \"pow <not dou>(dou, )\");/*return 0;しない方がコンパイル前に(voidを受け取るので)エラーが出ていいかも*/}\n    else if constexpr(is_floating_point<B>::value) { assert2(0, \"pow <not dou>(, dou)\");/*return 0;しない方がコンパイル前に(voidを受け取るので)エラーが出ていいかも*/}\n    else {\n#endif\n        T ret = 1;        T bek = a;        while (b) {            if (b & 1)ret *= bek;            bek *= bek;            b >>= 1;        }        return ret;\n#if __cplusplus >= 201703L\n    }\n#endif\n}\n#define pow my_pow\n\n#define ull unsigned long long\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define upd update\n#define sstream stringstream\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam1(ret) [&](auto&& v){return ret;}\n#define lam2(v, ret) [&](auto&& v){return ret;}\n#define lam(...) over2(__VA_ARGS__,lam2,lam1)(__VA_ARGS__)\n#define lamr(right) [&](auto&& p){return p right;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t, a) vector<vector<t>>a\n#define vvt2(t, a, b) vector<vector<t>>a(b)\n#define vvt3(t, a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t, a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n#define vvt(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(T,__VA_ARGS__)\n#define vv(type, ...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(type,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type, name, ...) auto name = make_v<type>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setp = set<P>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define uset unordered_set\n#define useti unordered_set<ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define mmap multimap\n//任意のマクロサポート用 使う度に初期化する\nint index_, v1_, v2_, v3_;\n\n/*@formatter:off*/\nstring to_string(char c) {    string ret = \"\";    ret += c;    return ret;}\ntemplate<class T> class pq_min_max {    vector<T> d;    void make_heap() {        for (int i = d.size(); i--;) {            if (i & 1 && d[i - 1] < d[i]) swap(d[i - 1], d[i]);            int k = down(i);            up(k, i);        }    }    inline int parent(int k) const { return ((k >> 1) - 1) & ~1; }    int down(int k) {        int n = d.size();        if (k & 1) { /* min heap*/            while (2 * k + 1 < n) {                int c = 2 * k + 3;                if (n <= c || d[c - 2] < d[c]) c -= 2;                if (c < n && d[c] < d[k]) {                    swap(d[k], d[c]);                    k = c;                }                else break;            }        }        else { /* max heap*/            while (2 * k + 2 < n) {                int c = 2 * k + 4;                if (n <= c || d[c] < d[c - 2]) c -= 2;                if (c < n && d[k] < d[c]) {                    swap(d[k], d[c]);                    k = c;                }                else break;            }        }        return k;    }    int up(int k, int root = 1) {        if ((k | 1) < (int) d.size() && d[k & ~1] < d[k | 1]) {            swap(d[k & ~1], d[k | 1]);            k ^= 1;        }        int p;        while (root < k && d[p = parent(k)] < d[k]) { /*max heap*/            swap(d[p], d[k]);            k = p;        }        while (root < k && d[k] < d[p = parent(k) | 1]) { /* min heap*/            swap(d[p], d[k]);            k = p;        }        return k;    }public:    pq_min_max() {}    pq_min_max(const vector<T> &d_) : d(d_) { make_heap(); }    template<class Iter> pq_min_max(Iter first, Iter last) : d(first, last) { make_heap(); }    void operator+=(const T &x) {        int k = d.size();        d.push_back(x);        up(k);    }    void pop_min() {        if (d.size() < 3u) { d.pop_back(); }        else {            swap(d[1], d.back());            d.pop_back();            int k = down(1);            up(k);        }    }    void pop_max() {        if (d.size() < 2u) { d.pop_back(); }        else {            swap(d[0], d.back());            d.pop_back();            int k = down(0);            up(k);        }    }    const T &get_min() const { return d.size() < 2u ? d[0] : d[1]; }    const T &get_max() const { return d[0]; }    int size() const { return d.size(); }    bool empty() const { return d.empty(); }};\n//小さいほうからM個取得するpq\ntemplate<class T> struct helper_pq_size {    pq_min_max<T> q;    T su = 0;    int max_size = 0;    helper_pq_size() {}    helper_pq_size(int max_size) : max_size(max_size) {}    void clear() {        q = pq_min_max<T>();        su = 0;    }    void operator+=(T v) {        su += v;        q += (v);        if (sz(q) > max_size) {            su -= q.get_max();            q.pop_max();        }    }    T sum() { return su; }    T top() { return q.get_min(); }    void pop() {        su -= q.get_min();        q.pop_min();    }    T poll() {        T ret = q.get_min();        su -= ret;        q.pop_min();        return ret;    }    ll size() { return q.size(); }};\n//大きいほうからM個取得するpq\ntemplate<class T> struct helper_pqg_size {    pq_min_max<T> q;    T su = 0;    int max_size = 0;    helper_pqg_size() {}    helper_pqg_size(int max_size) : max_size(max_size) {}    void clear() {        q = pq_min_max<T>();        su = 0;    }    void operator+=(T v) {        su += v;        q += (v);        if (sz(q) > max_size) {            su -= q.get_min();            q.pop_min();        }    }    T sum() { return su; }    T top() { return q.get_max(); }    void pop() {        su -= q.get_max();        q.pop_max();    }    T poll() {        T ret = q.get_max();        su -= ret;        q.pop_min();        return ret;    }    ll size() { return q.size(); }};;\n\ntemplate<class T, class Container = vector<T>,class Compare = std::less<typename Container::value_type>>\nstruct helper_pqg {    priority_queue<T, Container, Compare> q;/*小さい順*/    T su = 0;    helper_pqg() {}    void clear() {        q = priority_queue<T, vector<T>, greater<T> >();        su = 0;    }    void operator+=(T v) {        su += v;        q.push(v);    }    T sum() { return su; }    T top() { return q.top(); }    void pop() {        su -= q.top();        q.pop();    }    T poll() {        T ret = q.top();        su -= ret;        q.pop();        return ret;    }    ll size() { return q.size(); }};\ntemplate<class T>\nusing  helper_pq = helper_pqg<T, vector<T>, greater<T>>;\n#if __cplusplus >= 201703L\n\n//小さいほうからsize個残る\n//Tがoptionalなら空の時nullを返す\ntemplate<class T> struct pq {\n    helper_pq<T> a_q;/*大きい順*/    helper_pq_size<T> b_q;/*大きい順*/    bool aquery;\n    T su = 0;\n    pq(int size = inf) {aquery = size == inf;if (!aquery) { b_q = helper_pq_size<T>(size); }}\n    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }\n    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }\n    //optionalなら空の時nullを返す\n    T top() {        if constexpr(is_optional<T>::value) {            if (aquery) {                if (sz(a_q) == 0)return T();                return a_q.top();            }            else {                if (sz(b_q) == 0)return T();                return b_q.top();            }        }        else { if (aquery)return a_q.top(); else return b_q.top(); }    }\n    T sum() { if (aquery) return a_q.sum(); else return b_q.sum(); }\n    //optionalなら空の時何もしない\n    void pop() { if constexpr(is_optional<T>::value) { if (aquery) { if (sz(a_q))a_q.pop(); } else { if (sz(b_q))b_q.pop(); }} else { if (aquery)a_q.pop(); else b_q.pop(); }}    /*T*/\n    T poll() {        if constexpr(is_optional<T>::value) {            if (aquery) {                if (sz(a_q) == 0)return T();                return a_q.poll();            }            else {                if (sz(b_q) == 0)return T();                return b_q.poll();            }        }        else { if (aquery)return a_q.poll(); else return b_q.poll(); }    }\n    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }\n    /*@formatter:off*/\n};\ntemplate<class T> struct pqg {    helper_pqg<T> a_q;/*大きい順*/    helper_pqg_size<T> b_q;/*大きい順*/    bool aquery;    T su = 0;    pqg(int size = inf) {        aquery = size == inf;        if (!aquery) { b_q = helper_pqg_size<T>(size); }    }    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }    T sum() { if (aquery)return a_q.sum(); else return b_q.sum(); }    T top() { if (aquery) return a_q.top(); else return b_q.top(); }    void pop() { if (aquery) a_q.pop(); else b_q.pop(); }    T poll() { if (aquery) return a_q.poll(); else return b_q.poll(); }    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }};\n#else\n//小さいほうからsize個残る\ntemplate<class T> struct pq {    helper_pq<T> a_q;/*大きい順*/    helper_pq_size<T> b_q;/*大きい順*/    bool aquery;    T su = 0;    pq(int size = inf) {        aquery = size == inf;        if (!aquery) { b_q = helper_pq_size<T>(size); }    }    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }    T sum() { if (aquery)return a_q.sum(); else return b_q.sum(); }    T top() { if (aquery) return a_q.top(); else return b_q.top(); }    void pop() { if (aquery) a_q.pop(); else b_q.pop(); }    T poll() { if (aquery) return a_q.poll(); else return b_q.poll(); }    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }};\n//大きいほうからsize個残る\ntemplate<class T> struct pqg {    helper_pqg<T> a_q;/*大きい順*/    helper_pqg_size<T> b_q;/*大きい順*/    bool aquery;    T su = 0;    pqg(int size = inf) {        aquery = size == inf;        if (!aquery) { b_q = helper_pqg_size<T>(size); }    }    void clear() { if (aquery) a_q.clear(); else b_q.clear(); }    void operator+=(T v) { if (aquery) a_q += v; else b_q += v; }    T sum() { if (aquery)return a_q.sum(); else return b_q.sum(); }    T top() { if (aquery) return a_q.top(); else return b_q.top(); }    void pop() { if (aquery) a_q.pop(); else b_q.pop(); }    T poll() { if (aquery) return a_q.poll(); else return b_q.poll(); }    ll size() { if (aquery) return a_q.size(); else return b_q.size(); }};\n#endif\n#define pqi pq<ll>\n#define pqgi pqg<ll>\ntemplate<class T> string deb_tos(pq<T> &q) {    vector<T> res;    auto temq = q;    while (sz(temq))res.push_back(temq.top()), temq.pop();    stringstream ss;    ss<< res;    return ss.str();}\ntemplate<class T> string deb_tos(pqg<T> &q) {    vector<T> res;    auto temq = q;    while (sz(temq))res.push_back(temq.top()), temq.pop();    stringstream ss;    ss<< res;    return ss.str();}\n\n/*@formatter:off*/\n//マクロ 繰り返し\n//↓@オーバーロード隔離\n//todo 使わないもの非表示\n#define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n#define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n//逆順 閉区間\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n\n#ifdef use_for\n\n//ループを一つにまとめないとフォーマットで汚くなるため\n#define nex_ind1(i) i++\n#define nex_ind2(i, j, J) i = (j + 1 == J) ? i + 1 : i, j = (j + 1 == J ? 0 : j + 1)\n#define nex_ind3(i, j, k, J, K)i = (j + 1 == J && k + 1 == K) ? i + 1 : i, j = (k + 1 == K) ? (j + 1 == J ? 0 : j + 1) : j, k = (k + 1 == K ? 0 : k + 1)\n#define nex_ind4(i, j, k, l, J, K, L) i = (j + 1 == J && k + 1 == K && l + 1 == L) ? i + 1 : i, j = (k + 1 == K && l + 1 == L) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L ?(k + 1 == K ? 0 : k + 1) : k), l = l + 1 == L ? 0 : l + 1\n#define nex_ind5(i, j, k, l, m, J, K, L, M) i = (j + 1 == J && k + 1 == K && l + 1 == L && m + 1 == M) ? i + 1 : i, j = (k + 1 == K && l + 1 == L && m + 1 == M) ? (j + 1 == J ? 0 : j + 1) : j, k = (l + 1 == L && m + 1 == M ?(k + 1 == K ? 0 : k + 1) : k), l =  m + 1 == M ? l+1 == L ? 0 : l+1 : l,  m = m + 1 == M ? 0 : m + 1\n\n#define repss2(i, I) for (int i = 0; i < I; i++)\n#define repss4(i, j, I, J) for (int i = (J ? 0 : I), j = 0; i < I; nex_ind2(i, j, J))\n#define repss6(i, j, k, I, J, K) for (int i = (J && K ? 0 : I), j = 0, k = 0; i < I; nex_ind3(i, j, k, J, K))\n#define repss8(i, j, k, l, I, J, K, L) for (int i = (J && K && L ? 0 : I), j = 0, k = 0, l = 0; i < I; nex_ind4(i, j, k, l, J, K, L))\n#define repss10(i, j, k, l, m, I, J, K, L, M)for (int i = (J && K && L && M ? 0 : I), j = 0, k = 0, l = 0, m = 0; i < I; nex_ind5(i, j, k, l, m, J, K, L, M))\n\n//i,j,k...をnまで見る\n#define reps2(i, n) repss2(i, n)\n#define reps3(i, j, n) repss4(i, j, n, n)\n#define reps4(i, j, k, n) repss6(i, j, k, n, n, n)\n#define reps5(i, j, k, l, n) repss8(i, j, k, l, n, n, n, n)\ntemplate<class T> void nex_repv2(int &i, int &j, int &I, int &J, vector<vector<T>> &s) {    while (1) {        j++;        if (j >= J) {            j = 0;            i++;            if (i < I) { J = (int) s[i].size(); }        }        if (i >= I || J) return;    }}\ntemplate<class T> void nex_repv3(int &i, int &j, int &k, int &I, int &J, int &K, vector<vector<vector<T>>> &s) {    while (1) {        k++;        if (k >= K) {            k = 0;            j++;            if (j >= J) {                j = 0;                i++;                if (i >= I)return;            }        }        J = (int) s[i].size();        K = (int) s[i][j].size();        if (J && K) return;    }}\n\n#define repv_2(i, a) repss2(i, sz(a))\n//正方形である必要はない\n//直前を持つのとどっちが早いか\n#define repv_3(i, j, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), i = 0, j = 0; i < repvI; nex_repv2(i,j,repvI,repvJ,a))\n//箱状になっている事が要求される つまり[i] 次元目の要素数は一定\n#define repv_4(i, j, k, a) for (int repvI = (int)a.size(), repvJ = (int)a[0].size(), repvK =(int)a[0][0].size(), i = 0, j = 0, k=0; i < repvI; nex_repv3(i,j,k,repvI,repvJ,repvK,a))\n#define repv_5(i, j, k, l, a) repss8(i, j, k, l, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]))\n#define repv_6(i, j, k, l, m, a) repss10(i, j, k, l, m, sz(a), sz(a[0]), sz(a[0][0]), sz(a[0][0][0]), sz(a[0][0][0][0]))\n#endif\n\ntemplate<typename T> struct has_rbegin_rend { private:template<typename U> static auto check(U &&obj) -> decltype(std::rbegin(obj), std::rend(obj), std::true_type{});static std::false_type check(...);public:static constexpr bool value = decltype(check(std::declval<T>()))::value; };\ntemplate<typename T> constexpr bool has_rbegin_rend_v = has_rbegin_rend<T>::value;\ntemplate<typename Iterator> class Range { public:Range(Iterator &&begin, Iterator &&end) noexcept: m_begin(std::forward<Iterator>(begin)), m_end(std::forward<Iterator>(end)) {}Iterator begin() const noexcept { return m_begin; }Iterator end() const noexcept { return m_end; }private:const Iterator m_begin;const Iterator m_end; };\ntemplate<typename Iterator> static inline Range<Iterator> makeRange(Iterator &&begin, Iterator &&end) noexcept { return Range<Iterator>{std::forward<Iterator>(begin), std::forward<Iterator>(end)}; }\ntemplate<typename T> static inline decltype(auto) makeReversedRange(const std::initializer_list<T> &iniList) noexcept { return makeRange(std::rbegin(iniList), std::rend(iniList)); }\ntemplate<typename T, typename std::enable_if_t<has_rbegin_rend_v<T>, std::nullptr_t> = nullptr> static inline decltype(auto) makeReversedRange(T &&c) noexcept { return makeRange(std::rbegin(c), std::rend(c)); }/* rbegin(), rend()を持たないものはこっちに分岐させて，エラーメッセージを少なくする*/template<typename T, typename std::enable_if<!has_rbegin_rend<T>::value, std::nullptr_t>::type = nullptr> static inline void makeReversedRange(T &&) noexcept { static_assert(has_rbegin_rend<T>::value, \"Specified argument doesn't have reverse iterator.\"); }\n\n//#define use_for\n\n#define form1(st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form3(k, v, st) for (auto &&form_it = st.begin(); form_it != st.end(); ++form_it)\n#define form4(k, v, st, r) for (auto &&form_it = st.begin(); form_it != st.end() && (*form_it).fi < r; ++form_it)\n#define form5(k, v, st, l, r) for (auto &&form_it = st.lower_bound(l); form_it != st.end() && (*form_it).fi < r; ++form_it)\n\n#define forrm1(st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n#define forrm3(k, v, st) for (auto &&forrm_it = st.rbegin(); forrm_it != st.rend(); ++forrm_it)\n\n//向こう側で\n// ++itか it = st.erase(it)とする\n#define fors1(st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors2(v, st) for (auto &&it = st.begin(); it != st.end(); )\n#define fors3(v, st, r) for (auto &&it = st.begin(); it != st.end() && (*it) < r; )\n#define fors4(v, st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r; )\n\n#ifdef use_for\n#define forslr3(st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr4(v, st, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end(); ++forslr_it)\n#define forslr5(v, st, r, a, b) for (auto &&forslr_it = st.begin(); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n#define forslr6(v, st, l, r, a, b) for (auto &&forslr_it = st.lower_bound(l); forslr_it != st.end() && (*forslr_it) < r; ++forslr_it)\n\n#define fora_f_init_2(a, A) ;\n#define fora_f_init_3(fora_f_i, a, A) auto &&a = A[fora_f_i];\n#define fora_f_init_4(a, b, A, B) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i];\n#define fora_f_init_5(fora_f_i, a, b, A, B) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i];\n#define fora_f_init_6(a, b, c, A, B, C) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i];\n#define fora_f_init_7(fora_f_i, a, b, c, A, B, C) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i];\n#define fora_f_init_8(a, b, c, d, A, B, C, D) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i]; auto && d = D[fora_f_i];\n#define fora_f_init_9(fora_f_i, a, b, c, d, A, B, C, D) auto &&a = A[fora_f_i]; auto &&b = B[fora_f_i]; auto &&c = C[fora_f_i]; auto && d = D[fora_f_i];\n#define fora_f_init(...) over9(__VA_ARGS__,fora_f_init_9, fora_f_init_8, fora_f_init_7, fora_f_init_6, fora_f_init_5, fora_f_init_4, fora_f_init_3, fora_f_init_2)(__VA_ARGS__)\n\n#define forr_init_2(a, A) auto &&a = A[forr_i];\n#define forr_init_3(forr_i, a, A) auto &&a = A[forr_i];\n#define forr_init_4(a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_5(forr_i, a, b, A, B) auto &&a = A[forr_i]; auto &&b = B[forr_i];\n#define forr_init_6(a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_7(forr_i, a, b, c, A, B, C) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i];\n#define forr_init_8(a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init_9(forr_i, a, b, c, d, A, B, C, D) auto &&a = A[forr_i]; auto &&b = B[forr_i]; auto &&c = C[forr_i]; auto && d = D[forr_i];\n#define forr_init(...) over9(__VA_ARGS__, forr_init_9, forr_init_8, forr_init_7, forr_init_6, forr_init_5, forr_init_4, forr_init_3, forr_init_2)(__VA_ARGS__)\n\n#define forp_init3(k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init4(forp_i, k, v, S) auto &&k = S[forp_i].first;auto &&v = S[forp_i].second;\n#define forp_init(...) over4(__VA_ARGS__,forp_init4,forp_init3,forp_init2,forp_init1)(__VA_ARGS__)\n\n#define form_init(k, v, ...) auto &&k = (*form_it).fi;auto &&v = (*form_it).se;\n#define forrm_init(k, v, ...) auto &&k = (*forrm_it).fi;auto &&v = (*forrm_it).se;\n#define fors_init(v, ...) auto &&v = (*it);\n\n#define forlr_init(a, A, ngl, ngr) auto a = A[forlr_i]; auto prev = forlr_i ? A[forlr_i-1] : ngl;auto next = forlr_i+1< rep2lim? A[forlr_i+1] : ngr;\n#define forslr_init4(a, A, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init5(a, A, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init6(a, A, l, r, ngl, ngr) auto a = (*forslr_it); auto prev = (forslr_it!=A.begin())? (*std::prev(forslr_it)) : ngl;auto next = (forslr_it!=std::prev(A.end()))? (*std::next(forslr_it)) : ngr;\n#define forslr_init(...)  over6(__VA_ARGS__,forslr_init6,forslr_init5,forslr_init4)(__VA_ARGS__);\n\n//こうしないとmapがおかしくなる\n#define fora_f_2(a, A) for(auto&& a : A)\n#define fora_f_3(fora_f_i, a, A) rep(fora_f_i, sz(A))\n#define fora_f_4(a, b, A, B) rep(fora_f_i, sz(A))\n#define fora_f_5(fora_f_i, a, b, A, B) rep(fora_f_i, sz(A))\n#define fora_f_6(a, b, c, A, B, C) rep(fora_f_i, sz(A))\n#define fora_f_7(fora_f_i, a, b, c, A, B, C) rep(fora_f_i, sz(A))\n#define fora_f_8(a, b, c, d, A, B, C, D) rep(fora_f_i, sz(A))\n#define fora_f_9(fora_f_i, a, b, c, d, A, B, C, D) rep(fora_f_i, sz(A))\n\n#define forr_2(a, A) rer(forr_i, sz(A)-1)\n#define forr_3(forr_i, a, A) rer(forr_i, sz(A)-1)\n#define forr_4(a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_5(forr_i, a, b, A, B) rer(forr_i, sz(A)-1)\n#define forr_6(a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_7(forr_i, a, b, c, A, B, C) rer(forr_i, sz(A)-1)\n#define forr_8(a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#define forr_9(forr_i, a, b, c, d, A, B, C, D) rer(forr_i, sz(A)-1)\n#endif\n//↑@オーバーロード隔離\n\n//rep系はインデックス、for系は中身\n#define rep(...) over4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rer(...) over4(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n\n//自分込みで残りがREM以上の間ループを回す\n#define rem(i, N, REM) for (int i = 0; i < N - REM + 1; i++)\n\n//char用のrep\n#define repc(i, m, n) for(char i = m,repc3lim=n; i < repc3lim ; ++i)\n//i,j,k...をnまで見る\n#define reps(...) over5(__VA_ARGS__,reps5,reps4,reps3,reps2,)(__VA_ARGS__)\n#define repss(...) over10(__VA_ARGS__, repss10, a, repss8, a, repss6, a, repss4, a, repss2) (__VA_ARGS__)\n//vectorのindexを走査する\n//repv(i,j,vvi)\n#define repv(...) over6(__VA_ARGS__,repv_6,repv_5,repv_4,repv_3,repv_2,)(__VA_ARGS__)\n#define rerv(i, A) for (int i = sz(A)-1; i >= 0 ; i--)\n//repvn(dp) nは次元\n#define repv1(a) repv(i, a)\n#define repv2(a) repv(i, j, a)\n#define repv3(a) repv(i, j, k, a)\n#define repv4(a) repv(i, j, k, l, a)\n#ifdef use_for\n#define fora_f(...) over9(__VA_ARGS__, fora_f_9, fora_f_8, fora_f_7, fora_f_6, fora_f_5, fora_f_4, fora_f_3, fora_f_2)(__VA_ARGS__)\n#endif\n#define forr(...) over9(__VA_ARGS__, forr_9, forr_8, forr_7, forr_6, forr_5, forr_4, forr_3, forr_2)(__VA_ARGS__)\n//0~N-2まで見る\n\n#define forar_init(v, rv, A) auto &&v = A[forar_i]; auto && rv = A[forar_i+1];\n#define forar(v, rv, A) rep(forar_i, sz(A) - 1)\n\n#if __cplusplus >= 201703L\ntemplate<size_t M_SZ, bool indexed, class Iterator, class T, class U=T, class V=T, class W=T>\nclass ite_vec_merge : public Iterator {    std::size_t i = 0;    vector<T> &A;    vector<U> &B;    vector<V> &C;    vector<W> &D;public :    ite_vec_merge(Iterator ita, vector<T> &A) : Iterator(ita), A(A), B(A), C(A), D(A) {}    ite_vec_merge(Iterator ita, vector<T> &A, vector<U> &B) : Iterator(ita), A(A), B(B), C(A), D(A) {}    ite_vec_merge(Iterator ita, vector<T> &A, vector<U> &B, vector<V> &C) : Iterator(ita), A(A), B(B), C(C), D(A) {}    ite_vec_merge(Iterator ita, vector<T> &A, vector<U> &B, vector<V> &C, vector<W> &D) : Iterator(ita), A(A), B(B), C(C), D(D) {}    auto &operator++() {        ++i;        this->Iterator::operator++();        return *this;    }    auto operator*() const noexcept {        if constexpr(!indexed && M_SZ == 1) { return tuple<T &>(A[i]); }        else if constexpr(!indexed && M_SZ == 2) { return tuple<T &, U &>(A[i], B[i]); }        else if constexpr(!indexed && M_SZ == 3) { return tuple<T &, U &, V &>(A[i], B[i], C[i]); }        else if constexpr(!indexed && M_SZ == 4) { return tuple<T &, U &, V &, W &>(A[i], B[i], C[i], D[i]); }        else if constexpr(indexed && M_SZ == 1) { return tuple<int, T &>(i, A[i]); }        else if constexpr(indexed && M_SZ == 2) { return tuple<int, T &, U &>(i, A[i], B[i]); }        else if constexpr(indexed && M_SZ == 3) { return tuple<int, T &, U &, V &>(i, A[i], B[i], C[i]); }        else if constexpr(indexed && M_SZ == 4) { return tuple<int, T &, U &, V &, W &>(i, A[i], B[i], C[i], D[i]); }        else {            assert(0);            return tuple<int>(i);        }    }};\ntemplate<size_t M_SZ, bool indexed, class T, class U=T, class V=T, class W=T>\nclass vec_merge {    vector<T> &a;    vector<U> &b;    vector<V> &c;    vector<W> &d;public :    vec_merge(vector<T> &a) : a(a), b(a), c(a), d(a) {}    vec_merge(vector<T> &a, vector<U> &b) : a(a), b(b), c(a), d(a) {}    vec_merge(vector<T> &a, vector<U> &b, vector<V> &c) : a(a), b(b), c(c), d(a) {}    vec_merge(vector<T> &a, vector<U> &b, vector<V> &c, vector<W> &d) : a(a), b(b), c(c), d(d) {}    auto begin() const {        if constexpr(M_SZ == 1) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a}; }        else if constexpr(M_SZ == 2) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a, b}; }        else if constexpr(M_SZ == 3) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a, b, c}; }        else if constexpr(M_SZ == 4) { return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a, b, c, d}; }        else {            assert(0);            return ite_vec_merge<M_SZ, indexed, decltype(std::begin(a)), T, U, V, W>{std::begin(a), a};        }    }    auto end() const {        if constexpr(M_SZ == 1) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a}; }        else if constexpr(M_SZ == 2) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a, b}; }        else if constexpr(M_SZ == 3) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a, b, c}; }        else if constexpr(M_SZ == 4) { return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a, b, c, d}; }        else {            assert(0);            return ite_vec_merge<M_SZ, indexed, decltype(std::end(a)), T, U, V, W>{std::end(a), a};        }    }};\n#endif\n#define fora_2(a, A) for(auto&& a : A)\n\n#if __cplusplus >= 201703L\n#define fora_3(i, a, A) for(auto[i, a] : vec_merge<1, true, decl_t<decltype(A)>>(A))\n#define fora_4(a, b, A, B) for(auto[a, b] : vec_merge<2, false, decl_t<decltype(A)>, decl_t<decltype(B)>>(A, B))\n#define fora_5(i, a, b, A, B)  for(auto[i, a, b] : vec_merge<2, true, decl_t<decltype(A)>, decl_t<decltype(B)>>(A, B))\n#define fora_6(a, b, c, A, B, C)  for(auto[a, b, c] : vec_merge<3, false, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>>(A, B, C))\n#define fora_7(i, a, b, c, A, B, C)  for(auto[i, a, b, c] : vec_merge<3, true, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>>(A, B, C))\n#define fora_8(a, b, c, d, A, B, C, D) for(auto[a, b, c, d] : vec_merge<4, false, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>, decl_t<decltype(D)>>(A, B, C, D))\n#define fora_9(i, a, b, c, d, A, B, C, D) for(auto[i, a, b, c, d] : vec_merge<4, true, decl_t<decltype(A)>, decl_t<decltype(B)>, decl_t<decltype(C)>, decl_t<decltype(D)>>(A, B, C, D))\n#endif\n//構造化束縛ver\n//1e5要素で40ms程度\n//遅いときはfora_fを使う\n#define fora(...) over9(__VA_ARGS__, fora_9, fora_8, fora_7, fora_6, fora_5, fora_4, fora_3, fora_2)(__VA_ARGS__)\n//#define forr(v, a) for(auto&& v : makeReversedRange(a))\n//参照を取らない\n/*@formatter:off*/\n#ifdef use_for\ntemplate<class U> vector<U> to1d(vector<U> &a) { return a; }\ntemplate<class U> auto to1d(vector<vector<U>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)res.push_back(a2);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<U>>> &a) {    vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) res.push_back(a3);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<vector<U>>>> &a) {vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)res.push_back(a4);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<vector<vector<U>>>>> &a) {vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)res.push_back(a5);    return res;}\ntemplate<class U> vector<U> to1d(vector<vector<vector<vector<vector<vector<U>>>>>> &a) {vector<U> res;    for (auto &&a1 : a)for (auto &&a2 : a1)for (auto &&a3 : a2) for (auto &&a4 : a3)for (auto &&a5 : a4)for (auto &&a6 : a5)res.push_back(a6);    return res;}\n#define forv(a, b) for(auto a : to1d(b))\n//インデックスを前後含めて走査\n#define ring(i, s, len) for (int i = s, prev = (s == 0) ? len - 1 : s - 1, next = (s == len - 1) ? 0 : s + 1, cou = 0; cou < len; cou++, prev = i, i = next, next = (next == len - 1) ? 0 : next + 1)\n//値と前後を見る\n#define ringv(v, d) index_=0;for (auto prev = d[sz(d)-1],next= (int)d.size()>1?d[1]:d[0],v = d[0]; index_ < sz(d); index_++, prev = v, v = next, next = (index_>=sz(d)-1?d[0]:d[index_+1]))\n// 左右をnext prevで見る 0の左と nの右\n#define forlr(v, d, banpei_l, banpei_r) rep(forlr_i,sz(d))\n#endif\n\n#define form(...) over5(__VA_ARGS__,form5,form4,form3,form2,form1)(__VA_ARGS__)\n#define forrm(...) over5(__VA_ARGS__,forrm5,forrm4,forrm3,forrm2,forrm1)(__VA_ARGS__)\n#define fors(...) over4(__VA_ARGS__,fors4,fors3,fors2,fors1)(__VA_ARGS__)\n#define forslr(...) over6(__VA_ARGS__,forslr6,forslr5,forslr4,forslr3)(__VA_ARGS__)\n#define forp3(k, v, st)  rep(forp_i,sz(st))\n#define forp4(forp_i, k, v, st) rep(forp_i,sz(st))\n#define forp(...) over4(__VA_ARGS__,forp4,forp3)(__VA_ARGS__)\n\n//to_vec(rep(i, N))のように使い\n//iが走査した値を持つvectorを返す\n#define to_vec2(type, my_for) \\\n    [&](){                    \\\n        vector<type> ret;     \\\n        my_for{               \\\n            ret.push_back(i); \\\n        }                     \\\n        return ret;           \\\n    }()\n#define to_vec1(my_for) to_vec2(int, my_for)\n#define to_vec(...) over2(__VA_ARGS__,to_vec2,to_vec1)(__VA_ARGS__)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nconst double PI = 3.1415926535897932384626433832795029L;\n\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//stream まとめ\n/*@formatter:off*/\nistream &operator>>(istream &iss, P &a) {iss >> a.first >> a.second;return iss;}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec_) {for (T &x: vec_) iss >> x;return iss;}\ntemplate<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {os << p.fi << \" \" << p.se;return os;}\nostream &operator<<(ostream &os, T p) {os << p.f << \" \" << p.s << \" \" << p.t;return os;}\nostream &operator<<(ostream &os, F p) {os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;return os;}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &vec_) {for (ll i = 0; i < vec_.size(); ++i)os << vec_[i] << (i + 1 == vec_.size() ? \"\" : \" \");return os;}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec_) {for (ll i = 0; i < vec_.size(); ++i) {for (ll j = 0; j < vec_[i].size(); ++j) { os << vec_[i][j] << \" \"; }os << endl;}return os;}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {os << endl;for (auto &&v:m) os << v << endl;return os;}\ntemplate<class T> ostream &operator<<(ostream &os, set<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}\ntemplate<class T> ostream &operator<<(ostream &os, mset<T> s) {    fora(v, s) { os << v << \" \"; }    return os;}\ntemplate<class T> ostream &operator<<(ostream &os, deque<T> a) {    fora(v, a) { os << v << \" \"; }    return os;}\nostream &operator<<(ostream &os, vector<vector<char>> &vec_) {    rep(h, sz(vec_)) {        rep(w, sz(vec_[0])) { os << vec_[h][w]; }        os << endl;    }    return os;}\n\ntemplate<class T> struct range_now {\n    int l;\n    vector<T> A;\n    range_now(vector<T>&& A, int l) : A(A), l(l){}\n};\n/*@formatter:off*/\n//template<class T,class U>ostream &operator<<(ostream &os, vector<pair<T,U>>& a) {fora_f(v,a)os<<v<<endl;return os;}\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n//#define use_for_each  //_each _all_of _any_of _none_of _find_if _rfind_if _contains _count_if _erase_if _entry_if\n\n#ifdef use_for_each\n//todo Atcoderの過去問がc++17に対応したら\n#if __cplusplus >= 201703L\n//for_each以外はconst & (呼び出し側のラムダも)\ntemplate<typename T, typename F> bool all_of2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : v) { if (!all_of2(v_, f))return false; }        return true;    } else { return f(v); }}\ntemplate<typename T, typename F> bool any_of2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : v) { if (!any_of2(v_, f))return true; }        return false;    } else { return f(v); }}\ntemplate<typename T, typename F> bool none_of2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : v) { if (none_of2(v_, f))return false; }        return true;    } else { return f(v); }}\n\n//存在しない場合\n//1次元 Nを返す\n//多次元-1を返す\ntemplate<typename T, typename F> ll find_if2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (f(v[i]))return i; }    return sz(v);}\ntemplate<typename T, typename F> tuple<int, int> find_if2(const vector<vector<T> > &v, F f) {    rep(i, sz(v)) { rep(j, sz(v[i])) { if (f(v[i][j])) { return tuple<int, int>(i, j); }}}    return tuple<int, int>(-1, -1);}\ntemplate<typename T, typename F> auto find_if2(const vector<vector<vector<T> > > &v, F f) {    rep(i, sz(v)) { if (auto ret = find_if2(v[i], f); get<0>(ret) != -1) { return tuple_cat(tuple<int>(i), ret); }}    auto bad = tuple_cat(tuple<int>(-1), find_if2(v[0], f));    return bad;}\ntemplate<class T, class F> auto find_if2(const range_now<T> &v, F f) {return find_if2(v.A, f) + v.l;}\n//存在しない場合\n//1次元 -1を返す\n//多次元-1を返す\ntemplate<typename T, typename F> ll rfind_if2(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (f(v[i]))return i; }    return -1;}\ntemplate<typename T, typename F> tuple<int, int> rfind_if2(const vector<vector<T> > &v, F f) {    rer(i, sz(v) - 1) { rer(j, sz(v[i]) - 1) { if (f(v[i][j])) { return tuple<int, int>(i, j); }}}    return tuple<int, int>(-1, -1);}\ntemplate<typename T, typename F> auto rfind_if2(const vector<vector<vector<T> > > &v, F f) {    rer(i, sz(v) - 1) { if (auto ret = rfind_if2(v[i], f); get<0>(ret) != -1) { return tuple_cat(tuple<int>(i), ret); }}    auto bad = tuple_cat(tuple<int>(-1), rfind_if2(v[0], f));    return bad;}\n\n//todo まとめられそう string,vector全般\ntemplate<class T> bool contains(const string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(const vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(const vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(const T &v, F f) {    if constexpr(has_value_type<T>::value) {        ll ret = 0;        for (auto &&v_ : v) { ret += count_if2(v_, f); }        return ret;    } else { return f(v); }}\ntemplate<typename T, typename F> void for_each2(T &a, F f) {    if constexpr(has_value_type<T>::value) {        for (auto &&v_ : a)for_each2(v_, f);    } else {        f(a);    }}\n#else\ntemplate<typename T, typename F> bool all_of2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(const vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(const vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(const string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(const vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(const vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(const T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(const vector<T> &vec_, F f) {    ll ret = 0;    fora(v, vec_) { ret += count_if2(v, f); }    return ret;}\n\ntemplate<typename T, typename F> void for_each2(T &a, F f) {\n    f(a);\n}\ntemplate<typename T, typename F> void for_each2(vector<T>  &a, F f) {\n    for (auto &&v_ : a)for_each2(v_, f);\n}\n#endif\ntemplate<typename W> ll count_od(const vector<W> &a) { return count_if2(a, [](ll v) { return v & 1; }); }\ntemplate<typename W> ll count_ev(const vector<W> &a) { return count_if2(a, [](ll v) { return !(v & 1); }); }\n//削除した後のvectorを返す\ntemplate<typename T, typename F> vector<T> erase_if2(const vector<T> &v, F f) {    vector<T> nv;    rep(i, sz(v)) { if (!f(v[i])) { nv.push_back(v[i]); }}    return nv;}\ntemplate<typename T, typename F> vector<vector<T>> erase_if2(const vector<vector<T>> &v, F f) {    vector<vector<T>> res;    rep(i, sz(v)) { res[i] = erase_if2(v[i], f); }    return res;}\n\ntemplate<typename T, typename F> vector<T> entry_if2(const vector<T> &v, F f) {vector<T> nv;rep(i, sz(v)) { if (f(v[i])) { nv.push_back(v[i]); }}return nv;}\ntemplate<typename T, typename F> vector<vector<T>> entry_if2(const vector<vector<T>> &v, F f) {vector<vector<T>> res;rep(i, sz(v)) { res[i] = entry_if2(v[i], f); }return res;}\n\ntemplate<typename T, typename F> ll l_rfind_if(const vector<T> &v, F f) {rer(i, sz(v) - 1) { if (f(v[i]))return i; }return -1;}\ntemplate<typename T, typename F> bool l_contains_if(const vector<T> &v, F f) {rer(i, sz(v) - 1) { if (f(v[i]))return true; }return false;}\ntemplate<class A, class B, class C> auto t_all_of(A a, B b, C c) { return std::all_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_any_of(A a, B b, C c) { return std::any_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_none_of(A a, B b, C c) { return std::none_of(a, b, c); }\ntemplate<class A, class B, class C> auto t_find_if(A a, B b, C c) { return std::find_if(a, b, c); }\ntemplate<class A, class B, class C> auto t_count_if(A a, B b, C c) { return std::count_if(a, b, c); }\n\n#define all_of_s__2(a, right) (t_all_of(ALL(a),lamr(right)))\n#define all_of_s__3(a, v, siki) (t_all_of(ALL(a),[&](auto v){return siki;}))\n#define all_of_s(...) over3(__VA_ARGS__,all_of_s__3,all_of_s__2)(__VA_ARGS__)\n\n//all_of(A, %2);\n//all_of(A, a, a%2);\n#define all_of__2(a, right) all_of2(a,lamr(right))\n#define all_of__3(a, v, siki) all_of2(a,[&](auto v){return siki;})\n#define all_of(...) over3(__VA_ARGS__,all_of__3,all_of__2)(__VA_ARGS__)\n#define all_of_f(a, f) all_of2(a,f)\n\n#define any_of_s__2(a, right) (t_any_of(ALL(a),lamr(right)))\n#define any_of_s__3(a, v, siki) (t_any_of(ALL(a),[&](auto v){return siki;}))\n#define any_of_s(...) over3(__VA_ARGS__,any_of_s__3,any_of_s__2)(__VA_ARGS__)\n\n#define any_of__2(a, right) any_of2(a,lamr(right))\n#define any_of__3(a, v, siki) any_of2(a,[&](auto v){return siki;})\n#define any_of(...) over3(__VA_ARGS__,any_of__3,any_of__2)(__VA_ARGS__)\n#define any_of_f(a, f) any_of2(a,f)\n\n#define none_of_s__2(a, right) (t_none_of(ALL(a),lamr(right)))\n#define none_of_s__3(a, v, siki) (t_none_of(ALL(a),[&](auto v){return siki;}))\n#define none_of_s(...) over3(__VA_ARGS__,none_of_s__3,none_of_s__2)(__VA_ARGS__)\n\n#define none_of__2(a, right) none_of2(a,lamr(right))\n#define none_of__3(a, v, siki) none_of2(a,[&](auto v){return siki;})\n#define none_of(...) over3(__VA_ARGS__,none_of__3,none_of__2)(__VA_ARGS__)\n#define none_of_f(a, f) none_of2(a,f)\n\n#define find_if_s__2(a, right) (t_find_if(ALL(a),lamr(right))-a.begin())\n#define find_if_s__3(a, v, siki) (t_find_if(ALL(a),[&](auto v){return siki;})-a.begin())\n#define find_if_s(...) over3(__VA_ARGS__,find_if_s__3,find_if_s__2)(__VA_ARGS__)\n\n#define find_if__2(a, right) find_if2(a,lamr(right))\n#define find_if__3(a, v, siki) find_if2(a,[&](auto v){return siki;})\n#define find_if__4(a, l, v, siki) (find_if2(decltype(a)(a.begin()+l , a.end()),[&](auto v){return siki;}) + l)\n#define find_if(...) over4(__VA_ARGS__,find_if__4, find_if__3,find_if__2)(__VA_ARGS__)\n#define find_if_f(a, f) find_if2(a,f)\n\n#define rfind_if_s__2(a, right) l_rfind_if(a, lamr(right))\n#define rfind_if_s__3(a, v, siki) l_rfind_if(a, [&](auto v){return siki;})\n#define rfind_if_s(...) over3(__VA_ARGS__,rfind_if_s__3,rfind_if_s__2)(__VA_ARGS__)\n\n#define rfind_if__2(a, right) rfind_if2(a,lamr(right))\n#define rfind_if__3(a, v, siki) rfind_if2(a,[&](auto v){return siki;})\n#define rfind_if(...) over3(__VA_ARGS__,rfind_if__3,rfind_if__2)(__VA_ARGS__)\n#define rfind_if_f(a, f) rfind_if2(a,f)\n\n#define contains_if_s__2(a, right) l_contains_if(a, lamr(right))\n#define contains_if_s__3(a, v, siki) l_contains_if(a, [&](auto v){return siki;})\n#define contains_if_s(...) over3(__VA_ARGS__,contains_if_s__3,contains_if_s__2)(__VA_ARGS__)\n\n#define contains_if__2(a, right) contains_if2(a,lamr(right))\n#define contains_if__3(a, v, siki) contains_if2(a,[&](auto v){return siki;})\n#define contains_if(...) over3(__VA_ARGS__,contains_if__3,contains_if__2)(__VA_ARGS__)\n#define contains_if_f(a, f) contains_if2(a,f)\n\n#define count_if_s__2(a, right) (t_count_if(ALL(a),lamr(right)))\n#define count_if_s__3(a, v, siki) (t_count_if(ALL(a),[&](auto v){return siki;}))\n#define count_if_s(...) over3(__VA_ARGS__,count_if_s__3,count_if_s__2)(__VA_ARGS__)\n\n#define count_if__2(a, right) count_if2(a,lamr(right))\n#define count_if__3(a, v, siki) count_if2(a,[&](auto v){return siki;})\n#define count_if(...) over3(__VA_ARGS__,count_if__3,count_if__2)(__VA_ARGS__)\n#define count_if_f(a, f) count_if2(a,f)\n\n//vector<vi>で、viに対して操作\n#define for_each_s__2(a, right) do{fora(v,a){v right;}}while(0)\n#define for_each_s__3(a, v, shori) do{fora(v,a){shori;}}while(0)\n#define for_each_s(...) over3(__VA_ARGS__,for_each_s__3,for_each_s__2)(__VA_ARGS__)\n\n//vector<vi>で、intに対して操作\n#define for_each__2(a, right) for_each2(a,lamr(right))\n#define for_each__3(a, v, shori) for_each2(a,[&](auto& v){shori;})\n#define for_each(...) over3(__VA_ARGS__,for_each__3,for_each__2)(__VA_ARGS__)\n#define for_each_f(a, f) for_each2(a, f);\n\ntemplate<class T, class F> vector<T> help_for_eached(const vector<T> &A, F f) {    vector<T> ret = A;    for_each(ret, v, f(v));    return ret;}\n#define for_eached__2(a, right) help_for_eached(a, lamr(right))\n#define for_eached__3(a, v, shori) help_for_eached(a, lam(v, shori))\n#define for_eached(...) over3(__VA_ARGS__,for_eached__3,for_eached__2)(__VA_ARGS__)\n#define for_eached_f(a, f) for_eached2(a, f);\n\n#define each for_each\n#define eached for_eached\n\n\n//#define erase_if_s__2(a, right) l_erase_if2(a,lamr(right))\n//#define erase_if_s__3(a, v, siki) l_erase_if2(a,[&](auto v){return siki;})\n//#define erase_if_s(...) over3(__VA_ARGS__,erase_if_s__3,erase_if_s__2)(__VA_ARGS__)\n\n\n#define erase_if__2(a, right) erase_if2(a,lamr(right))\n#define erase_if__3(a, v, siki) erase_if2(a,[&](auto v){return siki;})\n#define erase_if(...) over3(__VA_ARGS__,erase_if__3,erase_if__2)(__VA_ARGS__)\n#define erase_if_f(a, f) erase_if2(a,f)\n\n//#define entry_if_s__2(a, right) l_entry_if2(a,lamr(right))\n//#define entry_if_s__3(a, v, siki) l_entry_if2(a,[&](auto v){return siki;})\n//#define entry_if_s(...) over3(__VA_ARGS__,entry_if_s__3,entry_if_s__2)(__VA_ARGS__)\n\n\n#define entry_if__2(a, right) entry_if2(a,lamr(right))\n#define entry_if__3(a, v, siki) entry_if2(a,[&](auto v){return siki;})\n#define entry_if(...) over3(__VA_ARGS__,entry_if__3,entry_if__2)(__VA_ARGS__)\n#define entry_if_f(a, f) entry_if2(a,f)\n\n#endif\n\n/*@formatter:off*/\ntemplate<class T, class U, class W> void replace(vector<W> &a, T key, U v) { rep(i, sz(a))if (a[i] == key)a[i] = v; }\ntemplate<class T, class U, class W> void replace(vector<vector<W>> &A, T key, U v) { rep(i, sz(A))replace(A[i], key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(ALL(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(ALL(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\nvoid replace(str &a) {    int dec = 0;    if ('a' <= a[0] && a[0] <= 'z')dec = 'a';    if ('A' <= a[0] && a[0] <= 'Z')dec = 'A';    fora(v, a) { v -= dec; }}\nvoid replace(str &a, str key, str v) {    stringstream t;    ll kn = sz(key);    std::string::size_type Pos(a.find(key));    ll l = 0;    while (Pos != std::string::npos) {        t << a.substr(l, Pos - l);        t << v;        l = Pos + kn;        Pos = a.find(key, Pos + kn);    }    t << a.substr(l, sz(a) - l);    a = t.str();}\n\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(ALL(a), ALL(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(ALL(a)); }\nvi iota(ll s, ll len) {vi ve(len);iota(ALL(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);    return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\n\n/*@formatter:off*/\ntemplate<class T> void sort(vector<T> &a, int l = -1, int r = -1) {    set_lr12(l, r, sz(a));    fast_sort(a.begin() + l, a.begin() + r);}\ntemplate<class T> void rsort(vector<T> &a, int l = -1, int r = -1) {    set_lr12(l, r, sz(a));    fast_sort(a.begin() + l, a.begin() + r, greater<T>());};\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class... T, class U> auto sorted(U head, T... a) {    sort(head, a...);    return head;}\ntemplate<class... T, class U> auto rsorted(U head, T... a) {rsort(head, a...);return head;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}\n//#define use_sort\n#ifdef use_sort\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti,    fisitd,    fisdti,    fisdtd,    fdsiti,    fdsitd,    fdsdti,    fdsdtd,    fitisi,    fitisd,    fitdsi,    fitdsd,    fdtisi,    fdtisd,    fdtdsi,    fdtdsd,    sifiti,    sifitd,    sifdti,    sifdtd,    sdfiti,    sdfitd,    sdfdti,    sdfdtd,    sitifi,    sitifd,    sitdfi,    sitdfd,    sdtifi,    sdtifd,    sdtdfi,    sdfdfd,    tifisi,    tifisd,    tifdsi,    tifdsd,    tdfisi,    tdfisd,    tdfdsi,    tdfdsd,    tisifi,    tisifd,    tisdfi,    tisdfd,    tdsifi,    tdsifd,    tdsdfi,    tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {typedef pair<A, B> U;if (type == fisi) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; }); else if (type == fisd) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; }); else if (type == fdsi) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; }); else if (type == fdsd) sort(ALL(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; }); else if (type == sifi) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; }); else if (type == sifd) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; }); else if (type == sdfi) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; }); else if (type == sdfd) sort(ALL(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};\ntemplate<class U> void sort(vector<U> &a, pcomparator type) { if (type == fisi) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; }); else if (type == fisd) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; }); else if (type == fdsi) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; }); else if (type == fdsd) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; }); else if (type == sifi) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == sifd) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == sdfi) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == sdfd) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; }); };\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {typedef F2<A, B, C, D> U;if (type == fisi) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; }); else if (type == fisd) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; }); else if (type == fdsi) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; }); else if (type == fdsd) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; }); else if (type == sifi) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == sifd) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == sdfi) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == sdfd) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};\ntemplate<class U> void sort(vector<U> &a, tcomparator type) {if (type == 0) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(ALL(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(ALL(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 41) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 42) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 43) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; }); else if (type == 44) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; }); else if (type == 45) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; }); else if (type == 46) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; }); else if (type == 47) sort(ALL(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}\ntemplate<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(ALL(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(ALL(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 41) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 42) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 43) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; }); else if (type == 44) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; }); else if (type == 45) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; }); else if (type == 46) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; }); else if (type == 47) sort(ALL(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\n/*@formatter:off*/\nvoid sort(string &a) { sort(ALL(a)); }\nvoid rsort(string &a) { sort(RALL(a)); }\nvoid sort(int &a, int &b) { if (a > b)swap(a, b); }\nvoid sort(int &a, int &b, int &c) {    sort(a, b);    sort(a, c);    sort(b, c);}\nvoid rsort(int &a, int &b) { if (a < b)swap(a, b); }\nvoid rsort(int &a, int &b, int &c) {    rsort(a, b);    rsort(a, c);    rsort(b, c);}\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(ALL(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(ALL(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}\ntemplate<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n/*indexの分で型が変わるためpcomparatorが必要*/\ntemplate<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}\ntemplate<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}\ntemplate<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}\ntemplate<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}\ntemplate<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}\ntemplate<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };\ntemplate<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}\ntemplate<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };\ntemplate<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}\ntemplate<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] < c[y]; else return b[x] < b[y]; } else { return a[x] < a[y]; }});    return ind;}\ntemplate<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}\ntemplate<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(ALL(ind), [&](ll x, ll y) { if (a[x] == a[y]) { if (b[x] == b[y])return c[x] > c[y]; else return b[x] > b[y]; } else { return a[x] > a[y]; }});    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\n#endif\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {    vi c = a;    vi d = b;    sort(c);    sort(d);    return includes(ALL(c), ALL(d));}\ntemplate<class T> bool distinct(const vector<T> &A) {    if ((int) (A).size() == 1)return true;    if ((int) (A).size() == 2)return A[0] != A[1];    if ((int) (A).size() == 3)return (A[0] != A[1] && A[1] != A[2] && A[0] != A[2]);    auto B = A;    sort(B);    int N = (B.size());    unique(B);    return N == (int) (B.size());}\ntemplate<class H, class... T> bool distinct(const H &a, const T &...b) { return distinct(vector<H>{a, b...}); }\n\n/*@formatter:off*/\ntemplate<class T, class U> void inc(pair<T, U> &a, U v = 1) { a.first += v, a.second += v; }\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U = int> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U = int> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, W v = 1) {for (auto &u :a)dec(u, v);for (auto &u :b)dec(u, v);}\ntemplate<class T, class U, class W> void dec(vector<T> &a, vector<U> &b, vector<W> &c) {    for (auto &u :a)dec(u, 1);    for (auto &u :b)dec(u, 1);    for (auto &u :c)dec(u, 1);}\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool san(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return san(0, i, sz(a)) && san(0, j, sz(a)); }\n#define inside ins\nll u0(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u0(vector<T> &a) {    vector<T> ret = a;    fora(v, ret) { v = u(v); }    return ret;}\n//todo 名前\nbool d_(int a, int b) {if (b == 0)return false;return (a % b) == 0;}\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    cerr << \"ole\" << endl;exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;exit(0);\n}\nvoid re(string s = \"\") {cerr << s << endl;assert(0 == 1);exit(0);}\n\nvoid tle() { while (inf)cout << inf << endl; }\n\n\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\ntemplate<class T> T in() {    T ret;    cin >> ret;    return ret;}\nstring sin() {    string ret;    cin >> ret;    return ret;}\ntemplate<class T> void in(T &head) { cin >> head; }\ntemplate<class T, class... U> void in(T &head, U &... tail) {    cin >> head;    in(tail...);}\n\n\n//value_typeを持つ場合呼べる\n//len回要素を追加する\ntemplate<class Iterable, class T = typename Iterable::value_type> Iterable tin(int len) {    Iterable ret;    T tem;    while (len--) {        cin >> tem;        ret += tem;    }    return ret;}\ntemplate<class T> T tin() {    T ret;    cin >> ret;    return ret;}\ntemplate<class T> T tind(int len = 0) {    auto ret = tin<T>(len);    dec(ret, 1);    return ret;}\n#define din_t2(type, a) type a;cin>>a\n#define din_t3(type, a, b) type a,b;cin>>a>> b\n#define din_t4(type, a, b, c) type a,b,c;cin>>a>>b>>c\n#define din_t5(type, a, b, c, d) type a,b,c,d;cin>>a>>b>>c>>d\n#define din_t6(type, a, b, c, d, e) type a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din_t7(type, a, b, c, d, e, f) type a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din_t(...) over7(__VA_ARGS__,din_t7,din_t6,din_t5,din_t4,din_t3 ,din_t2)(__VA_ARGS__)\n\n#define din(...) din_t(int,__VA_ARGS__)\n#define d_in\n#define dsig(...) din_t(signed,__VA_ARGS__)\n\n#define dst(...) din_t(string,__VA_ARGS__)\n#define dstr dst\n#define d_str dst\n\n#define dcha(...) din_t(char,__VA_ARGS__)\n#define dchar dcha\n\n#define ddou(...) din_t(double,__VA_ARGS__)\n\n\n#define din1d(a) din_t2(int, a);a--\n#define din2d(a, b) din_t3(int, a,b);a--,b--\n#define din3d(a, b, c) din_t4(int, a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din_t5(int, a,b,c,d);a--,b--,c--,d--\n#define dind(...) over4(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n/*@formatter:off*/\n#ifdef _DEBUG\ntemplate<class T> void err2(T &&head) { cerr << head; }\ntemplate<class T, class... U> void err2(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);}\ntemplate<class T, class... U> void err(T &&head, U &&... tail) {    cerr << head << \" \";    err2(tail...);    cerr << \"\" << endl;}\ntemplate<class T> void err(T &&head) { cerr << head << endl; }\nvoid err() { cerr << \"\" << endl; }\n//debで出力する最大長\nconstexpr int DEB_LEN = 20;\nconstexpr int DEB_LEN_H = 12;\nstring deb_tos(const int &v) { if (abs(v) == inf || abs(v) == linf)return \"e\"; else return to_string(v); }\ntemplate<class T> string deb_tos(const T &a) {stringstream ss;ss << a;return ss.str();}\n#ifdef use_epsdou\nstring deb_tos(const epsdou &a) {return deb_tos(a.v);}\n#endif\ntemplate<class T> string deb_tos(const optional<T> &a) { if (a.has_value()) { return deb_tos(a.value()); } else return \"e\"; }\ntemplate<class T> string deb_tos(const vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), DEB_LEN);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << deb_tos(a[i]);        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            lens[wi] = max(lens[wi], sz(deb_tos(a[h][W[wi]])) + 1);            lens[wi] = max(lens[wi], sz(deb_tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(lens[i])ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            ss << std::right << std::setw(lens[wi]) << deb_tos(a[h][w]);            wi++;        }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), DEB_LEN_H});    W = min({W, sz(a[0]), DEB_LEN_H});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    return deb_tos(a, hs, ws, key);}\ntemplate<class T> string deb_tos(const vector<vector<vector<T> > > &a, ll H = inf) {    stringstream ss;    if (H == inf)H = DEB_LEN_H;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << deb_tos(a[i], inf, inf, i);    }    return ss.str();}\ntemplate<class T> string deb_tos(vector<set<T> > &a, ll H = inf, ll W = inf, int key = -1) {    vector<vector<T> > b(sz(a));    rep(i, sz(a)) { fora(v, a[i]) { b[i].push_back(v); }}    return deb_tos(b, H, W, key);}\ntemplate<class T, size_t A> string deb_tos(T (&a)[A]) { return deb_tos(vector<T>(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B> string deb_tos(T (&a)[A][B]) { return deb_tos(vector<vector<T> >(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B, size_t C> string deb_tos(T (&a)[A][B][C]) { return deb_tos(vector<vector<vector<T> > >(begin(a), end(a))); }\n/*@formatter:off*/\ntemplate<class T> void out2(T head) {    cout << head;    res_mes += deb_tos(head);}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";    res_mes += deb_tos(head) + \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";    res_mes += deb_tos(head) + \" \";    out2(tail...);    cout << \"\" << endl;    res_mes += \"\\n\";}\ntemplate<class T> void out(T head) {    cout << head << endl;    res_mes += deb_tos(head) + \"\\n\";}\nvoid out() { cout << \"\" << endl; }\n\n#else\n#define err(...);\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\nvoid out() {    cout << \"\"  << endl;}\n\n#endif\n\n\ntemplate<class T> void outl(const vector<T> &a, int n = inf) { rep(i, min(n, sz(a)))cout << a[i] << endl; }\n//テーブルをスペースなしで出力\ntemplate<class T> void outt(vector<vector<T>> &a) {    rep(i, sz(a)) {        rep(j, sz(a[i])) { cout << a[i][j]; }        cout << endl;    }}\n//int型をbit表記で出力\nvoid outb(int a) { cout << bitset<20>(a) << endl; }\n\n/*@formatter:off*/\ntemplate<class T> void na(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i];}\ntemplate<class T> void na(set<T> &a, ll n) { rep(i, n)a.insert(in()); }\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\ntemplate<class T> void nao(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1], a[i + 1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T> void nad(set<T> &a, ll n) { rep(i, n)a.insert(in() - 1); }\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\ntemplate<class T, class U> void na2(set<T> &a, set<U> &b, ll n) {    rep(i, n) {        a.insert(in());        b.insert(in());    }}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\n#define dna2d(a, b, n) vi a,b; na2d(a,b,n);\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a,b,c; na3(a,b,c,n);\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a,b,c; na3d(a,b,c,n);\ntemplate<class T, class U, class W, class X> void na4(vector<T> &a, vector<U> &b, vector<W> &c, vector<X> &d, ll n) {a.resize(n);    b.resize(n);    c.resize(n);    d.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];}\n#define dna4(a, b, c, d, n)  vi a,b,c,d; na4(a,b,c,d,n);\n#define dna4d(a, b, c, d, n)  vi a,b,c,d; na4d(a,b,c,d,n);\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\n/*@formatter:off*/\n#define deb1(x)  debugName(x)<<\" = \"<<deb_tos(x)\n#define deb_2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb_3(x, ...) deb1(x) <<\", \"<< deb_2(__VA_ARGS__)\n#define deb_4(x, ...) deb1(x) <<\", \"<< deb_3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb_4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n//#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n//#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n//#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n//#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n/*@formatter:off*/\n#ifdef _DEBUG\nbool was_deb = false;\n#define deb(...)  do{was_deb=true;cerr<< over10(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb_4,deb_3,deb_2,deb1)(__VA_ARGS__) <<endl;}while(0)\n\n#define base_keta 8\nvoid print_n_base(int x, int base) { cerr << bitset<base_keta>(x) << endl; }\ntemplate<class T> void print_n_base(vector<T> X, int base) {cerr << endl;    for (auto &&x:X) { print_n_base(x, base); }    cerr << endl;}\n\n//n進数\n#define deb2(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 2);\n#define deb3(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 3);\n#define deb4(x) was_deb=true;cerr<<debugName(x)<<\" = \";print_n_base(x, 4);\n\n#define deb_ex_deb(x, len)  debugName(x)<<\" = \"<<deb_tos(x, len)\n#define call_deb_ex_deb(x, len) deb_ex_deb(x, len)\n//要素が存在する行だけ出力(vvt)\n#define deb_ex(v) do {int N = sz(v);int s = N;int t = 0;rep(i, N) {if (sz(v[i])) {chmi(s, i);chma(t, i);}}auto ex_v = sub(v, s, N);str S = deb_tos(ex_v, sz(ex_v));debugName(v);cerr<<\" = \"<<endl;cerr << S << endl;} while (0);\n#define debi(A) {int len=min(sz(A),20); was_deb=true;cerr<<debugName(A)<<\" = \"<<endl;rep(i, len)cerr<<std::right << std::setw((int)(sz(tos(A[i]))+(i ? 1 : 0)))<<(i%10);cerr<<endl;rep(i, len)cerr<<std::right << std::setw((int)(sz(tos(A[i]))+(i ? 1 : 0)))<<A[i];cerr<<endl;}\n\ntemplate<class T, class F> string deb_tos_f(vector<vector<T> > &a, F f, int key = -1) {vi hs, ws_;    int H = sz(a), W = sz(a[0]);    vi exh(H), exw(W);    rep(h, H) {        rep(w, W) {            if (f(a[h][w])) {                exh[h] = true;                exw[w] = true;            }        }    }    rep(h, H) if (exh[h])hs.push_back(h);    rep(w, W) if (exw[w])ws_.push_back(w);    return deb_tos(a, hs, ws_, key);}\ntemplate<class T, class F> string deb_tos_f(vector<vector<vector<T>>> &a, F f) {stringstream ss;    int H = sz(a);    if (sz(a) == 0)return ss.str();    rep(i, H) { ss << deb_tos_f(a[i], f, i); }    ss << \"\" << endl;    return ss.str();}\n#define debf_normal(tab, f) do{cerr<<debugName(tab)<<\" = \"<<endl;cerr<< deb_tos_f(tab, f)<<endl;}while(0);\n#define debf2(tab, siki_r) debf_normal(tab, lamr(siki_r))\n#define debf3(tab, v, siki)  debf_normal(tab, lam(siki))\n//S, sikir\n//S, v, siki\n#define debf(...) over3(__VA_ARGS__,debf3,debf2,debf1)(__VA_ARGS__)\n\n#else\n#define deb(...) ;\n#define deb2(...) ;\n#define deb3(...) ;\n#define deb4(...) ;\n#define deb_ex(...) ;\n#define debf(...) ;\n#define debi(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n/*@formatter:off*/\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {std::ostream::sentry s(dest);if (s) {__uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }return dest;}\n__int128 to_bint(string &s) {__int128 ret = 0;    for (ll i = 0; i < (ll) s.length(); ++i) if ('0' <= s[i] && s[i] <= '9') ret = 10 * ret + s[i] - '0';    return ret;}\nvoid operator>>(istream &iss, bint &v) {string S;    iss >> S;    v = 0;    rep(i, sz(S)) {        v *= 10;        v += S[i] - '0';    }}\n\n//便利関数\n/*@formatter:off*/\n//テスト用\n#define rand xor128_\nunsigned long xor128_(void) {static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;    unsigned long t;    t = (x ^ (x << 11));    x = y;    y = z;    z = w;    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));}\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nll rand(ll max) { return rand(0, max); }\ntemplate<class T> T rand(vector<T> &A) { return A[rand(sz(A) - 1)]; }\n//重複することがある\ntemplate<class T> vector<T> ranv(vector<T> &A, int N) {vector<T> ret(N);    rep(i, N) { ret[i] = rand(A); }    return ret;}\ntemplate<class T> vector<T> ranv_unique(vector<T> &A, int N) {vector<T> ret(N);    umapi was;    rep(j, N) {        int i;        while (1) {            i = rand(sz(A) - 1);            if (was.find(i) == was.end())break;        }        ret[j] = A[i];        was[i] = 1;    }    return ret;}\nvi ranv(ll n, ll min, ll max) {vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\n\n/*@formatter:off*/\n#ifdef _DEBUG\nbool timeup(int time) {static bool never = true;    if (never)message += \"may timeup, because slow\";    never = false;    auto end_time = system_clock::now();    auto part = duration_cast<milliseconds>(end_time - start_time);    auto lim = milliseconds(time);    return part >= lim;}\n#else\nbool timeup(int time) {\n    auto end_time = system_clock::now();\n    auto part = duration_cast<milliseconds>(end_time - start_time);\n    auto lim = milliseconds(time);\n    return part >= lim;\n}\n\n#endif\nvoid set_time() { past_time = system_clock::now(); }\n//MS型(millisecqnds)で返る\n//set_timeをしてからの時間\nauto calc_time_milli() {auto now = system_clock::now();    auto part = duration_cast<milliseconds>(now - past_time);    return part;}\nauto calc_time_micro() {auto now = system_clock::now();    auto part = duration_cast<microseconds>(now - past_time);    return part;}\nauto calc_time_nano() {auto now = system_clock::now();    auto part = duration_cast<nanoseconds>(now - past_time);    return part;}\nbool calc_time(int zikan) { return calc_time_micro() >= microseconds(zikan); }\nusing MS=std::chrono::microseconds;\nint div(microseconds a, microseconds b) { return a / b; }\nint div(nanoseconds a, nanoseconds b) {if (b < nanoseconds(1)) { return a / nanoseconds(1); }    int v = a / b;    return v;}\n//set_time();\n//rep(i,lim)shori\n\n//lim*=time_nanbai();\n//rep(i,lim)shoriと使う\n//全体でmilliかかっていいときにlimを何倍してもう一回できるかを返す\nint time_nanbai(int milli) {auto dec = duration_cast<nanoseconds>(past_time - start_time);    auto part = calc_time_nano();    auto can_time = nanoseconds(milli * 1000 * 1000);    can_time -= part;    can_time -= dec;    return div(can_time, part);}\n\n/*@formatter:off*/\n//#define use_rand\n#ifdef use_rand\nstr ransu(ll n) {str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\n#endif\n\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\ntemplate<class Iterable, class T = typename Iterable::value_type> vector<pair<T, int>> run_length(const Iterable &a) {vector<pair<T, int>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\n\n/*@formatter:off*/\n//#define use_mgr //_goldd _goldt\n#ifdef use_mgr\n//->[i, f(i)]\ntemplate<class T, class U, class F> auto mgr(T ok, U ng, const F &f, require_arg(is_integral<T>::value &&is_integral<U>::value)) {    auto mid = (ok + ng);    if (ok < ng)        while (ng - ok > 1) {            mid = (ok + ng) >> 1;            if (f(mid))ok = mid; else ng = mid;        }    else        while (ok - ng > 1) {            mid = (ok + ng) >> 1;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\n//[l, r)の中で,f(i)がtrueとなる範囲を返す okはそこに含まれる\ntemplate<class F> P mgr_range(int l, int r, F f, int ok) {if (f(ok) == 0) {        out(\"f(ok) must true\");        re();    }    return mp(mgr(ok, l - 1, f), mgr(ok, r, f) + 1);}\ntemplate<class F> auto mgrd(dou ok, dou ng, F f, int kai = 100) {if (ok < ng)        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    else        rep(i, kai) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\ntemplate<class F> dou mgrd_time(dou ok, dou ng, F f, int time = 1980) {bool han = true;    if (ok < ng)        while (1) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);            if (timeup(time)) { break; }        }    else        while (1) {            dou mid = (ok + ng) / 2;            if (f(mid))ok = mid, han = true; else ng = mid, han = false;            deb(mid, han);            if (timeup(time)) { break; }        }    return ok;}\n//todo 減らす\ntemplate<class F> auto goldd_l(ll left, ll right, F calc) {double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return make_tuple(resIndex, calc(resIndex));}\ntemplate<class F> auto goldt_l(ll left, ll right, F calc) {double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN<ll>();    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return make_tuple(resIndex, calc(resIndex));}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> auto goldd_d(dou left, dou right, F calc, ll loop = 200) {dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return make_tuple(left, calc(left));}\ntemplate<class F> auto goldt_d(dou left, dou right, F calc, ll loop = 200) {double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        }        else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return make_tuple(left, calc(left));}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> auto goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(mini, calc(mini));}\ntemplate<class F> auto goldt_ls(ll l, ll r, F calc, ll time = 2000) {auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN<ll>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(maxi, calc(maxi));}\ntemplate<class F> auto goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(mini, calc(mini));}\ntemplate<class F> auto goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN<dou>();    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return make_tuple(maxi, calc(maxi));}\n#endif\n\n//strを整数として比較\nstring smax(str &a, str b) { if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else if (a < b)return b; else return a; }\n//strを整数として比較\nstring smin(str &a, str b) { if (sz(a) > sz(b)) { return b; } else if (sz(a) < sz(b)) { return a; } else if (a > b)return b; else return a; }\n//エラー-1\ntemplate<typename W, typename T> ll find(vector<W> &a, int l, const T key) {rep(i, l, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {rep(i, sz(a))if (a[i] == key)return i;return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);return mp(-1, -1);}\n//getid(find())を返す 1次元にする\ntemplate<typename W, typename T> int findi(vector<vector<W >> &a, const T key) {rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return i * sz(a[0]) + j;return -1;}\ntemplate<typename W, typename U> tuple<int, int, int> find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return tuple<int, int, int>(i, j, k);    return tuple<int, int, int>(-1, -1, -1);}\n//無ければ-1\nint find(string &s, const string key) {    int klen = sz(key);    rep(i, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }return -1;}\nint find(string &s, int l, const string key) {    int klen = sz(key);    rep(i, l, sz(s) - klen + 1) {        if (s[i] != key[0])continue;        if (s.substr(i, klen) == key) { return i; }    }    return -1;}\nint find(string &s, const char key) {    rep(i, sz(s)) { if (s[i] == key)return i; }    return -1;}\nint find(string &s, int l, const char key) {    rep(i, l, sz(s)) { if (s[i] == key)return i; }    return -1;}\n//N箇所について右のkeyの場所を返す\ntemplate<typename W, typename T> vi finds(const W &a, const T& key) {    int n = sz(a);    vi rpos(n, -1);    rer(i, n-1){        if(i<n-1){            rpos[i] = rpos[i+1];        }        if(a[i]==key)rpos[i] = i;    }    return rpos;}\ntemplate<typename W, typename T> vi rfinds(const W &a, const T& key) {    int n = sz(a);    vi lpos(n, -1);    rep(i, n){        if(i> 0){            lpos[i] = lpos[i-1];        }        if(a[i]==key)lpos[i] = i;    }    return lpos;}\n//todoz\n#if __cplusplus >= 201703L\ntemplate<typename W, typename T, class Iterable = typename W::value_type>\nll count(const W &a, const T &k) { return count_if(a, ==k); }\ntemplate<typename W, class Iterable = typename W::value_type> vi count(const W &a) {\n    vi res;\n    for_each(a, v, if (sz(res) <= (int) v)res.resize((int) v + 1);\n            res[v]++;);\n    return res;\n}\n#endif\nll count(const str &a, const str &k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\n/*@formatter:off*/\n//'a' = 'A' = 0 として集計 既に-'a'されていても動く\nvi count(str &a, int l, int r) {    vi cou(26);    char c = 'a';    if ('A' <= a[l] && a[l] <= 'Z')c = 'A';    if ('a' <= a[l] && a[l] <= 'z') c = 'a'; else c = 0;    rep(i, l, r)++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> auto rev(const vector<T> &a) {    auto b = a;    reverse(ALL(b));    return b;}\n/* ＼反転  */                                                                                        template<class U>\nauto rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    return b;}\n/* ｜反転  */                                                                                        template<class U>\nauto revw(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0])) { b[h][W - 1 - w] = a[h][w]; }    return b;}\n\n/* ー反転  */                                                                                        template<class U>\nauto revh(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a), vector<U>(sz(a[0])));    int H = sz(a);    rep(h, sz(a)) rep(w, sz(a[0])) { b[H - 1 - h][w] = a[h][w]; }    return b;}\n\n/* ／反転  */                                                                                        template<class U>\nauto revr(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    int H = sz(a);    int W = sz(a[0]);    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[H - 1 - h][W - 1 - w];    return b;}\n\nauto rev(const string &a) {    string b = a;    reverse(ALL(b));    return b;}\ntemplate<class T> auto rev(const T &v, int i) {return v[sz(v) - 1 - i];}\nint rev(int N, int i) {return N-1-i;}\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\n//0は0桁\nll keta(ll v, int if_zero_res) { if(!v)return if_zero_res;if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) { if (v < p10[0])return 0; else return 1; } else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else return 15; } else { if (v < p10[17]) { if (v < p10[16]) return 16; else return 17; } else { if (v < p10[18])return 18; else return 19; }}}}}\n#if __cplusplus >= 201703L\nll getr(ll a, ll keta) { return (a / pow<ll>(10, keta)) % 10; }\n#else\nll getr(ll a, ll keta) { return (a / (int)pow(10, keta)) % 10; }\n#endif\n//上から何桁目か\nll getl(ll a, ll ket) {int sketa = keta(a, 1);return getr(a, sketa - 1 - ket);}\nll dsum(ll v, ll sin = 10) {ll ret = 0;for (; v; v /= sin)ret += v % sin;return ret;}\n\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\n\ntemplate<class T, class U> auto to_v1(vector<reference_wrapper<U>>& ret, vector<T> &A) {    rep(i, sz(A))ret.push_back(A[i]);    return ret;}\ntemplate<class T, class U> auto to_v1(vector<reference_wrapper<U>>& ret, vector<vector<T> > &A) {rep(i, sz(A))to_v1(ret, A[i]);return ret;}\n//参照付きで1次元に起こす\ntemplate<class T> auto to_v1(vector<vector<T> > &A) {    vector<reference_wrapper<decl2_t<decltype(A)>>> ret;    rep(i, sz(A))to_v1(ret, A[i]);    return ret;}\n\n//[v] := iとなるようなvectorを返す\n//存在しない物は-1\n//空でも動く(なぜか)\ntemplate<class T> auto keys(const T &a) {vector<decltype((a.begin())->fi)> res;for (auto &&k :a)res.push_back(k.fi);return res;}\ntemplate<class T> auto values(const T &a) {vector<decltype((a.begin())->se)> res;for (auto &&k :a)res.push_back(k.se);return res;}\n//todo 可変長で\ntemplate<class T> constexpr T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> constexpr T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\n//1次元のコンテナ\ntemplate<class T> int mini(const vector<T> &a) { return min_element(ALL(a)) - a.begin(); }\ntemplate<class T> int maxi(const vector<T> &a) { return max_element(ALL(a)) - a.begin(); }\ntemplate<class T> T sum(const T &A) {return A;}\ntemplate<class T> T sum(const vector<T> &A, int l = -1, int r = -1) {T s = 0;set_lr12(l, r, sz(A));rep(i, l, r)s += sum(A[i]);return s;}\n//1次元のIterableに使える\ntemplate<class T, require_t(!has_value_type<T>::value)>T min(T &a) { return a; }\ntemplate<class V, require_t(has_value_type<V>::value)>auto min(V &a, ll s = -1, ll n = -1) {    using Ret_t = decl2_t<V>;    auto ret = MAX<Ret_t>();    set_lr12(s, n, sz(a));    if (s == n) {        return INF<Ret_t>();    } else {        rep(i, s, n) {            ret = min(ret, min(a[i]));        }        return ret;    }}\ntemplate<class T, require_t(!has_value_type<T>::value)> T max(T &a) { return a; }\ntemplate<class V, require_t(has_value_type<V>::value)> auto max(V &a, ll s = -1, ll n = -1) {    using Ret_t = decl2_t<V>;    auto ret = MIN<Ret_t>();    set_lr12(s, n, sz(a));    if (s == n) { return -INF<Ret_t>(); }    else {        rep(i, s, n) { ret = max(ret, max(a[i])); }        return ret;    }}\ntemplate<class T> T mul(vector<T> &v, ll t = inf) {T ret = v[0];rep(i, 1, min(t, sz(v)))ret *= v[i];return ret;}\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\n//indexを持つvectorを返す\n\n/*@formatter:off*/\ntemplate<typename W, typename T> void fill(W &xx, const T vall) { xx = vall; }\ntemplate<typename W, typename T> void fill(vector<W> &vecc, const T vall) { for (auto &&vx     : vecc)fill(vx, vall); }\ntemplate<typename W, typename T> void fill(vector<W> &xx, const T v, ll len) { rep(i, len)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<W> &xx, const T v, int s, ll t) { rep(i, s, t)xx[i] = v; }\ntemplate<typename W, typename T> void fill(vector<vector<W>> &xx, T v, int sh, int th, int sw, int tw) { rep(h, sh, th)rep(w, sw, tw)xx[h][w] = v; }\n//#define use_fill //_sum _array _max _min\n#ifdef use_fill\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N){fill(a[i], v);}}\ntemplate<class T, class U> void fill(vector<T> &a, const vi &ind, U val) { fora(v, ind) { a[v] = val; }}\ntemplate<typename A, size_t N> auto sum(A (&a)[N], int l = -1, int r = -1) {set_lr12(l, r, N);auto res = sum(a[l]);if (l == r) {return res - res;}rep(i, l + 1, r)res += sum(a[i]);return res;}\ntemplate<typename A, size_t N> auto max(A (&a)[N], int l = -1, int r = -1) {    set_lr12(l, r, N);    auto res = max(a[l]);    if (l == r) {        return -INF<decltype(res)>();    }    rep(i, l + 1, r)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N> auto min(A (&a)[N], int l = -1, int r = -1) {    set_lr12(l, r, N);    auto res = min(a[l]);    if (l == r) {        return INF<decltype(res)>();    }    rep(i, l + 1, r)res = min(res, min(a[i]));    return res;}\n#endif\n\n\nvi inds_(vi &a) {    int n = max(a) + 1;    vi ret(n, -1);    rep(i, sz(a)) { assert(ret[a[i]] ==-1);ret[a[i]] = i; }    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\nvoid clear(priority_queue<int> &q) { q = priority_queue<int>(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\n//template<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\n//template<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n\n\ntemplate<class T> struct ruiC {\n    vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    /*先頭0*/\n    ruiC() : rui(1, 0) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruic \";            deb(l, r);            assert(0);        }        return rui[r] - rui[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, sz(rui) - 1)); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    T operator[](ll i) { return rui[i]; }\n    /*0から順に追加される必要がある*/\n    void operator+=(T v) { rui.push_back(rui.back() + v); }\n    void add(int i, T v) {if (sz(rui) - 1 != i)ole();operator+=(v);}\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n    auto begin() { return rui.begin(); }\n    auto end() { return rui.end(); }\n};\ntemplate<class T> string deb_tos(const ruiC<T> &a) {return deb_tos(a.rui);}\ntemplate<class T> ostream &operator<<(ostream &os, ruiC<T> a) {    fora(v, a.rui){os << v << \" \"; }   return os;}\ntemplate<class T> vector<T> ruiv(const vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(const vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\ntemplate<class T> ruiC<T> ruic() { return ruiC<T>(); }\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n\n//#define use_rui //_imo _ruic _ruiv\n#ifdef use_rui\n//kと同じものの数\ntemplate<class T, class U> vi imo(const vector<T> &a, U k) {    vi equ(sz(a));    rep(i, sz(a)){        equ[i] = a[i]==k;    }    return imo(equ);}\ntemplate<class T> vector<T> imox(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> ima(const vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chma(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rimi(const vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chmi(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> vector<T> rima(const vector<T> &v) {    vector<T> ret = v;    rer(i, sz(ret) - 1, 1)chma(ret[i - 1], ret[i]);    return ret;}\ntemplate<class T> struct ruimax {\n    template<typename Monoid> struct SegmentTree {        /*pairで処理*/        int sz;        vector<Monoid> seg;        const Monoid M1 = mp(MIN<T>(), -1);        Monoid f(Monoid a, Monoid b) { return max(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<int> ri;\n    bool build = false;\npublic:\n    int n;\n    ruimax(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        T ma = MIN<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = -INF<T>();        ri[0] = -1;        rep(i, n) {            if (chma(ma, a[i])) { index = i; }            rv[i + 1] = ma;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        if (!(l <= r && 0 <= l && r <= n)) {            deb(l, r, n);            assert(0);        }        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    int geti(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    int geti(int r = inf) { return geti(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> struct ruimin {\n    template<typename Monoid> struct SegmentTree {  /*pairで処理*/         int sz;vector<Monoid> seg;        const Monoid M1 = mp(MAX<T>(), -1);        Monoid f(Monoid a, Monoid b) { return min(a, b); }        void build(vector<T> &a) {            int n = sz(a);            sz = 1;            while (sz < n) sz <<= 1;            seg.assign(2 * sz, M1);            rep(i, n) { seg[i + sz] = mp(a[i], i); }            for (int k = sz - 1; k > 0; k--) { seg[k] = f(seg[k << 1], seg[(k << 1) | 1]); }        }        Monoid query(int a, int b) {            Monoid L = M1, R = M1;            for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {                if (a & 1) L = f(L, seg[a++]);                if (b & 1) R = f(seg[--b], R);            }            return f(L, R);        }        Monoid operator[](const int &k) const { return seg[k + sz]; }    };\nprivate:\n    vector<T> ve;\n    SegmentTree<pair<T, int>> seg;\n    vector<T> rv;\n    vector<int> ri;\n    bool build = false;\n    int n;\npublic:\n    ruimin(vector<T> &a) : ve(a), n(sz(a)) {        int index = -1;        T mi = MAX<T>();        rv.resize(n + 1);        ri.resize(n + 1);        rv[0] = INF<T>();        ri[0] = -1;        rep(i, n) {            if (chmi(mi, a[i])) { index = i; }            rv[i + 1] = mi;            ri[i + 1] = index;        }    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return rv[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).first;        }    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    T getv(int l, int r) { return operator()(l, r); }\n    T getv(int r = inf) { return getv(0, min(r, n)); };\n    int geti(int l, int r) {        {            assert(l <= r && 0 <= l && r <= n);            if (l == 0) { return ri[r]; }            else {                if (!build)seg.build(ve), build = true;                return seg.query(l, r).second;            }        }        assert(l <= r && 0 <= l && r <= n);        if (l == 0) { return ri[r]; }        else {            if (!build)seg.build(ve), build = true;            return seg.query(l, r).second;        }    }\n    int geti(int r = inf) { return geti(0, min(r, n)); };\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};/*@formatter:off*/\n\nvvi() ruib(vi &a) {    vvi(res, 61, sz(a) + 1);    rep(k, 61) { rep(i, sz(a)) { res[k][i + 1] = res[k][i] + ((a[i] >> k) & 1); }}    return res;}\nvector<ruiC<int>> ruibc(vi &a) {vector<ruiC<int>> ret(61);    vvi(res, 61, sz(a));    rep(k, 61) {        rep(i, sz(a)) { res[k][i] = (a[i] >> k) & 1; }        ret[k] = ruic(res[k]);    }    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\ntemplate<class T> struct ruiC2 {\n    int H;\n    vector<ruiC<T>> rui;\n    ruiC<T> dummy;//変なのをよばれたときはこれを返す//todo\n    ruiC2(const vector<vector<T>> &ru) : rui(sz(ru)), H(sz(ru)) {            for (int h = 0; h < H; h++) {                if (sz(ru[h]) == 0)continue;                if (sz(dummy) == 1) dummy = ruic(vector<T>(sz(ru[h])));                rui[h] = ruic(ru[h]);            }        }\n    //WについてHを返す\n    vector<T> operator()(ll l, ll r) {            if (l > r) {                cerr << \"ruic \";                deb(l, r);                assert(0);            }            vector<T> res(H);            for (int h = 0; h < H; h++)res[h] = rui[h](l, r);            return res;        }\n    //HについてWを返す\n    ruiC<T> &operator[](ll h) {\n#ifdef _DEBUG\n        if (h >= H) {message += \"warning ruiC h >= H\";}\n#endif\n        if (h >= H || sz(rui[h]) == 1)return dummy;else return rui[h];\n    }\n    /*@formatter:off*/\n    //    vector<T> operator()(int r) { return operator()(0, r); }\n    /*ruiv[]をruic[]に変えた際意味が変わるのがまずいため()と統一*/\n    /*単体iを返す 累積でないことに注意(seg木との統一でこうしている)*/\n//    T operator[](ll i) { return rui[i + 1] - rui[i]; }\n    /*0から順に追加される必要がある*/\n//    T back() { return rui.back(); }\n//    ll size() { return rui.size(); }\n//    auto begin(){return rui.begin();}\n//    auto end(){return rui.end();}\n};\n\ntemplate<class T, class U> ruiC<ll> ruicou(vector<T> &a, U b) {    vi cou(sz(a));    rep(i, sz(a)) { cou[i] = a[i] == b; }    return ruic(cou);}\n\n//メモリは形式によらず(26*N)\n// rui(l,r)でvector(26文字について, l~rのcの個数)\n// rui[h] ruic()を返す\n// 添え字は'a', 'A'のまま扱う (予め-='a','A'されているものが渡されたらそれに従う)\ntemplate<typename Iterable, class is_Iterable = typename Iterable::value_type>\nruiC2<ll> ruicou(const Iterable &a) {        int H = max(a) + 1;        vvi(cou, H);        rep(i, sz(a)) {            if (sz(cou[a[i]]) == 0)cou[a[i]].resize(sz(a));            cou[a[i]][i] = 1;        }        return ruiC2<ll>(cou);    }\n\n\n/*@formatter:off*/\n//h query\ntemplate<class T> vector<T> imoh(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v));    rep(h, sz(ret)) { ret[h] = v[h][w]; }    rep(i, sz(ret) - 1) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> vector<T> ruih(vector<vector<T>> &v, int w) {    vector<T> ret(sz(v) + 1);    rep(h, sz(v)) { ret[h + 1] = v[h][w]; }    rep(i, sz(v)) { ret[i + 1] += ret[i]; }    return ret;}\ntemplate<class T> ruiC<T> ruihc(vector<vector<T>> &a, int w) {    vector<T> ret = ruih(a, w);    return ruiC<T>(ret);}\n\n//xor\ntemplate<class T> struct ruixC {\n    vector<T> rui;\n    ruixC(vector<T> &ru) : rui(ru) {}\n    T operator()(ll l, ll r) {        if (l > r) {            cerr << \"ruiXc \";            deb(l, r);            assert(0);        }        return rui[r] ^ rui[l];    }\n    T operator[](ll i) { return rui[i]; }\n    T back() { return rui.back(); }\n    ll size() { return rui.size(); }\n};\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> ruixC<ll> ruixc(vector<T> &a) {    vi ret = ruix(a);    return ruixC<ll>(ret);}\n//差分を返す(累積を取ると元に戻る)\n//101なら\n//1111を返す\n//元の配列で[l, r)へのxorは\n//[l]と[r]へのxorになる https://atcoder.jp/contests/abc155/tasks/abc155_f\nvi ruix_diff(vi &A) {    int N = sz(A);    assert(N);    vi res(N + 1);    res[0] = A[0];    rep(i, 1, N) { res[i] = A[i - 1] ^ A[i]; }    res[N] = A[N - 1];    return res;}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> struct rruiC {\n    vector<T> rui;\n    int n;\n    rruiC(vector<T> &a) : n(sz(a)) {        rui.resize(n + 1);        rer(i, n - 1) { rui[i] = rui[i + 1] + a[i]; }    }\n    /*[r l)*/\n    T operator()(int r, int l) {        r++;        l++;        assert(l <= r && l >= 0 && r <= n);        return rui[l] - rui[r];    }\n    T operator()(int l) { return operator()(n - 1, l); }\n    T operator[](int i) { return operator()(i); }\n};\ntemplate<class T> ostream &operator<<(ostream &os, rruiC<T> a) {    fora(v, a.rui){os << v << \" \"; }   return os;}\ntemplate<class T> string deb_tos(rruiC<T> &a) {return deb_tos(a.rui);}\n\n#define rrui rruic\ntemplate<class T> rruiC<T> rruic(vector<T> &a) { return rruiC<T>(a); }\n\n//掛け算\ntemplate<class T> struct ruimulC {\n    vector<T> rv;\n    int n;\n    ruimulC(vector<T> &a) : rv(a), n(sz(a)) {        rv.resize(n + 1);        rv[0] = 1;        rep(i, n) { rv[i + 1] = a[i] * rv[i]; }    }\n    ruimulC() : n(0) {        rv.resize(n + 1);        rv[0] = 1;    }\n    void operator+=(T v) {        rv.push_back(rv.back() * v);        n++;    }\n    T operator()(int l, int r) {        assert(l <= r && 0 <= l && r <= n);        return rv[r] / rv[l];    }\n    T operator()(int r = inf) { return operator()(0, min(r, n)); }\n    T operator[](int r) { return operator()(0, r); }\n    auto begin() { return rv.begin(); }\n    auto end() { return rv.end(); }\n};\ntemplate<class T> ruimulC<T> ruimul(vector<T> &a) { return ruimulC<T>(a); }\ntemplate<class T> ruimulC<T> ruimul() {    vector<T> a;    return ruimulC<T>(a);}\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U, class W> T lowerBound(ruiC <T> &a, U v, W banpei) { return lowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T upperBound(ruiC <T> &a, U v, W banpei) { return upperBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rlowerBound(ruiC <T> &a, U v, W banpei) { return rlowerBound(a.rui, v, banpei); }\ntemplate<class T, class U, class W> T rupperBound(ruiC <T> &a, U v, W banpei) { return rupperBound(a.rui, v, banpei); }\n#endif\n\nconstexpr bool bget(ll m, ll keta) {\n#ifdef _DEBUG\n    assert(keta <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (m >> keta) & 1;\n}\n//bget(n)次元\n//                          NならN-1まで\nvector<vi> bget2(vi &a, int keta_size) {    vvi(res, keta_size, sz(a));    rep(k, keta_size) { rep(i, sz(a)) { res[k][i] = bget(a[i], k); }}    return res;}\nvi bget1(vi &a, int keta) {    vi res(sz(a));    rep(i, sz(a)) { res[i] = bget(a[i], keta); }    return res;}\n#if __cplusplus >= 201703L\nll bget(ll m, ll keta, ll sinsuu) {    m /= pow<ll>(sinsuu, keta);    return m % sinsuu;}\n#else\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll)pow(sinsuu, keta);    return m % sinsuu;}\n#endif\nconstexpr ll bit(ll n) {\n#ifdef _DEBUG\n    assert(n <= 62);//オーバーフロー 1^62までしか扱えない\n#endif\n    return (1LL << (n));\n}\n#if __cplusplus >= 201703L\nll bit(ll n, ll sinsuu) { return pow<ll>(sinsuu, n); }\n#else\nll bit(ll n, ll sinsuu) { return (ll)pow(sinsuu, n); }\n#endif\nll mask(ll n) { return (1ll << n) - 1; }\n//aをbitに置きなおす\n//{0, 2} -> 101\nll bit(const vi &a) {    int m = 0;    for (auto &&v:a) m |= bit(v);    return m;}\n\n//{1, 1, 0} -> 011\n//bitsetに置き換える感覚 i が立っていたら i bit目を立てる\nll bit_bool(vi &a) {    int m = 0;    rep(i, sz(a)) if (a[i])m |= bit(i);    return m;}\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { assert(n);return n & -n; }\nll lbiti(ll n) { assert(n);return log2(n & -n); }\n//最上位ビット\nll hbit(ll n) {    assert(n);n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbiti(ll n) { assert(n);return log2(hbit(n)); }\n//ll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\n/*over*/#define forbit1_2(i, mas) for (int forbitj = !mas ? 0 : lbit(mas), forbitm = mas, i = !mas ? 0 :log2(forbitj); forbitm; forbitm = forbitm ^ forbitj, forbitj = !forbitm ? 1 : lbit(forbitm), i = log2(forbitj))\n/*over*/#define forbit1_3(i, N, mas) for (int forbitj = !mas ? 0 : lbit(mas), forbitm = mas, i = !mas ? 0 :log2(forbitj); forbitm  && i < N; forbitm = forbitm ^ forbitj, forbitj = !forbitm ? 1 : lbit(forbitm), i = log2(forbitj))\n//masの立ってるindexを見る\n//              i, [N], mas\n#define forbit1(...) over3(__VA_ARGS__, forbit1_3, forbit1_2)(__VA_ARGS__)\n//masが立っていないindexを見る\n//              i, N, mas\n#define forbit0(i, N, mas) forbit1(i, mask(N) & (~(mas)))\n\n//forsubをスニペットして使う\n//Mの部分集合(0,M含む)を見る 3^sz(S)個ある\n#define forsub_all(m, M) for (int m = M; m != -1; m = m == 0 ? -1 : (m - 1) & M)\n//BASE進数\ntemplate<size_t BASE> class base_num {\n    int v;\npublic:\n    base_num(int v = 0) : v(v) {};\n    int operator[](int i) { return bget(v, i, BASE); }\n    void operator++() { v++; }\n    void operator++(signed) { v++; }\n    operator int() { return v; }\n};\n#define base3(mas, lim, BASE) for (base_num<BASE> mas; mas < lim; mas++)\n#define base2(mas, lim) base3(mas, lim, 2)\n#define base(...) over3(__VA_ARGS__,base3,base2,base1)(__VA_ARGS__)\n\n\n//aにある物をtrueとする\nvb bool_(vi a, int n) {    vb ret(max(max(a) + 1, n));    rep(i, sz(a))ret[a[i]] = true;    return ret;}\n\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    res = rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n//#define use_compress\n//[i] := vを返す\n//aは0~n-1で置き換えられる\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(ALL(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\n#ifdef use_compress\n//ind[i] := i番目に小さい数\n//map[v] := vは何番目に小さいか\nvi compress(vi &a, umapi &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(ALL(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a){b.push_back(v);}    fora(v, r){b.push_back(v);}    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(ALL(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(ALL(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a){b.push_back(v);}    fora(v, r){b.push_back(v);}    fora(v, s){b.push_back(v); }   sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(ALL(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(ALL(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(ALL(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vi> &a) {    vi b;    fora(vv, a){fora(v, vv){b.push_back(v);}}    sort(b);    unique(b);    fora(vv, a){fora(v, vv){v = lower_bound(ALL(b), v) - b.begin(); }}   ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a){fora(vv, vvv){fora(v, vv){b.push_back(v);}}}    sort(b);    unique(b);   fora(vvv, a){fora(vv, vvv){fora(v, vv){v = lower_bound(ALL(b), v) - b.begin();}}}    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(ALL(b), a[i]) - b.begin(); }}\n#endif\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(ALL(a),v))\n#define lowerIndex(a, v) (lower_bound(ALL(a),v)-a.begin())\n#define upperIndex(a, v) (upper_bound(ALL(a),v)-a.begin())\n#define rlowerIndex(a, v) (upper_bound(ALL(a),v)-a.begin()-1)\n#define rupperIndex(a, v) (lower_bound(ALL(a),v)-a.begin()-1)\n\ntemplate<class T, class U, class W> T lowerBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(vector<T> &a, U v, W banpei) {    auto it = upper_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(vector<T> &a, U v, W banpei) {    auto it = lower_bound(a.begin(), a.end(), v);    if (it == a.begin())return banpei; else { return *(--it); }}\n//todo 消せないか\ntemplate<class T, class U, class W> T lowerBound(set<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(set<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(set<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n\ntemplate<class T, class U, class W> T lowerBound(mset<T> &a, U v, W banpei) {    auto it = a.lower_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T upperBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.end())return banpei; else return *it;}\ntemplate<class T, class U, class W> T rlowerBound(mset<T> &a, U v, W banpei) {    auto it = a.upper_bound(v);    if (it == a.begin())return banpei; else { return *(--it); }}\ntemplate<class T, class U, class W> T rupperBound(mset<T> &a, U v, W banpei) {auto it = a.lower_bound(v);if (it == a.begin())return banpei; else { return *(--it); }}\n#define next2(a) next(next(a))\n#define prev2(a) prev(prev(a))\n\n//狭義の単調増加列 長さを返す\ntemplate<class T> int lis(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = lowerIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\ntemplate<class T> int lis_eq(vector<T> &a) {    int n = sz(a);    vi tail(n + 1, MAX<T>());    rep(i, n) {        int id = upperIndex(tail, a[i]);/**/        tail[id] = a[i];    }    return lowerIndex(tail, MAX<T>());}\n\n//iteratorを返す\n//valueが1以上の物を返す 0は見つけ次第削除\n//vを減らす場合 (*it).se--でいい\ntemplate<class T, class U, class V> auto lower_map(map<T, U> &m, V k) {    auto ret = m.lower_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\ntemplate<class T, class U, class V> auto upper_map(map<T, U> &m, V k) {    auto ret = m.upper_bound(k);    while (ret != m.end() && (*ret).second == 0) {        ret = m.erase(ret);    }    return ret;}\n//存在しなければエラー\ntemplate<class T, class U, class V> auto rlower_map(map<T, U> &m, V k) {    auto ret = upper_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\ntemplate<class T, class U, class V> auto rupper_map(map<T, U> &m, V k) {    auto ret = lower_map(m, k);    assert(ret != m.begin());    ret--;    while (1) {        if ((*ret).second != 0)break;        assert(ret != m.begin());        auto next = ret;        --next;        m.erase(ret);        ret = next;    }    return ret;}\n\ntemplate<class... T> void fin(T... s) {out(s...); exit(0); }\n\n//便利 数学 math\n//sub ⊂ top\nbool subset(int sub, int top) {return (sub & top) == sub;}\n//-180 ~ 180 degree\ndouble atand(double h, double w) {return atan2(h, w) / PI * 180;}\n//% -mの場合、最小の正の数を返す\nll mod(ll a, ll m) {if (m < 0) m *= -1;return (a % m + m) % m;}\n//ll pow(ll a) { return a * a; };\ntemplate<class T> T fact(int v) {    static vector<T> fact(2, 1);    if (sz(fact) <= v) { rep(i, sz(fact), v + 1) { fact.emplace_back(fact.back() * i); }}    return fact[v];}\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\n//二項係数の偶奇を返す\nint com_mod2(int n,int r){return n == ( r | (n - r) );}\ndouble comd2(ll n, ll r) {    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) { comb[i + 1][j] = comb[i][j] + comb[i][j - 1]; }        }    }    return comb[n][r];}\ndouble comd(int n, int r) {    if (r < 0 || r > n) return 0;    if (n < 2020)return comd2(n, r);    static vd fact(2, 1);    if (sz(fact) <= n) { rep(i, sz(fact), n + 1) { fact.push_back(fact.back() * i); }}    return fact[n] / fact[n - r] / fact[r];}\n\n#define gcd my_gcd\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\n#define lcm my_lcm\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\n#define hypot my_hypot\ndouble hypot(double dx, double dy){return std::sqrt(dx*dx+ dy*dy);}\n\nll sig0(int t) { return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\nbint sig0(bint t) {return t <= 0 ? 0 : ((1 + t) * t) >> 1; }\n//ll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\nll sig(ll s, ll t) {if (s > t)swap(s, t);return sig0(t - s) + s * (t - s + 1);}\n\n#define tousa_i tosa_i\n#define lower_tousa_i lower_tosa_i\n#define upper_tousa upper_tosa\n#define upper_tousa_i upper_tosa_i\nll tosa_i(ll st, ll ad, ll v) {    assert(((v - st) % ad) == 0);    return (v - st) / ad;}\nll tosa_s(ll st, ll ad, ll len) {    return st * len + sig0(len - 1) * ad;}\n\n// ax + r (x は非負整数) で表せる整数のうち、v 以上となる最小の整数\nll lower_tosa(ll st, ll ad, ll v) {    if (st >= v) return st;    return (v - st + ad - 1) / ad * ad + st;}\n//第何項か\nll lower_tosa_i(ll st, ll ad, ll v) {    if (st >= v) return 0;    return (v - st + ad - 1) / ad;}\nll upper_tosa(ll st, ll ad, ll v) { return lower_tosa(st, ad, v + 1); }\nll upper_tosa_i(ll st, ll ad, ll v) { return lower_tosa_i(st, ad, v + 1); }\n\n//b * res <= aを満たす [l, r)を返す div\nP drange_ika(int a, int b) {    P null_p = mp(linf, linf);    if (b == 0) {        if (a >= 0) {            return mp(-linf, linf + 1)/*全て*/;        } else {            return null_p/*無い*/;        }    } else {        if (a >= 0) {            if (b > 0) {                return mp(-linf, a / b + 1);            } else {                return mp(-(a / -b), linf + 1);            }        } else {            if (b > 0) {                return mp(-linf, -ceil(-a, b) + 1);            } else {                return mp(ceil(-a, -b), linf + 1);            }        }    }}\n\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {    if (a < 0) {        debugline(\"sqrt\");        deb(a);        ole();    }    ll res = (ll) std::sqrt(a);    while (res * res < a)++res;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\n\n\n/*@formatter:off*/\n\n//機能拡張\n#define dtie(a, b) int a, b; tie(a, b)\ntemplate<class T, class U> string to_string(T a, U b) {    string res = \"\";    res += a;    res += b;    return res;}\ntemplate<class T, class U, class V> string to_string(T a, U b, V c) {    string res = \"\";    res += a;    res += b;    res += c;    return res;}\ntemplate<class T, class U, class V, class W> string to_string(T a, U b, V c, W d) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    return res;}\ntemplate<class T, class U, class V, class W, class X> string to_string(T a, U b, V c, W d, X e) {    string res = \"\";    res += a;    res += b;    res += c;    res += d;    res += e;    return res;}\n//todo stringもセットで\ntemplate<class T> vector<T> sub(const vector<T> &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    vector<T> ret(r - l);    std::copy(A.begin() + l, A.begin() + r, ret.begin());    return ret;}\ntemplate<class T> vector<T> sub(const vector<T> &A, int r) { return sub(A, 0, r); }\ntemplate<class T> vector<T> subn(const vector<T> &A, int l, int len) { return sub(A, l, l + len); }\nstring sub(string &A, int l, int r) {    assert(0 <= l && l <= r && r <= sz(A));    return A.substr(l, r - l);}\ntemplate<class T, class F>\n//sub2で呼ぶ\nvector<T> sub(const vector<vector<T> >& A, int h, int w, int ah,int aw, F f){    vector<T> res;    while(0<= h && h < sz(A) && 0 <= w && w < sz(A[h]) && f(A[h][w])){        res.emplace_back(A[h][w]);        h += ah;        w += aw;    }    return res;}\ntemplate<class T> vector<T>sub(const vector<vector<T> >& A, int h, int w, int ah,int aw){return sub(A, h, w, ah, aw, [&](T v){return true;});}\n//range_nowを返す(find_ifでしか使われない)\n#if __cplusplus >= 201703L\ntemplate<class T> auto subr(const vector<T> &A, int l) {return range_now(vector<T>(A.begin()+l, A.end()), l);}\n#endif\n#define sub25(A, h, w, ah, aw) sub(A, h, w, ah, aw)\n#define sub26(A, h, w, ah, aw, siki_r) sub(A, h, w, ah, aw, [&](auto v){return v siki_r;})\n#define sub27(A, h, w, ah, aw, v, siki) sub(A, h, w, ah, aw, [&](auto v){return siki;})\n#define sub2(...) over7(__VA_ARGS__,sub27,sub26,sub25)(__VA_ARGS__)\n\nconstexpr int bsetlen = k5 * 2;\n//constexpr int bsetlen = 5050;\n#define bset bitset<bsetlen>\nbool operator<(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return false;}\nbool operator>(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return false;}\nbool operator<=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] < b[i])return true;if (a[i] > b[i])return false;}return true;}\nbool operator>=(bitset<bsetlen> &a, bitset<bsetlen> &b) {rer(i, bsetlen - 1) {if (a[i] > b[i])return true;if (a[i] < b[i])return false;}return true;}\nstring operator~(string &a) {string res = a;for (auto &&c:res) {if (c == '0')c = '1';else if (c == '1')c = '0';else {cerr << \"cant ~\" << a << \"must bit\" << endl;exit(0);}}return res;}\nostream &operator<<(ostream &os, bset& a) {    bitset<10> b;    vi list;    rep(i,bsetlen){        if(a[i])list.push_back(i),b[i]=1;    }    os<<b<<\", \"<<list;    return os;}\nint hbiti(bset&a){rer(i,bsetlen){if(a[i])return i;}return -1;}\n#define hk(a, b, c) (a <= b && b < c)\n\n//O(N/64)\nbset nap(bset &a, int v) {bset r = a | a << v;return r;}\nbset nap(bset &a, bset &v) {bset r = a;rep(i, bsetlen) {if (v[i])r |= a << i;}return r;}\n\ntemplate<class T> int count(set<T> &S, T l, T r) {    assert(l < r);    auto it = S.lower_bound(l);    return it != S.end() && (*it) < r;}\n\n//template<class T> void seth(vector<vector<T>> &S, int w, vector<T> &v) {assert(sz(S) == sz(v));assert(w < sz(S[0]));rep(h, sz(S)) { S[h][w] = v[h]; }}\ntemplate<class T> vector<T> geth(vector<vector<T>> &S, int w) {    assert(w < sz(S[0]));    vector<T> ret(sz(S));    rep(h, sz(S)) { ret[h] = S[h][w]; }    return ret;}\n//vector<bool>[i]は参照を返さないため、こうしないとvb[i] |= trueがコンパイルエラー\nvb::reference operator|=(vb::reference a, bool b){return a = a | b;}\nvb::reference operator&=(vb::reference a, bool b){return a = a & b;}\ntemplate<class T, class U> void operator+=(pair<T,U> &a, pair<T,U> & b) {a.fi+=b.fi;a.se+=b.se;}\ntemplate<class T, class U> pair<T, U> operator+(const pair<T, U> &a, const pair<T, U> &b) { return pair<T, U>(a.fi + b.fi, a.se + b.se); }\ntemplate<class T, class U> pair<T,U> operator-(const pair<T,U> &a, const pair<T,U> & b) {return pair<T,U>(a.fi-b.fi,a.se-b.se);}\ntemplate<class T, class U> pair<T,U> operator-(const pair<T, U>& a){return pair<T, U>(-a.first, -a.second);}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const int rv) {\n#ifdef _DEBUG\n    static bool was = false;if (!was)message += \"str += 65  is  'A'  not \\\"65\\\" \";was = true;\n#endif\n    return lhs + (char) rv;\n}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const int rv) {    lhs = lhs + rv;}\ntemplate<typename CharT, typename Traits, typename Alloc> basic_string<CharT, Traits, Alloc> operator+(const basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {    const int rv2 = rv;    return lhs + rv2;}\ntemplate<typename CharT, typename Traits, typename Alloc> void operator+=(basic_string<CharT, Traits, Alloc> &lhs, const signed rv) {const int v = rv; lhs += v; }\ntemplate<typename CharT, typename Traits, typename Alloc> void operator*=(basic_string<CharT, Traits, Alloc> &s, int num) {    auto bek = s;    s = \"\";    for (; num; num >>= 1) {        if (num & 1) { s += bek; }        bek += bek;    }}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v){a.push(d);}    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v){a.insert(d);}    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return a.insert(v); }template<class T, class U> auto operator-=(set<T> &a, U v) { return a.erase(v); }template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(U v,const vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(const vector<T>& a, const vector<T>& b) {    vector<T> ret;    ret = a;    fora(v, b){ret += v; }   return ret;}template<class T> vector<T> &operator+=(vector<T> &a,const vector<T> &b) {    rep(i, sz(b)) {/*こうしないとa+=aで両辺が増え続けてバグる*/        a.push_back(b[i]); }    return a;}template<class T, class U> map<T, U> &operator+=(map<T, U> &a, map<T, U> &b) {    for(auto&& bv : b) { a[bv.first] += bv.second; }    return a;}template<class T, class U> vector<T> operator+(const vector<T> &a, const U& v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> auto operator+=(uset<T> &a, U v) { return a.insert(v); }\ntemplate<class T> vector<T> operator%(vector<T>& a, int v){    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = a[i] % v;    }    return ret;}\ntemplate<class T> vector<T> operator%=(vector<T>& a, int v){    rep(i,sz(a)){        a[i] %= v;    }    return a;}\nvi operator&(vi& a, vi& b){    assert(sz(a)==sz(b));    vi ret(sz(a));    rep(i,sz(a)){        ret[i] = min(a[i],b[i]);    }    return ret;}\ntemplate<class T> void operator+=(mset<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(set<T> &a, vector<T>& v) { for(auto&& u : v)a.insert(u); }\ntemplate<class T> void operator+=(vector<T> &a, set<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> void operator+=(vector<T> &a, mset<T>& v) { for(auto&& u : v)a.emplace_back(u); }\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\n//template<class T, class U> void operator*=(vector<T> &a, U b) {    vector<T> ta = a;    rep(b-1){        a+=ta;    }}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<typename T> void pop_front(vector<T> &v) { erase(v, 0); }\ntemplate<typename T> void entry(vector<T> &v, unsigned ll s, unsigned ll e) { erase(v, e, sz(v));erase(v,0,s);}\n\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\nvector<string> split(const string &a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string &a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nll stoi(string& s){return stol(s);}\n#define assert_yn(yn_v, v); assert(yn_v == 0 || yn_v == v);yn_v = v;\n//不完全な対策、現状はautohotkeyで対応\nint yn_v = 0;\nvoid yn(bool a) { assert_yn(yn_v, 1);if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid fyn(bool a) {    assert_yn(yn_v, 1);yn(a);    exit(0);}\n\nvoid Yn(bool a) { assert_yn(yn_v, 2);if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid fYn(bool a) {    assert_yn(yn_v, 2);Yn(a);    exit(0);}\n\nvoid YN(bool a) { assert_yn(yn_v, 3);if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fYN(bool a) {    assert_yn(yn_v, 3);YN(a);    exit(0);}\nint ab_v = 0;\nvoid fAb(bool a) { assert_yn(ab_v, 1);if(a)cout<<\"Alice\"<<endl;else cout<<\"Bob\";}\nvoid fAB(bool a) { assert_yn(yn_v, 2);if(a)cout<<\"ALICE\"<<endl;else cout<<\"BOB\";}\nint pos_v = 0;\nvoid Possible(bool a) {    assert_yn(pos_v, 1);if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    assert_yn(pos_v, 2);if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\nvoid fPossible(bool a) {    assert_yn(pos_v, 1)Possible(a);exit(0);}\nvoid fPOSSIBLE(bool a) {    assert_yn(pos_v, 2)POSSIBLE(a);exit(0);}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\n\n\n//未分類\n//0,2,1 1番目と2番目の次元を入れ替える\ntemplate<class T> auto irekae(vector<vector<vector<T> > > &A, int x, int y, int z) {\n#define irekae_resize_loop(a, b, c) resize(res,a,b,c);rep(i,a)rep(j,b)rep(k,c)\n    vector<vector<vector<T> > > res;    if (x == 0 && y == 1 && z == 2) {        res = A;    } else if (x == 0 && y == 2 && z == 1) {        irekae_resize_loop(sz(A), sz(A[0][0]), sz(A[0])) {                    res[i][j][k] = A[i][k][j];                }    } else if (x == 1 && y == 0 && z == 2) {        irekae_resize_loop(sz(A[0]), sz(A), sz(A[0][0])) {                    res[i][j][k] = A[j][i][k];                }    } else if (x == 1 && y == 2 && z == 0) {        irekae_resize_loop(sz(A[0]), sz(A[0][0]), sz(A)) {                    res[i][j][k] = A[k][i][j];                }    } else if (x == 2 && y == 0 && z == 1) {        irekae_resize_loop(sz(A[0][0]), sz(A), sz(A[0])) {                    res[i][j][k] = A[j][k][i];                }    } else if (x == 2 && y == 1 && z == 0) {        irekae_resize_loop(sz(A[0][0]), sz(A[0]), sz(A)) {                    res[i][j][k] = A[k][j][i];                }    }    return res;\n#undef irekae_resize_loop\n}\ntemplate<class T> auto irekae(vector<vector<T>>&A,int i=1,int j=0){    vvt(res,sz(A[0]),sz(A));    rep(i,sz(A)){        rep(j,sz(A[0])){            res[j][i]=A[i][j];        }    }    return res;}\n//tou分割する\ntemplate<typename Iterable> vector<Iterable> table(const Iterable &a, int tou = 2) {int N = sz(a);    vector<Iterable> res(tou);    int hab = N / tou;    vi lens(tou, hab);    rep(i, N % tou) { lens[tou - 1 - i]++; }    int l = 0;    rep(i, tou) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//長さn毎に分割する\ntemplate<typename Iterable> vector<Iterable> table_n(const Iterable &a, int len) {    int N = sz(a);    vector<Iterable> res(ceil(N, len));    vi lens(N / len, len);    if (N % len)lens.push_back(N % len);    int l = 0;    rep(i, sz(lens)) {        int len = lens[i];        int r = l + len;        res[i].resize(len);        std::copy(a.begin() + l, a.begin() + r, res[i].begin());        l = r;    }    return res;}\n//縦を返す\nvi& geth(vvi()& a, int w){    static vi ret; ret.resize(sz(a));   rep(i,sz(a)){        ret[i] = a[i][w];    }    return ret;}\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;\n//#define pre prev\n//#define nex next\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\nvc atoz = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x','y', 'z'};\nvc AtoZ = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z'};\n//右、上が正\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))return i;    }    return i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))return i; }    return i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\n\n//H*Wのグリッドを斜めに分割する\n//右上\nvector<vp> naname_list_ne(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[sh] += mp(nh, nw);            }else{                break;            }        }    }    rep(sw, 1, W) {        int sh = H - 1;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh--;            nw++;            if (0 <= nh && nw < W) {                res[H + sw-1] += mp(nh, nw);            }else{                break;            }        }    }    return res;}\n//右下\nvector<vp> naname_list_se(int H, int W) {    vector<vp> res(H + W - 1);    rep(sh, H) {        int sw = 0;        res[sh] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh< H && nw < W) { res[sh] += mp(nh, nw); } else { break; }        }    }    rep(sw, 1, W) {        int sh = 0;        res[H + sw - 1] += mp(sh, sw);        int nh = sh;        int nw = sw;        while (1) {            nh++;            nw++;            if (0 <= nh && nh < H && nw < W) { res[H + sw - 1] += mp(nh, nw); } else { break; }        }    }    return res;}\n\n//グラフ内で #undef getid\n//#define getidとしているため、ここを書き直したらgraphも書き直す\n#define getid_2(h, w) ((h) * (W) + (w))\n#define getid_1(p) ((p).first * W + (p).second)\n#define getid(...) over2(__VA_ARGS__, getid_2, getid_1) (__VA_ARGS__)\n#define getp(id) mp(id / W, id % W)\n#define set_shuffle() std::random_device seed_gen;std::mt19937 engine(seed_gen())\n#define shuffle(a) std::shuffle((a).begin(), (a).end(), engine);\n//1980 開始からtime ms経っていたらtrue\nvb bit_bool(int v, int len) {    assert(bit(len) > v);    vb ret(len);    rep(i, len) { ret[i] = bget(v, i); }    return ret;}\nvi range(int l, int r) {vi ret;ret.resize(r - l);rep(v, l, r) {ret[v - l] = v;}return ret;}\nvi range(int r) {return range(0, r);}\nvi tov(vb& a){    vi ret;    rep(i,sz(a)){        if(a[i])ret.push_back(i);    }    return ret;}\nbool kaibun(const str& S){return S==rev(S);}\ntemplate<class T> vector<T> repeat(const vector<T> &A, int kaisu) {    vector<T> ret;    while (kaisu--) {        ret += A;    }    return ret;}\n#define rge range\n#define upd update\n//S[{s, t, d}]\n#define strs slice_str\nstruct slice_str {\n    string S;\n    slice_str() {}\n    slice_str(const string &S) : S(S) {}\n    slice_str(int len, char c) : S(len, c) {}\n    auto size(){return S.size();}\n    char& operator[](int p) {        return S[p]; }\n    string operator[](initializer_list<int> p) {        if (sz(p) == 1) {            return S.substr(0, *(p.begin()));        } else if (sz(p) == 2) {            int l = *(p.begin());            int r = *(next(p.begin()));            return S.substr(l, r - l);        } else {            auto it = p.begin();            int s = *(it++);            int t = *(it++);            int d = *(it);            if (d == -1) {                int s_ = sz(S) - s - 1;                int t_ = sz(S) - t - 1;                return rev(S).substr(s_, t_ - s_);            } else if (d < 0) {                t = max(-1ll, t);                string ret;                while (s > t) {                    ret += S[s];                    s += d;                }                return ret;            } else {                t = min(sz(S), t);                string ret;                while (s < t) {                    ret += S[s];                    s += d;                }                return ret;            }        }    }\n    operator string &() {        return S;    }\n    template<class T> void operator+=(const T &a) { S += a; }\n    bool operator==(const slice_str& rhs){return S==rhs.S;}\n};\nostream &operator<<(ostream &os, const slice_str &a) {    os << a.S;    return os;}\nistream &operator>>(istream &iss, const slice_str &a) {    iss >> a.S;    return iss;}\ntemplate<class T> bool can(const T &v, int i) { return 0 <= i && i < sz(v); }\n#if __cplusplus >= 201703L\n//template<class T> auto sum(int a, T  v...) {return (v + ... + 0);}\n#endif\n#define VEC vector\n#endif /*UNTITLED15_TEMPLATE_H*/\n\n#endif\n\n//† ←template終了\n/*@formatter:on*/\n//vectorで取れる要素数\n//bool=> 1e9 * 8.32\n//int => 1e8 * 2.6\n//ll  => 1e8 * 1.3\n//3次元以上取るとメモリがヤバい\n//static配列を使う\nvvc (ba);\nll N, M, H, W;\nvi A, B, C;\n#ifndef MINT\n#define MINT\n/*@formatter:off*/\ntemplate<typename T> T minv(T a, T m);\ntemplate<typename T> T minv(T a);\n\nusing Type = std::uint_fast64_t;\ntemplate <typename Mod_t> class modint {\n    constexpr static auto mod() { return Mod_t::value; }\npublic:\n    Type value;\n    constexpr modint() : value(){}\n    constexpr modint(const Type &x) noexcept {\n        if (-mod() <= x && x < mod()) value = static_cast<Type>(x); else value = static_cast<Type>(x % mod());\n        if (value < 0) value += mod();\n    }\n    const Type &operator()() const { return value; }\n    template<typename U> explicit operator U() const { return static_cast<U>(value); }\n\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        value += rhs.value;\n        if (value >= mod()) {\n            value -= mod();\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (value < rhs.value) {\n            value += mod();\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        value = value * rhs.value % mod();\n        return *this;\n    }\n    constexpr modint &operator/=(const modint& rhs) noexcept {\n        return operator*=(minv(rhs.value));\n    }\n    modint &operator++() { return *this += 1; }\n    modint &operator--() { return *this -= 1; }\n    modint operator++(signed) {\n        modint result(*this);\n        *this += 1;\n        return result;\n    }\n    modint operator--(signed) {\n        modint result(*this);\n        *this -= 1;\n        return result;\n    }\n    modint operator-() const { return modint(-value); }\n    template<typename U> friend bool operator==(const modint<U> &lhs, const modint<U> &rhs);\n    template<typename U> friend bool operator<(const modint<U> &lhs, const modint<U> &rhs);\n    template<typename U> friend std::istream &operator>>(std::istream &stream, modint<U> &number);\n    operator int() { return value; }\n};\n/*@formatter:off*/\ntemplate<typename T> bool operator==(const modint<T> &lhs, const modint<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const modint<T> &lhs, U rhs) { return lhs == modint<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const modint<T> &rhs) { return modint<T>(lhs) == rhs; }\ntemplate<typename T> bool operator!=(const modint<T> &lhs, const modint<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const modint<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const modint<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T> bool operator<(const modint<T> &lhs, const modint<T> &rhs) { return lhs.value < rhs.value; }\ntemplate<typename T> modint<T> operator+(const modint<T> &lhs, const modint<T> &rhs) { return modint<T>(lhs) += rhs; }\ntemplate<typename T, typename U> modint<T> operator+(const modint<T> &lhs, U rhs) { return modint<T>(lhs) += rhs; }\ntemplate<typename T, typename U> modint<T> operator+(U lhs, const modint<T> &rhs) { return modint<T>(lhs) += rhs; }\ntemplate<typename T> modint<T> operator-(const modint<T> &lhs, const modint<T> &rhs) { return modint<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> modint<T> operator-(const modint<T> &lhs, U rhs) { return modint<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> modint<T> operator-(U lhs, const modint<T> &rhs) { return modint<T>(lhs) -= rhs; }\ntemplate<typename T> modint<T> operator*(const modint<T> &lhs, const modint<T> &rhs) { return modint<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> modint<T> operator*(const modint<T> &lhs, U rhs) { return modint<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> modint<T> operator*(U lhs, const modint<T> &rhs) { return modint<T>(lhs) *= rhs; }\ntemplate<typename T> modint<T> operator/(const modint<T> &lhs, const modint<T> &rhs) { return modint<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> modint<T> operator/(const modint<T> &lhs, U rhs) { return modint<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> modint<T> operator/(U lhs, const modint<T> &rhs) { return modint<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> modint<T> operator%(const modint<T> &lhs, U rhs) {    cerr << \"can't  mint % int\" << endl;    assert(0);    exit(0);    return 0;}\n\nconstexpr signed MOD =\n        998244353;\n//        1e9 + 7;//MOD\nusing mint = modint<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n#ifdef optional\ntemplate<class T> optional<mint> operator+(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv + opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator-(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator*(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator/(const mint &mv, const optional<T> &opt) { if (opt.has_value())return mv / opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator+(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv + opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator-(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator*(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv * opt.value(); else return optional<mint>(); }\ntemplate<class T> optional<mint> operator/(const optional<T> &opt, const mint &mv) { if (opt.has_value())return mv / opt.value(); else return optional<mint>(); }\ntemplate<class T> void operator+=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv += opt.value(); }\ntemplate<class T> void operator-=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv -= opt.value(); }\ntemplate<class T> void operator*=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv *= opt.value(); }\ntemplate<class T> void operator/=(mint &mv, const optional<T> &opt) { if (opt.has_value())mv /= opt.value(); }\ntemplate<class T> void operator+=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value += mv;}\ntemplate<class T> void operator-=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value -= mv;}\ntemplate<class T> void operator*=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value *= mv;}\ntemplate<class T> void operator/=(const optional<T> &opt, mint &mv) {if (opt.has_value())opt.value /= mv;}\n#endif\n//constexpr int mint_len = std::min(1400001, MOD);\nvi fac, finv, inv;\nvi p2;\nvoid setmod_resize(int mint_len) {\n//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n    int tn = sz(fac);\n    fac.resize(mint_len);\n    finv.resize(mint_len);\n    inv.resize(mint_len);\n    inv[1] = fac[0] = finv[0] = 1;\n    for (int i = tn; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    for (int i = tn; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n}\n//4e6 >= n なら O(r)で計算する\nmint com_big(int n, int r) {    int fa = finv[r];    rep(i, r)fa *= n - i, fa %= MOD;    return mint(fa);}\nmint com(int n, int r) {if (r < 0 || r > n) return 0;    /*nが大きくてrが小さい場合、nを上からr個掛ける*/    if (n >= sz(fac)) { if (n <= 4e6)setmod_resize(n + 1000); else return com_big(n, r); }return mint(finv[r] * fac[n] % MOD * finv[n - r]);}\nmint pom(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;return mint(fac[n] * finv[n - r]);}\nmint npr(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;return mint(fac[n] * finv[n - r]);}\nmint com_grid(int n, int r) {assert(r);return com(n + r - 2, n - 1);}\nint nprin(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;return fac[n] * finv[n - r] % MOD;}\nint icom(int n, int r) {    const int NUM_ = 1400001;    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];    if (fac[0] == 0) {        inv[1] = fac[0] = finv[0] = 1;        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;    }    if (r < 0 || r > n) return 0;    return ((finv[r] * fac[n] % MOD) * finv[n - r]) % MOD;}\n#define ncr com\n#define ncri icom\n//n種類でr個選ぶ\n//n個の場所にr個の物を置く\n//負が渡された場合もcomが処理出来る\nmint nhr(int n, int r) { if (n == 0 && r == 0)return 1; else return com(n + r - 1, r); }\n//n種類でそれぞれ少なくとも1つは選び、r個揃える\nmint nhr1(int n, int r) { return nhr(n, r - n); }\nmint hom(int n, int r) { if (n == 0 && r == 0)return 1; else return com(n + r - 1, r); }\nint nhri(int n, int r) { if (n == 0 && r == 0)return 1; else return icom(n + r - 1, r); }\n//グリッドで0-indexedの最短経路 pascal\nmint pas(int h, int w) { return com(h + w, w); }\ntemplate<typename T> T minv(T a, T m) {    T u = 0, v = 1;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T> T minv(T a) {    if (a < sz(fac)){        return inv[a];    }    T u = 0, v = 1;    T m = MOD;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\n//int型 mod m\ntemplate<typename T, typename U, typename V> int mpow(const T a, const U b, const V m) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U> modint<T> mpow(const modint<T> &a, const U &b) {    assert(b >= 0);    int x = a(), res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\n//-k乗出来る\ntemplate<typename T, typename U> mint mpow(const T a, const U b) {/*    assert(b >= 0);*/    if (b < 0) { return minv(mpow(a, -b)); }    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<class T> mint mpow(bint a, const T b) { return mpow((mint) a, b); }\ntemplate<typename T, typename U, typename V> int mpowi(const T &a, const U &b, const V &m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T> string to_string(const modint<T> &number) { return to_string(number()); }\n#ifdef _DEBUG\nvoid yuri(const mint &a) {    stringstream st;    rep(i, 300) {        rep(j, 300) {            if ((mint) i / j == a) {                st << i << \" / \" << j;                i = 2000;                break;            }        }    }    string val = st.str();    if (val != \"\") {        deb(val);        return;    }    rep(i, 1000) {        rep(j, 1000) {            if ((mint) i / j == a) {                st << i << \" / \" << j;                i = 2000;                break;            }        }    }    val = st.str();    deb(val);}\n#else\n#define yuri(...) ;\n#endif\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const modint<T> &number) {\n    stream << number();\n#ifdef _DEBUG\n//    stream << \" -> \" << yuri(number);\n#endif\n    return stream;\n}\n//@formatter:off\ntemplate<typename T> std::istream &operator>>(std::istream &stream, modint<T> &number) {    typename common_type<typename modint<T>::Type, int64_t>::type x;    stream >> x;    number.value = modint<T>::normalize(x);    return stream;}\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\nusing mapm = map<int, mint>;\nusing umapm = umap<int, mint>;\n#define vvm(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(mint,__VA_ARGS__)\n#define vnm(name, ...) auto name = make_v<mint>(__VA_ARGS__)\nstring out_m2(mint a) {    stringstream st;    st<<(int)a ;    rep(i, 300) {        rep(j, 2, 300) {            if ((i%j)&&(mint) i / j == a) {                st <<\"(\"<< i << \"/\" << j<<\")\";                i = 2000;                break;            }        }    }    return st.str();}\n//nhr n個の場所にr個の物を分ける\nmint m1 = (mint) 1;\nmint half = (mint) 1 / 2;\n//struct setmod{\n//    //comで長さが足りない場合はsetmod_resizeでリサイズする\n//    int mint_len =1.4*1e6;\n//    setmod() {\n//    //p2を使う場合setmod_resizeも変える\n////    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n//        fac.resize(mint_len);    finv.resize(mint_len);    inv.resize(mint_len);    inv[1] = fac[0] = finv[0] = 1;    for (int i = 2; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;    for (int i = 1; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n//}}setmodv;\ntemplate<signed S> using mint_ = modint<std::integral_constant<decay<signed>::type, S>>;\n#endif\n/*@formatter:on*/\n\nvoid solve() {\n    using Mint = mint;\n    int n;\n    cin >> n;\n    vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n    for (int r = 0; r < 3; r++) {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            --x; --y;\n            if (x > y) {\n                swap(x, y);\n            }\n            g[r][x].push_back(y);\n        }\n    }\n    Mint p = (long long) 1e18;\n    vector<Mint> pw(n);\n    pw[0] = p;\n    for (int i = 1; i < n; i++) {\n        pw[i] = pw[i - 1] * p;\n    }\n    const int MAX = 512;\n    vector<vector<Mint>> cnt(3, vector<Mint>(MAX));\n    for (int r = 0; r < 3; r++) {\n        vector<int> gr(n);\n        for (int i = n - 1; i >= 0; i--) {\n            set<int> s;\n            for (int j : g[r][i]) {\n                s.insert(gr[j]);\n            }\n            while (s.find(gr[i]) != s.end()) {\n                ++gr[i];\n            }\n            cnt[r][gr[i]] += pw[i];\n        }\n    }\n    Mint ans = 0;\n    for (int x = 0; x < MAX; x++) {\n        for (int y = 0; y < MAX; y++) {\n            ans += cnt[0][x] * cnt[1][y] * cnt[2][x ^ y];\n        }\n    }\n    cout << ans << '\\n';\n}\n\nauto my(ll n, vi &a) {\n    return 0;\n}\n\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n\n\n            break;\n        }\n    }\n    if (!bad) {\n        //solveを書き直す\n        //solveを呼び出す\n    }\n    if (was_deb && sz(res_mes)) {\n        cerr << \"result = \" << endl << res_mes << endl;\n    }\n    if (sz(message)) {\n        cerr << \"****************************\" << endl;\n        cerr << \"Note.\" << endl;\n        cerr << message << endl;\n        cerr << \"****************************\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100010, P = 998244353;\nint n, ans, cnt1[maxn], cnt2[maxn], cnt3[maxn];\nint mx, m, sg[maxn];\nvector<int> G[maxn];\n\nint qp(int x, int y) {\n    int z = 1;\n    for (; y; y >>= 1, x = 1LL * x * x % P) {\n        if (y & 1) z = 1LL * z * x % P;\n    }\n    return z;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    auto solve = [&](int *cnt) {\n        memset(sg, 0, sizeof(sg));\n        for (int i = 1; i <= n; i++) {\n            G[i].clear();\n        }\n        scanf(\"%d\", &m);\n        for (int i = 1, u, v; i <= m; i++) {\n            scanf(\"%d %d\", &u, &v);\n            G[min(u, v)].push_back(max(u, v));\n        }\n        for (int i = n; i; i--) {\n            unordered_set<int> S;\n            for (int j : G[i]) S.insert(sg[j]);\n            while (S.count(sg[i])) sg[i]++;\n            mx = max(mx, sg[i]);\n            (cnt[sg[i]] += qp(10, 18 * i)) %= P;\n        }\n    };\n    solve(cnt1), solve(cnt2), solve(cnt3);\n    for (int i = 0; i <= mx; i++) {\n        for (int j = 0; j <= mx; j++) {\n            ans = (ans + 1LL * cnt1[i] * cnt2[j] % P * cnt3[i ^ j]) % P;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nconst int MOD = 998244353;\nconst long long w = ((long long)1e18)%MOD;\nlong long wpow[101010];\n\npair<long long, long long> solve(vector<pair<int, int> > V)\n{\n    long long os = 0, ts = 0;\n    vector<vector<int> > conn(N+1);\n    vector<int> sidx(N+1);\n    for(auto [u, v]: V)\n    {\n        conn[u].push_back(v);\n        conn[v].push_back(u);\n    }\n    for(int i=N; i>=1; --i)\n    {\n        bool e1 = false, e2 = false;\n        for(auto x: conn[i])\n        {\n            if(sidx[x] == 1) e1 = true;\n            if(sidx[x] == 2) e2 = true;\n        }\n        if(!e1)\n        {\n            sidx[i] = 1;\n            os = os + wpow[i];\n            if(os>=MOD) os -= MOD;\n        }\n        else if(!e2)\n        {\n            sidx[i] = 2;\n            ts = ts + wpow[i];\n            if(ts>=MOD) ts -= MOD;\n        }\n        else sidx[i] = 0;\n    }\n    return make_pair(os, ts);\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    wpow[0] = 1;\n    for(int i=1; i<=N; ++i)\n        wpow[i] = wpow[i-1]*w%MOD;\n    vector<pair<long long, long long> > Q;\n    for(int i=0; i<3; ++i)\n    {\n        vector<pair<int, int> > V;\n        int M; scanf(\"%d\", &M);\n        for(int j=0; j<M; ++j)\n        {\n            int u, v; scanf(\"%d%d\", &u, &v);\n            V.emplace_back(u, v);\n        }\n        Q.push_back(solve(V));\n    }\n    long long ans = 0;\n    auto [u1, u2] = Q[0];\n    auto [v1, v2] = Q[1];\n    auto [w1, w2] = Q[2];\n    ans += u1*v1%MOD*w1%MOD;\n    ans += u1*v2%MOD*w2%MOD;\n    ans += u2*v2%MOD*w1%MOD;\n    ans += u2*v1%MOD*w2%MOD;\n    ans %= MOD;\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nint M[3];\nvi G[3][MAX_N];\nint grundy[3][MAX_N];\nll E[3][2010];\nll pw10[MAX_N];\n\nvoid solve() {\n\tcin >> N;\n\trep(q, 0, 3) {\n\t\tcin >> M[q];\n\t\trep(i, 0, M[q]) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; a--; b--;\n\t\t\tG[q][a].pb(b);\n\t\t\tG[q][b].pb(a);\n\t\t}\n\t}\n\tpw10[0] = pw10[1] = 1;\n\trep(_, 0, 18) MUL(pw10[1], 10);\n\trep(i, 1, N) pw10[i + 1] = pw10[i] * pw10[1] % mod;\n\trep(q, 0, 3) {\n\t\trer(i, N, 0) {\n\t\t\tset<int> S;\n\t\t\trep(j, 0, sz(G[q][i])) {\n\t\t\t\tint n = G[q][i][j];\n\t\t\t\tif(n > i) {\n\t\t\t\t\t// debug(q, i, n, grundy[q][n]);\n\t\t\t\t\tS.insert(grundy[q][n]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!S.empty() && grundy[q][i] == *S.begin()) {\n\t\t\t\tgrundy[q][i]++;\n\t\t\t\tS.erase(S.begin());\n\t\t\t}\n\t\t\t// debug(q, i, grundy[q][i]);\n\t\t\tADD(E[q][grundy[q][i]], pw10[i + 1]);\n\t\t}\n\t}\n\tll res = 0;\n\trep(i, 0, 1024) {\n\t\trep(j, 0, 1024) {\n\t\t\tADD(res, E[0][i] * E[1][j] % mod * E[2][i ^ j] % mod);\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000 + 10;\nconst int mod = 998244353;\nll qpow(ll n,ll k){\n    ll res = 1;\n    while(k){\n        if(k&1) res = res * n % mod;\n        n = n * n % mod;\n        k >>= 1;\n    }\n    return res;\n}\nvoid add(ll &x,ll y){\n    (x += y) %= mod;\n}\nvoid brute(){\n    vector<int> e[10][10];\n    int n; cin>>n;\n    for(int i=1;i<=3;i++){\n        int m; cin>>m;\n        while(m--){\n            int u,v; cin>>u>>v;\n            e[i][u].push_back(v);\n            e[i][v].push_back(u);\n        }\n    }\n    ll ans = 0;\n    int vis[n+1][n+1][n+1] = {0};\n    for(int sum=3*n;sum>=3;sum--){\n        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) for(int k=1;k<=n;k++) if((i+j+k)==sum&&!vis[i][j][k]){\n            cout<<i<<' '<<j<<' '<<k<<endl;\n            add(ans,qpow(10,18*(i+j+k)));\n            for(int x: e[1][i]) if(x<i) vis[x][j][k] = 1;\n            for(int x: e[2][j]) if(x<j) vis[i][x][k] = 1;\n            for(int x: e[3][k]) if(x<k) vis[i][j][x] = 1;\n        }\n    }\n    cout<<ans<<endl;\n}\nll c[3][2];\nvector<int> g[N];\nint vis[N];\nint main(){\n//    brute();\n    int n; scanf(\"%d\",&n);\n    for(int x=0;x<3;x++){\n        int m; scanf(\"%d\",&m);\n        for(int i=1;i<=n;i++) g[i].clear(), vis[i] = 0;\n        while(m--){\n            int u,v; scanf(\"%d%d\",&u,&v);\n            g[u].push_back(v), g[v].push_back(u);\n        }\n        for(int i=n;i>=1;i--){\n            if(!vis[i]){\n                int mx = 0;\n                for(int j: g[i]) if(j<i) vis[j] = 1, mx = max(mx,j);\n                add(c[x][1],qpow(10,18*i));\n                if(mx) add(c[x][0],qpow(10,18*mx));\n            }\n        }\n//        for(int i=1;i<=n;i++) cout<<!vis[i]<<' '; cout<<endl;\n    }\n    ll ans = 0;\n    for(int i=0;i<2;i++) for(int j=0;j<2;j++) for(int k=0;k<2;k++) if((i+j+k)%2){\n        add(ans,c[0][i]*c[1][j]%mod*c[2][k]%mod);\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define maxn 100005 /*rem*/\n#define mod 998244353\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\nusing namespace std;\nint n;\nll qs = 1; \nll pw[maxn];\nint fl[maxn];\nvi eg[maxn];\nint main() {\n\tfor (int i = 0; i < 18; i++) qs *= 10;\n\tqs %= mod;\n\tpw[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tpw[i] = pw[i - 1] * qs % mod;\n\tint n;\n\tcin >> n;\n\tll mt = 1;\n\tll c[3][3];\n\tmemset(c, 0, sizeof(c));\n\tfor (int s = 0; s < 3; s++) {\n\t\tint m;\n\t\tcin >> m;\n\t\tfor (int i = 1; i <= n; i++) eg[i].clear();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\teg[u].pb(v), eg[v].pb(u);\n\t\t}\n\t\tmemset(fl, 0, sizeof(fl));\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfor (int j = n; j >= 1; j--) {\n\t\t\t\tif (fl[j]) continue;\n\t\t\t\telse {\n\t\t\t\t\tc[s][i] = (c[s][i] + pw[j]) % mod;\n\t\t\t\t\tfl[j] = 100;\n\t\t\t\t\tfor (auto v : eg[j])\n\t\t\t\t\t\tif (!fl[v]) fl[v] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\tfl[j] = max(fl[j], 0);\n\t\t}\n\t//\tcout << c[i]\n\t}\n\tll ans = c[0][0] * c[1][0] % mod * c[2][0] % mod;\n\tfor (int i = 0; i < 3; i++) {\n\t\tint u = (i + 1) % 3, v = (i + 2) % 3;\n\t\tll cur = c[i][0] * ((c[u][1] * c[v][1] + c[u][2] * c[v][2]) % mod) % mod;\n\t\tans = (ans + cur) % mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  vvi g[3];\n  cin >> n;\n  ll res = 0, all = 0;\n  vl pw(n + 1, 1);\n  ll r0 = 1000000000000000000LL % mod;\n  for (int i = 1; i < pw.size(); ++i) pw[i] = pw[i-1] * r0 % mod;\n  for (int i = 0; i < n; ++i) all = (all + pw[i + 1]) % mod;\n  ll prod = 1, sum = 0;\n  vl x[3];\n  for (int t = 0; t < 3; ++t) {\n    int m;\n    cin >> m;\n    g[t].resize(n);\n    for (int i = 0; i < m; ++i) {\n      int a, b;\n      cin >> a >> b;\n      --a; --b;\n      g[t][a].push_back(b);\n      g[t][b].push_back(a);\n    }\n    ll s = 0;\n    vi was(n);\n    for (int i = n-1; i >= 0; --i) if (!was[i]) {\n      s += pw[i + 1];\n      for (int j : g[t][i]) was[j] = 1;\n    }\n    s %= mod;\n//    sum = (sum + s) % mod;\n    prod = prod * s % mod;\n    x[t].push_back(s);\n    set<int> rem;\n    for (int i = 0; i < n; ++i) if (was[i]) rem.insert(i);\n    while (!rem.empty()) {\n      set<int> nrem;\n      ll s = 0;\n      while (!rem.empty()) {\n        auto it = rem.end(); --it;\n        int v = *it;\n        s += pw[v + 1];\n        for (int x : g[t][v]) if (rem.count(x)) {\n          rem.erase(x);\n          nrem.insert(x);\n        }\n        rem.erase(v);\n      }\n      x[t].push_back(s % mod);\n      rem.swap(nrem);\n    }\n  }\n  res = prod;\n  for (int t = 0; t < 3; ++t) {\n    int t1 = (t + 1) % 3, t2 = (t + 2) % 3;\n    for (int i = 1; i < min(x[t1].size(), x[t2].size()); ++i) {\n      res = (res + x[t][0] * x[t1][i] % mod * x[t2][i]) % mod;\n    }\n    for (int i = 1; i < x[t].size(); i += 3) {\n      if (i + 1 < x[t1].size() && i + 2 < x[t2].size()) res = (res + x[t][i] * x[t1][i + 1] % mod * x[t2][i + 2]) % mod;\n      if (i + 2 < x[t1].size() && i + 1 < x[t2].size()) res = (res + x[t][i] * x[t1][i + 2] % mod * x[t2][i + 1]) % mod;\n    }\n  }\n  cout << (res % mod + mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nstruct edge {\n    ll to, cost;\n};\n\n// vector<edge> Ga[200000], Gb[200000], Gc[200000];\nVV<edge> Ga(200000), Gb(200000), Gc(200000);\nVV<ll> grundy(3, V<ll>(200000, 0));\nV<bool> da0(200000, 0), db0(200000, 0), dc0(200000, 0);\nbool da1[200000], db1[200000], dc1[200000];\n\nvoid addedge(VV<edge>& G, int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\nll N;\nvoid setvalue() {\n    VV<edge> G[3] = {Ga, Gb, Gc};\n    REP(p, 0, 3) {\n        V<ll> used(N, -1);\n        PER(i, N - 1, -1) {\n            REP(j, 0, G[p][i].size()) {\n                edge e = G[p][i][j];\n                used[grundy[p][e.to]] = i;\n            }\n            while (used[grundy[p][i]] == i) {\n                grundy[p][i]++;\n            }\n        }\n    }\n}\n\nll ten[2000000];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    ten[0] = 1;\n    REP(i, 1, 2000000) {\n        ten[i] = multiply(ten[i - 1], 10);\n    }\n    ll M1, M2, M3;\n    cin >> M1;\n    REP(i, 0, M1) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        if (a > b) {\n            swap(a, b);\n        }\n        addedge(Ga, a, b, 0);\n    }\n    cin >> M2;\n    REP(i, 0, M2) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        if (a > b) {\n            swap(a, b);\n        }\n        addedge(Gb, a, b, 0);\n    }\n    cin >> M3;\n    REP(i, 0, M3) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        if (a > b) {\n            swap(a, b);\n        }\n        addedge(Gc, a, b, 0);\n    }\n    // cout << \"aaa\" << endl;\n    setvalue();\n    // cout << \"bbb\" << endl;\n    VV<ll> sum(3);\n    REP(p, 0, 3) {\n        REP(i, 0, N) {\n            while ((ll)sum[p].size() <= grundy[p][i]) {\n                sum[p].push_back(0);\n            }\n            sum[p][grundy[p][i]] = modadd(sum[p][grundy[p][i]], ten[18 * (i + 1)]);\n        }\n    }\n    // ll azero = 0, bzero = 0, czero = 0;\n    // ll aone = 0, bone = 0, cone = 0;\n    // REP(i, 0, N) {\n    //     if (da0[i] == false) {\n    //         azero = modadd(azero, ten[18 * (i + 1)]);\n    //     } else if (da1[i] == false) {\n    //         aone = modadd(aone, ten[18 * (i + 1)]);\n    //     }\n    //     if (db0[i] == false) {\n    //         bzero = modadd(bzero, ten[18 * (i + 1)]);\n    //     } else if (db1[i] == false) {\n    //         bone = modadd(bone, ten[18 * (i + 1)]);\n    //     }\n    //     if (dc0[i] == false) {\n    //         czero = modadd(czero, ten[18 * (i + 1)]);\n    //     } else if (dc1[i] == false) {\n    //         cone = modadd(cone, ten[18 * (i + 1)]);\n    //     }\n    // }\n    ll ans = 0;\n    REP(i, 0, sum[0].size()) {\n        REP(j, 0, sum[1].size()) {\n            ll k = i ^ j;\n            if (k < (ll)sum[2].size()) {\n                ans = modadd(ans, multiply(sum[0][i], multiply(sum[1][j], sum[2][k])));\n            }\n        }\n    }\n    // REP(p, 0, 3) {\n    //     REP(i, 0, N) {\n    //         cout << grundy[p][i] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // cout << \"aaa\" << endl;\n    // REP(p, 0, 3) {\n    //     REP(i, 0, sum[p].size()) {\n    //         cout << sum[p][i] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // ans = modadd(ans, multiply(azero, multiply(bzero, czero)));\n    // ans = modadd(ans, multiply(aone, multiply(bone, czero)));\n    // ans = modadd(ans, multiply(aone, multiply(bzero, cone)));\n    // ans = modadd(ans, multiply(azero, multiply(bone, cone)));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\n#define P 998244353\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nll perm(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (fac[n]*finv[n-k])%P;\n}\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\n\ntypedef vector<vector<ll>> graph;\nll n;\n\nstruct Merge{\n  set<vll> lr;\n  ll INF = 1000000000000000009;\n  vll remove(ll a, ll b){\n    if(a>b) swap(a, b);\n    auto itr = lr.lower_bound(vll{b+1, 0});\n    if(itr==lr.begin()) return vll{a, b};\n    itr--;\n    ll lef = a, ri = b;\n    while((*itr)[1]>=a){\n      ll now_x = (*itr)[0], now_y = (*itr)[1];\n      lef = min(lef, now_x), ri = max(ri, now_y);\n      if(itr==lr.begin()){\n        lr.erase(itr);\n        break;\n      }\n      itr--;\n      lr.erase(vll{now_x, now_y});\n    }\n    return vll{lef, ri};\n  }\n  void merge(ll a, ll b){lr.insert(remove(a, b));}\n\n  vll get(ll a){\n    auto itr = lr.lower_bound(vll{a+1, a+1});\n    if(lr.size()==0||itr==lr.begin()) return vll{INF, INF};\n    itr--;\n    if((*itr)[1]<a) return vll{INF, INF};\n    return *itr;\n  }\n  bool same(ll a, ll b){\n    if(get(a)[0]==-1) return false;\n    return get(a)[0]==get(b)[0];\n  }\n};\n\nvvl get(graph g){\n  //なるべく大きい要素を取る独立集合\n  //現在とったものに隣接していない最大の要素を貪欲に取っていく\n  vvl dat;\n  vll go(n+1, 10000000);\n\n  for(int i=n;i>0;i--){\n    Merge mg;\n    for(auto to:g[i]){\n      if(to<i) continue;\n      mg.merge(go[to], go[to]+1);\n    }\n    auto itr = mg.lr.begin();\n    if(mg.lr.size()==0||(*itr)[0]!=0) go[i] = 0;\n    else go[i] = (*itr)[1];\n\n    if(dat.size()<=go[i]) dat.push_back(vll());\n    dat[go[i]].push_back(i);\n  }\n  return dat;\n}\n\nvector<ll> cost(400000, 1);\n\n\n//独立集合の重み\nll get_cost(vll v){\n  ll ret = 0;\n  for(int i=0;i<v.size();i++) ret = (ret + cost[v[i]])%P;\n  return ret;\n}\n\nint main(int argc, char const *argv[]) {\n  init();\n  ll x = 1000000000000000000LL%P;\n  for(int i=1;i<400000;i++) cost[i] = (cost[i-1] * x)%P;\n  std::cin >> n;\n  ll lm = 10000;\n  vvl gr = VV(3, lm, 0, ll);\n\n  for(int i=0;i<3;i++){\n    ll m;std::cin >> m;\n    graph g(n+1);\n    for(int j=0;j<m;j++){\n      ll a, b;scanf(\"%lld %lld\", &a, &b);\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n    vvl X = get(g);\n    for(int j=0;j<min((ll)X.size(), lm);j++){\n      for(auto v:X[j]) gr[i][j] = (gr[i][j] + cost[v])%P;\n    }\n  }\n\n  ll ans = 0;\n  for(int i=0;i<lm;i++){\n    for(int j=0;j<lm;j++){\n      ll xo = i^j;\n      if(xo >= lm) continue;\n      ans = (ans + pp(gr[0][i], pp(gr[1][j], gr[2][xo])))%P;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n2020.03.21\n\n考虑一个暴力的贪心做法，从大到小枚举 S = x + y + z ，\n然后对于所有 (x, y, z) ，如果之前没有与之连边的点被选，那么这个点一定要出现在最优解中。\n可以给边定向，边从小连到大，那么整个图就是 DAG ，在 DAG 中抽象这个贪心：\n每次选择一个点满足其到的点都没有被选，然后删掉选择它加入最优解集合。\n那么一个点被选当且仅当其到的点都没被选，一个点没被选当且仅当其到的点存在被选的点（或没有出度）。\n这可以对应到博弈中的必胜必败态，这个 DAG 可以看做博弈转移图，答案就是求所有必败态的权值和。\n\n然而点数很大。\n考虑对于一个 (x, y, z) ，如何快速求出其必胜必败态，\n每次移动只能移动一维，这个博弈三维独立，就相当于每个维度有一个子游戏。\n对于每一维求出 SG 值 f[x], g[y], h[z] ，三者异或和就是这个的 SG 值。\n考虑计数，FWT 做异或卷积即可（事实上也可以三维暴力枚举 SG 值，SG 值的上界是 O(sqrt(M)) 的）。\n#endif\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n} read;\n\nconst int maxn = 200005, mod = 998244353;\nstd::vector<int> G[maxn];\nint sg[3][maxn];\nll f[3][maxn], g[maxn];\nll po[maxn * 3];\n\nvoid FWT (ll *a, int n) {\n\tfor (int m = 1; m < n; m <<= 1)\n\t\tfor (int i = 0; i < n; i += m << 1)\n\t\t\tfor (int k = i; k < i + m; k ++) {\n\t\t\tll x = a[k], y = a[k + m];\n\t\t\t(a[k] = x + y) %= mod;\n\t\t\t(a[k + m] = x + mod - y) %= mod;\n\t\t}\n}\n\nvoid iFWT (ll *a, int n) {\n\tFWT(a, n);\n\tll inv = mod - (mod - 1) / n;\n\tfor (int i = 0; i < n; i ++)\n\t\t(a[i] *= inv) %= mod;\n}\n\nint main () {\n\tint n = read, len = 1;\n\twhile (len < n)\n\t\tlen <<= 1;\n\n\tpo[0] = 1;\n\tll bs = 1000000000000000000ll % mod;\n\tfor (int i = 1; i <= n * 3; i ++)\n\t\tpo[i] = po[i - 1] * bs % mod;\n\n\tfor (int o = 0; o < 3; o ++) {\n\t\tint m = read;\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tG[i].clear();\n\t\tfor (int i = 1; i <= m; i ++) {\n\t\t\tint u = read, v = read;\n\t\t\tif (u < v) G[u].push_back(v);\n\t\t\tif (v < u) G[v].push_back(u);\n\t\t}\n\t\tfor (int i = n; i; i --) {\n\t\t\tstd::set<int> mex;\n\t\t\tfor (int j : G[i])\n\t\t\t\tmex.insert(sg[o][j]);\n\t\t\twhile (mex.count(sg[o][i]))\n\t\t\t\t++ sg[o][i];\n\t\t}\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\t(f[o][sg[o][i]] += po[i]) %= mod;\n\t\t/* FWT(f[o], len); */\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i < 500; i ++)\n\t\tfor (int j = 0; j < 500; j ++)\n\t\t\t(ans += f[0][i] * f[1][j] % mod * f[2][i ^ j]) %= mod;\n\tprintf(\"%lld\\n\", ans);\n\n/* \tfor (int i = 0; i < len; i ++) */\n/* \t\tg[i] = f[0][i] * f[1][i] % mod * f[2][i] % mod; */\n/* \tiFWT(g, len); */\n\n/* \tprintf(\"%lld\\n\", g[0]); */\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n\tnum B = pow(num(10), 18);\n\n\tint n;\n\tcin >> n;\n\n\tvector<num> powB(n+1, 0);\n\tpowB[0] = 1;\n\tfor(int i = 1; i <= n; i++) powB[i] = B * powB[i-1];\n\tvector<num> dp = {1, 0};\n\tfor(int _ = 0; _ < 3; _++){\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<vector<int> > edges(n);\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif(a < b) swap(a, b);\n\t\t\tedges[a].push_back(b);\n\t\t}\n\t\tvector<bool> ok1(n, true);\n\t\tvector<bool> ok2(n, true);\n\t\tnum ans1 = 0;\n\t\tnum ans2 = 0;\n\t\tfor(int v = n-1; v >= 0; v--){\n\t\t\tif(ok1[v]){\n\t\t\t\tok2[v] = false;\n\t\t\t\tfor(int w : edges[v]) ok1[w] = false;\n\t\t\t\tans1 += powB[v+1];\n\t\t\t} else if(ok2[v]){\n\t\t\t\tfor(int w : edges[v]) ok2[w] = false;\n\t\t\t\tans2 += powB[v+1];\n\t\t\t}\n\t\t}\n\t\tnum new0 = dp[0] * ans1 + dp[1] * ans2;\n\t\tnum new1 = dp[0] * ans2 + dp[1] * ans1;\n\t\tdp = {new0, new1};\n\t}\n\tcout << dp[0] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define P 998244353\n#define B ((ll)1e18%P)\n#define MAX 500005\nusing namespace std;\n\nint n, m, cnt, id;\nint head[MAX], vet[MAX], Next[MAX], sg[3][MAX];\nll p[MAX], f[3][MAX];\n\nvoid add(int x, int y){\n    cnt++;\n    Next[cnt] = head[x];\n    head[x] = cnt;\n    vet[cnt] = y;\n}\n\nint dfs(int x){\n    if(sg[id][x] != -1) return sg[id][x];\n    sg[id][x] = 0;\n    map<int, bool> mp;\n    for(int i = head[x]; i; i = Next[i]){\n        int v = vet[i];\n        mp[dfs(v)] = true;\n    }\n    while(mp[sg[id][x]]) sg[id][x]++;\n    return sg[id][x];\n}\n\nint main()\n{\n    cin >> n;\n    p[0] = 1;\n    for(int i = 1; i < MAX; i++){\n        p[i] = p[i-1]*B%P;\n    }\n    memset(sg, -1, sizeof(sg));\n    for(id = 0; id < 3; id++){\n        memset(head, 0, sizeof(head));\n        cnt = 0;\n        cin >> m;\n        int x, y;\n        for(int i = 1; i <= m; i++){\n            scanf(\"%d%d\", &x, &y);\n            if(x > y) swap(x, y);\n            add(x, y);\n        }\n        for(int i = 1; i <= n; i++){\n            if(sg[id][i] == -1) dfs(i);\n        }\n        for(int i = 1; i <= n; i++){\n            (f[id][sg[id][i]] += p[i]) %= P;\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i < 500; i++){\n        for(int j = 0; j < 500; j++){\n            ans = (ans + f[0][i]*f[1][j]%P*f[2][i^j]%P)%P;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\n#define x first\n#define y second\n#define pb push_back\n#define eb emplace_back\n#define rep(i,a,b) for(auto i=(a); i<(b); ++i)\n#define REP(i,n) rep(i,0,n)\n#define all(v) (v).begin(), (v).end()\n#define rs resize\n#define DBG(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n\nconst ld PI = acos(-1.0);\ntemplate<class T> using min_queue =\npriority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> int sz(const T &x) {\n    return (int) x.size(); // copy the ampersand(&)!\n}\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> &v) {\n    os << \"\\n[\";\n    for(T &x : v) os << x << ',';\n    return os << \"]\\n\";\n}\n\nstruct pairhash {\n    public:\n    template<typename T1, typename T2>\n    size_t operator()(const pair<T1, T2> &p) const {\n        size_t lhs = hash<T1>()(p.x);\n        size_t rhs = hash<T2>()(p.y);\n        return lhs ^ (rhs+0x9e3779b9+(lhs<<6)+(lhs>>2));\n    }\n};\n\nconst ll MOD = 998244353;\nconst ll BASE = 1000000000000000000%MOD;\n\n//vector<vvi> adj;\nvvi nim;\n\nvoid run() {\n\tll N;\n\tcin >> N;\n\n\tll maxNim = 0;\n\tfor (ll i = 0; i < 3; i++) {\n\t\tvvi adj(N);\n\t\tnim.pb(vi(N, 0));\n\t\tll M;\n\t\tcin >> M;\n\t\tfor (ll j = 0; j < M; j++) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif (a > b) swap(a, b);\n\t\t\tadj[a].pb(b);\n\t\t}\n\n\t\tfor (ll j = N-1; j >= 0; j--) {\n\t\t\tvector<bool> U(adj[j].size()+2, false);\n\t\t\tfor (ll k : adj[j]) {\n\t\t\t\tif (nim[i][k] < U.size()) U[nim[i][k]] = true;\n\t\t\t}\n\t\t\tfor (ll k = 0; k < U.size(); k++) {\n\t\t\t\tif (!U[k]) {\n\t\t\t\t\t//cout << j << \": \" << k << endl;\n\t\t\t\t\tnim[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxNim = max(maxNim, nim[i][j]+1);\n\t\t}\n\t}\n\n\tvvi nimScore(3, vi(maxNim, 0));\n\tfor (ll i = 0; i < 3; i++) {\n\t\tll p = 1;\n\t\tfor (ll j = 0; j < N; j++) {\n\t\t\tp *= BASE;\n\t\t\tp %= MOD;\n\t\t\tnimScore[i][nim[i][j]] += p;\n\t\t\tnimScore[i][nim[i][j]] %= MOD;\n\t\t}\n\t}\n\t\n\tll res = 0;\n\tfor (ll i1 = 0; i1 < maxNim; i1++) {\n\t\tfor (ll i2 = 0; i2 < maxNim; i2++) {\n\t\t\tif ((i1^i2) < maxNim && (i1^i2) >= 0) {\n\t\t\t\tres += (nimScore[0][i1]*nimScore[1][i2])%MOD*nimScore[2][i1^i2];\n\t\t\t\tres %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << maxNim << endl;\n\tcout << res << endl;\n\t//cout << nimScore[0][0] << \", \" << nimScore[1][0] << \", \" << nimScore[2][0] << endl;\n}\n\nsigned main() {\n    // DON'T MIX \"scanf\" and \"cin\"!\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << fixed << setprecision(20);\n    run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=100005;\nconst int mod=998244353;\nnamespace {\n    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}\n    inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}\n    inline int Mul(int x,int y) {return 1ll*x*y%mod;}\n    inline int Pow(int x,int y=mod-2){if(y==0)return 1;int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}\n}\nint n,m;\nvector<int> G[max_n];\nvector<int> solve(vector<int> a,vector<int> b){\n    vector<int> c;\n    c.assign(1024,0);\n    for(int i=0;i<1024;i++){\n        for(int j=0;j<1024;j++)c[i^j]=Add(c[i^j],Mul(a[i],b[j]));\n    }\n    return c;\n}\nint p[max_n];\nint sg[max_n];\nint SG(int u){\n    if(~sg[u])return sg[u];\n    set<int> s;\n    for(auto v:G[u]){\n        if(v>u)s.insert(SG(v));\n    }\n    for(int i=0;;i++)if(s.count(i)==0)return sg[u]=i;\n}\nint main(){\n    p[0]=1,p[1]=Pow(10,18);\n    for(int i=2;i<1024;i++)p[i]=Mul(p[i-1],p[1]);\n    scanf(\"%d\",&n);\n    vector<int> f;f.assign(1024,0);f[0]=1;\n    vector<int> a;\n    scanf(\"%d\",&m);\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    //for(int i=n;i>=1;i--)\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    printf(\"%d\\n\",f[0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 3;\nconst int mod = 998244353;\n\nint n, m[4];\nvector <int> adj[4][maxn];\nvoid read()\n{\n    cin >> n;\n    for (int i = 1; i <= 3; i++)\n    {\n        cin >> m[i];\n        for (int j = 1; j <= m[i]; j++)\n        {\n            int a, b;\n            cin >> a >> b;\n\n            adj[i][a].push_back(b);\n            adj[i][b].push_back(a);\n        }\n    }\n}\n\nlong long add(long long a, long long b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n\n    return a;\n}\n\nlong long st[maxn*2];\nint gr[4][maxn];\nmap <int, long long> mp[4];\nvoid solve()\n{\n    st[0] = 1;\n    for (int i = 1; i <= 2 * n; i++)\n        st[i] = st[i-1] * 1000000000 % mod;\n\n    for (int i = 1; i <= 3; i++)\n    {\n        mp[i][0] = add(mp[i][0], st[n*2]);\n        for (int j = n-1; j >= 1; j--)\n        {\n            set <int> s;\n            for (auto k: adj[i][j])\n                if (k > j)\n                s.insert(gr[i][k]);\n\n            while (s.find(gr[i][j]) != s.end())\n                gr[i][j]++;\n\n            mp[i][gr[i][j]] = add(mp[i][gr[i][j]], st[j*2]);\n        }\n    }\n\n    int p = sqrt(max({m[1], m[2], m[3]})) + 10;\n    long long ans = 0;\n    for (int i = 0; i <= p; i++)\n        if (mp[1].count(i))\n        for (int j = 0; j <= p; j++)\n        if (mp[2].count(j))\n            ans = add(ans, mp[1][i] * mp[2][j] % mod * mp[3][i^j] % mod);\n\n    cout << ans << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    read();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nstruct modint{\n    using i64=int_fast64_t;\n    i64 a;\n    static constexpr i64 MOD=998244353;\n    modint(){a=0;}\n    modint(i64 a_){\n        a=a_%MOD;\n        if(a<0) a+=MOD;\n    }\n    modint inv()const{\n        i64 n=1,m=MOD-2,A=a;\n        while(m){\n            if(m&1)(n*=A)%=MOD;\n            (A*=A)%=MOD;\n            m>>=1;\n        }\n        modint y;\n        y.a=n;\n        return y;\n    }\n    bool operator==(const modint& x){\n        return a==x.a;\n    }\n    bool operator!=(const modint& x){\n        return a!=x.a;\n    }\n    modint& operator=(const modint& x){\n        a=x.a;\n        return *this;\n    }\n    modint operator+(const modint& x){\n        modint y;\n        y.a=a+x.a;\n        if(y.a>=MOD) y.a-=MOD;\n        return y;\n    }\n    modint operator-(const modint& x){\n        modint y;\n        y.a=a-x.a;\n        if(y.a<0) y.a+=MOD;\n        return y;\n    }\n    modint operator*(const modint& x){\n        modint y;\n        y.a=(a*x.a)%MOD;\n        return y;\n    }\n    modint operator/(const modint& x){\n        modint y;\n        y.a=(a*x.inv().a)%MOD;\n        return y;\n    }\n    modint& operator+=(const modint& x){\n        a+=x.a;\n        if(a>=MOD) a-=MOD;\n        return *this;\n    }\n    modint& operator-=(const modint& x){\n        a-=x.a;\n        if(a<0) a+=MOD;\n        return *this;\n    }\n    modint& operator*=(const modint& x){\n        (a*=x.a)%=MOD;\n        return *this;\n    }\n    modint& operator/=(const modint& x){\n        (a*=x.inv().a)%=MOD;\n        return *this;\n    }\n};\nistream& operator>>(istream &in,modint& x){\n    int_fast64_t a_;\n    in>>a_;\n    modint y(a_);\n    x=y;\n    return in;\n}\nostream& operator<<(ostream &out,const modint& x){\n    out<<x.a;\n    return out;\n}\nmodint pwr(int_fast64_t a,int_fast64_t b){\n    modint _;\n    int_fast64_t n=1,A=a;\n    while(b){\n        if(b&1) (n*=A)%=modint::MOD;\n        (A*=A)%=modint::MOD;\n        b>>=1;\n    }\n    _.a=n;\n    return _;\n}\n\nvector<modint> p;\n\nvector<modint> solve(int n){\n    int m,a,b;\n    vector<vector<int>> e(n);\n    cin>>m;\n    fr(i,m){\n        cin>>a>>b;\n        if(a>b) swap(a,b);\n        e[a-1].emplace_back(b-1);\n    }\n    vector<int> v(n);\n    vector<modint> c;\n    vector<bool> q(n+1);\n    ifr(i,n){\n        fr(j,e[i].size()+1) q[j]=false;\n        for(auto&j:e[i]) q[v[j]]=true;\n        fr(j,e[i].size()+1) if(!q[j]){\n            if(c.size()==j) c.emplace_back();\n            c[v[i]=j]+=p[i+1];\n            break;\n        }\n    }\n    return c;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    istream& in(cin);\n    ostream& out(cout);\n    int n;\n    in>>n;\n    p.resize(n+1);\n    modint e18=pwr(10,18);\n    p[0]=1;\n    fr(i,n) p[i+1]=p[i]*e18;\n    auto c0=solve(n),c1=solve(n),c2=solve(n);\n    modint ans;\n    fr(i,c0.size()) fr(j,c1.size()) if((i^j)<c2.size()){\n        ans+=c0[i]*c1[j]*c2[i^j];\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nint me(vi &v)\n{\n\tsort(v.begin(), v.end());\n\tv.pb(9999999);\n\tif (v[0] > 0)return 0;\n\tfor (int i = 0; i < v.size(); i++)\n\t\tif (v[i + 1] - v[i] > 1)return v[i] + 1;\n}\nvector<int>gran(const vii &gr)\n{\n\tvi grn(gr.size());\n\tint n = gr.size();\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tvi v;\n\t\tfor (int j = 0; j < gr[i].size(); j++)v.pb(grn[gr[i][j]]);\n\t\tgrn[i] = me(v);\n\t}\n\tvi sums(1<<10);\n\tint md = bp(10, 18), cur = md;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tsums[grn[i]] = add(sums[grn[i]], cur);\n\t\tcur = mlt(cur, md);\n\t}\n\treturn sums;\n}\nvi grr(int n)\n{\n\tvii gr(n);\n\tint m;\n\tcin >> m;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint a, b;\n\t\tcin >>a >> b;\n\t\tif (a > b) gr[b - 1].pb(a - 1);\n\t\telse gr[a - 1].pb(b - 1);\n\t}\n\treturn gran(gr);\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint n, an=0;\n\tcin >> n;\n\tvi v1 = grr(n), v3 = grr(n), v4 = grr(n);\n\tfor (int i = 0; i < v1.size(); i++)\n\t\tfor (int j = 0; j < v3.size(); j++)\n\t\t\tan = add(an, mlt(v1[i], mlt(v3[j], v4[i^j])));\n\tcout << an << endl;\n\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\n\nusing D = mint;\nvoid transform(vector<D> &a, int l, int n) {\n\tif (n == 1) return;\n\tint m = l + n / 2;\n\ttransform(a, l, n / 2);\n\ttransform(a, m, n / 2);\n\tfor (int i = 0; i < n / 2; i++) {\n\t\tD x = a[l + i], y = a[m + i];\n\t\ta[l + i] = x + y;\n\t\ta[m + i] = x - y;\n\t}\n}\n\nvoid transform(vector<D> &a) {\t//size must be power of 2\n\ttransform(a, 0, a.size());\n}\nvector<D> conv(vector<D> a,vector<D> b){\n\tassert(a.size()==b.size());\n\tint N = a.size();\n\ttransform(a);\n\ttransform(b);\n\tvector<D> c(N);\n\trep(i,N) c[i] = a[i]*b[i];\n\ttransform(c);\n\trep(i,N) c[i]/=N;\n\treturn c;\n}\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tint N; cin >> N;\n\tV<mint> a(1<<17);a[0] = 1;\n\tmint B = TEN(18);\n\trep(t,3){\n\t\tint M; cin >> M;\n\t\tVV<int> G(N);\n\t\trep(i,M){\n\t\t\tint x,y; cin >> x >> y; x--,y--;\n\t\t\tG[x].pb(y);G[y].pb(x);\n\t\t}\n\t\tset<int,greater<int>> alive; rep(i,N) alive.insert(i);\n\t\tset<int> ban;\n\t\tV<mint> b(1<<17);\n\t\tint idx=0;\n\t\twhile(!alive.empty()){\n\t\t\tdump(alive);\n\t\t\tfor(auto it = alive.begin();it != alive.end();){\n\t\t\t\tif(ban.count(*it)){\n\t\t\t\t\tit++;\n\t\t\t\t}else{\n\t\t\t\t\tint v = *it;\n\t\t\t\t\tit = alive.erase(it);\n\t\t\t\t\tb[idx] += B.pow(v+1);\n\t\t\t\t\tfor(int u: G[v]) ban.insert(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t\tban.clear();\n\t\t}\n\t\ta = conv(a,b);\n\t}\n\tcout << a[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define re register\n#define LL long long\n#define MOD 998244353\n#define MAXN 100005\nusing namespace std;\nLL n,ans,bs[3*MAXN];\nLL rd(){\n\tLL x=0,tp=1;char c;c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')tp=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=(x*10+c-'0');c=getchar();}\n\treturn x*tp;\n}\nstruct Graph{\n\tLL m,sg[MAXN],f[MAXN];\n\tvector<int>e[MAXN];\n\tvoid work(){\n\t\tint x,y;\n\t\tm=rd();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tx=rd(),y=rd();\n\t\t\tif(x>y)swap(x,y);\n\t\t\te[x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tset<int>s;\n\t\t\tint sz=e[i].size();\n\t\t\tfor(int j=0;j<sz;j++)s.insert(sg[e[i][j]]);\n\t\t\twhile(s.count(sg[i]))sg[i]++;\n\t\t\t(f[sg[i]]+=bs[i])%=MOD;\n\t\t\t// printf(\"sg[%d]=%d\\n\",i,sg[i]);\n\t\t}\n\t}\n}g[3];\nint main(){\n\t// freopen(\"testdata.in\",\"r\",stdin);\n\t// freopen(\"shit.out\",\"w\",stdout);\n\tn=rd();int Sqr=sqrt(n);\n\tbs[0]=1;LL fuck=1000000000000000000ll%MOD;\n\tfor(int i=1;i<=3*n;i++)bs[i]=bs[i-1]*fuck%MOD;\n\tfor(int i=0;i<3;i++)g[i].work();\n\tfor(int i=0;i<=Sqr;i++)\n\t\tfor(int j=0;j<=Sqr;j++)\n\t\t\t(ans+=g[0].f[i]*g[1].f[j]%MOD*g[2].f[i^j]%MOD)%=MOD;\n\tprintf(\"%lld\\n\",ans);\n\t// printf(\"%.2lf\\n\",(double)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Let's join Kaede Takagaki Fun Club !!\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define all(x) x.begin(),x.end()\ntemplate<class T>\nvoid dmp(T a){\n\trep(i,a.size()) cout << a[i] << \" \";\n\tcout << endl;\n}\ntemplate<class T>\nbool chmax(T&a, T b){\n\tif(a < b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nbool chmin(T&a, T b){\n\tif(a > b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nvoid g(T &a){\n\tcin >> a;\n}\ntemplate<class T>\nvoid o(const T &a,bool space=false){\n\tcout << a << (space?' ':'\\n');\n}\n//ios::sync_with_stdio(false);\nconst ll mod = 998244353;\ntemplate<class T>\nvoid add(T&a,T b){\n\ta+=b;\n\tif(a >= mod) a-=mod;\n}\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll b = 1000000000000000000LL%mod;\nint n;\nvector<ll>make(){\n\tint m; g(m);\n\tvector<vector<int>>adj(n);\n\trep(i,m){\n\t\tint a,b; g(a); g(b); a--; b--;\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\tvector<int>num(n);\n\tfor(int i=n-1;i>=0;i--){\n\t\tset<int>S;\n\t\tfor(auto at:adj[i]){\n\t\t\tif(at > i) S.insert(num[at]);\n\t\t}\n\t\tfor(int v=0;;v++) if(S.find(v) == S.end()){\n\t\t\tnum[i] = v; \n\t\t\tbreak;\n\t\t}\n\t}\n\tvector<ll>ret(n);\n\trep(j,n){\n\t\tadd(ret[num[j]], modpow(b,j+1));\n\t}\n\twhile(ret.back() == 0) ret.pop_back();\n\treturn ret;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tg(n);\n\tvector<vector<ll>>gr;\n\trep(i,3){\n\t\tgr.pb(make());\n\t}\n\tll ans = 0;\n\trep(i,gr[0].size()){\n\t\trep(j,gr[1].size()){\n\t\t\tint k = (i^j);\n\t\t\tif(gr[2].size() > k){\n\t\t\t\tadd(ans, gr[0][i]*gr[1][j]%mod*gr[2][k]%mod);\n\t\t\t}\n\t\t}\n\t}\n\to(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdio>\n#include <complex>\n#include <numeric>\n#include <string.h>\n#include <random>\n#include <cmath>\n#include <unordered_map>\n#include <unordered_set>\n#include <chrono>\n#include <cassert>\n#define rep(i,n) for (ll i = 0; i < (ll)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\ndouble PI = 3.141592653589793238462643383279;\nconst double EPS = 1e-9;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate< int mod >\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n         return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt< MOD >;\n\nint n;\nint m[3];\nvector<vector<int>> e[3];\nbool done[3][100000];\nbool done2[3][100000];\nmint val[3];\nmint val2[3];\nmint ten = 10;\nmint ans;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i,3) {\n        e[i].resize(n);\n        cin >> m[i];\n        rep(j,m[i]) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            e[i][a].push_back(b);\n            e[i][b].push_back(a);\n        }\n    }\n    rep(i,3) {\n        for (int j = n-1; j >= 0; j--) {\n            if (done[i][j]) continue;\n            val[i] += ten.pow(18*(j+1));\n            for (int to : e[i][j]) {\n                done[i][to] = true;\n            }\n        }\n    }\n    ans = val[0]*val[1]*val[2];\n    while (true) {\n        rep(i,3) val2[i] = 0;\n        memset(done2, 0, sizeof(done2));\n        bool end = true;\n        rep(i,3) {\n            for (int j = n-1; j >= 0; j--) {\n                if (!done[i][j]) continue;\n                if (done2[i][j]) continue;\n                val2[i] += ten.pow(18*(j+1));\n                end = false;\n                for (int to : e[i][j]) {\n                    if (to > j) continue;\n                    done2[i][to] = true;\n                }\n            }\n        }\n        if (end) break;\n        ans += val2[0]*val2[1]*val[2];\n        ans += val2[0]*val[1]*val2[2];\n        ans += val[0]*val2[1]*val2[2];\n        // rep(i,3) val[i] += val2[i];\n        rep(i,3) rep(j,n) if (!done2[i][j]) {\n            done[i][j] = false;\n        }\n    }\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db double\n\nusing namespace std;\nconst int N=1e5+10,mod=998244353;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nvoid ad(int &x,int y){x+=y,x-=x>=mod?mod:0;}\nint fpow(int a,int b){int an=1;while(b){if(b&1) an=1ll*an*a%mod;a=1ll*a*a%mod,b>>=1;}return an;}\nint ginv(int a){return fpow(a,mod-2);}\nint n,pw[N],vs[N],ti,sb[3][N],ans;\nqueue<int> q;\nstruct graph\n{\n\tint to[N],nt[N],hd[N],sg[N],tot;\n\tvoid adde(int x,int y){++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;}\n\tvoid inii()\n\t{\n\t\tfor(int x=n;x;--x)\n\t\t{\n\t\t\t++ti;\n\t\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t\t{\n\t\t\t\tint y=to[i];\n\t\t\t\tvs[sg[y]]=ti;\n\t\t\t}\n\t\t\twhile(vs[sg[x]]==ti) ++sg[x];\n\t\t}\n\t}\n}gg[3];\n\nint main()\n{\n\tn=rd();\n\tpw[0]=1,pw[1]=fpow(10,18);\n\tfor(int i=2;i<=n;++i) pw[i]=1ll*pw[i-1]*pw[1]%mod;\n\tfor(int h=0;h<=2;++h)\n\t{\n\t\tint m=rd();\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tint x=rd(),y=rd();\n\t\t\tif(x>y) swap(x,y);\n\t\t\tgg[h].adde(x,y);\n\t\t}\n\t\tgg[h].inii();\n\t\tfor(int i=1;i<=n;++i) ad(sb[h][gg[h].sg[i]],pw[i]);\n\t}\n\tfor(int i=0;i<=1000;++i)\n\t\tfor(int j=0;j<=1000;++j)\n\t\t\tad(ans,1ll*sb[0][i]*sb[1][j]%mod*sb[2][i^j]%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int Mod=998244353,Inv2=Mod+1>>1,MAXN=1e5+5,ba=716070898;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\ninline int Add(int x,int y){return x+y>=Mod?x+y-Mod:x+y;}\ninline int Sub(int x,int y){return x-y<0?x-y+Mod:x-y;}\ninline void Div(int&x){if(x&1)x=1ll*x*Inv2%Mod;else x/=2;}\nint n,m,len,SG[MAXN],Sum[5][MAXN],ans[MAXN],S[MAXN],N,Fpow[MAXN];\nvector<int>G[MAXN];\ninline int Get(int x){\n\tN=0;for(auto y:G[x])S[++N]=SG[y];sort(S+1,S+N+1);\n\tS[0]=-1;Rep(i,1,N)if(S[i]>S[i-1]+1)return S[i-1]+1;\n\treturn S[N]+1;\n}\ninline void FwtXor(int*F,int len,int opt){\n\tfor(int i=1;i<len;i<<=1)for(int j=0;j<len;j+=i<<1)for(int k=0;k<i;k++){\n\t\tint x=F[i+j+k],y=F[j+k];F[j+k]=Add(x,y),F[i+j+k]=Sub(y,x);if(opt==-1)Div(F[j+k]),Div(F[i+j+k]);\n\t}\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read();Fpow[0]=1;Rep(i,1,n)Fpow[i]=1ll*Fpow[i-1]*ba%Mod;\n\tfor(int t=1;t<=3;t++){\n\t\tm=read(),len=1024;\n\t\tRep(i,1,m){int x=read(),y=read();if(x<y)swap(x,y);G[y].push_back(x);}\n\t\tRed(i,n,1)SG[i]=Get(i),Sum[t][SG[i]]=(Sum[t][SG[i]]+Fpow[i])%Mod;FwtXor(Sum[t],len,1);\n\t\tRep(i,1,n)G[i].clear();\n\t}for(int i=0;i<len;i++)ans[i]=1ll*Sum[1][i]*Sum[2][i]%Mod*Sum[3][i]%Mod;\n\tFwtXor(ans,len,-1);cout<<ans[0]<<\"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\nvector<int> G[3][101010];\nint s[3][101010];\nint f[3][512];\nint M[3];\n\nint buffer[101010];\n\nint _10[202020];\n\nint main()\n{\n\t_10[0] = 1;\n\tfor(int i = 1; i <= 200000; i++)\n\t\t_10[i] = 1ll * _10[i-1] * (((long long)1e18) % mod) % mod;\n\t\n\t\n\tint N;\n\tscanf(\"%d\", &N);\n\t\n\tfor(int t = 0; t < 3; t++)\n\t{\n\t\tscanf(\"%d\", &M[t]);\n\t\tfor(int i = 1; i <= M[t]; i++)\n\t\t{\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif(u > v)\n\t\t\t\tswap(u, v);\n\t\t\tG[t][u].push_back(v);\n\t\t}\n\t\tfor(int i = N; i >= 1; i--)\n\t\t{\n\t\t\tfor(int x: G[t][i])\n\t\t\t\tbuffer[s[t][x]] = 1;\n\t\t\twhile(buffer[s[t][i]])\n\t\t\t\ts[t][i]++;\n\t\t\tfor(int x: G[t][i])\n\t\t\t\tbuffer[s[t][x]] = 0;\n\t\t\tf[t][s[t][i]] += _10[i];\n\t\t\tf[t][s[t][i]] %= mod; \n\t\t}\n\t}\n\tint ans = 0;\n\t\n\tfor(int i = 0; i < 512; i++)\n\tfor(int j = 0; j < 512; j++)\n\t{\n\t\tans += 1ll * f[0][i] * f[1][j] % mod * f[2][i^j] % mod;\n\t\tif(ans >= mod)\n\t\t\tans -= mod;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define re register\n#define cs const\n\nnamespace IO{\n\tinline char gc(){\n\t\tstatic cs int Rlen=1<<22|1;static char buf[Rlen],*p1,*p2;\n\t\treturn (p1==p2)&&(p2=(p1=buf)+fread(buf,1,Rlen,stdin),p1==p2)?EOF:*p1++;\n\t}template<typename T>T get_integer(){\n\t\tchar c;bool f=false;while(!isdigit(c=gc()))f=c=='-';T x=c^48;\n\t\twhile(isdigit(c=gc()))x=((x+(x<<2))<<1)+(c^48);return f?-x:x;\n\t}inline int gi(){return get_integer<int>();}\n}using namespace IO;\n\nusing std::cerr;\nusing std::cout;\n\ncs int mod=998244353,Val=(ll)(1e18)%mod;\ninline int add(int a,int b){return a+b>=mod?a+b-mod:a+b;}\ninline int dec(int a,int b){return a-b<0?a-b+mod:a-b;}\ninline int mul(int a,int b){ll r=(ll)a*b;return r>=mod?r%mod:r;}\ninline void Inc(int &a,int b){a+=b-mod;a+=a>>31&mod;} \ninline void Dec(int &a,int b){a-=b;a+=a>>31&mod;}\ninline void Mul(int &a,int b){a=mul(a,b);}\ninline void ex_gcd(int a,int b,int &x,int &y){\n\tif(!b){x=1,y=0;return ;}ex_gcd(b,a%b,y,x);y-=a/b*x;\n}inline int inv(int a){int x,y;ex_gcd(mod,a,y,x);return x+(x>>31&mod);}\n\ncs int SIZE=1<<10|7;\n\nint S,ivS;\n\nvoid FWT(int *A){\n\tfor(int re i=1;i<S;i<<=1)\n\t\tfor(int re j=0;j<S;j+=i<<1)\n\t\t\tfor(int re k=0;k<i;++k){\n\t\t\t\tint x=A[j+k],y=A[i+j+k];\n\t\t\t\tA[j+k]=add(x,y);\n\t\t\t\tA[i+j+k]=dec(x,y);\n\t\t\t}\n}\n\nvoid IFWT(int *A){\n\tFWT(A);for(int re i=0;i<S;++i)Mul(A[i],ivS);\n}\n\nint sm[3][SIZE];\n\ncs int N=1e5+7;\n\nint n,m,mx,ans;\n\nint el[N],nx[N],to[N],ec;\ninline void adde(int u,int v){\n\tif(u>v)std::swap(u,v);\n\tnx[++ec]=el[u],el[u]=ec,to[ec]=v;\n}\n\nvoid clr(){\n\tmemset(el,0,(n+1)<<2);ec=0;\n}\n\nint pw[N],sg[N],vs[SIZE];\nvoid calc(int *sm){\n\tfor(int re u=n;u;--u){\n\t\tfor(int re e=el[u];e;e=nx[e])\n\t\t\tvs[sg[to[e]]]=true;\n\t\tsg[u]=0;while(vs[sg[u]])++sg[u];\n\t\tfor(int re e=el[u];e;e=nx[e])\n\t\t\tvs[sg[to[e]]]=false;\n\t\tInc(sm[sg[u]],pw[u]);\n\t}\n}\n\nvoid Main(){\n\tn=gi();\n\tfor(int re i=pw[0]=1;i<=n;++i)\n\t\tpw[i]=mul(pw[i-1],Val);\n\tfor(int re t=0;t<3;++t){\n\t\tm=gi();mx=std::max(mx,m);\n\t\tfor(int re i=1;i<=m;++i)\n\t\t\tadde(gi(),gi());\n\t\tcalc(sm[t]);clr();\n\t}for(S=1;S*S>>1<mx;S<<=1);ivS=inv(S);\n\tFWT(sm[0]),FWT(sm[1]);\n\tfor(int re i=0;i<S;++i)\n\t\tMul(sm[0][i],sm[1][i]);\n\tIFWT(sm[0]);\n\tfor(int re i=0;i<S;++i)\n\t\tInc(ans,mul(sm[0][i],sm[2][i]));\n\tcout<<ans<<\"\\n\";\n}\n\ninline void file(){\n#ifdef zxyoi\n\tfreopen(\"C.in\",\"r\",stdin);\n#endif\n}signed main(){file();Main();return 0;} "
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 21.03.2020 15:21:33       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n  for (int r = 0; r < 3; r++) {\n    int m;\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      if (x > y) {\n        swap(x, y);\n      }\n      g[r][x].push_back(y);\n    }\n  }\n  Mint p = (long long) 1e18;\n  vector<Mint> pw(n);\n  pw[0] = p;\n  for (int i = 1; i < n; i++) {\n    pw[i] = pw[i - 1] * p;\n  }\n  const int MAX = 512;\n  vector<vector<Mint>> cnt(3, vector<Mint>(MAX));\n  for (int r = 0; r < 3; r++) {\n    vector<int> gr(n);\n    for (int i = n - 1; i >= 0; i--) {\n      set<int> s;\n      for (int j : g[r][i]) {\n        s.insert(gr[j]);\n      }\n      while (s.find(gr[i]) != s.end()) {\n        ++gr[i];\n      }\n      cnt[r][gr[i]] += pw[i];\n    }\n  }\n  Mint ans = 0;\n  for (int x = 0; x < MAX; x++) {\n    for (int y = 0; y < MAX; y++) {\n      ans += cnt[0][x] * cnt[1][y] * cnt[2][x ^ y];\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MaxN = 100000, MaxS = 1000;\nconst int Mod = 998244353, base = ((long long) 1e18) % Mod;\n\nint N;\nint Pw[MaxN + 5];\nint Sg[3][MaxN + 5];\nstd::vector<int> Gr[3][MaxN + 5];\nint Buc[3][MaxS + 5];\n\ninline int add(int x, int y) { return (x += y) >= Mod ? x - Mod : x; }\ninline int mul(int x, int y) { return 1LL * x * y % Mod; }\ninline void inc(int &x, int y = 1) { x = add(x, y); }\n\nvoid init() {\n  scanf(\"%d\", &N);\n  Pw[0] = 1;\n  for (int i = 1; i <= N; ++i) Pw[i] = mul(Pw[i - 1], base);\n  for (int k = 0; k < 3; ++k) {\n    int m;\n    scanf(\"%d\", &m);\n    for (int i = 1; i <= m; ++i) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      if (u > v) std::swap(u, v);\n      Gr[k][u].push_back(v);\n    }\n  }\n}\n\nvoid getSg(int k) {\n  static bool buc[MaxN + 5];\n  memset(buc, false, sizeof buc);\n  int mx = 0;\n  for (int u = N; u >= 1; --u) {\n    for (int i = 0; i <= mx; ++i) buc[i] = false;\n    mx = 0;\n    for (int v : Gr[k][u]) {\n      buc[Sg[k][v]] = true;\n      mx = std::max(mx, Sg[k][v]);\n    }\n    for (int i = 0; i <= mx + 1; ++i)\n      if (buc[i] == false) {\n        Sg[k][u] = i;\n        break;\n      }\n  }\n}\n\nvoid solve() {\n  for (int k = 0; k < 3; ++k) getSg(k);\n  for (int k = 0; k < 3; ++k)\n    for (int i = 1; i <= N; ++i)\n      inc(Buc[k][Sg[k][i]], Pw[i]);\n  int ans = 0;\n  for (int i = 0; i <= MaxS; ++i)\n    for (int j = 0; j <= MaxS; ++j) {\n      int k = i ^ j;\n      inc(ans, mul(mul(Buc[0][i], Buc[1][j]), Buc[2][k]));\n    }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  init();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=100005,mod=998244353,M=1<<10;\nconst int bas=int(1000000000000000000ll%mod);\nint pw[N],f[N],g[M],dp[M],ndp[M],vis[M];\nint n,A,B,a,b,m;\nvi e[N];\n\nint main(){\n\tread(n);\n\tpw[0]=1;\n\trep(i,1,n) pw[i]=(ll)pw[i-1]*bas%mod;\n\tdp[0]=1;\n\tREP(t,3){\n\t\trep(i,1,n) e[i].clear();\n\t\tread(m);\n\t\trep(i,1,m){\n\t\t\tread(a),read(b);\n\t\t\tif(a>b) swap(a,b);\n\t\t\te[a].pb(b);\n\t\t}\n\t\tmemset(g,0,sizeof g);\n\t\tper(i,n,1){\n\t\t\tf[i]=0;\n\t\t\tfor(auto j:e[i]) vis[f[j]]=1;\n\t\t\twhile(vis[f[i]]) f[i]++;\n\t\t\tg[f[i]]=(g[f[i]]+pw[i])%mod;\n\t\t\tfor(auto j:e[i]) vis[f[j]]=0;\n\t\t}\n\t\tmemset(ndp,0,sizeof ndp);\n\t\tREP(i,M) REP(j,M)\n\t\t\tndp[i^j]=(ndp[i^j]+(ll)dp[i]*g[j])%mod;\n\t\tmemcpy(dp,ndp,sizeof dp);\n\t}\n\tcout<<dp[0]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int maxn=1024;\nconst int mod=998244353;\nint n,m,sg[200005];\nlong long f[3][2005],pw[100005],h[2005],B=1e18;\nvector<int> G[100005];\nlong long ksm(long long x,long long n)\n{\n\tlong long ans=1;\n\twhile(n)\n\t{\n\t\tif(n&1) ans=ans*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn ans;\n}\nvoid FWT(long long a[],int n,int ty)\n{\n\tfor(int i=1;i<n;i<<=1)\n\tfor(int j=0;j<n;j++)\n\t{\n\t\tif(j&i)\n\t\t{\n\t\t\tlong long t0=a[j-i],t1=a[j];\n\t\t\ta[j-i]=(t0+t1)%mod;a[j]=(t0-t1+mod)%mod;\n\t\t}\n\t}\n\tif(ty==-1)\n\t{\n\t\tlong long rev=ksm(n,mod-2);\n\t\tfor(int i=0;i<n;i++) a[i]=a[i]*rev%mod;\n\t}\n}\nint dfs(int x)\n{\n\tif(sg[x]!=-1) return sg[x];\n\tmap<int,bool> g;\n\tint sz=G[x].size();\n\tfor(int i=0;i<sz;i++) g[dfs(G[x][i])]=1;\n\tint now=0;\n\twhile(g[now]) now++;\n\treturn sg[x]=now;\n}\nint main()\n{\n\tB%=mod;\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++) pw[i]=pw[i-1]*B%mod;\n\tfor(int t=0;t<3;t++)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tmemset(sg,-1,sizeof(sg));\n\t\tfor(int i=1;i<=n;i++) G[i].clear();\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tif(x>y) swap(x,y);\n\t\t\tG[x].push_back(y);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) if(sg[i]==-1) dfs(i);\n\t\tfor(int i=1;i<=n;i++) f[t][sg[i]]=(f[t][sg[i]]+pw[i])%mod;\n\t\tFWT(f[t],maxn,1);\n\t}\n\tfor(int i=0;i<maxn;i++) h[i]=1;\n\tfor(int t=0;t<3;t++)\n\tfor(int i=0;i<maxn;i++) h[i]=h[i]*f[t][i]%mod;\n\tFWT(h,maxn,-1);\n\tprintf(\"%lld\\n\",(h[0]%mod+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nconst int P = 998244353;\nconst int Q = 716070898;\nconst int limit = 1000;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, x[MAXN], y[MAXN], z[MAXN];\nint bit[MAXN], f[MAXN], g[MAXN], res[MAXN];\nvector <int> a[MAXN], b[MAXN], c[MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nvoid work(vector <int> *a, int *res) {\n\tstatic int vis[MAXN];\n\tfor (int i = n; i >= 1; i--) {\n\t\tfor (auto x : a[i]) vis[res[x]] = true;\n\t\tres[i] = 1; while (vis[res[i]]) res[i]++;\n\t\tfor (auto x : a[i]) vis[res[x]] = false;\n\t}\n}\nint main() {\n\tread(n);\n\tread(m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y; read(x), read(y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tread(m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y; read(x), read(y);\n\t\tb[x].push_back(y);\n\t\tb[y].push_back(x);\n\t}\n\tread(m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y; read(x), read(y);\n\t\tc[x].push_back(y);\n\t\tc[y].push_back(x);\n\t}\n\twork(a, x);\n\twork(b, y);\n\twork(c, z);\n\tbit[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tbit[i] = 1ll * Q * bit[i - 1] % P;\n\tfor (int i = 1; i <= n; i++) {\n\t\tupdate(f[y[i]], bit[i]);\n\t\tupdate(g[z[i]], bit[i]);\n\t}\n\tfor (int i = 1; i <= limit; i++) {\n\t\tint inc = (i - 1) / 2 * 2;\n\t\tfor (int j = 1; j <= limit; j++) {\n\t\t\tint k = j + inc;\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tif (j % 2) k++;\n\t\t\t\telse k--;\n\t\t\t}\n\t\t\tupdate(res[i], 1ll * f[j] * g[k] % P);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tupdate(ans, 1ll * res[x[i]] * bit[i] % P);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for (int i = 0; i < int(n); i++)\n\nconst int MOD = 998244353;\nconst int N = 1e5 + 10;\n\nint n, nim[3][N], cnt[3][N], mx[3], pot[N];\nvector<int> adj[N];\nbool vis[N];\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n\n    pot[0] = 1;\n    pot[1] = 1; forn(_,18) pot[1] = 10LL*pot[1]%MOD;\n    for (int i = 2; i < N; i++) pot[i] = (long long) pot[i-1] * pot[1] % MOD;\n\n    forn(i,3) {\n        forn(j,n) {\n            adj[j].clear();\n            nim[i][j] = 0;\n        }\n        int m; cin >> m;\n        while (m--) {\n            int u,v; cin >> u >> v;\n            u--; v--;\n            if (u > v) swap(u,v);\n            adj[u].push_back(v);\n        }\n        for (int j = n-1; j >= 0; j--) {\n            int sz = adj[j].size();\n            fill_n(vis, sz+2, 0);\n            for (auto k : adj[j]) vis[nim[i][k]] = 1;\n            while (vis[nim[i][j]]) nim[i][j]++;\n\n            add(cnt[i][nim[i][j]], pot[j+1]);\n            mx[i] = max(mx[i], nim[i][j]);\n        }\n    }\n\n    long long ans = 0;\n    for (int x = 0; x <= mx[0]; x++) {\n        for (int y = 0; y <= mx[1]; y++) {\n            int z = x^y;\n            ans += (long long) cnt[0][x] * cnt[1][y] % MOD * cnt[2][z] % MOD;\n        }\n    }\n    cout << ans % MOD << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\nLL Inverse(LL n, LL m) {\n    n %= m;\n    if (n <= 1) return n; // Handles properly (n = 0, m = 1).\n    return m - ((m * Inverse(m, n) - 1) / n);\n}\n\n// Fast exponentiation modulo mod. Returns x**e modulo mod.\n// Assumptions: 0 <= x < m\n//              mod < 2**31.\n//              0 <= e < 2**63\nLL pow(LL x, LL e, LL mod) {\n    LL res = 1;\n    for (; e >= 1; e >>= 1) {\n        if (e & 1) res = res * x % mod;\n        x = x * x % mod;\n    }\n    return res;\n}\n\nconst int MAXN = 1<<17;\nvector<int> aa[3][MAXN];\nint nim[3][MAXN];\n\nLL val[3][MAXN + 1];\nconst LL mod = 998244353;\n\nLL res[MAXN+1];\n\nvoid fwht(LL *data, int dim) {\n    for (int len = 1; 2 * len <= dim; len <<= 1) {\n        for (int i = 0; i < dim; i += 2 * len) {\n            for (int j = 0; j < len; j++) {\n                LL a = data[i + j];\n                LL b = data[i + j + len];\n                \n                data[i + j] = (a + b) % mod;\n                data[i + j + len] = (mod + a - b) % mod;\n            }   \n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n\n    int N;\n    cin >> N;\n    dbg(N);\n    for (int z = 0; z < 3; z++) {\n        int M;\n        cin >> M;\n        for (int i = 0; i < M; i++) {\n            int a, b;\n            cin >> a >> b;\n            if (a > b) swap(a, b);\n            aa[z][a].push_back(b);\n        }\n        for (int i = N; i >= 1; i--) {\n            vector<int> vals;\n            for (int a: aa[z][i]) vals.push_back(nim[z][a]);\n            sort(vals.begin(), vals.end());\n            vals.erase(unique(vals.begin(), vals.end()), vals.end());\n            nim[z][i] = 0;\n            while (nim[z][i] < SZ(vals) and vals[nim[z][i]] == nim[z][i]) nim[z][i]++;\n            val[z][nim[z][i]] = (val[z][nim[z][i]] + pow(10, 18*i, mod)) % mod;\n        }\n        fwht(val[z], MAXN);\n    }\n\n    for (int i = 0; i < MAXN; i++) {\n        res[i] = val[0][i] * val[1][i] % mod;\n        res[i] = res[i] * val[2][i] % mod;\n    }\n\n    fwht(res, MAXN);\n    \n    LL inv = Inverse(MAXN, mod);\n    for (int i = 0; i < MAXN; i++) {\n        res[i] = res[i] * inv % mod;\n        if (res[i] < 0) res[i] += mod;\n    }\n    cout << res[0] << \"\\n\";\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 100005\n#define SQR 512\n#define MOD 998244353\n#define INF 1000000000000000000LL\nusing namespace std;\ntypedef long long int ll;\n\nint n;\nvector <int> vec[SIZE];\nint grundy[SIZE];\nll sum[3][SQR];\n\nvoid solve(int t)\n{\n\tint m;\n\tscanf(\"%d\",&m);\n\tfor(int i=0;i<n;i++) vec[i].clear();\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\ta--,b--;\n\t\tif(a>b) swap(a,b);\n\t\tvec[a].push_back(b);\n\t}\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tset <int> st;\n\t\tfor(int j=0;j<vec[i].size();j++) st.insert(grundy[vec[i][j]]);\n\t\tgrundy[i]=0;\n\t\twhile(st.count(grundy[i])) grundy[i]++;\n\t}\n\tll mul=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tmul*=INF%MOD;\n\t\tmul%=MOD;\n\t\tsum[t][grundy[i]]+=mul;\n\t\tif(sum[t][grundy[i]]>=MOD) sum[t][grundy[i]]-=MOD;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int t=0;t<3;t++) solve(t);\n\tll ret=0;\n\tfor(int i=0;i<SQR;i++)\n\t{\n\t\tfor(int j=0;j<SQR;j++)\n\t\t{\n\t\t\tret+=sum[0][i]*sum[1][j]%MOD*sum[2][i^j]%MOD;\n\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// No.074901032320\n#include <bits/stdc++.h>\n#define N 100100\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, m, vis[N], sg[N], f[3][N], mx, pw[N];\nvector<int> G[N];\n\nint main() {\n#ifdef isLOCAL\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    int base = 1000000000000000000ll % Mod;\n    for (int i = pw[0] = 1; i <= n; ++i)\n        pw[i] = 1ll * pw[i - 1] * base % Mod;\n\n    for (int g = 0; g < 3; ++g) {\n        cin >> m;\n        for (int i = 1; i <= n; ++i) G[i].clear();\n        for (int i = 1, u, v; i <= m; ++i) {\n            scanf(\"%d%d\", &u, &v);\n            if (u > v) swap(u, v);\n            G[u].push_back(v);\n        }\n        for (int i = n; i >= 1; --i) {\n            for (int v : G[i])\n                vis[sg[v]]++;\n            sg[i] = 0;\n            while (vis[sg[i]]) ++sg[i];\n            for (int v : G[i])\n                vis[sg[v]]--;\n            mx = max(mx, sg[i]);\n            f[g][sg[i]] = (f[g][sg[i]] + pw[i]) % Mod;\n        }\n    }\n    \n    long long ans = 0;\n    for (int i = 0; i <= mx; ++i)\n        for (int j = 0; j <= mx; ++j)\n            ans = (ans + 1ll * f[0][i] * f[1][j] % Mod * f[2][i xor j]) % Mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\nvector<int> solveOne(int n) {\n\tvector<vector<int>> G(n);\n\t\n\tint m;\n\tignore = scanf(\"%d\", &m);\n\tfor (int i = 0, u, v; i < m; i++) {\n\t\tignore = scanf(\"%d %d\", &u, &v);\n\t\tu--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tvector<int> w;\n\tw.push_back(1000000000LL * 1000000000LL % md);\n\tfor (int i = 1; i < n; i++) {\n\t\tw.push_back(w.back() * 1LL * w.front() % md);\n\t}\n\t\n\tvector<int> res, grp(n);\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tset<int> bad;\n\t\tfor (int u : G[i]) {\n\t\t\tif (u < i) continue;\n\t\t\tbad.insert(grp[u]);\n\t\t}\n\t\t\n\t\tint g = 0;\n\t\twhile (bad.count(g) == 1) g++;\n\t\t\n\t\tgrp[i] = g;\n\t\t\n\t\tif (res.size() < g + 1) {\n\t\t\tres.resize(g + 1);\n\t\t}\n\t\t\n\t\tres[g] = (res[g] + w[i]) % md;\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d\", &n);\n\t\n\tauto v1 = solveOne(n);\n\tauto v2 = solveOne(n);\n\tauto v3 = solveOne(n);\n\t\n\tsize_t n1 = v1.size();\n\tsize_t n2 = v2.size();\n\tsize_t n3 = v3.size();\n\t\n\tsize_t N = max({n1, n2, n3});\n\t\n\tvector<vector<bool>> taken12(N, vector<bool>(N, false));\n\tauto taken13 = taken12;\n\tauto taken23 = taken12;\n\t\n\tint ans = 0;\n\tfor (size_t s = 0; s < n1 + n2 + n3; s++)\n\t\tfor (size_t i1 = 0; i1 < n1 && i1 <= s; i1++)\n\t\t\tfor (size_t i2 = 0; i2 < n2 && i1 + i2 <= s; i2++) {\n\t\t\t\tsize_t i3 = s - i1 - i2;\n\t\t\t\tif (i3 >= n3) continue;\n\t\t\t\t\n\t\t\t\tif (taken12[i1][i2]) continue;\n\t\t\t\tif (taken13[i1][i3]) continue;\n\t\t\t\tif (taken23[i2][i3]) continue;\n\t\t\t\t\n\t\t\t\ttaken12[i1][i2] = true;\n\t\t\t\ttaken13[i1][i3] = true;\n\t\t\t\ttaken23[i2][i3] = true;\n\t\t\t\t\n\t\t\t\tans = (ans + v1[i1] * 1LL * v2[i2] % md * v3[i3]) % md;\n\t\t\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nconst int mod = 998244353;\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n;\n  vvi g[3];\n  cin >> n;\n  ll res = 0, all = 0;\n  vl pw(n + 1, 1);\n  ll r0 = 1000000000000000000LL % mod;\n  for (int i = 1; i < pw.size(); ++i) pw[i] = pw[i-1] * r0 % mod;\n  for (int i = 0; i < n; ++i) all = (all + pw[i + 1]) % mod;\n  ll prod = 1, sum = 0;\n  vl x[3];\n  for (int t = 0; t < 3; ++t) {\n    int m;\n    cin >> m;\n    g[t].resize(n);\n    for (int i = 0; i < m; ++i) {\n      int a, b;\n      cin >> a >> b;\n      --a; --b;\n      g[t][a].push_back(b);\n      g[t][b].push_back(a);\n    }\n    ll s = 0;\n    vi was(n);\n    for (int i = n-1; i >= 0; --i) if (!was[i]) {\n      s += pw[i + 1];\n      for (int j : g[t][i]) was[j] = 1;\n    }\n    s %= mod;\n//    sum = (sum + s) % mod;\n    prod = prod * s % mod;\n    x[t].push_back(s);\n    set<int> rem;\n    for (int i = 0; i < n; ++i) if (was[i]) rem.insert(i);\n    while (!rem.empty()) {\n      set<int> nrem;\n      ll s = 0;\n      while (!rem.empty()) {\n        auto it = rem.end(); --it;\n        int v = *it;\n        s += pw[v + 1];\n        for (int x : g[t][v]) if (rem.count(x)) {\n          rem.erase(x);\n          nrem.insert(x);\n        }\n        rem.erase(v);\n      }\n      x[t].push_back(s % mod);\n      rem.swap(nrem);\n    }\n  }\n  res = prod;\n  for (int t = 0; t < 3; ++t) {\n    int t1 = (t + 1) % 3, t2 = (t + 2) % 3;\n    for (int i = 1; i < min(x[t1].size(), x[t2].size()); ++i) {\n      res = (res + x[t][0] * x[t1][i] % mod * x[t2][i]) % mod;\n    }\n    for (int i = 1; i < x[t].size(); ++i) {\n      for (int j = 2 * i; j < n; j += 2 * i) {\n        if (j < x[t1].size() && j + i < x[t2].size()) res = (res + x[t][i] * x[t1][j] % mod * x[t2][j + i]) % mod;\n        if (j < x[t2].size() && j + i < x[t1].size()) res = (res + x[t][i] * x[t2][j] % mod * x[t1][j + i]) % mod;\n      }\n    }\n  }\n  cout << (res % mod + mod) % mod << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// I think of what the world could be, A vision of the one I see, A million dreams is all it's gonna take\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn = 1e5 + 10, mod = 998244353;\nconst int MX = 1 << 17;\n\nint cnt1[MX], cnt2[MX], cnt3[MX], arr[MX];\nint n, dp[maxn];\nvector<int> v[maxn];\n\nint Pow(int a, int b){\n    int ans = 1;\n    for(; b; b >>= 1, a = 1ll * a * a % mod)\n\tif(b&1)\n\t    ans = 1ll * ans * a % mod;\n    return ans;\n}\nvoid solve(int *arr){\n    int m;\n    cin >> m;\n    for(int i = 1; i <= n; i++){\n\tv[i].clear();\n    }\n    while(m--){\n\tint a, b;\n\tcin >> a >> b;\n\tif(a > b)\n\t    swap(a, b);\n\tv[a].PB(b);\n    }\n    for(int i = n; i >= 1; i--){\n\tvector<int> vec;\n\tfor(int j : v[i])\n\t    vec.PB(dp[j]);\n\tsort(vec.begin(), vec.end());\n\tvec.resize( unique(vec.begin(), vec.end()) - vec.begin() );\n\tdp[i] = sz(vec);\n\tfor(int j = 0; j < sz(vec); j++){\n\t    if(j != vec[j]){\n\t\tdp[i] = j;\n\t\tbreak;\n\t    }\n\t}\n\tassert(dp[i] < MX);\n\tarr[dp[i]] = (arr[dp[i]] + Pow(10, 18 * i)) % mod;\n    }\n}\nvoid txor(int *a,int tw,bool inv){\n    for(int ln=1;(2*ln)<=tw;ln*=2){\n\tfor(int l=0;l<tw;l+=ln+ln){\n\t    for(int i=0;i<ln;i++){\n\t\tint x=a[l+i],y=a[l+ln+i];\n\t\ta[l+i]=(x+y) % mod;\n\t\ta[l+ln+i]=(x-y) % mod;\n\t    }\n\t}\n    }\n    if(inv){\n\tint r = Pow(tw, mod-2);\n\tfor(int i=0;i<tw;i++)\n\t    a[i] = 1ll * a[i] * r % mod;\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie();\n\n    cin >> n;\n    solve(cnt1), solve(cnt2), solve(cnt3);\n\n    txor(cnt1, 1<<17, 0);\n    txor(cnt2, 1<<17, 0);\n    for(int i = 0; i < (1<<17); i++)\n\tcnt1[i] = 1ll * cnt1[i] * cnt2[i] % mod;\n    txor(cnt1, 1<<17, 1);\n    int ans = 0;\n    for(int i = 0; i < (1<<17); i++)\n\tans = (1ll * ans + 1ll * cnt1[i] * cnt3[i]) % mod;\n    if(ans < 0)\n\tans+= mod;\n    return cout << ans << endl, 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int Maxn = 100005;\nconst int mod = 998244353;\nconst int pw = 1000000;\nconst int Maxm = 1005;\n\nint n;\nvector <int> neigh[Maxn];\nvector <int> my[3];\nint col[3][Maxn];\nint res;\nbool was[3][Maxm][Maxm];\n\nint toPower(int a, int p)\n{\n    int res = 1;\n    while (p) {\n        if (p & 1) res = ll(res) * a % mod;\n        p >>= 1; a = ll(a) * a % mod;\n    }\n    return res;\n}\n\nvoid Solve(vector <int> &res, int col[])\n{\n    int m; scanf(\"%d\", &m);\n    for (int i = 1; i <= n; i++)\n        neigh[i].clear();\n    for (int i = 0; i < m; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        if (a > b) swap(a, b);\n        neigh[a].push_back(b);\n    }\n    for (int i = n; i > 0; i--) {\n        vector <int> seq;\n        for (int j = 0; j < neigh[i].size(); j++)\n            seq.push_back(col[neigh[i][j]]);\n        sort(seq.begin(), seq.end());\n        col[i] = 0;\n        int my = toPower(pw, 3 * i);\n        for (int j = 0; j < seq.size(); j++)\n            if (seq[j] == col[i]) col[i]++;\n        if (col[i] == res.size()) res.push_back(my);\n        else res[col[i]] = (res[col[i]] + my) % mod;\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < 3; i++) {\n        Solve(my[i], col[i]);\n        assert(my[i].size() < Maxm);\n    }\n    for (int i = 0; i < my[0].size(); i++)\n        for (int j = 0; j < my[1].size(); j++)\n            for (int k = 0; k < my[2].size(); k++) {\n                if (was[0][i][j] || was[1][i][k] || was[2][j][k]) continue;\n                was[0][i][j] = was[1][i][k] = was[2][j][k] = true;\n                res = (res + ll(my[0][i]) * my[1][j] % mod * my[2][k]) % mod;\n            }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// No.074901032320\n#include <bits/stdc++.h>\n#define N 100100\nusing namespace std;\nconst int Mod = 998244353;\n\nint n, m, vis[N], sg[N], f[3][N], mx, pw[N];\nvector<int> G[N];\n\nint main() {\n#ifdef isLOCAL\n    freopen(\".in\", \"r\", stdin);\n    freopen(\".out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    int base = 1000000000000000000ll % Mod;\n    for (int i = pw[0] = 1; i <= n; ++i)\n        pw[i] = 1ll * pw[i - 1] * base % Mod;\n\n    for (int g = 0; g < 3; ++g) {\n        cin >> m;\n        for (int i = 1; i <= n; ++i) G[i].clear();\n        for (int i = 1, u, v; i <= m; ++i) {\n            scanf(\"%d%d\", &u, &v);\n            if (u > v) swap(u, v);\n            G[u].push_back(v);\n        }\n        for (int i = n; i >= 1; --i) {\n            for (int v : G[i])\n                vis[sg[v]]++;\n            sg[i] = 0;\n            while (vis[sg[i]]) ++sg[i];\n            for (int v : G[i])\n                vis[sg[v]]--;\n            mx = max(mx, sg[i]);\n            f[g][sg[i]] = (f[g][sg[i]] + pw[i]) % Mod;\n        }\n    }\n    \n    long long ans = 0;\n    for (int i = 0; i <= mx; ++i)\n        for (int j = 0; j <= mx; ++j)\n            ans = (ans + 1ll * f[0][i] * f[1][j] % Mod * f[2][i xor j]) % Mod;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <memory.h>\n#include <cmath>\n#include <array>\n\nusing namespace std;\n\nvoid re(int& x);\n\ntemplate<class T, class... Ts> void re(T& t, Ts&... ts);\n\nvoid pr(long long x);\n\nvoid pr(const char *x);\n\nvoid ps();\ntemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts);\n\n#ifdef FFDBG\n\n#else\n#define dbg(x...) dsfdsfsdfasd\n#endif\n\n#define sz(x) (int)(x).size()\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n\nconst int mod = 998244353;\nconst long long base = 1000000000000000000 % mod;\n\nint n,m;\nvector<int> g[3][110000];\nint seen[3][110000];\nvector<long long> vals[3];\nlong long pot[110000];\n\n// int dfs(int v) {\n//     if (seen[v]) return -1;\n//     seen[v] = 1;\n//     int ans = v;\n//     for (int x : g[v]) ans = max(v, dfs(x));\n//     return ans;\n// }\n\nvoid solve()\n{\n    pot[0] = 1;\n    rep(i,1,100010) pot[i] = (pot[i-1] * 1ll * base) % mod;\n\n    // dbg(base);\n\n    re(n);\n    rep(iter,0,3) {\n        re(m);\n\n        rep(i,0,m) {\n            int u,v; re(u,v); u--; v--;\n            g[iter][u].push_back(v);\n            g[iter][v].push_back(u);\n        }\n\n        int taken = 0, cc = 0;\n        while (taken < n) {\n            long long cur = 0;\n            cc++;\n            for (int i = n-1; i >= 0; i--) if (seen[iter][i] < cc) {\n                seen[iter][i]=n+1;\n                taken++;\n                cur = (cur + pot[i+1]) % mod;\n                for (int x : g[iter][i]) seen[iter][x] = max(seen[iter][x], cc);\n            }\n            vals[iter].push_back(cur);\n        }\n    }\n\n    long long ans = 0;\n\n    // dbg(vals[0][0], vals[0][1]);\n\n    rep(i,0,min(sz(vals[1]), sz(vals[2]))) {\n        long long th = vals[0][0];\n        th = (th * 1ll * vals[1][i]) % mod;\n        th = (th * 1ll * vals[2][i]) % mod;\n        ans = (ans + th) % mod;\n    }\n    rep(i,1,min(sz(vals[0]), sz(vals[2]))) {\n        long long th = vals[1][0];\n        th = (th * 1ll * vals[0][i]) % mod;\n        th = (th * 1ll * vals[2][i]) % mod;\n        ans = (ans + th) % mod;\n    }\n    rep(i,1,min(sz(vals[0]), sz(vals[1]))) {\n        long long th = vals[2][0];\n        th = (th * 1ll * vals[0][i]) % mod;\n        th = (th * 1ll * vals[1][i]) % mod;\n        ans = (ans + th) % mod;\n    }\n\n    ps(ans);\n}\n\nint main() {\n\n    solve();\n}\n\nvoid re(int& x) { scanf(\"%d\", &x); }\n\ntemplate<class T, class... Ts> void re(T& t, Ts&... ts) { \n    re(t); re(ts...); \n}\n\nvoid pr(long long x) { printf(\"%lld\", x); }\n\nvoid pr(const char *x) { printf(\"%s\", x); }\n\nvoid ps() { pr(\"\\n\"); }\ntemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n    pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define MOD 998244353\n\n#line 1 \"base.hpp\"//r\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//rb\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n#line 1 \"mod.hpp\"//rb\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//rbm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//rb\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//rb\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing WI=vvec<int>;using VI=vec<int>;using VWI=vec<vvec<int>>;using WM=vvec<mint>;\n#line 1 \"alias.hpp\"//rb\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//rb\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){auto l=leftmost_gt(from,to,d);RT l==from?to:--l;}\nTL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){auto l=leftmost_ge(from,to,d);RT l==from?to:--l;}\nnamespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}TL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){\nRT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//rb\nTL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)\n#line 6001 \"base.hpp\"//r\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"r3.cpp\"//\n//#include \"consts.hpp\"\n\nvoid solve() {\n  // NXX(MM(AB))\n  /* <foxy.memo-area> */\n  int N;int X=3;WI A;WI B;cin>>N;VI M(X);A.resize(X);B.resize(X);times(X,Ri_0\n  ){cin>>M[Ri_0];A[Ri_0].resize(M[Ri_0]);B[Ri_0].resize(M[Ri_0]);times(M[Ri_0]\n  ,Ri_1){cin>>A[Ri_0][Ri_1];--A[Ri_0][Ri_1];cin>>B[Ri_0][Ri_1];--B[Ri_0][Ri_1];}}\n  /* </foxy.memo-area> */\n\n  VWI edges(3, WI(N));\n  times(3, i) times(M[i], j) {\n    edges[i][A[i][j]].PB(B[i][j]);\n    edges[i][B[i][j]].PB(A[i][j]);\n  }\n\n  WM gc(3);\n  VI gs;\n  times(3, i) {\n    VI gr(N);\n    rtimes(N, j) {\n      gs.clear();\n      for(int k : edges[i][j]) if(k > j) {\n        gs.PB(gr[k]);\n      }\n      uniq(gs);\n      if(size(gs) == 0 || gs[0] > 0) {\n        gr[j] = 0;\n      } else {\n        times(size(gs) - 1, k) {\n          if(gs[k] + 1 != gs[k+1]) {\n            gr[j] = gs[k] + 1;\n            goto pyonp;\n          }\n        }\n        gr[j] = gs.back() + 1;\n        pyonp:;\n      }\n\n      if(gr[j] >= size(gc[i])) gc[i].resize(gr[j] + 1);\n      gc[i][gr[j]] += 10_m .pow(18 * (j + 1));\n    }\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  gr:    \"<<(gr)ln<<\"  gc[i]: \"<<(gc[i])ln;}\n  }\n\n  mint ans = 0_m;\n  times(size(gc[0]), i) times(size(gc[1]), j) {\n    if((i ^ j) < size(gc[2])) {\n      {if(debug)cerr<<'#'<<__LINE__ ln<<\"  i:                                  \"<<(i)ln<<\"  j:                                  \"<<(j)ln<<\"  i^j:                                \"<<(i^j)ln<<\"  gc[0][i] * gc[1][j] * gc[2][i ^ j]: \"<<(gc[0][i] * gc[1][j] * gc[2][i ^ j])ln;}\n      ans += gc[0][i] * gc[1][j] * gc[2][i ^ j];\n    }\n  }\n\n  cout << ans ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef vector<ll> vll;\n#define INF 0x3f3f3f3f\n#define MOD 998244353LL\n#define EPSILON 0.00001\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n \n#define FOR(i, a, b) for (ll i=(a); i<=(signed)(b); i++)\n#define F0R(i, a) for (ll i=0; i<(signed)(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 100005\nint n;\nint m[3];\nvi e[3][MN];\nll lol;\nll exps[MN];\n\nint tch[3][MN];\nll sm[3];\nll ot[3];\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    lol = 1000000000000000000LL % MOD;\n    //lol = 3;\n    exps[0] = 1;\n    FOR(i, 1, MN-2){\n        exps[i] = (exps[i-1]*lol)%MOD;\n    }\n    cin >> n;\n    F0R(i, 3){\n        cin >> m[i];\n        F0R(_, m[i]){\n            int u, v;\n            cin >> u >> v;\n            e[i][u].pb(v);\n            e[i][v].pb(u);\n        }\n    }\n    \n    /*ll sm = 0;\n    RFOR(i, n, 1){\n        if(tch[i]){\n            sm = (sm+exps[i])%MOD;\n        } else{\n            for(auto u : e[0][i]) if(u < i){\n                tch[u] = true;\n            }\n        }\n    }*/\n    ll totsm = 0;\n    FOR(i, 1, n) totsm = (totsm+exps[i])%MOD;\n\n    F0R(i, 3){\n        //cout << \"doing \" << i << \"\\n\";\n        RFOR(cn, n, 1){\n            if(tch[i][cn] == 3){\n                //cout << cn << \" bad\\n\";\n                continue;\n            } else if(tch[i][cn] == 2){\n                //cout << cn << \" ok\\n\";\n                ot[i] += exps[cn];\n                ot[i] %= MOD;\n                for(auto nn : e[i][cn]) if(nn < cn){\n                    if(tch[i][nn] % 2 == 0) tch[i][nn]++;\n                }\n            } else{\n                //cout << cn << \" good\\n\";\n                sm[i] += exps[cn];\n                sm[i] %= MOD;\n                for(auto nn : e[i][cn]) if(nn < cn){\n                    if(tch[i][nn] < 2) tch[i][nn] += 2;\n                }\n            }\n        }\n        //cout << sm[i] << \" \" << ot[i] << \"\\n\";\n    }\n    /*ll ans = ((sm[0]*sm[1])%MOD*sm[2])%MOD;\n    ans += ((sm[0]*ot[1])%MOD*ot[2])%MOD;\n    ans %= MOD;\n    ans += ((ot[0]*sm[1])%MOD*ot[2])%MOD;\n    ans %= MOD;\n    ans += ((ot[0]*ot[1])%MOD*sm[2])%MOD;\n    ans %= MOD;\n    ll rltot = ((totsm*totsm)%MOD*totsm)%MOD;\n    cout << ans << \" \" << rltot << \"\\n\";\n    cout << (rltot-ans+MOD)%MOD << \"\\n\";*/\n    ll ans = ((sm[0]*sm[1])%MOD*sm[2])%MOD;\n    ans += ((sm[0]*ot[1])%MOD*ot[2])%MOD;\n    ans %= MOD;\n    ans += ((ot[0]*sm[1])%MOD*ot[2])%MOD;\n    ans %= MOD;\n    ans += ((ot[0]*ot[1])%MOD*sm[2])%MOD;\n    ans %= MOD;\n    cout << ans << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nll mod = 998244353;\n\nll modpower(ll a, ll r){ //a^r\n    ll x = 1;\n    a %= mod;\n    while (r > 0) {\n        if (r & 1) x = x * a % mod;\n        r >>= 1;\n        a = a * a % mod;\n    }\n    return x;\n}\n\nll modinv(ll a){\n    return modpower(a, mod-2);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> M(3);\n    vector<vector<vector<int>>> edge(3, vector<vector<int>>(N+1));\n    for (int i = 0; i < 3; i++) {\n        cin >> M[i];\n        for (int j = 0; j < M[i]; j++) {\n            int a, b;\n            cin >> a >> b;\n            edge[i][b].push_back(a);\n            edge[i][a].push_back(b);\n        }\n    }\n    \n    ll q = 1e18;\n    q %= mod;\n    vector<ll> pow10(N+1, 1);\n    for (int i = 1; i <= N; i++) {\n        pow10[i] = pow10[i-1] * q % mod;\n    }\n    \n    vector<bool> xuse(N+1, true), xuse2(N+1, true);\n    for (int i = N; i >= 1; i--) {\n        for(int t : edge[0][i]) {\n            if (t < i) continue;\n            if (xuse[t]) xuse[i] = false;\n            if (xuse2[t]) xuse2[i] = false;\n        }\n        if (xuse[i]) xuse2[i] = false;\n    }\n    \n    ll x1= 0, x2 = 0;\n    for (int i = 1; i <= N; i++) {\n        if (xuse[i]) {\n            x1 += pow10[i];\n            x1 %= mod;\n        }\n        if (xuse2[i]) {\n            x2 += pow10[i];\n            x2 %= mod;\n        }\n    }\n    \n    vector<bool> yuse(N+1, true), yuse2(N+1, true);\n    for (int i = N; i >= 1; i--) {\n        for(int t : edge[1][i]) {\n            if (t < i) continue;\n            if (yuse[t]) yuse[i] = false;\n            if (yuse2[t]) yuse2[i] = false;\n        }\n        if (yuse[i]) yuse2[i] = false;\n    }\n    \n    ll y1= 0, y2 = 0;\n    for (int i = 1; i <= N; i++) {\n        if (yuse[i]) {\n            y1 += pow10[i] * x1;\n            y2 += pow10[i] * x2;\n            y1 %= mod;\n            y2 %= mod;\n        }\n        if (yuse2[i]) {\n            y1 += pow10[i] * x2;\n            y2 += pow10[i] * x1;\n            y1 %= mod;\n            y2 %= mod;\n        }\n    }\n    \n    vector<bool> zuse(N+1, true), zuse2(N+1, true);\n    for (int i = N; i >= 1; i--) {\n        for(int t : edge[2][i]) {\n            if (t < i) continue;\n            if (zuse[t]) zuse[i] = false;\n            if (zuse2[t]) zuse2[i] = false;\n        }\n        if (zuse[i]) zuse2[i] = false;\n    }\n    \n    ll z1= 0, z2 = 0;\n    for (int i = 1; i <= N; i++) {\n        if (zuse[i]) {\n            z1 += pow10[i] * y1;\n            z2 += pow10[i] * y2;\n            z1 %= mod;\n            z2 %= mod;\n        }\n        if (zuse2[i]) {\n            z1 += pow10[i] * y2;\n            z2 += pow10[i] * y1;\n            z1 %= mod;\n            z2 %= mod;\n        }\n    }\n    cout << z1%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define TR(X) ({ if(1) cerr << \"TR: \" << (#X) << \" = \" << (X) << endl; })\n\n// const ll N = 3e5 + 10, MOD = 998244353*1e9, A = 100;\nconst ll N = 3e5 + 10, MOD = 998244353, A = ll(1e18) % MOD;\nll Apow[N];\n\nconst ll HALF = (MOD+1)/2;\n\nvl transform(vl A, bool inverse = false) {\n\tll N = sz(A);\n\tvl B(N,0);\n\tfor(ll p = 1; p < N; p *= 2){\n\t\tFOR(i,0,N)B[i] = (((i&p)?-A[i]:A[i]) + A[i^p]) % MOD;\n\t\tif(inverse) FOR(i,0,N) B[i] = (B[i] * HALF)%MOD;\n\t\tswap(A,B);\n\t}\n\treturn A;\n}\n\nvl multiply(vl p, vl q) {\n\tint N = 1;\n\twhile(N < max(sz(p), sz(q))) N *= 2;\n\tp.resize(N, 0);\n\tq.resize(N, 0);\n\tp = transform(p),\tq = transform(q);\n\tvector<ll> pq(N);\n\tFOR(i,0,N) pq[i] = (p[i] * q[i]) % MOD;\n\treturn transform(pq, true);\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tApow[0] = 1;\n\tFOR(i,1,N) Apow[i] = A*Apow[i-1] % MOD;\n\n\tll n; cin >> n;\n\t\n\tll N = 1;\n\twhile (N < n) N *= 2;\n\n\tvl u(N);\n\tu[0] = 1;\n\t\n\tFOR(dim,0,3) {\n\t\tll m; cin >> m;\n\t\tvvl adj(n);\n\t\twhile (m--) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tif (a > b) swap(a,b);\n\t\t\tadj[a].pb(b);\n\t\t}\n\t\n\t\tvl col(n);\n\t\tFORD(i,0,n) {\n\t\t\tset<ll> s;\n\t\t\tfor (ll j: adj[i]) s.insert(col[j]);\n\t\t\twhile (s.count(col[i])) col[i]++;\n\t\t}\n\n\t\tvl v(N);\n\t\tFOR(i,0,n) v[col[i]] = (v[col[i]] + Apow[i+1]) % MOD;\n\t\t\n\t\tu = multiply(u,v);\n\n\t\t// cerr << u[0] << \" \" << u[1] << endl;\n\t}\n\n\tll res = u[0];\n\tif (res < 0) res += MOD;\n\tcout << res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#define mod 998244353\n#define inv2 499122177\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100005;\ninline int readint()\n{\n\tint res = 0, f = 1;\n\tchar c = 0;\n\twhile(!isdigit(c))\n\t{\n\t\tc = getchar();\n\t\tif(c=='-')\n\t\t\tf = -1;\n\t}\n\twhile(isdigit(c))\n\t\tres = res*10+c-'0', c = getchar();\n\treturn res*f;\n}\ninline ll qpow(ll a, int b)\n{\n\tll res = 1;\n\tfor(; b; a = a*a%mod, b >>= 1)\n\t    if(b&1)\n\t        res = res*a%mod;\n\treturn res;\n}\nstruct Node\n{\n\tint u,v;\n\tNode *next;\n}pool[MAXN<<3],*h[4][MAXN];\nint n,m[4],deg[4][MAXN],tot;\ninline void addEdge(int id, int u, int v)\n{\n\tNode *p = &pool[++tot];\n    p->v = v, p->next = h[id][u], h[id][u] = p;\n    deg[id][v]++;\n}\nint sg[4][MAXN];\nll f[4][270005];\nvector<int> num[4][MAXN];\ninline void calc(int id, int u)\n{\n\tif(sg[id][u]>=0)\n\t    return;\n\tsg[id][u] = 0;\n\tfor(Node *p = h[id][u]; p; p = p->next)\n\t{\n        calc(id,p->v);\n        num[id][u].push_back(sg[id][p->v]);\n\t}\n\tsort(num[id][u].begin(),num[id][u].end());\n\tfor(int i = 0; i<num[id][u].size(); i++)\n\t    if(sg[id][u]==num[id][u][i])\n\t        sg[id][u]++;\n}\ninline void fwt(ll *a, int deg)\n{\n\tll u,t;\n\tfor(int i = 1; i<deg; i <<= 1)\n\t    for(int j = 0; j<deg; j += i<<1)\n\t        for(int k = j; k<j+i; k++)\n\t        {\n\t            u = a[k], t = a[k+i];\n\t            a[k] = (u+t)%mod, a[k+i] = (u-t+mod)%mod;\n\t\t\t}\n}\ninline void ifwt(ll *a, int deg)\n{\n    ll u,t;\n\tfor(int i = 1; i<deg; i <<= 1)\n\t    for(int j = 0; j<deg; j += i<<1)\n\t\t    for(int k = j; k<j+i; k++)\n\t\t\t{\n\t            u = a[k], t = a[k+i];\n\t            a[k] = (u+t)*inv2%mod, a[k+i] = (u-t+mod)*inv2%mod;\n\t\t\t}\n}\n\nint main()\n{\n    n = readint();\n    for(int i = 1; i<=3; i++)\n    {\n        m[i] = readint();\n        for(int j = 1; j<=m[i]; j++)\n        {\n            int u = readint(), v = readint();\n            addEdge(i,min(u,v),max(u,v)); \n\t\t}\n\t}\n\tmemset(sg,-1,sizeof(sg));\n\tfor(int i = 1; i<=3; i++)\n\t    for(int j = 1; j<=n; j++)\n\t\t    if(!deg[i][j])\n\t\t\t    calc(i,j);\n\tfor(int i = 1; i<=3; i++)\n        for(int j = 1; j<=n; j++)\n\t\t\tf[i][sg[i][j]] += qpow(qpow(10,18),j);\n\tfor(int i = 1; i<=3; i++)\n        fwt(f[i],262144);\n    for(int i = 0; i<262144; i++)\n        f[1][i] = f[1][i]*f[2][i]%mod*f[3][i]%mod;\n    ifwt(f[1],262144);\n    cout << f[1][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define mod 998244353\n\nusing namespace std;\n\nllint n;\nvector<llint> G[3][100005];\nllint base, beki[300005];\nllint grundy[3][100005];\nllint a[3][1<<9];\n\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid get(vector<llint> G[], llint grundy[])\n{\n\tfor(int i = n; i >= 1; i--){\n\t\tset<llint> S;\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tS.insert(grundy[G[i][j]]);\n\t\t}\n\t\twhile(S.count(grundy[i])) grundy[i]++;\n\t}\n}\n\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tllint m;\n\tfor(int i = 0; i < 3; i++){\n\t\tcin >> m;\n\t\tllint u, v;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tcin >> u >> v;\n\t\t\tif(u > v) swap(u, v);\n\t\t\tG[i][u].push_back(v);\n\t\t}\n\t}\n\t\n\tbase = modpow(10, 18);\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 300005; i++) beki[i] = beki[i-1] * base % mod;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tget(G[i], grundy[i]);\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\ta[i][grundy[i][j]] += beki[j];\n\t\t\ta[i][grundy[i][j]] %= mod;\n\t\t}\n\t}\n\t\n\tllint N = 1<<9, ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tans += a[0][i] * a[1][j] % mod * a[2][i^j] % mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst ll M=400;\nconst ll val=(1000000000000000000)%mod;\nint n;\nint tmp[100000][M];\n\nvvi f(){\n\tvvi g(n);\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tg[u].push_back(v);\n\t}\n\treturn g;\n}\n\nint main(){\n\tcin>>n;\n\tvvi g1=f(),g2=f(),g3=f();\n\tvi used(n),gra(n);\n\tvl c,cost(M);\n\twhile(used!=vi(n,1)){\n\t\tvi b(n);\n\t\tfor(int i=n-1;i>=0;i--) if(!used[i]){\n\t\t\tbool flag=1;\n\t\t\tfor(auto j:g1[i]) if(b[j]) flag=0;\n\t\t\tif(flag){\n\t\t\t\tb[i]++;\n\t\t\t\tused[i]++;\n\t\t\t}\n\t\t}\n\t\tll t=1,s=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t(t*=val)%=mod;\n\t\t\t(s+=t*b[i])%=mod;\n\t\t}\n\t\tc.push_back(s);\n\t}\n\tfor(int i=0;i<M;i++){\n\t\ttmp[n-1][i]=1;\n\t\tvi a(n);\n\t\ta[n-1]=i;\n\t\tfor(int j=n-2;j>=0;j--){\n\t\t\tfor(auto k:g2[j]) tmp[j][a[k]]++;\n\t\t\tfor(int k=0;k<M;k++) if(!tmp[j][k]){\n\t\t\t\ttmp[j][k]++;\n\t\t\t\ta[j]=k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(auto k:g2[j]) tmp[j][a[k]]--;\n\t\t}\n\t\tll t=1;\n\t\tfor(int j=0;j<n;j++){\n\t\t\t(t*=val)%=mod;\n\t\t\tif(a[j]<c.size()) (cost[i]+=c[a[j]]*t)%=mod;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=0;i--){\n\t\tset<int> st;\n\t\tfor(auto j:g3[i]) st.insert(gra[j]);\n\t\tfor(int j=0;;j++) if(st.find(j)==st.end()){\n\t\t\tgra[i]=j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tll t=1,res=0;\n\tfor(int i=0;i<n;i++){\n\t\t(t*=val)%=mod;\n\t\t(res+=cost[gra[i]]*t)%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 0;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  vector<long long> ary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    set<int> usable;\n    for(int i = 1; i<N+1; ++i) {\n      usable.insert(i);\n    }\n    while(!usable.empty()) {\n      set<int> u = usable;\n      long long curr = 0;\n      while(!u.empty()) {\n        auto it = u.end();\n        it--;\n        int next = *it;\n        curr = (curr + pows[next]) % MOD;\n        for(int i = 0; i<adj[next].size(); ++i) {\n          u.erase(adj[next][i]);\n        }\n        u.erase(next);\n        usable.erase(next);\n      }\n      ary[graph].push_back(curr);\n    }\n  }\n\n  for(int i = 0; i<min(min(ary[0].size(), ary[1].size()), ary[2].size()); ++i) {\n    long long add = 0;\n    if(i % 2 == 0) {\n      add = ((ary[0][i] * ary[1][i]) % MOD) * ary[2][i];\n    }\n    else {\n      add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][i-1] + ((ary[0][i] * ary[1][i-1])%MOD) * ary[2][i] + ((ary[0][i-1] * ary[1][i])%MOD) * ary[2][i];\n    }\n    ret = (ret + add) % MOD;\n  }\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst ll M=100;\nconst ll val=(1000000000000000000)%mod;\nint n;\n\nvvi f(){\n\tvvi g(n);\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tg[u].push_back(v);\n\t}\n\treturn g;\n}\n\nint main(){\n\tcin>>n;\n\tvvi g1=f(),g2=f(),g3=f();\n\tvi used(n),gra(n);\n\tvl c,cost(M);\n\twhile(used!=vi(n,1)){\n\t\tvi b(n);\n\t\tfor(int i=n-1;i>=0;i--) if(!used[i]){\n\t\t\tbool flag=1;\n\t\t\tfor(auto j:g1[i]) if(b[j]) flag=0;\n\t\t\tif(flag){\n\t\t\t\tb[i]++;\n\t\t\t\tused[i]++;\n\t\t\t}\n\t\t}\n\t\tll t=1,s=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t(t*=val)%=mod;\n\t\t\t(s+=t*b[i])%=mod;\n\t\t}\n\t\tc.push_back(s);\n\t}\n\tvi d(n);\n\tfor(int i=n-1;i>=0;i--){\n\t\tset<int> st;\n\t\tfor(auto j:g2[i]) st.insert(d[j]);\n\t\tfor(int j=0;;j++) if(st.find(j)==st.end()){\n\t\t\td[i]=j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=0;i--){\n\t\tset<int> st;\n\t\tfor(auto j:g3[i]) st.insert(gra[j]);\n\t\tfor(int j=0;;j++) if(st.find(j)==st.end()){\n\t\t\tgra[i]=j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tll tmp=1,res=0;\n\tfor(int i=0;i<n;i++){\n\t\t(tmp*=val)%=mod;\n\t\tll t=tmp;\n\t\tfor(int j=0;j<n;j++){\n\t\t\t(t*=val)%=mod;\n\t\t\tint id=d[i]^gra[j];\n\t\t\tif(id<c.size()) (res+=c[id]*t)%=mod;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define LL long long\n#define ULL unsigned long long \n#define y second\n#define sqr(x) ((x)*(x))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pdd pair<double,double>\n#define MEM(x) memset(x,0,sizeof(x))\n#define pi acos(-1)\n#define MEMS(x) memset(x,-1,sizeof(x))\nusing namespace std;\nint val[3][100005];\nvector<int> v[3][100005];\nvector<int> num[3][100005];\nint number=716070898;\nint mod=998244353;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nint test[10][10][10];\nvoid T(){\n    //queue<tuple<int,int,int> > q;\n    //q.push(mp(0,0,0));\n    int n=10;\n    while(true){\n        int Min=1e9,x,y,z;\n        for(int i = 0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<n;k++){\n                    if(!test[i][j][k]){\n                        if(i+j+k<Min){\n                            Min=i+j+k;\n                            x=i;\n                            y=j;\n                            z=k;\n                        }\n                    }\n                }\n            }\n        }\n        if(Min==1e9)break;\n        printf(\"%d %d %d\\n\",x,y,z);\n        for(int i = 0;i<n;i++){\n            test[x][y][i]=1;\n            test[x][i][z]=1;\n            test[i][y][z]=1;\n        }\n    }\n}\nint main(){ \n   // T();\n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 0;i<3;i++){\n        int m;\n        scanf(\"%d\",&m);\n        for(int j =0;j<m;j++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            if(x>y)swap(x,y);\n            v[i][x].pb(y);\n        }\n        for(int j = n;j>=1;j--){\n            vector<int> arr;\n            for(auto it:v[i][j]){\n                arr.pb(val[i][it]);\n            }\n            sort(arr.begin(),arr.end());\n            arr.resize(unique(arr.begin(),arr.end())-arr.begin());\n            val[i][j]=arr.size();\n            for(int k = 0;k<arr.size();k++){\n                if(arr[k]!=k){\n                    val[i][j]=k;\n                    break;\n                }\n            }\n           // if(val[i][j]<2){\n            num[i][val[i][j]].pb(j);\n            //}\n        }\n    }\n    LL ans=0;\n    LL val[3][100005];//,b[2]={0,0},c[2]={0,0};\n    LL sum[3];\n    MEM(val);\n    MEM(sum);\n    for(int i =0;i<3;i++){\n        for(int j=0;j<100005;j++){\n            for(auto it:num[i][j]){\n                val[i][j]+=f_pow(number,it);\n                val[i][j]%=mod;\n            }\n            if(j>1)sum[i]+=val[i][j],sum[i]%=mod;\n        }\n    }\n    ans+=val[0][0]*val[1][0]%mod*val[2][0]%mod;\n    for(int j=1;j<100005;j++){\n        ans+=val[0][0]*val[1][j]%mod*val[2][j]%mod;\n        ans+=val[0][j]*val[1][0]%mod*val[2][j]%mod;\n        ans+=val[0][j]*val[1][j]%mod*val[2][0]%mod;\n       /* if(j>1){\n            ans-=val[0][1]*val[1][j]%mod*val[2][j]%mod;\n            ans-=val[0][j]*val[1][1]%mod*val[2][j]%mod;\n            ans-=val[0][j]*val[1][j]%mod*val[2][1]%mod;\n        }*/\n        ans%=mod;\n    }\n    for(int j = 2;j<100001;j+=2){\n        ans+=val[0][1]*val[1][j]%mod*val[2][j+1]%mod;\n        ans+=val[0][1]*val[2][j]%mod*val[1][j+1]%mod;\n        ans+=val[1][1]*val[0][j]%mod*val[2][j+1]%mod;\n        ans+=val[1][1]*val[2][j]%mod*val[0][j+1]%mod;\n        ans+=val[2][1]*val[1][j]%mod*val[0][j+1]%mod;\n        ans+=val[2][1]*val[0][j]%mod*val[1][j+1]%mod;\n        ans%=mod;\n\n    }\n    ans=(ans%mod+mod)%mod;\n    printf(\"%lld\\n\",ans);\n    /*\n    for(int i = 0;i<num[0][0].size();i++){\n        a[0]+=f_pow(number,num[0][0][i]);\n        a[0]%=mod;\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][0][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][1][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][0][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][1][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }*/\n    //printf(\"%lld\\n\",ans);\n}\n/*\n\n5\nAACCMMAA\nA\nAA\nMM\nACA\nACMAA\n\n\n5\n0 9 7 1 100\n-1 0 -1 -1 91\n-1 5 0 -1 96\n-1 8 9 0 99\n-1 -1 -1 -1 0\n3 4\n3 5\n5 6\n5 7\n3 or 4\n3 or 5\n5 or 6\n5 or 7\n\ndp[x]=max(dp[x-w_i*j]+j*t_i-delta t_i*j*(j-1)/2)\ndp[x]=max(dp[j]+x*t_i-j*t_i-delta t_i*(x-j)*(x-j-1)/2)\ndp[x]=max(dp[j]-j*t_i-delta t_i *(j^2/2+j/2) - \n        delta t_i * xj + x*t_i + delta t_i * (x^2/2-x/2))\ndp[x]=max(dp[j] + g(j) - delta t_i *xj + w(i) )\ng(j)= dp[j]-j*t_i-delta t_i *(j^2/2+j/2)\nw(i)=  x*t_i + delta t_i * (x^2/2-x/2)\nx^2/2 -xj -x/2  +j^2/2 +j/2\n*/\n\n/*\n \n\n*/"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\n\n\nint xy[410][410],xz[410][410],yz[410][410];\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vector<int> d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,310000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g1[i]){\n            if(e>i)se.insert(d1[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d1[i]=gr;\n        D1[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g2[i]){\n            if(e>i)se.insert(d2[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d2[i]=gr;\n        D2[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g3[i]){\n            if(e>i)se.insert(d3[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d3[i]=gr;\n        D3[gr] += P[i];\n    }\n    vec a,b;\n    mint ans;\n    int k1=0,k2=0,k3=0;\n    rep(i,400){\n        rep(j,400){\n            if(i>n or j>n )break;\n            ans+=D1[i]*D2[j]*D3[i^j];\n        }\n    }\n\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll a, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nconst int max_n = 10000;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\nmodint t10[1 << 22];\nvoid init() {\n\tt10[0] = 1;\n\trep(i, (1 << 22)-1) {\n\t\tt10[i + 1] = t10[i] * (modint)10;\n\t}\n}\n\nint mex(vector<int> &v) {\n\tsort(all(v));\n\tv.erase(unique(all(v)), v.end());\n\trep(i, v.size())if (i != v[i])return i;\n\treturn v.size();\n}\nvector<int> G[3][1 << 17];\nint grandy[3][1 << 17];\nmodint sum[3][320];\nvoid solve() {\n\tinit();\n\tint n; cin >> n;\n\trep(t, 3) {\n\t\tint m; cin >> m;\n\t\trep(i, m) {\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tG[t][b].push_back(a);\n\t\t\tG[t][a].push_back(b);\n\t\t}\n\t\tper(i, n) {\n\t\t\tvector<int> v;\n\t\t\tfor (int to : G[t][i]) {\n\t\t\t\tif (to > i) {\n\t\t\t\t\tv.push_back(grandy[t][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrandy[t][i] = mex(v);\n\t\t\tsum[t][grandy[t][i]] += t10[18*(i+1)];\n\t\t}\n\t}\n\tmodint ans = 0;\n\trep(i, 320)rep(j, 320)rep(k, 320) {\n\t\tint x = i ^ j^k;\n\t\tif (x == 0) {\n\t\t\tans += sum[0][i] * sum[1][j] * sum[2][k];\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <ratio>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#include <cassert>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\ninline void ModMul(int& x, int y)\n{\n    x = (1LL * x * y) % MOD;\n}\n\ninline int GetModMul(int x, int y)\n{\n    ModMul(x, y);\n    return x;\n}\n\ninline void ModSum(int& x, int y)\n{\n    x += y;\n    if (x < 0) {\n        x += MOD;\n    }\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\ninline int GetModSum(int x, int y)\n{\n    ModSum(x, y);\n    return x;\n}\n\nconst int MAX_N = 1e5;\n\nint bases[MAX_N + 1];\n\nvoid Prepare()\n{\n    bases[0] = 1;\n    bases[1] = 1;\n    for (int i = 0; i < 18; ++i) {\n        ModMul(bases[1], 10);\n    }\n    for (int i = 2; i <= MAX_N; ++i) {\n        bases[i] = GetModMul(bases[i - 1], bases[1]);\n    }\n}\n\nint n;\nvector<vector<int>> g[3];\nvector<bool> used[3];\nset<int> vs[3];\n\nvoid MarkUsed(int index, int v)\n{\n    assert(!used[index][v]);\n    used[index][v] = true;\n    auto erased = vs[index].erase(v);\n    assert(erased);\n}\n\ntemplate <class TFunction>\nvoid ForEachNeighbor(\n    int index,\n    int v,\n    TFunction&& f)\n{\n    for (size_t i = 0; i < g[index][v].size(); ) {\n        auto u = g[index][v][i];\n        if (used[index][u]) {\n            g[index][v][i] = g[index][v].back();\n            g[index][v].pop_back();\n            continue;\n        }\n        f(u);\n        ++i;\n    }\n}\n\nint GetSum(int index)\n{\n    unordered_set<int> forbidden;\n    unordered_set<int> newUsed;\n    for (auto it = vs[index].rbegin(); it != vs[index].rend(); ++it) {\n        auto v = *it;\n        if (forbidden.find(v) == forbidden.end()) {\n            newUsed.insert(v);\n            ForEachNeighbor(index, v, [&] (int u) {\n                forbidden.insert(u);\n            });\n        }\n    }\n    assert(newUsed.size() > 0);\n    int sum = 0;\n    for (auto v : newUsed) {\n        ModSum(sum, bases[v + 1]);\n        MarkUsed(index, v);\n    }\n    return sum;\n}\n\nvector<int> GetSums(int index)\n{\n    vs[index].clear();\n    used[index].assign(n, false);\n    for (int j = 0; j < n; ++j) {\n        vs[index].insert(j);\n    }\n    vector<int> result;\n    while (vs[index].size() > 0) {\n        result.push_back(GetSum(index));\n    }\n    return result;\n}\n\nvoid Solve()\n{\n    vector<int> sums[3];\n    for (int i = 0; i < 3; ++i) {\n        sums[i] = GetSums(i);\n    }\n    int result = 0;\n    for (int i = 0; i < (int) sums[1].size(); ++i) {\n        for (int j = 0; j < (int) sums[2].size(); ++j) {\n            int k = i ^ j;\n            if (k < (int) sums[0].size()) {\n                ModSum(result, GetModMul(GetModMul(sums[1][i], sums[2][j]), sums[0][k]));\n            }\n        }\n    }\n    cout << result << endl;\n}\n\nbool Read()\n{\n    if (!(cin >> n)) {\n        return false;\n    }\n    for (int i = 0; i < 3; ++i) {\n        g[i].clear();\n        g[i].resize(n);\n        int m;\n        cin >> m;\n        for (int j = 0; j < m; ++j) {\n            int a, b;\n            cin >> a >> b;\n            --a;\n            --b;\n            g[i][a].push_back(b);\n            g[i][b].push_back(a);\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);\n\n    Prepare();\n\n    while (Read()) {\n        Solve();\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ff first\n#define ss second\n#define pii pair<int, int>\n#define pb emplace_back\n#define pf emplace_front\n#define mp make_pair\n#define ld long double\n#define all(x) x.begin(), x.end()\n#define uniq(x) sort(all(x)), x.resize(unique(all(x)) - x.begin())\n\n//random_device rd;\n//mt19937_64 gen(rd());\n//\n//template<typename T>\n//T rand(T l, T r) {\n//    uniform_int_distribution<T> uid(l, r);\n//    return uid(gen);\n//}\n\nconst int maxn = 1e5 + 9;\nvector<int> g[3][maxn];\nint c[3][maxn];\nint n;\nint mod = 998244353;\nint p[maxn];\nvector<int> w[3];\nint ans;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    p[0] = 1;\n    p[1] = ((int)1e18) % mod;\n    for (int i = 2; i < maxn; i++)\n        p[i] = (p[i - 1] * p[1]) % mod;\n    cin >> n;\n    for (int j = 0; j < 3; j++)\n    {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++)\n        {\n            int a, b;\n            cin >> a >> b;\n            a--, b--;\n            g[j][a].pb(b);\n            g[j][b].pb(a);\n        }\n        int kek = 0;\n        int t = 0;\n        while (kek != n)\n        {\n            t++;\n            for (int i = n - 1; i >= 0; i--)\n            {\n                if (c[j][i])\n                    continue;\n                bool fl = 0;\n                for (int to : g[j][i])\n                {\n                    if (c[j][to] == t)\n                        fl = 1;\n                }\n                if (!fl)\n                {\n                    c[j][i] = t;\n                    if (w[j].size() < t + 1)\n                        w[j].resize(t + 1, 0);\n                    w[j][t] = (w[j][t] + p[i + 1]) % mod;\n                    kek++;\n                }\n            }\n        }\n//        for (int i = 0; i < n; i++)\n//            cout << c[j][i] << \" \";\n//        cout << \"\\n\";\n    }\n    vector<vector<int> > q;\n    for (int a = 0; a < 3; a++)\n        for (int b = 0; b < 3; b++)\n            for (int c = 0; c < 3; c++)\n    {\n        if (a != b && b != c && a != c)\n        {\n            vector<int> cur = {a, b, c};\n            q.pb(cur);\n        }\n    }\n    set<pii> used;\n    int sz = max(max(w[0].size(), w[1].size()), w[2].size());\n    for (int a = 1; a < sz; a++)\n    {\n        for (int b = 1; b <= a; b++)\n        {\n            if (used.find(mp(a, b)) != used.end())\n                continue;\n            for (int c = 1; c <= b; c++)\n            {\n                if (used.find(mp(a, c)) != used.end())\n                    continue;\n                if (used.find(mp(b, c)) != used.end())\n                    continue;\n\n                bool fl = 0;\n                for (auto u : q)\n                {\n                    vector<int> polina;\n                    bool U[3] = {};\n                    bool fll = 1;\n                    for (int r = 0; r < 3; r++)\n                    {\n                        if (u[r] == 0)\n                        {\n                            polina.pb(a);\n                            if (a == b && U[1])\n                                fll = 0;\n                            U[0] = 1;\n                        }\n                        else if (u[r] == 1)\n                        {\n                            polina.pb(b);\n                            if (b == c && U[2])\n                                fll = 0;\n                            U[1] = 1;\n                        }\n                        else\n                        {\n                            polina.pb(c);\n                            U[2] = 1;\n                        }\n\n                    }\n                    if (!fll)\n                        continue;\n                    int cur = 1;\n\n                    if ((int)w[0].size() > polina[0])\n                        cur = (cur * w[0][polina[0]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[1].size() > polina[1])\n                        cur = (cur * w[1][polina[1]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[2].size() > polina[2])\n                        cur = (cur * w[2][polina[2]]) % mod;\n                    else\n                        fll = 0;\n\n                    if (fll)\n                    {\n                        ans = (ans + cur) % mod;\n                        fl = 1;\n                    }\n                }\n                if (fl)\n                {\n//                    cout << a << \" \" << b << \" \" << c << \"\\n\";\n                    used.emplace(a, b);\n                    used.emplace(a, c);\n                    used.emplace(b, c);\n                }\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nlld arr[300000];\nvector<lld> adj[300000][3];\nar<lld,3> siz;\nlld grundy[300000][3];\nmap<lld,lld> sums[3];\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nvoid dfs_grundy(lld node,lld grp){\n    if (grundy[node][grp]!=-1)return ;\n  //  grundy[node][grp]=0;\n    vector<lld> mex;\n    //nums[0][grp]++;\n    for (auto it:adj[node][grp]){\n        if (it<node) continue;\n        dfs_grundy(it,grp);\n        mex.pb(grundy[it][grp]);\n    }\n    if (mex.empty()) {grundy[node][grp]=0;sums[grp][0]+=fastpower(10,18*(node+1),modd);sums[grp][0]%=modd;return;}\n    sort(all(mex));\n    auto ip = unique(all(mex));\n    mex.resize(distance(mex.begin(),ip));\n    rep(i,0,mex.size()-1){\n        if (i!=mex[i]){\n            grundy[node][grp]=i;\n        //    nums[0][grp]--;\n      //      nums[i][grp]++;\n            sums[grp][i]+=fastpower(10,18*(node+1),modd);sums[grp][i]%=modd;\n            return ;\n        }\n    }\n    grundy[node][grp]=mex.size();\n    //nums[0][grp]--;\n    //nums[mex.size()][grp]++;\n    sums[grp][mex.size()]+=fastpower(10,18*(node+1),modd);sums[grp][mex.size()]%=modd;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,r,k,c,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n//     ans=0;\n     //cin>>TESTS;\n     memset(grundy,-1,sizeof(grundy));\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(j,0,2){\n         cin>>siz[j];\n         rep(i,0,siz[j]-1){\n            cin>>a>>b;a--;b--;\n            adj[a][j].pb(b);\n            adj[b][j].pb(a);\n         }\n         }\n         rep(j,0,2) rep(i,0,n-1) dfs_grundy(i,j);\n         lld ans=0;\n         rep(i,0,1000) rep(j,0,1000) {\n            lld k=i^j;\n            if(k<sums[2].size())ans+=(((sums[0][i]*sums[1][j])%modd)*sums[2][k])%modd;\n            ans%=modd;\n         }\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits_stdc++.h\"\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a; swap(a, m);\n        u -= t * v; swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n    using u64 = std::uint_fast64_t;\n\npublic:\n    u64 a;\n\n    constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n    constexpr u64 &value() noexcept { return a; }\n    constexpr const u64 &value() const noexcept { return a; }\n    constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint &operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n            a -= Modulus;\n        }\n        return *this;\n    }\n    constexpr modint &operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n            a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n    }\n    constexpr modint &operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept {\n        u64 exp = Modulus - 2;\n        while (exp) {\n            if (exp % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            exp /= 2;\n        }\n        return *this;\n    }\n};\nint main() {\n    using Mint = modint<998244353>;\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n    for (int r = 0; r < 3; r++) {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            --x; --y;\n            if (x > y) {\n                swap(x, y);\n            }\n            g[r][x].push_back(y);\n        }\n    }\n    Mint p = (long long) 1e18;\n    vector<Mint> pw(n);\n    pw[0] = p;\n    for (int i = 1; i < n; i++) {\n        pw[i] = pw[i - 1] * p;\n    }\n    const int MAX = 512;\n    vector<vector<Mint>> cnt(3, vector<Mint>(MAX));\n    for (int r = 0; r < 3; r++) {\n        vector<int> gr(n);\n        for (int i = n - 1; i >= 0; i--) {\n            set<int> s;\n            for (int j : g[r][i]) {\n                s.insert(gr[j]);\n            }\n            while (s.find(gr[i]) != s.end()) {\n                ++gr[i];\n            }\n            cnt[r][gr[i]] += pw[i];\n        }\n    }\n    Mint ans = 0;\n    for (int x = 0; x < MAX; x++) {\n        for (int y = 0; y < MAX; y++) {\n            ans += cnt[0][x] * cnt[1][y] * cnt[2][x ^ y];\n        }\n    }\n    cout << ans.a << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 0;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  vector<long long> ary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    set<int> usable;\n    for(int i = 1; i<N+1; ++i) {\n      usable.insert(i);\n    }\n    while(!usable.empty()) {\n      set<int> u = usable;\n      long long curr = 0;\n      while(!u.empty()) {\n        auto it = u.end();\n        it--;\n        int next = *it;\n        curr = (curr + pows[next]) % MOD;\n        for(int i = 0; i<adj[next].size(); ++i) {\n          u.erase(adj[next][i]);\n        }\n        u.erase(next);\n        usable.erase(next);\n      }\n      ary[graph].push_back(curr);\n    }\n  }\n\n  ret = ((ary[0][0] * ary[1][0]) % MOD) * ary[2][0];\n  ret = (ret % MOD);\n  for(int i = 1; i<min(ary[0].size(), ary[1].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0];\n    ret = (ret + add) % MOD;\n  }\n  for(int i = 1; i<min(ary[0].size(), ary[2].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][i] * ary[1][0])%MOD) * ary[2][i];\n    ret = (ret + add) % MOD;\n  }\n  for(int i = 1; i<min(ary[1].size(), ary[2].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n    ret = (ret + add) % MOD;\n  }\n\n  for(int i = 1; i<ary[0].size(); ++i) {\n    set<int> kk;\n    for(int k = 1; k<ary[2].size(); ++k) kk.insert(k);\n    for(int j = i+1; j<ary[1].size(); ++j) {\n      for(auto k : kk) {\n        if(i == j || j == k || i ==k) continue;\n        long long add = ((ary[0][i] * ary[1][j]) % MOD) * ary[2][k];\n        ret = (ret + add) % MOD;\n        kk.erase(k);\n        break;\n      }\n    }\n  }\n\n  /*\n  for(int i = 0; i<min(min(ary[0].size(), ary[1].size()), ary[2].size()); ++i) {\n    long long add = 0;\n    if(i == 0) {\n      add = ((ary[0][i] * ary[1][i]) % MOD) * ary[2][i];\n    }\n    else {\n      //add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0] + ((ary[0][i] * ary[1][0])%MOD) * ary[2][i] + ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n      add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][i-1] + ((ary[0][i] * ary[1][i-1])%MOD) * ary[2][i] + ((ary[0][i-1] * ary[1][i])%MOD) * ary[2][i];\n    }\n    ret = (ret + add) % MOD;\n  }\n  */\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nvector<int>pat[3][101010];\nint gr[101010];\nll p10[555555];\nvector<ll>calc(int t, int n)\n{\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tint s = 0;\n\t\tvector<int>f;\n\t\tf.resize(pat[t][i].size() + 3);\n\t\tfor (int j = 0; j < pat[t][i].size(); j++)\n\t\t{\n\t\t\tint v = pat[t][i][j];\n\t\t\tf[gr[v]] = 1;\n\t\t}\n\t\tfor (int j = 0; j < f.size(); j++)\n\t\t{\n\t\t\tif (f[j] == 0)\n\t\t\t{\n\t\t\t\tgr[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ll>r;\n\tr.resize(2000);\n\tfor (int i = 0; i < min(n,2000); i++)r[gr[i]] = (r[gr[i]] + p10[i + 1]) % mod;\n\treturn r;\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tint w;\n\t\tscanf(\"%d\", &w);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tint za, zb;\n\t\t\tscanf(\"%d%d\", &za, &zb);\n\t\t\tza--, zb--;\n\t\t\tif (za > zb)swap(za, zb);\n\t\t\tpat[i][za].push_back(zb);\n\t\t}\n\t}\n\tp10[0] = 1;\n\tfor (int i = 0; i < 505050; i++)p10[i + 1] = p10[i] * (1000000000000000000LL % mod) % mod;\n\t//for (int i = 0; i < 505050; i++)p10[i + 1] = p10[i] * (10LL % mod) % mod;\n\tvector<ll>v[3];\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tvector<ll>z = calc(i, num);\n\t\t//for (int k = 0; k < z.size(); k++)printf(\"%lld \", z[k]); printf(\"\\n\");\n\t\tv[i] = z;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < min(num, 1000); i++)\n\t{\n\t\tfor (int j = 0; j < min(num, 1000); j++)\n\t\t{\n\t\t\tif ((i^j) < num)\n\t\t\t{\n\t\t\t\t//printf(\"%d %d %d\\n\", i, j, i^j);\n\t\t\t\tans = (ans + v[0][i] * v[1][j] % mod*v[2][i^j]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n\tfor(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n  using value_type = ::std::uint_fast64_t;\n  value_type n;\npublic:\n  ModInt() : n(0) {}\n  ModInt(value_type n_) : n(n_ % mod) {}\n  ModInt(const ModInt& m) : n(m.n) {}\n\n  template<typename T>\n  explicit operator T() const { return static_cast<T>(n); }\n  value_type get() const { return n; }\n\n  friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n    return os << a.n;\n  }\n\n  friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n    value_type x;\n    is >> x;\n    a = ModInt<mod>(x);\n    return is;\n  }\n\n  bool operator==(const ModInt& m) const { return n == m.n; }\n  bool operator!=(const ModInt& m) const { return n != m.n; }\n  ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n  ModInt pow(value_type b) const{\n    ModInt ans = 1, m = ModInt(*this);\n    while(b){\n      if(b & 1) ans *= m;\n      m *= m;\n      b >>= 1;\n    }\n    return ans;\n  }\n\n  ModInt inv() const { return (*this).pow(mod-2); }\n  ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n  ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n  ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n  ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n  ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n  ModInt& operator++(){ n += 1; return *this; }\n  ModInt& operator--(){ n -= 1; return *this; }\n  ModInt operator++(int){\n    ModInt old(n);\n    n += 1;\n    return old;\n  }\n  ModInt operator--(int){\n    ModInt old(n);\n    n -= 1;\n    return old;\n  }\n  ModInt operator-() const { return ModInt(mod-n); }\n};\n\nconstexpr int64 mod = 998244353;\nusing Mint = ModInt<mod>;\n\nint64 N, M[3];\nvector<vector<int64>> G[3];\nvector<int64> gr[3];\n\nvoid calc(const vector<vector<int64>>& G, vector<int64>& gr) {\n  for (int64 i = N-1; i >= 0; i--) {\n    set<int64> st;\n    for (auto &u : G[i]) {\n      if (gr[u] != -1) st.insert(gr[u]);\n    }\n    int64 x = 0;\n    while (st.size() && *(st.begin()) == x) {\n      x++;\n      st.erase(st.begin());\n    }\n    gr[i] = x;\n  }\n}\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin >> N;\n  vector<Mint> grsum[3];\n  REP(i, 3) {\n    cin >> M[i];\n    G[i].resize(N);\n    gr[i].resize(N, -1);\n    REP(j, M[i]) {\n      int64 a, b;\n      cin >> a >> b; a--; b--;\n      G[i][a].push_back(b);\n      G[i][b].push_back(a);\n    }\n    calc(G[i], gr[i]);\n    grsum[i].resize(sqrt(2*M[i])+1, 0);\n    REP(j, N) {\n      grsum[i][gr[i][j]] += Mint(INF_LL).pow(j+1);\n    }\n  }\n  vector<Mint> sum(M[2]+1, 0);\n  REP(i, grsum[0].size()) {\n    REP(j, grsum[1].size()) {\n      if ((i^j) <= M[2])\n        sum[i^j] += grsum[0][i] * grsum[1][j];\n    }\n  }\n  Mint res = 0;\n  REP(i, grsum[2].size()) {\n    res += grsum[2][i] * sum[i];\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <math.h>\n#include <time.h>\n#include <assert.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define all(x) x.begin(),x.end()\n#define SZ(x) int(x.size())\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define per(i, a, b) for(int i = b-1; i >= a; i--)\n#define DBG(x) cerr << (#x) << \"=\" << x << \"\\n\";\n#define ll long long\n#define inf 1000000007\n#define mod 998244353//1000000007\n#define N 100005\n\ntemplate<typename U, typename V> void Min(U &a, const V & b){if(a > b)a = b;}\ntemplate<typename U, typename V> void Max(U &a, const V & b){if(a < b)a = b;}\ntemplate<typename U, typename V> void add(U &a, const V & b){a = (a + b) % mod;}\ntemplate<typename U> U gcd(U a, U b){\n    if(a == 0)return b;\n    if(b == 0)return a;\n    if(a >= b)return gcd(a % b, b);\n    else return gcd(a, b % a);\n}\nint pow(int a, int b){\n    int ans = 1;\n    while(b){\n        if(b & 1)ans = 1LL * ans * a % mod;\n        a = 1LL * a * a % mod;\n        b >>= 1;\n    }\n    return ans;\n}\nint pow(int a, ll b, int c){\n    int ans = 1;\n    while(b){\n        if(b & 1)ans = 1LL * ans * a % c;\n        a = 1LL * a * a % c;\n        b >>= 1;\n    }\n    return ans;\n}\n\nint vis[N], sg[N], dp[3][N], p[N], now, mx[3];\nvi g[N];\nint main(){\n  int T, m, i, j, k, n, K;\n  scanf(\"%d\", &n);\n  p[0] = 1;\n  p[1] = pow(10, 18);\n  rep(i, 2, n+1)p[i] = 1LL * p[i-1] * p[1] % mod;\n  rep(it, 0, 3){\n    scanf(\"%d\", &m);\n    rep(i, 0, n)g[i].clear();\n    while(m--){\n      scanf(\"%d%d\", &i, &j);\n      i--, j--;\n      if(i > j)swap(i, j);\n      g[i].pb(j);\n    }\n    per(i, 0, n){\n      now++;\n      sg[i] = 0;\n      for(auto &v : g[i])vis[sg[v]] = now;\n      while(vis[sg[i]] == now)sg[i]++;\n      Max(mx[it], sg[i]);\n      add(dp[it][sg[i]], p[i+1]);\n    }\n  }\n  ll ans = 0;\n  rep(i, 0, mx[0]+1){\n    rep(j, 0, mx[1]+1){\n      ans = ans + 1LL * dp[0][i] * dp[1][j] % mod * dp[2][i^j] % mod;\n    }\n  }\n  ans %= mod;\n  printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc043/tasks/agc043_c\n#define CIN_ONLY\n#define DECIMAL_DIGITS 10\n#define STATIC_MOD 998244353\n\n#ifdef BTK\n/*<head>*/\n#    include \"Template.hpp\"\n#    include \"num/ModInt.hpp\"\n/*</head>*/\n#else\n/*<body>*/\n/* #region auto includes */\n/* #region stl */\n/*<stl>*/\n#    include <bits/stdc++.h>\n#    include <sys/types.h>\n#    include <unistd.h>\nusing namespace std;\n/*</stl>*/\n/* #endregion */\n/* #region template/Grid.hpp*/\n\n/**\n * @brief グリッドをラップするための関数\n * @tparam T std::string や std;:vector を想定\n * @tparam U 周りに配置する要素の型\n * @param grid 入力、R > 0 でないとバグる\n * @param material 周りに配置する要素\n * @return std::vector<T> material で 周りを埋めた grid\n */\ntemplate <typename T, typename U>\ninline std::vector<T> wrapGrid(std::vector<T> grid, U material) {\n    std::vector<T> wrappedGrid(grid.size() + 2,\n                               T(grid[0].size() + 2, material));\n    for (std::size_t i = 0; i < grid.size(); i++) {\n        for (std::size_t j = 0; j < grid[i].size(); j++) {\n            wrappedGrid[i + 1][j + 1] = grid[i][j];\n        }\n    }\n    return wrappedGrid;\n}\n\n/**\n * @brief\n *\n */\nconstexpr int dr4[] = {0, 1, 0, -1};\nconstexpr int dc4[] = {-1, 0, 1, 0};\n/* #endregion */\n/* #region template/IncludeSTL.hpp*/\n/**\n * @file IncludeSTL.hpp\n * @author btk\n * @brief 標準ライブラリをincludeするだけ\n * @version 0.1\n * @date 2019-07-21\n * @todo 何故か2回includeされる（展開scriptに\n * @copyright Copyright (c) 2019\n *\n */\n\n\n/* #endregion */\n/* #region template/Macro.hpp*/\n/**\n * @file Macro.hpp\n * @author btk\n * @brief マクロとか，LLとか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n//! LL\nusing LL = long long;\n\n/**\n * @def DEBUG\n * @brief デバッグ用のif文 提出時はif(0)で実行されない\n */\n\n/*</head>*/\n#    ifdef BTK\n#        define DEBUG if (1)\n#    else\n#        ifdef CIN_ONLY\n#            define FAST_IO\n#        endif\n#        define DEBUG if (0)\n#    endif\n/**\n * @def ALL(v)\n * @brief\n * ALLマクロ\n */\n#    define ALL(v) (v).begin(), (v).end()\n\n/**\n * @def REC(ret, ...)\n * @brief\n * 再帰ラムダをするためのマクロ\n */\n#    define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n\n/**\n * @def VAR_NAME(var)\n * @brief 変数名を取得する\n */\n#    define VAR_NAME(var) #    var\n\n/**\n * @brief\n * rangeで生まれる使わない変数を消す用（警告消し）\n */\ntemplate <typename T>\ninline T& unused_var(T& v) {\n    return v;\n}\n\ntemplate <typename T>\nstd::vector<T> nestingVector(std::size_t size) {\n    return std::vector<T>(size);\n}\n\ntemplate <typename T, typename... Ts>\ninline auto nestingVector(std::size_t size, Ts... ts) {\n    return std::vector<decltype(nestingVector<T>(ts...))>(\n        size, nestingVector<T>(ts...));\n}\n/* #endregion */\n/* #region template/IO.hpp*/\n/**\n * @file IO.hpp\n * @author btk\n * @brief cin高速化とか，出力の小数桁固定とか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n */\n\n\n/**\n * @brief 入出力の設定を行うための構造体\n */\nstruct cww {\n    /**\n     * @brief Construct a new cww::cww object\n     * @details\n     * CIN_ONLYを定義すると，submit時にcinとscanfの同期を切る設定が走る\n     * DECIMAL_DIGITSを定義すると，doubleの出力時指定した桁数分小数部を吐くようになる\n     */\n    cww() {\n#    ifdef FAST_IO\n        std::ios::sync_with_stdio(false);\n        std::cin.tie(0);\n#    endif\n#    ifdef DECIMAL_DIGITS\n        std::cout << std::fixed;\n        std::cout << std::setprecision(DECIMAL_DIGITS);\n#    endif\n    }\n};\n\n//! 入出力設定構造体を実体化\ncww star;\n\n/**\n * @brief\n * vectorに直接cin流すためのやつ\n * @tparam T\n * @param is\n * @param v\n * @return istream&\n */\ntemplate <typename T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& v) {\n    for (auto& it : v) is >> it;\n    return is;\n}\n/* #endregion */\n/* #region template/Loop.hpp*/\n/**\n * @file Loop.hpp\n * @author btk\n * @brief rangeとかループ系のクラス\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n/**\n * @brief\n * rangeを逆向きに操作したいとき用\n * @details\n * ループの範囲は[bg,ed)なので注意\n * @see range\n */\nclass reverse_range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x - 1; }\n        bool operator!=(I& lhs) { return x > lhs.x; }\n        void operator++() { --x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param n\n     */\n    reverse_range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param i\n     * @param n\n     */\n    reverse_range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return n; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return i; }\n};\n/**\n * @brief\n * python みたいな range-based for を実現\n * @details\n * ループの範囲は[bg,ed)なので注意\n * !つけると逆向きにループが回る (reverse_range)\n * 空間計算量はO(1)\n * 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n */\nclass range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x; }\n        bool operator!=(I& lhs) { return x < lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new range object\n     *\n     * @param n\n     */\n    range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new range object\n     *\n     * @param i\n     * @param n\n     */\n    range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return i; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return n; }\n    /**\n     * @brief\n     * 逆向きに参照するrange(reverse_rangeを取得できるs)\n     * @return reverse_range\n     */\n    reverse_range operator!() { return reverse_range(*i, *n); }\n};\n/* #endregion */\n/* #region template/Math.hpp*/\n\n/**\n * @brief gcd, ceil等自作算数用関数を集める。stdと被るので名前空間を区切る\n */\nnamespace math {\n\n    /**\n     * @brief aとｂの最大公約数\n     * @param a int64\n     * @param b int64\n     * @return int64 最大公約数\n     */\n    int64_t gcd(int64_t a, int64_t b) { return (b == 0) ? a : gcd(b, a % b); }\n\n    /**\n     * @brief aとｂの最小公倍数\n     * @param a int64\n     * @param b int64\n     * @return int64 最小公倍数\n     */\n    int64_t lcm(int64_t a, int64_t b) { return (a / gcd(a, b)) * b; }\n\n\n    /**\n     * @brief 拡張ユークリッド互除法\n     * @details ax + by = gとなるx,yを求める\n     * @param a 入力\n     * @param b 入力\n     * @param x 値引き継ぎ用の変数\n     * @param y 値引き継ぎ用の変数\n     * @return int64_t g:aとbの最大公約数\n     */\n    int64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y) {\n        int64_t g = a;\n        x         = 1;\n        y         = 0;\n        if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n        return g;\n    }\n\n    /**\n     * @brief u/dを切り上げした整数を求める\n     * @todo 負の数への対応\n     * @tparam T 整数型\n     * @param u 入力\n     * @param d 入力\n     * @return T 切り上げ後の値\n     */\n    template <typename T>\n    inline T ceil(T u, T d) {\n        return (u + d - (T)1) / d;\n    }\n\n} // namespace math\n/* #endregion */\n/* #region template/MinMaxOperation.hpp*/\n/**\n * @file MinMaxOperation.hpp\n * @author btk\n * @brief 最大値とか最小値を求める\n * @version 0.1\n * @date 2019-07-04\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n/**\n * @brief 2項の最小値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct min_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l < r ? l : r; }\n};\n\n/**\n * @brief 2項の最大値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct max_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l > r ? l : r; }\n};\n\n/**\n * @brief テンプレート再帰の末尾\n *\n * @tparam F 二項演算\n * @tparam T\n * @param v\n * @return T\n */\ntemplate <typename F, typename T>\ninline T multi_op(T&& v) {\n    return v;\n}\n\n/**\n * @brief 複数項における演算の結果を返す\n *\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename F, typename T, typename... Ts>\ninline T multi_op(const T head, Ts&&... tail) {\n    return F::exec(head, multi_op<F>(tail...));\n}\n\n/**\n * @brief 複数項の最小値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_min(T head, Ts... tail) {\n    return multi_op<min_op<T>>(head, tail...);\n}\n\n/**\n * @brief 複数項の最大値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_max(T head, Ts... tail) {\n    return multi_op<max_op<T>>(head, tail...);\n}\n\n/**\n * @brief\n * \b先頭の値をFで参照する関数に基づいて変更できたらする\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param target\n * @param candidates\n * @return true\n * @return false\n */\ntemplate <typename F, typename T, typename... Ts>\ninline bool ch_op(T& target, Ts&&... candidates) {\n    const T old = target;\n    target      = multi_op<F>(target, candidates...);\n    return old != target;\n}\n\n/**\n * @brief change min\n * @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmin(T& target, Ts&&... candidates) {\n    return ch_op<min_op<T>>(target, candidates...);\n}\n\n/**\n * @brief chminのmax版\n * @see chmin\n *  @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmax(T& target, Ts&&... candidates) {\n    return ch_op<max_op<T>>(target, candidates...);\n}\n/* #endregion */\n/* #region template/Random.hpp*/\n/**\n * @file Random.hpp\n * @author btk\n * @brief 乱数生成系\n * @version 0.1\n * @date 2019-07-13\n * @copyright Copyright (c) 2019\n */\n\n\n//! 乱数のシード値をプロセスIDとして取得\nconst pid_t pid = getpid();\n\n/**\n * @brief XorShift32の実装\n */\nclass XorShift32 {\n  private:\n    //! XorShiftの現在の値\n    unsigned value;\n\n    /**\n     * @brief XorShift32のアルゴリズムに基づいて value を更新\n     */\n    inline void update() {\n        value = value ^ (value << 13);\n        value = value ^ (value >> 17);\n        value = value ^ (value << 5);\n    }\n\n    /**\n     * @brief 値を更新し，更新前の値を返却\n     * @return unsigned 呼び出し時の value を用いる\n     */\n    inline unsigned get() {\n        unsigned v = value;\n        update();\n        return v;\n    }\n\n  public:\n    /**\n     * @brief [0, 2^bit) の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_int() {\n        return (int)(get() >> (32 - bit));\n    }\n\n    /**\n     * @brief [-2^bit,2^bit)の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_signed() {\n        unsigned v = get();\n        return (int)((v >> (31 - bit)) - (1 << (bit)));\n    }\n\n    /**\n     * @brief next_int呼び出し時の最大値を取得\n     * @tparam 31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int range_max() {\n        return (int)((1u << bit) - 1);\n    };\n\n    /**\n     * @brief Construct a new XorShift32 object\n     * @param seed\n     * @details 初期シードをvalueとするXorShift32のインスタンスを生成\n     */\n    XorShift32(const unsigned seed) {\n        value = seed;\n        update();\n    }\n\n    /**\n     * @brief Construct a new XorShift 32 object\n     * @details 初期シードをプロセスIDとするXorShift32のインスタンスを生成\n     */\n    XorShift32() : XorShift32(pid) {}\n};\n/* #endregion */\n/* #region template/Strings.hpp*/\n/**\n * @file Strings.hpp\n * @author btk\n * @brief 文字列を扱いやすくするライブラリ\n * @version 0.1\n * @date 2020-02-02\n *\n * @copyright Copyright (c) 2020\n *\n */\n\n\n/**\n * @brief コレクションを文字列に変換する関数\n * @tparam T コレクションの型、range-based for に対応している必要あり\n * @tparam U 区切り文字の型\n * @param v コレクション\n * @param delimiter 区切り文字\n * @return std::string delimiterで結合された文字列\n */\ntemplate <typename T, typename U>\nstd::string join(const T& v, const U delimiter) {\n    std::stringstream ss;\n    bool isFirst = true;\n    for (auto& it : v) {\n        if (!isFirst) {\n            ss << delimiter;\n        }\n        isFirst = false;\n        ss << it;\n    }\n    return ss.str();\n}\n\n/**\n * @brief コレクションを文字列に変換する関数（イテレータ版）\n * @tparam ITR イテレータ型\n * @tparam T 区切り文字の型\n * @param bg 開始\n * @param ed 終了\n * @param delimiter 区切り文字\n * @return std::string delimiterで結合された文字列\n */\ntemplate <typename ITR, typename T>\nstd::string join(const ITR bg, const ITR ed, const T delimiter) {\n    std::stringstream ss;\n    bool isFirst = true;\n    for (auto it = bg; it != ed; ++it) {\n        if (!isFirst) {\n            ss << delimiter;\n        }\n        isFirst = false;\n        ss << *it;\n    }\n    return ss.str();\n}\n/* #endregion */\n/* #region Template.hpp*/\n/**\n * @file Template.hpp\n * @brief 競技プログラミング用テンプレート\n * @author btk15049\n * @date 2019/05/02\n */\n\n\n/* #endregion */\n/* #region num/ModInt.hpp*/\n\n#    include <utility>\n\n/**\n * @file ModInt.hpp\n * @brief mod構造体\n * @author btk15049\n * @date 2019/03/08\n * @details\n *  \\todo verifyが足りない\n *  verify: CSA12E，RUPC day3 F\n */\n\n//! [WARNING!] mod が入力で与えられる場合はconstexprを外す\n#    ifdef STATIC_MOD\nconstexpr int mod = STATIC_MOD;\n#    else\nint mod;\n#    endif\n\n/**\n * @brief mod構造体\n * @details\n * 整数をラップして，常に保持されているデータがmodされた状態になるよう管理．\n */\nclass ModInt {\n  private:\n    //! 中身\n    int x;\n\n  public:\n    /**\n     * @brief ゲッター\n     * @details 出力時などは \"cout << *ret << endl;\"のようにやるとよい．\n     */\n    long long operator*() const { return x; }\n    /**\n     * @brief デフォルトコンストラクタ．0で初期化される．\n     */\n    ModInt() { x = 0; }\n\n    /**\n     * @brief intからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt(const int y) { x = y; }\n\n    /**\n     * @brief long longからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details 毎回modを取るので低速．\n     */\n    ModInt(const long long y) { x = (int)((mod + y % mod) % mod); }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt(const ModInt& o) { this->x = *o; }\n    /**\n     * @brief 整数から高速にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details xが[0,mod)であることが保証されてないと正しく動かない．\n     */\n    static inline ModInt raw(const long long x) {\n        // assert(x<mod);\n        return ModInt((int)x);\n    }\n\n    /**\n     * @brief 整数から安全にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    static inline ModInt get(const long long x) { return ModInt(x); }\n\n    /**\n     * @brief intからの代入演算子\n     * @param[in] o 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt& operator=(const int o) {\n        this->x = o >= mod ? o - mod : o;\n        return *this;\n    }\n\n    /**\n     * @brief long longからの代入演算子\n     * @param[in] o 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    ModInt& operator=(const long long o) {\n        this->x = (int)((mod + o % mod) % mod);\n        return *this;\n    }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt& operator=(const ModInt o) {\n        this->x = *o;\n        return *this;\n    }\n};\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n * @details if文使って少し高速化．\n */\ninline ModInt add(const ModInt l, const ModInt r) {\n    const long long x = *l + *r;\n    return ModInt::raw(x >= mod ? x - mod : x);\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt．\n */\ninline ModInt mul(const ModInt l, const ModInt r) {\n    return ModInt::raw(*l * *r % mod);\n}\n\n/**\n * @brief a^x %modを求める\n * @param[in] a ModInt\n * @param[in] x long long．\n */\ninline ModInt pow(ModInt a, long long x) {\n    ModInt ret = ModInt::raw(1);\n    while (x) {\n        if (x & 1) {\n            ret = mul(ret, a);\n        }\n        a = mul(a, a);\n        x >>= 1;\n    }\n    return ret;\n}\n\n/**\n * @brief x^-1 %modを求める\n * @param[in] x ModInt．\n * @details\n *   内部ではユークリッドの拡張互助法を使っている．\n *   O(log(mod))\n */\ninline ModInt inv(const ModInt x) {\n    long long a = *x, b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        std::swap(a -= t * b, b);\n        std::swap(u -= t * v, v);\n    }\n    return ModInt::get(u);\n}\n\n/**\n * @brief 負数を求める単項演算子\n * @param[in] x ModInt\n */\ninline ModInt operator-(const ModInt x) { return add(mod, -*x); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator+(const ModInt l, const ModInt r) { return add(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator*(const ModInt l, const ModInt r) { return mul(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator-(const ModInt l, const ModInt r) { return add(l, -r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator+(const ModInt l, const int r) {\n    return add(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator+(const ModInt l, const long long r) {\n    return add(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator*(const ModInt l, const int r) {\n    return mul(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator*(const ModInt l, const long long r) {\n    return mul(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator-(const ModInt l, const int r) {\n    return add(l, ModInt::raw(mod - r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator-(const ModInt l, const long long r) {\n    return add(l, -ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator/(const ModInt l, const int r) {\n    return mul(l, inv(ModInt::raw(r)));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator/(const ModInt l, const long long r) {\n    return mul(l, inv(ModInt::get(r)));\n}\n\n/**\n* @param[in] l ModInt\n* @param[in] r long long\n* @details\n*   pow(l,r)を呼び出すだけなのでpowを参照のこと．\n計算量はO(log mod)\n*/\ninline ModInt operator^(const ModInt l, const long long r) { return pow(l, r); }\n\n/**\n * @brief\n * +=の実装、各operator+を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 足すやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator+=(ModInt& l, T r) {\n    l = l + r;\n    return l;\n}\n\n/**\n * @brief\n * -=の実装、各operator-を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 引くやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator-=(ModInt& l, T r) {\n    l = l - r;\n    return l;\n}\n\n/**\n * @brief\n * *=の実装、各operator*を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r かけるやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator*=(ModInt& l, T r) {\n    l = l * r;\n    return l;\n}\n\n/**\n * @namespace factorial\n * @brief 順列数関連の関数のまとめ\n * @details\n *   - combination\n *   - permutation\n *   - multiChoose\n */\nnamespace factorial {\n    //! 順列数を格納する配列のサイズ\n    constexpr int size =\n#    ifdef FACTORIAL_SIZE\n        FACTORIAL_SIZE;\n#    else\n        3123456;\n#    endif\n    //! 前計算ができているかどうかのフラグ\n    bool is_build = false;\n\n    //! 順列数を格納する配列\n    ModInt factorial[size];\n    //! (順列数)^-1を格納する配列\n    ModInt inverse_factorial[size];\n\n    /**\n     * @brief 順列数の前計算\n     * @details\n     *   順列数と，その逆元を[0,size)まで求める.\n     *   計算量は，O(size + log(mod))\n     */\n    void build() {\n        is_build     = true;\n        factorial[0] = 1;\n        for (int i = 1; i < size; i++) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n        inverse_factorial[size - 1] = inv(factorial[size - 1]);\n        for (int i = size - 1; i >= 1; i--) {\n            inverse_factorial[i - 1] = inverse_factorial[i] * i;\n        }\n    }\n\n    /**\n     * @brief nPkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt permutation(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief nCkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt combination(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[k] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief 重複組合せ\n     * @param n 何種類のものを (仕切りがn-1個)\n     * @param r いくつ並べるか\n     * @return ModInt nHr\n     */\n    ModInt multiChoose(int n, int r) {\n        if (n == 0 && r == 0) return ModInt::raw(1);\n        return combination(n + r - 1, r);\n    }\n\n    /**\n     * @brief 上限付き重複組合せ\n     * @details\n     * 包除原理を用いて，lim個以上の品物が1,2,...,i種類の場合を足したり引いたりしていく\n     * 計算量は O(min(n, r / lim))\n     * @param n 何種類のものを\n     * @param r いくつ並べるか\n     * @param lim 1種類のものを選べる上限\n     * @return ModInt\n     */\n    ModInt multiChoose(int n, int r, int lim) {\n        ModInt ret = 0;\n        for (int i = 0; i <= n; i++) {\n            if (i * (lim + 1) > r) break;\n            ret += ((i & 1) ? mod - 1 : 1) * combination(n, i)\n                   * multiChoose(n, r - i * (lim + 1));\n        }\n        return ret;\n    }\n\n} // namespace factorial\n  /* #endregion */\n  /* #endregion */\n  /*</body>*/\n#endif\n\nint n;\n\nusing VV = vector<vector<int>>;\nVV in() {\n    int m;\n    cin >> m;\n    auto g = nestingVector<int>(n, 0);\n    for (int i : range(m)) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    return g;\n}\n\n\nvector<ModInt> solve(VV& g) {\n    vector<int> color(n, -1);\n    VV cs(n);\n    vector<ModInt> ret(n, ModInt(0));\n    ModInt e18 = ModInt((LL)(1e9)) * ModInt((LL)(1e9));\n    for (int v : !range(n)) {\n        vector<int> used;\n        used.reserve(g[v].size());\n        for (auto& u : g[v]) {\n            if (color[u] != -1) used.push_back(color[u]);\n        }\n        sort(ALL(used));\n        used.erase(unique(ALL(used)), used.end());\n        int val = used.size();\n        for (int i : range(used.size())) {\n            if (i != used[i]) {\n                val = i;\n                break;\n            }\n        }\n        ret[val] += e18 ^ (v + 1);\n        cs[val].push_back(v + 1);\n        color[v] = val;\n    }\n    return ret;\n}\n\nint main() {\n    /* write here */\n    cin >> n;\n    auto g1    = in();\n    auto g2    = in();\n    auto g3    = in();\n    auto s1    = solve(g1);\n    auto s2    = solve(g2);\n    auto s3    = solve(g3);\n    ModInt ret = 0;\n    int X      = min(1000, n);\n    VV used(X, vector<int>(X));\n    for (int i : range(0, X)) {\n        for (int j : range(i, X)) {\n            if (used[i][j]) continue;\n            for (int k : range(j, X)) {\n                if (used[i][k] || used[j][k]) continue;\n                ret += s1[i] * s2[j] * s3[k];\n                if (i != j) {\n                    ret += s1[j] * s2[i] * s3[k];\n                    ret += s1[k] * s2[j] * s3[i];\n                    if (j != k) {\n                        ret += s1[i] * s2[k] * s3[j];\n                        ret += s1[j] * s2[k] * s3[i];\n                        ret += s1[k] * s2[i] * s3[j];\n                    }\n                }\n                used[i][j] = 1;\n                used[j][k] = 1;\n                used[i][k] = 1;\n                break;\n            }\n        }\n    }\n    cout << *ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n  int H,W;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      \n      "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\ntypedef pair<int, int> pii;\n\ntemplate< typename T > inline void read(T &x)\n{\n    static char _c;\n    static bool _f;\n\n    x = 0;\n    _f = 0;\n    _c = getchar();\n\n    while(_c < '0' || '9' < _c) {if(_c == '-') _f = true; _c = getchar();}\n    while('0' <= _c && _c <= '9') {x = (x << 1) + (x << 3) + (_c & 15); _c = getchar();}\n    if(_f) x = -x;\n}\n\ntemplate < typename T > inline void Min(T &x, T y) {if(y < x) x = y;}\ntemplate < typename T > inline void Max(T &x, T y) {if(x < y) x = y;}\n\n\n#define lowbit(x) ((x) & -(x))\n#define lson l,mid,id<<1\n#define rson mid+1,r,id<<1|1\n#define ls id<<1\n#define rs id<<1|1\n#define MID(l,r) ((l)+(((r)-(l))>>1))\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\nconst int INF = 0x3f3f3f3f;\nconst double pi = (double) acos(-1.0);\nconst double eps = (double) 1e-8;\n//const int MOD = (int) 1e9 + 7;\nconst int MOD = (int) 998244353;\nconst int maxn = (int) 1e5 + 20;\nconst int maxm = (int) 1e6 + 20;\n\ninline int sig(double x) {return x < -eps ? -1 : eps < x;}\nLL fp(LL a, LL n, LL mod = MOD)\n{\n    if(n < 0) a = fp(a, mod - 2, mod), n = -n;\n    LL res = 1; for(; n; n >>= 1, a = a * a % mod) if(n & 1) res = res * a % mod; return res;\n}\n\nstruct Mint\n{\n    LL x;\n    Mint() {}\n    Mint(int _x): x(_x) {}\n    Mint(LL _x): x(_x) {}\n    Mint operator - () const{\n        return Mint(MOD - x);\n    }\n    Mint operator + (const Mint &rhs) const{\n        LL res = x + rhs.x; if(res >= MOD) res -= MOD; return Mint(res);\n    }\n    Mint operator - (const Mint &rhs) const{\n        LL res = x - rhs.x; if(res < 0) res += MOD; return Mint(res);\n    }\n    Mint operator * (const Mint &rhs) const{\n        return Mint(x * rhs.x % MOD);\n    }\n    Mint operator / (const Mint &rhs) const{\n        return Mint(x * fp(rhs.x, -1) % MOD);\n    }\n    bool operator == (const Mint &rhs) const{\n        return x == rhs.x;\n    }\n    bool operator != (const Mint &rhs) const{\n        return x != rhs.x;\n    }\n    friend ostream& operator << (ostream &out, const Mint &rhs){\n        return out << rhs.x;\n    }\n    friend istream& operator >> (istream &in, Mint &rhs){\n        return in >> rhs.x;\n    }\n};\n\nint n;\nvector<int> G[3][maxn];\nMint po[maxn];\n\nMint a[3][512];\nint sg[3][maxn];\n\nvoid work()\n{\n    read(n);\n\n    po[0] = Mint(1);\n    po[1] = (LL) 1e18 % MOD;\n    for(int i = 2; i <= n; i++) po[i] = po[i - 1] * po[1];\n\n    for(int d = 0; d < 3; d++)\n    {\n        int m; read(m);\n        for(int i = 0; i < m; i++)\n        {\n            int x, y; read(x); read(y);\n            if(x > y) swap(x, y);\n            G[d][x].pb(y);\n        }\n    }\n\n    for(int d = 0; d < 3; d++)\n    {\n        for(int i = 0; i < 512; i++) a[d][i] = Mint(0);\n        for(int i = n; i; i--)\n        {\n            set<int> s;\n            for(auto j : G[d][i])\n                s.insert(sg[d][j]);\n\n            int t = 0;\n            while(s.find(t) != s.end()) t++;\n\n            sg[d][i] = t;\n            a[d][t] = a[d][t] + po[i];\n        }\n    }\n\n    Mint ans = Mint(0);\n    for(int i = 0; i < 512; i++)\n        for(int j = 0; j < 512; j++)\n            ans = ans + a[0][i] * a[1][j] * a[2][i ^ j];\n    cout <<ans <<endl;\n}\n\n\nint main(int argc, char **argv)\n{\n#ifdef yukihana0416\nfreopen(\"in.txt\", \"r\", stdin);\n//freopen(\"out.txt\", \"w\", stdout);\n#endif // yukihana0416\n//    get_prime();\n//    pre();\n    int tc = 1;\n//    read(tc);\n    for(int ca = 1; ca <= tc; ca++)\n    {\n//        printf(\"Case #%d: \", ca);\n        work();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\nconst int P = 998244353;\nconst int Q = 716070898;\nconst int limit = 1000;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint n, m, x[MAXN], y[MAXN], z[MAXN];\nint bit[MAXN], f[MAXN], g[MAXN], res[MAXN];\nvector <int> a[MAXN], b[MAXN], c[MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nvoid work(vector <int> *a, int *res) {\n\tstatic int vis[MAXN];\n\tfor (int i = n; i >= 1; i--) {\n\t\tfor (auto x : a[i]) if (x > i) vis[res[x]] = true;\n\t\twhile (vis[res[i]]) res[i]++;\n\t\tfor (auto x : a[i]) if (x > i) vis[res[x]] = false;\n\t}\n}\nint main() {\n\tread(n);\n\tread(m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y; read(x), read(y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tread(m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y; read(x), read(y);\n\t\tb[x].push_back(y);\n\t\tb[y].push_back(x);\n\t}\n\tread(m);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint x, y; read(x), read(y);\n\t\tc[x].push_back(y);\n\t\tc[y].push_back(x);\n\t}\n\twork(a, x);\n\twork(b, y);\n\twork(c, z);\n\tbit[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tbit[i] = 1ll * Q * bit[i - 1] % P;\n\tfor (int i = 1; i <= n; i++) {\n\t\tupdate(f[y[i]], bit[i]);\n\t\tupdate(g[z[i]], bit[i]);\n\t}\n\tfor (int i = 0; i <= limit; i++) {\n\t\tfor (int j = 0; j <= limit; j++) {\n\t\t\tint k = i ^ j;\n\t\t\tupdate(res[i], 1ll * f[j] * g[k] % P);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tupdate(ans, 1ll * res[x[i]] * bit[i] % P);\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD_> struct ModInt {\n    static constexpr unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconstexpr LL MOD = 998244353;\nusing Mint = ModInt<MOD>;\n\nint N;\nint S[100011];\nMint B[100011];\n\npair<Mint, Mint> calc() {\n    int M;\n    scanf(\"%d\", &M);\n    vector<pair<int, int> > E;\n    REP (i, M) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tif (x > y) swap(x, y);\n\tE.emplace_back(x, y);\n    }\n    sort(E.begin(), E.end());\n    reverse(E.begin(), E.end());\n    for (int v=N, i=0; v>=1; v--) {\n\tbool has1 = false, has2 = false;\n\n\twhile (i < (int)E.size() && E[i].first == v) {\n\t    int p = E[i].second;\n\t    if (S[p] == 1) has1 = true;\n\t    if (S[p] == 2) has2 = true;\n\t    i++;\n\t}\n\n\tif (!has1) S[v] = 1;\n\telse if (!has2) S[v] = 2;\n\telse S[v] = 0;\n    }\n\n    pair<Mint, Mint> ret;\n    for (int v=1; v<=N; v++) {\n\tif (S[v] == 1) ret.first += B[v];\n\tif (S[v] == 2) ret.second += B[v];\n    }\n    return ret;\n}\n\nvoid MAIN() {\n    B[0] = 1;\n    B[1] = Mint(10).pow(18);\n    for (int i=2; i<100011; i++) B[i] = B[i-1] * B[1];\n\n    scanf(\"%d\", &N);\n    auto X = calc();\n    auto Y = calc();\n    auto Z = calc();\n\n    Mint ans = 0;\n    ans += X.first * Y.first * Z.first;\n    ans += X.second * Y.second * Z.first;\n    ans += X.second * Y.first * Z.second;\n    ans += X.first * Y.second * Z.second;\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// -----------------------------------\n// Author     : MatsuTaku\n// Affiliation: Tokushima University\n// Country    : Japan\n// Date       : 03/21/2020\n// -----------------------------------\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 998244353;\nconstexpr ll MAX_GRANDY = 512;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n\n  int N; cin>>N;\n  vector<int> graph[3][N+1];\n  for (int i = 0; i < 3; i++) {\n    int M; cin>>M;\n    for (int m = 0; m < M; m++) {\n      int a,b; cin>>a>>b;\n      if (a > b) swap(a,b);\n      graph[i][a].push_back(b);\n    }\n  }\n\n  vector<ll> pw(N+1);\n  pw[0] = 1;\n  constexpr ll p = ll(1e18)%MOD;\n  for (int i = 1; i <= N; i++) {\n    pw[i] = pw[i-1]*p%MOD;\n  }\n\n  array<array<ll, MAX_GRANDY>, 3> cnt={};\n  for (int i = 0; i < 3; i++) {\n    vector<int> gr(N+1, 0);\n    for (int v = N; v >= 1; v--) {\n      set<int> ps;\n      for (auto t : graph[i][v])\n        ps.insert(gr[t]);\n      while (ps.count(gr[v]) > 0)\n        ++gr[v];\n      cnt[i][gr[v]] += pw[v];\n      cnt[i][gr[v]] %= MOD;\n    }\n  }\n\n  ll ans = 0;\n  for (int i = 0; i < MAX_GRANDY; i++) for (int j = 0; j < MAX_GRANDY; j++) {\n    ans += cnt[0][i] * cnt[1][j] % MOD * cnt[2][i^j] % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\n\n// Mod int\nconst int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint operator~() const { return mint(1) / *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=a.pow(mod-2).x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  mint pow(ll t) const {\n    if(!t) return 1;\n    mint res = pow(t/2);\n    res *= res;\n    return (t&1)?res*x:res;\n  }\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint ex(mint x, ll t) { return x.pow(t);}\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\nstruct comb {\n  vm f, g;\n  comb(){}\n  comb(int mx):f(mx+1),g(mx+1) {\n    f[0] = 1;\n    rrep(i,mx) f[i] = f[i-1]*i;\n    g[mx] = f[mx].pow(mod-2);\n    for(int i=mx;i>0;i--) g[i-1] = g[i]*i;\n  }\n  mint operator()(int a, int b) {\n    if (a < b) return 0;\n    return f[a]*g[b]*g[a-b];\n  }\n};\n//\n\n// Fast Hadamard Transform\nvoid ada(vm& d) {\n  int n = sz(d);\n  for (int i = n; i >= 1; i >>= 1) {\n    rep(j,n) if (j&i) {\n      mint x = d[j^i], y = d[j];\n      d[j^i] = x+y;\n      d[j] = x-y;\n    }\n  }\n}\nvoid dad(vm& d) {\n  int n = sz(d);\n  mint i2 = ex(2,mod-2);\n  for (int i = 1; i <= n; i <<= 1) {\n    rep(j,n) if (j&i) {\n      mint x = d[j^i], y = d[j];\n      d[j^i] = (x+y)*i2;\n      d[j] = (x-y)*i2;\n    }\n  }\n}\n//\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  mint ten = ex(10,18);\n  vm ts(n*3+1);\n  ts[0] = 1;\n  rep(i,n*3) ts[i+1] = ts[i]*ten;\n  int n2 = 1;\n  while (n2 < n) n2 <<= 1;\n  vm dp(n2,1);\n  rep(gi,3) {\n    int m;\n    scanf(\"%d\",&m);\n    vvi to(n);\n    rep(i,m) {\n      int a,b;\n      scanf(\"%d%d\",&a,&b);\n      --a; --b;\n      if (a > b) swap(a,b);\n      to[a].pb(b);\n    }\n    vi c(n);\n    drep(i,n) {\n      set<int> s;\n      for (int u : to[i]) s.insert(c[u]);\n      while (s.count(c[i])) ++c[i];\n    }\n    vm d(n2);\n    rep(i,n) {\n      d[c[i]] += ts[i+1];\n    }\n    ada(d);\n    rep(i,n2) dp[i] *= d[i];\n  }\n  dad(dp);\n  cout<<dp[0]<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define trav(x,a) for (const auto& x: a)\n#define sz(x) (int)(x).size()\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int _i = 0; _i < (n); _i++) ni(a[_i])\n#define nal(a, n) for (int _i = 0; _i < (n); _i++) nl(a[_i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int mod = 998244353;\nconst int inf = 1e9 + 7;\nconst int N = 1e5 + 5;\nconst double eps = 1e-9;\nint m[3], dp[N];\nvector<int> adj[3][N], val[3];\n\n\nint add(int x, int y) { return x+y < mod ? x+y : x+y-mod; }\nint mul(int x, int y) { return x*1ll*y % mod; }\n\nll pw(ll x, ll y) {\n  ll r = 1;\n  while (y > 0) {\n    if (y&1)\n      r = r*x % mod, y--;\n    else\n      x = x*x % mod, y /= 2;\n  }\n  return r;\n}\n\nint main() {\n  int n; scanf(\"%d\", &n);\n  for (int it = 0; it < 3; it++) {\n    scanf(\"%d\", &m[it]);\n    for (int i = 0; i < m[it]; i++) {\n      int u, v; scanf(\"%d %d\", &u, &v);\n      adj[it][u].pb(v);\n      adj[it][v].pb(u);\n    }\n    for (int i = n; i; i--) {\n      set<int> nx;\n      trav(v, adj[it][i]) {\n        if (v <= i)\n          continue;\n        nx.insert(dp[v]);\n      }\n      dp[i] = 0;\n      while (nx.count(dp[i]))\n        dp[i]++;\n      while (sz(val[it]) <= dp[i])\n        val[it].pb(0);\n      val[it][dp[i]] = add(val[it][dp[i]], pw(10, 18ll*i));\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < sz(val[0]); i++)\n    for (int j = 0; j < sz(val[1]); j++) {\n      int k = i^j;\n      if (k < sz(val[2]))\n        ans = add(ans, mul(mul(val[0][i], val[1][j]), val[2][k]));\n    }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 0;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  vector<long long> ary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    set<int> usable;\n    for(int i = 1; i<N+1; ++i) {\n      usable.insert(i);\n    }\n    while(!usable.empty()) {\n      set<int> u = usable;\n      long long curr = 0;\n      while(!u.empty()) {\n        auto it = u.end();\n        it--;\n        int next = *it;\n        curr = (curr + pows[next]) % MOD;\n        for(int i = 0; i<adj[next].size(); ++i) {\n          u.erase(adj[next][i]);\n        }\n        u.erase(next);\n        usable.erase(next);\n      }\n      ary[graph].push_back(curr);\n    }\n  }\n\n  for(int i = 0; i<min(min(ary[0].size(), ary[1].size()), ary[2].size()); ++i) {\n    long long add = 0;\n    if(i == 0) {\n      add = ((ary[0][i] * ary[1][i]) % MOD) * ary[2][i];\n    }\n    else {\n      add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0] + ((ary[0][i] * ary[1][0])%MOD) * ary[2][i] + ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n    }\n    ret = (ret + add) % MOD;\n  }\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n freopen(\"input\",\"r\",stdin);\n freopen(\"output\",\"w\",stdout);\n*/\n\nll MOD = 998244353;\n\nvector<vector<int>> A, B, C;\nvector<ll> X,Y,Z;\n\nint N, M;\n\nll power(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res *= a;\n            res %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nll cal(const unordered_set<int>& s) {\n    ll v = 0;\n    for (const int t : s) {\n        v += power(10, t * 18);\n        v %= MOD;\n    }\n    return v;\n}\n\nvector<ll> process(const vector<vector<int>>& x) {\n    unordered_set<int> u;\n    vector<ll> res;\n    for (int i = N;i > 0;i--) {\n        if (u.find(i) != u.end()) continue;\n        unordered_set<int> s;\n        s.insert(i);\n        u.insert(i);\n        unordered_set<int> r;\n        r.insert(i);\n        for (auto m : x[i]) r.insert(m);\n        for (int j = i - 1;j > 0;j--) {\n            if (r.find(j) != r.end() || u.find(j) != u.end()) continue;\n            s.insert(j);\n            u.insert(j);\n            r.insert(j);\n            for (auto m : x[j]) r.insert(m);\n        }\n        res.push_back(cal(s));\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> N;\n    A.resize(N+1);\n    B.resize(N+1);\n    C.resize(N+1);\n    int a, b;\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        A[a].push_back(b);\n        A[b].push_back(a);\n    }\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        B[a].push_back(b);\n        B[b].push_back(a);\n    }\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        C[a].push_back(b);\n        C[b].push_back(a);\n    }\n    X = process(A);\n    Y = process(B);\n    Z = process(C);\n    set<pair<int,int>> xy;\n    ll ans = 0;\n    for (int i = 0;i < Z.size();i++) {\n        ll z = Z[i];\n        unordered_set<int> u;\n        for (int j = 0;j < Y.size();j++) {\n            ll y = z * Y[j];\n            y %= MOD;\n            for (int k = 0;k < X.size();k++) {\n                if (xy.find(make_pair(j,k)) == xy.end() && u.find(k) == u.end()) {\n                    xy.insert(make_pair(j,k));\n                    u.insert(k);\n                    ans += (y * X[k]) % MOD;\n                    ans %= MOD;\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconstexpr long long MOD = 998244353;\nconstexpr long long U = 1000000000000000000 % MOD;\n\nvoid input(vector<vector<int> >& V) {\n\tint M;\n\tcin >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint A, B;\n\t\tcin >> A >> B;\n\t\tA--, B--;\n\t\tif (A > B) swap(A, B);\n\t\tV[A].push_back(B);\n\t}\n}\n\nvoid Grundy(vector<int>& G, vector<vector<int> >& V) {\n\tfor (int i = (int)V.size() - 1; i >= 0; i--) {\n\t\tif (V[i].empty()) {\n\t\t\tG[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> Gs;\n\t\tfor (int j : V[i]) {\n\t\t\tGs.push_back(G[j]);\n\t\t}\n\t\tsort(Gs.begin(), Gs.end());\n\t\tGs.erase(unique(Gs.begin(), Gs.end()), Gs.end());\n\t\tif (Gs[Gs.size() - 1] == Gs.size() - 1) {\n\t\t\tG[i] = Gs.size();\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < Gs.size(); j++) {\n\t\t\tif (Gs[j] != j) {\n\t\t\t\tG[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long Pow(int A) {\n\tif (A == 0) return 1;\n\tif (A % 2 == 0) {\n\t\tlong long B = Pow(A / 2);\n\t\treturn (B * B) % MOD;\n\t}\n\treturn (U * Pow(A - 1)) % MOD;\n}\n\nvoid Count(vector<long long>& C, vector<int>& G) {\n\tfor (int i = 0; i < G.size(); i++) {\n\t\tC[G[i]] += Pow(i + 1);\n\t\tC[G[i]] %= MOD;\n\t}\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<vector<int> > X(N), Y(N), Z(N);\n\tvector<int> GX(N), GY(N), GZ(N);\n\tvector<long long> CX(512, 0), CY(512, 0), CZ(512, 0);\n\tinput(X), input(Y), input(Z);\n\tGrundy(GX, X), Grundy(GY, Y), Grundy(GZ, Z);\n\tCount(CX, GX), Count(CY, GY), Count(CZ, GZ);\n\tlong long ANS = 0;\n\tfor (int i = 0; i < 512; i++) {\n\t\tfor (int j = 0; j < 512; j++) {\n\t\t\tlong long MUL = (CX[i] * CY[j]) % MOD;\n\t\t\tMUL *= CZ[i ^ j];\n\t\t\tMUL %= MOD;\n\t\t\tANS += MUL;\n\t\t\tANS %= MOD;\n\t\t}\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 110000, mod = 998244353;\n\nint n, m, fa[3][N], lim[3];\nll sum[3][N], f[N], ans;\nvector<int> to[N];\nset<int> mex;\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\ninline ll quickpow(ll base, ll pw) {\n\tll ret = 1;\n\twhile (pw) {\n\t\tif (pw & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, pw >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint x, y;\n\tread(n);\n\tfor (R int i = 0; i <= 2; ++i) {\n\t\tread(m);\n\t\tfor (R int j = 1; j <= n; ++j) to[i].clear();\n\t\tfor (R int j = 1; j <= m; ++j)\n\t\t\tread(x), read(y), to[min(x, y)].push_back(max(x, y));\n\t\tfor (R int j = n; j; --j) {\n\t\t\tmex.clear();\n\t\t\tfor (auto &v : to[j])\n\t\t\t\tmex.insert(fa[i][v]);\n\t\t\twhile (mex.find(fa[i][j]) != mex.end())\n\t\t\t\t++fa[i][j];\n\t\t\tlim[i] = max(lim[i], fa[i][j]);\n\t\t\tsum[i][fa[i][j]] = (sum[i][fa[i][j]] + quickpow(10, 18 * j)) % mod;\n\t\t}\n\t}\n\tfor (R int i = 0; i <= lim[1]; ++i)\n\t\tfor (R int j = 0; j <= lim[2]; ++j)\n\t\t\tf[i ^ j] = (f[i ^ j] + sum[1][i] * sum[2][j]) % mod;\n\tfor (R int i = 0; i <= lim[0]; ++i)\n\t\tans = (ans + sum[0][i] * f[i]) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  vector< int > rev, rts;\n  int base, max_base, root;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n};\n\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vec d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,3100000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        D1[d1[i]] += P[i];\n        for(auto e:g1[i]){\n            if(d1[e]==d1[i])d1[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D2[d2[i]]+=P[i];\n        for(auto e:g2[i]){\n            if(d2[e]==d2[i])d2[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D3[d3[i]]+=P[i];\n        for(auto e:g3[i]){\n            if(d3[e]==d3[i])d3[e]++;\n        }\n    }\n    vec a,b;\n    mint ans;\n    ans+=D1[0]*D2[0]*D3[0];\n    rep(i,n){\n        ans+=D1[i]*D2[i+1]*D3[i+1];\n        ans+=D1[i+1]*D2[i]*D3[i+1];\n        ans+=D1[i+1]*D2[i+1]*D3[i];\n    }\n\n\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 998244353;\n mt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 1e5 + 10;\nvector<int> a[N];\n\nint64 power_mod(int64 a, int64 n, int p = MOD) {\n  int64 ret = 1;\n  for (; n; n >>= 1) {\n    if (n & 1) ret = ret * a % p;\n    a = a * a % p;\n  }\n  return ret;\n}\n\nvector<int64> process(int n) {\n  for (int i = 0; i < n; ++i) a[i].clear();\n  int m;\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    --x; --y;\n    if (x > y) swap(x, y);\n    a[x].push_back(y);\n  }\n  vector<int> sg(n);\n  vector<int> visit(n, -1);\n  vector<int64> ret;\n  int64 x = power_mod(10, 18);\n  for (int i = n - 1; i >= 0; --i) {\n    for (auto& j : a[i]) {\n      visit[sg[j]] = i;\n    }\n    for (int k = 0; ; ++k) {\n      if (visit[k] != i) {\n        sg[i] = k;\n        break;\n      }\n    }\n    int64 cur = power_mod(x, i + 1);\n    if (sg[i] >= ret.size()) {\n      ret.push_back(cur);\n    } else {\n      ret[sg[i]] += cur;\n      ret[sg[i]] %= MOD;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<int64> A = process(n);\n  vector<int64> B = process(n);\n  vector<int64> C = process(n);\n  int64 ret = 0;\n  for (int i = 0; i < A.size(); ++i) {\n    for (int j = 0; j < B.size(); ++j) {\n      int k = i ^ j;\n      if (k >= C.size()) continue;\n      ret += A[i] * B[j] % MOD * C[k] % MOD;\n      ret %= MOD;\n    }\n  }\n  printf(\"%lld\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5,mod=998244353;\nll base1=1,base2=0,p[N];\nint n,m,tot,vis[N],head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvector<ll>res[3];\nvoid solve(int flag)\n{\n    tot=0;memset(head,0,sizeof(head));\n    memset(vis,false,sizeof(vis));\n    m=100000;\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        //u=v=1;while(u==v) u=rand()*rand()%n+1,v=rand()*rand()%n+1;\n        add(u,v);add(v,u);\n    }\n    priority_queue<int>q[2];\n    int x=0,tim=0;\n    for(int i=1;i<=n;i++) q[x].push(i);\n    vector<ll>f;\n    while(!q[x].empty())\n    {\n        tim++;\n        ll ans=0;\n        while(!q[x].empty())\n        {\n            while(!q[x].empty()&&vis[q[x].top()]==tim) q[x].pop();\n            if(q[x].empty()) break;\n            int u=q[x].top();q[x].pop();\n            vis[u]=1e9;\n            ans=(ans+p[u])%mod;\n            for(int i=head[u];i;i=nex[i])\n            {\n                int v=to[i];\n                if(vis[v]<tim)\n                {\n                    vis[v]=tim;\n                    q[x^1].push(v);\n                }\n            }\n        }\n        x^=1;\n        f.push_back(ans);\n    }\n    res[flag]=f;\n}\nbool vis1[105][105],vis2[105];\nll solve()\n{\n    memset(vis2,0,sizeof(vis2));\n    ll ans=0;\n    for(int i=0;i<res[1].size();i++)\n    {\n        int mx=0;\n        while(mx<res[2].size()&&vis1[i][mx]||vis2[mx]) mx++;\n        if(mx<res[2].size())\n        {\n            vis1[i][mx]=vis2[mx]=true;\n            ans=(ans+res[1][i]*res[2][mx])%mod;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    srand(time(0));\n    p[0]=1;\n    for(int i=1;i<N;i++) p[i]=1000000000000000000ll%mod*p[i-1]%mod;\n    scanf(\"%d\",&n);\n    solve(0);solve(1);solve(2);\n    assert(res[0].size()<=100);\n    assert(res[1].size()<=100);\n    assert(res[2].size()<=100);\n    ll ans=0;\n    for(int i=0;i<res[0].size();i++)\n        ans=(ans+res[0][i]*solve())%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, n) for (int i = 0; i < (int)(n); ++i)\n#define pb push_back\n#define debug(x) std::cout << #x << \": \" << x << '\\n';\ntypedef long long ll;\nconst int N = 1e6 + 10, P = ll(1e18) % 998244353, mod = 998244353;\nint power[N];\nint mult(int a, int b) {\n    return (a * 1ll * b) % mod;\n}\nint add(int a, int b) {\n    return (a + b) % mod;\n}\nstd::vector<int> g[N][3];\nint dp[N][3];\nint byDp[3][3];\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int n;\n    std::cin >> n;\n    power[0] = 1;\n    FOR(i, N - 1) {\n        power[i + 1] = mult(power[i], P);\n    }\n    FOR(t, 3) {\n        int m;\n        std::cin >> m;\n        FOR(i, m) {\n            int a, b;\n            std::cin >> a >> b;\n            --a; --b;\n            if (a < b) std::swap(a, b);\n            g[b][t].pb(a);\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            std::set<int> mex;\n            for (auto e : g[i][t]) {\n                mex.insert(dp[e][t]);\n                // if (dp[e][t] == 0) {\n                //     dp[i][t] = 1;\n                //     break;\n                // }\n            }\n            while (mex.count(dp[i][t])) ++dp[i][t];\n            if (dp[i][t] < 2) {\n                byDp[dp[i][t]][t] = add(byDp[dp[i][t]][t], power[i + 1]);\n            }\n\n            // toMult[t].v[dp[i][t]] = add(toMult[t].v[dp[i][t]], power[i + 1]);\n        }\n    }\n    int answ = 0;\n    for (int mask = 0; mask < (1 << 3); ++mask) {\n        if (__builtin_popcount(mask) % 2 == 1) continue;\n        // debug(mask)\n        int toAdd = 1;\n        for (int i = 0; i < 3; ++i) {\n            toAdd = mult(toAdd, byDp[(mask >> i) & 1][i]);\n        }\n        // if (toAdd != 0) {\n        //     debug(mask << ' ' << toAdd)\n        // }\n        answ = add(answ, toAdd);\n    }\n    std::cout << answ;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nlld arr[300000];\nlld pref[300000];\nlld bi[300000];\nlld trep[300000];\nvector<lld> adj[300000][3];\nar<lld,3> siz;\nbool rem[300000][3];\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nlld chos(lld num) {return (num*(num-1)/2)%modd;}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,r,k,c,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n//     ans=0;\n     //cin>>TESTS;\n     memset(rem,false,sizeof(rem));\n     while(TESTS--)\n     {\n         cin>>n;\n         cin>>siz[0];\n         rep(i,0,siz[0]-1){\n            cin>>a>>b;a--;b--;\n            adj[a][0].pb(b);\n            adj[b][0].pb(a);\n            rem[max(a,b)][0]=true;\n         }\n         cin>>siz[1];\n         rep(i,0,siz[1]-1){\n            cin>>a>>b;a--;b--;\n            adj[a][1].pb(b);\n            adj[b][1].pb(a);\n            rem[max(a,b)][1]=true;\n         }\n         cin>>siz[2];\n         rep(i,0,siz[2]-1){\n            cin>>a>>b;a--;b--;\n            adj[a][2].pb(b);\n            adj[b][2].pb(a);\n            rem[max(a,b)][2]=true;\n         }\n         pref[1]=0;\n         pref[2]=1;\n         bi[2]=1;\n         rep(i,3,2*n){\n             pref[i]=pref[i-1];\n             if (i<=n)pref[i]+=i-1;\n             else pref[i]+=2*n-i+1;\n             pref[i]%=modd;\n             bi[i]=pref[i]-pref[i-1]+modd;\n             bi[i]%=modd;\n         }\n         rep(i,3,3*n){\n            lld mini=max(2ll,i-n);\n            lld maxi=min(2*n,i-1);\n            trep[i]=pref[maxi]-pref[mini-1]+modd;\n            trep[i]%=modd;\n         }\n         lld ans=0;\n         lld bad=0;\n         rep(i,4,3*n) ans=(ans+(trep[i]*fastpower(fastpower(10,18,modd),i,modd))%modd)%modd;\n         rep(i,2,2*n) bad=(bad+(bi[i]*fastpower(fastpower(10,18,modd),(i)%modd,modd))%modd)%modd;\n         //cout<<ans<<\"\\n\";\n         rep(i,0,n-1) {\n            if (rem[i][0]){\n                ans=(ans-(fastpower(fastpower(10,18,modd),i+1,modd)*bad)%modd+modd)%modd;\n            }\n            if (rem[i][1]){\n                ans=(ans-(fastpower(fastpower(10,18,modd),i+1,modd)*bad)%modd+modd)%modd;\n            }\n            if (rem[i][2]){\n                ans=(ans-(fastpower(fastpower(10,18,modd),i+1,modd)*bad)%modd+modd)%modd;\n            }\n         }\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\n#define MP make_pair\n#define fi first\n#define se second\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\nconst int N = 100003, M = 1024, mod = 998244353;\ntemplate<typename T>\nvoid read(T &x){\n\tint ch = getchar(); x = 0; bool f = false;\n\tfor(;ch < '0' || ch > '9';ch = getchar()) f |= ch == '-';\n\tfor(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';\n\tif(f) x = -x;\n}\nvoid qmo(int &x){x += (x >> 31) & mod;}\nint ksm(int a, int b){\n\tint res = 1;\n\tfor(;b;b >>= 1, a = (LL) a * a % mod) if(b & 1) res = (LL) res * a % mod;\n\treturn res;\n}\ntemplate<typename T>\ninline bool chmax(T &a, const T &b){if(a < b) return a = b, 1; return 0;}\ntemplate<typename T>\ninline bool chmin(T &a, const T &b){if(a > b) return a = b, 1; return 0;}\nint n, m, head[N], to[N], nxt[N], cnt, f[3][M], sg[N], pw[N], ans; bool vis[N];\nvoid add(int a, int b){\n\tto[++ cnt] = b; nxt[cnt] = head[a]; head[a] = cnt;\n}\nvoid solve(int t){\n\tcnt = 0; read(m);\n\tfor(Rint i = 1;i <= n;++ i) head[i] = sg[i] = 0;\n\tfor(Rint i = 1, u, v;i <= m;++ i){\n\t\tread(u); read(v); if(u > v) swap(u, v); add(u, v);\n\t}\n\tfor(Rint i = n;i;-- i){\n\t\tfor(Rint j = head[i];j;j = nxt[j]) vis[sg[to[j]]] = true;\n\t\tfor(;vis[sg[i]];++ sg[i]); qmo(f[t][sg[i]] += pw[i] - mod);\n\t\tfor(Rint j = head[i];j;j = nxt[j]) vis[sg[to[j]]] = false;\n\t}\n}\nint main(){\n\tread(n); pw[0] = 1; pw[1] = 716070898;\n\tfor(Rint i = 2;i <= n;++ i) pw[i] = (LL) pw[i-1] * pw[1] % mod;\n\tfor(Rint t = 0;t < 3;++ t) solve(t);\n\tfor(Rint i = 0;i < M;++ i)\n\t\tfor(Rint j = 0;j < M;++ j)\n\t\t\tqmo(ans += (LL) f[0][i] * f[1][j] % mod * f[2][i^j] % mod - mod);\n\tprintf(\"%d\\n\", ans);\n} // NTFTSD0"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i=(a); i<(int)(b); i++)\n#define FORD(i, a, b) for (int i=a; i>(int)(b); i--)\n#define PPC(x) __builtin_popcount(x)\n#define SZ(x) ((int)(x).size())\n#define MSB(x) (31 - __builtin_clz(x))\n#define pb push_back\n#define ALL(x) (x).begin(), (x).end()\n#define ithBit(m, i) ((m) >> (i) & 1)\n#define ft first\n#define sd second\n#ifdef DEBUG\n#include \"debug.h\"\n#else\n#define dbg(...) 0\n#endif\nusing namespace std;\n \nconst int maxN = 1 << 19, maxS = 413, mod = 998244353;\nconst long long INF = 1000000000000000000ll;\n\ntemplate <class T1, class T2> inline void addMod(T1& a, T2 b)\t{   a = (a + b) % mod;  }\ntemplate <class T1, class T2> inline void multMod(T1& a, T2 b)\t{   a = a * b % mod;    }\n\nlong long pows[maxN], T[3][maxS];\nvector <int> graph[3][maxN];\nint mex[maxN], vis[maxN];\n \nint main()\n{\n\tint n;\n\tscanf (\"%d\", &n);\n\tpows[1] = INF % mod;\n\tFOR(i, 2, n+1)\n\t\tpows[i] = pows[i-1] * pows[1] % mod;\n\tFOR(s, 0, 3)\n\t{\n\t\tvector <int>* G = graph[s];\n\t\tint m;\n\t\tscanf (\"%d\", &m);\n\t\twhile (m--)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf (\"%d%d\", &a, &b);\n\t\t\tif (a > b)\n\t\t\t\tswap(a, b);\n\t\t\tG[a].pb(b);\n\t\t}\n\t\t\n\t\tFORD(v, n, 0)\n\t\t{\n\t\t\tfor (int u : G[v])\n\t\t\t\tvis[mex[u]] = v;\n\t\t\tfor (mex[v] = 0; vis[mex[v]] == v; mex[v]++) ;\n\t\t\taddMod(T[s][mex[v]], pows[v]);\n\t\t}\n\t\t\n\t\tfill(vis, vis+n+1, 0);\n\t}\n\t\n\tlong long res = 0;\n\tFOR(a, 0, maxS) FOR(b, 0, maxS) FOR(c, 0, maxS) if ((a^b^c) == 0)\n\t{\n\t\tlong long tak = T[0][a];\n\t\tmultMod(tak, T[1][b]);\n\t\tmultMod(tak, T[2][c]);\n\t\taddMod(res, tak);\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct SumNode { UL a, b, c; };\n\nstruct Problem {\n\t/*\n\tUL F[4][4] = {\n\t\t{0, 1, 2, 3},\n\t\t{1, 0, 1, 2},\n\t\t{2, 1, 0, 1},\n\t\t{3, 2, 1, 0}\n\t};\n\n\tUL V[1000000];*/\n\n\tbool G[501][501] = {};\n\n\tvoid Solve() {\n\t\t/*\n\t\tUL N; cin >> N; N--;\n\t\t{\n\t\t\tUL a; cin >> a;\n\t\t\trep(i, N) {\n\t\t\t\tUL t; cin >> t;\n\t\t\t\tV[i] = F[a][t];\n\t\t\t\ta = t;\n\t\t\t}\n\t\t}*/\n\t\tconst ULL M = 998244353;\n\t\tconst ULL Z = 1000000000000000000 % 998244353;\n\n\t\tUL N; cin >> N;\n\t\tUL S[3];\n\t\tvector<vector<UL>> E[3];\n\t\trep(i, 3) {\n\t\t\tcin >> S[i];\n\t\t\tE[i].resize(N);\n\t\t\trep(j, S[i]) {\n\t\t\t\tUL u, v; cin >> u >> v; u--; v--;\n\t\t\t\tE[i][u].push_back(v);\n\t\t\t\tE[i][v].push_back(u);\n\t\t\t}\n\t\t}\n\t\tvector<UL> POWZ(N * 3 + 1); POWZ[0] = 1;\n\t\trep(i, N * 3) POWZ[i + 1] = POWZ[i] * Z % M;\n\t\tvector<ULL> A[3] = {};\n\t\trep(t, 3) {\n\t\t\t//cout << \"t = \" << t << endl;\n\t\t\tA[t].resize(N);\n\t\t\tvector<UL> F(N);\n\t\t\tfor (UL v = N - 1; v != -1; v--) {\n\t\t\t\tA[t][F[v]] = (A[t][F[v]] + POWZ[v + 1]) % M;\n\t\t\t\tfor (UL e : E[t][v]) {\n\t\t\t\t\tif (F[e] == F[v]) F[e] = F[v] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//rep(i, N) cout << F[i] << \" \"; cout << endl;\n\t\t}\n\n\n\t\tvector<SumNode> Q;\n\n\t\t{\n\t\t\tUL SX = min(N, 500u);\n\t\t\tfor (UL s = 0; s < SX * 3; s++) {\n\t\t\t\tfor (UL a = 0; a <= min(s, SX); a++) {\n\t\t\t\t\tfor (UL b = a; a + b + b <= s; b++) {\n\t\t\t\t\t\tUL c = s - a - b;\n\t\t\t\t\t\tif (c >= SX) continue;\n\t\t\t\t\t\tif (G[a][b]) continue;\n\t\t\t\t\t\tif (G[a][c]) continue;\n\t\t\t\t\t\tif (G[b][c]) continue;\n\t\t\t\t\t\tG[a][b] = G[a][c] = G[b][c] = true;\n\t\t\t\t\t\tQ.push_back({ a,b,c });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tULL ans = 0;\n\t\tfor (SumNode s : Q) {\n\t\t\tif (s.a == s.b && s.a == s.c) {\n\t\t\t\tans += A[0][s.a] * A[1][s.a] % M * A[2][s.a] % M;\n\t\t\t}\n\t\t\telse if (s.a != s.b && s.a != s.c && s.b != s.c) {\n\t\t\t\tans += A[0][s.a] * A[1][s.b] % M * A[2][s.c] % M;\n\t\t\t\tans += A[0][s.a] * A[1][s.c] % M * A[2][s.b] % M;\n\t\t\t\tans += A[0][s.b] * A[1][s.a] % M * A[2][s.c] % M;\n\t\t\t\tans += A[0][s.c] * A[1][s.a] % M * A[2][s.b] % M;\n\t\t\t\tans += A[0][s.b] * A[1][s.c] % M * A[2][s.a] % M;\n\t\t\t\tans += A[0][s.c] * A[1][s.b] % M * A[2][s.a] % M;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s.a == s.b) swap(s.a, s.c);\n\t\t\t\telse if (s.a == s.c) swap(s.a, s.b);\n\t\t\t\tans += A[0][s.a] * A[1][s.b] % M * A[2][s.b] % M;\n\t\t\t\tans += A[0][s.b] * A[1][s.a] % M * A[2][s.b] % M;\n\t\t\t\tans += A[0][s.b] * A[1][s.b] % M * A[2][s.a] % M;\n\t\t\t}\n\t\t\tans %= M;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nvoid radd(int &a, int b)\n{\n\ta=add(a,b); \n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nvoid rmult(int &a, int b)\n{\n\ta=mult(a,b);\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\n\t\nint a[3][111111];\nvi adj[3][111111];\n//wtf FWHT for 900 pts\nint c[3][200000];\n\nvoid fwht(int *data, int dim=131072) {\n    for (int len = 1; 2 * len <= dim; len <<= 1) {\n        for (int i = 0; i < dim; i += 2 * len) {\n            for (int j = 0; j < len; j++) {\n                int a = data[i + j];\n                int b = data[i + j + len];\n                \n                data[i + j] = add(a,b);\n                data[i + j + len] = add(a,MOD-b);\n            }   \n        }\n    }\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int z=0;z<3;z++)\n\t{\n\t\tint m; cin>>m;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint u,v; cin>>u>>v;u--; v--;\n\t\t\tif(u>v) swap(u,v);\n\t\t\tadj[z][u].pb(v);\n\t\t}\n\t}\n\tll C = ll(1e18);\n\tC%=MOD;\n\tint ans=0;\n\tfor(int z=0;z<3;z++)\n\t{\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tset<int> S;\n\t\t\tfor(int v:adj[z][i])\n\t\t\t{\n\t\t\t\tS.insert(a[z][v]);\n\t\t\t}\n\t\t\ta[z][i]=0;\n\t\t\twhile(S.find(a[z][i])!=S.end())\n\t\t\t{\n\t\t\t\ta[z][i]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int z=0;z<3;z++)\n\t{\n\t\tint curC=C;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tc[z][a[z][i]]=add(c[z][a[z][i]],curC);\n\t\t\tcurC=mult(curC,C);\n\t\t}\n\t}\n\tfwht(c[0]);\n\tfwht(c[1]);\n\tfwht(c[2]);\n\tfor(int i=0;i<131072;i++)\n\t{\n\t\tc[0][i]=mult(c[0][i],c[1][i]);\n\t\tc[0][i]=mult(c[0][i],c[2][i]);\n\t}\n\tfwht(c[0]);\n\tint invv = modpow(131072,MOD-2);\n\tcout<<mult(c[0][0],invv)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAX_N = int(1e5) + 10;\nconst int mod = 998244353;\n\nint n, m, base;\n\nstruct Graph {\n\tint sg[MAX_N], cnt[MAX_N], ext[MAX_N];\n\tstd::vector<int> edges[MAX_N];\n\n\tvoid addEdge(int x, int y) {\n\t\tif (x > y) std::swap(x, y);\n\t\tedges[x].emplace_back(y);\n\t}\n\n\tvoid getSG(int x) {\n\t\tfor (auto p : edges[x]) ext[sg[p]] = 1;\n\t\twhile (ext[sg[x]]) ++sg[x];\n\t\tfor (auto p : edges[x]) ext[sg[p]] = 0;\n\t}\n\n\tvoid init() {\n\t\tint x = 1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tx = 1LL * base * x % mod;\n\t\t\t(cnt[sg[i]] += x) %= mod;\n\t\t}\n\t}\n} g[3];\n\nint main() {\n\tbase = 1;\n\tfor (int i = 1; i <= 18; ++i) {\n\t\tbase = 1LL * base * 10 % mod;\n\t}\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tscanf(\"%d\", &m);\n\t\twhile (m--) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tg[i].addEdge(x, y);\n\t\t}\n\t\tfor (int j = n; j; --j) {\n\t\t\tg[i].getSG(j);\n\t\t}\n\t\tg[i].init();\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < 512; ++i) {\n\t\tfor (int j = 0; j < 512; ++j) {\n\t\t\tint d = 1LL * g[0].cnt[i] * g[1].cnt[j] % mod * g[2].cnt[i ^ j] % mod;\n\t\t\t(ans += d) %= mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\n#define re register\n#define LL long long\n#define MOD 998244353\n#define MAXN 100005\nusing namespace std;\nLL n,ans,bs[3*MAXN];\nLL rd(){\n\tLL x=0,tp=1;char c;c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')tp=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=(x*10+c-'0');c=getchar();}\n\treturn x*tp;\n}\nstruct Graph{\n\tLL m,sg[MAXN],f[MAXN];\n\tvector<int>e[MAXN];\n\tvoid work(){\n\t\tint x,y;\n\t\tm=rd();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tx=rd(),y=rd();\n\t\t\tif(x>y)swap(x,y);\n\t\t\te[x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tset<int>s;\n\t\t\tint sz=e[i].size();\n\t\t\tfor(int j=0;j<sz;j++)s.insert(sg[e[i][j]]);\n\t\t\twhile(s.count(sg[i]))sg[i]++;\n\t\t\t(f[sg[i]]+=bs[i])%=MOD;\n\t\t\t// printf(\"sg[%d]=%d\\n\",i,sg[i]);\n\t\t}\n\t}\n}g[3];\nint main(){\n\t// freopen(\"testdata.in\",\"r\",stdin);\n\t// freopen(\"shit.out\",\"w\",stdout);\n\tn=rd();int Sqr=sqrt(3*n);\n\tbs[0]=1;LL fuck=1000000000000000000ll%MOD;\n\tfor(int i=1;i<=3*n;i++)bs[i]=bs[i-1]*fuck%MOD;\n\tfor(int i=0;i<3;i++)g[i].work();\n\tfor(int i=0;i<=Sqr;i++)\n\t\tfor(int j=0;j<=Sqr;j++)\n\t\t\t(ans+=g[0].f[i]*g[1].f[j]%MOD*g[2].f[i^j]%MOD)%=MOD;\n\tprintf(\"%lld\\n\",ans);\n\t// printf(\"%.2lf\\n\",(double)clock()/CLOCKS_PER_SEC);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lld;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define trav(a,v) for(auto a:v)\n#define MOD 998244353\nvector<int> nei[1000000][3];\nint used[1000000][3];\n\nint main(){\n  lld base=1;\n  rep(i,0,18){\n    base*=10;\n    base%=MOD;\n  }\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin>>n;\n  rep(i,0,3){\n    int m;\n    cin>>m;\n    rep(j,0,m){\n      int x,y;\n      cin>>x>>y;\n      x--;y--;\n      if(x>y)swap(x,y);\n      nei[x][i].push_back(y);\n    }\n  }\n  /*lld Res[3][2];\n  rep(k,0,3){\n    rep(i,0,2)Res[k][i]=0;\n    rep(i,0,n)used[i][k]=-1;\n    for(int i=n-1;i>-1;i--){\n      if(used[i][k]==-1){\n\tused[i][k]=1;\n\ttrav(a,nei[i][k]){\n\t  used[a][k]=0;\n\t}\n      }\n    }\n    lld Pow=base;\n    rep(i,0,n){\n      if(used[i][k]){\n\tRes[k][1]+=Pow;\n\tRes[k][1]%=MOD;\n      }else{\n\tRes[k][0]+=Pow;\n\tRes[k][0]%=MOD;\n      }\n      Pow*=base;\n      Pow%=MOD;\n    }\n  }\n  lld ans=0;\n  rep(msk,0,8){\n    lld can=1;\n    int cnt=0;\n    rep(i,0,3){\n      if((msk>>i)%2>0)can*=Res[i][1],cnt++;\n      else can*=Res[i][0];\n      can%=MOD;\n    }\n    cnt%=2;\n    //ans+=can;\n    if(cnt==1){\n      ans+=can;\n      ans%=MOD;\n    }\n    }\n    cout<<ans<<endl;*/\n  int nim[n][3];\n  int max_nim=0;\n  set<int> s;\n  rep(j,0,3){\n    for(int i=n-1;i>-1;i--){\n      s.clear();\n      trav(a,nei[i][j]){\n\ts.insert(nim[a][j]);\n      }\n      int cnt=0;\n      while(s.find(cnt)!=s.end())cnt++;\n      nim[i][j]=cnt;\n      max_nim=max(max_nim,cnt+1);\n    }\n  }\n  lld Tot[max_nim][3];\n  rep(i,0,max_nim){\n    rep(j,0,3)Tot[i][j]=0;\n  }\n  //cout<<base<<endl;\n  rep(j,0,3){\n    lld Pow=base;\n    rep(i,0,n){\n      Tot[nim[i][j]][j]+=Pow;\n      Tot[nim[i][j]][j]%=MOD;\n      Pow*=base;\n      Pow%=MOD;\n    }\n  }\n  /*rep(i,0,max_nim){\n    rep(j,0,3)cout<<Tot[i][j]<<\" \";\n    cout<<endl;\n  }*/\n  lld ans=0;\n  rep(i,0,max_nim){\n    rep(j,0,max_nim){\n      if((i^j)<max_nim){\n      lld can=1;\n      can*=Tot[i][0];\n      can%=MOD;\n      can*=Tot[j][1];\n      can%=MOD;\n      can*=Tot[i^j][2];\n      can%=MOD;\n      ans+=can;\n      ans%=MOD;\n      //cout<<i<<\" \"<<j<<\" \"<<(i^j)<<endl;\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\n#include<set>\n#include<vector>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nset<int>s[3],ss;\nvector<int>p[3][100010];\nconst int mod=998244353;\ninline int ad(int x){return x>=mod?x-mod:x;}\ninline int dec(int x){return x<0?x+mod:x;}\ninline int power(int a,int b)\n{\n\tint ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}return ans;\n}\nint pw[100010],sum[3],pre[3];\nint main()\n{\n    //freopen(\"a.in\",\"r\",stdin);\n    //freopen(\"a.out\",\"w\",stdout);\n    pw[1]=1;\n    for(int i=1;i<=18;i++)pw[1]=1LL*pw[1]*10%mod;\n   \tint n=read(),ans=0;\n   \tfor(int i=2;i<=n;i++)pw[i]=1LL*pw[i-1]*pw[1]%mod;\n\tfor(int T=0;T<3;T++)\n\t{\n\t\tint m=read();\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x=read(),y=read();if(x<y)swap(x,y);\n\t\t\tp[T][x].push_back(y);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)s[T].insert(i);\n\t}\n\tbool bk=true;\n\twhile(s[0].empty()!=true || s[1].empty()!=true || s[2].empty()!=true)\n\t{\n\t\tint prod=1;\n\t\tfor(int T=0;T<3;T++)\n\t\t{\n\t\t\tsum[T]=0;ss=s[T];\n\t\t\twhile(ss.empty()!=true)\n\t\t\t{\n\t\t\t\tint x=*ss.rbegin();sum[T]=ad(sum[T]+pw[x]);ss.erase(x),s[T].erase(x);\n\t\t\t\tfor(int i=0;i<p[T][x].size();i++)ss.erase(p[T][x][i]);\n\t\t\t}prod=1LL*prod*sum[T]%mod;\n\t\t\tif(bk==true)pre[T]=sum[T];\n\t\t}if(bk==true)bk=false;\n\t\tfor(int T=0;T<3;T++)ans=ad(ans+1LL*prod*power(sum[T],mod-2)%mod*pre[T]%mod);\n\t}\n\tpr2(dec(ans-ad(1LL*pre[0]*pre[1]%mod*pre[2]%mod*2)));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <limits.h>\n#include <fstream>\n\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define pll pair <ll, ll>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n#define uint unsigned int\n\nconst int maxn = (int)1e6 + 10, mod = 998244353;\nchar s[maxn];\n\nint mul(int x, int y) {\n\treturn (ll)x * y % mod;\n}\n\nint add(int x, int y) {\n\tx += y;\n\tif (x >= mod) {\n\t\tx -= mod;\n\t}\n\treturn x;\n}\n\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) {\n\t\tx += mod;\n\t}\n\treturn x;\n}\n\nint my_pow(int x, int y) {\n\tint ans = 1;\n\n\twhile (y) {\n\t\tif (y & 1) {\n\t\t\tans = mul(ans, x);\n\t\t}\n\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int maxlog = 23;\nint g[maxlog + 1];\n\nint rev(int x, int st) {\n\tint y = 0;\n\n\tfor (int i = 0; i < st; i++) {\n\t\ty <<= 1;\n\t\ty += x & 1;\n\t\tx >>= 1;\n\t}\n\treturn y;\n}\n\nvoid fft(vector <int> &v, int st, bool fl) {\n\tint n = (1 << st);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = rev(i, st);\n\t\tif (x < i) {\n\t\t\tswap(v[i], v[x]);\n\t\t}\n\t}\n\n\tint pos = 0;\n\n\tfor (int len = 2; len <= n; len <<= 1) {\n\t\tpos++;\n\t\tint wlen = g[pos];\n\n\t\tfor (int i = 0; i < n; i += len) {\n\t\t\tint w = 1;\n\n\t\t\tfor (int j = i; j < i + len / 2; j++) {\n\t\t\t\tint a = v[j];\n\t\t\t\tint b = mul(v[j + len / 2], w);\n\t\t\t\tv[j] = add(a, b);\n\t\t\t\tv[j + len / 2] = sub(a, b);\n\n\t\t\t\tw = mul(w, wlen);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fl) {\n\t\treverse(1 + all(v));\n\t\tint rn = my_pow(n, mod - 2);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = mul(v[i], rn);\n\t\t}\n\t}\n}\n\nint n;\n\nvector <int> red[maxn];\n\nconst int mag = 19;\n\nint mex(vector <int> a) {\n\tvector <int> cnt((int)a.size() + 1, 0);\n\n\tfor (int x : a) {\n\t\tif (x < (int)cnt.size()) {\n\t\t\tcnt[x]++;\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\twhile (cnt[ans]) {\n\t\tans++;\n\t}\n\n\treturn ans;\n}\n\nvector <int> get() {\n\tint m;\n\tcin >> m;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tred[i].clear();\n\t}\n\n\twhile (m--) {\n\t\tint x, y;\n\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tred[y].push_back(x);\n\t\tred[x].push_back(y);\n\t}\n\n\tvector <int> ans(1 << mag, 0);\n\n\tint f = my_pow(10, 18);\n\tint x = 1;\n\n\tvector <int> ps(n + 1);\n\n\tfor (int i = n; i > 0; i--) {\n\t\tvector <int> a;\n\n\t\tfor (int u : red[i]) {\n\t\t\tif (u > i) {\n\t\t\t\ta.push_back(ps[u]);\n\t\t\t}\n\t\t}\n\n\t\tps[i] = mex(a);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tx = mul(x, f);\n\n\t\tans[ps[i]] = add(ans[ps[i]], x);\n\t}\n\n\treturn ans;\n}\n\nvector <int> operator *(vector <int> a, vector <int> b) {\n\tvector <int> c(a.size(), 0);\n\n\tfor (int i = 0; i < (1 << 13); i++) {\n\t\tfor (int j = 0; j < (1 << 13); j++) {\n\t\t\tc[i ^ j] = add(c[i ^ j], mul(a[i], b[j]));\n\t\t}\n\t}\n\n\treturn c;\n}\n\nint main() {\n\tg[maxlog] = my_pow(3, (mod - 1) / (1 << maxlog));\n\tfor (int i = maxlog - 1; i >= 0; i--) {\n\t\tg[i] = mul(g[i + 1], g[i + 1]);\n\t}\n\n\tcin >> n;\n\tauto a = get();\n\tauto b = get();\n\tauto c = get();\n\n\ta = a * b;\n\ta = a * c;\n\n\tcout << a[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Created by Nikolay Budin\n\n#ifdef DEBUG\n#  define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define ff first\n#define ss second\n#define szof(x) ((int)x.size())\n#ifndef LOCAL\n#  define cerr __get_ce\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename K, typename V> using ordered_map = tree<K, V, less<K>, rb_tree_tag, tree_order_statistics_node_update>;\n\nint const INF = (int)1e9 + 1e3;\nll const INFL = (ll)1e18 + 1e6;\n#ifdef LOCAL\n\tmt19937 tw(9450189);\n#else\n\tmt19937 tw(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\nuniform_int_distribution<ll> ll_distr;\nll rnd(ll a, ll b) { return ll_distr(tw) % (b - a + 1) + a; }\n\nconst int MOD = 998244353;\n\nvoid add(int& a, int b) {\n\ta += b;\n\tif (a >= MOD) {\n\t\ta -= MOD;\n\t}\n}\n\nint sum(int a, int b) {\n\tadd(a, b);\n\treturn a;\n}\n\nint mult(int a, int b) {\n\treturn (ll) a * b % MOD;\n}\n\nint mpow(int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tret = mult(ret, a);\n\t\t}\n\t\ta = mult(a, a);\n\t\tb /= 2;\n\t}\n\treturn ret;\n}\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tvector<int> arr1(3), arr2(3);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<vector<int>> graph(n);\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\t--a; --b;\n\t\t\tif (a > b) {\n\t\t\t\tswap(a, b);\n\t\t\t}\n\t\t\tgraph[a].push_back(b);\n\t\t}\n\n\t\tvector<bool> take(n);\n\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int to : graph[j]) {\n\t\t\t\tcnt += take[to];\n\t\t\t}\n\t\t\tif (cnt == 0) {\n\t\t\t\tadd(arr1[i], mpow(10, 18 * (j + 1)));\n\t\t\t\t// cerr << i << \" \" << j << \" \" << 1 << endl;\n\t\t\t\ttake[j] = true;\n\t\t\t} else if (szof(graph[j]) == 1) {\n\t\t\t\tadd(arr2[i], mpow(10, 18 * (j + 1)));\n\t\t\t\t// cerr << i << \" \" << j << \" \" << 2 << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tadd(ans, mult(mult(arr1[0], arr1[1]), arr1[2]));\n\n\tadd(ans, mult(mult(arr2[0], arr2[1]), arr1[2]));\n\tadd(ans, mult(mult(arr2[0], arr1[1]), arr2[2]));\n\tadd(ans, mult(mult(arr1[0], arr2[1]), arr2[2]));\n\n\tcout << ans << \"\\n\";\n}\n\n\nint main() {\n#ifdef LOCAL\n\tauto start_time = clock();\n\tcerr << setprecision(3) << fixed;\n#endif\n\tcout << setprecision(15) << fixed;\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test_count = 1;\n\t// cin >> test_count;\n\tfor (int test = 1; test <= test_count; ++test) {\n\t\tsolve();\n\t}\n\n#ifdef LOCAL\n\tauto end_time = clock();\n\tcerr << \"Execution time: \" << (end_time - start_time) * (int)1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int mod=998244353;\nint n,pw[300005];\ninline void inc(int& x,int y){x=x+y<mod?x+y:x+y-mod;}\n\nstruct Graph{\n\tint m,sg[100005],vis[100005],val[100005];\n\tvector<int> E[100005];\n\tvoid dfs(int u){\n\t\tfor(int v:E[u])if(!~sg[v])dfs(v);\n\t\tfor(int v:E[u])vis[sg[v]]=1;\n\t\tsg[u]=0;\n\t\twhile(vis[sg[u]])++sg[u];\n\t\tfor(int v:E[u])vis[sg[v]]=0;\n\t}\n\tvoid calSG(){\n\t\tmemset(sg,-1,sizeof sg);\n\t\tREP(i,1,n)if(!~sg[i])dfs(i);\n\t\tREP(i,1,n)inc(val[sg[i]],pw[i]);\n\t}\n} G[3];\n\nint main(){\n\t// freopen(\"in.in\",\"r\",stdin);\n\tint b=((ll)1e18)%mod;\n\tREP(i,pw[0]=1,300001)pw[i]=1ll*pw[i-1]*b%mod;\n\tn=read();\n\tREP(t,0,2){\n\t\tG[t].m=read();\n\t\tREP(i,1,G[t].m){\n\t\t\tint u=read(),v=read();\n\t\t\tif(u>v)swap(u,v);\n\t\t\tG[t].E[u].pb(v);\n\t\t}\n\t\tG[t].calSG();\n\t}\n\tint ans=0;\n\tREP(a,0,sqrt(G[0].m)*2)REP(b,0,sqrt(G[1].m)*2){\n\t\tint c=a^b;\n\t\tinc(ans,1ll*G[0].val[a]*G[1].val[b]%mod*G[2].val[c]%mod);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,abm,mmx,popcnt,avx,avx2,tune=native\")\n           \n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n           \n//#define int long long\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pld;\n\ntemplate<typename T>\nusing kawaii_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n  \nvoid FAST_IO() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.setf(ios::fixed);\n    //cout.precision(20);\n    #ifndef _offline\n    //freopen(\"mincost.in\", \"r\", stdin);\n    //freopen(\"mincost.out\", \"w\", stdout);\n    #endif\n}\n\nconst ll mod = 998244353;\nconst ll kek = 716070898;\nconst int K = 350;\nconst int MAXN = 1e5 + 100;\nvector<int> g1[MAXN], g2[MAXN], g3[MAXN];\nint v1[MAXN], v2[MAXN], v3[MAXN];\nll s1[K], s2[K], s3[K];\n\nll binpow(ll a, ll n) {\n    ll res = 1;\n    while (n) {\n        if (n & 1) {\n            res = (res * a) % mod;\n        }\n        a = (a * a) % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nvoid relax1(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g1[u]) {\n        bs[v1[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v1[u] = i;\n            break;\n        }\n    }\n    s1[v1[u]] += binpow(kek, u + 1);\n    if (s1[v1[u]] >= mod) {\n        s1[v1[u]] -= mod;\n    }\n}\n\nvoid relax2(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g2[u]) {\n        bs[v2[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v2[u] = i;\n            break;\n        }\n    }\n    s2[v2[u]] += binpow(kek, u + 1);\n    if (s2[v2[u]] >= mod) {\n        s2[v2[u]] -= mod;\n    }\n}\n\nvoid relax3(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g3[u]) {\n        bs[v3[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v3[u] = i;\n            break;\n        }\n    }\n    s3[v3[u]] += binpow(kek, u + 1);\n    if (s3[v3[u]] >= mod) {\n        s3[v3[u]] -= mod;\n    }\n}\n\nsigned main() {\n    FAST_IO();\n    int n;\n    cin >> n;\n    int m1;\n    cin >> m1;\n    for (int i = 0; i < m1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g1[u].push_back(v);\n    }\n    int m2;\n    cin >> m2;\n    for (int i = 0; i < m2; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g2[u].push_back(v);\n    }\n    int m3;\n    cin >> m3;\n    for (int i = 0; i < m3; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g3[u].push_back(v);\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        relax1(i);\n        relax2(i);\n        relax3(i);\n    }\n    vector<tuple<int, int, int>> kektor;\n    for (int i = 0; i < K; ++i) {\n        if (s1[i] == 0) {\n            continue;\n        }\n        for (int j = 0; j < K; ++j) {\n            if (s2[j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < K; ++k) {\n                if (s3[k] == 0) {\n                    continue;\n                }\n                kektor.push_back(make_tuple(i, j, k));\n            }\n        }\n    }\n    sort(all(kektor), [&](tuple<int, int, int> a, tuple<int, int, int> b) {\n        return get<0>(a) + get<1>(a) + get<2>(a) < get<0>(b) + get<1>(b) + get<2>(b);\n    });\n    set<pii> xy, xz, yz;\n    ll ans = 0;\n    for (auto t : kektor) {\n        int x, y, z;\n        tie(x, y, z) = t;\n        if (xy.count(make_pair(x, y)) || xz.count(make_pair(x, z)) || yz.count(make_pair(y, z))) {\n            continue;\n        }\n        ll val = (s1[x] * s2[y]) % mod;\n        val = (val * s3[z]) % mod;\n        ans += val;\n        if (ans >= mod) {\n            ans -= mod;\n        }\n        xy.insert(make_pair(x, y));\n        xz.insert(make_pair(x, z));\n        yz.insert(make_pair(y, z));\n    }\n    cout << ans << '\\n';\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 998244353;\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<map<int, Mint>> mp(3);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tvector<vector<int>> E(n + 1);\n\t\tvector<int> nim(n + 1);\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tif (a > b) swap(a, b);\n\t\t\tE[a].push_back(b);\n\t\t}\n\t\tfor (int j = n; j >= 1; --j) {\n\t\t\tset<int> vals;\n\t\t\tfor (int x : E[j]) {\n\t\t\t\tvals.insert(nim[x]);\n\t\t\t}\n\t\t\twhile (vals.count(nim[j])) ++nim[j];\n\t\t\tmp[i][nim[j]] += modex(Mint(1e18), j);\n\t\t}\n\t}\n\tMint ans = 0;\n\tfor (auto& ak : mp[0]) {\n\t\tint a = ak.first;\n\t\tfor (auto& bk : mp[1]) {\n\t\t\tint b = bk.first;\n\t\t\tint c = a ^ b;\n\t\t\tauto it = mp[2].find(c);\n\t\t\tif (it == mp[2].end()) continue;\n\t\t\tans += it->second * bk.second * ak.second;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\n\nint n,m[3],gr[3][100005];\nvi g[3][100005];\nMint sum[3][450],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,3){\n\t\tcin>>m[i];\n\t\trep(j,m[i]){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tg[i][--a].pb(--b);\n\t\t\tg[i][b].pb(a);\n\t\t}\n\t\tvi p;\n\t\trrep(j,n){\n\t\t\tp.clear();\n\t\t\tfor(auto &k:g[i][j]){\n\t\t\t\tif(j<k){\n\t\t\t\t\tp.pb(gr[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(p));\n\t\t\tp.erase(unique(all(p)),p.end());\n\t\t\tgr[i][j]=-1;\n\t\t\trep(k,si(p)){\n\t\t\t\tif(k!=p[k]){\n\t\t\t\t\tgr[i][j]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(gr[i][j]==-1)gr[i][j]=si(p);\n\t\t\tsum[i][gr[i][j]]+=Mint(10).pow(18*(j+1));\n\t\t}\n\t}\n\trep(i,450){\n\t\trep(j,450){\n\t\t\trep(k,450){\n\t\t\t\tif((i^j^k)==0){\n\t\t\t\t\tans+=sum[0][i]*sum[1][j]*sum[2][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=100005;\nconst int mo=998244353;\nint n;\nint power(int x,int y){\n\tint s=1;\n\tfor (;y;y/=2,x=1ll*x*x%mo)\n\t\tif (y&1) s=1ll*s*x%mo;\n\treturn s;\n}\nstruct G{\n\tvector<int> e[N];\n\tint vis[N],T,sg[N],a[N];\n\tvoid init(){\n\t\tint m;\n\t\tscanf(\"%d\",&m);\n\t\tFor(i,1,m){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\te[min(x,y)].PB(max(x,y));\n\t\t}\n\t\tRep(i,n,1){\n\t\t\t++T;\n\t\t\tfor (auto j:e[i]) vis[sg[j]]=T;\n\t\t\tfor (;vis[sg[i]]==T;++sg[i]);\n\t\t\t//cout<<i<<' '<<sg[i]<<endl;\n\t\t\ta[sg[i]]=(a[sg[i]]+power(10,18*i))%mo;\n\t\t}\n\t}\n}T[10];\nint main(){\n\tint ans=0;\n\tscanf(\"%d\",&n);\n\tFor(i,1,3) T[i].init();\n\tFor(i,0,1000) For(j,0,1000)\n\t\tans=(ans+1ll*T[1].a[i]*T[2].a[j]%mo*T[3].a[i^j])%mo;\n\tprintf(\"%d\\n\",ans);\n} \n/*\n3 3 3\n2 2 3\n2 3 2\n3 2 2\n1 1 3\n1 3 1\n3 1 1\n  1 2\nsg[4]=0;\nsg[3]=1;\nsg[2]\n*/"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = int(Y)-1;(X) >= int(S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=998244353;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return modInt<mod>(n%mod)/m;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(1123456);\nusing pmm=pair<mint,mint>;\n\nvector<pmm> solve(int n){\n\tconst mint pw=1'000'000'000'000'000'000%MOD;\n\tout(pw,pw*pw,1);\n\tvector<mint> pws(n+1); pws[0]=1;\n\trep(i,n) pws[i+1]=pws[i]*pw;\n\tint m;\n\tcin>>m;\n\tvv<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b; --a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tvector<int> gr(n);\n\trrep(v,n){\n\t\tvector<int> vs{MOD};\n\t\tfor(int w:g[v])if(w>v) vs.eb(gr[w]);\n\t\tsort(all(vs)); UNIQUE(vs);\n\t\trep(i,vs.size())if(vs[i]!=i){\n\t\t\tgr[v]=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint N=*max_element(all(gr))+1;\n\tvector<pmm> re(N);\n\trep(i,n){\n\t\tre[gr[i]].X+=pws[i+1];\n\t\tre[gr[i]].Y+=1;\n\t}\n\treturn re;\n}\nvector<int> solve_(int n){\n\tint m;\n\tcin>>m;\n\tvv<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b; --a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\tvector<int> ok(n,1);\n\tvector<int> re;\n\trrep(v,n)if(ok[v]){\n\t\tre.pb(v);\n\t\tfor(int w:g[v]) ok[w]=0;\n\t}\n\treturn re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tvv<pmm> vss(3);\n\trep(i,3) vss[i]=solve(n);\n\tout(vss,1);\n\tmint re=0;\n\trep(i,vss[0].size())rep(j,vss[1].size()){\n\t\tint k=i^j;\n\t\tif(k>=vss[2].size()) continue;\n\t\tauto a=vss[0][i];\n\t\tauto b=vss[1][j];\n\t\tauto c=vss[2][k];\n\t\tre+=a.X*b.X*c.X;\n\t\t// re+=a.X*b.Y*c.Y;\n\t\t// re+=b.X*a.Y*c.Y;\n\t\t// re+=c.X*b.Y*a.Y;\n\t}\n\tcout<<re NL;\n\t// vv<int> vss(3);\n\t// rep(i,3) vss[i]=solve(n);\n\t// int m=n;\n\t// rep(i,3) MN(m,(int)vss[i].size());\n\t// out(vss,1);\n\t// vector<int> vs(m);\n\t// rep(i,3)rep(j,m) vs[j]+=vss[i][j]+1;\n\t// mint re=0;\n\t// mint pw=modpow(mint(10),18);\n\t// for(int v:vs) re+=modpow(pw,v);\n\t// cout<<re NL;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nnamespace my_std {\nusing namespace std;\n#define reg register\n#define Rint register int\n#define FOR(i, a, b) for (register int i = (a), ed_##i = (b); i <= ed_##i; ++i)\n#define ROF(i, a, b) for (register int i = (a), ed_##i = (b); i >= ed_##i; --i)\n#define FORit(templ, arr, i, a, b) \\\nfor (register templ *i = (arr) + (a), *ed_##i = (arr) + (b) + 1; i != ed_##i; ++i)\n#define ROFit(templ, arr, i, a, b) \\\nfor (register templ *i = (arr) + (a), *ed_##i = (arr) + (b)-1; i != ed_##i; --i)\n#define GO(x, p, e, i, v) for (register int i = p[x].head, v; i; i = e[i].link)\n#define MEM(x, v) memset(x, v, sizeof(x))\n#define pb push_back\ntypedef long long i64;\n#define Templ(T) template <typename T>\ninline int read() {\n    reg int ans = 0, f = 1;\n    reg char c = getchar();\n    while (!isdigit(c)) f ^= (c == '-'), c = getchar();\n    for (; isdigit(c); c = getchar()) ans = (ans << 1) + (ans << 3) + (c ^ 48);\n    return f ? ans : -ans;\n}\nTempl(_Tp) inline int chkmin(_Tp &x, _Tp y) { return x > y ? x = y, 1 : 0; }\nTempl(_Tp) inline int chkmax(_Tp &x, _Tp y) { return x < y ? x = y, 1 : 0; }\n#define mod 998244353\ninline void inc(int &x, const int &y) { x += y; if (x >= mod) x -= mod; }\ninline void dec(int &x, const int &y) { x -= y; if (x < 0) x += mod; }\ninline void qmo(int &x){ x += (x >> 31) & mod; }\n} // namespace my_std\nusing namespace my_std;\n\n#define N 100010\n#define BN 610\nconst i64 V = i64(1e18) % mod;\n\nint n;\nstruct Graph{\n    vector<int> E[N];\n    int sg[N], n, m, val[BN], mxsg;\n    inline void build(){\n        n = ::n, m = read();\n        Rint u, v;\n        FOR(i, 1, m){\n            u = read(), v = read();\n            if(u > v) u ^= v ^= u ^= v;\n            E[u].pb(v);\n        }\n    }\n    inline void topo(){\n        int *c = new int[BN];\n        mxsg = 0;\n        memset(c, 0, sizeof(int) * BN);\n        ROF(u, n, 1){\n            for(Rint v: E[u]) c[sg[v]] = 1;\n            Rint t(0);\n            while(c[t]) ++t;\n            chkmax(mxsg, sg[u] = t);\n            for(Rint v: E[u]) c[sg[v]] = 0;\n        }\n        delete c;\n        Rint x(V);\n        FOR(i, 1, n){\n            qmo(val[sg[i]] += x - mod);\n            x = V * x % mod;\n        }\n    }\n}G[3];\n\nint main() {\n    n = read();\n    FOR(i, 0, 2) G[i].build(), G[i].topo();\n    Rint ans(0);\n    FOR(i, 0, G[0].mxsg) FOR(j, 0, G[1].mxsg){\n        qmo(ans += ((i64)G[0].val[i] * G[1].val[j] % mod\n            * G[2].val[i ^ j] % mod) - mod);\n    }\n    printf(\"%d\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define LL long long\n#define ULL unsigned long long \n#define y second\n#define sqr(x) ((x)*(x))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pdd pair<double,double>\n#define MEM(x) memset(x,0,sizeof(x))\n#define pi acos(-1)\n#define MEMS(x) memset(x,-1,sizeof(x))\nusing namespace std;\nint val[3][100005];\nvector<int> v[3][100005];\nvector<int> num[3][100005];\nint number=716070898;\nint mod=998244353;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nint main(){ \n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 0;i<3;i++){\n        int m;\n        scanf(\"%d\",&m);\n        for(int j =0;j<m;j++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            if(x>y)swap(x,y);\n            v[i][x].pb(y);\n        }\n        for(int j = n;j>=1;j--){\n            vector<int> arr;\n            for(auto it:v[i][j]){\n                arr.pb(val[i][it]);\n            }\n            sort(arr.begin(),arr.end());\n            arr.resize(unique(arr.begin(),arr.end())-arr.begin());\n            val[i][j]=arr.size();\n            for(int k = 0;k<arr.size();k++){\n                if(arr[k]!=k){\n                    val[i][j]=k;\n                    break;\n                }\n            }\n           // if(val[i][j]<2){\n            num[i][val[i][j]].pb(j);\n            //}\n        }\n    }\n    LL ans=0;\n    LL val[3][100005];//,b[2]={0,0},c[2]={0,0};\n    MEM(val);\n    for(int i =0;i<3;i++){\n        for(int j=0;j<100005;j++){\n            for(auto it:num[i][j]){\n                val[i][j]+=f_pow(number,it);\n                val[i][j]%=mod;\n            }\n        }\n    }\n    ans+=val[0][0]*val[1][0]%mod*val[2][0]%mod;\n    for(int j=1;j<100005;j++){\n        ans+=val[0][0]*val[1][j]%mod*val[2][j]%mod;\n        ans+=val[0][j]*val[1][0]%mod*val[2][j]%mod;\n        ans+=val[0][j]*val[1][j]%mod*val[2][0]%mod;\n    }\n    ans%=mod;\n    printf(\"%lld\\n\",ans);\n    /*\n    for(int i = 0;i<num[0][0].size();i++){\n        a[0]+=f_pow(number,num[0][0][i]);\n        a[0]%=mod;\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][0][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][1][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][0][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][1][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }*/\n    //printf(\"%lld\\n\",ans);\n}\n/*\n\n5\nAACCMMAA\nA\nAA\nMM\nACA\nACMAA\n\n\n5\n0 9 7 1 100\n-1 0 -1 -1 91\n-1 5 0 -1 96\n-1 8 9 0 99\n-1 -1 -1 -1 0\n3 4\n3 5\n5 6\n5 7\n3 or 4\n3 or 5\n5 or 6\n5 or 7\n\ndp[x]=max(dp[x-w_i*j]+j*t_i-delta t_i*j*(j-1)/2)\ndp[x]=max(dp[j]+x*t_i-j*t_i-delta t_i*(x-j)*(x-j-1)/2)\ndp[x]=max(dp[j]-j*t_i-delta t_i *(j^2/2+j/2) - \n        delta t_i * xj + x*t_i + delta t_i * (x^2/2-x/2))\ndp[x]=max(dp[j] + g(j) - delta t_i *xj + w(i) )\ng(j)= dp[j]-j*t_i-delta t_i *(j^2/2+j/2)\nw(i)=  x*t_i + delta t_i * (x^2/2-x/2)\nx^2/2 -xj -x/2  +j^2/2 +j/2\n*/\n\n/*\n \n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\n#define MP make_pair\n#define fi first\n#define se second\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\nconst int N = 100003, M = 1024, mod = 998244353;\ntemplate<typename T>\nvoid read(T &x){\n\tint ch = getchar(); x = 0; bool f = false;\n\tfor(;ch < '0' || ch > '9';ch = getchar()) f |= ch == '-';\n\tfor(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';\n\tif(f) x = -x;\n}\nvoid qmo(int &x){x += (x >> 31) & mod;}\nint ksm(int a, int b){\n\tint res = 1;\n\tfor(;b;b >>= 1, a = (LL) a * a % mod) if(b & 1) res = (LL) res * a % mod;\n\treturn res;\n}\ntemplate<typename T>\ninline bool chmax(T &a, const T &b){if(a < b) return a = b, 1; return 0;}\ntemplate<typename T>\ninline bool chmin(T &a, const T &b){if(a > b) return a = b, 1; return 0;}\nint n, m, head[N], to[N], nxt[N], cnt, f[3][M], sg[N], pw[N], ans; bool vis[N];\nvoid add(int a, int b){\n\tto[++ cnt] = b; nxt[cnt] = head[a]; head[a] = cnt;\n}\nvoid solve(int t){\n\tcnt = 0; read(m);\n\tfor(Rint i = 1;i <= n;++ i) head[i] = sg[i] = 0;\n\tfor(Rint i = 1, u, v;i <= m;++ i){\n\t\tread(u); read(v); if(u > v) swap(u, v); add(u, v);\n\t}\n\tfor(Rint i = n;i;-- i){\n\t\tfor(Rint j = head[i];j;j = nxt[j]) vis[sg[to[j]]] = true;\n\t\tfor(;vis[sg[i]];++ sg[i]); qmo(f[t][sg[i]] += pw[i] - mod);\n\t\tfor(Rint j = head[i];j;j = nxt[j]) vis[sg[to[j]]] = false;\n\t}\n}\nint main(){\n\tread(n); pw[0] = 1; pw[1] = 716070898;\n\tfor(Rint i = 2;i <= n;++ i) pw[i] = (LL) pw[i-1] * pw[1] % mod;\n\tfor(Rint t = 0;t < 3;++ t) solve(t);\n\tfor(Rint i = 0;i < M;++ i)\n\t\tfor(Rint j = 0;j < M;++ j)\n\t\t\tqmo(ans += (LL) f[0][i] * f[1][j] % mod * f[2][i^j] % mod - mod);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\n\nint sum(int a, int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint sub(int a, int b) {\n    return a - b < 0 ? a - b + MOD : a - b;\n}\nint mul(int a, int b) {\n    return (1LL*a*b)%MOD;\n}\nint pw(int a, int b) {\n\tif (!b) return 1;\n\tint r = pw(a, b/2);\n\tr = mul(r, r);\n\tif (b%2) r = mul(r, a);\n\treturn r;\n}\n\nconst int MAXN = 3e5+7;\nvector< int >G[3][MAXN];\nint grundy[3][MAXN];\nint fr[3][MAXN];\nint mx[3];\n\nint p10[MAXN];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n;\n\n    p10[0] = 1;\n    const int base = pw(10, 18);\n    for (int i = 1; i <= n; i++) p10[i] = mul(base, p10[i-1]);\n\n    for (int c = 0; c < 3; c++) {\n        cin >> m;\n        while (m--) {\n            int u, v;\n            cin >> u >> v;\n            if (u > v) swap(u, v);\n            G[c][u].push_back(v);\n        }\n\n        for (int i = n; i > 0; i--) {\n            set< int >st;\n            for (int v : G[c][i]) st.insert(grundy[c][v]);\n\n            grundy[c][i] = 0;\n            for (int x : st) {\n                if (x==grundy[c][i]) grundy[c][i]++;\n                else break;\n            }\n\n//            cout << c << \" \" << i << \" => \" << grundy[c][i] << endl;\n            fr[c][grundy[c][i]] = sum(fr[c][grundy[c][i]], p10[i]);\n            mx[c] = max(mx[c], grundy[c][i]);\n        }\n    }\n\n    int ans = 0;\n    for (int g0 = 0; g0 <= mx[0]; g0++) {\n        for (int g1 = 0; g1 <= mx[1]; g1++) {\n            int g2 = g0^g1;\n            if (g2 > mx[2]) continue;\n\n            int tmp = mul(mul(fr[0][g0], fr[1][g1]), fr[2][g2]);\n            ans = sum(ans, tmp);\n        }\n    }\n\n//    ans = mul(ans, pw(10, 54));\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\n\n\nint xy[410][410],xz[410][410],yz[410][410];\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vector<int> d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,310000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g1[i]){\n            if(e>i)se.insert(d1[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d1[i]=gr;\n        D1[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g2[i]){\n            if(e>i)se.insert(d2[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d2[i]=gr;\n        D2[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g3[i]){\n            if(e>i)se.insert(d3[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d3[i]=gr;\n        D3[gr] += P[i];\n    }\n    vec a,b;\n    mint ans;\n    int k1=0,k2=0,k3=0;\n    rep(i,800){\n        rep(j,800){\n            if(i>n or j>n )break;\n            ans+=D1[i]*D2[j]*D3[i^j];\n        }\n    }\n\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// O O O O O O O O O O O O O O O OO O OO O OO O O O TTCH O TTTCH O TTTCH O O O O\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx\")\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdio.h>\n#include <cstdio>\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n// #include <random>\n#include <iomanip>\n#include <bitset>\n#include <cassert>\n \nusing namespace std;\n\n#define int long long\n#define y1 y11\n#define double long double\n#define less less228\n#define left left228\n#define right right228\n#define list list228\n#define all(v) v.begin(), v.end()\n \n \n \ntemplate<typename T> void uin(T &a, T b) {\n    if (b < a) a = b;\n}\ntemplate<typename T> void uax(T &a, T b) {\n    if (b > a) a = b;\n}\n \nconst int N = 100 * 1000 + 228;\nconst int MOD = 998244353;\n\nint mod(int x) {\n    x %= MOD;\n    if (x < 0) x += MOD;\n    return x;\n}\nint fp(int a, int b) {\n    int res = 1;\n    for (; b; b >>= 1, a = mod(a * a)) {\n        if (b & 1) res = mod(res * a);\n    }\n    return res;\n}\n\nbool used[N];\n\nint mex(vector<int> v) {\n    for (int i : v) {\n        used[i] = 1;\n    }\n    int mx = 0;\n    while (used[mx])++mx;\n    for (int i : v) {\n        used[i] = 0;\n    }\n    return mx;\n}\n\nint n;\nint m1, m2, m3;\nvector<int> g[3][N];\nint gr[3][N];\nint val[3][N];\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> n;\n    cin >> m1;\n    for (int i = 0; i < m1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        g[0][min(u, v)].emplace_back(max(u, v));\n    }\n    cin >> m2;\n    for (int i = 0; i < m2; ++i) {\n        int u, v;\n        cin >> u >> v;\n        g[1][min(u, v)].emplace_back(max(u, v));\n    }\n    cin >> m3;\n    for (int i = 0; i < m3; ++i) {\n        int u, v;\n        cin >> u >> v;\n        g[2][min(u, v)].emplace_back(max(u, v));\n    }\n    for (int t = 0; t < 3; ++t) {\n        for (int v = n; v; --v) {\n\n            vector<int> go;\n            for (int to : g[t][v]) {\n                go.emplace_back(gr[t][to]);\n            }\n            gr[t][v] = mex(go);\n            val[t][gr[t][v]] = mod(val[t][gr[t][v]] + fp(10, 18 * v));\n        }\n    }\n    int ans = 0;\n    for (int a = 0; a < 500; ++a) {\n        if (val[0][a] == 0) continue;\n        for (int b = 0; b < 500; ++b) {\n            if (val[1][b] == 0) continue;\n            int c = a ^ b;\n            ans = mod(ans + mod(val[0][a] * val[1][b]) * val[2][c]);\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n// RU_023\n \n/*\n5\n1 3 4 2 3 \n3\n1 5 3\n4 3 2\n2 4 2\n-------\n2\n\n\n7\n5 6 2 3 6 7 6\n5\n7 7 5\n3 3 7\n3 7 10\n1 7 6\n4 7 8\n-------\n16\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nusing cat = long long;\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint N;\n\tcin >> N;\n\tcat mod = 998244353;\n\tvector<cat> pw(N+1, 1);\n\tfor(int i = 0; i < 18; i++) pw[1] = pw[1] * 10 % mod;\n\tfor(int i = 2; i <= N; i++) pw[i] = pw[i-1] * pw[1] % mod;\n\tvector<int> level[3];\n\tvector<cat> level_w[3];\n\tint V[3] = {0, 0, 0};\n\tfor(int k = 0; k < 3; k++) {\n\t\tint M;\n\t\tvector< vector<int> > G(N);\n\t\tcin >> M;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tG[--u].push_back(--v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tlevel[k].resize(N, 0);\n\t\tfor(int i = N-1; i >= 0; i--) {\n\t\t\tstatic vector<int> l_gt(N+1, 0);\n\t\t\tfor(auto x : G[i]) if(x > i) l_gt[level[k][x]]++;\n\t\t\twhile(l_gt[level[k][i]]) level[k][i]++;\n\t\t\tfor(auto x : G[i]) if(x > i) l_gt[level[k][x]]--;\n\t\t\tV[k] = max(V[k], level[k][i]);\n\t\t}\n\t\tlevel_w[k].resize(V[k]+1, 0);\n\t\tfor(int i = N-1; i >= 0; i--) {\n\t\t\tlevel_w[k][level[k][i]] += pw[i+1];\n\t\t\tif(level_w[k][level[k][i]] >= mod) level_w[k][level[k][i]] -= mod;\n\t\t}\n\t}\n\tvector< vector< vector<char> > > state(V[0]+1, vector< vector<char> >(V[1]+1, vector<char>(V[2]+1, 0)));\n\tvector< vector<char> > used[3];\n\tused[0].resize(V[1]+1, vector<char>(V[2]+1, 0));\n\tused[1].resize(V[0]+1, vector<char>(V[2]+1, 0));\n\tused[2].resize(V[0]+1, vector<char>(V[1]+1, 0));\n\tfor(int i = 0; i <= V[0]; i++)\n\t\tfor(int j = 0; j <= V[1]; j++)\n\t\t\tfor(int k = 0; k <= V[2]; k++)\n\t\t\t\tif(!used[0][j][k] && !used[1][i][k] && !used[2][i][j])\n\t\t\t\t\tstate[i][j][k] = used[0][j][k] = used[1][i][k] = used[2][i][j] = 1;\n\tcat ans = 0;\n\tfor(int i = 0; i <= V[0]; i++)\n\t\tfor(int j = 0; j <= V[1]; j++)\n\t\t\tfor(int k = 0; k <= V[2]; k++)\n\t\t\t\tif(state[i][j][k])\n\t\t\t\t\tans = (ans + level_w[0][i] * level_w[1][j] % mod * level_w[2][k]) % mod;\n\tcout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Maxn 107\n#define inf 1000007\nchar s[Maxn][Maxn];\nint last[1000007],pre[1000007],other[1000007],len[1000007],cnt=0;\nint n,m;\nint calc(int x,int y)\n{\n    return (x-1)*m+y;\n}\nvoid insert(int u,int v,int l)\n{\n    other[++cnt]=v,pre[cnt]=last[u],last[u]=cnt;\n    len[cnt]=l;\n}\nint dis[1000007];\nbool vis[1000007];\npriority_queue<pair<int,int> >que;\nint dijkstra(int s,int t)\n{\n    for (int i=1;i<=t;i++)\n        dis[i]=inf;\n    memset(vis,false,sizeof(vis));\n    while (!que.empty()) que.pop();\n    que.push(make_pair(0,s));\n    dis[s]=0;\n    while (!que.empty())\n    {\n        int u=que.top().second;\n        que.pop();\n        if (vis[u]) continue;\n        vis[u]=true;\n        for (int q=last[u];q;q=pre[q])\n        {\n            int v=other[q];\n            if (dis[v]>dis[u]+len[q])\n            {\n                dis[v]=dis[u]+len[q];\n                que.push(make_pair(-dis[v],v));\n            }\n        }\n    }\n    return dis[t];\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++)\n        scanf(\"%s\",s[i]+1);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n        {\n            if (i<n)\n            {\n                int tmp=0;\n                if (s[i][j]=='.'&&s[i][j]!=s[i+1][j]) tmp=1;\n                insert(calc(i,j),calc(i+1,j),tmp);\n            }\n            if (j<m)\n            {\n                int tmp=0;\n                if (s[i][j]=='.'&&s[i][j]!=s[i][j+1]) tmp=1;\n                insert(calc(i,j),calc(i,j+1),tmp);\n            }\n        }\n    int S=n*m+1,T=n*m+2;\n    if (s[1][1]=='.') insert(S,calc(1,1),0); else insert(S,calc(1,1),1);\n    insert(calc(n,m),T,0);\n    printf(\"%d\\n\",dijkstra(S,T));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nmt19937 mt(736);\n\nconst int mod = 998244353;\n\n\nint powmod10(int n)\n{\n\tstatic vector<int> dp = {1};\n\n\twhile (n >= dp.size())\n\t\tdp.push_back((10ll * dp.back()) % mod);\n\n\treturn dp[n];\n}\n\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint n;\n\n\tcin >> n;\n\n\tarray<vector<vector<int>>, 3> xyz;\n\n\tfor (auto &gr : xyz)\n\t{\n\t\tgr.resize(n);\n\n\t\tint m;\n\n\t\tcin >> m;\n\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tint a, b;\n\n\t\t\tcin >> a >> b;\n\t\t\ta--;\n\t\t\tb--;\n\n\t\t\tgr[a].push_back(b);\n\t\t\tgr[b].push_back(a);\n\t\t}\n\t}\n\n\tarray<vector<int>, 3> mex;\n\n\tarray<ll, 3> wm{}, bm{};\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tmex[i].resize(n, -1);\n\n\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t{\n\t\t\tunordered_set<int> neigh;\n\n\t\t\tfor (auto it : xyz[i][j])\n\t\t\t\tneigh.insert(it);\n\n\t\t\tfor (mex[i][j] = 0; neigh.count(mex[i][j]); mex[i][j]++);\n\t\t}\n\t}\n\n\tarray<vector<ll>, 3> grundy;\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tgrundy[i].resize(*max_element(mex[i].begin(), mex[i].end()) + 1);\n\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tgrundy[i][mex[i][j]] += powmod10(18 * (j + 1));\n\t}\n\n\tll ans = 0;\n\n\tfor (int x = 0; x < grundy[0].size(); x++)\n\t\tfor (int y = 0; y < grundy[1].size(); y++)\n\t\t{\n\t\t\tauto z = x ^y;\n\n\t\t\tif (z < grundy[2].size())\n\t\t\t\tans += grundy[0][x] * grundy[1][y] % mod * grundy[2][z] % mod;\n\t\t}\n\n\tcout << ans % mod << endl;\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcout << fixed;\n\n#ifdef LOCAL\n\tauto st = clock();\n\n\tifstream fin(\"../input.txt\");\n\n\tsolve(fin);\n\n\tcout << \"clock: \" << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tsolve();\n#endif\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __INTMOD_H__\n#define __INTMOD_H__\n\n/* updated: 2019-10-10 */\n\n#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cstdint>\n#include <functional>\n#include <unordered_map>\n\ntemplate <uint32_t Mod>\nclass IntMod {\n\tstatic_assert(Mod != 0, \"Mod must not be 0\");\n\tstatic_assert(Mod < 0x80000000, \"Mod must be less than 0x80000000\");\n\nprivate:\n\tuint32_t value_m;\n\npublic:\n\tIntMod();\n\tIntMod(int32_t value);\n\tIntMod(uint32_t value);\n\tIntMod(int64_t value);\n\tIntMod(uint64_t value);\n\n\tconst IntMod<Mod>& operator+() const;\n\tIntMod<Mod> operator-() const;\n\tIntMod<Mod>& operator++();\n\tIntMod<Mod>& operator--();\n\tIntMod<Mod> operator++(int dummy);\n\tIntMod<Mod> operator--(int dummy);\n\tIntMod<Mod>& operator+=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator-=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator*=(const IntMod<Mod>& right);\n\tIntMod<Mod>& operator/=(const IntMod<Mod>& right);\n\tIntMod<Mod> operator[](uint64_t exp) const;\n\n\tstatic IntMod<Mod> add(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> subtract(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> multiply(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic IntMod<Mod> divide(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\tstatic int compare(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n\tIntMod<Mod> inverse() const;\n\tIntMod<Mod> power(uint64_t exp) const;\n\tuint32_t get() const;\n\n\tstatic IntMod<Mod> fact(uint32_t num);\n\tstatic IntMod<Mod> invFact(uint32_t num);\n\tstatic IntMod<Mod> combi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> homcombi(uint32_t n, uint32_t r);\n\tstatic IntMod<Mod> perm(uint32_t n, uint32_t r);\n\tstatic std::vector<IntMod<Mod>> calcInverseList(int max);\n};\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b);\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b);\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b);\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object);\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object);\n\nusing MInt = IntMod<1000000007>;\n\n// for unordered_set/map\nnamespace std {\n\ttemplate <uint32_t Mod>\n\tstruct hash<IntMod<Mod>> {\n\t\tsize_t operator() (const IntMod<Mod>& object) const {\n\t\t\treturn std::hash<uint32_t>()(object.get());\n\t\t}\n\t};\n}\n\ntemplate <uint32_t Mod>\nuint32_t discreteLog(const IntMod<Mod>& a, const IntMod<Mod>& b);\n\n/*------------------------------------*/\n/*-------   Implementations   --------*/\n/*------------------------------------*/\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod() \n\t: value_m(0) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int32_t value) {\n\tint32_t tmp = value % int32_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint32_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(int64_t value) {\n\tint32_t tmp = value % int64_t(Mod);\n\tvalue_m = tmp >= 0 ? tmp : Mod - uint32_t(-tmp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>::IntMod(uint64_t value)\n\t: value_m(value % Mod) {\n}\n\ntemplate <uint32_t Mod>\nconst IntMod<Mod>& IntMod<Mod>::operator+() const {\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator-() const {\n\tIntMod<Mod> ret;\n\tif (value_m == 0) {\n\t\tret.value_m = 0;\n\t} else {\n\t\tret.value_m = Mod - value_m;\n\t}\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator++() {\n\t++value_m;\n\tif (value_m == Mod) {\n\t\tvalue_m = 0;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator--() {\n\tif (value_m == 0) {\n\t\tvalue_m = Mod;\n\t}\n\t--value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator++(int dummy) {\n\tIntMod ret(*this);\n\t++*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator--(int dummy) {\n\tIntMod ret(*this);\n\t--*this;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator+=(const IntMod<Mod>& right) {\n\tvalue_m += right.value_m;\t\t// note: value_m < 0x80000000\n\tif (value_m >= Mod) {\n\t\tvalue_m -= Mod;\n\t}\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator-=(const IntMod<Mod>& right) {\n\tif (value_m < right.value_m) {\n\t\tvalue_m += Mod;\t\t\t\t// note: value_m < 0x80000000\n\t}\n\tvalue_m -= right.value_m;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator*=(const IntMod<Mod>& right) {\n\tvalue_m = (uint64_t(value_m) * right.value_m) % Mod;\n\treturn *this;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod>& IntMod<Mod>::operator/=(const IntMod<Mod>& right) {\n\t*this *= right.inverse();\n\treturn *this;\n}\n\n// for power\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::operator[](uint64_t exp) const {\n\treturn power(exp);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::add(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret += b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::subtract(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret -= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::multiply(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret *= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::divide(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tIntMod<Mod> ret(a);\n\tret /= b;\n\treturn ret;\n}\n\ntemplate <uint32_t Mod>\nint IntMod<Mod>::compare(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\tif (a.value_m < b.value_m) return -1;\n\tif (a.value_m > b.value_m) return 1;\n\treturn 0;\n}\n\n/* Mod must be a prime. */\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::inverse() const {\n\tassert(value_m != 0);\n\treturn power(Mod - 2);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::power(uint64_t exp) const {\n\tIntMod<Mod> product(1);\n\tIntMod<Mod> factor(*this);\n\twhile (exp > 0) {\n\t\tif (exp & 1) {\n\t\t\tproduct *= factor;\n\t\t}\n\t\tfactor *= factor;\n\t\texp >>= 1;\n\t}\n\treturn product;\n}\n\ntemplate <uint32_t Mod>\nuint32_t IntMod<Mod>::get() const {\n\treturn value_m;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::fact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\tfor (uint32_t i = old_size; i <= num; ++i) {\n\t\ttable[i] = table[i - 1] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::invFact(uint32_t num) {\n\tassert(num <= 0x80000000);\n\n\tstatic std::vector<IntMod<Mod>> table(1, 1);\n\tif (table.size() > num) return table[num];\n\n\tuint32_t old_size = table.size();\n\ttable.resize(num + 1);\n\ttable[num] = fact(num).inverse();\n\tfor (uint32_t i = num; i >= old_size; --i) {\n\t\ttable[i - 1] = table[i] * i;\n\t}\n\treturn table[num];\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::combi(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) * invFact(n - r) * invFact(r);\n}\n\ntemplate<uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::homcombi(uint32_t n, uint32_t r) {\n\tassert(n != 0 || r == 0);\n\n\tif (n == 0 && r == 0) return IntMod<Mod>(1);\n\treturn combi(n + r - 1, r);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> IntMod<Mod>::perm(uint32_t n, uint32_t r) {\n\tassert(n >= r);\n\treturn fact(n) / fact(n - r);\n}\n\ntemplate <uint32_t Mod>\nstd::vector<IntMod<Mod>> IntMod<Mod>::calcInverseList(int max) {\n\tassert(max < Mod);\n\n\tstd::vector<IntMod<Mod>> table(max + 1);\n\ttable[1] = 1;\n\tfor (int i = 2; i <= max; ++i) {\n\t\ttable[i] = (uint64_t(Mod - Mod / i) * table[Mod % i].get()) % Mod;\n\t}\n\treturn table;\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::add(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::subtract(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::multiply(a, b);\n}\n\ntemplate <uint32_t Mod>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::divide(a, b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const IntMod<Mod>& a, const Int& b) {\n\treturn a + IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const IntMod<Mod>& a, const Int& b) {\n\treturn a - IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const IntMod<Mod>& a, const Int& b) {\n\treturn a * IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const IntMod<Mod>& a, const Int& b) {\n\treturn a / IntMod<Mod>(b);\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator+(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) + b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator-(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) - b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator*(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) * b;\n}\n\ntemplate<uint32_t Mod, class Int>\nIntMod<Mod> operator/(const Int& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>(a) / b;\n}\n\ntemplate <uint32_t Mod>\nbool operator==(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) == 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator!=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) != 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) < 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator<=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) <= 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) > 0;\n}\n\ntemplate <uint32_t Mod>\nbool operator>=(const IntMod<Mod>& a, const IntMod<Mod>& b) {\n\treturn IntMod<Mod>::compare(a, b) >= 0;\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator==(const IntMod<Mod>& a, const Int& b) {\n\treturn a == IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod, class Int>\nbool operator!=(const IntMod<Mod>& a, const Int& b) {\n\treturn a != IntMod<Mod>(b);\n}\n\ntemplate <uint32_t Mod>\nstd::istream& operator>>(std::istream& ist, IntMod<Mod>& object) {\n\tuint64_t value;\n\tist >> value;\n\tobject = IntMod<Mod>(value);\n\treturn ist;\n}\n\ntemplate <uint32_t Mod>\nstd::ostream& operator<<(std::ostream& ost, const IntMod<Mod>& object) {\n\tost << object.get();\n\treturn ost;\n}\n\n#endif\n#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = uint32_t;\nusing LL = int64_t;\nusing ULL = uint64_t;\nusing PP = pair<LL, LL>;\ntemplate <typename T> using PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n#define REP(i, a, n) for(LL i = (a), i##_max_ = (n); i < i##_max_; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##_min_ = (a); i >= i##_min_; --i)\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP { cin.tie(NULL); ios::sync_with_stdio(false); }\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U> istream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U> ostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N> void Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N> void Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate <class T> T Next() { T buf; cin >> buf; return buf; }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"Accumulator.h\"\n#include \"Algebraic.h\"\n#include \"BinaryMatrix.h\"\n#include \"BinaryTree.h\"\n#include \"Bipartite.h\"\n#include \"BIT.h\"\n#include \"Compressor.h\"\n#include \"Decompositions.h\"\n#include \"DynamicMod.h\"\n#include \"Factorization.h\"\n#include \"FFT.h\"\n#include \"FlowSolver.h\"\n#include \"Graph.h\"\n#include \"GraphUtil.h\"\n#include \"IntMod.h\"\n#include \"LazySegmentTree.h\"\n#include \"LIS.h\"\n#include \"Math.h\"\n#include \"MathUtil.h\"\n#include \"Matrix.h\"\n#include \"MinCostFlowSolver.h\"\n#include \"MinMax.h\"\n#include \"Numbers.h\"\n#include \"Optimize.h\"\n#include \"Permutation.h\"\n#include \"Polynomial.h\"\n#include \"Position.h\"\n#include \"Range.h\"\n#include \"Rational.h\"\n#include \"SegmentTree.h\"\n#include \"SegmentTree2D.h\"\n#include \"Sets.h\"\n#include \"Shortest.h\"\n#include \"SlidingWindow.h\"\n#include \"SpanningTree.h\"\n#include \"StringSearching.h\"\n#include \"SuffixArray.h\"\n#include \"Tree.h\"\n#include \"TreeUtil.h\"\n#include \"UnionFind.h\"\n#include \"Util.h\"\n#include \"VectorUtil.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>>(istream& ist, __int128& val) { LL tmp; ist >> tmp; val = tmp; return ist; }\nostream& operator<<(ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\nusing M9 = IntMod<998244353>;\n\nint N, A, B, C;\nvector<int> G[100000];\nvector<int> H[100000];\nvector<int> I[100000];\n\nvoid input() {\n\tcin >> N;\n\tcin >> A;\n\tREP(z, 0, A) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tcin >> B;\n\tREP(z, 0, B) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tH[a].push_back(b);\n\t\tH[b].push_back(a);\n\t}\n\tcin >> C;\n\tREP(z, 0, C) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tI[a].push_back(b);\n\t\tI[b].push_back(a);\n\t}\n}\n\nint GQ[100000];\nint HQ[100000];\nint IQ[100000];\n\nvoid calc(vector<int>* g, int* gq) {\n\tREM(from, 0, N) {\n\t\tvector<int> st;\n\t\tfor (int to : g[from]) {\n\t\t\tif (to < from) continue;\n\t\t\tst.push_back(gq[to]);\n\t\t}\n\t\tsort(st.begin(), st.end());\n\t\tst.erase(unique(st.begin(), st.end()), st.end());\n\t\tst.push_back(INF);\n\n\t\tint mn = 0;\n\t\twhile (st[mn] == mn) {\n\t\t\t++mn;\n\t\t}\n\t\tgq[from] = mn;\n\t}\n}\n\nint main() {\n\tinput();\n\tcalc(G, GQ);\n\tcalc(H, HQ);\n\tcalc(I, IQ);\n\n\tmap<int, M9> mg, mh, mi;\n\tREP(i, 0, N) {\n\t\tmg[GQ[i]] += M9(10)[18 * (i + 1)];\n\t\tmh[HQ[i]] += M9(10)[18 * (i + 1)];\n\t\tmi[IQ[i]] += M9(10)[18 * (i + 1)];\n\t}\n\n\tM9 sum = 0;\n\tfor (auto&& p : mg) {\n\t\tfor (auto&& q : mh) {\n\t\t\tsum += p.second * q.second * mi[p.first ^ q.first];\n\t\t}\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define int long long\nusing namespace std;\ninline int read(){\n\tregister int x=0;\n\tregister bool f=0;\n\tregister char c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') f=1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+c-48;\n\t\tc=getchar();\n\t}\n\treturn f?-x:x;\n}\nchar cr[200],str[200];int tt;\ninline void print(int x,char k='\\n') {\n    if(!x) putchar('0');\n    if(x < 0) putchar('-'),x=-x;\n    while(x) cr[++tt]=x%10+'0',x/=10;\n    while(tt) putchar(cr[tt--]);\n    putchar(k);\n}\nconst int maxn=300000+10;\nconst int p=998244353;\nconst int b=1000000000000000000ll%p;\nint h[maxn],cnt,s[maxn],n;\nint sg[maxn],f[4][maxn],m;\nbool vis[maxn];\nstruct _{\n\tint nxt,to;\n}e[maxn<<1];\nvoid add(int u,int v){\n\te[++cnt].nxt=h[u];\n\te[cnt].to=v;\n\th[u]=cnt;\n}\nsigned main(){\n    n=read();\n    s[0]=1;\n    for(int i=1;i<=n*3;i++){\n    \ts[i]=s[i-1]*b%p;\n\t}\n\tfor(int o=1;o<=3;o++){\n\t\tmemset(h,0,sizeof(h));\n\t\tmemset(sg,0,sizeof(sg));\n\t\tcnt=0;m=read();\n\t\tfor(int i=1;i<=m;i++){\n            int u=read(),v=read();\n            if(u<v) add(u,v);\n            if(v<u) add(v,u);\n        }\n        for(int i=n;i>=1;i--){\n        \tfor(int j=h[i];j;j=e[j].nxt){\n        \t\tvis[sg[e[j].to]]=1;\n\t\t\t}\n\t\t\tfor(int j=0;;j++){\n\t\t\t\tif(!vis[j]){\n\t\t\t\t\tsg[i]=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=h[i];j;j=e[j].nxt){\n        \t\tvis[sg[e[j].to]]=0;\n\t\t\t}\n            (f[o][sg[i]]+=s[i])%=p;\n\t\t}\n\t}\n\tint ans=0;\n\tfor (int i=0;i<500;i++)\n        for (int j=0;j<500;j++)\n            (ans+=f[3][i]*f[1][j]%p*f[2][i^j])%=p;\n    print(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing ld = long double;\nusing ii = pair<ll, ll>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vii = vector<ii>;\nusing vvii = vector<vii>;\nusing vd = vector<ld>;\n\ntemplate<class T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class TIn, class TOut = null_type>\nusing order_tree = tree<TIn, TOut, less<TIn>, rb_tree_tag,\n\ttree_order_statistics_node_update>;\n// .find_by_order(int r) and .order_of_key(TIn v)\n\nconstexpr int INF = 2000000010;\nconstexpr ll LLINF = 9000000000000000010LL;\nconstexpr ld PI = acos(-1);\n\nconstexpr ll MOD = 998244353LL;\n\nll mpw(ll a, ll b) {\n\tif (b == 0LL) return 1LL;\n\tll r = mpw(a*a%MOD, b/2);\n\tif (b&1) r = r*a%MOD;\n\treturn r;\n}\n\nll invert(ll x) {\n\treturn mpw(x, MOD-2);\n}\n\nvoid brinc(int &x, int k) {\n\tint i = k - 1, s = 1 << i;\n\tx ^= s;\n\tif ((x & s) != s) {\n\t\t--i; s >>= 1;\n\t\twhile (i >= 0 && ((x & s) == s))\n\t\t\tx = x &~ s, --i, s >>= 1;\n\t\tif (i >= 0) x |= s;\n\t}\n}\nvoid fft(vi &A, int p, bool inv = false) {\n\tint N = 1<<p;\n\tfor(int i = 0, r = 0; i < N; ++i, brinc(r, p))\n\t\tif (i < r) swap(A[i], A[r]);\n\tfor (int m = 2; m <= N; m <<= 1) {\n\t\tfor (int k = 0; k < N; k += m) {\n\t\t\tfor (int j = 0; j < m/2; ++j) {\n\t\t\t\tll t = A[k + j + m/2];\n\t\t\t\tA[k + j + m/2] = (MOD+A[k + j] - t)%MOD;\n\t\t\t\tA[k + j] = (A[k + j] + t)%MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif(inv){ ll inverse = invert(N); for(auto &x : A) x = x*inverse%MOD; }\n}\n\nvoid solve() {\n\tint N, M[3];\n\tcin >> N;\n\n\tconstexpr ll e18 = 1'000'000'000'000'000'000LL % MOD;\n\n\tvi p10(N+1, 1LL);\n\tfor (ll n = 1; n <= N; ++n)\n\t\tp10[n] = e18*p10[n-1]%MOD;\n\n\tvvi ltr[3];\n\tfor (int r = 0; r < 3; ++r) {\n\t\tcin >> M[r];\n\t\tltr[r].resize(N);\n\t\tfor (int e = 0; e < M[r]; ++e) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\t--a, --b;\n\t\t\tif (a > b) swap(a, b);\n\t\t\tltr[r][a].push_back(b);\n\t\t}\n\t}\n\n\t// Color graphs 1 and 2.\n\tvi col[3];\n\tfor (int r = 0; r < 2; ++r) {\n\t\tcol[r].assign(N, -1);\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tunordered_set<int> nbs;\n\t\t\tfor (int j : ltr[r][i]) nbs.insert(col[r][j]);\n\t\t\tdo col[r][i]++; while (nbs.find(col[r][i]) != nbs.end());\n\t\t}\n\t}\n\n\t// Color and cost graph 3.\n\tcol[2].assign(2*N, -1);\n\tvi prof(2*N, 0);\n\tfor (int i = N-1; i >= 0; --i) {\n\t\tunordered_set<int> nbs;\n\t\tfor (int j : ltr[2][i]) nbs.insert(col[2][j]);\n\t\tdo col[2][i]++; while (nbs.find(col[2][i]) != nbs.end());\n\t\tprof[col[2][i]] = (prof[col[2][i]] + p10[i+1]) % MOD;\n\t}\n\n\tint k = 0;\n\twhile ((1<<k) <= N) ++k;\n\n\tvi g0(1<<k, 0LL);\n\tvi g1(1<<k, 0LL);\n\tfor (int i = 0; i < N; ++i) {\n\t\tg0[col[0][i]] = (g0[col[0][i]] + p10[i+1]) % MOD;\n\t\tg1[col[1][i]] = (g1[col[1][i]] + p10[i+1]) % MOD;\n\t}\n\tfft(g0, k, false);\n\tfft(g1, k, false);\n\tvi rev(1<<k);\n\tfor (int i = 0; i < (1<<k); ++i) rev[i] = (g0[i]*g1[i])%MOD;\n\tfft(rev, k, true);\n\n\tll ans = 0LL;\n\tfor (ll ij = 0; ij < 2*N && ij < (1<<k); ++ij) {\n\t\tans = (ans + prof[ij] * rev[ij]) % MOD;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout << fixed << setprecision(12);\n\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MaxN = 100000, MaxS = 511;\nconst int Mod = 998244353, base = ((long long) 1e18) % Mod;\n\nint N;\nint Pw[MaxN + 5];\nint Sg[3][MaxN + 5];\nstd::vector<int> Gr[3][MaxN + 5];\nint Buc[3][MaxS + 5];\n\ninline int add(int x, int y) { return (x += y) >= Mod ? x - Mod : x; }\ninline int mul(int x, int y) { return 1LL * x * y % Mod; }\ninline void inc(int &x, int y = 1) { x = add(x, y); }\n\nvoid init() {\n  scanf(\"%d\", &N);\n  Pw[0] = 1;\n  for (int i = 1; i <= N; ++i) Pw[i] = mul(Pw[i - 1], base);\n  for (int k = 0; k < 3; ++k) {\n    int m;\n    scanf(\"%d\", &m);\n    for (int i = 1; i <= m; ++i) {\n      int u, v;\n      scanf(\"%d %d\", &u, &v);\n      if (u > v) std::swap(u, v);\n      Gr[k][u].push_back(v);\n    }\n  }\n}\n\nvoid getSg(int k) {\n  static bool buc[MaxN + 5];\n  memset(buc, false, sizeof buc);\n  int mx = 0;\n  for (int u = N; u >= 1; --u) {\n    for (int i = 0; i <= mx; ++i) buc[i] = false;\n    mx = 0;\n    for (int v : Gr[k][u]) {\n      buc[Sg[k][v]] = true;\n      mx = std::max(mx, Sg[k][v]);\n    }\n    for (int i = 0; i <= mx + 1; ++i)\n      if (buc[i] == false) {\n        Sg[k][u] = i;\n        break;\n      }\n  }\n}\n\nvoid solve() {\n  for (int k = 0; k < 3; ++k) getSg(k);\n  for (int k = 0; k < 3; ++k)\n    for (int i = 1; i <= N; ++i)\n      inc(Buc[k][Sg[k][i]], Pw[i]);\n  int ans = 0;\n  for (int i = 0; i <= MaxS; ++i)\n    for (int j = 0; j <= MaxS; ++j) {\n      int k = i ^ j;\n      if (k > MaxS) continue;\n      inc(ans, mul(mul(Buc[0][i], Buc[1][j]), Buc[2][k]));\n    }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  init();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e5+10, P = 998244353;\nint n, m, vis[N], sg[N], h[N], f[3][N];\nvector<int> g[N];\nvoid add(int &a, ll b) {a=(a+b)%P;}\n\nint main() {\n\th[0] = 1;\n\th[1] = 1000000000000000000ll%P;\n\tREP(i,2,N-1) h[i] = (ll)h[i-1]*h[1]%P;\n\tscanf(\"%d\", &n);\n\tREP(i,0,2) {\n\t\tscanf(\"%d\", &m);\n\t\tREP(j,1,n) g[j].clear();\n\t\tREP(j,1,m) {\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif (u>v) swap(u,v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tPER(j,1,n) {\n\t\t\tint sz = g[j].size();\n\t\t\tREP(k,0,sz) vis[k] = 0;\n\t\t\tfor (int k:g[j]) vis[sg[k]] = 1;\n\t\t\tREP(k,0,sz) if (!vis[k]) {\n\t\t\t\tsg[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(f[i][sg[j]],h[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i,0,400) REP(j,0,400) {\n\t\tadd(ans, (ll)f[0][i]*f[1][j]%P*f[2][i^j]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nlong long T=1000000000000000000LL%mod;\nvector<int>g[3][110000];\nint s[3];\nint f[3][110000];\nint f2[3][110000];\nint dp[3][110000];\nlong long gr[3][110000];\nint calc(int a,int b){\n\tif(dp[a][b]>=0)return dp[a][b];\n\tvector<int>t;\n\tfor(int i=0;i<g[a][b].size();i++){\n\t\tt.push_back(calc(a,g[a][b][i]));\n\t}\n\tstd::sort(t.begin(),t.end());\n\tint ret=0;\n\tfor(int i=0;i<t.size();i++){\n\t\tif(ret<t[i])break;\n\t\tif(ret==t[i])ret++;\n\t}\n\treturn dp[a][b]=ret;\n}\nlong long pT[110000];\nlong long key[3];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<3;i++)for(int j=0;j<a;j++)dp[i][j]=-1;\n\n\tpT[0]=1;\n\tfor(int i=1;i<110000;i++){\n\t\tpT[i]=pT[i-1]*T%mod;\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tscanf(\"%d\",&s[j]);\n\t\tfor(int i=0;i<s[j];i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\tif(p>q)swap(p,q);\n\t\t\tg[j][p].push_back(q);\n\t\t}\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint at=calc(j,i);\n\t\t\tgr[j][at]=(gr[j][at]+pT[i])%mod;\n\t\t}\n\t}\n\n\tlong long ret=gr[0][0]*gr[1][0]%mod*gr[2][0]%mod;\n\tfor(int i=1;i<a;i++){\n\t\tret=(ret+gr[0][0]*gr[1][i]%mod*gr[2][i])%mod;\n\t\tret=(ret+gr[1][0]*gr[2][i]%mod*gr[0][i])%mod;\n\t\tret=(ret+gr[2][0]*gr[0][i]%mod*gr[1][i])%mod;\n\t\t\n\t}\n\tret=ret*T%mod;\n\tret=ret*T%mod;\n\tret=ret*T%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < (n); i++)\n#define forr(i,a,b) for (int i = (a); i <= (b); i++)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n \nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ii> vii;\n\nconst int MX = 100005, mod = 998244353, SQ = (1 << 9);\nint n, m, inv2, f[MX];\nll a[3][SQ], res[SQ];\nvi adj[MX];\n\nll pot (ll b, int p) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= b) %= mod;\n\t\t(b *= b) %= mod;\n\t\tp /= 2;\n\t}\n\treturn res;\n}\n\nvoid dfs (int u) {\n\tif (f[u] != -1) return;\n\n\tset<int> st;\n\tfor (int v : adj[u])\n\t\tif (v > u) {\n\t\t\tdfs(v);\n\t\t\tst.insert(f[v]);\n\t\t}\n\n\tfor (int i = 0;; i++)\n\t\tif (!st.count(i)) {\n\t\t\tf[u] = i;\n\t\t\tbreak;\n\t\t}\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinv2 = pot(2, mod - 2);\n\n\tcin >> n;\n\tforn (i, 3) {\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tadj[j].clear();\n\n\t\tcin >> m;\n\t\twhile (m--) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tadj[a].pb(b);\n\t\t\tadj[b].pb(a);\n\t\t}\n\n\t\tmemset(f, -1, sizeof(f));\n\t\tfor (int j = 1; j<= n; j++) {\n\t\t\tdfs(j);\n\t\t\t(a[i][f[j]] += pot(10, 18 * j)) %= mod;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < SQ; i++)\n\t\tfor (int j = 0; j < SQ; j++)\n\t\t\tfor (int k = 0; k < SQ; k++)\n\t\t\t\t(res[i ^ j ^ k] += a[0][i] * a[1][j] % mod * a[2][k]) %= mod;\n\n\tcout << res[0] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned int\n#define ull unsigned long long\n#define inf 1010000000\n#define infll 1010000000000000000ll\n#define vi vector<int>\n#define vll vector<ll>\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pdd pair<double,double>\n#define mpr make_pair\n#define fi first\n#define se second\n#define pq priority_queue<int>\n#define pqll priority_queue<ll>\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define ad(x,y) (x=(x+(y))%mod)\n#define cbn(x,y) ((ll)fac[x]*inv[y]%mod*inv[(x)-(y)]%mod)\n#define N 100009\n#define mod 998244353\nusing namespace std;\n\nint read(); ll readll();\n\nint n,m,mx,pw[N],a[N],b[N],c[N],f[N],g[N],h[N],tg[N]; vi e[N];\nvoid work(int *a,int *b){\n\tm=read();\n\tint i,x,y;\n\tfor (i=1; i<=n; i++) e[i].clear();\n\tfor (i=1; i<=m; i++){\n\t\tx=read(); y=read();\n\t\tif (x>y) swap(x,y); e[x].pb(y);\t\n\t}\n\tmemset(tg,0,sizeof(tg));\n\tfor (i=n; i; i--){\n\t\tfor (int p:e[i]) tg[a[p]]=i;\n\t\tfor (; tg[a[i]]==i; a[i]++);\n\t\tup(mx,a[i]); ad(b[a[i]],pw[i]);\n\t}\n}\nint main(){\n\tn=read();\n\tint i,j;\n\tfor (i=pw[0]=1; i<=n; i++) \n\t\tfor (j=0,pw[i]=pw[i-1]; j<18; j++) pw[i]=10ll*pw[i]%mod;\n\twork(a,f); work(b,g); work(c,h);\n\tint ans=0;\n\tfor (i=0; i<=mx; i++)\n\t\tfor (j=0; j<=mx; j++) ad(ans,(ll)f[i]*g[j]%mod*h[i^j]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\nint read(){\n\tint x=0; char ch=getchar(); bool flag=0;\n\twhile (ch<'0' || ch>'9'){ if (ch=='-') flag=1; ch=getchar(); }\n\twhile (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }\n\treturn flag?-x:x;\n}\nll readll(){\n\tll x=0; char ch=getchar(); bool flag=0;\n\twhile (ch<'0' || ch>'9'){ if (ch=='-') flag=1; ch=getchar(); }\n\twhile (ch>='0' && ch<='9'){ x=x*10+ch-'0'; ch=getchar(); }\n\treturn flag?-x:x;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=1e5+5,mod=998244353;\nconst int W=(long long)1e18%mod;\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n}\nint n;\nstruct graph{\n\tvector<int> e[N];\n\tint sg[N],val[N],mx;\n\tint SG(int u){\n\t\tif(sg[u]!=-1) return sg[u];\n\t\tmap<int,bool> fl;\n\t\tfor(int i=0;i<e[u].size();++i)\n\t\t\tfl[SG(e[u][i])]=1;\n     \tdo{\n          ++sg[u];\n        }while(fl.count(sg[u]));\n\t\treturn sg[u];\n\t}\n\tvoid solve(){\n\t\tint m,u,v;\n\t\tcin>>m;\n\t\tfor(int i=1;i<=m;++i){\n\t\t\tcin>>u>>v;\n\t\t\tif(u>v) swap(u,v);\n\t\t\te[u].push_back(v);\n\t\t}\n\t\tfor(int i=1;i<=n;++i) sg[i]=-1;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tif(sg[i]==-1) SG(i);\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tmx=max(mx,sg[i]),\n\t\t\tval[sg[i]]+=ksm(W,i),val[sg[i]]%=mod;\n\t//\tfor(int i=1;i<=n;++i)\n\t\t//\tcout<<i<<\" \"<<sg[i]<<endl;\n\t}\n}g0,g1,g2;\nsigned main(){\n//\tcout<<W<<endl;\n\tcin>>n;\n\tg0.solve();g1.solve();g2.solve();\n\tint ans=0;\n\tfor(int i=0;i<=g0.mx;++i)\n\t\tfor(int j=0;j<=g1.mx;++j)\n\t\t\tans+=g0.val[i]*g1.val[j]%mod*g2.val[i^j]%mod,ans%=mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nlong long p[100010];\n\nvoid init() {\n    p[0] = p[1] = 1;\n    for (int i = 0; i < 18; i++) {\n        p[1] = p[1] * 10 % mod;\n    }\n    for (int i = 1; i <= 100000; i++) {\n        p[i+1] = p[i] * p[1] % mod;\n    }\n}\n\nvoid calc(int n, vector<long long> &v, vector<vector<int>> &w) {\n    int m; cin >> m;\n    vector<int> e[n+1];\n    vector<int> g(n+1, -1);\n    for (int i = 0; i < m; i++) {\n        int a, b; cin >> a >> b;\n        e[a].emplace_back(b);\n        e[b].emplace_back(a);\n    }\n    for (int i = n; i > 0; i--) {\n        set<int> s;\n        for (auto &to: e[i]) {\n            s.emplace(g[to]);\n        }\n        int t = 0;\n        for (auto &x: s) {\n            if (x == -1) continue;\n            if (x != t) break;\n            t++;\n        }\n        g[i] = t;\n        w[t].emplace_back(i);\n    }\n    for (int i = 1; i <= n; i++) {\n        v[g[i]] = (v[g[i]] + p[i]) % mod;\n    }\n}\n\nvector<long long> mul(vector<long long> &x, vector<long long> &y, int n) {\n    vector<long long> d(n+1, 0), ret(n, 0);\n    for (int i = n-1; i >= 0; i--) {\n        d[i] = x[i] * y[i] % mod;\n        if (i != n-1) d[i] = (d[i] + d[i+1]) % mod;\n    }\n    long long sum = 0;\n    for (int i = 0; i < n; i++) {\n        ret[i] = (d[i+1] + x[i] * y[0] % mod + sum) % mod;\n        if (i != n-1) sum += x[i] * y[i+1] % mod; sum %= mod;\n    }\n    return ret;\n}\n\n\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    init();\n    int n; cin >> n;\n    vector<long long> x(n, 0), y(n, 0), z(n, 0);\n    vector<vector<int>> vx(n), vy(n), vz(n);\n    calc(n, x, vx); calc(n, y, vy); calc(n, z, vz);\n    if (vx > vy) {\n        swap(vx, vy); swap(x, y);\n    }\n    if (vy > vz) {\n        swap(vy, vz); swap(y, z);\n    }\n    if (vx > vy) {\n        swap(vx, vy); swap(x, y);\n    }\n    auto r = mul(x, y, n);\n    auto q = mul(r, z, n);\n    cout << (q[0]) % mod << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define MOD 1000000007\n#define MOD 998244353\n\nclass mint {\n\tpublic:\n\t\tint i;\n\n\t\tmint() : i(0) {}\n\n\t\ttemplate<class T>\n\t\t\tmint(T x) {\n\t\t\t\ti = int(x % MOD);\n\t\t\t\tif (i < 0) i += MOD;\n\t\t\t}\n\n\t\tmint operator+(mint x) {\n\t\t\treturn i + x.i;\n\t\t}\n\n\t\tmint operator-(mint x) {\n\t\t\treturn i - x.i;\n\t\t}\n\n\t\tmint operator*(mint x) {\n\t\t\treturn (long long)i * x.i;\n\t\t}\n\n\t\tmint operator/(mint x) {\n\t\t\treturn (long long)i * x.pow(MOD - 2).i;\n\t\t}\n\n\t\tmint inv() {\n\t\t\treturn pow(MOD - 2);\n\t\t}\n\n\t\ttemplate<class T>\n\t\t\tmint pow(T p) {\n\t\t\t\tlong long r = 1;\n\t\t\t\tlong long t = i;\n\t\t\t\tfor(; p > 0; p >>= 1) {\n\t\t\t\t\tif (p & 1) r = r * t % MOD;\n\t\t\t\t\tt = t * t % MOD;\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\ttemplate<class T1, class T2>\n\t\t\tstatic mint pow(T1 a, T2 b) {\n\t\t\t\tlong long r = 1;\n\t\t\t\tlong long t = (long long)(a % MOD);\n\t\t\t\tfor(; b > 0; b >>= 1) {\n\t\t\t\t\tif (b & 1) r = r * t % MOD;\n\t\t\t\t\tt = t * t % MOD;\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\tmint& operator+=(mint x) {\n\t\t\ti = (i + x.i) % MOD;\n\t\t\treturn *this;\n\t\t}\n\n\t\tmint& operator-=(mint x) {\n\t\t\ti = i - x.i;\n\t\t\tif (i < 0) i += MOD;\n\t\t\treturn *this;\n\t\t}\n\n\t\tmint& operator*=(mint x) {\n\t\t\ti = (int)((long long)i * x.i % MOD);\n\t\t\treturn *this;\n\t\t}\n\n\t\tmint& operator/=(mint x) {\n\t\t\ti = (long long)i * x.pow(MOD - 2).i % MOD;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream& os, const mint& m) {\n\treturn os << m.i;\n}\n\nstd::vector<std::vector<int>> iig(int vn, int en) { \n        std::vector<std::vector<int>> res(vn); \n        for(int i = 0; i < en; i++) { \n                int s, t; \n                std::cin >> s >> t; \n                s--; t--; \n\t\tif (s > t) swap(s, t);\n                res[t].push_back(s); \n        } \n        return res; \n}\n\nstd::vector<int> assign_grundy(std::vector<std::vector<int>>& dg) {\n\tint gsize = dg.size();\n\tstd::vector<int> incomings(gsize);\n\tfor(int i = 0; i < gsize; i++) {\n\t\tfor(int j: dg[i]) {\n\t\t\tincomings[j]++;\n\t\t}\n\t}\n\tstd::vector<int> vs_ready;\n\tfor(int i = 0; i < gsize; i++) {\n\t\tif (incomings[i] == 0) vs_ready.push_back(i);\n\t}\n\tstd::vector<std::set<int>> prohibited_grundy(gsize);\n\tstd::vector<int> grundy(gsize);\n\twhile(!vs_ready.empty()) {\n\t\tint i = vs_ready.back();\n\t\tvs_ready.pop_back();\n\t\tint g = 0;\n\t\tfor(int pg: prohibited_grundy[i]) {\n\t\t\tif (g == pg) g++;\n\t\t\telse break;\n\t\t}\n\t\tgrundy[i] = g;\n\t\tfor(int j: dg[i]) {\n\t\t\tprohibited_grundy[j].insert(g);\n\t\t\tif ((--incomings[j]) == 0) vs_ready.push_back(j);\n\t\t}\n\t}\n\treturn grundy;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n;\n\tcin >> m;\n\tauto g1 = iig(n, m);\n\tcin >> m;\n\tauto g2 = iig(n, m);\n\tcin >> m;\n\tauto g3 = iig(n, m);\n\t// assume that each edge direction is reversed\n\tauto grn1 = assign_grundy(g1);\n\tauto grn2 = assign_grundy(g2);\n\tauto grn3 = assign_grundy(g3);\t\n\t// gmax * (gmax + 1) <= E * 2\n\n\tvector<mint> w(n + 1);\n\tmint step = mint(10).pow(18);\n\tw[0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tw[i] = w[i-1] * step;\n\t}\n\n\tvector<mint> gcount1(500), gcount2(500), gcount3(500);\n\tfor(int i = 0; i < n; i++) {\n\t\tgcount1[grn1[i]] += w[i+1];\n\t\tgcount2[grn2[i]] += w[i+1];\n\t\tgcount3[grn3[i]] += w[i+1];\n\t}\n\n\tmint res = 0;\n\n\tfor(int i = 0; i < 500; i++)\n\t\tfor(int j = 0; j < 500; j++) {\n\t\t\tint k = i ^ j;\n\t\t\tres += gcount1[i] * gcount2[j] * gcount3[k];\n\t\t}\n\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int Maxn = 100005;\nconst int mod = 998244353;\nconst int pw = 1000000;\nconst int Maxm = 1005;\n\nint n;\nvector <int> neigh[Maxn];\nvector <int> my[3];\nint col[3][Maxn];\nint res;\n\nint toPower(int a, int p)\n{\n    int res = 1;\n    while (p) {\n        if (p & 1) res = ll(res) * a % mod;\n        p >>= 1; a = ll(a) * a % mod;\n    }\n    return res;\n}\n\nvoid Solve(vector <int> &res, int col[])\n{\n    int m; scanf(\"%d\", &m);\n    for (int i = 1; i <= n; i++)\n        neigh[i].clear();\n    for (int i = 0; i < m; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        if (a > b) swap(a, b);\n        neigh[a].push_back(b);\n    }\n    for (int i = n; i > 0; i--) {\n        vector <int> seq;\n        for (int j = 0; j < neigh[i].size(); j++)\n            seq.push_back(col[neigh[i][j]]);\n        sort(seq.begin(), seq.end());\n        col[i] = 0;\n        int my = toPower(pw, 3 * i);\n        for (int j = 0; j < seq.size(); j++)\n            if (seq[j] == col[i]) col[i]++;\n        if (col[i] == res.size()) res.push_back(my);\n        else res[col[i]] = (res[col[i]] + my) % mod;\n    }\n    reverse(res.begin(), res.end());\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < 3; i++) {\n        Solve(my[i], col[i]);\n        assert(my[i].size() < Maxm);\n    }\n    while (my[0].size() >= 2 && my[1].size() >= 2 && my[2].size() >= 2) {\n        int a2 = my[0].back(); my[0].pop_back();\n        int a1 = my[0].back(); my[0].pop_back();\n        int b2 = my[1].back(); my[1].pop_back();\n        int b1 = my[1].back(); my[1].pop_back();\n        int c2 = my[2].back(); my[2].pop_back();\n        int c1 = my[2].back(); my[2].pop_back();\n        res = (res + ll(a2) * b2 % mod * c2) % mod;\n        res = (res + ll(a1) * b1 % mod * c2) % mod;\n        res = (res + ll(a1) * b2 % mod * c1) % mod;\n        res = (res + ll(a2) * b1 % mod * c1) % mod;\n    }\n    if (my[0].size() > my[1].size()) swap(my[0], my[1]);\n    if (my[1].size() > my[2].size()) swap(my[1], my[2]);\n    if (my[0].size() > my[1].size()) swap(my[0], my[1]);\n    if (my[0].size() == 1) {\n        int a = my[0].back();\n        while (my[1].size() >= 1 && my[2].size() >= 1) {\n            int b = my[1].back(); my[1].pop_back();\n            int c = my[2].back(); my[2].pop_back();\n            res = (res + ll(a) * b % mod * c) % mod;\n        }\n    }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int S = 500, SSS = S * S * S, N = 1e5 + 5, mod = 998244353;\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nconst int base = powmod(10, 18);\n\nbitset<SSS> vis;\n\nint pos(int a, int b, int c) {\n  return ((a * S) + b) * S + c;\n}\n\ntuple<int, int, int> decod(int v) {\n  int c = v % S;\n  v /= S;\n  int b = v % S;\n  v /= S;\n  return make_tuple(v, b, c);\n}\n\nvector<int> g[N];\n\nvector<pair<int, int>> independent(int n, vector<pair<int ,int>> & edges) {\n  for (int i = 0; i < n; ++i)\n    g[i].clear();\n  for (auto e : edges) {\n    g[e.first].push_back(e.second);\n    g[e.second].push_back(e.first);\n  }\n  vector<bool> done(n, false), mark(n);\n  int cnt = 0;\n  vector<pair<int, int>> res;\n  while (cnt < n) {\n    mark = done;\n    int hig = -1, sum = 0;\n    for (int v = n-1; v >= 0; --v) {\n      if (mark[v]) continue;\n      ++cnt;\n      done[v] = 1;\n      hig = max(hig, v+1);\n      sum = (sum + powmod(base, v+1)) % mod;\n      for (int u : g[v]) {\n        mark[u] = 1;\n      }\n    }\n    res.emplace_back(hig, sum);\n  }\n  return res;\n}\n\nvector<pair<int, int>> read_edges() {\n  int m;\n  scanf(\"%d\", &m);\n  vector<pair<int, int>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &edges[i].first, &edges[i].second);\n    --edges[i].first;\n    --edges[i].second;\n  }\n  return edges;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> ex = read_edges();\n  vector<pair<int, int>> ey = read_edges();\n  vector<pair<int, int>> ez = read_edges();\n  vector<pair<int, int>> rx = independent(n, ex);\n  vector<pair<int, int>> ry = independent(n, ey);\n  vector<pair<int, int>> rz = independent(n, ez);\n  assert(rx.size() < S);\n  assert(ry.size() < S);\n  assert(rz.size() < S);\n  vector<vector<bool>> xy(rx.size(), vector<bool>(ry.size(), false));\n  vector<vector<bool>> xz(rx.size(), vector<bool>(rz.size(), false));\n  vector<vector<bool>> yz(ry.size(), vector<bool>(rz.size(), false));\n  priority_queue<pair<int, int>> pq;\n  auto insert_node = [&](int i, int j, int k) {\n    if (i >= (int)rx.size() || j >= (int)ry.size() || k >= (int)rz.size())\n      return;\n    int now = pos(i, j, k);\n    if (vis[now])\n      return;\n    pq.emplace(rx[i].first + ry[j].first + rz[k].first, now);\n    vis[now] = 1;\n  };\n  priority_queue<pair<int, int>> pxy, pxz, pyz;\n  for (int i = 0; i < (int)rx.size(); ++i) {\n    for (int j = 0; j < (int)ry.size(); ++j) {\n      pxy.emplace(rx[i].first + ry[j].first, i * S + j);\n    }\n  }\n  for (int i = 0; i < (int)rx.size(); ++i) {\n    for (int j = 0; j < (int)rz.size(); ++j) {\n      pxz.emplace(rx[i].first + rz[j].first, i * S + j);\n    }\n  }\n  for (int i = 0; i < (int)ry.size(); ++i) {\n    for (int j = 0; j < (int)rz.size(); ++j) {\n      pyz.emplace(ry[i].first + rz[j].first, i * S + j);\n    }\n  }\n  long long ans = 0;\n  while (1) {\n    while (!pxy.empty() && xy[pxy.top().second/S][pxy.top().second % S]) pxy.pop();\n    while (!pxz.empty() && xz[pxz.top().second/S][pxz.top().second % S]) pxz.pop();\n    while (!pyz.empty() && yz[pyz.top().second/S][pyz.top().second % S]) pyz.pop();\n    int i, j, k;\n    i = j = k = -1;\n    int best = -1;\n    // cerr << pxy.size() << \" sz \" << pxz.size() << \" \" << pyz.size() << endl;\n    if (!pxy.empty()) {\n      int ii = pxy.top().second / S, jj = pxy.top().second % S;\n      // cerr << ii << \" x \" << jj << endl;\n      for (int kk = 0; kk < (int)rz.size(); ++kk) {\n        if (xy[ii][jj] || xz[ii][kk] || yz[jj][kk]) continue;\n        int cost = rx[ii].first + ry[jj].first + rz[kk].first;\n        if (best < cost) {\n          i = ii;\n          j = jj;\n          k = kk;\n          best = cost;\n        }\n      }\n    }\n\n    if (!pxz.empty()) {\n      int ii = pxz.top().second / S, kk = pxz.top().second % S;\n      // cerr << ii << \" y \" << kk << endl;\n      for (int jj = 0; jj < (int)ry.size(); ++jj) {\n        if (xy[ii][jj] || xz[ii][kk] || yz[jj][kk]) continue;\n        int cost = rx[ii].first + ry[jj].first + rz[kk].first;\n        if (best < cost) {\n          i = ii;\n          j = jj;\n          k = kk;\n          best = cost;\n        }\n      }\n    }\n\n    if (!pyz.empty()) {\n      int jj = pyz.top().second / S, kk = pyz.top().second % S;\n      // cerr << jj << \" z \" << kk << endl;\n      for (int ii = 0; ii < (int)rx.size(); ++ii) {\n        if (xy[ii][jj] || xz[ii][kk] || yz[jj][kk]) continue;\n        int cost = rx[ii].first + ry[jj].first + rz[kk].first;\n        if (best < cost) {\n          i = ii;\n          j = jj;\n          k = kk;\n          best = cost;\n        }\n      }\n    }\n    if (best < 0) break;\n    // cerr << i << \" \" << j << \" \" << k << endl;\n    long long cur = rx[i].second * (long long) ry[j].second % mod;\n    cur = cur * rz[k].second % mod;\n    ans = (ans + cur) % mod;\n    xy[i][j] = 1;\n    xz[i][k] = 1;\n    yz[j][k] = 1;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e5+10, P = 998244353;\nint n, m, vis[N], sg[N], h[N], f[3][N];\nvector<int> g[N];\nvoid add(int &a, ll b) {a=(a+b)%P;}\n\nint main() {\n\th[0] = 1;\n\th[1] = 1000000000000000000ll%P;\n\tREP(i,2,N-1) h[i] = (ll)h[i-1]*h[1]%P;\n\tscanf(\"%d\", &n);\n\tREP(i,0,2) {\n\t\tscanf(\"%d\", &m);\n\t\tREP(j,1,n) g[j].clear();\n\t\tREP(j,1,m) {\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif (u>v) swap(u,v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tPER(j,1,n) {\n\t\t\tint sz = g[j].size();\n\t\t\tREP(k,0,sz) vis[k] = 0;\n\t\t\tfor (int k:g[j]) vis[sg[k]] = 1;\n\t\t\tREP(k,0,sz) if (!vis[k]) {\n\t\t\t\tsg[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(f[i][sg[j]],h[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i,0,600) REP(j,0,600) {\n\t\tadd(ans, (ll)f[0][i]*f[1][j]%P*f[2][i^j]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/agc043/tasks/agc043_c\n#define CIN_ONLY\n#define DECIMAL_DIGITS 10\n#define STATIC_MOD 998244353\n\n#ifdef BTK\n/*<head>*/\n#    include \"Template.hpp\"\n#    include \"num/ModInt.hpp\"\n/*</head>*/\n#else\n/*<body>*/\n/* #region auto includes */\n/* #region stl */\n/*<stl>*/\n#    include <bits/stdc++.h>\n#    include <sys/types.h>\n#    include <unistd.h>\nusing namespace std;\n/*</stl>*/\n/* #endregion */\n/* #region template/Grid.hpp*/\n\n/**\n * @brief グリッドをラップするための関数\n * @tparam T std::string や std;:vector を想定\n * @tparam U 周りに配置する要素の型\n * @param grid 入力、R > 0 でないとバグる\n * @param material 周りに配置する要素\n * @return std::vector<T> material で 周りを埋めた grid\n */\ntemplate <typename T, typename U>\ninline std::vector<T> wrapGrid(std::vector<T> grid, U material) {\n    std::vector<T> wrappedGrid(grid.size() + 2,\n                               T(grid[0].size() + 2, material));\n    for (std::size_t i = 0; i < grid.size(); i++) {\n        for (std::size_t j = 0; j < grid[i].size(); j++) {\n            wrappedGrid[i + 1][j + 1] = grid[i][j];\n        }\n    }\n    return wrappedGrid;\n}\n\n/**\n * @brief\n *\n */\nconstexpr int dr4[] = {0, 1, 0, -1};\nconstexpr int dc4[] = {-1, 0, 1, 0};\n/* #endregion */\n/* #region template/IncludeSTL.hpp*/\n/**\n * @file IncludeSTL.hpp\n * @author btk\n * @brief 標準ライブラリをincludeするだけ\n * @version 0.1\n * @date 2019-07-21\n * @todo 何故か2回includeされる（展開scriptに\n * @copyright Copyright (c) 2019\n *\n */\n\n\n/* #endregion */\n/* #region template/Macro.hpp*/\n/**\n * @file Macro.hpp\n * @author btk\n * @brief マクロとか，LLとか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n//! LL\nusing LL = long long;\n\n/**\n * @def DEBUG\n * @brief デバッグ用のif文 提出時はif(0)で実行されない\n */\n\n/*</head>*/\n#    ifdef BTK\n#        define DEBUG if (1)\n#    else\n#        ifdef CIN_ONLY\n#            define FAST_IO\n#        endif\n#        define DEBUG if (0)\n#    endif\n/**\n * @def ALL(v)\n * @brief\n * ALLマクロ\n */\n#    define ALL(v) (v).begin(), (v).end()\n\n/**\n * @def REC(ret, ...)\n * @brief\n * 再帰ラムダをするためのマクロ\n */\n#    define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n\n/**\n * @def VAR_NAME(var)\n * @brief 変数名を取得する\n */\n#    define VAR_NAME(var) #    var\n\n/**\n * @brief\n * rangeで生まれる使わない変数を消す用（警告消し）\n */\ntemplate <typename T>\ninline T& unused_var(T& v) {\n    return v;\n}\n\ntemplate <typename T>\nstd::vector<T> nestingVector(std::size_t size) {\n    return std::vector<T>(size);\n}\n\ntemplate <typename T, typename... Ts>\ninline auto nestingVector(std::size_t size, Ts... ts) {\n    return std::vector<decltype(nestingVector<T>(ts...))>(\n        size, nestingVector<T>(ts...));\n}\n/* #endregion */\n/* #region template/IO.hpp*/\n/**\n * @file IO.hpp\n * @author btk\n * @brief cin高速化とか，出力の小数桁固定とか\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n */\n\n\n/**\n * @brief 入出力の設定を行うための構造体\n */\nstruct cww {\n    /**\n     * @brief Construct a new cww::cww object\n     * @details\n     * CIN_ONLYを定義すると，submit時にcinとscanfの同期を切る設定が走る\n     * DECIMAL_DIGITSを定義すると，doubleの出力時指定した桁数分小数部を吐くようになる\n     */\n    cww() {\n#    ifdef FAST_IO\n        std::ios::sync_with_stdio(false);\n        std::cin.tie(0);\n#    endif\n#    ifdef DECIMAL_DIGITS\n        std::cout << std::fixed;\n        std::cout << std::setprecision(DECIMAL_DIGITS);\n#    endif\n    }\n};\n\n//! 入出力設定構造体を実体化\ncww star;\n\n/**\n * @brief\n * vectorに直接cin流すためのやつ\n * @tparam T\n * @param is\n * @param v\n * @return istream&\n */\ntemplate <typename T>\nstd::istream& operator>>(std::istream& is, std::vector<T>& v) {\n    for (auto& it : v) is >> it;\n    return is;\n}\n/* #endregion */\n/* #region template/Loop.hpp*/\n/**\n * @file Loop.hpp\n * @author btk\n * @brief rangeとかループ系のクラス\n * @version 0.1\n * @date 2019-07-13\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n\n/**\n * @brief\n * rangeを逆向きに操作したいとき用\n * @details\n * ループの範囲は[bg,ed)なので注意\n * @see range\n */\nclass reverse_range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x - 1; }\n        bool operator!=(I& lhs) { return x > lhs.x; }\n        void operator++() { --x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param n\n     */\n    reverse_range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new reverse range object\n     *\n     * @param i\n     * @param n\n     */\n    reverse_range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return n; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return i; }\n};\n/**\n * @brief\n * python みたいな range-based for を実現\n * @details\n * ループの範囲は[bg,ed)なので注意\n * !つけると逆向きにループが回る (reverse_range)\n * 空間計算量はO(1)\n * 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n */\nclass range {\n  private:\n    struct I {\n        int x;\n        int operator*() { return x; }\n        bool operator!=(I& lhs) { return x < lhs.x; }\n        void operator++() { ++x; }\n    };\n    I i, n;\n\n  public:\n    /**\n     * @brief Construct a new range object\n     *\n     * @param n\n     */\n    range(int n) : i({0}), n({n}) {}\n    /**\n     * @brief Construct a new range object\n     *\n     * @param i\n     * @param n\n     */\n    range(int i, int n) : i({i}), n({n}) {}\n    /**\n     * @brief\n     * begin iterator\n     * @return I&\n     */\n    I& begin() { return i; }\n    /**\n     * @brief\n     * end iterator\n     * @return I&\n     */\n    I& end() { return n; }\n    /**\n     * @brief\n     * 逆向きに参照するrange(reverse_rangeを取得できるs)\n     * @return reverse_range\n     */\n    reverse_range operator!() { return reverse_range(*i, *n); }\n};\n/* #endregion */\n/* #region template/Math.hpp*/\n\n/**\n * @brief gcd, ceil等自作算数用関数を集める。stdと被るので名前空間を区切る\n */\nnamespace math {\n\n    /**\n     * @brief aとｂの最大公約数\n     * @param a int64\n     * @param b int64\n     * @return int64 最大公約数\n     */\n    int64_t gcd(int64_t a, int64_t b) { return (b == 0) ? a : gcd(b, a % b); }\n\n    /**\n     * @brief aとｂの最小公倍数\n     * @param a int64\n     * @param b int64\n     * @return int64 最小公倍数\n     */\n    int64_t lcm(int64_t a, int64_t b) { return (a / gcd(a, b)) * b; }\n\n\n    /**\n     * @brief 拡張ユークリッド互除法\n     * @details ax + by = gとなるx,yを求める\n     * @param a 入力\n     * @param b 入力\n     * @param x 値引き継ぎ用の変数\n     * @param y 値引き継ぎ用の変数\n     * @return int64_t g:aとbの最大公約数\n     */\n    int64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y) {\n        int64_t g = a;\n        x         = 1;\n        y         = 0;\n        if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n        return g;\n    }\n\n    /**\n     * @brief u/dを切り上げした整数を求める\n     * @todo 負の数への対応\n     * @tparam T 整数型\n     * @param u 入力\n     * @param d 入力\n     * @return T 切り上げ後の値\n     */\n    template <typename T>\n    inline T ceil(T u, T d) {\n        return (u + d - (T)1) / d;\n    }\n\n} // namespace math\n/* #endregion */\n/* #region template/MinMaxOperation.hpp*/\n/**\n * @file MinMaxOperation.hpp\n * @author btk\n * @brief 最大値とか最小値を求める\n * @version 0.1\n * @date 2019-07-04\n *\n * @copyright Copyright (c) 2019\n *\n */\n\n/**\n * @brief 2項の最小値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct min_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l < r ? l : r; }\n};\n\n/**\n * @brief 2項の最大値求める\n *\n * @tparam T\n */\ntemplate <typename T>\nstruct max_op {\n    /**\n     * @brief 本体\n     *\n     * @param l\n     * @param r\n     * @return T\n     */\n    static T exec(const T l, const T r) { return l > r ? l : r; }\n};\n\n/**\n * @brief テンプレート再帰の末尾\n *\n * @tparam F 二項演算\n * @tparam T\n * @param v\n * @return T\n */\ntemplate <typename F, typename T>\ninline T multi_op(T&& v) {\n    return v;\n}\n\n/**\n * @brief 複数項における演算の結果を返す\n *\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename F, typename T, typename... Ts>\ninline T multi_op(const T head, Ts&&... tail) {\n    return F::exec(head, multi_op<F>(tail...));\n}\n\n/**\n * @brief 複数項の最小値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_min(T head, Ts... tail) {\n    return multi_op<min_op<T>>(head, tail...);\n}\n\n/**\n * @brief 複数項の最大値\n * @see multi_op\n * @tparam T\n * @tparam Ts\n * @param head\n * @param tail\n * @return T\n */\ntemplate <typename T, typename... Ts>\ninline T multi_max(T head, Ts... tail) {\n    return multi_op<max_op<T>>(head, tail...);\n}\n\n/**\n * @brief\n * \b先頭の値をFで参照する関数に基づいて変更できたらする\n * @tparam F\n * @tparam T\n * @tparam Ts\n * @param target\n * @param candidates\n * @return true\n * @return false\n */\ntemplate <typename F, typename T, typename... Ts>\ninline bool ch_op(T& target, Ts&&... candidates) {\n    const T old = target;\n    target      = multi_op<F>(target, candidates...);\n    return old != target;\n}\n\n/**\n * @brief change min\n * @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmin(T& target, Ts&&... candidates) {\n    return ch_op<min_op<T>>(target, candidates...);\n}\n\n/**\n * @brief chminのmax版\n * @see chmin\n *  @tparam T 型\n * @param target 変更する値\n * @param candidates\n * @return 更新があればtrue\n */\ntemplate <typename T, typename... Ts>\ninline bool chmax(T& target, Ts&&... candidates) {\n    return ch_op<max_op<T>>(target, candidates...);\n}\n/* #endregion */\n/* #region template/Random.hpp*/\n/**\n * @file Random.hpp\n * @author btk\n * @brief 乱数生成系\n * @version 0.1\n * @date 2019-07-13\n * @copyright Copyright (c) 2019\n */\n\n\n//! 乱数のシード値をプロセスIDとして取得\nconst pid_t pid = getpid();\n\n/**\n * @brief XorShift32の実装\n */\nclass XorShift32 {\n  private:\n    //! XorShiftの現在の値\n    unsigned value;\n\n    /**\n     * @brief XorShift32のアルゴリズムに基づいて value を更新\n     */\n    inline void update() {\n        value = value ^ (value << 13);\n        value = value ^ (value >> 17);\n        value = value ^ (value << 5);\n    }\n\n    /**\n     * @brief 値を更新し，更新前の値を返却\n     * @return unsigned 呼び出し時の value を用いる\n     */\n    inline unsigned get() {\n        unsigned v = value;\n        update();\n        return v;\n    }\n\n  public:\n    /**\n     * @brief [0, 2^bit) の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_int() {\n        return (int)(get() >> (32 - bit));\n    }\n\n    /**\n     * @brief [-2^bit,2^bit)の範囲の乱数値を取り出す\n     * @tparam デフォルトは31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int next_signed() {\n        unsigned v = get();\n        return (int)((v >> (31 - bit)) - (1 << (bit)));\n    }\n\n    /**\n     * @brief next_int呼び出し時の最大値を取得\n     * @tparam 31\n     * @return int\n     */\n    template <int bit = 31>\n    inline int range_max() {\n        return (int)((1u << bit) - 1);\n    };\n\n    /**\n     * @brief Construct a new XorShift32 object\n     * @param seed\n     * @details 初期シードをvalueとするXorShift32のインスタンスを生成\n     */\n    XorShift32(const unsigned seed) {\n        value = seed;\n        update();\n    }\n\n    /**\n     * @brief Construct a new XorShift 32 object\n     * @details 初期シードをプロセスIDとするXorShift32のインスタンスを生成\n     */\n    XorShift32() : XorShift32(pid) {}\n};\n/* #endregion */\n/* #region template/Strings.hpp*/\n/**\n * @file Strings.hpp\n * @author btk\n * @brief 文字列を扱いやすくするライブラリ\n * @version 0.1\n * @date 2020-02-02\n *\n * @copyright Copyright (c) 2020\n *\n */\n\n\n/**\n * @brief コレクションを文字列に変換する関数\n * @tparam T コレクションの型、range-based for に対応している必要あり\n * @tparam U 区切り文字の型\n * @param v コレクション\n * @param delimiter 区切り文字\n * @return std::string delimiterで結合された文字列\n */\ntemplate <typename T, typename U>\nstd::string join(const T& v, const U delimiter) {\n    std::stringstream ss;\n    bool isFirst = true;\n    for (auto& it : v) {\n        if (!isFirst) {\n            ss << delimiter;\n        }\n        isFirst = false;\n        ss << it;\n    }\n    return ss.str();\n}\n\n/**\n * @brief コレクションを文字列に変換する関数（イテレータ版）\n * @tparam ITR イテレータ型\n * @tparam T 区切り文字の型\n * @param bg 開始\n * @param ed 終了\n * @param delimiter 区切り文字\n * @return std::string delimiterで結合された文字列\n */\ntemplate <typename ITR, typename T>\nstd::string join(const ITR bg, const ITR ed, const T delimiter) {\n    std::stringstream ss;\n    bool isFirst = true;\n    for (auto it = bg; it != ed; ++it) {\n        if (!isFirst) {\n            ss << delimiter;\n        }\n        isFirst = false;\n        ss << *it;\n    }\n    return ss.str();\n}\n/* #endregion */\n/* #region Template.hpp*/\n/**\n * @file Template.hpp\n * @brief 競技プログラミング用テンプレート\n * @author btk15049\n * @date 2019/05/02\n */\n\n\n/* #endregion */\n/* #region num/ModInt.hpp*/\n\n#    include <utility>\n\n/**\n * @file ModInt.hpp\n * @brief mod構造体\n * @author btk15049\n * @date 2019/03/08\n * @details\n *  \\todo verifyが足りない\n *  verify: CSA12E，RUPC day3 F\n */\n\n//! [WARNING!] mod が入力で与えられる場合はconstexprを外す\n#    ifdef STATIC_MOD\nconstexpr int mod = STATIC_MOD;\n#    else\nint mod;\n#    endif\n\n/**\n * @brief mod構造体\n * @details\n * 整数をラップして，常に保持されているデータがmodされた状態になるよう管理．\n */\nclass ModInt {\n  private:\n    //! 中身\n    int x;\n\n  public:\n    /**\n     * @brief ゲッター\n     * @details 出力時などは \"cout << *ret << endl;\"のようにやるとよい．\n     */\n    long long operator*() const { return x; }\n    /**\n     * @brief デフォルトコンストラクタ．0で初期化される．\n     */\n    ModInt() { x = 0; }\n\n    /**\n     * @brief intからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt(const int y) { x = y; }\n\n    /**\n     * @brief long longからのコンストラクタ\n     * @param[in] y 設定したい値\n     * @details 毎回modを取るので低速．\n     */\n    ModInt(const long long y) { x = (int)((mod + y % mod) % mod); }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt(const ModInt& o) { this->x = *o; }\n    /**\n     * @brief 整数から高速にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details xが[0,mod)であることが保証されてないと正しく動かない．\n     */\n    static inline ModInt raw(const long long x) {\n        // assert(x<mod);\n        return ModInt((int)x);\n    }\n\n    /**\n     * @brief 整数から安全にModIntを作りたいときに使う\n     * @param[in] x 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    static inline ModInt get(const long long x) { return ModInt(x); }\n\n    /**\n     * @brief intからの代入演算子\n     * @param[in] o 設定したい値\n     * @details\n     * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    ModInt& operator=(const int o) {\n        this->x = o >= mod ? o - mod : o;\n        return *this;\n    }\n\n    /**\n     * @brief long longからの代入演算子\n     * @param[in] o 設定したい値\n     * @details mod2回取るから遅い．負数でもOK．\n     */\n    ModInt& operator=(const long long o) {\n        this->x = (int)((mod + o % mod) % mod);\n        return *this;\n    }\n\n    /**\n     * @brief ModIntからの代入演算子\n     * @param[in] o 設定したい値\n     * @details 高速\n     */\n    ModInt& operator=(const ModInt o) {\n        this->x = *o;\n        return *this;\n    }\n};\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n * @details if文使って少し高速化．\n */\ninline ModInt add(const ModInt l, const ModInt r) {\n    const long long x = *l + *r;\n    return ModInt::raw(x >= mod ? x - mod : x);\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt．\n */\ninline ModInt mul(const ModInt l, const ModInt r) {\n    return ModInt::raw(*l * *r % mod);\n}\n\n/**\n * @brief a^x %modを求める\n * @param[in] a ModInt\n * @param[in] x long long．\n */\ninline ModInt pow(ModInt a, long long x) {\n    ModInt ret = ModInt::raw(1);\n    while (x) {\n        if (x & 1) {\n            ret = mul(ret, a);\n        }\n        a = mul(a, a);\n        x >>= 1;\n    }\n    return ret;\n}\n\n/**\n * @brief x^-1 %modを求める\n * @param[in] x ModInt．\n * @details\n *   内部ではユークリッドの拡張互助法を使っている．\n *   O(log(mod))\n */\ninline ModInt inv(const ModInt x) {\n    long long a = *x, b = mod, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        std::swap(a -= t * b, b);\n        std::swap(u -= t * v, v);\n    }\n    return ModInt::get(u);\n}\n\n/**\n * @brief 負数を求める単項演算子\n * @param[in] x ModInt\n */\ninline ModInt operator-(const ModInt x) { return add(mod, -*x); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator+(const ModInt l, const ModInt r) { return add(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator*(const ModInt l, const ModInt r) { return mul(l, r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r ModInt\n */\ninline ModInt operator-(const ModInt l, const ModInt r) { return add(l, -r); }\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator+(const ModInt l, const int r) {\n    return add(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator+(const ModInt l, const long long r) {\n    return add(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator*(const ModInt l, const int r) {\n    return mul(l, ModInt::raw(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator*(const ModInt l, const long long r) {\n    return mul(l, ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator-(const ModInt l, const int r) {\n    return add(l, ModInt::raw(mod - r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator-(const ModInt l, const long long r) {\n    return add(l, -ModInt::get(r));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n * @details\n * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n */\ninline ModInt operator/(const ModInt l, const int r) {\n    return mul(l, inv(ModInt::raw(r)));\n}\n\n/**\n * @param[in] l ModInt\n * @param[in] r int\n */\ninline ModInt operator/(const ModInt l, const long long r) {\n    return mul(l, inv(ModInt::get(r)));\n}\n\n/**\n* @param[in] l ModInt\n* @param[in] r long long\n* @details\n*   pow(l,r)を呼び出すだけなのでpowを参照のこと．\n計算量はO(log mod)\n*/\ninline ModInt operator^(const ModInt l, const long long r) { return pow(l, r); }\n\n/**\n * @brief\n * +=の実装、各operator+を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 足すやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator+=(ModInt& l, T r) {\n    l = l + r;\n    return l;\n}\n\n/**\n * @brief\n * -=の実装、各operator-を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r 引くやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator-=(ModInt& l, T r) {\n    l = l - r;\n    return l;\n}\n\n/**\n * @brief\n * *=の実装、各operator*を呼ぶだけ\n * @tparam T\n * @param l ModInt\n * @param r かけるやつ\n * @return ModInt&\n */\ntemplate <typename T>\nModInt& operator*=(ModInt& l, T r) {\n    l = l * r;\n    return l;\n}\n\n/**\n * @namespace factorial\n * @brief 順列数関連の関数のまとめ\n * @details\n *   - combination\n *   - permutation\n *   - multiChoose\n */\nnamespace factorial {\n    //! 順列数を格納する配列のサイズ\n    constexpr int size =\n#    ifdef FACTORIAL_SIZE\n        FACTORIAL_SIZE;\n#    else\n        3123456;\n#    endif\n    //! 前計算ができているかどうかのフラグ\n    bool is_build = false;\n\n    //! 順列数を格納する配列\n    ModInt factorial[size];\n    //! (順列数)^-1を格納する配列\n    ModInt inverse_factorial[size];\n\n    /**\n     * @brief 順列数の前計算\n     * @details\n     *   順列数と，その逆元を[0,size)まで求める.\n     *   計算量は，O(size + log(mod))\n     */\n    void build() {\n        is_build     = true;\n        factorial[0] = 1;\n        for (int i = 1; i < size; i++) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n        inverse_factorial[size - 1] = inv(factorial[size - 1]);\n        for (int i = size - 1; i >= 1; i--) {\n            inverse_factorial[i - 1] = inverse_factorial[i] * i;\n        }\n    }\n\n    /**\n     * @brief nPkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt permutation(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief nCkを求める\n     * @details\n     *   前計算がしてあれば O(1)．前計算してない場合は is_build\n     * を読み取って前計算をする．\n     */\n    inline ModInt combination(int n, int k) {\n        if (k < 0 || k > n) return ModInt::raw(0);\n        if (!is_build) build();\n        return factorial[n] * inverse_factorial[k] * inverse_factorial[n - k];\n    }\n\n    /**\n     * @brief 重複組合せ\n     * @param n 何種類のものを (仕切りがn-1個)\n     * @param r いくつ並べるか\n     * @return ModInt nHr\n     */\n    ModInt multiChoose(int n, int r) {\n        if (n == 0 && r == 0) return ModInt::raw(1);\n        return combination(n + r - 1, r);\n    }\n\n    /**\n     * @brief 上限付き重複組合せ\n     * @details\n     * 包除原理を用いて，lim個以上の品物が1,2,...,i種類の場合を足したり引いたりしていく\n     * 計算量は O(min(n, r / lim))\n     * @param n 何種類のものを\n     * @param r いくつ並べるか\n     * @param lim 1種類のものを選べる上限\n     * @return ModInt\n     */\n    ModInt multiChoose(int n, int r, int lim) {\n        ModInt ret = 0;\n        for (int i = 0; i <= n; i++) {\n            if (i * (lim + 1) > r) break;\n            ret += ((i & 1) ? mod - 1 : 1) * combination(n, i)\n                   * multiChoose(n, r - i * (lim + 1));\n        }\n        return ret;\n    }\n\n} // namespace factorial\n  /* #endregion */\n  /* #endregion */\n  /*</body>*/\n#endif\n\nint n;\n\nusing VV = vector<vector<int>>;\nVV in() {\n    int m;\n    cin >> m;\n    auto g = nestingVector<int>(n, 0);\n    for (int i : range(m)) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    return g;\n}\n\n\nvector<ModInt> solve(VV& g) {\n    vector<int> color(n, -1);\n    VV cs(n);\n    vector<ModInt> ret(n);\n    ModInt e18 = ModInt((LL)(1e9)) * ModInt((LL)(1e9));\n    for (int v : !range(n)) {\n        vector<int> used;\n        used.reserve(g[v].size());\n        for (auto& u : g[v]) {\n            if (color[u] != -1) used.push_back(color[u]);\n        }\n        sort(ALL(used));\n        used.erase(unique(ALL(used)), used.end());\n        int val = used.size();\n        for (int i : range(used.size())) {\n            if (i != used[i]) {\n                val = i;\n                break;\n            }\n        }\n        ret[val] += e18 ^ (v + 1);\n        cs[val].push_back(v + 1);\n        color[v] = val;\n    }\n    return ret;\n}\n\nint main() {\n    /* write here */\n    cin >> n;\n    auto g1    = in();\n    auto g2    = in();\n    auto g3    = in();\n    auto s1    = solve(g1);\n    auto s2    = solve(g2);\n    auto s3    = solve(g3);\n    ModInt ret = s1[0] * s2[0] * s3[0];\n    for (int i : range(1, n)) {\n        ret += s1[0] * s2[i] * s3[i];\n        ret += s1[i] * s2[0] * s3[i];\n        ret += s1[i] * s2[i] * s3[0];\n    }\n    cout << *ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#ifdef CURIOUSCAT\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n#else\n#define Pr(f,...)\n#endif\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e6+50,P=998244353;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint C(int n,int m) { \n\tif (m<0||m>n)return 0;\n\tif(m<=1)return m==1?n:1;\n\treturn 1ll*C(n/2,m/2)*C(n%2,m%2)%2;\n}\n\nint n,pw[N],sg[3][N],ans,m,o[N],w[N],mx[3];\nvector<int> g[N];\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tread(n); \t\n\t{int w=1;rep(i,1,18)w=mul(w,10);\n\tpw[0]=1;rep(i,1,n)pw[i]=mul(pw[i-1],w);}\n\tlop(k,0,3){\n\t\trep(i,1,n)g[i].clear();\n\t\tread(m); \n\t\trep(i,1,m){\n\t\t\tint u,v; \n\t\t\tread(u),read(v); \n\t\t\tif(u>v)swap(u,v); \n\t\t\tg[u].pb(v); \n\t\t}\n\t\tmem(o,0); \n\t\tdec(v,n,1){\n\t\t\tfor(int d:g[v])o[w[d]]=v; \n\t\t\tint x=0;\n\t\t\twhile(o[x]==v)++x;\n\t\t\tw[v]=x;\n\t\t\tsg[k][x]=add(sg[k][x],pw[v]);\n\t\t\tif(w[v])Pr(\"w[%d]=%d\\n\",v,w[v]); \n\t\t\tcmax(mx[k],x); \n\t\t}\n\t\tPr(\"%d,%d\\n\",sg[k][0],sg[k][1]); \n\t}\n\trep(i,0,mx[0])rep(j,0,mx[1])ans=add(ans,mul(sg[0][i],mul(sg[1][j],sg[2][i^j]))); \n\tprintf(\"%d\\n\",ans); \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\ntypedef pair<ll,ll> P;\ntypedef priority_queue<P,vector<P>,greater<P>> P_queue;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(),a.end()\n#define SORT(a) sort(ALL(a))\n#define U_ERASE(V) V.erase(unique(ALL(V)), V.end());\n\nconst ll MOD=998244353;\nconst ll mod=1000000007;\nconst ll INF=1e18;\nvec dx={1,0,-1,0};\nvec dy={0,1,0,-1};\n\nconst ll Ki=INF%MOD;\nconst ll MAXN=100011;\nll memory[MAXN*3];\n\nll AN(ll x){\n    if(memory[x]!=-1) return memory[x];\n    if(x==0) return memory[x]=1;\n    ll T=AN(x/2);\n    T=(T*T)%MOD;\n    if(x%2==1) return (T*Ki)%MOD;\n    return T;\n}\nvec G[3][MAXN];\nll U[3][MAXN];\nvec M(3);\nvec Sy[3];\n\nint main(){\n    \n    rep(i,3*MAXN) memory[i]=-1;\n    rep(i,MAXN) rep(j,3) U[j][i]=-1;\n    //cout<<\"arrived\"<<endl;\n    ll N; cin>>N;\n    vec ANS(3,0), XANS(3,0);\n    rep(i,3){\n        cin>>M.at(i);\n        \n        rep(j,M.at(i)){\n            ll a,b; cin>>a>>b;\n            if(a>b) swap(a,b);\n            G[i][b].pb(a);\n        }\n        for(ll j=N; j>0; j--){\n            if(U[i][j]==0) {\n                Sy[i].pb(j);\n                XANS.at(i)=(XANS.at(i)+AN(j))%MOD;\n            }\n            if(U[i][j]!=0){\n                U[i][j]=1;\n                ANS.at(i)=(ANS.at(i)+AN(j))%MOD;\n                rep(k,G[i][j].size()) U[i][G[i][j].at(k)]=0;\n            }\n        }\n    }\n    ll ans=1;\n    \n    rep(i,3) ans=(ans*ANS.at(i))%MOD;\n    rep(i,3){\n        ll K=XANS.at(i);\n        K=(K*XANS.at((i+1)%3))%MOD;\n        K=(K*ANS.at((i+2)%3))%MOD;\n        ans=(K+ans)%MOD;\n    }\n    cout<<ans<<endl;\n\n\n    \n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=998244353;\nint n;\nll ans[300000];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nll qpow(ll x,ll p){\n\tll ret=1;\n\tfor(;p;p>>=1,x=x*x%cys) if(p&1) ret=ret*x%cys;\n\treturn ret;\n}\n\nstruct graph{\n\tint m;\n\tint col[100005];\n\tll A[300000];\n\tbool vis[100005];\n\tvector<int> adj[100005];\n\tvoid init(){\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tfor(auto v:adj[i]) vis[col[v]]=1;\n\t\t\twhile(vis[col[i]]) col[i]++;\n\t\t\tfor(auto v:adj[i]) vis[col[v]]=0;\n\t\t}\n\t\tfor(int i=1;i<=n;i++) A[col[i]]=(A[col[i]]+qpow(10,18*i))%cys;\n\t}\n}g[4];\n\nvoid fwt(ll *A,int m,int f){\n\tfor(int i=1;i<m;i<<=1){\n\t\tfor(int j=0;j<m;j+=(i<<1)){\n\t\t\tfor(int k=j;k<j+i;k++){\n\t\t\t\tll x=A[k],y=A[k+i];\n\t\t\t\tif(f>0) A[k]=mod(x+y),A[k+i]=mod(x+cys-y);\n\t\t\t\telse A[k]=(x+y)*((cys+1)/2)%cys,A[k+i]=(x+cys-y)*((cys+1)/2)%cys;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tn=readint();\n\tint x,y;\n\tfor(int i=1;i<=3;i++){\n\t\tg[i].m=readint();\n\t\tfor(int j=1;j<=g[i].m;j++){\n\t\t\tx=readint(); y=readint();\n\t\t\tif(x>y) swap(x,y);\n\t\t\tg[i].adj[x].pb(y);\n\t\t}\n\t\tg[i].init();\n\t}\n\tint m;\n\tfor(m=1;m<n;m<<=1);\n\tfor(int i=1;i<=3;i++) fwt(g[i].A,m,1);\n\tfor(int i=0;i<m;i++) ans[i]=g[1].A[i]*g[2].A[i]%cys*g[3].A[i]%cys;\n\tfwt(ans,m,-1);\n\tprintf(\"%lld\\n\",ans[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << ','; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \",\" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifndef ONLINE_JUDGE\n#define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)\n#else\n#define debug(x...)\n#endif\n\n#define rep(i, n)    for(int i = 0; i < (n); ++i)\n#define repA(i, a, n)  for(int i = a; i <= (n); ++i)\n#define repD(i, a, n)  for(int i = a; i >= (n); --i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define fill(a)  memset(a, 0, sizeof (a))\n#define fst first\n#define snd second\n#define mp make_pair\n#define pb push_back\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nll pw[100009];\nconst ll mod = 998244353;\nvoid pre(){\n\tpw[0]=1;\n\tpw[1]= ll(1e18)%mod;\n\trepA(i,2,100000) pw[i] = pw[i-1]*pw[1]%mod;\n}\n\nvoid solve(){\n\n\n}\nvi g[100009];\nint fg[100009];\nll dp[3][100009];\nint main() {\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\tpre();\n\tint n;cin>>n;\n\tll ans=0;\n\trep(i,3){\n\t\trep(j,n+1) g[j].clear();\n\t\tint m;cin>>m;\n\t\tfill(fg);\n\t\trep(k,m) {\n\t\t\tint u,v;cin>>u>>v;\n\t\t\tif(u>v) swap(u,v);\n\t\t\tg[v].pb(u);\n\t\t}\n\t\tset<int> s,cur;\n\t\trepA(j,1,n) s.insert(-j);\n\t\tint ix=1;\n\t\twhile(sz(s)){\n\t\t\twhile(sz(s)){\n\t\t\t\tint v = -(*(s.begin()));\n\t\t\t\ts.erase(s.begin());\n\t\t\t\tfg[v] = ix;\n\t\t\t\ttrav(u,g[v]){\n\t\t\t\t\tif(!fg[u]){\n\t\t\t\t\t\tauto it = s.find(-u);\n\t\t\t\t\t\tif(it!=s.end()&&(*it)==-u) {\n\t\t\t\t\t\t\ts.erase(it),cur.insert(-u);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ts=cur;\n\t\t\tcur.clear();\n\t\t\tix++;\n\t\t}\n\t\trepA(j,1,n){\n\t\t\tdp[i][fg[j]-1]+=pw[j];\n\t\t}\n\t}\n\trepA(j,0,n) rep(i,3) dp[i][j]%=mod;\n\trepA(j,1,n){\n\t\tans+=dp[0][0]*dp[1][j]%mod*dp[2][j]%mod;\n\t\tans+=dp[1][0]*dp[0][j]%mod*dp[2][j]%mod;\n\t\tans+=dp[2][0]*dp[1][j]%mod*dp[0][j]%mod;\n\t\tans%=mod;\n\t}\n\tans+=dp[0][0]*dp[1][0]%mod*dp[2][0]%mod;\n\tcout<<ans%mod;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n//#pragma GCC target(\"avx512f,avx512dq,avx512cd,avx512bw,avx512vl\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define DB double\n#define LD long double\n#define ST string\n#define BS bitset\n#define PA pair<LL,LL>\n#define VE vector\n#define VL vector<LL>\n#define VP vector<pair<LL,LL>>\n#define VVL vector<vector<LL>>\n#define PQ priority_queue\n#define PQS priority_queue<LL,vector<LL>,greater<LL>>\n#define PB push_back\n#define POB pop_back\n#define PF push_front\n#define POF pop_front\n#define EB emplace_back\n#define MP make_pair\n#define TS to_string\n#define TU to_ullong\n#define BPL __builtin_popcountll\n#define FOR(i,a,n) for(i=a;i<n;++i)\n#define FORR(i,a,n) for(i=n-1;i>=a;--i)\n#define rep(i,n) FOR(i,0,n)\n#define repr(i,n) FORR(i,0,n)\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define SORT(a) sort(ALL(a))\n#define REV(a) reverse(ALL(a))\n#define UB(a,n) *upper_bound(ALL(a),n)\n#define LB(a,n) *lower_bound(ALL(a),n)\n#define INF 1145141919810364364\n#define PI 3.14159265358979\n//#define MOD 1000000007\n#define MOD 998244353\n#define ERR 0.00000001\n#define NUM 200010\n#define FAST cin.tie(0);ios::sync_with_stdio(false)\n\nvoid Yn(LL a){if(a)printf(\"Yes\\n\");else printf(\"No\\n\");}\nvoid YN(LL a){if(a)printf(\"YES\\n\");else printf(\"NO\\n\");}\nLL pwmn(LL a,LL n){LL ans=1;while(ans<a)ans*=n;return ans;}\nLL dig(LL n){LL ret=0;while(n)n/=10,ret++;return ret;}\nLL LBn(VL &v,LL a){LL mx=v.size(),mn=-1,md;while(mx-mn>1){md=(mx+mn)/2;if(v[md]<a)mn=md;else mx=md;}return mx;}\nLL GCD(LL a,LL b){LL c=1,tmp=max(a,b);b=min(a,b);a=tmp;while(c!=0){c=a%b;a=b;b=c;}return a;}\nLL LCM(LL a,LL b){return a*b/GCD(a,b);}\nint lcmp(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return 1;if(*(LL*)a<*(LL*)b)return -1;return 0;}\nint lcmpr(const void* a,const void* b){if(*(LL*)a>*(LL*)b)return -1;if(*(LL*)a<*(LL*)b)return 1;return 0;}\nint ccmp(const void* a,const void* b){return *(char*)a-*(char*)b;}\nint ccmpr(const void* a,const void* b){return *(char*)b-*(char*)a;}\nint scmp(const void* a,const void* b){return strcmp((char*)a,(char*)b);}\nint scmpr(const void* a,const void* b){return strcmp((char*)b,(char*)a);}\nLL cmod(LL a,LL m){if(a%m<0)return a%m+abs(m);else return a%m;}\nLL DIV(LL a,LL d,LL m){LL l=m,x=1,y=0,k;while(l){k=d/l;d-=k*l;swap(l,d);x-=k*y;swap(x,y);}return cmod(a*cmod(x,m),m);}\nLL POW(LL a,LL n,LL m){LL ans=1;while(n>0){if(n&1)ans=ans*a%m;a=a*a%m;n>>=1;}return ans;}\nLL fact[NUM],finv[NUM],inv[NUM];\nvoid comi(){LL i;fact[0]=fact[1]=1;finv[0]=finv[1]=1;inv[1]=1;FOR(i,2,NUM){fact[i]=fact[i-1]*i%MOD;inv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;finv[i]=finv[i-1]*inv[i]%MOD;}}\nLL com(LL n,LL k){if(n<k||n<0||k<0)return 0;return fact[n]*(finv[k]*finv[n-k]%MOD)%MOD;}\nbool cmps(pair<LL,LL> a,pair<LL,LL> b){if(a.second!=b.second)return a.second<b.second;return a.first<b.first;}\ntemplate<typename T>bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\n#define MI modint<MOD>\ntemplate<int mod>struct modint{\n\tint x;\n\tmodint():x(0){}\n\tmodint(LL n):x(n>=0?n%mod:(mod-(-n)%mod)%mod){}\n\tmodint &operator+=(const modint &n){if((x+=n.x)>=mod)x-=mod;return *this;}\n\tmodint &operator-=(const modint &n){if((x+=mod-n.x)>=mod)x-=mod;return *this;}\n\tmodint &operator++(){*this+=1;return *this;}\n  modint &operator--(){*this-=1;return *this;}\n\tmodint &operator*=(const modint &n){x=(int)((LL)x*n.x%mod);return *this;}\n\tmodint &operator/=(const modint &n){*this*=n.inv();return *this;}\n\tmodint operator-()const{return modint(-x);}\n\tmodint operator+(const modint &n)const{return modint(*this)+=n;}\n\tmodint operator-(const modint &n)const{return modint(*this)-=n;}\n\tmodint operator++(int){modint ret(*this);*this+=1;return ret;}\n  modint operator--(int){modint ret(*this);*this-=1;return ret;}\n\tmodint operator*(const modint &n)const{return modint(*this)*=n;}\n\tmodint operator/(const modint &n)const{return modint(*this)/=n;}\n\tbool operator<(const modint &n)const{return x<n.x;}\n\tbool operator>(const modint &n)const{return x>n.x;}\n\tbool operator<=(const modint &n)const{return x<=n.x;}\n\tbool operator>=(const modint &n)const{return x>=n.x;}\n\tbool operator!=(const modint &n)const{return x!=n.x;}\n\tbool operator==(const modint &n)const{return x==n.x;}\n\tfriend istream &operator>>(istream &is,modint &n){LL l;is>>l;n=modint<mod>(l);return is;}\n\tfriend ostream &operator<<(ostream &os,const modint &n){return os<<n.x;}\n\tint getmod(){return mod;}\n\tmodint inv()const{int a=x,b=mod,c=1,d=0,n;while(b){n=a/b;swap(a-=n*b,b);swap(c-=n*d,d);}return modint(c);}\n\tmodint pow(LL n)const{modint ret(1),m(x);while(n){if(n&1)ret*=m;m*=m;n>>=1;}return ret;}\n};\n\nint main(){\n\tFAST;\n\tLL i,j,k,N,M,a,b;\n\tMI ans,h,iv;\n  cin>>N;\n\tVE<VE<MI>> s(3);\n\tiv=MI(10).pow(18).inv();\n\trep(k,3){\n\t\tVVL t(N);\n\t\tcin>>M;\n\t\trep(i,M){\n\t\t\tcin>>a>>b;\n\t\t\t--a,--b;\n\t\t\tif(a>b)swap(a,b);\n\t\t\tt[a].PB(b);\n\t\t}\n\t\th=MI(10).pow(18*N);\n\t\tVL g(N),f(N,-1);\n\t\trepr(i,N){\n\t\t\tfor(LL l:t[i])f[g[l]]=i;\n\t\t\twhile(f[g[i]]==i)++g[i];\n\t\t\twhile(s[k].size()<=g[i])s[k].PB(0);\n\t\t\ts[k][g[i]]+=h;\n\t\t\th*=iv;\n\t\t}\n\t}\n\trep(i,s[0].size())rep(j,s[1].size()){\n\t\tk=i^j;\n\t\tif(k<s[2].size())ans+=s[0][i]*s[1][j]*s[2][k];\n\t}\n\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nstruct edge {\n    ll to, cost;\n};\n\nint V;\nvector<edge> Ga[200000], Gb[200000], Gc[200000];\nbool da0[200000], db0[200000], dc0[200000];\nbool da1[200000], db1[200000], dc1[200000];\n\nvoid addedgea(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    Ga[st].push_back(e);\n}\n\nvoid addedgeb(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    Gb[st].push_back(e);\n}\n\nvoid addedgec(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    Gc[st].push_back(e);\n}\n\nll N;\nll M1, M2, M3;\nvoid setvalue() {\n    PER(i, N - 1, -1) {\n        if (da0[i] == false) {\n            REP(j, 0, Ga[i].size()) {\n                edge e = Ga[i][j];\n                if (e.to < i && da0[e.to] == false) {\n                    da0[e.to] = true;\n                }\n            }\n        } else if (da0[i] == true && da1[i] == false) {\n            REP(j, 0, Ga[i].size()) {\n                edge e = Ga[i][j];\n                if (e.to < i && da1[e.to] == false) {\n                    da1[e.to] = true;\n                }\n            }\n        }\n    }\n    PER(i, N - 1, -1) {\n        if (db0[i] == false) {\n            REP(j, 0, Gb[i].size()) {\n                edge e = Gb[i][j];\n                if (e.to < i && db0[e.to] == false) {\n                    db0[e.to] = true;\n                }\n            }\n        } else if (db0[i] == true && db1[i] == false) {\n            REP(j, 0, Gb[i].size()) {\n                edge e = Gb[i][j];\n                if (e.to < i && db1[e.to] == false) {\n                    db1[e.to] = true;\n                }\n            }\n        }\n    }\n    PER(i, N - 1, -1) {\n        if (dc0[i] == false) {\n            REP(j, 0, Gc[i].size()) {\n                edge e = Gc[i][j];\n                if (e.to < i && dc0[e.to] == false) {\n                    dc0[e.to] = true;\n                }\n            }\n        } else if (dc0[i] == true && dc1[i] == false) {\n            REP(j, 0, Gc[i].size()) {\n                edge e = Gc[i][j];\n                if (e.to < i && dc1[e.to] == false) {\n                    dc1[e.to] = true;\n                }\n            }\n        }\n    }\n}\n\nll ten[2000000];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> M1;\n    ten[0] = 1;\n    REP(i, 1, 2000000) {\n        ten[i] = multiply(ten[i - 1], 10);\n    }\n    REP(i, 0, M1) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedgea(a, b, 0);\n        addedgea(b, a, 0);\n    }\n    cin >> M2;\n    REP(i, 0, M2) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedgeb(a, b, 0);\n        addedgeb(b, a, 0);\n    }\n    cin >> M3;\n    REP(i, 0, M3) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedgec(a, b, 0);\n        addedgec(b, a, 0);\n    }\n    // cout << \"aaa\" << endl;\n    setvalue();\n    // cout << \"bbb\" << endl;\n    ll azero = 0, bzero = 0, czero = 0;\n    ll aone = 0, bone = 0, cone = 0;\n    REP(i, 0, N) {\n        if (da0[i] == false) {\n            azero = modadd(azero, ten[18 * (i + 1)]);\n        } else if (da1[i] == false) {\n            aone = modadd(aone, ten[18 * (i + 1)]);\n        }\n        if (db0[i] == false) {\n            bzero = modadd(bzero, ten[18 * (i + 1)]);\n        } else if (db1[i] == false) {\n            bone = modadd(bone, ten[18 * (i + 1)]);\n        }\n        if (dc0[i] == false) {\n            czero = modadd(czero, ten[18 * (i + 1)]);\n        } else if (dc1[i] == false) {\n            cone = modadd(cone, ten[18 * (i + 1)]);\n        }\n    }\n    ll ans = 0;\n    ans = modadd(ans, multiply(azero, multiply(bzero, czero)));\n    ans = modadd(ans, multiply(aone, multiply(bone, czero)));\n    ans = modadd(ans, multiply(aone, multiply(bzero, cone)));\n    ans = modadd(ans, multiply(azero, multiply(bone, cone)));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct Problem {\n\n\tvoid Solve() {\n\t\tconst ULL M = 998244353;\n\t\tconst ULL Z = 1000000000000000000 % 998244353;\n\n\n\t\tUL N; cin >> N;\n\n\t\tvector<UL> POWZ(N + 1); POWZ[0] = 1;\n\t\trep(i, N) POWZ[i + 1] = POWZ[i] * Z % M;\n\t\tvector<ULL> A[3];\n\n\t\tvector<vector<UL>> E[3];\n\t\trep(t, 3) {\n\t\t\tUL S; cin >> S;\n\t\t\tvector<vector<UL>> E(N);\n\t\t\trep(j, S) {\n\t\t\t\tUL u, v; cin >> u >> v; u--; v--;\n\t\t\t\tE[u].push_back(v);\n\t\t\t\tE[v].push_back(u);\n\t\t\t}\n\t\t\tA[t].resize(min(N, 1024u));\n\t\t\tvector<UL> F(N);\n\t\t\tfor (UL v = N - 1; v != -1; v--) {\n\t\t\t\tA[t][F[v]] += POWZ[v + 1];\n\t\t\t\tA[t][F[v]] %= M;\n\t\t\t\tfor (UL e : E[v]) {\n\t\t\t\t\tif (F[e] == F[v]) F[e]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tULL ans = 0;\n\t\t{\n\t\t\trep(a, A[0].size()) rep(b, A[1].size()) {\n\t\t\t\tUL c = a ^ b; if (c >= A[2].size()) continue;\n\t\t\t\tans += A[0][a] * A[1][b] % M * A[2][c] % M;\n\t\t\t\tans %= M;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 110000;\nvi e[3][maxn];\nint gr[3][maxn];\n\nconst i64 P = 998244353, Q = 716070898;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n;\n    cin >> n;\n    vvi64 cnt(3, vi64(500));\n    forn(i, 3) {\n        int m;\n        cin >> m;\n        forn(j, m) {\n            int u, v;\n            cin >> u >> v;\n            --u; --v;\n            if (u > v) swap(u, v);\n            e[i][u].pb(v);\n        }\n\n        ford(j, n) {\n            vi used(e[i][j].size() + 1);\n            for (int k: e[i][j]) {\n                int x = gr[i][k];\n                if (x >= used.size()) continue;\n                used[x] = 1;\n            }\n            while (used[gr[i][j]]) ++gr[i][j];\n//            cerr << i << ' ' << j << ' ' << gr[i][j] << '\\n';\n        }\n        i64 z = Q;\n        forn(j, n) {\n            (cnt[i][gr[i][j]] += z) %= P;\n            (z *= Q) %= P;\n        }\n    }\n\n    i64 ans = 0;\n    forn(i, 500) forn(j, 500) {\n        if ((i ^ j) >= 500) continue;\n        ans += cnt[0][i] * cnt[1][j] % P * cnt[2][i ^ j];\n        ans %= P;\n    }\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC target (\"avx\")\n#pragma GCC target (\"avx2\")\n#pragma GCC target (\"fma\")\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppld pair <pld, pld>\n#define ppll pair <pll, pll>\n#define pldl pair <ld, ll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#define ordered_set tree <ll, null_type, less <ll>, rb_tree_tag, tree_order_statistics_node_update>\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\nll mod = 998244353;\nll m118;\nll p1018[100005];\nll nim[100005][3], a[100005][3];\nll val[8005][4];\nvll fwd[100005][3];\nll binpow(ll a, ll b){\n\tif (b == 0) return 1;\n\tll x = binpow(a, b / 2);\n\tx *= x; x %= mod;\n\tif (b % 2) return (x * a) % mod;\n\telse return x;\n}\nll bindiv(ll a, ll b){\n\tll inv = binpow(b, mod - 2);\n\treturn (a * inv) % mod;\n}\nint main(){\n\tfastio;\n\tm118 = 1e18; m118 %= mod;\n\tp1018[0] = 1;\n\tfor (ll i = 1; i < 100005; i++) p1018[i] = (p1018[i - 1] * m118) % mod;\n\tll n; cin >> n;\n\tll m[3];\n\tfor (ll i = 0; i < 3; i++){\n\t\tcin >> m[i];\n\t\tfor (ll j = 0; j < m[i]; j++){\n\t\t\tll u, v; cin >> u >> v; u--; v--;\n\t\t\tif (u > v) swap(u, v); fwd[u][i].pb(v);\n\t\t}\n\t}\n\tfor (ll i = 0; i < 3; i++){\n\t\tnim[n - 1][i] = 0;\n\t\tfor (ll j = n - 2; j >= 0; j--){\n\t\t\tset <ll> nms;\n\t\t\tfor (ll k = 0; k < fwd[j][i].size(); k++) nms.insert(nim[fwd[j][i][k]][i]);\n\t\t\tll mex = 0;\n\t\t\twhile (nms.count(mex)) mex++;\n\t\t\tnim[j][i] = mex;\n\t\t}\n\t}\n\tfor (ll i = 0; i < 3; i++) for (ll j = 0; j < n; j++) (val[nim[j][i]][i] += p1018[j + 1]) %= mod;\n\tfor (ll i = 0; i < 1005; i++){\n\t\tfor (ll j = 0; j < 1005; j++) (val[i ^ j][3] += (val[i][0] * val[j][1])) %= mod;\n\t}\n\tll ans = 0;\n\tfor (ll i = 0; i < 1005; i++) (ans += (val[i][3] * val[i][2])) %= mod;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n freopen(\"input\",\"r\",stdin);\n freopen(\"output\",\"w\",stdout);\n*/\n\nll MOD = 998244353;\n\nvector<vector<int>> A, B, C;\nvector<ll> X,Y,Z;\n\nint N, M;\n\nll power(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res *= a;\n            res %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nll cal(const unordered_set<int>& s) {\n    ll v = 0;\n    for (const int t : s) {\n        v += power(10, t * 18);\n        v %= MOD;\n    }\n    return v;\n}\n\nvector<ll> process(const vector<vector<int>>& x) {\n    unordered_set<int> u;\n    vector<ll> res;\n    set<int> rem;\n    for (int i = 1;i <= N;i++) rem.insert(-i);\n    for (int i = N;i > 0;i--) {\n        if (u.find(i) != u.end()) continue;\n        unordered_set<int> s;\n        s.insert(i);\n        u.insert(i);\n        unordered_set<int> r;\n        r.insert(i);\n        rem.erase(-i);\n        for (auto m : x[i]) r.insert(m);\n        for (int jj : rem) {\n            int j = -jj;\n            if (r.find(j) != r.end() || u.find(j) != u.end()) continue;\n            s.insert(j);\n            u.insert(j);\n            r.insert(j);\n            for (auto m : x[j]) r.insert(m);\n        }\n        for (int j : s) {\n            rem.erase(-j);\n        }\n        res.push_back(cal(s));\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> N;\n    A.resize(N+1);\n    B.resize(N+1);\n    C.resize(N+1);\n    int a, b;\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        A[a].push_back(b);\n        A[b].push_back(a);\n    }\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        B[a].push_back(b);\n        B[b].push_back(a);\n    }\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        C[a].push_back(b);\n        C[b].push_back(a);\n    }\n    X = process(A);\n    Y = process(B);\n    Z = process(C);\n    ll ans = 0;\n    vector<set<int>> yx(Y.size());\n    for (int i = 0;i < Y.size();i++) {\n        for (int j = 0;j < X.size();j++) yx[i].insert(j);\n    }\n    for (int i = 0;i < Z.size();i++) {\n        ll z = Z[i];\n        unordered_set<int> use;\n        for (int j = 0;j < Y.size();j++) {\n            ll y = z * Y[j];\n            y %= MOD;\n            for (int k : yx[j]) {\n                if (use.find(k) == use.end()) {\n                    use.insert(k);\n                    yx[j].erase(k);\n                    ans += (y * X[k]) % MOD;\n                    ans %= MOD;\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+10,mod=998244353,B=1e18;\nint n,ans,tmp=B%mod;\nstruct Graph{\n\tint m,cnt;\n\tint head[N],to[N],nxt[N],vis[N],sg[N],sum[N];\n\tvoid add(int u,int v){\n\t\tto[++cnt]=v,nxt[cnt]=head[u],head[u]=cnt;\n\t}\n\tvoid init(){\n\t\tscanf(\"%lld\",&m);\n\t\tfor(int i=1;i<=m;i++){ int u,v; scanf(\"%lld%lld\",&u,&v),add(min(u,v),max(u,v)); }\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tfor(int j=head[i];j;j=nxt[j]) vis[sg[to[j]]]=1;\n\t\t\twhile(vis[sg[i]]) sg[i]++;\n\t\t\tfor(int j=head[i];j;j=nxt[j]) vis[sg[to[j]]]=0; \n\t\t}\n\t\tfor(int i=1,mul=1;i<=n;i++) mul=mul*tmp%mod,sum[sg[i]]=(sum[sg[i]]+mul)%mod;\n\t}\n}G[3];\nsigned main(){\n\tscanf(\"%lld\",&n); \n\tfor(int i=0;i<3;i++) G[i].init();\n\tfor(int i=0;i<512;i++) for(int j=0;j<512;j++) ans=(ans+G[0].sum[i]*G[1].sum[j]%mod*G[2].sum[i^j]%mod)%mod;\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\nint N;\nint M[3];\nvector<int>G[3][100001];\nbool used[3][100001];\nLL gra[3][100001];\nLL ans[3][100001];\n\nLL MOD=998244353;\nLL MM(LL x){\n\tLL answer=1;\n\tLL now=10;\n\twhile(x!=0){\n\t\tif(x%2==1){\n\t\t\tanswer*=now;\n\t\t\tanswer%=MOD;\n\t\t}\n\t\tnow*=now;\n\t\tnow%=MOD;\n\t\tx/=2;\n\t}\n\treturn answer;\n}\n\nvoid calc(int x){\n\tfor(int i=N-1;i>=0;i--){\n\t\tint now=0;\n\t\tvector<int>v;\n\t\tREP(j,G[x][i].size()){\n\t\t\tif(G[x][i][j]>i){\n\t\t\t\tv.push_back(gra[x][G[x][i][j]]);\n\t\t\t}\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tREP(j,v.size()){\n\t\t\tif(v[j]==now)now++;\n\t\t}\n\t\tgra[x][i]=now;\n\t\tans[x][now]+=MM(18*(i+1));\n\t\tans[x][now]%=MOD;\n\t}\n}\n\n\n\nint main(){\n\tcin>>N;\n\tREP(i,3){\n\t\tcin>>M[i];\n\t\tREP(j,M[i]){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tG[i][a].push_back(b);\n\t\t\tG[i][b].push_back(a);\n\t\t}\n\t}\n\tREP(i,3){\n\t\tREP(j,N){\n\t\t\tused[i][j]=false;\n\t\t}\n\t}\n\tREP(i,3){\n\t\tcalc(i);\n\t}\n\t/*REP(i,3){\n\t\tREP(j,N){\n\t\t\tcout<<ans[i][j]<<endl;\n\t\t}\n\t\tcout<<endl;\n\t}*/\n\tLL answer=0;\n\tREP(i,401){\n\t\tREP(j,401){\n\t\t\tint now=i^j;\n\t\t\tLL temp=ans[0][i];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=ans[1][j];\n\t\t\ttemp%=MOD;\n\t\t\ttemp*=ans[2][now];\n\t\t\ttemp%=MOD;\n\t\t\t//LL temp=18*(ans[0][i]*ans[1][j]*ans[2][now]);\n\t\t\t/*if(temp!=0){\n\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<now<<\" \"<<temp<<endl;\n\t\t\t\tcout<<ans[0][i]<<\"ans \"<<ans[1][j]<<\" \"<<ans[2][now]<<\" \"<<temp<<endl;\n\t\t\t}*/\n\t\t\tanswer+=temp;\n\t\t\tanswer%=MOD;\n\t\t}\n\t}\n\tcout<<answer<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = 998244353;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 100 * 1000 + 13;\nconst int P = 4000;\n\nint n;\nvector<int> g[3][N];\n\nbool read(){\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\tforn(i, n) forn(j, 3)\n\t\tg[j][i].clear();\n\tforn(j, 3){\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tforn(i, m){\n\t\t\tint v, u;\n\t\t\tscanf(\"%d%d\", &v, &u);\n\t\t\t--v, --u;\n\t\t\tg[j][v].pb(u);\n\t\t\tg[j][u].pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * li(b) % MOD;\n}\n\nint gr[3][N];\nint cnt[3][P];\nint pw[N];\n\nint calc(int i, int v){\n\tif (gr[i][v] != -1)\n\t\treturn gr[i][v];\n\tvector<int> tmp;\n\tfor (auto u : g[i][v]) if (u > v)\n\t\ttmp.pb(calc(i, u));\n\tsort(all(tmp));\n\tforn(i, sz(tmp)) if (tmp[i] != i)\n\t\treturn gr[i][v] = i;\n\treturn gr[i][v] = sz(tmp);\n}\n\nvoid solve() {\n\tmemset(gr, -1, sizeof(gr));\n\tmemset(cnt, 0, sizeof(cnt));\n\tpw[0] = 1;\n\tpw[1] = INF64 % MOD;\n\tfore(i, 2, N) pw[i] = mul(pw[i - 1], pw[1]);\n\tforn(j, 3) forn(i, n) cnt[j][calc(j, i)] = add(cnt[j][calc(j, i)], pw[i + 1]);\n\tint ans = 0;\n\tforn(i, P) forn(j, P) if ((i ^ j) < P && cnt[0][i] && cnt[1][j] && cnt[2][i ^ j])\n\t\tans = add(ans, mul(mul(cnt[0][i], cnt[1][j]), cnt[2][i ^ j]));\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n#ifdef _DEBUG\n\twhile(read()) {\t\n#else\n\tif(read()) {\n#endif\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nlld arr[300000];\nvector<lld> adj[300000][3];\nar<lld,3> siz;\nlld grundy[300000][3];\nmap<lld,lld> sums[3];\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nvoid dfs_grundy(lld node,lld grp){\n    if (grundy[node][grp]!=-1)return ;\n    grundy[node][grp]=0;\n    vector<lld> mex;\n    //nums[0][grp]++;\n    for (auto it:adj[node][grp]){\n        if (it<node) continue;\n        dfs_grundy(it,grp);\n        mex.pb(grundy[it][grp]);\n    }\n    if (mex.empty()) {sums[grp][0]+=fastpower(10,18*(node+1),modd);sums[grp][0]%=modd;return;}\n    sort(all(mex));\n    rep(i,0,mex.size()-1){\n        if (i!=mex[i]){\n            grundy[node][grp]=i;\n        //    nums[0][grp]--;\n      //      nums[i][grp]++;\n            sums[grp][i]+=fastpower(10,18*(node+1),modd);sums[grp][i]%=modd;\n            return ;\n        }\n    }\n    grundy[node][grp]=mex.size();\n    //nums[0][grp]--;\n    //nums[mex.size()][grp]++;\n    sums[grp][mex.size()]+=fastpower(10,18*(node+1),modd);sums[grp][mex.size()]%=modd;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,r,k,c,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n//     ans=0;\n     //cin>>TESTS;\n     memset(grundy,-1,sizeof(grundy));\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(j,0,2){\n         cin>>siz[j];\n         rep(i,0,siz[j]-1){\n            cin>>a>>b;a--;b--;\n            adj[a][j].pb(b);\n            adj[b][j].pb(a);\n         }\n         }\n         rep(j,0,2) rep(i,0,n-1) dfs_grundy(i,j);\n         lld ans=0;\n         rep(i,0,sums[0].size()-1) rep(j,0,sums[1].size()-1) {\n            lld k=i^j;\n            if(k<sums[2].size())ans+=(((sums[0][i]*sums[1][j])%modd)*sums[2][k])%modd;\n            ans%=modd;\n         }\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\nconst num BASE(int64_t(1e18));\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nvoid slow() {\n\tint N; cin >> N;\n\tvector<vector<vector<int>>> adj(3, vector<vector<int>>(N));\n\tfor (int z = 0; z < 3; z++) {\n\t\tint M; cin >> M;\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tint u, v; cin >> u >> v; u--, v--;\n\t\t\tassert(u != v);\n\t\t\tif (u > v) swap(u, v);\n\t\t\tassert(u < v);\n\t\t\tadj[z][u].push_back(v);\n\t\t}\n\t}\n\tnum ans = 0;\n\tvector<vector<vector<bool>>> take(N, vector<vector<bool>>(N, vector<bool>(N, false)));\n\tfor (int s = 3*(N-1); s >= 0; s--) {\n\t\tfor (int x = 0; x < N; x++) {\n\t\t\tfor (int y = 0; y < N; y++) {\n\t\t\t\tint z = s-x-y;\n\t\t\t\tif (0 <= z && z < N) {\n\t\t\t\t\ttake[x][y][z] = true;\n\t\t\t\t\tfor (int x2 : adj[0][x]) {\n\t\t\t\t\t\tif (take[x2][y][z]) take[x][y][z] = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int y2 : adj[1][y]) {\n\t\t\t\t\t\tif (take[x][y2][z]) take[x][y][z] = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int z2 : adj[2][z]) {\n\t\t\t\t\t\tif (take[x][y][z2]) take[x][y][z] = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (take[x][y][z]) {\n\t\t\t\t\t\tcerr << x+1 << ' ' << y+1 << ' ' << z+1 << '\\n';\n\t\t\t\t\t\tans += pow(BASE, x+y+z+3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<num> cost(N);\n\tcost[0] = BASE;\n\tfor (int i = 1; i < N; i++) cost[i] = cost[i-1] * BASE;\n\n\tconst int LG = 17;\n\tconst int S = 1 << 17;\n\n\tvector<num> ans(S, 1);\n\n\tfor (int z = 0; z < 3; z++) {\n\t\tint M; cin >> M;\n\t\tvector<vector<int>> adj(N);\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tint u, v; cin >> u >> v; u--, v--;\n\t\t\tassert(u != v);\n\t\t\tif (u > v) swap(u, v);\n\t\t\tassert(u < v);\n\t\t\tadj[u].push_back(v);\n\t\t}\n\n\t\tvector<num> cnt(S);\n\t\tvector<int> nimber(N);\n\t\tfor (int i = N-1; i >= 0; i--) {\n\t\t\tset<int> s;\n\t\t\tfor (int j : adj[i]) {\n\t\t\t\ts.insert(nimber[j]);\n\t\t\t}\n\t\t\tnimber[i] = 0;\n\t\t\twhile (s.count(nimber[i])) nimber[i]++;\n\t\t\tcnt[nimber[i]] += cost[i];\n\t\t}\n\t\tfor (int l = 0; l < LG; l++) {\n\t\t\tfor (int m = 0; m < S; m++) {\n\t\t\t\tif (m & (1<<l)) continue;\n\t\t\t\tnum s = cnt[m | (1<<l)];\n\t\t\t\tnum a = cnt[m];\n\t\t\t\tcnt[m] = a+s;\n\t\t\t\tcnt[m|(1<<l)] = a-s;\n\t\t\t}\n\t\t}\n\n\t\tfor (int m = 0; m < S; m++) {\n\t\t\tans[m] *= cnt[m];\n\t\t}\n\t}\n\n\tfor (int l = 0; l < LG; l++) {\n\t\tfor (int m = 0; m < S; m++) {\n\t\t\tif (m & (1<<l)) continue;\n\t\t\tnum s = ans[m | (1<<l)];\n\t\t\tnum a = ans[m];\n\t\t\tans[m] = (a+s)/2;\n\t\t\tans[m|(1<<l)] = (a-s)/2;\n\t\t}\n\t}\n\n\n\tcout << ans[0] << '\\n';\n\n\treturn 0;\n}\n\n// sample2:\n// 3,31,32\n//\n// 3,3,3\n// 3,3,2\n// 2,2,3\n// 3,1,3\n// 2,2,2\n// 3,1,2\n// 3,2,1\n// 2,3,1\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=998244353;\nint n;\nll pw[100005];\n\nstruct node{\n\tint m;\n\tll sum[5];\n\tvector<int> adj[100005],f[5];\n\tbool vis[100005],now[100005];\n\tvoid get(){\n\t\tfor(int i=1;i<=3;i++){\n\t\t\tmemset(now,0,sizeof(now));\n\t\t\tfor(int j=n;j>=1;j--){\n\t\t\t\tif(vis[j]||now[j]) continue;\n\t\t\t\tvis[j]=1;\n\t\t\t\tf[i].pb(j);\n\t\t\t\tfor(auto v:adj[j]) if(v<j) now[v]=1;\n\t\t\t}\n\t\t}\n\t}\n}g[5];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nint main(){\n\tn=readint();\n\tint x,y;\n\tfor(int i=1;i<=3;i++){\n\t\tg[i].m=readint();\n\t\tfor(int j=1;j<=g[i].m;j++){\n\t\t\tx=readint(); y=readint();\n\t\t\tg[i].adj[x].pb(y),g[i].adj[y].pb(x);\n\t\t}\n\t\tg[i].get();\n\t}\n\tll base=1000000000000000000ll%cys;\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++) pw[i]=pw[i-1]*base%cys;\n\tfor(int i=1;i<=3;i++)\n\t\tfor(int j=1;j<=3;j++)\n\t\t\tfor(auto x:g[i].f[j])\n\t\t\t\tg[i].sum[j]=mod(g[i].sum[j]+pw[x]);\n\tll ans=g[1].sum[1]*g[2].sum[1]%cys*g[3].sum[1]%cys;\n\tans=(ans+g[1].sum[1]*g[2].sum[2]%cys*g[3].sum[2]%cys+g[1].sum[2]*g[2].sum[1]%cys*g[3].sum[2]%cys+g[1].sum[2]*g[2].sum[2]%cys*g[3].sum[1]%cys)%cys;\n\tans=(ans+g[1].sum[3]*g[2].sum[3]%cys*g[3].sum[3])%cys;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+3;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int P=1000000000000000000ll%M;\nconst int E=1<<17;\nvector <int> h[maxn];\nint sg[maxn],n,m,cnt[3][E],a[maxn],ans[maxn];\nbool f[maxn];\nvoid add(int &x,int y){\n    x+=y;if (x>=M)x-=M;\n}\nvoid FWT(int a[],int n){\n    for(int d=1;d<n;d<<=1)\n        for(int m=d<<1,i=0;i<n;i+=m)\n            for(int j=0;j<d;j++){\n                int x=a[i+j],y=a[i+j+d];\n                a[i+j]=(x+y)%M,a[i+j+d]=(x-y+M)%M;\n            }\n}\nvoid UFWT(int a[],int n){\n    for(int d=1;d<n;d<<=1)\n        for(int m=d<<1,i=0;i<n;i+=m)\n            for(int j=0;j<d;j++){\n                int x=a[i+j],y=a[i+j+d];\n                a[i+j]=1ll*(x+y)*inv2%M,a[i+j+d]=1ll*(x-y+M)*inv2%M;\n            }\n}\nint main(){\n    scanf(\"%d\",&n);\n    a[0]=1;\n    for (int i=1;i<=n;i++) a[i]=1ll*a[i-1]*P%M;\n    for (int i=0;i<3;i++){\n        scanf(\"%d\",&m);\n        for (int j=1;j<=n;j++) h[j].clear();\n        for (int j=0;j<m;j++){\n            int u,v;scanf(\"%d%d\",&u,&v);\n            if (u>v) swap(u,v);\n            h[u].pb(v);\n        }\n        for (int j=n;j;j--){\n            sg[j]=0;\n            for (auto v:h[j]) f[sg[v]]=1;\n            while (f[sg[j]]) sg[j]++;\n            for (auto v:h[j]) f[sg[v]]=0;\n            add(cnt[i][sg[j]],a[j]);\n        }\n        FWT(cnt[i],E);\n    }\n    for (int i=0;i<E;i++) ans[i]=1ll*cnt[0][i]*cnt[1][i]%M*cnt[2][i]%M;\n    UFWT(ans,E);\n    printf(\"%d\\n\",ans[0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Created by Nikolay Budin\n\n#ifdef DEBUG\n#  define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define ff first\n#define ss second\n#define szof(x) ((int)x.size())\n#ifndef LOCAL\n#  define cerr __get_ce\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef unsigned long long ull;\n\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename K, typename V> using ordered_map = tree<K, V, less<K>, rb_tree_tag, tree_order_statistics_node_update>;\n\nint const INF = (int)1e9 + 1e3;\nll const INFL = (ll)1e18 + 1e6;\n#ifdef LOCAL\n\tmt19937 tw(9450189);\n#else\n\tmt19937 tw(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\nuniform_int_distribution<ll> ll_distr;\nll rnd(ll a, ll b) { return ll_distr(tw) % (b - a + 1) + a; }\n\nconst int MOD = 998244353;\n\nvoid add(int& a, int b) {\n\ta += b;\n\tif (a >= MOD) {\n\t\ta -= MOD;\n\t}\n}\n\nint sum(int a, int b) {\n\tadd(a, b);\n\treturn a;\n}\n\nint mult(int a, int b) {\n\treturn (ll) a * b % MOD;\n}\n\nint mpow(int a, int b) {\n\tint ret = 1;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tret = mult(ret, a);\n\t\t}\n\t\ta = mult(a, a);\n\t\tb /= 2;\n\t}\n\treturn ret;\n}\n\nint inv(int n) {\n\treturn mpow(n, MOD - 2);\n}\n\nvoid transform(vector<int>::iterator from, vector<int>::iterator to) { \n    if (to - from == 1) \n        return;\n    auto mid = from + (to - from) / 2; \n    transform(from, mid); \n    transform(mid, to); \n    for(int i = 0; i < mid - from; i++) {\n        int a = *(from + i);\n        int b = *(mid + i);\n        *(from + i) = sum(a, b);\n        *(mid + i) = sum(a, MOD - b);\n    }\n} \n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\tint bpv = 1;\n\twhile (bpv < n) {\n\t\tbpv *= 2;\n\t}\n\tvector<vector<int>> arr(3, vector<int>(bpv));\n\tfor (int i = 0; i < 3; ++i) {\n\t\tint m;\n\t\tcin >> m;\n\t\tvector<vector<int>> graph(n);\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\t--a; --b;\n\t\t\tif (a > b) {\n\t\t\t\tswap(a, b);\n\t\t\t}\n\t\t\tgraph[a].push_back(b);\n\t\t}\n\n\t\tvector<int> take(n);\n\n\t\tfor (int j = n - 1; j >= 0; --j) {\n\t\t\tset<int> cur;\n\t\t\tfor (int to : graph[j]) {\n\t\t\t\tcur.insert(take[to]);\n\t\t\t}\n\t\t\twhile (cur.count(take[j])) {\n\t\t\t\t++take[j];\n\t\t\t}\n\t\t\tadd(arr[i][take[j]], mpow(10, 18 * (j + 1)));\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\t// add(ans, mult(mult(arr[0][0], arr[1][0]), arr[2][0]));\n\n\t// for (int i = 0; i < 3; ++i) {\n\t// \tfor (int j = 1; j < n; ++j) {\n\t// \t\tadd(ans, mult(arr[i][0], mult(arr[(i + 1) % 3][j], arr[(i + 2) % 3][j])));\n\t// \t}\n\t// }\n\n\t// for (int x = 0; x < n; ++x) {\n\t// \tfor (int y = 0; y < n; ++y) {\n\t// \t\tint z = x ^ y;\n\t// \t\tif (z < n) {\n\t// \t\t\tadd(ans, mult(arr[0][x], mult(arr[1][y], arr[2][z])));\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// for (int i = 0; i < 3; ++i) {\n\t// \tfor (int num : arr[0]) {\n\t// \t\tcerr << num << \" \";\n\t// \t}\n\t// \tcerr << endl;\n\t// }\n\n\ttransform(arr[0].begin(), arr[0].end());\n\ttransform(arr[1].begin(), arr[1].end());\n\n\tfor (int i = 0; i < bpv; ++i) {\n\t\tarr[0][i] = mult(arr[0][i], arr[1][i]);\n\t}\n\n\ttransform(arr[0].begin(), arr[0].end());\n\n\n\tint coef = inv(bpv);\n\tfor (int i = 0; i < bpv; ++i) {\n\t\tarr[0][i] = mult(arr[0][i], coef);\n\t}\n\t// for (int num : arr[0]) {\n\t// \tcerr << num << \" \";\n\t// }\n\t// cerr << endl;\n\n\tfor (int i = 0; i < bpv; ++i) {\n\t\tadd(ans, mult(arr[0][i], arr[2][i]));\n\t}\n\n\tcout << ans << \"\\n\";\n}\n\n\nint main() {\n#ifdef LOCAL\n\tauto start_time = clock();\n\tcerr << setprecision(3) << fixed;\n#endif\n\tcout << setprecision(15) << fixed;\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint test_count = 1;\n\t// cin >> test_count;\n\tfor (int test = 1; test <= test_count; ++test) {\n\t\tsolve();\n\t}\n\n#ifdef LOCAL\n\tauto end_time = clock();\n\tcerr << \"Execution time: \" << (end_time - start_time) * (int)1e3 / CLOCKS_PER_SEC << \" ms\\n\";\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e5+10, P = 998244353;\nint n, m, vis[N], sg[N], h[N], f[3][N];\nvector<int> g[N];\nvoid add(int &a, ll b) {a=(a+b)%P;}\n\nint main() {\n\th[0] = 1;\n\th[1] = 1000000000000000000ll%P;\n\tREP(i,2,N-1) h[i] = (ll)h[i-1]*h[1]%P;\n\tscanf(\"%d\", &n);\nint mx = 0;\n\tREP(i,0,2) {\n\t\tscanf(\"%d\", &m);\nmx = max(mx, (int)sqrt(m));\n\t\tREP(j,1,n) g[j].clear();\n\t\tREP(j,1,m) {\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif (u>v) swap(u,v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tPER(j,1,n) {\n\t\t\tint sz = g[j].size();\n\t\t\tREP(k,0,sz) vis[k] = 0;\n\t\t\tfor (int k:g[j]) vis[sg[k]] = 1;\n\t\t\tREP(k,0,sz) if (!vis[k]) {\n\t\t\t\tsg[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(f[i][sg[j]],h[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i,0,mx) REP(j,0,mx) {\n\t\tadd(ans, (ll)f[0][i]*f[1][j]%P*f[2][i^j]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    const auto& modpow = [](unsigned long n, unsigned long b = 1, unsigned long a = 716070898) -> unsigned long {\n        unsigned long r{b % MOD};\n        while(n){\n            if(n & 1)(r *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return r;\n    };\n    unsigned long N;\n    cin >> N;\n    vector<unsigned long> indpX, indpY, indpZ;\n    for(unsigned long _{0}; _ < 3; ++_){\n        swap(indpX, indpY);\n        swap(indpZ, indpY);\n        unsigned long M;\n        cin >> M;\n        vector<vector<unsigned long>> edge(N);\n        for(unsigned long i{0}, a, b; i < M; ++i){\n            cin >> a >> b;\n            if(a < b)swap(a, b);\n            edge[--a].push_back(--b);\n        }\n        vector<unsigned long> id(N, N - 1);\n        map<unsigned long, pair<unsigned long, unsigned long>> mp;\n        for(unsigned long i{N}; i--; ){\n            for(unsigned long j{N}; j--;){\n                if(id[j] == i){\n                    mp[i].first = max(mp[i].first, j + 1);\n                    (mp[i].second += modpow(j + 1)) %= MOD;\n                    for(const auto& k : edge[j])if(id[k] == i)id[k] = max(i, 1UL) - 1;\n                }\n            }\n        }\n        vector<pair<unsigned long, unsigned long>> Z;\n        for(const auto& i : mp)Z.emplace_back(i.second);\n        sort(Z.begin(), Z.end(), greater<>());\n        for(const auto& i : Z)indpZ.emplace_back(i.second);\n    }\n    /*for(const auto& i : indpX)cout << i << \" \";cout << endl;\n    for(const auto& i : indpY)cout << i << \" \";cout << endl;\n    for(const auto& i : indpZ)cout << i << \" \";cout << endl;*/\n    if(indpX.size() > indpZ.size())swap(indpX, indpZ);\n    if(indpY.size() > indpZ.size())swap(indpY, indpZ);\n    if(indpX.size() > indpY.size())swap(indpX, indpY);\n    unsigned long MX{indpX.size()}, MY{indpY.size()};\n    string al{string(500, '1')};\n    vector<bitset<500>> usedY(MY, bitset<500>(al));\n    unsigned long ans{0};\n    for(const auto& i : indpZ){\n        bitset<500> used{al};\n        unsigned long tmp{0};\n        for(unsigned long j{0}; j < MY; ++j){\n            unsigned long k{(usedY[j] & used)._Find_first()};\n            if(k < MX){\n                //cout << j << \" : \" << k << endl;\n                used[k] = false;\n                usedY[j][k] = false;\n                (tmp += indpY[j] * indpX[k] % MOD) %= MOD;\n            }\n        }\n        //cout << endl;\n        tmp %= MOD;\n        (ans += i * tmp % MOD) %= MOD;\n    }\n    cout << ans % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\n\nconst int N = 100100;\nll p[N];\nint n, m;\nvector<int> g[N];\nint used[N];\nll ans[3][2];\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tp[0] = 1;\n\tp[1] = bin_pow(10, 18);\n\tfor (int i = 2; i < N; i++)\n\t\tp[i] = mult(p[i - 1], p[1]);\n\n\tscanf(\"%d\", &n);\n\tfor (int it = 0; it < 3; it++) {\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tg[i].clear();\n\t\t\tused[i] = 0;\n\t\t}\n\t\tans[it][0] = ans[it][1] = 0;\n\t\tscanf(\"%d\", &m);\n\t\twhile(m--) {\n\t\t\tint v, u;\n\t\t\tscanf(\"%d%d\", &v, &u);\n\t\t\tif (v < u) swap(v, u);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tfor (int i = n; i > 0; i--) {\n\t\t\tint z = 0;\n\t\t\twhile(z < 2 && ((used[i] >> z) & 1)) z++;\n\t\t\tif (z == 2) continue;\n\t\t\tans[it][z ^ 1] = add(ans[it][z ^ 1], p[i]);\n\t\t\tfor (int v : g[i])\n\t\t\t\tused[v] |= 1 << z;\n\t\t}\n\t}\n\n\tll res = mult(ans[0][1], mult(ans[1][1], ans[2][1]));\n\tfor (int i = 0; i < 3; i++) {\n\t\tll cur = ans[i][1];\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tif (i != j)\n\t\t\t\tcur = mult(cur, ans[j][0]);\n\t\tres = add(res, cur);\n\t}\n\tprintf(\"%lld\\n\", res);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 1\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n// mint{{{\ntemplate <class ModType> struct modint {\n    using value_type = typename ModType::value_type;\n    using mint = modint<ModType>;\n    using mod_type = ModType;\n\n    static value_type mod() { return ModType::value; }\n\n    private:\n    static value_type inverse(value_type x) {\n        value_type y=1,u=mod(),v=0;\n        while(x){\n            value_type q=u/x;\n            u-=q*x; std::swap(x,u);\n            v-=q*y; std::swap(y,v);\n        }\n        assert(x==0 && std::abs(y)==mod() && std::abs(u)==1 && std::abs(v)<mod());\n        return v<0?v+mod():v;\n    }\n\n    public:\n    // the member variable\n    value_type value;\n\n    // constructors\n    modint()=default;\n    modint(modint const&)=default;\n    modint(modint&&)=default;\n    modint& operator=(modint const&)=default;\n    modint& operator=(modint&&)=default;\n    ~modint()=default;\n\n    template <class T> modint(T t) : value([t] () mutable {\n            if ( t <= -static_cast<T>(mod()) || static_cast<T>(mod()) <= t ) t %= mod();\n            return t < 0 ? t + mod() : t;\n            }()) {}\n\n    // operators\n    mint& operator+= (mint y) {\n        value += y.value;\n        if (mod() <= value) value -= mod();\n        return *this;\n    }\n\n    mint& operator-= (mint y) {\n        value -= y.value;\n        if ( value < 0 ) value += mod();\n        return *this;\n    }\n\n    mint& operator*= (mint y) {\n        value = (long long)value * y.value % mod();\n        return *this;\n    }\n\n    mint& operator/= (mint y) {\n        value = (long long)value * inverse(y.value) % mod();\n        return *this;\n    }\n\n    mint& operator++() { return *this+=1; }\n    mint& operator--() { return *this-=1; }\n    mint  operator++(int) { mint this_=*this; ++*this; return this_; }\n    mint  operator--(int) { mint this_=*this; --*this; return this_; }\n\n    // static member functions\n    static mint inv(mint x) { return inverse(x.value); }\n\n    static mint m1pow(long long y) { return y%2?-1:1; }\n\n    static mint pow(mint x, unsigned long long y) {\n        mint ans=1;\n        for(;y;y>>=1){\n            if(y&1ull) ans*=x;\n            x*=x;\n        }\n        return ans;\n    }\n\n    // non-member functions\n    mint& add_assign(mint y) { return *this+=y; }\n    mint& sub_assign(mint y) { return *this-=y; }\n    mint& mul_assign(mint y) { return *this*=y; }\n    mint& div_assign(mint y) { return *this/=y; }\n    mint& inv_assign()       { return *this = inv(*this); }\n    mint& pow_assign(unsigned long long y){ return *this = pow(*this, y); }\n\n    mint add(mint y) { mint ans=*this; return ans.add_assign(y); }\n    mint sub(mint y) { mint ans=*this; return ans.sub_assign(y); }\n    mint mul(mint y) { mint ans=*this; return ans.mul_assign(y); }\n    mint div(mint y) { mint ans=*this; return ans.div_assign(y); }\n    mint inv()       { mint ans=*this; return ans.inv_assign(); }\n    mint pow(unsigned long long y) { return pow(*this, y); }\n\n    template <class F> mint map(F const& f){\n        value=f(value);\n        return *this;\n    }\n};\n\n    template <class T> std::istream&\noperator>>(std::istream& is, modint<T>& x)\n{\n    typename modint<T>::value_type y;\n    is >> y;\n    x = modint<T>{ y };\n    return is;\n}\n    template <class T> std::ostream&\noperator<<(std::ostream& os, modint<T> x)\n{\n    return os << x.value;\n}\n\ntemplate <class T> modint<T> operator+(modint<T> x, modint<T> y) { return x+=y; }\ntemplate <class T> modint<T> operator-(modint<T> x, modint<T> y) { return x-=y; }\ntemplate <class T> modint<T> operator*(modint<T> x, modint<T> y) { return x*=y; }\ntemplate <class T> modint<T> operator/(modint<T> x, modint<T> y) { return x/=y; }\ntemplate <class T> bool operator==(modint<T> x, modint<T> y) { return x.value==y.value; }\ntemplate <class T> bool operator!=(modint<T> x, modint<T> y) { return x.value!=y.value; }\n\ntemplate <class T, class U> modint<T> operator+(modint<T> x, U y) { return x+modint<T>(y); }\ntemplate <class T, class U> modint<T> operator-(modint<T> x, U y) { return x-modint<T>(y); }\ntemplate <class T, class U> modint<T> operator*(modint<T> x, U y) { return x*modint<T>(y); }\ntemplate <class T, class U> modint<T> operator/(modint<T> x, U y) { return x/modint<T>(y); }\ntemplate <class T, class U> bool operator==(modint<T> x, U y) { return x==modint<T>(y); }\ntemplate <class T, class U> bool operator!=(modint<T> x, U y) { return x!=modint<T>(y); }\n\ntemplate <class T, class U> modint<T> operator+(U x, modint<T> y) { return modint<T>(x)+y; }\ntemplate <class T, class U> modint<T> operator-(U x, modint<T> y) { return modint<T>(x)-y; }\ntemplate <class T, class U> modint<T> operator*(U x, modint<T> y) { return modint<T>(x)*y; }\ntemplate <class T, class U> modint<T> operator/(U x, modint<T> y) { return modint<T>(x)/y; }\ntemplate <class T, class U> bool operator==(U x, modint<T> y) { return modint<T>(x)==y; }\ntemplate <class T, class U> bool operator!=(U x, modint<T> y) { return modint<T>(x)!=y; }\n/*}}}*/\nusing mint = modint<std::integral_constant<i32, 998244353>>;\n// fact{{{\nstruct factorials {\n    std::vector<mint> fact, finv;\n\n    factorials(usize n)\n        : fact(n, 1), finv(n)\n    {\n        for(usize i=1;i<n;i++){\n            fact.at(i) = fact.at(i-1) * i;\n        }\n\n        finv.at(n-1) = fact.at(n-1).inv();\n        for(usize i=n-1; i; i--){\n            finv.at(i-1) = finv.at(i) * i;\n        }\n    }\n\n    std::size_t size() const { return fact.size(); }\n    std::size_t max() const { return fact.size() - 1; }\n\n    mint at(std::size_t i) const { return fact.at(i); }\n    mint inv(std::size_t i) const { return finv.at(i); }\n\n    template <\n        class T, class U,\n        std::enable_if_t< std::is_integral<T>::value && std::is_integral<U>::value, int> = 0\n    >\n    mint binom(T n, U k) {\n        assert(0<=n);\n        if (k<0||n<k) return 0;\n        assert(k<=n && static_cast<usize>(n)<size());\n        return fact.at(n) * finv.at(k) * finv.at(n-k);\n    }\n\n    template <\n        class T, class U,\n        std::enable_if_t< std::is_integral<T>::value && std::is_integral<U>::value, int> = 0\n    >\n    mint deal(T n, U k) {\n        if (n==0 && k==0) return 1;\n        return binom(n+k-1, k-1);\n    }\n};\n/*}}}*/\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    i32 n;\n    std::cin >> n;\n    vec<vec<mint>> f(3);\n\n    mint unit_weight = mint{10}.pow(18);\n    mint initial_weight = unit_weight.pow(n);\n    mint weight_decrease = unit_weight.inv();\n\n    for (usize t=0; t<3; t++) {\n        usize m;\n        std::cin >> m;\n        vec<vec<usize>> g(n);\n        while (m--) {\n            usize u, v;\n            std::cin >> u >> v;\n            u--, v--;\n            if (u>v) std::swap(u, v);\n            g.at(u).push_back(v);\n        }\n\n        mint coeff = initial_weight;\n        vec<usize> grundy(n), ckd(n,n);\n        for (usize i=n-1; i!=-1; i--, coeff*=weight_decrease) {\n            for (usize j: g.at(i)) {\n                ckd.at(grundy.at(j)) = i;\n            }\n            while (ckd.at(grundy.at(i))==i) grundy.at(i)++;\n            while (f.at(t).size() <= grundy.at(i)) f.at(t).emplace_back();\n            f.at(t).at(grundy.at(i)) += coeff;\n        }\n    }\n\n    mint ans = 0;\n    for (usize i=0; i<f.at(0).size(); i++) for (usize j=0; j<f.at(1).size(); j++) {\n        usize k=i^j;\n        if (f.at(2).size()<=k) continue;\n        ans += f.at(0).at(i) * f.at(1).at(j) * f.at(2).at(k);\n    }\n    std::cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int W = 716070898, P = 998244353, I2 = 499122177;\n\nvoid add(int&x , int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int N;\n  cin >> N;\n  vector<int> pw(N);\n  pw[0] = 1;\n  for (int i = 1; i < N; ++i) pw[i] = pw[i - 1] * (ll)W % P;\n  int l = 0;\n  while ((1 << l) < N) ++l;\n  vector<int> SG1, SG2, SG3;\n  auto getSG = [&]() {\n    vector<int> ret(N);\n    int M;\n    cin >> M;\n    vector<vector<int>> G(N);\n    while (M--) {\n      int u, v;\n      cin >> u >> v;\n      --u; --v;\n      if (u > v) swap(u, v);\n      G[u].push_back(v);\n    }\n    for (int i = N - 1; i >= 0; --i) {\n      vector<bool> vis(G[i].size() + 1);\n      for (int v : G[i])\n        vis[ret[v]] = true;\n      while (vis[ret[i]]) ++ret[i];\n    }\n    return ret;\n  };\n  SG1 = getSG();\n  SG2 = getSG();\n  SG3 = getSG();\n  auto toWt = [&](const vector<int>& SG) {\n    vector<int> ret(1 << l);\n    for (int i = 0; i < N; ++i)\n      add(ret[SG[i]], pw[i]);\n    return ret;\n  };\n  auto A1 = toWt(SG1), A2 = toWt(SG2), A3 = toWt(SG3);\n  auto FWT = [&](vector<int>& A) -> void {\n    for (int i = 0; i < l; ++i)\n      for (int j = 0; j < (1 << l); ++j)\n        if (!((j >> i) & 1)) {\n          int a0 = A[j], a1 = A[j ^ (1 << i)];\n          A[j] = (a0 + a1) % P;\n          A[j ^ (1 << i)] = (a0 - a1 + P) % P;\n        }\n  };\n  FWT(A1);\n  FWT(A2);\n  FWT(A3);\n  for (int i = 0; i < (1 << l); ++i)\n    A1[i] = A1[i] * (ll)A2[i] % P * A3[i] % P;\n  FWT(A1);\n  int ans = A1[0] * (ll)W % P * W % P * W % P;\n  for (int i = 0; i < l; ++i)\n    ans = ans * (ll)I2 % P;\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define ff first\n#define ss second\n#define pii pair<int, int>\n#define pb emplace_back\n#define pf emplace_front\n#define mp make_pair\n#define ld long double\n#define all(x) x.begin(), x.end()\n#define uniq(x) sort(all(x)), x.resize(unique(all(x)) - x.begin())\n\n//random_device rd;\n//mt19937_64 gen(rd());\n//\n//template<typename T>\n//T rand(T l, T r) {\n//    uniform_int_distribution<T> uid(l, r);\n//    return uid(gen);\n//}\n\nconst int maxn = 1e5 + 9;\nvector<int> g[3][maxn];\nint c[3][maxn];\nint n;\nint mod = 998244353;\nint p[maxn];\nvector<int> w[3];\nint ans;\n\nsigned main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    p[0] = 1;\n    p[1] = ((int)1e18) % mod;\n    for (int i = 2; i < maxn; i++)\n        p[i] = (p[i - 1] * p[1]) % mod;\n    cin >> n;\n    for (int j = 0; j < 3; j++)\n    {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++)\n        {\n            int a, b;\n            cin >> a >> b;\n            a--, b--;\n            g[j][a].pb(b);\n            g[j][b].pb(a);\n        }\n        int kek = 0;\n        int t = 0;\n        while (kek != n)\n        {\n            t++;\n            for (int i = n - 1; i >= 0; i--)\n            {\n                if (c[j][i])\n                    continue;\n                bool fl = 0;\n                for (int to : g[j][i])\n                {\n                    if (c[j][to] == t)\n                        fl = 1;\n                }\n                if (!fl)\n                {\n                    c[j][i] = t;\n                    if (w[j].size() < t + 1)\n                        w[j].resize(t + 1, 0);\n                    w[j][t] = (w[j][t] + p[i + 1]) % mod;\n                    kek++;\n                }\n            }\n        }\n//        for (int i = 0; i < n; i++)\n//            cout << c[j][i] << \" \";\n//        cout << \"\\n\";\n    }\n    vector<vector<int> > q;\n    for (int a = 0; a < 3; a++)\n        for (int b = 0; b < 3; b++)\n            for (int c = 0; c < 3; c++)\n    {\n        if (a != b && b != c && a != c)\n        {\n            vector<int> cur = {a, b, c};\n            q.pb(cur);\n        }\n    }\n    set<pii> used;\n    int sz = max(max(w[0].size(), w[1].size()), w[2].size());\n    for (int a = 1; a < sz; a++)\n    {\n        for (int b = 1; b <= a; b++)\n        {\n            for (int c = 1; c <= b; c++)\n            {\n                if (used.find(mp(a, b)) != used.end())\n                    continue;\n                if (used.find(mp(a, c)) != used.end())\n                    continue;\n                if (used.find(mp(b, c)) != used.end())\n                    continue;\n\n                set<vector<int> > U;\n                bool fl = 0;\n                for (auto u : q)\n                {\n                    vector<int> polina;\n                    for (int r = 0; r < 3; r++)\n                    {\n                        if (u[r] == 0)\n                            polina.pb(a);\n                        else if (u[r] == 1)\n                            polina.pb(b);\n                        else\n                            polina.pb(c);\n                    }\n                    if (U.find(polina) != U.end())\n                        continue;\n                    U.insert(polina);\n                    int cur = 1;\n                    bool fll = 1;\n\n                    if ((int)w[0].size() > polina[0])\n                        cur = (cur * w[0][polina[0]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[1].size() > polina[1])\n                        cur = (cur * w[1][polina[1]]) % mod;\n                    else\n                        fll = 0;\n\n                    if ((int)w[2].size() > polina[2])\n                        cur = (cur * w[2][polina[2]]) % mod;\n                    else\n                        fll = 0;\n\n                    if (fll)\n                    {\n                        ans = (ans + cur) % mod;\n                        fl = 1;\n                    }\n                }\n                if (fl)\n                {\n//                    cout << a << \" \" << b << \" \" << c << \"\\n\";\n                    used.emplace(a, b);\n                    used.emplace(a, c);\n                    used.emplace(b, c);\n                }\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nll pw[1010101],cac[4][1010101];\nint n,m,sg[1010101],vis[1010101];\nvector<int> e[1010101];\ninline void solve(int id){\n\tfor (int i=1;i<=n;i++) e[i].clear(),sg[i]=vis[i]=0;\n\tm=read();\n\tfor (int i=1;i<=m;i++){\n\t\tint x=read(),y=read();\n\t\te[min(x,y)].push_back(max(x,y));\n\t}\n\tfor (int i=n;i;i--){\n\t\tfor (auto v:e[i]) vis[sg[v]]=1;\n\t\twhile (vis[sg[i]]) sg[i]++;\n\t\tfor (auto v:e[i]) vis[sg[v]]=0;\n\t\tcac[id][sg[i]]=(cac[id][sg[i]]+pw[i])%ljc;\n\t}\n}\nsigned main(){\n\tn=read();\n\tpw[0]=1,pw[1]=1000000000000000000%ljc;\n\tfor (int i=2;i<=n;i++) pw[i]=pw[i-1]*pw[1]%ljc;\n\tsolve(1);\n\tsolve(2);\n\tsolve(3);\n\tll _=0;\n\tfor (int i=0;i<=1000;i++)\n\t\tfor (int j=0;j<=1000;j++) _=(_+cac[1][i]*cac[2][j]%ljc*cac[3][i^j]%ljc)%ljc;\n\tcout<<_;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\nconst int N=3e5+5;\nvector<int> g[N];\nint x[N];\nconst int M=998244353;\nconst int P=((ll)(1e18))%M;\nint p[N];\nvector<int> c[3];\n\nint32_t main(){\n    p[0]=1;\n    for(int i=1;i<N;++i)p[i]=(p[i-1]*P)%M;\n    int n;\n    cin>>n;\n    forn(t,3){\n        int m;\n        cin>>m;\n        for(int i=1;i<=n;++i)g[i].clear();\n        forn(i,m){\n            int a,b;\n            cin>>a>>b;\n            if(a>b)swap(a,b);\n            g[a].pb(b);\n        }\n        for(int i=n;i>=1;--i){\n            vector<int> go;\n            for(int to:g[i])go.pb(x[to]);\n            sort(go.begin(), go.end());\n            go.resize(unique(go.begin(), go.end())-go.begin());\n            x[i]=go.size();\n            forn(j,go.size()){\n                if(go[j]!=j){\n                    x[i]=j;\n                    break;\n                }\n            }\n            if(x[i]>=c[t].size())c[t].resize(x[i]+1,0);\n            (c[t][x[i]]+=p[i])%=M;\n        }\n    }\n    int ans=0;\n    forn(i,c[0].size()){\n        forn(j,c[1].size()){\n            int k=i^j;\n            if(k<c[2].size()){\n                int cur=c[0][i]*c[1][j]%M;\n                (cur*=c[2][k])%=M;\n                if((ans+=cur)>=M)ans-=M;\n            }\n        }\n    }\n    cout<<ans<<'\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int mxk = 1e5 + 7, mod = 998244353;\n\nint n, m; long long base = 1e18;\n\nstruct node {\n\tint nxt, to;\n} edge[mxk << 1];\n\nint tot = 0, head[mxk];\n\nvoid addedge(int u, int v) {edge[++tot].to = v; edge[tot].nxt = head[u]; head[u] = tot;}\n\nlong long sg[mxk], len = 9; long long cnt1[mxk], cnt2[mxk], cnt3[mxk], pwr[mxk], ans[mxk];\nbool vis[mxk];\n\nint main() {\n\tcin >> n; base = base % mod;\n\tpwr[0] = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tpwr[i] = pwr[i - 1] * base % mod;\n\t\t\n\ttot = 0; memset(head, 0, sizeof(head)); cin >> m;\n\tfor(int i = 1; i <= m; ++i)\t{ int u, v; cin >> u >> v; \n\t\t\tif(u > v) swap(u, v); addedge(u, v); }\n\tmemset(sg, 0, sizeof(sg)); memset(vis, 0, sizeof(vis));\n\tcnt1[0] = (cnt1[0] + pwr[n]) % mod;\n\tfor(int u = n - 1; u >= 1; --u) {\n\t\tfor(int i = head[u]; i; i = edge[i].nxt)\n\t\t\tvis[sg[edge[i].to]] = 1;\n\t\tint ptr = 0; while(vis[ptr]) ++ptr;\n\t\tsg[u] = ptr; cnt1[ptr] = (cnt1[ptr] + pwr[u]) % mod;\n\t\tfor(int i = head[u]; i; i = edge[i].nxt)\n\t\t\tvis[sg[edge[i].to]] = 0;\n\t}\t\n\t\n\ttot = 0; memset(head, 0, sizeof(head)); cin >> m;\n\tfor(int i = 1; i <= m; ++i)\t{ int u, v; cin >> u >> v; \n\t\t\tif(u > v) swap(u, v); addedge(u, v); }\n\tmemset(sg, 0, sizeof(sg)); memset(vis, 0, sizeof(vis));\n\tcnt2[0] = (cnt2[0] + pwr[n]) % mod;\n\tfor(int u = n - 1; u >= 1; --u) {\n\t\tfor(int i = head[u]; i; i = edge[i].nxt)\n\t\t\tvis[sg[edge[i].to]] = 1;\n\t\tint ptr = 0; while(vis[ptr]) ++ptr;\n\t\tsg[u] = ptr; cnt2[ptr] = (cnt2[ptr] + pwr[u]) % mod;\n\t\tfor(int i = head[u]; i; i = edge[i].nxt)\n\t\t\tvis[sg[edge[i].to]] = 0;\n\t}\t\t\n\t\n\ttot = 0; memset(head, 0, sizeof(head)); cin >> m;\n\tfor(int i = 1; i <= m; ++i)\t{ int u, v; cin >> u >> v; \n\t\t\tif(u > v) swap(u, v); addedge(u, v); }\n\tmemset(sg, 0, sizeof(sg)); memset(vis, 0, sizeof(vis));\n\tcnt3[0] = (cnt3[0] + pwr[n]) % mod;\n\tfor(int u = n - 1; u >= 1; --u) {\n\t\tfor(int i = head[u]; i; i = edge[i].nxt)\n\t\t\tvis[sg[edge[i].to]] = 1;\n\t\tint ptr = 0; while(vis[ptr]) ++ptr;\n\t\tsg[u] = ptr; cnt3[ptr] = (cnt3[ptr] + pwr[u]) % mod;\n\t\tfor(int i = head[u]; i; i = edge[i].nxt)\n\t\t\tvis[sg[edge[i].to]] = 0;\n\t}\t\n\tfor(int i = 0; i < (1 << 9); ++i)\n\t\tfor(int j = 0; j < (1 << 9); ++j)\n\t\t\tans[i ^ j] = (ans[i ^ j] + cnt1[i] * cnt2[j] % mod) % mod;\n\tmemcpy(cnt1, ans, sizeof(ans));\n\tmemset(ans, 0, sizeof(ans));\n\tfor(int i = 0; i < (1 << 9); ++i)\n\t\tfor(int j = 0; j < (1 << 9); ++j)\n\t\t\tans[i ^ j] = (ans[i ^ j] + cnt1[i] * cnt3[j] % mod) % mod;\n\t\n\tcout << ans[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#define mod 998244353\n#define inv2 499122177\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100005;\ninline int readint()\n{\n\tint res = 0, f = 1;\n\tchar c = 0;\n\twhile(!isdigit(c))\n\t{\n\t\tc = getchar();\n\t\tif(c=='-')\n\t\t\tf = -1;\n\t}\n\twhile(isdigit(c))\n\t\tres = res*10+c-'0', c = getchar();\n\treturn res*f;\n}\ninline ll qpow(ll a, int b)\n{\n\tll res = 1;\n\tfor(; b; a = a*a%mod, b >>= 1)\n\t    if(b&1)\n\t        res = res*a%mod;\n\treturn res;\n}\nstruct Node\n{\n\tint u,v;\n\tNode *next;\n}pool[MAXN<<3],*h[4][MAXN];\nint n,m[4],deg[4][MAXN],tot;\ninline void addEdge(int id, int u, int v)\n{\n\tNode *p = &pool[++tot];\n    p->v = v, p->next = h[id][u], h[id][u] = p;\n    deg[id][v]++;\n}\nint sg[4][MAXN];\nll f[4][270005];\nvector<int> num[4][MAXN];\ninline void calc(int id, int u)\n{\n\tif(sg[id][u]>=0)\n\t    return;\n\tsg[id][u] = 0;\n\tfor(Node *p = h[id][u]; p; p = p->next)\n\t{\n        calc(id,p->v);\n        num[id][u].push_back(sg[id][p->v]);\n\t}\n\tsort(num[id][u].begin(),num[id][u].end());\n\tfor(int i = 0; i<num[id][u].size(); i++)\n\t    if(sg[id][u]==num[id][u][i])\n\t        sg[id][u]++;\n}\ninline void fwt(ll *a, int deg)\n{\n\tll u,t;\n\tfor(int i = 1; i<deg; i <<= 1)\n\t    for(int j = 0; j<deg; j += i<<1)\n\t        for(int k = j; k<j+i; k++)\n\t        {\n\t            u = a[k], t = a[k+i];\n\t            a[k] = (u+t)%mod, a[k+i] = (u-t+mod)%mod;\n\t\t\t}\n}\ninline void ifwt(ll *a, int deg)\n{\n    ll u,t;\n\tfor(int i = 1; i<deg; i <<= 1)\n\t    for(int j = 0; j<deg; j += i<<1)\n\t\t    for(int k = j; k<j+i; k++)\n\t\t\t{\n\t            u = a[k], t = a[k+i];\n\t            a[k] = (u+t)*inv2%mod, a[k+i] = (u-t+mod)*inv2%mod;\n\t\t\t}\n}\n\nint main()\n{\n    n = readint();\n    for(int i = 1; i<=3; i++)\n    {\n        m[i] = readint();\n        for(int j = 1; j<=m[i]; j++)\n        {\n            int u = readint(), v = readint();\n            addEdge(i,min(u,v),max(u,v)); \n\t\t}\n\t}\n\tmemset(sg,-1,sizeof(sg));\n\tfor(int i = 1; i<=3; i++)\n\t    for(int j = 1; j<=n; j++)\n\t\t    if(!deg[i][j])\n\t\t\t    calc(i,j);\n\tfor(int i = 1; i<=3; i++)\n        for(int j = 1; j<=n; j++)\n\t\t\tf[i][sg[i][j]] += qpow(qpow(10,18),j);\n\tfor(int i = 1; i<=3; i++)\n        fwt(f[i],262144);\n    for(int i = 0; i<262144; i++)\n        f[1][i] = f[1][i]*f[2][i]%mod*f[3][i]%mod;\n    ifwt(f[1],262144);\n    cout << f[1][0] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll a, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nconst int max_n = 10000;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\nmodint t10[1 << 22];\nvoid init() {\n\tt10[0] = 1;\n\trep(i, (1 << 22)-1) {\n\t\tt10[i + 1] = t10[i] * (modint)10;\n\t}\n}\n\nint mex(vector<int> &v) {\n\tsort(all(v));\n\tv.erase(unique(all(v)), v.end());\n\trep(i, v.size())if (i != v[i])return i;\n\treturn v.size();\n}\nvector<int> G[3][1 << 17];\nint grandy[3][1 << 17];\nmodint sum[3][500];\nvoid solve() {\n\tinit();\n\tint n; cin >> n;\n\trep(t, 3) {\n\t\tint m; cin >> m;\n\t\trep(i, m) {\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tG[t][b].push_back(a);\n\t\t\tG[t][a].push_back(b);\n\t\t}\n\t\tper(i, n) {\n\t\t\tvector<int> v;\n\t\t\tfor (int to : G[t][i]) {\n\t\t\t\tif (to > i) {\n\t\t\t\t\tv.push_back(grandy[t][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrandy[t][i] = mex(v);\n\t\t\tsum[t][grandy[t][i]] += t10[18*(i+1)];\n\t\t}\n\t}\n\tmodint ans = 0;\n\trep(i, 500)rep(j, 500)rep(k, 500) {\n\t\tint x = i ^ j^k;\n\t\tif (x == 0) {\n\t\t\tans += sum[0][i] * sum[1][j] * sum[2][k];\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\t//init_f();\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\n#define P 998244353\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nll perm(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (fac[n]*finv[n-k])%P;\n}\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\n\ntypedef vector<vector<ll>> graph;\nll n;\n\nstruct Merge{\n  set<vll> lr;\n  ll INF = 1000000000000000009;\n  vll remove(ll a, ll b){\n    if(a>b) swap(a, b);\n    auto itr = lr.lower_bound(vll{b+1, 0});\n    if(itr==lr.begin()) return vll{a, b};\n    itr--;\n    ll lef = a, ri = b;\n    while((*itr)[1]>=a){\n      ll now_x = (*itr)[0], now_y = (*itr)[1];\n      lef = min(lef, now_x), ri = max(ri, now_y);\n      if(itr==lr.begin()){\n        lr.erase(itr);\n        break;\n      }\n      itr--;\n      lr.erase(vll{now_x, now_y});\n    }\n    return vll{lef, ri};\n  }\n  void merge(ll a, ll b){lr.insert(remove(a, b));}\n\n  vll get(ll a){\n    auto itr = lr.lower_bound(vll{a+1, a+1});\n    if(lr.size()==0||itr==lr.begin()) return vll{INF, INF};\n    itr--;\n    if((*itr)[1]<a) return vll{INF, INF};\n    return *itr;\n  }\n  bool same(ll a, ll b){\n    if(get(a)[0]==-1) return false;\n    return get(a)[0]==get(b)[0];\n  }\n};\n\nvvl get(graph g){\n  //なるべく大きい要素を取る独立集合\n  //現在とったものに隣接していない最大の要素を貪欲に取っていく\n  vvl dat;\n  vll go(n+1, 10000000);\n\n  for(int i=n;i>0;i--){\n    Merge mg;\n    for(auto to:g[i]){\n      if(to<i) continue;\n      mg.merge(go[to], go[to]+1);\n    }\n    auto itr = mg.lr.begin();\n    if(mg.lr.size()==0||(*itr)[0]!=0) go[i] = 0;\n    else go[i] = (*itr)[1];\n\n    if(dat.size()<=go[i]) dat.push_back(vll());\n    dat[go[i]].push_back(i);\n  }\n  return dat;\n}\n\nvector<ll> cost(400000, 1);\n\n\n//独立集合の重み\nll get_cost(vll v){\n  ll ret = 0;\n  for(int i=0;i<v.size();i++) ret = (ret + cost[v[i]])%P;\n  return ret;\n}\n\nint main(int argc, char const *argv[]) {\n  init();\n  ll x = 1000000000000000000LL%P;\n  for(int i=1;i<400000;i++) cost[i] = (cost[i-1] * x)%P;\n\n  std::cin >> n;\n  vvl d = VV(3, 0, 0, ll);\n  for(int i=0;i<3;i++){\n    ll m;std::cin >> m;\n    graph g(n+1);\n    for(int j=0;j<m;j++){\n      ll a, b;scanf(\"%lld %lld\", &a, &b);\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n    vvl X = get(g);\n    /*\n    std::cout << \"---\" << '\\n';\n    for(int j=0;j<X.size();j++) {\n      for(auto v:X[j]){\n        std::cout << v << \" \";\n      }\n      std::cout << '\\n';\n    }\n    */\n    for(int j=0;j<X.size();j++) {\n      d[i].push_back(get_cost(X[j]));\n    }\n  }\n  ll ans = pp(pp(d[0][0], d[1][0]), d[2][0]);\n\n  //0\n  for(int j=1;j<n;j++){\n    if(j>=d[1].size()||j>=d[2].size()) break;\n    ans = (ans + pp(d[0][0], pp(d[1][j], d[2][j])))%P;\n  }\n  //1\n  for(int j=1;j<n;j++){\n    if(j>=d[2].size()||j>=d[0].size()) break;\n    ans = (ans + pp(d[1][0], pp(d[0][j], d[2][j])))%P;\n  }\n  //2\n  for(int j=1;j<n;j++){\n    if(j>=d[1].size()||j>=d[0].size()) break;\n    ans = (ans + pp(d[2][0], pp(d[0][j], d[1][j])))%P;\n  }\n\n  ll p = d[0].size(), q = d[1].size(), r = d[2].size();\n\n  vll ps(p, 0), qs(q, 0), rs(r, 0);\n  for(int i=0;i<p;i++) ps[i] = ((i==0?0:ps[i-1]) + d[0][i])%P;\n  for(int i=0;i<q;i++) qs[i] = ((i==0?0:qs[i-1]) + d[1][i])%P;\n  for(int i=0;i<r;i++) rs[i] = ((i==0?0:rs[i-1]) + d[2][i])%P;\n  ll pmax = ps[p-1];\n  ll qmax = qs[q-1];\n  ll rmax = rs[r-1];\n\n  //0\n  if(p>1){\n    for(ll i=1;i<p;i++){\n      for(ll j=i+1;j<q;j++) {\n        ll upper = min(r-1, j);\n        ans = (ans + pp(d[0][i], pp(d[1][j], (rmax - rs[upper] + P)%P)))%P;\n      }\n      for(ll j=i+1;j<r;j++) {\n        ll upper = min(q-1, j);\n        ans = (ans + pp(d[0][i], pp(d[2][j], (qmax - qs[upper] + P)%P)))%P;\n      }\n    }\n  }\n\n  if(q>1){\n    //1\n    for(int i=1;i<q;i++){\n      for(ll j=i+1;j<p;j++) {\n        ll upper = min(r-1, j);\n        ans = (ans + pp(d[1][i], pp(d[0][j], (rmax - rs[upper] + P)%P)))%P;\n      }\n      for(ll j=i+1;j<r;j++) {\n        ll upper = min(p-1, j);\n        ans = (ans + pp(d[1][i], pp(d[2][j], (pmax - ps[upper] + P)%P)))%P;\n      }\n    }\n  }\n\n  if(r>1){\n    //2\n    for(int i=1;i<r;i++){\n      for(ll j=i+1;j<p;j++) {\n        ll upper = min(q-1, j);\n        ans = (ans + pp(d[2][i], pp(d[0][j], (qmax - qs[upper] + P)%P)))%P;\n      }\n      for(ll j=i+1;j<q;j++) {\n        ll upper = min(p-1, j);\n        ans = (ans + pp(d[2][i], pp(d[1][j], (pmax - ps[upper] + P)%P)))%P;\n      }\n    }\n  }\n\n\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MOD = 998244353;\n\nvoid add(int &a, int b) {\n  if ((a += b) >= MOD)\n    a -= MOD;\n}\n\nvoid sub(int &a, int b) {\n  if ((a -= b) < 0)\n    a += MOD;\n}\n\nint mul(int a, int b) { return (int)((a * 1LL * b) % MOD); }\n\nint mpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1)\n      res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nint minv(int x) { return mpow(x, MOD - 2); }\n\nint mex(vector<int> a) {\n  sort(a.begin(), a.end());\n  a.erase(unique(a.begin(), a.end()), a.end());\n  a.push_back(1e9);\n  int res = 0;\n  while (a[res] == res) res++;\n  return res;\n}\n\nvector<int> readGraph(int n) {\n  vector<vector<int>> g(n);\n  int m;\n  scanf(\"%d\", &m);\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    --a, --b;\n    if (a < b) {\n      g[a].push_back(b);\n    } else {\n      g[b].push_back(a);\n    }\n  }\n\n  vector<int> id(n);\n  for (int i = n - 1; i >= 0; i--) {\n    vector<int> nxt;\n    nxt.reserve(g[i].size());\n    for (int v : g[i]) {\n      nxt.push_back(id[v]);\n    }\n    id[i] = mex(nxt);\n  }\n\n  vector<int> score(*max_element(id.begin(), id.end()) + 1);\n  int v = ll(1e18) % MOD;\n  int cur = v;\n  for (int i = 0; i < n; i++) {\n    add(score[id[i]], cur);\n    cur = mul(cur, v);\n  }\n  return score;\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"c.in\", \"r\", stdin);\n  freopen(\"c.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    vector<int> g1 = readGraph(n);\n    vector<int> g2 = readGraph(n);\n    vector<int> g3 = readGraph(n);\n\n    auto get = [](const vector<int>&a, int pos) {\n      if (pos < (int)a.size()) return a[pos];\n      return 0;\n    };\n\n    int ans = 0;\n    for (int i = 0; i < (int)g1.size(); i++) {\n      for (int j = 0; j < (int)g2.size(); j++) {\n        int cur = mul(g1[i], g2[j]);\n        cur = mul(cur, get(g3, i ^ j));\n        add(ans, cur);\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_set>\n#include<unordered_map>\n#include<cassert>\n#include<stack>\n#include<fstream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define chmin(a,b) a=min(a,b)\n#define chmax(a,b) a=max(a,b)\n#define mod 998244353\n#define mad(a,b) a=(a+b)%mod\n#define N 100010\nll po(ll x,ll y){\n\tll res=1;\n\tfor(;y;y>>=1){\n\t\tif(y&1)res=res*x%mod;\n\t\tx=x*x%mod;\n\t}\n\treturn res;\n}\nll n;\nvector<ll> g[N];\nll col[N];\nP solve(){\n\tll m;\n\tcin>>m;\n\trep(i,n)g[i].clear();\n\trep(i,m){\n\t\tll a,b;\n\t\tcin>>a>>b; a--,b--;\n\t\tif(a>b)swap(a,b);\n\t\tg[b].push_back(a);\n\t}\n\trep(i,n)col[i]=0;\n\tfor(int i=n-1;i>=0;i--){\n\t\tif(col[i]==0)col[i]=0;\n\t\telse if(col[i]==1)col[i]=1;\n\t\telse if(col[i]==2)col[i]=0;\n\t\telse col[i]=-1;\n\t\tif(col[i]==-1)continue;\n\t\tfor(auto j:g[i]){\n\t\t\tif(col[i]==0)col[j]|=1;\n\t\t\tif(col[i]==1)col[j]|=2;\n\t\t}\n\t}\n\tll s0=0,s1=0;\n\tll p=(ll)1e18%mod;\n\trep(i,n){\n\t\t//cerr<<i<<\":\"<<col[i]<<endl;\n\t\tif(col[i]==0)mad(s0,po(p,i+1));\n\t\tif(col[i]==1)mad(s1,po(p,i+1));\n\t}\n\treturn make_pair(s0,s1);\n}\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tP s,t,r;\n\ts=solve();\n\tt=solve();\n\tr=solve();\n\tll fans=s.first*t.first%mod*r.first%mod;\n\tmad(fans,s.first*t.second%mod*r.second);\n\tmad(fans,s.second*t.first%mod*r.second);\n\tmad(fans,s.second*t.second%mod*r.first);\n\tif(fans<0)fans+=mod;\n\tcout<<fans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d>>(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n\n#define P 998244353\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\nll perm(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (fac[n]*finv[n-k])%P;\n}\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\n\ntypedef vector<set<ll>> graph;\nll n;\n\nvvl get(graph g){\n  //なるべく大きい要素を取る独立集合\n  //現在とったものに隣接していない最大の要素を貪欲に取っていく\n  vvl dat;\n  vll go(n+1, 0);\n\n  for(int i=n;i>0;i--){\n    //iが何番目の集合に入るか\n    if(dat.size()<=go[i]) dat.push_back(vll());\n    dat[go[i]].push_back(i);\n    for(auto to:g[i]){\n      if(go[to]==go[i]) go[to]++;\n      g[to].erase(i);\n    }\n  }\n  return dat;\n}\n\nvector<ll> cost(400000, 1);\n\n\n//独立集合の重み\nll get_cost(vll v){\n  ll ret = 0;\n  for(int i=0;i<v.size();i++) ret = (ret + cost[v[i]])%P;\n  return ret;\n}\n\nint main(int argc, char const *argv[]) {\n  init();\n  ll x = 1000000000000000000LL%P;\n  for(int i=1;i<400000;i++) cost[i] = (cost[i-1] * x)%P;\n\n  std::cin >> n;\n\n  vvl d = VV(3, 0, 0, ll);\n  for(int i=0;i<3;i++){\n    ll m;std::cin >> m;\n    graph g(n+1);\n    for(int j=0;j<m;j++){\n      ll a, b;scanf(\"%lld %lld\", &a, &b);\n      g[a].insert(b);\n      g[b].insert(a);\n    }\n    vvl X = get(g);\n    for(int j=0;j<X.size();j++) {\n      d[i].push_back(get_cost(X[j]));\n    }\n  }\n\n  ll ans = pp(pp(d[0][0], d[1][0]), d[2][0]);\n  //0\n  for(int j=1;j<n;j++){\n    if(j>=d[1].size()||j>=d[2].size()) break;\n    ans = (ans + pp(d[0][0], pp(d[1][j], d[2][j])))%P;\n  }\n  //1\n  for(int j=1;j<n;j++){\n    if(j>=d[2].size()||j>=d[0].size()) break;\n    ans = (ans + pp(d[1][0], pp(d[0][j], d[2][j])))%P;\n  }\n  //2\n  for(int j=1;j<n;j++){\n    if(j>=d[1].size()||j>=d[0].size()) break;\n    ans = (ans + pp(d[2][0], pp(d[0][j], d[1][j])))%P;\n  }\n  ll p = d[0].size(), q = d[1].size(), r = d[2].size();\n\n  vll ps(p, 0), qs(q, 0), rs(r, 0);\n  for(int i=0;i<p;i++) ps[i] = ((i==0?0:ps[i-1]) + d[0][i])%P;\n  for(int i=0;i<q;i++) qs[i] = ((i==0?0:qs[i-1]) + d[1][i])%P;\n  for(int i=0;i<r;i++) rs[i] = ((i==0?0:rs[i-1]) + d[2][i])%P;\n  ll pmax = ps[p-1];\n  ll qmax = qs[q-1];\n  ll rmax = rs[r-1];\n\n  //0\n  if(p>1){\n    for(ll i=1;i<p;i++){\n      for(ll j=i+1;j<q;j++) {\n        ll upper = min(r-1, j);\n        ans = (ans + pp(d[0][i], pp(d[1][j], (rmax - rs[upper] + P)%P)))%P;\n      }\n      for(ll j=i+1;j<r;j++) {\n        ll upper = min(q-1, j);\n        ans = (ans + pp(d[0][i], pp(d[2][j], (qmax - qs[upper] + P)%P)))%P;\n      }\n    }\n  }\n\n  if(q>1){\n    //1\n    for(int i=1;i<q;i++){\n      for(ll j=i+1;j<p;j++) {\n        ll upper = min(r-1, j);\n        ans = (ans + pp(d[1][i], pp(d[0][j], (rmax - rs[upper] + P)%P)))%P;\n      }\n      for(ll j=i+1;j<r;j++) {\n        ll upper = min(p-1, j);\n        ans = (ans + pp(d[1][i], pp(d[2][j], (pmax - ps[upper] + P)%P)))%P;\n      }\n    }\n  }\n\n  if(r>1){\n    //2\n    for(int i=1;i<r;i++){\n      for(ll j=i+1;j<p;j++) {\n        ll upper = min(q-1, j);\n        ans = (ans + pp(d[2][i], pp(d[0][j], (qmax - qs[upper] + P)%P)))%P;\n      }\n      for(ll j=i+1;j<q;j++) {\n        ll upper = min(p-1, j);\n        ans = (ans + pp(d[2][i], pp(d[1][j], (pmax - ps[upper] + P)%P)))%P;\n      }\n    }\n  }\n\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdio>\n#include <complex>\n#include <numeric>\n#include <string.h>\n#include <random>\n#include <cmath>\n#include <unordered_map>\n#include <unordered_set>\n#include <chrono>\n#include <cassert>\n#define rep(i,n) for (ll i = 0; i < (ll)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\ndouble PI = 3.141592653589793238462643383279;\nconst double EPS = 1e-9;\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate< int mod >\nstruct ModInt {\n    int x;\n\n    ModInt() : x(0) {}\n\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    ModInt operator-() const { return ModInt(-x); }\n\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n    bool operator==(const ModInt &p) const { return x == p.x; }\n\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n\n    ModInt inverse() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(int64_t n) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n            if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n         return os << p.x;\n    }\n\n    friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n\n    static int get_mod() { return mod; }\n};\n\nusing mint = ModInt< MOD >;\n\nint n;\nint m[3];\nvector<vector<int>> e[3];\nbool done[3][100000];\nbool done2[3][100000];\nmint val[3];\nmint val2[3];\nmint ten = 10;\nmint ans;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    rep(i,3) {\n        e[i].resize(n);\n        cin >> m[i];\n        rep(j,m[i]) {\n            int a, b; cin >> a >> b;\n            a--; b--;\n            e[i][a].push_back(b);\n            e[i][b].push_back(a);\n        }\n    }\n    cout << ten.x << endl;\n    rep(i,3) {\n        for (int j = n-1; j >= 0; j--) {\n            if (done[i][j]) continue;\n            val[i] += ten.pow(18*(j+1));\n            for (int to : e[i][j]) {\n                done[i][to] = true;\n            }\n        }\n    }\n    cout << ans << endl;\n    ans = val[0]*val[1]*val[2];\n    rep(i,3) {\n        for (int j = n-1; j >= 0; j--) {\n            if (!done[i][j]) continue;\n            if (done2[i][j]) continue;\n            val2[i] += ten.pow(18*(j+1));\n            for (int to : e[i][j]) {\n                done2[i][to] = true;\n            }\n        }\n    }\n    ans += val2[0]*val2[1]*val[2];\n    ans += val2[0]*val[1]*val2[2];\n    ans += val[0]*val2[1]*val2[2];\n    cout << ans.x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rds(char *s, int &x) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (x = 0; c >= 33 && c <= 126; s[++x] = c, c = gc());\n\t\ts[x+1] = '\\0';\n\t}\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\tinline void prints(string s) {\n\t\tint x = s.length();\n\t\twhile (t < x) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rds;\nusing io::print;\nusing io::prints;\n\nconst int P = 998244353;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return x = x + o.x >= P ? x + o.x - P : x + o.x, *this; }\n    inline modint &operator -= (modint o) { return x = x - o.x < 0 ? x - o.x + P : x - o.x, *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    inline modint &operator ^= (ll b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^= -1; }\n    inline modint &operator += (int o) { return x = x + o >= P ? x + o - P : x + o, *this; }\n    inline modint &operator -= (int o) { return x = x - o < 0 ? x - o + P : x - o, *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { modint y = modint(o); return *this *= y ^= -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    inline friend modint operator ^ (modint a, ll b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\nconst int N = 1e5 + 7;\nconst modint K = 1000000000000000000ll % P;\nint n;\nmodint ans;\nstruct Graph {\n\tint n, m, sg[N], k;\n\tmodint c[N];\n\tvi e[N];\n\tinline Graph() {}\n\tinline Graph(int n) : n(n) {}\n\tint SG(int x) {\n\t\tif (~sg[x]) return sg[x];\n\t\tmap<int, bool> p;\n\t\tfor (int y : e[x]) p[SG(y)] = 1;\n\t\twhile (p[++sg[x]]);\n\t\treturn sg[x];\n\t}\n\tinline void main() {\n\t\trd(m);\n\t\tfor (int i = 1; i <= n; i++) sg[i] = -1;\n\t\tfor (int i = 1, x, y; i <= m; i++) {\n\t\t\trd(x), rd(y);\n\t\t\tif (x > y) swap(x, y);\n\t\t\te[x].pb(y);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) if (!~sg[i]) SG(i);\n\t\tfor (int i = 1; i <= n; i++) k = max(k, sg[i]), c[sg[i]] += K ^ i;\n\t}\n} G[3];\n\nint main() {\n\trd(n);\n\tfor (int i = 0; i < 3; i++) G[i] = Graph(n), G[i].main();\n\tfor (int i = 0; i <= G[0].k; i++)\n\t\tfor (int j = 0; j <= G[1].k; j++)\n\t\t\tans += G[0].c[i] * G[1].c[j] * G[2].c[i^j];\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n\nusing ll = long long;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nint const nmax = 100000;\nint const rad = 500;\nint const modulo = 998244353;\nstd::vector<int> g[3][1 + nmax];\nint nimber[3][1 + nmax];\n\nint lgpow(int a, int b) {\n  if(b == 0)\n    return 1;\n  else if(b == 1)\n    return a;\n  else {\n    int result = lgpow(a, b / 2);\n    if(b % 2 == 0)\n      return 1LL * result * result % modulo;\n    else\n      return 1LL * result * result % modulo * a % modulo;\n  }\n}\n\nint mex(std::vector<int> v) {\n  std::sort(v.begin(), v.end());\n  v.erase(std::unique(v.begin(), v.end()), v.end());\n  for(int i = 0; i < v.size(); i++)\n    if(i != v[i])\n      return i;\n  return v.size();\n}\n\nint sum[3][5 + nmax];\n\nint main() {\n  int n, m[3];\n  std::cin >> n;\n  for(int h = 0; h < 3; h++) {\n    std::cin >> m[h];\n    for(int i = 1;i <= m[h]; i++){\n      int x, y;\n      std::cin >> x >> y;\n      if(y < x)\n        std::swap(x, y);\n      g[h][x].push_back(y);\n    }\n    std::vector<int> cand;\n    for(int i = n; 1 <= i; i--) {\n      cand.clear();\n      for(int h_ = 0; h_ < g[h][i].size(); h_++){\n        int to = g[h][i][h_];\n        cand.push_back(nimber[h][to]);\n      }\n      nimber[h][i] = mex(cand);\n      sum[h][nimber[h][i]] = (sum[h][nimber[h][i]] + lgpow(10, 18 * i)) % modulo;\n    }\n  }\n\n  int result = 0;\n  \n  for(int i = 0; i < rad; i++)\n    for(int j = 0; j < rad; j++)\n      if((i ^ j) < rad) { \n        result = (result + 1LL * sum[0][i] * sum[1][j] % modulo * sum[2][i ^ j]) % modulo;\n      }\n  std::cout << result;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\nusing ll = long long;\ntemplate <typename T> using V = vector<T>;\n\nconstexpr int Mod = 998244353;\nconstexpr int mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\n\ntemplate <typename T> constexpr bool chmax(T &a, const T &b) {\n    if(a >= b) return false;\n    a = b;\n    return true;\n}\ntemplate <typename T> constexpr bool chmin(T &a, const T &b) {\n    if(a <= b) return false;\n    a = b;\n    return true;\n}\n\n/*-------------------------------------------*/\n\ntemplate <int M> class ModInt {\n    int x;\n\n  public:\n    constexpr ModInt() : x(0) {}\n    constexpr ModInt(int64_t y) : x(y >= 0 ? y % M : (M - (-y) % M) % M) {}\n    constexpr ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator-=(const ModInt &p) {\n        if((x += M - p.x) >= M) x -= M;\n        return *this;\n    }\n    constexpr ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % M);\n        return *this;\n    }\n    constexpr ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n    constexpr ModInt operator-() const { return ModInt(-x); }\n    constexpr ModInt operator+(const ModInt &p) const {\n        return ModInt(*this) += p;\n    }\n    constexpr ModInt operator-(const ModInt &p) const {\n        return ModInt(*this) -= p;\n    }\n    constexpr ModInt operator*(const ModInt &p) const {\n        return ModInt(*this) *= p;\n    }\n    constexpr ModInt operator/(const ModInt &p) const {\n        return ModInt(*this) /= p;\n    }\n    constexpr bool operator==(const ModInt &p) const { return x == p.x; }\n    constexpr bool operator!=(const ModInt &p) const { return x != p.x; }\n    constexpr ModInt inverse() const {\n        int a = x, b = M, u = 1, v = 0, t = 0;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n    constexpr ModInt pow(const int64_t &n) const {\n        ModInt ret(1), mul(x);\n        int64_t k = n % (M - 1);\n        if(k < 0) k += M - 1;\n        while(k > 0) {\n            if(k & 1) ret *= mul;\n            mul *= mul;\n            k >>= 1;\n        }\n        return ret;\n    }\n    constexpr friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    constexpr friend istream &operator>>(istream &is, ModInt &a) {\n        int64_t t = 0;\n        is >> t;\n        a = ModInt(t);\n        return (is);\n    }\n};\nusing modint = ModInt<Mod>;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    V<modint> ten(500009, 1);\n    modint f = modint(1000000000000000000);\n    rep(i, 500005) ten[i + 1] = ten[i] * f;\n\n    int n;\n    cin >> n;\n    V<V<V<int>>> G(3, V<V<int>>(n));\n    rep(i, 3) {\n        int m;\n        cin >> m;\n        rep(j, m) {\n            int a, b;\n            cin >> a >> b;\n            a--;\n            b--;\n            G[i][a].push_back(b);\n            G[i][b].push_back(a);\n        }\n    }\n    V<V<int>> grundy(3, V<int>(n, -1));\n    V<V<modint>> memo(3, V<modint>(1000, 0));\n    rep(i, 3) FORR(v, n) {\n        bool x[1000] = {};\n        for(int e : G[i][v])\n            if(grundy[i][e] != -1) x[grundy[i][e]] = true;\n        int g = 0;\n        while(x[g])\n            g++;\n        grundy[i][v] = g;\n        memo[i][g] += ten[v + 1];\n    }\n    modint res = 0;\n    rep(a, 1000) {\n        if(memo[0][a] == 0) break;\n        rep(b, 1000) {\n            if(memo[1][b] == 0) break;\n            int c = a ^ b;\n            res += memo[0][a] * memo[1][b] * memo[2][c];\n        }\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\ntemplate <class T> using VVV = V<VV<T>>;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nstruct edge {\n    ll to, cost;\n};\n\nVVV<edge> G(3, VV<edge>(200000));\nVV<ll> grundy(3, V<ll>(200000, 0));\n\nvoid addedge(VV<edge>& G, int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    G[st].push_back(e);\n}\n\nll N;\nvoid setvalue() {\n    REP(p, 0, 3) {\n        V<ll> used(N, -1);\n        PER(i, N - 1, -1) {\n            REP(j, 0, G[p][i].size()) {\n                edge e = G[p][i][j];\n                used[grundy[p][e.to]] = i;\n            }\n            while (used[grundy[p][i]] == i) {\n                grundy[p][i]++;\n            }\n        }\n    }\n}\n\nll ten[2000000];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    ten[0] = 1;\n    REP(i, 1, 2000000) {\n        ten[i] = multiply(ten[i - 1], 10);\n    }\n    ll M[3];\n    REP(p, 0, 3) {\n        cin >> M[p];\n        REP(i, 0, M[p]) {\n            ll a, b;\n            cin >> a >> b;\n            a--;\n            b--;\n            if (a > b) {\n                swap(a, b);\n            }\n            addedge(G[p], a, b, 0);\n        }\n    }\n    // cout << \"aaa\" << endl;\n    setvalue();\n    // cout << \"bbb\" << endl;\n    VV<ll> sum(3);\n    REP(p, 0, 3) {\n        REP(i, 0, N) {\n            while ((ll)sum[p].size() <= grundy[p][i]) {\n                sum[p].push_back(0);\n            }\n            sum[p][grundy[p][i]] = modadd(sum[p][grundy[p][i]], ten[18 * (i + 1)]);\n        }\n    }\n    ll ans = 0;\n    REP(i, 0, sum[0].size()) {\n        REP(j, 0, sum[1].size()) {\n            ll k = i ^ j;\n            if (k < (ll)sum[2].size()) {\n                ans = modadd(ans, multiply(sum[0][i], multiply(sum[1][j], sum[2][k])));\n            }\n        }\n    }\n    // REP(p, 0, 3) {\n    //     REP(i, 0, N) {\n    //         cout << grundy[p][i] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // cout << \"aaa\" << endl;\n    // REP(p, 0, 3) {\n    //     REP(i, 0, sum[p].size()) {\n    //         cout << sum[p][i] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n        #define int long long\nconst int MAX = 510000;\nconst int MOD =  998244353;\nconst int  Inv2 = (MOD+1)/2;\ntemplate <typename T>\nvoid fwt(vector<T>& f,int n) {\n  \n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD, f[j | i] = (x+MOD - y)%MOD;\n            }\n        }\n    }\n}\ntemplate <typename T>\nvoid ifwt(vector<T>& f,int n) {\n    \n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                T x = f[j], y = f[j | i];\n                f[j] = (x + y)%MOD *Inv2 %MOD, f[j | i] = (x+MOD - y) %MOD *Inv2 %MOD;\n            }\n        }\n    }\n}\n     signed main(){\n   int n,nn=1,t=1,m,a,b;\n   for(int i=0;i<18;i++)t=(t*10)%MOD;\n   cin>>n;\n   while(nn<n)nn*=2;\n vector<int> p(nn,0),q(nn,0),r(nn,0),ban(n,0),henp[n],henq[n],henr[n];\n cin>>m;\n for(int i=0;i<m;i++){\n         cin>>a>>b;a--;b--;\n         if(a>b)swap(a,b);\n         henp[a].push_back(b);\n }\n        cin>>m;\n for(int i=0;i<m;i++){\n         cin>>a>>b;a--;b--;\n         if(a>b)swap(a,b);\n         henq[a].push_back(b);\n }\n cin>>m;\n for(int i=0;i<m;i++){\n         cin>>a>>b;a--;b--;\n         if(a>b)swap(a,b);\n         henr[a].push_back(b);\n }\n\npriority_queue<int,vector<int>,greater<int>> que;\nint mb=0;\n for(int i=n-1;i>=0;i--){\n         ban[i]=0;\n         for(int j=0;j<henp[i].size();j++)que.push(ban[henp[i][j]]);\n         while(!que.empty()){\n                 if(ban[i]==que.top())ban[i]++;\n                \n                 que.pop();\n         }\n         mb=max(mb,ban[i]);\n }\n a=1;\n for(int i=0;i<n;i++){\n         a=(a*t)%MOD;\n        p[ban[i]]=(p[ban[i]]+a)%MOD;\n }\n for(int i=n-1;i>=0;i--){\n         ban[i]=0;\n         for(int j=0;j<henq[i].size();j++)que.push(ban[henq[i][j]]);\n         while(!que.empty()){\n                 if(ban[i]==que.top())ban[i]++;\n                 que.pop();\n         }\n         mb=max(mb,ban[i]);\n }\n a=1;\n for(int i=0;i<n;i++){\n         a=(a*t)%MOD;\n        q[ban[i]]=(q[ban[i]]+a)%MOD;\n }\n for(int i=n-1;i>=0;i--){\n         ban[i]=0;\n         for(int j=0;j<henr[i].size();j++)que.push(ban[henr[i][j]]);\n         while(!que.empty()){\n                 if(ban[i]==que.top())ban[i]++;\n                 que.pop();\n         }\n         mb=max(mb,ban[i]);\n }\n a=1;\n for(int i=0;i<n;i++){\n         a=(a*t)%MOD;\n        r[ban[i]]=(r[ban[i]]+a)%MOD;\n }\n fwt(p,mb+1);fwt(q,mb+1);\n for(int i=0;i<nn;i++)q[i]=(q[i]*p[i])%MOD;\n ifwt(q,mb+1);\n int ans=0;\n for(int i=0;i<nn;i++)ans=(ans+(q[i]*r[i])%MOD)%MOD;\n cout<<ans<<endl;\n\n\n         \n}\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 3;\nconst int mod = 998244353;\n\nint n, m[4];\nvector <int> adj[4][maxn];\nvoid read()\n{\n    cin >> n;\n    for (int i = 1; i <= 3; i++)\n    {\n        cin >> m[i];\n        for (int j = 1; j <= m[i]; j++)\n        {\n            int a, b;\n            cin >> a >> b;\n\n            adj[i][a].push_back(b);\n            adj[i][b].push_back(a);\n        }\n    }\n}\n\nlong long add(long long a, long long b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n\n    return a;\n}\n\nlong long st[maxn*2];\nint gr[4][maxn];\nmap <int, long long> mp[4];\nvoid solve()\n{\n    st[0] = 1;\n    for (int i = 1; i <= 2 * n; i++)\n        st[i] = st[i-1] * 1000000000 % mod;\n\n    for (int i = 1; i <= 3; i++)\n    {\n        mp[i][0] = add(mp[i][0], st[n*2]);\n        for (int j = n-1; j >= 1; j--)\n        {\n            set <int> s;\n            for (auto k: adj[i][j])\n                if (k > j)\n                s.insert(gr[i][k]);\n\n            while (s.find(gr[i][j]) != s.end())\n                gr[i][j]++;\n\n            mp[i][gr[i][j]] = add(mp[i][gr[i][j]], st[j*2]);\n        }\n    }\n\n    int p = sqrt(max({m[1], m[2], m[3]})) * 2;\n    long long ans = 0;\n    for (int i = 0; i <= p; i++)\n        if (mp[1].count(i))\n        for (int j = 0; j <= p; j++)\n        if (mp[2].count(j))\n            ans = add(ans, mp[1][i] * mp[2][j] % mod * mp[3][i^j] % mod);\n\n    cout << ans << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    read();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\ntypedef Field<998244353> FF;\nclass CGiantGraph {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector2<vector<int>> E(3, N);\n        vector2<bool> A(3, N, false), B(3, N, false);\n        for (int i = 0; i < 3; ++i) {\n            int M; cin >> M;\n            for (int j = 0; j < M; ++j) {\n                int a, b; cin >> a >> b;\n                --a; --b;\n                E[i][a].push_back(b);\n                E[i][b].push_back(a);\n            }\n\n            for (int j = N-1; j >= 0; --j) {\n                if (!A[i][j] && !B[i][j]) A[i][j] = true;\n                if (A[i][j] && B[i][j]) continue;\n                for (int k : E[i][j]) {\n                    if (k < j) {\n                        if (A[i][j]) B[i][k] = true;\n                        else A[i][k] = true;\n                    }\n                }\n            }\n        }\n\n        FF base = FF{10}.pow(18);\n        FF ans = 0;\n        vector2<FF> Q(3, 2, 0);\n\n        for (int k = 0; k < 3; ++k) {\n            for (int i = 0; i < N; ++i) {\n                if (A[k][i] && B[k][i]) continue;\n                Q[k][A[k][i]] += base.pow(i + 1);\n            }\n        }\n\n        for (int i = 0; i < 2; ++i) {\n            for (int j = 0; j < 2; ++j) {\n                for (int k = 0; k < 2; ++k) {\n                    if (i^j^k) ans += Q[0][i] * Q[1][j] * Q[2][k];\n                }\n            }\n        }\n//\n//            for (int k = 0; k < N; ++k) {\n//                if (A[2][k] && B[2][k]) continue;\n//                if (1 == A[2][k]) {\n//                    ans += (Q[0][0] * Q[1][0] + Q[0][1] * Q[1][1]) * base.pow(k+1);\n//                } else {\n//                    ans += (Q[0][1] * Q[1][0] + Q[0][0] * Q[1][1]) * base.pow(k+1);\n//                }\n//            }\n////        }\n        cout << ans << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tCGiantGraph solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nlld arr[300000];\nvector<lld> adj[300000][3];\nar<lld,3> siz;\nlld grundy[300000][3];\nmap<lld,lld> sums[3];\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nvoid dfs_grundy(lld node,lld grp){\n    if (grundy[node][grp]!=-1)return ;\n  //  grundy[node][grp]=0;\n    vector<lld> mex;\n    //nums[0][grp]++;\n    for (auto it:adj[node][grp]){\n        //if (it<node) continue;\n        dfs_grundy(it,grp);\n        mex.pb(grundy[it][grp]);\n    }\n    if (mex.empty()) {grundy[node][grp]=0;sums[grp][0]+=fastpower(10,18*(node+1),modd);sums[grp][0]%=modd;return;}\n    sort(all(mex));\n    rep(i,0,mex.size()-1){\n        if (i!=mex[i]){\n            grundy[node][grp]=i;\n        //    nums[0][grp]--;\n      //      nums[i][grp]++;\n            sums[grp][i]+=fastpower(10,18*(node+1),modd);sums[grp][i]%=modd;\n            return ;\n        }\n    }\n    grundy[node][grp]=mex.size();\n    //nums[0][grp]--;\n    //nums[mex.size()][grp]++;\n    sums[grp][mex.size()]+=fastpower(10,18*(node+1),modd);sums[grp][mex.size()]%=modd;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,r,k,c,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n//     ans=0;\n     //cin>>TESTS;\n     memset(grundy,-1,sizeof(grundy));\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(j,0,2){\n         cin>>siz[j];\n         rep(i,0,siz[j]-1){\n            cin>>a>>b;a--;b--;\n            adj[a][j].pb(b);\n            adj[b][j].pb(a);\n         }\n         }\n         rep(j,0,2) rep(i,0,n-1) dfs_grundy(i,j);\n         lld ans=0;\n         rep(i,0,1000) rep(j,0,1000) {\n            lld k=i^j;\n            if(k<sums[2].size())ans+=(((sums[0][i]*sums[1][j])%modd)*sums[2][k])%modd;\n            ans%=modd;\n         }\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n2020.03.21\n\n考虑一个暴力的贪心做法，从大到小枚举 S = x + y + z ，\n然后对于所有 (x, y, z) ，如果之前没有与之连边的点被选，那么这个点一定要出现在最优解中。\n可以给边定向，边从小连到大，那么整个图就是 DAG ，在 DAG 中抽象这个贪心：\n每次选择一个点满足其到的点都没有被选，然后删掉选择它加入最优解集合。\n那么一个点被选当且仅当其到的点都没被选，一个点没被选当且仅当其到的点存在被选的点（或没有出度）。\n这可以对应到博弈中的必胜必败态，这个 DAG 可以看做博弈转移图，答案就是求所有必败态的权值和。\n\n然而点数很大。\n考虑对于一个 (x, y, z) ，如何快速求出其必胜必败态，\n每次移动只能移动一维，这个博弈三维独立，就相当于每个维度有一个子游戏。\n对于每一维求出 SG 值 f[x], g[y], h[z] ，三者异或和就是这个的 SG 值。\n考虑计数，FWT 做异或卷积即可（事实上也可以三维暴力枚举 SG 值，SG 值的上界是 O(sqrt(M)) 的）。\n#endif\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n} read;\n\nconst int maxn = 200005, mod = 998244353;\nstd::vector<int> G[maxn];\nint sg[3][maxn];\nll f[3][maxn], g[maxn];\nll po[maxn * 3];\n\nvoid FWT (ll *a, int n) {\n\tfor (int m = 1; m < n; m <<= 1)\n\t\tfor (int i = 0; i < n; i += m << 1)\n\t\t\tfor (int k = i; k < i + m; k ++) {\n\t\t\tll x = a[k], y = a[k + m];\n\t\t\t(a[k] = x + y) %= mod;\n\t\t\t(a[k + m] = x + mod - y) %= mod;\n\t\t}\n}\n\nvoid iFWT (ll *a, int n) {\n\tFWT(a, n);\n\tll inv = mod - (mod - 1) / n;\n\tfor (int i = 0; i < n; i ++)\n\t\t(a[i] *= inv) %= mod;\n}\n\nint main () {\n\tint n = read, len = 1;\n\twhile (len < n)\n\t\tlen <<= 1;\n\n\tpo[0] = 1;\n\tll bs = 1000000000000000000ll % mod;\n\tfor (int i = 1; i <= n * 3; i ++)\n\t\tpo[i] = po[i - 1] * bs % mod;\n\n\tfor (int o = 0; o < 3; o ++) {\n\t\tint m = read;\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tG[i].clear();\n\t\tfor (int i = 1; i <= m; i ++) {\n\t\t\tint u = read, v = read;\n\t\t\tif (u < v) G[u].push_back(v);\n\t\t\tif (v < u) G[v].push_back(u);\n\t\t}\n\t\tfor (int i = n; i; i --) {\n\t\t\tstd::set<int> mex;\n\t\t\tfor (int j : G[i])\n\t\t\t\tmex.insert(sg[o][j]);\n\t\t\twhile (mex.count(sg[o][i]))\n\t\t\t\t++ sg[o][i];\n\t\t}\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\t(f[o][sg[o][i]] += po[i]) %= mod;\n\t\tFWT(f[o], len);\n\t}\n\n\tfor (int i = 0; i < len; i ++)\n\t\tg[i] = f[0][i] * f[1][i] % mod * f[2][i] % mod;\n\tiFWT(g, len);\n\n\tprintf(\"%lld\\n\", g[0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\n#define deb debug(\"line %d\\n\",__LINE__)\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"-1\");exit(0);}\n\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=998244353;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int MM=5e6+10;\n\tll fac[MM],facinv[MM],Inv[MM];ll Comb(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,MM-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[MM-1]=invm(fac[MM-1]);fd(i,MM-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,MM-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=1e6+10;\n\t//------------------FIXED------------------\n\tint n,MX;\n\tll dec[N];\n\tstruct Graph\n\t{\n\t\tvc<int> to[N];\n\t\tbool used[N];int sg[N],cnt[N];\n\t\tvoid input()\n\t\t{\n\t\t\tint m=qread();while(m--){ int x=qread(),y=qread();if(x>y)swap(x,y);to[x].PB(y); }\n\t\t\tfd(x,n,1)\n\t\t\t{\n\t\t\t\tfor(auto y:to[x]) used[sg[y]]=1;\n\t\t\t\twhile(used[sg[x]]) sg[x]++;add(cnt[sg[x]],dec[x]),chmax(MX,sg[x]);\n\t\t\t\tfor(auto y:to[x]) used[sg[y]]=0;\n\t\t\t}\n\t\t\tdeb;\n\t\t}\n\t}G[3];\n\tvoid main()\n\t{\n\t\tdec[0]=1,dec[1]=ll(1e18)%MOD;fo(i,2,N-1) dec[i]=dec[i-1]*dec[1]%MOD;\n\t\tn=qread();fo(id,0,2) G[id].input();\n\t\tint ans=0;fo(i,0,MX) fo(j,0,MX) add(ans, 1ll*G[2].cnt[i^j]*G[0].cnt[i]%MOD*G[1].cnt[j]%MOD );write(ans);\n\t}\n};//变量重名！\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();\n\tmine::main();\n\tdebug(\"\\n------------------------------------------\\nTime: %.2lf s\\n\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=100005;\nconst int MOD=998244353;\nint n,m;\nlong long ksm(long long a,long long b)\n{\n\ta%=MOD,b%=(MOD-1);\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nvector<int>G[N];\nint sg[N];\nint dfs(int u)\n{\n\tif(sg[u]!=-1) return sg[u];\n\tstatic int vis[N];\n\tfor(int v:G[u])\n\t{\n\t\tdfs(v);\n\t\tvis[sg[v]]=true;\n\t}\n\tfor(int i=0;;i++)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tsg[u]=i;\n\t\t\tbreak;\n\t\t}\n\tfor(int v:G[u])\n\t\tvis[sg[v]]=false;\n\treturn sg[u];\n}\nvector<long long> getsg()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tG[i].clear();\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x>y) swap(x,y);\n\t\tG[x].push_back(y);\n\t}\n\tmemset(sg,-1,sizeof(sg));\n\tfor(int i=n;i>=1;i--)\n\t\tdfs(i);\n\tint Max=*max_element(sg+1,sg+n+1);\n\tvector<long long>res;\n\tres.resize(Max+1);\n\tfor(int i=1;i<=n;i++)\n\t\tres[sg[i]]=(res[sg[i]]+ksm(1e18,i))%MOD;\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tvector<long long>x=getsg(),y=getsg(),z=getsg();\n\tlong long ans=0;\n\tfor(int i=0;i<x.size();i++)\n\t\tfor(int j=0;j<y.size();j++)\n\t\t{\n\t\t\tint k=i^j;\n\t\t\tif(k>=z.size()) continue;\n\t\t\tans=(ans+x[i]*y[j]%MOD*z[k]%MOD)%MOD;\n\t\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\n#define x first\n#define y second\n#define pb push_back\n#define eb emplace_back\n#define rep(i,a,b) for(auto i=(a); i<(b); ++i)\n#define REP(i,n) rep(i,0,n)\n#define all(v) (v).begin(), (v).end()\n#define rs resize\n#define DBG(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << endl\n\nconst ld PI = acos(-1.0);\ntemplate<class T> using min_queue =\npriority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> int sz(const T &x) {\n    return (int) x.size(); // copy the ampersand(&)!\n}\n\ntemplate<class T> ostream& operator<<(ostream &os, vector<T> &v) {\n    os << \"\\n[\";\n    for(T &x : v) os << x << ',';\n    return os << \"]\\n\";\n}\n\nstruct pairhash {\n    public:\n    template<typename T1, typename T2>\n    size_t operator()(const pair<T1, T2> &p) const {\n        size_t lhs = hash<T1>()(p.x);\n        size_t rhs = hash<T2>()(p.y);\n        return lhs ^ (rhs+0x9e3779b9+(lhs<<6)+(lhs>>2));\n    }\n};\n\nconst ll MOD = 998244353;\nconst ll BASE = 1000000000000000000%MOD;\n\nvector<vvi> adj;\nvvi nim;\n\nvoid run() {\n\tll N;\n\tcin >> N;\n\n\tll maxNim = 0;\n\tfor (ll i = 0; i < 3; i++) {\n\t\tadj.pb(vvi(N));\n\t\tnim.pb(vi(N, 0));\n\t\tll M;\n\t\tcin >> M;\n\t\tfor (ll j = 0; j < M; j++) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tif (a > b) swap(a, b);\n\t\t\tadj[i][a].pb(b);\n\t\t}\n\n\t\t//while (maxNim*(maxNim+1)/2 <= M) {\n\t\t//\tmaxNim++;\n\t\t//}\n\t\t//maxNim += 2;\n\n\t\tfor (ll j = N-1; j >= 0; j--) {\n\t\t\tvector<bool> U(adj[i][j].size()+2, false);\n\t\t\tfor (ll k : adj[i][j]) {\n\t\t\t\tU[nim[i][k]] = true;\n\t\t\t}\n\t\t\tfor (ll k = 0; k < U.size(); k++) {\n\t\t\t\tif (!U[k]) {\n\t\t\t\t\t//cout << j << \": \" << k << endl;\n\t\t\t\t\tnim[i][j] = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaxNim = max(maxNim, nim[i][j]+1);\n\t\t}\n\t}\n\n\tvvi nimScore(3, vi(maxNim, 0));\n\tfor (ll i = 0; i < 3; i++) {\n\t\tll p = 1;\n\t\tfor (ll j = 0; j < N; j++) {\n\t\t\tp *= BASE;\n\t\t\tp %= MOD;\n\t\t\tnimScore[i][nim[i][j]] += p;\n\t\t\tnimScore[i][nim[i][j]] %= MOD;\n\t\t}\n\t}\n\t\n\tll res = 0;\n\tfor (ll i1 = 0; i1 < maxNim; i1++) {\n\t\tfor (ll i2 = 0; i2 < maxNim; i2++) {\n\t\t\tif ((i1^i2) < maxNim) {\n\t\t\t\tres += (nimScore[0][i1]*nimScore[1][i2])%MOD*nimScore[2][i1^i2];\n\t\t\t\tres %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << maxNim << endl;\n\tcout << res << endl;\n\t//cout << nimScore[0][0] << \", \" << nimScore[1][0] << \", \" << nimScore[2][0] << endl;\n}\n\nsigned main() {\n    // DON'T MIX \"scanf\" and \"cin\"!\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout << fixed << setprecision(20);\n    run();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5,M=505,mod=998244353;\nll base1=1,base2=0,p[N];\nint n,m,tot,vis[N],head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nvector<ll>res[3];\nvoid solve(int flag)\n{\n    tot=0;memset(head,0,sizeof(head));\n    memset(vis,false,sizeof(vis));\n    m=100000;\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        //u=v=1;while(u==v) u=rand()*rand()%n+1,v=rand()*rand()%n+1;\n        add(u,v);add(v,u);\n    }\n    priority_queue<int>q[2];\n    int x=0,tim=0;\n    for(int i=1;i<=n;i++) q[x].push(i);\n    vector<ll>f;\n    while(!q[x].empty())\n    {\n        tim++;\n        ll ans=0;\n        while(!q[x].empty())\n        {\n            while(!q[x].empty()&&vis[q[x].top()]==tim) q[x].pop();\n            if(q[x].empty()) break;\n            int u=q[x].top();q[x].pop();\n            vis[u]=1e9;\n            ans=(ans+p[u])%mod;\n            for(int i=head[u];i;i=nex[i])\n            {\n                int v=to[i];\n                if(vis[v]<tim)\n                {\n                    vis[v]=tim;\n                    q[x^1].push(v);\n                }\n            }\n        }\n        x^=1;\n        f.push_back(ans);\n    }\n    res[flag]=f;\n}\nbool vis1[M][M],vis2[M];\nll solve()\n{\n    memset(vis2,0,sizeof(vis2));\n    ll ans=0;\n    for(int i=0;i<res[1].size();i++)\n    {\n        int mx=0;\n        while(mx<res[2].size()&&vis1[i][mx]||vis2[mx]) mx++;\n        if(mx<res[2].size())\n        {\n            vis1[i][mx]=vis2[mx]=true;\n            ans=(ans+res[1][i]*res[2][mx])%mod;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    srand(time(0));\n    p[0]=1;\n    for(int i=1;i<N;i++) p[i]=1000000000000000000ll%mod*p[i-1]%mod;\n    scanf(\"%d\",&n);\n    solve(0);solve(1);solve(2);\n    assert(res[0].size()<M);\n    assert(res[1].size()<M);\n    assert(res[2].size()<M);\n    ll ans=0;\n    for(int i=0;i<res[0].size();i++)\n        ans=(ans+res[0][i]*solve())%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define ll long long\n//#define cccgift\n#define lowbit(x) ((x)&-(x))\n#define rep(i,l,r) for(res i=l,_r=r;i<=_r;++i)\n#define per(i,r,l) for(res i=r,_l=l;i>=_l;--i)\n#define mkp make_pair\n#define pb push_back\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem0n(a,n) memset(a,0,n*sizeof(a[0]))\n#define iter(x,v) for(res v,_p=head[x];v=ver[_p],_p;_p=nxt[_p])\n#ifdef cccgift //by lqh\n#define SHOW(x) cerr<<#x\"=\"<<(x)<<endl\n#else\n#define SHOW(x) 0\n#endif\n//#define getchar()(ip1==ip2&&(ip2=(ip1=ibuf)+fread(ibuf,1,1<<21,stdin),ip1==ip2)?EOF:*ip1++)\n//char ibuf[1<<21],*ip1=ibuf,*ip2=ibuf;\ntemplate<typename T>\ninline void read(T &x)\n{\n    static char ch;bool f=1;\n    for(x=0,ch=getchar();!isdigit(ch);ch=getchar()) if(ch=='-') f=0;\n    for(;isdigit(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());x=f?x:-x;\n}\ntemplate<typename T>\nvoid print(T x)\n{\n    if (x<0) x=-x,putchar('-');\n    if (x>9) print(x/10);\n    putchar(x%10+48);\n}\ntemplate<typename T>\ninline void print(T x,char ap) {print(x);if (ap) putchar(ap);}\ntemplate<typename T>\ninline void chkmax(T &x,const T &y) {x=x<y?y:x;}\ntemplate<typename T>\ninline void chkmin(T &x,const T &y) {x=x<y?x:y;}\nconst int mod=998244353;\nint n,m,head[100001],ver[100001],nxt[100001],ans,tong[4][1001],x,y,mi[100001],sg[100001];\nbool vis[1001];\n#define inc(x,y) x+=y,x>=mod?x-=mod:0\ninline void add(int x,int y) {ver[++ans]=y,nxt[ans]=head[x],head[x]=ans;}\nint main()\n{\n\tread(n),mi[0]=1,mi[1]=(ll)1e18%mod;\n\trep(i,2,n) mi[i]=(ll)mi[i-1]*mi[1]%mod;\n\trep(_,1,3) {\n\t\tread(m),mem0(head),mem0(sg),ans=0;\n\t\trep(i,1,m) read(x),read(y),add(min(x,y),max(x,y));\n\t\tper(i,n,1) {\n\t\t\titer(i,v) vis[sg[v]]=true;\n\t\t\twhile(vis[sg[i]]) ++sg[i];\n\t\t\titer(i,v) vis[sg[v]]=false;\n\t\t}\n\t\trep(i,1,n) inc(tong[_][sg[i]],mi[i]);\n\t}\n\tint tot=0;\n\trep(i,0,1000)\n\t  rep(j,0,1000) inc(tot,(ll)tong[1][i]*tong[2][j]%mod*tong[3][i^j]%mod);\n\tprint(tot,'\\n');\n\treturn 0;\n}\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do something instead of nothing and stay organized\n*/ \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int N=100005,mod=998244353;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nint base=Pow(10,18);\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n;\nvi a[N],b[N],c[N];\nint sa[N],sb[N],sc[N];\nvoid get(vi *e,int *s){\n\tstatic int vis[N],sg[N],tc=0;\n\tint m=read();\n\twhile (m--){\n\t\tint x=read(),y=read();\n\t\tif (x>y)\n\t\t\tswap(x,y);\n\t\te[x].pb(y);\n\t}\n\tclr(sg);\n\tFod(i,n,1){\n\t\ttc++;\n\t\tfor (auto j : e[i])\n\t\t\tvis[sg[j]]=tc;\n\t\twhile (vis[sg[i]]==tc)\n\t\t\tsg[i]++;\n\t\tAdd(s[sg[i]],Pow(base,i));\n\t}\n}\nint main(){\n\tn=read();\n\tget(a,sa),get(b,sb),get(c,sc);\n\tint ans=0;\n\tFor(i,0,1000)\n\t\tFor(j,0,1000)\n\t\t\tAdd(ans,(LL)sa[i]*sb[j]%mod*sc[i^j]%mod);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 100003, M = 500, mod = 998244353, X = (LL) 1e18 % mod;\ntemplate<typename T>\ninline void read(T &x){\n    int ch = getchar(); x = 0;\n    for(;ch < '0' || ch > '9';ch = getchar());\n    for(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';\n}\ntemplate<typename T>\ninline bool chkmax(T &a, const T &b){if(a < b) return a = b, 1; return 0;}\ninline void qmo(int &x){x += (x >> 31) & mod;}\nint n, m, r, f[3][M], sg[N], po[N], vis[N], ans;\nvector<int> E[N];\nint main(){\n    read(n); po[0] = 1;\n    for(Rint i = 1;i <= n;++ i) po[i] = (LL) po[i - 1] * X % mod;\n    for(Rint t = 0, x, y;t < 3;++ t){\n        read(m);\n        for(Rint i = 1;i <= n;++ i) E[i].clear();\n        while(m --){\n            read(x); read(y);\n            if(x > y) swap(x, y);\n            E[x].push_back(y);\n        }\n        for(Rint i = n;i;-- i){\n            int id = t * n + i;\n            for(Rint j : E[i]) vis[sg[j]] = id;\n            for(sg[i] = 0;vis[sg[i]] == id;++ sg[i]);\n            qmo(f[t][sg[i]] += po[i] - mod); chkmax(r, sg[i]);\n        }\n    }\n    for(Rint i = 0;i <= r;++ i)\n        for(Rint j = 0;j <= r;++ j)\n            qmo(ans += (LL) f[0][i] * f[1][j] % mod * f[2][i ^ j] % mod - mod);\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <memory.h>\n#include <cmath>\n#include <array>\n\nusing namespace std;\n\nvoid re(int& x);\n\ntemplate<class T, class... Ts> void re(T& t, Ts&... ts);\n\nvoid pr(long long x);\n\nvoid pr(const char *x);\n\nvoid ps();\ntemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts);\n\n#ifdef FFDBG\n\n#else\n#define dbg(x...) dsfdsfsdfasd\n#endif\n\n#define sz(x) (int)(x).size()\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n\nconst int mod = 998244353;\nconst long long base = 1000000000000000000 % mod;\n\nint n,m;\nvector<int> g[3][110000];\nint seen[3][110000];\nvector<long long> vals[3];\nlong long pot[110000];\n\n// int dfs(int v) {\n//     if (seen[v]) return -1;\n//     seen[v] = 1;\n//     int ans = v;\n//     for (int x : g[v]) ans = max(v, dfs(x));\n//     return ans;\n// }\n\nvoid solve()\n{\n    pot[0] = 1;\n    rep(i,1,100010) pot[i] = (pot[i-1] * 1ll * base) % mod;\n\n    // dbg(base);\n\n    re(n);\n    rep(iter,0,3) {\n        re(m);\n\n        rep(i,0,m) {\n            int u,v; re(u,v); u--; v--;\n            g[iter][u].push_back(v);\n            g[iter][v].push_back(u);\n        }\n\n        int taken = 0, cc = 0;\n        while (taken < n) {\n            long long cur = 0;\n            cc++;\n            for (int i = n-1; i >= 0; i--) if (seen[iter][i]!=-1 && seen[iter][i] != cc) {\n                seen[iter][i]=-1;\n                taken++;\n                cur = (cur + pot[i+1]) % mod;\n                for (int x : g[iter][i]) seen[iter][x] = cc;\n            }\n            vals[iter].push_back(cur);\n        }\n    }\n\n    long long ans = 0;\n\n    // dbg(vals[0][0], vals[0][1]);\n\n    rep(i,0,min(sz(vals[1]), sz(vals[2]))) {\n        long long th = vals[0][0];\n        th = (th * 1ll * vals[1][i]) % mod;\n        th = (th * 1ll * vals[2][i]) % mod;\n        ans = (ans + th) % mod;\n    }\n    rep(i,1,min(sz(vals[0]), sz(vals[2]))) {\n        long long th = vals[1][0];\n        th = (th * 1ll * vals[0][i]) % mod;\n        th = (th * 1ll * vals[2][i]) % mod;\n        ans = (ans + th) % mod;\n    }\n    rep(i,1,min(sz(vals[0]), sz(vals[1]))) {\n        long long th = vals[2][0];\n        th = (th * 1ll * vals[0][i]) % mod;\n        th = (th * 1ll * vals[1][i]) % mod;\n        ans = (ans + th) % mod;\n    }\n\n    ps(ans);\n}\n\nint main() {\n\n    solve();\n}\n\nvoid re(int& x) { scanf(\"%d\", &x); }\n\ntemplate<class T, class... Ts> void re(T& t, Ts&... ts) { \n    re(t); re(ts...); \n}\n\nvoid pr(long long x) { printf(\"%lld\", x); }\n\nvoid pr(const char *x) { printf(\"%s\", x); }\n\nvoid ps() { pr(\"\\n\"); }\ntemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n    pr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+10;\nconst int mod=998244353;\nint h[N],e[N],ne[N],idx;\nint f[N],g[N];\nll sum[N][3];\nint sz[N];\nvoid add(int a,int b)\n{\n    e[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\nint inv;\nll qmi(int a,int b)\n{\n    ll ans=1;\n    while(b)\n    {\n        if(b&1)ans=(ans*a)%mod;\n        a=((ll)a*a)%mod;\n        b>>=1;\n    }\n    return ans;\n}\nll gs(int a,int b)\n{\n    return qmi(a,b);\n}\nint main()\n{\n    int n;\n    cin>>n;\n    inv=qmi(qmi(10,18),mod-2);\n    for(int i=0;i<3;i++)\n    {\n        int m;\n        cin>>m;\n        memset(h,-1,sizeof h);\n        idx=0;\n        for(int j=0;j<m;j++)\n        {\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            if(a>b)swap(a,b);\n            add(a,b);\n        }\n        memset(g,0,sizeof g);\n        ll now=gs(10,18*n);\n        for(int j=n;j>=1;j--)\n        {\n            for(int k=h[j];k!=-1;k=ne[k])\n            {\n                g[f[e[k]]]=j;\n            }\n            f[j]=0;\n            while(g[f[j]]==j)f[j]++;\n            // cout<<f[j]<<endl;\n            sz[i]=max(sz[i],f[j]);\n            ll&v=sum[i][f[j]];\n            // cout<<now<<endl;\n            v=(v+now)%mod;\n            now=(now*inv)%mod;\n        }\n    }\n    ll ans=0;\n    // cout<<sz[1]<<endl;\n    for(int i=0;i<=sz[0];i++)\n    {\n        for(int j=0;j<=sz[1];j++)\n        {\n            int k=i^j;\n            ans=(ans+sum[0][i]*sum[1][j]%mod*sum[2][k]%mod)%mod;\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+3;\nconst int M=998244353;\nconst int inv2=(M+1)/2;\nconst int P=1000000000000000000ll%M;\nconst int E=1<<17;\nvector <int> h[maxn];\nint sg[maxn],n,m,cnt[3][E],a[maxn],ans[maxn];\nbool f[maxn];\nvoid add(int &x,int y){\n    x+=y;if (x>=M)x-=M;\n}\nvoid FWT(int a[],int n){\n    for(int d=1;d<n;d<<=1)\n        for(int m=d<<1,i=0;i<n;i+=m)\n            for(int j=0;j<d;j++){\n                int x=a[i+j],y=a[i+j+d];\n                a[i+j]=(x+y)%M,a[i+j+d]=(x-y+M)%M;\n            }\n}\nvoid UFWT(int a[],int n){\n    for(int d=1;d<n;d<<=1)\n        for(int m=d<<1,i=0;i<n;i+=m)\n            for(int j=0;j<d;j++){\n                int x=a[i+j],y=a[i+j+d];\n                a[i+j]=1ll*(x+y)*inv2%M,a[i+j+d]=1ll*(x-y+M)*inv2%M;\n            }\n}\nint main(){\n    scanf(\"%d\",&n);\n    a[0]=1;\n    for (int i=1;i<=n;i++) a[i]=1ll*a[i-1]*P%M;\n    for (int i=0;i<3;i++){\n        scanf(\"%d\",&m);\n        for (int j=1;j<=n;j++) h[j].clear();\n        for (int j=0;j<m;j++){\n            int u,v;scanf(\"%d%d\",&u,&v);\n            if (u>v) swap(u,v);\n            h[u].pb(v);\n        }\n        for (int j=n;j;j--){\n            sg[j]=0;\n            for (auto v:h[j]) f[sg[v]]=1;\n            while (f[sg[j]]) sg[j]++;\n            for (auto v:h[j]) f[sg[v]]=0;\n            add(cnt[i][sg[j]],a[j]);\n        }\n        FWT(cnt[i],E);\n    }\n    for (int i=0;i<E;i++) ans[i]=1ll*cnt[0][i]*cnt[1][i]%M*cnt[2][i]%M;\n    UFWT(ans,E);\n    printf(\"%d\\n\",ans[0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db double\n\nusing namespace std;\nconst int N=1e5+10,mod=998244353;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nvoid ad(int &x,int y){x+=y,x-=x>=mod?mod:0;}\nint fpow(int a,int b){int an=1;while(b){if(b&1) an=1ll*an*a%mod;a=1ll*a*a%mod,b>>=1;}return an;}\nint ginv(int a){return fpow(a,mod-2);}\nint n,pw[N],vs[N],ti,sb[3][N],ans;\nqueue<int> q;\nstruct graph\n{\n\tint to[N],nt[N],hd[N],sg[N],tot;\n\tvoid adde(int x,int y){++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;}\n\tvoid inii()\n\t{\n\t\tfor(int x=n;x;--x)\n\t\t{\n\t\t\t++ti;\n\t\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t\t{\n\t\t\t\tint y=to[i];\n\t\t\t\tvs[sg[y]]=ti;\n\t\t\t}\n\t\t\twhile(vs[sg[x]]==ti) ++sg[x];\n\t\t}\n\t}\n}gg[3];\n\nint main()\n{\n\tn=rd();\n\tpw[0]=1,pw[1]=fpow(10,18);\n\tfor(int i=2;i<=n;++i) pw[i]=1ll*pw[i-1]*pw[1]%mod;\n\tfor(int h=0;h<=2;++h)\n\t{\n\t\tint m=rd();\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tint x=rd(),y=rd();\n\t\t\tif(x>y) swap(x,y);\n\t\t\tgg[h].adde(x,y);\n\t\t}\n\t\tgg[h].inii();\n\t\tfor(int i=1;i<=n;++i) ad(sb[h][gg[h].sg[i]],pw[i]);\n\t}\n\tfor(int i=0;i<=333;++i)\n\t\tfor(int j=0;j<=333;++j)\n\t\t\tad(ans,1ll*sb[0][i]*sb[1][j]%mod*sb[2][i^j]%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<array>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tconstexpr ll mod = 998244353;\n\n\tll n;\n\tcin >> n;\n\tMatrix grundy(3, Array(2000, 0));\n\tREP(i, 3) {\n\t\tll m;\n\t\tcin >> m;\n\t\tGraph g(n);\n\t\tREP(j, m) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\tadd_edge(g, a, b, 1, true, 1);\n\t\t}\n\t\tArray temp(n, 0);\n\t\tfor(int j=g.size()-1;j>=0;j--) {\n\t\t\tset<ll> st;\n\t\t\tll now = 0;\n\t\t\tREP(k, g[j].size()) {\n\t\t\t\tll to = g[j][k].to;\n\t\t\t\tif (to < j)continue;\n\t\t\t\tst.insert(temp[to]);\n\t\t\t\twhile (st.count(now))now++;\n\t\t\t}\n\t\t\ttemp[j] = now;\n\t\t\t(grundy[i][now] += mod_pow(10, 18*(j + 1), mod)) %= mod;\n\t\t}\n\t}\n\tll ans = 0;\n\tREP(i, 1000) {\n\t\tREP(j, 1000) {\n\t\t\tll temp = grundy[0][i] * grundy[1][j] % mod;\n\t\t\t(temp *= grundy[2][(i ^ j)]) %= mod;\n\t\t\t(ans += temp )%= mod;\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[1000100];\n                int inv[1000010];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\nint n;\n\nvector<int> G[100020];\n\nint x[3][256*1024]={};\nint juu[101000*18];\n\nvoid yaru(int r){\n\t\n\tfor(int i=1;i<=n;i++)G[i].clear();\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint y,yy;\n\t\tcin>>y>>yy;\n\t\tif(y>yy)swap(y,yy);\n\t\tG[y].pb(yy);\n\t\t\n\t}\n\t//cout<<\"d\"<<endl;\n\tvector<int> gr(n+10,0);\n\tfor(int i=n;i>0;i--){\n\t\tset<int> se;\n\t\tfor(auto v:G[i])se.insert(gr[v]);\n\t//\tcout<<i<<endl;\n\t\tfor(int j=0;;j++)if(!se.count(j)){\n\t\t\tgr[i]=j;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n//\tcout<<\"d\"<<endl;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tx[r][gr[i]]+=juu[18*i];\n\t\tx[r][gr[i]]%=mod;\n\t}\n//\tfor(int i=0;i<20;i++)cout<<x[r][i]<<\" \";\n//\tcout<<endl;\n}\n\nsigned main(){\ncin.tie(0);\nios::sync_with_stdio(false);\nmod=998244353;\n\t//int n;\n\tcin>>n;\n\tjuu[0]=1;\n\tfor(int i=1;i<=n*18+100;i++)juu[i]=(juu[i-1]*10)%mod;\n\t//cout<<\"d\"<<endl;\n\tyaru(0);\n\tyaru(1);\n\tyaru(2);\n\t//cout<<\"d\"<<endl;\n\tn=1024*256;\n\tfor (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                int X = x[0][j], Y = x[0][j | i];\n            \tx[0][j] = (X + Y)%mod, x[0][j | i] = (X - Y+mod)%mod;\n            }\n        }\n    }\n\tfor (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                int X = x[1][j], Y = x[1][j | i];\n            \tx[1][j] = (X + Y)%mod, x[1][j | i] = (X - Y+mod)%mod;\n            }\n        }\n    }\n\t\n\tfor(int i=0;i<n;i++){\n\t\tx[1][i]*=x[0][i];\n\t\tx[1][i]%=mod;\n\t}\n\t\n\tint ni=beki(2,mod-2,mod);\n    for (int i = 1; i < n; i <<= 1) {\n        for (int j = 0; j < n; j++) {\n            if ((j & i) == 0) {\n                int X = x[1][j], Y = x[1][j | i];\n                x[1][j] = (X + Y)%mod * ni%mod, x[1][j | i] = (X +mod-Y)%mod *ni%mod;\n            }\n        }\n    }\n\t\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tans+=x[1][i]*x[2][i]%mod;\n\t\t\n\t}\n\tcout<<ans%mod<<endl;\n\t\n\t/*\n\tvector<int> ve[3];\n\tve[0]={0,2,1,0};\n\tve[1]={0,0,1,0};\n\tve[2]={0,1,0,0};\n\t\n\tint ans=0;\n\tfor(int i=1;i<=3;i++)for(int j=1;j<=3;j++)for(int k=1;k<=3;k++){\n\t\tif(0==(ve[0][i]^ve[1][j]^ve[2][k]))ans+=beki(10,18*(i+j+k),mod);\n\t}\n\tcout<<ans%mod<<endl;\n\t*/\nreturn 0;\n }\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\nnamespace dfcmd {\n\n    typedef long long LL;\n\n    const int maxn = 500005;\n    const int mod = 998244353;\n    const int di = 1000000000000000000LL % mod;\n\n    int bin[maxn];\n\n    inline void add(int& x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    int n;\n\n    struct myhnb {\n        int m;\n        int sg[maxn];\n        int ss[maxn];\n\n        struct Edge {\n            int to, nxt;\n        } e[maxn];\n\n        int first[maxn];\n\n        inline void add_edge(int u, int v) {\n            static int cnt = 0;\n            if (u > v) {\n                swap(u, v);\n            }\n            e[++cnt].nxt = first[u];\n            first[u] = cnt;\n            e[cnt].to = v;\n        }\n\n        int vis[maxn];\n\n        myhnb() {\n            memset(first, 0, sizeof(first));\n            memset(ss, 0, sizeof(ss));\n            memset(vis, 0, sizeof(vis));\n        }\n\n        inline void Dfs() {\n            for (int now = n; now; --now) {\n                vis[now] = true;\n                set<int> sgg;\n                sgg.clear();\n                for (int i = first[now]; i; i = e[i].nxt) {\n                    sgg.insert(sg[e[i].to]);\n                }\n                sg[now] = 0;\n                while (sgg.count(sg[now])) {\n                    sg[now]++;\n                }\n                add(ss[sg[now]], bin[now]);\n            }\n        }\n\n        inline int& operator [] (int x) {\n            return ss[x];\n        }\n    } d[3];\n\n    int main() {\n        read(n);\n        bin[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            bin[i] = (LL) bin[i - 1] * di % mod;\n        }\n        for (int i = 0; i < 3; ++i) {\n            read(d[i].m);\n            for (int j = 1; j <= d[i].m; ++j) {\n                int u, v;\n                read(u), read(v);\n                d[i].add_edge(u, v);\n            }\n            d[i].Dfs();\n//            cout << \"sg = \";\n//            for (int j = 1; j <= n; ++j) {\n//                cout << d[i].sg[j] << ' ';\n//            }\n//            cout << endl;\n        }\n        int ans = 0;\n        for (int i = 0; i <= 1000; ++i) {\n            for (int j = 0; j <= 1000; ++j) {\n                add(ans, (LL) d[0][i] * d[1][j] % mod * d[2][i ^ j] % mod);\n            }\n        }\n        writeln(ans);\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int MAXN = 1e5 + 11;\nconst int MAXM = 555;\nconst int mod = 998244353;\n#define FOR(i, a, b) for(int i = (a);i <= (b); i++)\n#define ROF(i, a, b) for(int i = (a);i >= (b); i--)\nint n, m;\nint f[3][MAXM], sg[MAXN], mark[MAXM];\nvector<int> G[MAXN];\nvoid Add(int &x, int y){\n    x = x + y - (x + y >= mod ? mod : 0);\n}\nvoid Mu(int &x, int y){\n    x = 1LL * x * y % mod;\n}\nint A(int x, int y){\n    return x + y - (x + y >= mod ? mod : 0);\n}\nint M(int x, int y){\n    return 1LL * x * y % mod;\n}\nint ksm(int base, int x){\n    base %= mod;\n    int ans = 1;\n    while(x){\n        if(x & 1)Mu(ans, base);\n        x >>= 1;\n        Mu(base, base);\n    }\n    return ans;\n}\nint main(){\n    cin>>n;\n    FOR(t, 0, 2){\n        cin>>m;\n        int u, v;\n        memset(sg, -1, sizeof sg);\n        memset(mark, 0, sizeof mark);\n        FOR(i, 1, m){\n            scanf(\"%d%d\", &u, &v);\n            if(u < v)swap(u, v);\n            G[v].push_back(u);\n        }\n        ROF(u, n, 1){\n            for(int v : G[u]){\n                mark[sg[v]] = u;\n            }\n            sg[u] = 0;\n            while(mark[sg[u]] == u)sg[u]++;\n            Add(f[t][sg[u]], ksm((LL)(1e18 + 0) % mod, u));\n            G[u].clear();\n            //printf(\"u=%d sg=%d\\n\", u, sg[u]);\n        }\n    }\n    int ans = 0;\n    FOR(i, 0, 500){\n        FOR(j, 0, 500){\n            Add(ans, M(M(f[0][i],f[1][j]), f[2][i^j]));\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n// #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define FAST std::ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define DECIMAL(n)  std::cout << std::fixed;std::cout << std::setprecision(n);\n#define hell 1000000007\n#define narak 998244353\n#define PI 3.14159265358979323844\n#define mp make_pair\n#define eb emplace_back\n#define pb push_back\n#define fi first \n#define se second\n#define all(v) v.begin(), v.end()\n#define endl \"\\n\"\n#define sqr(a) (a)*(a)\n#define __lcm(m,n) m*(n/__gcd(m,n))\n#define inputarr(a,n) for(int xxx=0;xxx<n;++xxx) cin>>(a)[xxx]\n#define sz(a) (int)a.size()\n#define sl(a) (int)a.length()\n#define display(x) for(auto &a:x) cout<<a<<\" \";cout<<endl\n#define debug cerr<<\"bhau\"<<endl\n#define between(n,a,b) (a<=n&&n<=b)\n#define elasped_time 1.0 * clock() / CLOCKS_PER_SEC \n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n    std::cerr << name << \" : \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n    const char* comma = strchr(names + 1, ',');std::cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y) { \n    if (y < x) \n        x = y; \n}\n\ntemplate<typename T, typename U> static inline void amax(T &x, U y) { \n    if (x < y) \n        x = y; \n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& out, std::pair<T,U> a) {\n    out<<a.fi<<\" \"<<a.se;\n    return out;\n}\n\ntemplate<typename T,typename U> std::istream& operator>>(std::istream& in, std::pair<T,U> &a) {\n    in>>a.fi>>a.se;\n    return in;\n}\n\ninline long long toint(const std::string &s) {std::stringstream ss; ss << s; long long x; ss >> x; return x;}\ninline std::string tostring(long long number) {std::stringstream ss; ss << number; return ss.str();}\ninline std::string tobin(long long x) {return std::bitset<63>(x).to_string();}\n\nstd::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n\n#define ll long long\n#define pii std::pair<int, int>\n#define vi vector<int>  \n#define vvi vector<vi > \n#define vii vector<pii >\n#define point complex<ll>\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n\n/*----------------------Graph Moves----------------*/\n//const int fx[]={+1,-1,+0,+0};\n//const int fy[]={+0,+0,+1,-1};\n//const int fx[]={+0,+0,+1,-1,-1,+1,-1,+1};   // Kings Move\n//const int fy[]={-1,+1,+0,+0,+1,+1,-1,-1};  // Kings Move\n//const int fx[]={-2, -2, -1, -1,  1,  1,  2,  2};  // Knights Move\n//const int fy[]={-1,  1, -2,  2, -2,  2, -1,  1}; // Knights Move\n/*------------------------------------------------*/\n\n//primes for hashing 937,991,1013,1409,1741\n\nusing namespace std;\nusing namespace __gnu_pbds;\nconst int MOD = narak;\nstruct mod_int {\n    int val;\n \n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n \n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n \n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n \n        return x < 0 ? x + m : x;\n    }\n \n    explicit operator int() const {\n        return val;\n    }\n \n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n \n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n \n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n \n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n \n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n \n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n \n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n \n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n \n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n \n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n \n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n \n    mod_int inv() const {\n        return mod_inv(val);\n    }\n \n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n \n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n \n            a *= a;\n            p >>= 1;\n        }\n \n        return result;\n    }\n \n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n    friend istream& operator>>(istream &stream, mod_int &m) {\n        return stream >> m.val;\n    }\n};\nmod_int base;\nconst int maxn=100005;\nvi adj[3][maxn];\nint grundy[3][maxn];\nmod_int g[3][2048];\nvoid meowmeow321()\n{\n    int n;\n    cin>>n;\n    int m[3];\n    cin>>m[0];\n    for (int i = 0; i < m[0]; ++i) {\n    \tint a,b;\n    \tcin>>a>>b;\n    \tif(a>b)swap(a,b);\n    \tadj[0][a].pb(b);\n    }\n    cin>>m[1];\n    for (int i = 0; i < m[1]; ++i) {\n    \tint a,b;\n    \tcin>>a>>b;\n    \tif(a>b)swap(a,b);\n    \tadj[1][a].pb(b);\n    }\n    cin>>m[2];\n    for (int i = 0; i < m[2]; ++i) {\n    \tint a,b;\n    \tcin>>a>>b;\n    \tif(a>b)swap(a,b);\n    \tadj[2][a].pb(b);\n    }\n    for (int j = 0; j < 3; ++j) {\n    \tfor (int i = n; i >=1 ; --i) {\n    \t\tvi vals;\n    \t\tfor(auto u:adj[j][i]){\n    \t\t\tvals.pb(grundy[j][u]);\n    \t\t}\n    \t\tsort(all(vals));\n    \t\tint cur=0;\n    \t\tfor(auto x:vals){\n    \t\t\tif(x==cur){\n    \t\t\t\tcur++;\n    \t\t\t}\n    \t\t\tif(x>cur)break;\n    \t\t}\n    \t\tgrundy[j][i]=cur;\n    \t\tg[j][grundy[j][i]]+=base.pow(i);\n    \t}\n    }\n    mod_int ans=0;\n    for (int i = 0; i < 2048; ++i) {\n    \tfor (int j = 0; j < 2048; ++j) {\n    \t\tans+=g[0][i]*g[1][j]*g[2][i^j];\n    \t}\n    }\n    cout<<ans;\n}\nsigned main()\n{\n    FAST;\n    int testcases=1;\n    base=1;\n    for (int i = 0; i < 18; ++i) {\n    \tbase*=10;\n    }\n    //cin>>testcases;\n    for(int i=0;i<testcases;++i)\n    {\n        meowmeow321();\n    }\n    cerr<<endl<<\"Time Elasped : \"<<elasped_time<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\ttypedef pair<int,int> P;\n\tconst int N=1e5+9,mod=998244353,inv2=(mod+1)/2;\n\tint head[N],nex[N],to[N],cnt;\n\tinline void add(int u,int v){\n\t\tnex[++cnt]=head[u];\n\t\thead[u]=cnt;to[cnt]=v;\n\t}\n\n\tint n,m,pw[N],sg[N],f[1<<20],limit=1,ans[1<<20];\n\tinline void fwt_xor(int *a,int opt){\n\t\tfor(int mid=1;mid<limit;mid<<=1)\n\t\t\tfor(int i=0,R=mid<<1;i<limit;i+=R)\n\t\t\t\tfor(int j=0;j<mid;j++){\n\t\t\t\t\tint x=a[i+j],y=a[i+j+mid];\n\t\t\t\t\ta[i+j]=1LL*(x+y)*(opt?1:inv2)%mod;\n\t\t\t\t\ta[i+j+mid]=(1LL*(x-y)*(opt?1:inv2)%mod+mod)%mod;\n\t\t\t\t}\n\t}\n\tmap<P,bool> mp;\n\tint main(){\n\t\tn=read<int>();\n\t\twhile(limit<=n) limit<<=1;\n\t\tint bas=((long long)1e18)%mod;pw[0]=1;\n\t\tfor(int i=1;i<=n;i++) pw[i]=1LL*pw[i-1]*bas%mod;\n\t\tfor(int i=0;i<limit;i++) ans[i]=1;\n\t\tfor(int num=0;num<3;num++){\n\t\t\tm=read<int>();\n\t\t\tfor(int i=1;i<=n;i++) head[i]=0,sg[i]=0;cnt=0;\n\t\t\tfor(int i=1;i<=m;i++){\n\t\t\t\tint u=read<int>(),v=read<int>();\n\t\t\t\tadd(min(u,v),max(u,v));\n\t\t\t}\n\t\t\tmp.clear();\n\t\t\tfor(int u=n;u>=1;u--){\n\t\t\t\tfor(int i=head[u];i;i=nex[i])\n\t\t\t\t\tif(~sg[to[i]]) mp[P(u,sg[to[i]])]=1;\n\t\t\t\twhile(mp[P(u,sg[u])]) sg[u]++;\n\t\t\t}\n\t\t//\tfor(int i=1;i<=n;i++)\n\t\t//\t\tcout<<sg[i]<<endl;\n\t\t\tfor(int i=0;i<limit;i++) f[i]=0;\n\t\t\tfor(int i=1;i<=n;i++) f[sg[i]]=(f[sg[i]]+pw[i])%mod;\n\t\t\tfwt_xor(f,1);\n\t\t\tfor(int i=0;i<limit;i++) ans[i]=1LL*ans[i]*f[i]%mod;\n\t\t}\n\t\tfwt_xor(ans,0);\n\t\tprintf(\"%d\\n\",ans[0]);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\"graph.in\",\"r\",stdin);\n\tfreopen(\"graph.out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define re register\n#define int long long\n#define pb push_back\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int inf = 1e18 ; \nconst int P = 998244353 ; \nconst int N = 1e5 + 5 ; \nconst int M = 1e5 + 5 ;\nint n, m1, m2, m3, ans[N], h[N], f[N], g[N], f1[N], f2[N], f3[N], Ans ;\nint book[N] ; \nvector<int> G1[N], G2[N], G3[N] ; \nsigned main()\n{\n\tn = gi(), ans[1] = inf % P ; \n\trep( i, 2, n ) ans[i] = ans[i - 1] * ans[1] % P ; \n\t\n\tint x, y ; m1 = gi() ; \n\trep( i, 1, m1 ) x = gi(), y = gi(), ( x < y ) ? G1[x].pb(y) : G1[y].pb(x) ;\n\tm2 = gi() ; \n\trep( i, 1, m2 ) x = gi(), y = gi(), ( x < y ) ? G2[x].pb(y) : G2[y].pb(x) ;\n\tm3 = gi() ; \n\trep( i, 1, m3 ) x = gi(), y = gi(), ( x < y ) ? G3[x].pb(y) : G3[y].pb(x) ;\n\t\n\tfor( re int i = n, l; i >= 1; -- i ) {\n\t\tfor( int j : G1[i] ) book[f1[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f1[i] = l ;\n\t\tfor( int j : G1[i] ) book[f1[j]] = 0 ; \n\t\t\n\t\tfor( int j : G2[i] ) book[f2[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f2[i] = l ;\n\t\tfor( int j : G2[i] ) book[f2[j]] = 0 ; \n\t\t\n\t\tfor( int j : G3[i] ) book[f3[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f3[i] = l ;\n\t\tfor( int j : G3[i] ) book[f3[j]] = 0 ; \n\t\tf[f1[i]] = ( f[f1[i]] + ans[i] ) % P, \n\t\tg[f2[i]] = ( g[f2[i]] + ans[i] ) % P,\n\t\th[f3[i]] = ( h[f3[i]] + ans[i] ) % P ; \n\t}\n\trep( i, 0, 500 ) rep( j, 0, 500 ) rep( k, 0, 500 ) \n\t( ( i ^ j ^ k ) == 0 ) ? Ans = ( Ans + f[i] * g[j] % P * h[k] % P ) % P : Ans = Ans ; \n\t\n\tcout << Ans << endl ; \n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define re register\n#define int long long\n#define pb push_back\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int inf = 1e18 ; \nconst int P = 998244353 ; \nconst int N = 1e5 + 5 ; \nconst int M = 1e5 + 5 ;\nint n, m1, m2, m3, ans[N], h[N], f[N], g[N], f1[N], f2[N], f3[N], Ans ;\nint book[N] ; \nvector<int> G1[N], G2[N], G3[N] ; \nsigned main()\n{\n\tn = gi(), ans[1] = inf % P ; \n\trep( i, 2, n ) ans[i] = ans[i - 1] * ans[1] % P ; \n\t\n\tint x, y ; m1 = gi() ; \n\trep( i, 1, m1 ) x = gi(), y = gi(), ( x < y ) ? G1[x].pb(y) : G1[y].pb(x) ;\n\tm2 = gi() ; \n\trep( i, 1, m2 ) x = gi(), y = gi(), ( x < y ) ? G2[x].pb(y) : G2[y].pb(x) ;\n\tm3 = gi() ; \n\trep( i, 1, m3 ) x = gi(), y = gi(), ( x < y ) ? G3[x].pb(y) : G3[y].pb(x) ;\n\t\n\tfor( re int i = n, l; i >= 1; -- i ) {\n\t\tfor( int j : G1[i] ) book[f1[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f1[i] = l ;\n\t\tfor( int j : G1[i] ) book[f1[j]] = 0 ; \n\t\t\n\t\tfor( int j : G2[i] ) book[f2[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f2[i] = l ;\n\t\tfor( int j : G2[i] ) book[f2[j]] = 0 ; \n\t\t\n\t\tfor( int j : G3[i] ) book[f3[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f3[i] = l ;\n\t\tfor( int j : G3[i] ) book[f3[j]] = 0 ; \n\t\tf[f1[i]] = ( f[f1[i]] + ans[i] ) % P, \n\t\tg[f2[i]] = ( g[f2[i]] + ans[i] ) % P,\n\t\th[f3[i]] = ( h[f3[i]] + ans[i] ) % P ; \n\t}\n\trep( i, 0, 500 ) rep( j, 0, 500 ) rep( k, 0, 500 ) \n\t( ( i ^ j ^ k ) == 0 ) ? Ans = ( Ans + f[i] * g[j] % P * h[k] % P ) % P : Ans = Ans ; \n\t\n\tcout << Ans << endl ; \n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "// -----------------------------------\n// Author     : MatsuTaku\n// Affiliation: Tokushima University\n// Country    : Japan\n// Date       : 03/21/2020\n// -----------------------------------\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 998244353;\nconstexpr ll MAX_GRANDY = 512;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n\n  int N; cin>>N;\n  vector<int> graph[3][N+1];\n  for (int i = 0; i < 3; i++) {\n    int M; cin>>M;\n    for (int m = 0; m < M; m++) {\n      int a,b; cin>>a>>b;\n      if (a > b) swap(a,b);\n      graph[i][a].push_back(b);\n    }\n  }\n\n  vector<ll> pw(N+1);\n  pw[0] = 1;\n  constexpr ll p = ll(1e18)%MOD;\n  for (int i = 1; i <= N; i++) {\n    pw[i] = pw[i-1]*p%MOD;\n  }\n\n  array<array<ll, MAX_GRANDY>, 3> cnt={};\n  for (int i = 0; i < 3; i++) {\n    vector<int> gr(N+1, 0);\n    for (int v = N; v >= 1; v--) {\n      unordered_set<int> ps;\n      for (auto t : graph[i][v])\n        ps.insert(gr[t]);\n      while (ps.count(gr[v]) > 0)\n        ++gr[v];\n      cnt[i][gr[v]] += pw[v];\n      cnt[i][gr[v]] %= MOD;\n    }\n  }\n\n  ll ans = 0;\n  for (int i = 0; i < MAX_GRANDY; i++) for (int j = 0; j < MAX_GRANDY; j++) {\n    ans += cnt[0][i] * cnt[1][j] % MOD * cnt[2][i^j] % MOD;\n    ans %= MOD;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int N = 1e5+100, SQ=512, M=3, MOD = 998244353; \n\nint add(ll a, int b){\n    return (a + b + 2LL*MOD) % MOD;\n}\n \nint mul(ll a, int b){\n    return (a * b) % MOD;\n}\n\nvoid sadd(int &a, int b){\n    a = add(a, b);\n}\n\nvoid smul(int &a, int b){\n    a = mul(a, b);\n}\n\nint bp(int a, int b){\n    if(b == 0)\n        return 1;\n    int x = bp(a, b/2);\n    smul(x, x);\n    return b&1 ? mul(x, a) : x;\n}\n\nvector<int> g[M][N];\nint n, m[M], gr[M][N], cnt[M][SQ], res[SQ];\n\nvoid calc(vector<int> g[], int gr[]){\n\tmemset(gr, 0, N * sizeof gr[0]);\n\tfor(int v=n-1 ; v>=0 ; v--){\n\t\tset<int> st;\n\t\tfor(auto u : g[v])\n\t\t\tst.insert(gr[u]);\n\t\tint mex=0;\n\t\twhile(st.count(mex))\n\t\t\tmex ++;\n\t\tgr[v] = mex;\n\t}\n}\n\nvoid merge(int a[], int b[], int res[]){\n\tmemset(res, 0, SQ*sizeof res[0]);\n\tfor(int i=0 ; i<SQ ; i++)\n\t\tfor(int j=0 ; j<SQ ; j++)\n\t\t\tsadd(res[i^j], mul(a[i], b[j]));\n}\n\nsigned main(){\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\tcin >> n;\n\tfor(int i=0 ; i<M ; i++){\n\t\tcin >> m[i];\n\t\tfor(int j=0 ; j<m[i] ; j++){\n\t\t\tint v, u;cin >> v >> u;v --;u --;\n\t\t\tif(v>u)\n\t\t\t\tswap(v, u);\n\t\t\tg[i][v].push_back(u);\n\t\t}\n\t\tcalc(g[i], gr[i]);\n\t\tfor(int j=0 ; j<n ; j++)\n\t\t\tsadd(cnt[i][ gr[i][j] ], bp(10, 18*(j+1)));\n\t}\n\tmerge(cnt[0], cnt[1], res);\n\tfor(int i=0 ; i<SQ ; i++)\n\t\tcnt[1][i] = res[i];\n\tmerge(cnt[1], cnt[2], res);\n\tcout << res[0] << \"\\n\";\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n#define uint unsigned int\n\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\ninline int lgput(int a, int b) {\n\tint ans = 1;\n\twhile(b > 0) {\n\t\tif(b & 1) ans = (1LL * ans * a) % MOD;\n\t\tb >>= 1;\n\t\ta = (1LL * a * a) % MOD;\n\t}\n\treturn ans;\n}\n\ninline void solve(vector<int> &sum, vector<vector<int>> &g, int n) {\n\tvector<int> grundy(n + 1, 0);\n\tfor(int i = n; i >= 1; i--) {\n\t\tset<int> vals;\n\t\tfor(auto it : g[i]) {\n\t\t\tif(it > i) {\n\t\t\t\tvals.insert(grundy[it]);\n\t\t\t}\n\t\t}\n\t\tint j = 0;\n\t\twhile(vals.find(j) != vals.end()) {\n\t\t\tj++;\n\t\t}\n\t\tgrundy[i] = j;\n\t}\n\tsum.resize(*max_element(grundy.begin(), grundy.end()) + 1);\n\tfor(int i = 1; i <= n; i++) {\n\t\tsum[grundy[i]] = (sum[grundy[i]] + lgput(10, 18 * i)) % MOD;\n\t}\n}\n\nint main() {\n#ifdef HOME\n    ifstream cin(\"A.in\");\n    ofstream cout(\"A.out\");\n#endif\n    int n;\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n   \t// dp0[x][y][z] =  0 (poti sa-l iei pe x, y, z)\n   \t//\t\t\t    != 0 (nu poti sa-l iei)\t\n   \t// dp0[x][y][z] = grundy(x) ^ grundy(y) ^ grundy(z)\n    // grundy(x) <= sqrt(M)\n\n    cin >> n;\n    vector<vector<int>> sum(3);\n    for(int t = 0; t < 3; t++) {\n    \tint m; cin >> m;\n    \tvector<vector<int>> g(n + 1);\n    \twhile(m--) {\n    \t\tint x, y; cin >> x >> y;\n    \t\tg[x].push_back(y);\n    \t\tg[y].push_back(x);\n    \t}\n    \tsolve(sum[t], g, n);\n    }\n    int ans = 0;\n    for(int a = 0; a < (int)sum[0].size(); a++) {\n    \tfor(int b = 0; b < (int)sum[1].size(); b++) {\n    \t\tint c = (a ^ b);\n    \t\tif(c < (int)sum[2].size()) {\n    \t\t\tans = (ans + 1LL * sum[0][a] * (1LL * sum[1][b] * sum[2][c] % MOD)) % MOD;\n    \t\t}\n    \t}\n    }\n    cout << ans;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\nusing namespace chrono;\n\n#ifdef DEBUG\n\t#define LOCAL_INPUT_FILE\n#else\n\t//~ #define USE_FILE_IO\n#endif\n\n#ifdef USE_FILE_IO\n\t#define INPUT_FILE \"input.txt\"\n\t#define OUTPUT_FILE \"output.txt\"\n\t#define cin ____cin\n\t#define cout ____cout\n\tifstream cin(INPUT_FILE);\n\tofstream cout(OUTPUT_FILE);\n#else\n\t#ifdef LOCAL_INPUT_FILE\n\t\t#define cin ____cin\n\t\tifstream cin(\"input.txt\");\n\t#endif\n#endif\n\nconst int infinity = (int)1e9 + 42;\nconst int64_t llInfinity = (int64_t)1e18 + 256;\nconst int mod = 998'244'353; \nconst long double eps = 1e-8;\n\nmt19937_64 randGen(system_clock().now().time_since_epoch().count());\n\ninline void raiseError(string errorCode) {\n\tcerr << \"Error : \" << errorCode << endl;\n\texit(42);\n}\n\ninline int64_t d2m(int64_t a) {\n\tif (a % 2 != 0) a += mod;\n\treturn a/2;\n}\n\ninline void konvolve(vector<int64_t> &v, int l, int r, bool inv) {\n\tif (l == r) {\n\t\treturn;\n\t}\n\tint m = (l + r) / 2;\n\tassert(m-l+1 == r-m);\n\tfor (int i = l, j = m+1; i <= m; ++i, ++j) {\n\t\tint64_t x = v[i], y = v[j];\n\t\tif (inv) {\n\t\t\tv[i] = d2m((x+y) % mod);\n\t\t\tv[j] = d2m((x-y+mod) % mod);\n\t\t} else {\n\t\t\tv[i] = (x+y) % mod;\n\t\t\tv[j] = (x-y+mod) % mod;\n\t\t}\n\t}\n\tkonvolve(v, l, m, inv);\n\tkonvolve(v, m+1, r, inv);\n}\n\nsigned main() {\n\t#ifndef USE_FILE_IO\n\t\tios_base::sync_with_stdio(false);\n\t#endif\n\tint n; cin >> n;\n\t\n\tconst int64_t pw = (int64_t)1e18 % mod;\n\tvector<int64_t> ps(n+1);\n\tps[0] = pw;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tps[i] = ps[i-1] * pw % mod;\n\t}\n\t\n\tint k = 1;\n\twhile (k < n) k *= 2;\n\t\n\tauto graph = [&]() {\n\t\tint m; cin >> m;\n\t\t\n\t\tvector< vector<int> > g(n);\n\t\tset<int, greater<> > avail;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a, b; cin >> a >> b; --a; --b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tavail.insert(i);\n\t\t}\n\t\t\n\t\tvector<int64_t> res;\n\t\tvector<char> used(n, false);\n\t\twhile (!avail.empty()) {\n\t\t\tset<int, greater<> > navail;\n\t\t\tint64_t ans = 0;\n\t\t\tfor (int i : avail) {\n\t\t\t\tif (used[i]) {\n\t\t\t\t\tnavail.insert(i);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int j : g[i]) {\n\t\t\t\t\tused[j] = true;\n\t\t\t\t}\n\t\t\t\tans += ps[i];\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t\tres.push_back(ans);\n\t\t\tfor (int i : avail) {\n\t\t\t\tif (navail.count(i)) continue;\n\t\t\t\tfor (int j : g[i]) {\n\t\t\t\t\tused[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tavail = navail;\n\t\t}\n\t\t\n\t\tres.resize(k, 0);\n\t\tkonvolve(res, 0, k-1, false);\n\t\treturn res;\n\t};\n\t\n\tauto a = graph();\n\tauto b = graph();\n\tauto c = graph();\n\tfor (int i = 0; i < k; ++i) {\n\t\ta[i] *= b[i] * c[i] % mod;\n\t\ta[i] %= mod;\n\t}\n\tkonvolve(a, 0, k-1, true);\n\tcout << a[0] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = 998244353;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nstruct edge { ll to; ll d; };\nvector<vector<edge>> adj[3];\nvector<ll> d[3];\nvector<bool> used[3];\n\nvoid dijkstra(int i, int n) {\n  int N = adj[i].size();\n  auto c = [](const p_ll &x, const p_ll &y){return x.second>y.second;};\n  priority_queue<p_ll, vector<p_ll>, decltype(c)> q(c);\n  q.push(make_pair(n,0));\n  while(q.size()) {\n    p_ll now = q.top(); q.pop();\n    ll np = now.first, nd = now.second;\n    if (nd>d[i][np]) continue;\n    for (auto x: adj[i][np]) {\n      if (d[i][x.to]<=d[i][np]+x.d||used[i][x.to]) continue;\n      q.push(make_pair(x.to, d[i][np]+x.d));\n      d[i][x.to] = d[i][np]+x.d;\n    }\n  }\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nint main() {\n  int N; cin >> N;\n  ll p1 = 716070898;\n  // ll p1 = 10;\n  ll p18[N*3+1] = {}; rep(i,N*3+1) p18[i] = i==0 ? 1 : (p18[i-1]*p1)%MOD;\n  ll r[3][3] = {};\n\n  vector<ll> u1[3], u2[3], u3[3];\n  rep(i,3) {\n    adj[i].resize(N); \n    int M; cin >> M;\n    rep(j,M) {\n      int a, b; cin >> a >> b; a--; b--;\n      adj[i][a].push_back({b,1});\n      adj[i][b].push_back({a,1});\n    }\n\n    d[i].resize(N,LLINF);\n    used[i].resize(N,false);\n    per(j,N) {\n      if (d[i][j]!=LLINF) continue;\n      d[i][j] = 0;\n      dijkstra(i,j);\n    }\n    rep(j,N) {\n      if (d[i][j]%2==0) {\n        u1[i].push_back(j);\n        used[i][j] = true;\n      }\n    }\n\n    rep(j,N) d[i][j] = LLINF;\n    per(j,N) {\n      if (d[i][j]!=LLINF||used[i][j]) continue;\n      d[i][j] = 0;\n      dijkstra(i,j);\n    }\n    rep(j,N) {\n      if (!used[i][j]&&d[i][j]%2==0) {\n        u2[i].push_back(j);\n        used[i][j] = true;\n      }\n    }\n\n    rep(j,N) d[i][j] = LLINF;\n    per(j,N) {\n      if (d[i][j]!=LLINF||used[i][j]) continue;\n      d[i][j] = 0;\n      dijkstra(i,j);\n    }\n    rep(j,N) {\n      if (!used[i][j]&&d[i][j]%2==0) {\n        u3[i].push_back(j);\n        used[i][j] = true;\n      }\n    }\n\n    for (auto x: u1[i]) r[i][0] = (r[i][0]+p18[x+1])%MOD;\n    for (auto x: u2[i]) r[i][1] = (r[i][1]+p18[x+1])%MOD;\n    for (auto x: u3[i]) r[i][2] = (r[i][2]+p18[x+1])%MOD;\n\n  }\n  // rep(i,3) { debug(all(u1[i])); debug(all(u2[i])); cout << endl; }\n\n  ll result = 0;\n  result = (result+(r[0][0]*r[1][0])%MOD*r[2][0])%MOD;\n  result = (result+(r[0][1]*r[1][1])%MOD*r[2][0])%MOD;\n  result = (result+(r[0][1]*r[1][0])%MOD*r[2][1])%MOD;\n  result = (result+(r[0][0]*r[1][1])%MOD*r[2][1])%MOD;\n  result = (result+(r[0][2]*r[1][2])%MOD*r[2][0])%MOD;\n  result = (result+(r[0][2]*r[1][0])%MOD*r[2][2])%MOD;\n  result = (result+(r[0][0]*r[1][2])%MOD*r[2][2])%MOD;\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 100007\n#define modp 998244353\nusing namespace std;\nint base=1;\nint n,m1,m2,m3;\nint n1,n2,n3,val1[Maxn],val2[Maxn],val3[Maxn],val[3*Maxn];\nvector<int> e1[Maxn],e2[Maxn],e3[Maxn];\nbool vis[Maxn],flag[Maxn];\nbool vis1[2007][2007],vis2[2007][2007],vis3[2007][2007];\nvector<pair<int,pair<int,int> > >v;\nvoid solve1()\n{\n    n1=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val1[++n1]=val[i];\n                } else val1[n1]=(val1[n1]+val[i])%modp;\n                for (int j=0;j<(int)e1[i].size();j++)\n                    flag[e1[i][j]]=false;\n            }\n    }\n}\nvoid solve2()\n{\n    n2=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val2[++n2]=val[i];\n                } else val2[n2]=(val2[n2]+val[i])%modp;\n                for (int j=0;j<(int)e2[i].size();j++)\n                    flag[e2[i][j]]=false;\n            }\n    }\n}\nvoid solve3()\n{\n    n3=0;\n    bool chk=true;\n    memset(vis,false,sizeof(vis));\n    while (chk)\n    {\n        memset(flag,true,sizeof(flag));\n        chk=false;\n        for (int i=n;i;i--)\n            if ((!vis[i])&&flag[i])\n            {\n                vis[i]=true;\n                if (!chk)\n                {\n                    chk=true;\n                    val3[++n3]=val[i];\n                } else val3[n3]=(val3[n3]+val[i])%modp;\n                for (int j=0;j<(int)e3[i].size();j++)\n                    flag[e3[i][j]]=false;\n            }\n    }\n}\nint main()\n{\n    for (int i=1;i<=18;i++)\n        base=(10LL*base)%modp;\n    scanf(\"%d\",&n);\n    val[0]=1;\n    for (int i=1;i<=3*n;i++)\n        val[i]=(1LL*val[i-1]*base)%modp;\n    scanf(\"%d\",&m1);\n    for (int i=1;i<=m1;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e1[u].push_back(v);\n        e1[v].push_back(u);\n    }\n    scanf(\"%d\",&m2);\n    for (int i=1;i<=m2;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e2[u].push_back(v);\n        e2[v].push_back(u);\n    }\n    scanf(\"%d\",&m3);\n    for (int i=1;i<=m3;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        e3[u].push_back(v);\n        e3[v].push_back(u);\n    }\n    solve1();\n    solve2();\n    solve3();\n    for (int x=3;x<=n1+n2+n3;x++)\n        for (int i=1;i<=n1;i++)\n            for (int j=1;j<=n2;j++)\n            {\n                int k=x-i-j;\n                if (k>=1&&k<=n3) v.push_back(make_pair(i,make_pair(j,k)));\n            }\n    int ans=0;\n    memset(vis1,true,sizeof(vis1));\n    memset(vis2,true,sizeof(vis2));\n    memset(vis3,true,sizeof(vis3));\n    for (int id=0;id<v.size();id++)\n    {\n        int i=v[id].first;\n        int j=v[id].second.first;\n        int k=v[id].second.second;\n        if (vis1[i][j]&&vis2[j][k]&&vis3[k][i])\n        {\n            vis1[i][j]=false;\n            vis2[j][k]=false;\n            vis3[k][i]=false;\n            int tmp=(1LL*val1[i]*val2[j])%modp;\n            tmp=(1LL*tmp*val3[k])%modp;\n            ans=(ans+tmp)%modp;\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=14e4,S=131072,mo=998244353,W=716070898;\nint n,mi[N],b[N],i;\ninline void FWT(int*a){\n\tint i,j,k,m;\n\tfor(i=2;i<=S;i<<=1)for(j=0,m=i>>1;j<S;j+=i)for(k=0;k<m;++k){\n\t\tint x=a[j+k],y=a[j+k+m];\n\t\ta[j+k]=(x+y)%mo;a[j+k+m]=(x+mo-y)%mo;\n\t}\n}\nstruct graph{\n\tvector<int>e[N];\n\tint sg[N],a[N];\n\tvoid ini(){\n\t\tint i,x,y,m;\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=1;i<=m;++i){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tif(x>y)swap(x,y);e[x].push_back(y);\n\t\t}\n\t\tfor(i=n;i;--i){\n\t\t\tstatic int buc[N];int d=e[i].size();\n\t\t\tmemset(buc,0,d+2<<2);\n\t\t\tfor(int j:e[i])if(sg[j]<d+2)++buc[sg[j]];\n\t\t\tfor(sg[i]=0;buc[sg[i]];++sg[i]);\n\t\t\ta[sg[i]]=(a[sg[i]]+mi[i])%mo;\n\t\t}\n\t\tFWT(a);\n\t}\n}g[3];\nint main(){\n\tfor(i=*mi=1;i<N;++i)mi[i]=1ll*mi[i-1]*W%mo;\n\tscanf(\"%d\",&n);for(i=0;i<3;++i)g[i].ini();\n\tmemcpy(b,g[0].a,sizeof b);\n\tfor(i=0;i<S;++i)b[i]=1ll*b[i]*g[1].a[i]%mo;\n\tfor(i=0;i<S;++i)b[i]=1ll*b[i]*g[2].a[i]%mo;\n\tFWT(b);\n\tprintf(\"%lld\\n\",998236737ll*b[0]%mo);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iomanip>\n//#include <chrono>\n//#include <random>\n \n#define fio ios_base::sync_with_stdio(false)\n#define pdl cout << \"*\" << endl\n#define MOD 1000000007\n#define INF 1000000000\n#define INFLL 1000000000000000000ll\n#define long int64_t\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1> void __f(const char* name, Arg1&& arg1){ std::cerr << name << \" : \" << arg1 << '\\n'; }\ntemplate <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args)\n{ const char* comma = strchr(names + 1, ','); std::cerr.write(names, comma - names) << \" : \" << arg1 << \" | \"; __f(comma+1, args...); }\n \nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//uniform_int_distribution<> dis(0, INF<<1);\n\n#define mul(a, b, c) ((((a * 1ll * b) % mod) * 1ll * c) % mod)\n\nconst int N = 100001;\nconst int M = 3;\nconst int A = 10;\nconst int B = 18;\nconst int mod = 998244353;\n\nint modexp(int a, int b)\n{\n\tint r = 1;\n\twhile(b)\n\t{\n\t\tif(b & 1)\n\t\t\tr = (r * 1ll * a) % mod;\n\t\ta = (a * 1ll * a) % mod;\n\t\tb >>= 1;\n\t}\n\treturn r;\n}\n\nvector<int> gr[M][N];\nint gn[M][N], ng[M], gs[M][N];\nbool oc[N];\n\nint main()\n{\n\tfio;\n\tint n;\n\tcin >> n;\n\tfor(int i=0; i<M; i++)\n\t{\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int j=0; j<m; j++)\n\t\t{\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tif(u > v)\n\t\t\t\tswap(u, v);\n\t\t\tgr[i][u].push_back(v);\n\t\t}\n\t}\n\tfor(int i=0; i<M; i++)\n\t{\n\t\tfor(int j=n; j; j--)\n\t\t{\n\t\t\tfor(int it : gr[i][j])\n\t\t\t\toc[gn[i][it]] = true;\n\t\t\tint mex = 1;\n\t\t\twhile(oc[mex])\n\t\t\t\tmex++;\n\t\t\tgn[i][j] = mex;\n\t\t\tfor(int it : gr[i][j])\n\t\t\t\toc[gn[i][it]] = false;\n\t\t\tgs[i][mex] += modexp(A, B * j);\n\t\t\tgs[i][mex] %= mod;\n\t\t\tng[i] = max(ng[i], mex);\n\t\t}\n\t}\n\tint l = 0;\n\tfor(int i=0; i<M; i++)\n\t\tl = max(l, ng[i]);\n\tint ans = mul(gs[0][1], gs[1][1], gs[2][1]);\n\tfor(int i=2; i<=l; i++)\n\t\tans = (ans + 0ll + mul(gs[0][1], gs[1][i], gs[2][i]) + mul(gs[0][i], gs[1][1], gs[2][i]) + mul(gs[0][i], gs[1][i], gs[2][1])) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define LL long long\n#define ULL unsigned long long \n#define y second\n#define sqr(x) ((x)*(x))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pdd pair<double,double>\n#define MEM(x) memset(x,0,sizeof(x))\n#define pi acos(-1)\n#define MEMS(x) memset(x,-1,sizeof(x))\nusing namespace std;\nint val[3][100005];\nvector<int> v[3][100005];\nvector<int> num[3][100005];\nint number=716070898;\nint mod=998244353;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\n//int val[10][10][10];\nint main(){ \n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 0;i<3;i++){\n        int m;\n        scanf(\"%d\",&m);\n        for(int j =0;j<m;j++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            if(x>y)swap(x,y);\n            v[i][x].pb(y);\n        }\n        for(int j = n;j>=1;j--){\n            vector<int> arr;\n            for(auto it:v[i][j]){\n                arr.pb(val[i][it]);\n            }\n            sort(arr.begin(),arr.end());\n            arr.resize(unique(arr.begin(),arr.end())-arr.begin());\n            val[i][j]=arr.size();\n            for(int k = 0;k<arr.size();k++){\n                if(arr[k]!=k){\n                    val[i][j]=k;\n                    break;\n                }\n            }\n           // if(val[i][j]<2){\n            num[i][val[i][j]].pb(j);\n            //}\n        }\n    }\n    LL ans=0;\n    LL val[3][100005];//,b[2]={0,0},c[2]={0,0};\n    LL sum[3];\n    MEM(val);\n    MEM(sum);\n    for(int i =0;i<3;i++){\n        for(int j=0;j<100005;j++){\n            for(auto it:num[i][j]){\n                val[i][j]+=f_pow(number,it);\n                val[i][j]%=mod;\n            }\n            if(j>1)sum[i]+=val[i][j],sum[i]%=mod;\n        }\n    }\n    ans+=val[0][0]*val[1][0]%mod*val[2][0]%mod;\n    for(int j=1;j<100005;j++){\n        ans+=val[0][0]*val[1][j]%mod*val[2][j]%mod;\n        ans+=val[0][j]*val[1][0]%mod*val[2][j]%mod;\n        ans+=val[0][j]*val[1][j]%mod*val[2][0]%mod;\n       /* if(j>1){\n            ans-=val[0][1]*val[1][j]%mod*val[2][j]%mod;\n            ans-=val[0][j]*val[1][1]%mod*val[2][j]%mod;\n            ans-=val[0][j]*val[1][j]%mod*val[2][1]%mod;\n        }*/\n        ans%=mod;\n    }\n    for(int j = 2;j<100005;j++){\n        ans+=val[0][1]*val[1][j]%mod*val[2][j+1]%mod;\n        ans+=val[0][1]*val[2][j]%mod*val[1][j+1]%mod;\n        ans+=val[1][1]*val[0][j]%mod*val[2][j+1]%mod;\n        ans+=val[1][1]*val[2][j]%mod*val[0][j+1]%mod;\n        ans+=val[2][1]*val[1][j]%mod*val[0][j+1]%mod;\n        ans+=val[2][1]*val[0][j]%mod*val[1][j+1]%mod;\n        ans%=mod;\n\n    }\n    ans=(ans%mod+mod)%mod;\n    printf(\"%lld\\n\",ans);\n    /*\n    for(int i = 0;i<num[0][0].size();i++){\n        a[0]+=f_pow(number,num[0][0][i]);\n        a[0]%=mod;\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][0][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][1][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][0][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][1][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }*/\n    //printf(\"%lld\\n\",ans);\n}\n/*\n\n5\nAACCMMAA\nA\nAA\nMM\nACA\nACMAA\n\n\n5\n0 9 7 1 100\n-1 0 -1 -1 91\n-1 5 0 -1 96\n-1 8 9 0 99\n-1 -1 -1 -1 0\n3 4\n3 5\n5 6\n5 7\n3 or 4\n3 or 5\n5 or 6\n5 or 7\n\ndp[x]=max(dp[x-w_i*j]+j*t_i-delta t_i*j*(j-1)/2)\ndp[x]=max(dp[j]+x*t_i-j*t_i-delta t_i*(x-j)*(x-j-1)/2)\ndp[x]=max(dp[j]-j*t_i-delta t_i *(j^2/2+j/2) - \n        delta t_i * xj + x*t_i + delta t_i * (x^2/2-x/2))\ndp[x]=max(dp[j] + g(j) - delta t_i *xj + w(i) )\ng(j)= dp[j]-j*t_i-delta t_i *(j^2/2+j/2)\nw(i)=  x*t_i + delta t_i * (x^2/2-x/2)\nx^2/2 -xj -x/2  +j^2/2 +j/2\n*/\n\n/*\n \n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005, M = 200005;\nconst long long mod = 998244353ll, inv2 = mod + 1 >> 1, base = 1000000000000000000ll;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n, m1, m2, m3, f1[N], f2[N], f3[N];\nvector<int> g1[N], g2[N], g3[N];\nbool tmp[N];\n\nlong long x1[N << 1], x2[N << 1], x3[N << 1], x[N << 1];\nvoid fwt (long long *f, int len, int ty) {\n\tfor (int i = 1; i < len; i <<= 1) {\n\t\tfor (int j = 0; j < len; j += (i << 1)) {\n\t\t\tfor (int k = 0; k < i; k++) {\n\t\t\t\tlong long u = f[j + k], v = f[i + j + k];\n\t\t\t\tf[j + k] = (u + v) % mod;\n\t\t\t\tf[i + j + k] = (u + mod - v) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tif (ty < 0) {\n\t\tlong long coef = 1ll;\n\t\tfor (int i = 1; i < len; i <<= 1) coef = coef * inv2 % mod;\n\t\tfor (int i = 0; i < len; i++) f[i] = f[i] * coef % mod;\n\t}\n}\n\nint main () {\n\tread(n);\n\tfor (int i = 0; i <= n; i++) tmp[i] = false;\n\n\tread(m1);\n\tfor (int i = 1; i <= m1; i++) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\tg1[min(u, v)].push_back(max(u, v));\n\t}\n\n\tread(m2);\n\tfor (int i = 1; i <= m2; i++) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\tg2[min(u, v)].push_back(max(u, v));\n\t}\n\n\tread(m3);\n\tfor (int i = 1; i <= m3; i++) {\n\t\tint u, v;\n\t\tread(u), read(v);\n\t\tg3[min(u, v)].push_back(max(u, v));\n\t}\n\n\tfor (int i = n; i; i--) {\n\t\tf1[i] = 0;\n\t\tfor (int j = 0; j < g1[i].size(); j++) tmp[f1[g1[i][j]]] = true;\n\t\twhile (tmp[f1[i]]) f1[i]++;\n\t\tfor (int j = 0; j < g1[i].size(); j++) tmp[f1[g1[i][j]]] = false;\n\t}\n\n\tfor (int i = n; i; i--) {\n\t\tf2[i] = 0;\n\t\tfor (int j = 0; j < g2[i].size(); j++) tmp[f2[g2[i][j]]] = true;\n\t\twhile (tmp[f2[i]]) f2[i]++;\n\t\tfor (int j = 0; j < g2[i].size(); j++) tmp[f2[g2[i][j]]] = false;\n\t}\n\n\tfor (int i = n; i; i--) {\n\t\tf3[i] = 0;\n\t\tfor (int j = 0; j < g3[i].size(); j++) tmp[f3[g3[i][j]]] = true;\n\t\twhile (tmp[f3[i]]) f3[i]++;\n\t\tfor (int j = 0; j < g3[i].size(); j++) tmp[f3[g3[i][j]]] = false;\n\t}\n\n\tint U = 1;\n\twhile (U < n) U <<= 1;\n\tfor (int i = 0; i < U; i++) x1[i] = x2[i] = x3[i] = 0ll;\n\n\tlong long pw = 1ll;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpw = pw * (base % mod) % mod;\n\t\tx1[f1[i]] = (x1[f1[i]] + pw) % mod;\n\t}\n\n\tpw = 1ll;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpw = pw * (base % mod) % mod;\n\t\tx2[f2[i]] = (x2[f2[i]] + pw) % mod;\n\t}\n\n\tpw = 1ll;\n\tfor (int i = 1; i <= n; i++) {\n\t\tpw = pw * (base % mod) % mod;\n\t\tx3[f3[i]] = (x3[f3[i]] + pw) % mod;\n\t}\n\n\tfwt(x1, U, 1), fwt(x2, U, 1), fwt(x3, U, 1);\n\tfor (int i = 0; i < U; i++) x[i] = x1[i] * x2[i] % mod * x3[i] % mod;\n\tfwt(x, U, -1);\n\twrite(x[0]), putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int W = 716070898, P = 998244353, I2 = 499122177;\n\nvoid add(int&x , int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int N;\n  cin >> N;\n  vector<int> pw(N);\n  pw[0] = 1;\n  for (int i = 1; i < N; ++i) pw[i] = pw[i - 1] * (ll)W % P;\n  int l = 0;\n  while ((1 << l) < N) ++l;\n  vector<int> SG1, SG2, SG3;\n  auto getSG = [&]() {\n    vector<int> ret(N);\n    int M;\n    cin >> M;\n    vector<vector<int>> G(N);\n    while (M--) {\n      int u, v;\n      cin >> u >> v;\n      --u; --v;\n      if (u > v) swap(u, v);\n      G[u].push_back(v);\n    }\n    for (int i = N - 1; i >= 0; --i) {\n      vector<bool> vis(G[i].size() + 1);\n      for (int v : G[i])\n        if (v <= G[i].size())\n          vis[ret[v]] = true;\n      while (vis[ret[i]]) ++ret[i];\n    }\n    return ret;\n  };\n  SG1 = getSG();\n  SG2 = getSG();\n  SG3 = getSG();\n  auto toWt = [&](const vector<int>& SG) {\n    vector<int> ret(1 << l);\n    for (int i = 0; i < N; ++i)\n      add(ret[SG[i]], pw[i]);\n    return ret;\n  };\n  auto A1 = toWt(SG1), A2 = toWt(SG2), A3 = toWt(SG3);\n  auto FWT = [&](vector<int>& A) -> void {\n    for (int i = 0; i < l; ++i)\n      for (int j = 0; j < (1 << l); ++j)\n        if (!((j >> i) & 1)) {\n          int a0 = A[j], a1 = A[j ^ (1 << i)];\n          A[j] = (a0 + a1) % P;\n          A[j ^ (1 << i)] = (a0 - a1 + P) % P;\n        }\n  };\n  FWT(A1);\n  FWT(A2);\n  FWT(A3);\n  for (int i = 0; i < (1 << l); ++i)\n    A1[i] = A1[i] * (ll)A2[i] % P * A3[i] % P;\n  FWT(A1);\n  int ans = A1[0] * (ll)W % P * W % P * W % P;\n  for (int i = 0; i < l; ++i)\n    ans = ans * (ll)I2 % P;\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int S = 2048;\nconst int N = 5e5 + 7;\nconst int MX = 998244353;\n\nint n;\nvector <int> G[N];\n\nint last[N];\nint color[N];\n\nint dp[N];\nint cur[N];\n\nint tmp[N];\nint pre[N];\n\nint getMagic(){\n\tint cur = 1000 * 1000 * 1000 % MX;\n\treturn 1LL * cur * cur % MX;\n}\n\nvoid add(int &a, int b){\n\ta += b;\n\tif(a >= MX)\n\t\ta -= MX;\n}\n\nvoid getMex(int u){\n\tfor(auto v: G[u])\n\t\tif(v > u)\n\t\t\tlast[color[v]] = u;\n\t\n\tfor(int t = 0; true; ++t)\n\t\tif(last[t] != u){\n\t\t\tcolor[u] = t;\n\t\t\tbreak;\n\t\t}\n}\n\nvoid solve(int id){\n\tint m;\n\tscanf(\"%d\", &m);\n\t\n\tlast[0] = n + 1;\n\tfor(int i = 1; i <= n; ++i){\n\t\tG[i].clear();\n\t\tcolor[i] = 0;\n\t\tlast[i] = n + 1;\n\t}\n\t\n\tfor(int i = 1; i <= m; ++i){\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\t\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tfor(int i = 0; i < S; ++i)\n\t\tcur[i] = 0;\n\t\n\tfor(int i = n; i >= 1; --i){\n\t\tgetMex(i);\n\t\tadd(cur[color[i]], pre[i]);\n\t}\n\t\n\tfor(int i = 0; i < S; ++i){\n\t\ttmp[i] = dp[i];\n\t\tdp[i] = 0;\n\t}\n\t\n\tfor(int i = 0; i < S; ++i)\n\t\tfor(int j = 0; j < S; ++j)\n\t\t\tadd(dp[i ^ j], 1LL * tmp[i] * cur[j] % MX);\n}\n\nint main(){\n\tpre[0] = 1;\n\tfor(int i = 1; i < N; ++i)\n\t\tpre[i] = 1LL * pre[i - 1] * getMagic() % MX;\n\tdp[0] = 1;\n\n\tscanf(\"%d\", &n);\n\tfor(int t = 1; t <= 3; ++t)\n\t\tsolve(t);\n\t\n\tprintf(\"%d\\n\", dp[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int MAXN = 1e5 + 11;\nconst int MAXM = 555;\nconst int mod = 998244353;\n#define FOR(i, a, b) for(int i = (a);i <= (b); i++)\n#define ROF(i, a, b) for(int i = (a);i >= (b); i--)\nint n, m;\nint f[3][MAXM], sg[MAXN], mark[MAXM];\nvector<int> G[MAXN];\nvoid Add(int &x, int y){\n    x = x + y - (x + y >= mod ? mod : 0);\n}\nvoid Mu(int &x, int y){\n    x = 1LL * x * y % mod;\n}\nint A(int x, int y){\n    return x + y - (x + y >= mod ? mod : 0);\n}\nint M(int x, int y){\n    return 1LL * x * y % mod;\n}\nint ksm(int base, int x){\n    base %= mod;\n    int ans = 1;\n    while(x){\n        if(x & 1)Mu(ans, base);\n        x >>= 1;\n        Mu(base, base);\n    }\n    return ans;\n}\nint main(){\n    cin>>n;\n    FOR(t, 0, 2){\n        cin>>m;\n        int u, v;\n        memset(sg, -1, sizeof sg);\n        memset(mark, 0, sizeof mark);\n        FOR(i, 1, m){\n            scanf(\"%d%d\", &u, &v);\n            if(u < v)swap(u, v);\n            G[v].push_back(u);\n        }\n        ROF(u, n, 1){\n            for(int v : G[u]){\n                mark[sg[v]] = u;\n            }\n            sg[u] = 0;\n            while(mark[sg[u]] == u)sg[u]++;\n            Add(f[t][sg[u]], ksm((LL)(1e18 + 0) % mod, u));\n            G[u].clear();\n            //printf(\"u=%d sg=%d\\n\", u, sg[u]);\n        }\n    }\n    int ans = 0;\n    FOR(i, 0, 500){\n        FOR(j, 0, 500){\n            Add(ans, M(M(f[0][i],f[1][j]), f[2][i^j]));\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nconst ll mod = 998244353;\nconst ll x = 716070898;\n\nvector <int> G[101010];\nvector <ll> V[3];\nset <int> S1, S2;\nll C[101010], ans;\nint n;\n\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint m, u, v, i, j, k;\n\tll t, s;\n\n\tcin >> n;\n\n\tfor(i = 1, t = x; i <= n; i ++){\n\t\tC[i] = t; t = t * x % mod;\n\t}\n\n\tfor(i = 0; i < 3; i ++){\n\t\tfor(j = 1; j <= n; j ++){\n\t\t\tG[j].clear();\n\t\t\tS1.insert(j);\n\t\t}\n\t\tcin >> m;\n\t\tfor(; m --; ){\n\t\t\tcin >> u >> v;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tfor(; !S1.empty(); ){\n\t\t\tfor(s = 0; !S1.empty(); ){\n\t\t\t\tu = *prev(S1.end()); S1.erase(u);\n\t\t\t\ts = (s + C[u]) % mod;\n\t\t\t\tfor(int &t: G[u]){\n\t\t\t\t\tif(S1.find(t) != S1.end()){\n\t\t\t\t\t\tS1.erase(t);\n\t\t\t\t\t\tS2.insert(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tV[i].push_back(s);\n\t\t\tswap(S1, S2);\n\t\t}\n\t}\n\n\tfor(i = 0; i < V[0].size(); i ++){\n\t\tfor(j = 0; j < V[1].size(); j ++){\n\t\t\tk = i ^ j;\n\t\t\tif(k < V[2].size()){\n\t\t\t\tans = (ans + V[0][i] * V[1][j] % mod * V[2][k]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\n\n\nint xy[710][710],xz[710][710],yz[710][710];\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vector<int> d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,310000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g1[i]){\n            if(e>i)se.insert(d1[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d1[i]=gr;\n        D1[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g2[i]){\n            if(e>i)se.insert(d2[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d2[i]=gr;\n        D2[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g3[i]){\n            if(e>i)se.insert(d3[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d3[i]=gr;\n        D3[gr] += P[i];\n    }\n    vec a,b;\n    mint ans;\n    int k1=0,k2=0,k3=0;\n    rep(i,700){\n        rep(j,700){\n            rep(k,700){\n                if(i>n or j>n or k>n)break;\n                if(xy[i][j]==0 and xz[i][k]==0 and yz[j][k]==0) {\n                    ans+=D1[i]*D2[j]*D3[k];\n                    xy[i][j]=1;\n                    xz[i][k]=1;\n                    yz[j][k]=1;\n                } \n            }\n        }\n    }\n\n    cout<<ans.a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n\nconstexpr ll MOD = 998244353;\nconstexpr int IMAX = 450;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    vb usedrow(IMAX, false);\n    vector<vb> used(IMAX, usedrow);\n\n    vector<tuple<int, int, int>> good;\n    for (int i=0;i<IMAX;i++) {\n        good.push_back({0, i , i});\n        // cout << 0 << \" \" << i << \" \" << i << endl;\n    }\n\n    for (int i=1;i<IMAX;i++) {\n        // cout << \"i = \" << i << endl;\n        int j = i+1;\n        while (j < IMAX) {\n            while (j < IMAX && used[i][j]) {\n                j++;\n            }\n            if (j < IMAX) {\n                int k = j+1;\n                while (k < IMAX && (used[i][k] || used[j][k])) {\n                    k++;\n                }\n                if (k < IMAX) {\n                    good.push_back({i, j, k});\n                    // cout << i << \" \" << j << \" \" << k << endl;\n                    used[i][j] = true;\n                    used[i][k] = true;\n                    used[j][k] = true;\n                }\n            }\n            j++;\n        }\n    }\n\n    // cout << good.size() << endl;\n\n    int N;\n    cin >> N;\n    vvi adj1(N);\n    vvi adj2(N);\n    vvi adj3(N);\n\n    int M1;\n    cin >> M1;\n    for (int i=0;i<M1;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj1[u].push_back(v);\n        adj1[v].push_back(u);\n    }\n\n    int M2;\n    cin >> M2;\n    for (int i=0;i<M2;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj2[u].push_back(v);\n        adj2[v].push_back(u);\n    }\n\n    int M3;\n    cin >> M3;\n    for (int i=0;i<M3;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj3[u].push_back(v);\n        adj3[v].push_back(u);\n    }\n\n    vi label1(N, 0);\n    vi label2(N, 0);\n    vi label3(N, 0);\n\n    vb levels(IMAX, false);\n    int max_label = 0;\n    for (int i=N-1;i>=0;i--) {\n        for (int nbr : adj1[i]) {\n            if (nbr > i) levels[label1[nbr]] = true;\n            \n        }\n        while(levels[label1[i]]) label1[i]++;\n        max_label = max(max_label, label1[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj2[i]) {\n            if (nbr > i) levels[label2[nbr]] = true;\n            \n        }\n        while(levels[label2[i]]) label2[i]++;\n        max_label = max(max_label, label2[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj3[i]) {\n            if (nbr > i) levels[label3[nbr]] = true;\n            \n        }\n        while(levels[label3[i]]) label3[i]++;\n        max_label = max(max_label, label3[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n    }\n\n    // for (int i=0;i<N;i++) {\n    //     cout << i << \" \" << label1[i] << \" \" << label2[i] << \" \" << label3[i] << endl;\n    // }\n\n    vector<modnum<MOD>> wts1(IMAX+1, 0);\n    vector<modnum<MOD>> wts2(IMAX+1, 0);\n    vector<modnum<MOD>> wts3(IMAX+1, 0);\n\n    modnum<MOD> base = modnum<MOD>(10).pow(18);\n    for (int i=0;i<N;i++) {\n        wts1[label1[i]] += base.pow(i+1);\n        wts2[label2[i]] += base.pow(i+1);\n        wts3[label3[i]] += base.pow(i+1);\n    }\n\n    // cout << \"weights: \" << endl;\n    // for (int i=0;i<5;i++) {\n    //     cout << i << \" \" << wts1[i] << \" \" << wts2[i] << \" \" << wts3[i] << endl;\n    // }\n\n    modnum<MOD> ans = 0;\n\n    for (auto gtrip : good) {\n        int x = get<0>(gtrip);\n        int y = get<1>(gtrip);\n        int z = get<2>(gtrip);\n\n        if (x == y  && x == z) {\n            ans += wts1[x] * wts2[y] * wts3[z];\n        } else if (y == z) {\n            ans += wts1[x] * wts2[y] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[y];\n            ans += wts1[y] * wts2[y] * wts3[x];\n        } else {\n            ans += wts1[x] * wts2[y] * wts3[z];\n            ans += wts1[x] * wts2[z] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[z];\n            ans += wts1[y] * wts2[z] * wts3[x];\n            ans += wts1[z] * wts2[x] * wts3[y];\n            ans += wts1[z] * wts2[y] * wts3[x];\n        }\n    }\n\n    cout << ans << endl;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// BEGIN CUT HERE\ntemplate <typename T>\nclass Vector : public vector<T> {\n    using parent = vector<T>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const T& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<T> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    const T& operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    T& operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<T>& operator=(Vector<T>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<T>& operator=(const Vector<T>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\ntemplate <>\nclass Vector<bool> : public vector<bool> {\n    using parent = vector<bool>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<bool> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    parent::const_reference operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    parent::reference operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<bool>& operator=(const Vector<bool>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\n#ifdef LOCAL\n#define vec Vector\n#else\n// END CUT HERE\n#define vec vector\n// BEGIN CUT HERE\n#endif\n// END CUT HERE\n\nusing vi = vec<int>;\n\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) {\n        allocate(n);\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i = 0; i < n; ++i) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr3d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int shift;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    const T& operator()(int i1, int i2, int i3) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    arr2d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr2d<T>(b + at * shift, d2, d3);\n    }\n\n    vector<vector<vector<T>>> view() {\n        vector<vector<vector<T>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr4d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int d4;\n    int shift1;\n    int shift2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n    }\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    int dim4() const {\n        return d4;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3, int i4) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    const T& operator()(int i1, int i2, int i3, int i4) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    arr3d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr3d<T>(b + at * shift1, d2, d3, d4);\n    }\n\n    vector<vector<vector<vector<T>>>> view() {\n        vector<vector<vector<vector<T>>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n);\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vec<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vec<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        if (c == EOF) {\n            exhausted = true;\n        }\n        return c;\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    ll readLong() {\n        return readInteger<ll>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return string(all(res));\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i = 0; i < n; i++) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return string(all(res));\n    }\n\n    double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    bool isExhausted() { return exhausted; }\n\n    void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ndouble Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\nint Input::readType() {\n    return readInt();\n}\n\ntemplate <>\nll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\nchar Input::readType() {\n    return readChar();\n}\n\ntemplate <>\nstring Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream& out = cout;\n\n    template <typename T>\n    void printSingle(const T& value) {\n        out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vec<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                out << array(i, j);\n                if (j + 1 != m) {\n                    out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    void printSingle(const pair<T, U>& value) {\n        out << value.first << ' ' << value.second;\n    }\n\npublic:\n    Output() {//ostream& out) : out(out) {\n        out << fixed << setprecision(20);\n    }\n\n    void print() {}\n\n    template <typename T, typename...Targs>\n    void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            out << ' ';\n            print(args...);\n        }\n    }\n\n    template <typename...Targs>\n    void printLine(const Targs... args) {\n        print(args...);\n        out << '\\n';\n    }\n\n    void flush() {\n        out.flush();\n    }\n};\n\nOutput out;\n\n\ntemplate <typename W, typename C>\nclass WeightedFlowEdge {\nprivate:\n    WeightedFlowEdge<W, C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    C capacity;\n    int id;\n\n    WeightedFlowEdge(int from, int to, W weight, C capacity) : from(from), to(to), weight(weight), capacity(capacity) {\n        reverseEdge = new WeightedFlowEdge(this);\n    }\n\n    WeightedFlowEdge<W, C>* transposed() { return nullptr; }\n\n    WeightedFlowEdge<W, C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    WeightedFlowEdge(WeightedFlowEdge<W, C>* reverse) : from(reverse->to), to(reverse->from), weight(-reverse->weight),\n                                                        capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename C>\nclass FlowEdge {\nprivate:\n    FlowEdge<C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    C capacity;\n    int id;\n\n    FlowEdge(int from, int to, C capacity) : from(from), to(to), capacity(capacity) {\n        reverseEdge = new FlowEdge(this);\n    }\n\n    FlowEdge<C>* transposed() { return nullptr; }\n\n    FlowEdge<C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    FlowEdge(FlowEdge<C>* reverse) : from(reverse->to), to(reverse->from), capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename W>\nclass WeightedEdge {\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    WeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n    }\n\n    WeightedEdge<W>* transposed() { return nullptr; }\n\n    WeightedEdge<W>* reverse() { return nullptr; }\n};\n\ntemplate <typename W>\nclass BiWeightedEdge {\nprivate:\n    BiWeightedEdge<W>* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    BiWeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n        transposedEdge = new BiWeightedEdge(this);\n    }\n\n    BiWeightedEdge<W>* transposed() { return transposedEdge; }\n\n    BiWeightedEdge<W>* reverse() { return nullptr; }\n\nprivate:\n    BiWeightedEdge(BiWeightedEdge<W>* transposed) : from(transposed->to), to(transposed->from),\n                                                    weight(transposed->weight) {\n        transposedEdge = transposed;\n    }\n};\n\nclass BaseEdge {\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BaseEdge(int from, int to) : from(from), to(to) {\n    }\n\n    BaseEdge* transposed() { return nullptr; }\n\n    BaseEdge* reverse() { return nullptr; }\n};\n\nclass BiEdge {\nprivate:\n    BiEdge* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BiEdge(int from, int to) : from(from), to(to) {\n        transposedEdge = new BiEdge(this);\n    }\n\n    BiEdge* transposed() { return transposedEdge; }\n\n    BiEdge* reverse() { return nullptr; }\n\nprivate:\n    BiEdge(BiEdge* transposed) : from(transposed->to), to(transposed->from) {\n        transposedEdge = transposed;\n    }\n};\n\ntemplate <class Edge>\nclass Graph {\npublic:\n    int vertexCount;\n    int edgeCount = 0;\nprivate:\n    vec<vec<Edge*>> edges;\n\npublic:\n    Graph(int vertexCount) : vertexCount(vertexCount), edges(vertexCount, vec<Edge*>()) {}\n\n    void addEdge(Edge* edge) {\n#ifdef LOCAL\n        if (edge->from < 0 || edge->to < 0 || edge->from >= vertexCount || edge->to >= vertexCount) {\n            throw \"Out of bounds\";\n        }\n#endif\n        edge->id = edgeCount;\n        edges[edge->from].push_back(edge);\n        Edge* reverse = edge->reverse();\n        if (reverse != nullptr) {\n            reverse->id = edgeCount;\n            edges[reverse->from].push_back(reverse);\n        }\n        Edge* transposed = edge->transposed();\n        if (transposed != nullptr) {\n            edges[transposed->from].push_back(transposed);\n            transposed->id = edgeCount;\n            Edge* transRev = transposed->reverse();\n            if (transRev != nullptr) {\n                edges[transRev->from].push_back(transRev);\n                transRev->id = edgeCount;\n            }\n        }\n        edgeCount++;\n    }\n\n    template <typename...Ts>\n    void addEdge(Ts...args) {\n        addEdge(new Edge(args...));\n    }\n\n    vec<Edge*>& operator[](int at) {\n        return edges[at];\n    }\n\n    void addVertices(int count) {\n        vertexCount += count;\n        edges.resize(vertexCount);\n    }\n};\n\n\nconst int MOD7 = 1000000007;\nconst int MOD9 = 1000000009;\nconst int MODF = 998244353;\n\nint mod = MOD7;\n\ntemplate <typename T>\nT gcd(T a, T b, T& x, T& y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int d = gcd(b % a, a, y, x);\n    x -= (b / a) * y;\n    return d;\n}\n\nclass modint {\npublic:\n    int n;\n\n    modint() : n(0) {}\n\n    modint(ll n) {\n        if (n >= 0 && n < mod) {\n            this->n = n;\n            return;\n        }\n        n %= mod;\n        if (n < 0) {\n            n += mod;\n        }\n        this->n = n;\n    }\n\n    modint& operator+=(const modint& other) {\n        n += other.n;\n        if (n >= mod) {\n            n -= mod;\n        }\n        return *this;\n    }\n\n    modint& operator-=(const modint& other) {\n        n -= other.n;\n        if (n < 0) {\n            n += mod;\n        }\n        return *this;\n    }\n\n    modint& operator*=(const modint& other) {\n        n = ll(n) * other.n % mod;\n        return *this;\n    }\n\n    modint& operator/=(const modint& other) {\n#ifdef LOCAL\n        if (other.n == 0) {\n            throw \"Division by zero\";\n        }\n#endif\n        return *this *= other.inverse();\n    }\n\n    modint operator-() {\n        if (n == 0) {\n            return 0;\n        }\n        return modint(mod - n);\n    }\n\n    modint inverse() const {\n        ll x, y;\n        ll g = gcd(ll(n), ll(mod), x, y);\n#ifdef LOCAL\n        if (g != 1) {\n            throw \"not inversable\";\n        }\n#endif\n        return x;\n    }\n\n    int log(modint alpha);\n};\n\nmodint operator+(const modint& a, const modint& b) {\n    return modint(a) += b;\n}\n\nmodint operator-(const modint& a, const modint& b) {\n    return modint(a) -= b;\n}\n\nmodint operator*(const modint& a, const modint& b) {\n    return modint(a) *= b;\n}\n\nmodint operator/(const modint& a, const modint& b) {\n    return modint(a) /= b;\n}\n\nostream& operator<<(ostream& out, const modint& val) {\n    return out << val.n;\n}\n\nbool operator==(const modint& a, const modint& b) {\n    return a.n == b.n;\n}\n\nbool operator!=(const modint& a, const modint& b) {\n    return a.n != b.n;\n}\n\nnamespace std {\n    template <>\n    struct hash<modint> {\n        size_t operator()(const modint& n) const {\n            return n.n;\n        }\n    };\n}\n\nint modint::log(modint alpha) {\n    unordered_map<modint, int> base;\n    int exp = 0;\n    modint pow = 1;\n    modint inv = *this;\n    modint alInv = alpha.inverse();\n    while (exp * exp < mod) {\n        if (inv == 1) {\n            return exp;\n        }\n        base[inv] = exp++;\n        pow *= alpha;\n        inv *= alInv;\n    }\n    modint step = pow;\n    for (int i = 1;; i++) {\n        if (base.count(pow)) {\n            return exp * i + base[pow];\n        }\n        pow *= step;\n    }\n}\n\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        a = a % b;\n        swap(a, b);\n    }\n    return a;\n}\n\ntemplate <typename T>\nT lcm(T a, T b) {\n    return a / gcd(a, b) * b;\n}\n\ntemplate <typename T>\nT power(const T& a, ll b) {\n    if (b == 0) {\n        return 1;\n    }\n    if ((b & 1) == 0) {\n        T res = power(a, b >> 1);\n        return res * res;\n    } else {\n        return power(a, b - 1) * a;\n    }\n}\n\ntemplate <typename T>\nT factorial(int n) {\n    T result = 1;\n    for (int i = 2; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> factorials(int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * i;\n    }\n    return result;\n}\n\ntemplate <typename T>\narr<T> powers(T base, int length) {\n    arr<T> result(length);\n    if (length > 0) {\n        result[0] = 1;\n    }\n    for (int i = 1; i < length; i++) {\n        result[i] = result[i - 1] * base;\n    }\n    return result;\n}\n\n\nclass ReverseNumberIterator : public NumberIterator {\npublic:\n    ReverseNumberIterator(int v) : NumberIterator(v) {}\n\n    ReverseNumberIterator& operator++() {\n        --v;\n        return *this;\n    }\n};\n\nclass RevRange : pii {\npublic:\n    RevRange(int begin, int end) : pii(begin - 1, min(begin, end) - 1) {}\n\n    RevRange(int n) : pii(n - 1, min(n, 0) - 1) {}\n\n    ReverseNumberIterator begin() {\n        return first;\n    }\n\n    ReverseNumberIterator end() {\n        return second;\n    }\n};\n\n\nclass CGiantGraph {\npublic:\n    void solve() {\n        int n = in.readInt();\n        arr<Graph<BaseEdge>> graphs(3, Graph<BaseEdge>(n));\n        for (int i : range(3)) {\n            int m = in.readInt();\n            arri u, v;\n            in.readArrays(m, u, v);\n            decreaseByOne(u, v);\n            for (int j : range(m)) {\n                graphs[i].addEdge(min(u[j], v[j]), max(u[j], v[j]));\n            }\n        }\n\n        mod = MODF;\n        auto p = powers(modint(1000000000000000000ll), n + 1);\n        arr2d<modint> levels(3, n, 0);\n        arri level(n);\n        for (int i : range(3)) {\n            for (int j : RevRange(n)) {\n                unordered_set<int> bad;\n                for (auto* e : graphs[i][j]) {\n                    bad.insert(level[e->to]);\n                }\n                for (int k : range(n)) {\n                    if (!bad.count(k)) {\n                        level[j] = k;\n                        levels(i, k) += p[j + 1];\n                        break;\n                    }\n                }\n            }\n        }\n        modint answer = levels(0, 0) * levels(1, 0) * levels(2, 0);\n        for (int i : range(3)) {\n            for (int j : range(i)) {\n                for (int k : range(1, n)) {\n                    answer += levels(i, k) * levels(j, k) * levels(3 - i - j, 0);\n                }\n            }\n        }\n        for (int i : range(1, n)) {\n            for (int j = 2 * i; j < n; j += 2 * i) {\n                for (int k : range(i)) {\n                    if (j + i + k >= n) {\n                        break;\n                    }\n                    for (int a : range(3)) {\n                        for (int b : range(3)) {\n                            if (a == b) {\n                                continue;\n                            }\n                            answer += levels(a, i) * levels(b, j + k) * levels(3 - a - b, j + i + k);\n                        }\n                    }\n                }\n            }\n        }\n        out.printLine(answer);\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    CGiantGraph solver;\n\n\n    solver.solve();\n    fflush(stdout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate <unsigned int MOD>\nstruct ModInt {\n\tusing uint = unsigned int;\n\tusing ull = unsigned long long;\n\tusing M = ModInt;\n\n\tuint v;\n\n\tModInt(ll _v = 0) { set_norm(_v % MOD + MOD); }\n\tM& set_norm(uint _v) { //[0, MOD * 2)->[0, MOD)\n\t\tv = (_v < MOD) ? _v : _v - MOD;\n\t\treturn *this;\n\t}\n\n\texplicit operator bool() const { return v != 0; }\n\tM operator+(const M& a) const { return M().set_norm(v + a.v); }\n\tM operator-(const M& a) const { return M().set_norm(v + MOD - a.v); }\n\tM operator*(const M& a) const { return M().set_norm(ull(v) * a.v % MOD); }\n\tM operator/(const M& a) const { return *this * a.inv(); }\n\tM& operator+=(const M& a) { return *this = *this + a; }\n\tM& operator-=(const M& a) { return *this = *this - a; }\n\tM& operator*=(const M& a) { return *this = *this * a; }\n\tM& operator/=(const M& a) { return *this = *this / a; }\n\tM operator-() const { return M() - *this; }\n\tM& operator++(int) { return *this = *this + 1; }\n\tM& operator--(int) { return *this = *this - 1; }\n\n\tM pow(ll n) const {\n\t\tif (n < 0) return inv().pow(-n);\n\t\tM x = *this, res = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) res *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tM inv() const {\n\t\tll a = v, b = MOD, p = 1, q = 0, t;\n\t\twhile (b != 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(p -= t * q, q);\n\t\t}\n\t\treturn M(p);\n\t}\n\n\tbool operator==(const M& a) const { return v == a.v; }\n\tbool operator!=(const M& a) const { return v != a.v; }\n\tfriend ostream& operator<<(ostream& os, const M& a) { return os << a.v; }\n};\n\nusing Mint = ModInt<998244353>;\n\nconst int maxn = 100010;\nconst Mint W(TEN(18));\n\nMint pw[maxn * 3];\n\nV<int> g[3][maxn];\nint gr[3][maxn];\nMint sum[3][maxn];\n\nint main() {\n\tint N; cin >> N;\n\n\tpw[0] = 1;\n\tfor (int i = 1; i <= N * 3; ++i) {\n\t\tpw[i] = pw[i-1] * W;\n\t}\n\n\trep(i, 3) {\n\t\tint M; cin >> M;\n\t\trep(j, M) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t--x; --y;\n\t\t\tg[i][x].pb(y);\n\t\t\tg[i][y].pb(x);\n\t\t}\n\t}\n\n\tint mx = 0;\n\n\trep(t, 3) {\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tset<int> st;\n\t\t\tfor (int to : g[t][i]) {\n\t\t\t\tif (to > i) {\n\t\t\t\t\tst.insert(gr[t][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (st.count(gr[t][i])) {\n\t\t\t\t++gr[t][i];\n\t\t\t}\n\t\t\tsum[t][gr[t][i]] += pw[i + 1];\n\t\t\tchmax(mx, gr[t][i]);\n\t\t}\n\t}\n\n\tMint ans = 0;\n\n\tfor (int i = 0; i <= mx; ++i) {\n\t\tfor (int j = 0; j <= mx; ++j) {\n\t\t\tfor (int k = 0; k <= mx; ++k) {\n\t\t\t\tif ((i ^ j ^ k) == 0) {\n\t\t\t\t\tans += sum[0][i] * sum[1][j] * sum[2][k]; \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ntypedef long long i64;\ninline int rd(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 1e5+5, P = 998244353, W = int(((long long)1e18)%P);\nint n, ans; void fix(int &x) { x<P?0:x-=P; }\nstruct G\n{\n    int sg[N], w[N], t; vector<int> e[N]; void add(int x, int y) { if(x > y) swap(x, y); e[x].push_back(y); }\n    int SG(int x)\n    {\n        if(~sg[x]) return sg[x]; sg[x] = 0; map<int, bool> h;\n        for(int y:e[x]) h[SG(y)] = 1; while(h.count(sg[x])) ++sg[x]; return sg[x];\n    }\n    void sol()\n    {\n        memset(sg+1, -1, sizeof(int)*n);\n        for(int i = 1; i <= n; ++i) sg[i] = SG(i);\n        for(int i = 1, v = 1; i <= n; ++i) v = (i64)v*W%P, t = max(sg[i], t), fix(w[sg[i]]+=v);\n    }\n}g[3];\nint main()\n{\n    n = rd(); for(int k = 0; k < 3; g[k].sol(), ++k) for(int m = rd(), x, y; m--; ) x = rd(), y = rd(), g[k].add(x, y);\n    for(int i = 0; i <= g[0].t; ++i) for(int j = 0; j <= g[1].t; ++j) fix(ans+=(i64)g[0].w[i]*g[1].w[j]%P*g[2].w[i^j]%P);\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\ntypedef long long LL;\ntemplate <typename F, typename S> std::ostream& operator<<(ostream& os, const pair<F,S>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\"; for(const T& a: v){ os << a << \", \"; } os << \"]\"; return os; }\ntemplate <typename K, typename V> ostream& operator<<(ostream& os, const map<K,V>& m) {\n    os << \"{\"; for(const auto& p: m){ os << p.first <<\":\"<< p.second << \", \"; } os << \"}\"; return os; }\n\nstruct ModInt{\n    static const LL MOD = 998244353;\n    LL v;\n    ModInt():v(0){}\n    ModInt(LL op):v(op){}\n    ModInt operator+(ModInt op) const{ return (v + op) % MOD; }\n    ModInt operator-(ModInt op) const{ return (v - op + MOD) % MOD; }\n    ModInt operator*(ModInt op) const{ return (v * op) % MOD; }\n    ModInt operator/(ModInt op) const{ return (v * op.inverse()) % MOD; }\n    ModInt operator%(LL op) = delete;\n    ModInt operator+=(ModInt op){ return v = (v + op) % MOD; }\n    ModInt operator-=(ModInt op){ return v = (v - op + MOD) % MOD; }\n    ModInt operator*=(ModInt op){ return v = (v * op) % MOD; }\n    ModInt operator/=(ModInt op){ return v = (v * op.inverse()) % MOD; }\n    ModInt operator-() const{ return MOD - v; }\n    bool operator==(ModInt op) const{ return v == op.v; }\n    bool operator!=(ModInt op) const{ return v != op.v; }\n    ModInt inverse() const{ return pow(MOD-2); }\n    ModInt pow(LL n) const{\n        if(n < 0) return pow(MOD-1 + n);\n        if(n == 0) return 1;\n        ModInt res = pow(n/2);\n        return res * res * ((n&1)?ModInt(v): ModInt(1));\n    }\n    LL get() const{ return v; }\nprivate:\n    operator LL() const{ return v; }\n};\nistream& operator>>(istream& st, ModInt& m){ st>>m.v; return st; }\nostream& operator<<(ostream& st, const ModInt& m){ st<<m.v; return st; }\n\n\nvector<ModInt> factorial(LL n){\n    vector<ModInt> res(n, 1);\n    for(LL i = 2; i < n; ++i) res[i] = res[i-1] * ModInt(i);\n    return res;\n}\n\nModInt permutation(LL n, LL m, vector<ModInt>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    return factorial.at(n) / factorial.at(n-m);\n}\n\nModInt combination(LL n, LL m, vector<ModInt>& factorial){\n    if(m < 0 || n < m) return 0;\n    if(m == 0) return 1;\n    return factorial.at(n) / factorial.at(n-m) / factorial.at(m);\n}\n\nvector<vector<LL>> loadEdge(LL n){\n    LL n_edge;\n    cin >> n_edge;\n    vector<vector<LL>> edge(n);\n    for(LL i = 0; i < n_edge; ++i){\n        LL a, b;\n        cin >> a >> b;\n        --a; --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    return edge;\n}\n\n\nint main(){\n    LL n, m1, m2, m3;\n    cin >> n;\n    vector<vector<vector<LL>>> e(3);\n    e[0] = loadEdge(n);\n    e[1] = loadEdge(n);\n    e[2] = loadEdge(n);\n    ModInt base = ModInt(10).pow(18);\n    vector<ModInt> sum(3), sum2(3);\n    vector<vector<LL>> used(3, vector<LL>(n));\n    for(LL i = n-1; i >= 0; --i){\n        for(LL j = 0; j < 3; ++j){\n            if(used[j][i] == 0){\n                used[j][i] = 2;\n                sum[j] += base.pow(i+1);\n                //cerr << \"sum1 : \" << j << \": \" << i+1 << endl;\n                for(LL to: e[j][i]){\n                    used[j][to] = 1;\n                }\n            }\n        }\n    }\n    for(LL i = n-1; i >= 0; --i){\n        for(LL j = 0; j < 3; ++j){\n            if(used[j][i] == 1){\n                used[j][i] = 3;\n                sum2[j] += base.pow(i+1);\n                //cerr << \"sum2 : \" << j << \": \" << i+1 << endl;\n                for(LL to: e[j][i]){\n                    used[j][to] = 4;\n                }\n            }\n        }\n    }\n    //cerr << used << endl;\n    cout << sum[0]*sum[1]*sum[2]\n        + sum[0]*sum2[1]*sum2[2]\n        + sum[1]*sum2[2]*sum2[0]\n        + sum[2]*sum2[0]*sum2[1]\n        << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 0;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  vector<long long> ary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    set<int> usable;\n    for(int i = 1; i<N+1; ++i) {\n      usable.insert(i);\n    }\n    while(!usable.empty()) {\n      set<int> u = usable;\n      long long curr = 0;\n      while(!u.empty()) {\n        auto it = u.end();\n        it--;\n        int next = *it;\n        curr = (curr + pows[next]) % MOD;\n        for(int i = 0; i<adj[next].size(); ++i) {\n          u.erase(adj[next][i]);\n        }\n        u.erase(next);\n        usable.erase(next);\n      }\n      ary[graph].push_back(curr);\n    }\n  }\n\n  for(int i = 0; i<min(min(ary[0].size(), ary[1].size()), ary[2].size()); ++i) {\n    long long add = 0;\n    if(i == 0) {\n      add = ((ary[0][i] * ary[1][i]) % MOD) * ary[2][i];\n    }\n    else {\n      add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0] + ((ary[0][i] * ary[1][0])%MOD) * ary[2][i] + ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n      ary[0][0] = (ary[0][0] + ary[0][i]) % MOD;\n      ary[1][0] = (ary[1][0] + ary[1][i]) % MOD;\n      ary[2][0] = (ary[2][0] + ary[2][i]) % MOD;\n    }\n    ret = (ret + add) % MOD;\n  }\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = 998244353;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 100 * 1000 + 13;\nconst int P = 1000;\n\nint n;\nvector<int> g[3][N];\n\nbool read(){\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\tforn(i, n) forn(j, 3)\n\t\tg[j][i].clear();\n\tforn(j, 3){\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tforn(i, m){\n\t\t\tint v, u;\n\t\t\tscanf(\"%d%d\", &v, &u);\n\t\t\t--v, --u;\n\t\t\tif (v > u) swap(v, u);\n\t\t\tg[j][v].pb(u);\n\t\t}\n\t}\n\treturn true;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * li(b) % MOD;\n}\n\nint gr[3][N];\nint cnt[3][P];\nint pw[N];\n\nint calc(int i, int v){\n\tif (gr[i][v] != -1)\n\t\treturn gr[i][v];\n\tvector<int> tmp;\n\tfor (auto u : g[i][v])\n\t\ttmp.pb(calc(i, u));\n\tsort(all(tmp));\n\tforn(j, sz(tmp)) if (tmp[j] != j)\n\t\treturn gr[i][v] = j;\n\treturn gr[i][v] = sz(tmp);\n}\n\nvoid solve() {\n\tmemset(gr, -1, sizeof(gr));\n\tmemset(cnt, 0, sizeof(cnt));\n\tpw[0] = 1;\n\tpw[1] = INF64 % MOD;\n\tfore(i, 2, N) pw[i] = mul(pw[i - 1], pw[1]);\n\tforn(j, 3) forn(i, n) cnt[j][calc(j, i)] = add(cnt[j][calc(j, i)], pw[i + 1]);\n\tint ans = 0;\n\tforn(i, P) forn(j, P) if ((i ^ j) < P && cnt[0][i] && cnt[1][j] && cnt[2][i ^ j])\n\t\tans = add(ans, mul(mul(cnt[0][i], cnt[1][j]), cnt[2][i ^ j]));\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n#ifdef _DEBUG\n\twhile(read()) {\t\n#else\n\tif(read()) {\n#endif\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define long long long int\nstatic const long MOD = 998244353;\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n    for (int t = 0; t < 3; t++) {\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int x, y;\n            cin >> x >> y;\n            x--;\n            y--;\n            if (x > y) swap(x, y);\n            g[t][x].push_back(y);\n        }\n    }\n    vector<vector<int>> gr(3, vector<int>(n));\n    int mx = 0;\n    for (int t = 0; t < 3; t++) {\n        vector<int> z(n + 1);\n        int zz = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            zz++;\n            for (int j : g[t][i]) {\n                z[gr[t][j]] = zz;\n            }\n            while (z[gr[t][i]] == zz) gr[t][i]++;\n            mx = max(mx, gr[t][i]);\n        }\n    }\n    vector<vector<long>> ss(3, vector<long>(mx + 1));\n    vector<long> pw(n + 1);\n    pw[0] = 1;\n    for (int i = 0; i < n; i++) {\n        pw[i + 1] = pw[i] * 716070898 % MOD;\n    }\n    for (int t = 0; t < 3; t++) {\n        for (int i = 0; i < n; i++) {\n            ss[t][gr[t][i]] += pw[i + 1];\n            ss[t][gr[t][i]] %= MOD;\n        }\n    }\n    long res = 0;\n    for (int i = 0; i <= mx; i++) {\n        for (int j = 0; j <= mx; j++) {\n            if ((i ^ j) > mx) continue;\n            long s = ss[0][i];\n            s *= ss[1][j];\n            s %= MOD;\n            s *= ss[2][i ^ j];\n            s %= MOD;\n            res += s;\n            res %= MOD;\n        }\n    }\n    cout << res << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nconst int MM = 500;\nconst int MN = 100100;\nconst ll M = 998244353;\nbitset<MM> bs[MM][2];\nint pt[MM][2];\nint get(int a, int b) {\n\tint st = max(pt[a][0],pt[b][1]);\n\twhile(bs[a][0][st] || bs[b][1][st]) {\n\t\tst++;\n\t}\n\treturn st;\n}\nvoid up(int a, int b, int val) {\n\tbs[a][0].set(val);\n\tbs[b][1].set(val);\n\twhile(bs[a][0][pt[a][0]]) {pt[a][0]++;}\n\twhile(bs[b][1][pt[b][1]]) {pt[b][1]++;}\n}\nll mul(ll a, ll b) {\n\treturn (a*b)%M;\n}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {ac = mul(ac,b);}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll wor[MM][3];\nvvi g[3];\nint ro[3];\nll po[MN];\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tmemset(pt,0,sizeof(pt));\n\tmemset(wor,0,sizeof(wor));\n\tint n;\n\tcin >> n;\n\tpo[0] = 1;\n\tll B = bp(10,18);\n\tfor(int i=1;i<MN;i++) {\n\t\tpo[i] = mul(po[i-1],B);\n\t}\n\tfor(int i=0;i<3;i++) {\n\t\tg[i].assign(n,vi());\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;a--;b--;\n\t\t\tif(a < b) {swap(a,b);}\n\t\t\tg[i][a].push_back(b);\n\t\t}\n\t\tint ctr = 0;\n\t\tvi cu,nu;\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tcu.push_back(j);\n\t\t}\n\t\tbitset<MN> ko;\n\t\twhile(!cu.empty()) {\n\t\t\tko.reset();\n\t\t\tnu.clear();\n\t\t\tfor(int j=cu.size()-1;j>=0;j--) {\n\t\t\t\tint u = cu[j];\n\t\t\t\tif(ko[u]) {\n\t\t\t\t\tnu.push_back(u);continue;}\n\t\t\t\twor[ctr][i] += po[u+1];\n\t\t\t\tif(wor[ctr][i] >= M) {wor[ctr][i] -= M;}\n\t\t\t\tfor(int k=0;k<g[i][u].size();k++) {\n\t\t\t\t\tko.set(g[i][u][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctr++;\n\t\t\tcu = nu;\n\t\t\treverse(cu.begin(),cu.end());\n\t\t}\n\t\tro[i] = ctr;\n\t}\n\tll res = 0;\n\tfor(int i=0;i<ro[0];i++) {\n\t\tfor(int j=0;j<ro[1];j++) {\n\t\t\tint re = get(i,j);\n\t\t\tif(re < ro[2]) {\n\t\t\t\tres += mul(wor[i][0],mul(wor[j][1],wor[re][2]));\n\t\t\t\tup(i,j,re);\n\t\t\t}\n\t\t}\n\t}\n\tres %= M;\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100000 + 10;\nconst int mod = 998244353;\nll qpow(ll n,ll k){\n    ll res = 1;\n    while(k){\n        if(k&1) res = res * n % mod;\n        n = n * n % mod;\n        k >>= 1;\n    }\n    return res;\n}\nvoid add(ll &x,ll y){\n    (x += y) %= mod;\n}\nvoid brute(){\n    vector<int> e[10][10];\n    int n; cin>>n;\n    for(int i=1;i<=3;i++){\n        int m; cin>>m;\n        while(m--){\n            int u,v; cin>>u>>v;\n            e[i][u].push_back(v);\n            e[i][v].push_back(u);\n        }\n    }\n    ll ans = 0;\n    int vis[n+1][n+1][n+1] = {0};\n    for(int sum=3*n;sum>=3;sum--){\n        for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) for(int k=1;k<=n;k++) if((i+j+k)==sum&&!vis[i][j][k]){\n            cout<<i<<' '<<j<<' '<<k<<endl;\n            add(ans,qpow(10,18*(i+j+k)));\n            for(int x: e[1][i]) if(x<i) vis[x][j][k] = 1;\n            for(int x: e[2][j]) if(x<j) vis[i][x][k] = 1;\n            for(int x: e[3][k]) if(x<k) vis[i][j][x] = 1;\n        }\n    }\n    cout<<ans<<endl;\n}\nll c[3][2];\nvector<int> g[N];\nint vis[N];\nint main(){\n//    brute();\n    int n; scanf(\"%d\",&n);\n    for(int x=0;x<3;x++){\n        int m; scanf(\"%d\",&m);\n        for(int i=1;i<=n;i++) g[i].clear(), vis[i] = 0;\n        while(m--){\n            int u,v; scanf(\"%d%d\",&u,&v);\n            g[u].push_back(v), g[v].push_back(u);\n        }\n        for(int i=n;i>=1;i--){\n            if(vis[i]==0){\n                for(int j: g[i]) if(j<i) vis[j] = 1;\n                add(c[x][1],qpow(10,18*i));\n            }\n        }\n        for(int i=n;i>=1;i--){\n            if(vis[i]==1){\n                for(int j: g[i]) if(j<i) vis[j] = 0;\n                add(c[x][0],qpow(10,18*i));\n            }\n        }\n//        for(int i=1;i<=n;i++) cout<<!vis[i]<<' '; cout<<endl;\n    }\n    ll ans = 0;\n    for(int i=0;i<2;i++) for(int j=0;j<2;j++) for(int k=0;k<2;k++) if((i+j+k)%2){\n        add(ans,c[0][i]*c[1][j]%mod*c[2][k]%mod);\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 998244353\nusing namespace std;\nint read()\n{\n\tchar c=0;\n\tint sum=0;\n\twhile (c<'0'||c>'9')\n\t\tc=getchar();\n\twhile ('0'<=c&&c<='9')\n\t\tsum=sum*10+c-'0',c=getchar();\n\treturn sum; \n};\nstruct node\n{\n\tint v,nxt;\n};\nnode edge[4][2000001];\nlong long n,m,head[4][2000001],len[4];\nbool vis[101][101][101];\nvoid add(int k,int x,int y)\n{\n\tedge[k][++len[k]].v=y,edge[k][len[k]].nxt=head[k][x],head[k][x]=len[k];\n\tedge[k][++len[k]].v=x,edge[k][len[k]].nxt=head[k][y],head[k][y]=len[k];\n\treturn;\n}\nlong long fast_pow(long long a,int b)\n{\n\tif (b==0)\n\t\treturn 1;\n\tif (b&1)\n\t\treturn fast_pow(a*a%mod,b/2)*a%mod;\n\telse\n\t\treturn fast_pow(a*a%mod,b/2); \n}\nint main()\n{\n\tint x,y;\n\tn=read();\n\tfor (int op=0;op<=2;++op)\n\t{\n\t\tm=read();\n\t\tfor (int i=1;i<=m;++i) x=read(),y=read(),add(op,x,y);\n\t}\n\tlong long ans=0;\n\tfor (int i=n;i>=1;--i)\n\t\tfor (int j=n;j>=1;--j)\n\t\t\tfor (int k=n;k>=1;--k)\n\t\t\t\tif (!vis[i][j][k])\n\t\t\t\t{\n\t\t\t\t\tfor (int t=head[0][i];t>0;t=edge[0][t].nxt)\n\t\t\t\t\t\tvis[edge[0][t].v][j][k]=1;\n\t\t\t\t\tfor (int t=head[1][j];t>0;t=edge[1][t].nxt)\n\t\t\t\t\t\tvis[i][edge[1][t].v][k]=1;\n\t\t\t\t\tfor (int t=head[2][k];t>0;t=edge[2][t].nxt)\n\t\t\t\t\t\tvis[i][j][edge[2][t].v]=1;\n\t\t\t\t\tans=(ans+fast_pow(10,18*(i+j+k)));\n\t\t\t\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = 998244353;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 100 * 1000 + 13;\nconst int P = 1000;\n\nint n;\nvector<int> g[3][N];\n\nbool read () {\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\tforn(i, n) forn(j, 3)\n\t\tg[j][i].clear();\n\tforn(j, 3){\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tforn(i, m){\n\t\t\tint v, u;\n\t\t\tscanf(\"%d%d\", &v, &u);\n\t\t\t--v, --u;\n\t\t\tg[j][v].pb(u);\n\t\t\tg[j][u].pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * li(b) % MOD;\n}\n\nint gr[3][N];\nint cnt[3][P];\nint pw[N];\n\nint calc(int i, int v){\n\tif (gr[i][v] != -1)\n\t\treturn gr[i][v];\n\tvector<int> tmp;\n\tfor (auto u : g[i][v]) if (u > v)\n\t\ttmp.pb(calc(i, u));\n\tsort(all(tmp));\n\tforn(i, sz(tmp)) if (tmp[i] != i)\n\t\treturn gr[i][v] = i;\n\treturn gr[i][v] = sz(tmp);\n}\n\nvoid solve() {\n\tmemset(gr, -1, sizeof(gr));\n\tmemset(cnt, 0, sizeof(cnt));\n\tpw[0] = 1;\n\tpw[1] = INF64 % MOD;\n\tfore(i, 2, N) pw[i] = mul(pw[i - 1], pw[1]);\n\tforn(j, 3) forn(i, n) cnt[j][calc(j, i)] = add(cnt[j][calc(j, i)], pw[i + 1]);\n\tint ans = 0;\n\tforn(i, P) forn(j, P) if ((i ^ j) < P && cnt[0][i] && cnt[1][j] && cnt[2][i ^ j])\n\t\tans = add(ans, mul(mul(cnt[0][i], cnt[1][j]), cnt[2][i ^ j]));\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n#ifdef _DEBUG\n\twhile(read()) {\t\n#else\n\tif(read()) {\n#endif\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define ll long long\n\nusing namespace std;\n\nconst int MAXN = 3e5 + 5;\nconst ll mod = 998244353;\nconst ll cost = 1e18;\n\nll money[MAXN];\n\nvoid precalc() {\n\tmoney[0] = 1;\n\tll x = cost % mod;\n\tfor (int i = 1; i < MAXN; i++) {\n\t\tmoney[i] = money[i - 1] * x % mod;\n\t}\n}\n\nint n;\n\nvoid input(vector<vector<int> >& graph, int &m) {\n\tcin >> m;\n\tgraph.resize(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n}\n\nconst int MAXN2 = 105;\n\nbool used[MAXN2][MAXN2][MAXN2];\n\nint main() {\n\tprecalc();\n\tcin >> n;\n\tvector<vector<int> > graph1, graph2, graph3;\n\tint m1, m2, m3;\n\tinput(graph1, m1);\n\tinput(graph2, m2);\n\tinput(graph3, m3);\n\tll ans = 0;\n\tfor (int S = 3 * n - 3; S >= 0; S--) {\n\t\tfor (int a = 0; a < n; a++) {\n\t\t\tfor (int b = 0; b < n; b++) {\n\t\t\t\tint c = S - a - b;\n\t\t\t\tif (c < 0 || c >= n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (used[a][b][c])\n\t\t\t\t\tcontinue;\n\t\t\t\tused[a][b][c] = 1;\n\t\t\t\tans += money[S + 3];\n\t\t\t\tans %= mod;\n\t\t\t\tfor (int a1 : graph1[a])\n\t\t\t\t\tused[a1][b][c] = 1;\n\t\t\t\tfor (int b1 : graph2[b])\n\t\t\t\t\tused[a][b1][c] = 1;\n\t\t\t\tfor (int c1 : graph3[c])\n\t\t\t\t\tused[a][b][c1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,abm,mmx,popcnt,avx,avx2,tune=native\")\n           \n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n           \n//#define int long long\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pld;\n\ntemplate<typename T>\nusing kawaii_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n  \nvoid FAST_IO() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.setf(ios::fixed);\n    //cout.precision(20);\n    #ifndef _offline\n    //freopen(\"mincost.in\", \"r\", stdin);\n    //freopen(\"mincost.out\", \"w\", stdout);\n    #endif\n}\n\nconst ll mod = 998244353;\nconst ll kek = 716070898;\nconst int K = 500;\nconst int MAXN = 1e5 + 100;\nvector<int> g1[MAXN], g2[MAXN], g3[MAXN];\nint v1[MAXN], v2[MAXN], v3[MAXN];\nll s1[K], s2[K], s3[K];\nbool xy[K][K], xz[K][K], yz[K][K];\n\nll binpow(ll a, ll n) {\n    ll res = 1;\n    while (n) {\n        if (n & 1) {\n            res = (res * a) % mod;\n        }\n        a = (a * a) % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nvoid relax1(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g1[u]) {\n        bs[v1[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v1[u] = i;\n            break;\n        }\n    }\n    s1[v1[u]] += binpow(kek, u + 1);\n    if (s1[v1[u]] >= mod) {\n        s1[v1[u]] -= mod;\n    }\n}\n\nvoid relax2(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g2[u]) {\n        bs[v2[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v2[u] = i;\n            break;\n        }\n    }\n    s2[v2[u]] += binpow(kek, u + 1);\n    if (s2[v2[u]] >= mod) {\n        s2[v2[u]] -= mod;\n    }\n}\n\nvoid relax3(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g3[u]) {\n        bs[v3[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v3[u] = i;\n            break;\n        }\n    }\n    s3[v3[u]] += binpow(kek, u + 1);\n    if (s3[v3[u]] >= mod) {\n        s3[v3[u]] -= mod;\n    }\n}\n\nsigned main() {\n    FAST_IO();\n    int n;\n    cin >> n;\n    int m1;\n    cin >> m1;\n    for (int i = 0; i < m1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g1[u].push_back(v);\n    }\n    int m2;\n    cin >> m2;\n    for (int i = 0; i < m2; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g2[u].push_back(v);\n    }\n    int m3;\n    cin >> m3;\n    for (int i = 0; i < m3; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g3[u].push_back(v);\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        relax1(i);\n        relax2(i);\n        relax3(i);\n    }\n    vector<tuple<int, int, int>> kektor;\n    for (int i = 0; i < K; ++i) {\n        if (s1[i] == 0) {\n            continue;\n        }\n        for (int j = 0; j < K; ++j) {\n            if (s2[j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < K; ++k) {\n                if (s3[k] == 0) {\n                    continue;\n                }\n                kektor.push_back(make_tuple(i, j, k));\n            }\n        }\n    }\n    sort(all(kektor), [&](tuple<int, int, int> a, tuple<int, int, int> b) {\n        return get<0>(a) + get<1>(a) + get<2>(a) < get<0>(b) + get<1>(b) + get<2>(b);\n    });\n    ll ans = 0;\n    for (auto t : kektor) {\n        int x, y, z;\n        tie(x, y, z) = t;\n        if (xy[x][y] || xz[x][z] || yz[y][z]) {\n            continue;\n        }\n        ll val = (s1[x] * s2[y]) % mod;\n        val = (val * s3[z]) % mod;\n        ans += val;\n        if (ans >= mod) {\n            ans -= mod;\n        }\n        xy[x][y] = true;\n        xz[x][z] = true;\n        yz[y][z] = true;\n    }\n    cout << ans << '\\n';\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<class T, class U>\nvoid ckmin(T &a, U b)\n{\n    if (a > b) a = b;\n}\n\ntemplate<class T, class U>\nvoid ckmax(T &a, U b)\n{\n    if (a < b) a = b;\n}\n\n#define MP make_pair\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define SZ(x) ((int) (x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, a, b) for (auto i = (a); i < (b); i++)\n#define FORD(i, a, b) for (auto i = (a) - 1; i >= (b); i--)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\n\nconst int MAXN = 300013;\nconst int INF = 998244353;\nconst int BASE = 716070898;\n\nint add(int a, int b)\n{\n    a += b; if (a >= INF) a -= INF; return a;\n}\nint mul(int a, int b)\n{\n    return (ll) a * b % INF;\n}\nint sub(int a, int b)\n{\n    a -= b; if (a < 0) a += INF; return a;\n}\nint pwr(int a, int b)\n{\n    int res = 1;\n    while(b > 0)\n    {\n        if (b & 1) res = mul(res, a);\n        b >>= 1;\n        a = mul(a, a);\n    }\n    return res;\n}\nint inv(int a)\n{\n    return pwr(a, INF - 2);\n}\nint dvd(int a, int b)\n{\n    return mul(a, inv(b));\n}\n\nint N;\nint M[3];\nvi edge[3][MAXN];\nint num[3][MAXN];\nint sum[3][MAXN];\nint pw[MAXN];\nint ans;\n\nint32_t main()\n{\n    cout << fixed << setprecision(12);\n    cerr << fixed << setprecision(4);\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    cin >> N;\n    FOR(i, 0, 3)\n    {\n        cin >> M[i];\n        FOR(j, 0, M[i])\n        {\n            int u, v;\n            cin >> u >> v; u--; v--;\n            if (u > v) swap(u, v);\n            edge[i][u].PB(v);\n        }\n        FORD(u, N, 0)\n        {\n            set<int> nums;\n            for (int v : edge[i][u]) nums.insert(num[i][v]);\n            num[i][u] = 0;\n            while(nums.count(num[i][u])) num[i][u]++;\n        }\n        int pw = 1;\n        FOR(j, 0, N)\n        {\n            pw = mul(pw, BASE);\n            sum[i][num[i][j]] = add(sum[i][num[i][j]], pw);\n            // cerr << \"sum \" << i << ' ' << num[i][j] << \" peq \" << pw << endl;\n        }\n        // cerr << \"ok\\n\";\n    }\n    // cerr << \"alive\\n\";\n    FOR(i, 0, 512)\n    {\n        FOR(j, 0, 512)\n        {\n            ans = add(ans, mul(sum[2][i ^ j], mul(sum[0][i], sum[1][j])));\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n    //if an odd # say to include it then do it.\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long prime = 998244353LL;\n\nlong long pow_mod(long long a, long long r) {\n    if (r == 0) return 1LL;\n    if (r == 1) return a;\n    long long y = pow_mod(a, r/2);\n    if (r % 2 == 0) {\n        return y * y % prime;\n    }\n    return y * y % prime * a % prime;\n}\n\nlong long x = pow_mod(10, 18);\n\nstruct Graph {\n    int n, m;\n    vector<vector<int>> adj_list;\n    vector<int> grundy;\n    vector<long long> agg_grundy;\n    Graph(int n): n(n), adj_list(n), grundy(n) {}\n    void read() {\n        cin >> m;\n        for (int i = 0; i < m; ++i) {\n            int a, b;\n            cin >> a >> b;\n            --a;\n            --b;\n            adj_list[a].push_back(b);\n            adj_list[b].push_back(a);\n        }\n    }\n    void calc_grundy() {\n        int highest = 0;\n        for (int i = n-1; i >= 0; --i) {\n            set<int> neighbors;\n            for (int j : adj_list[i]) {\n                if (j > i) {\n                    neighbors.insert(grundy[j]);\n                }\n            }\n            grundy[i] = 0;\n            while (neighbors.find(grundy[i]) != neighbors.end()) {\n                ++grundy[i];\n            }\n            highest = max(highest, grundy[i]);\n        }\n        agg_grundy = vector<long long>(highest + 1, 0LL);\n        long long y = x;\n        for (int i = 0; i < n; ++i, y = y * x % prime) {\n            agg_grundy[grundy[i]] = (agg_grundy[grundy[i]] + y) % prime;\n        }\n    }\n};\n\nvector<long long> combine_aggs(vector<long long>& a, vector<long long> b) {\n    int n = 1;\n    while (n < (int) a.size() || n < (int) b.size()) {\n        n *= 2;\n    }\n    vector<long long> c(n, 0LL);\n    for (int i = 0; i < (int) a.size(); ++i) {\n        for (int j = 0; j < (int) b.size(); ++j) {\n            c[i ^ j] = (c[i ^ j] + a[i] * b[j]) % prime;\n        }\n    }\n    return c;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    Graph g1(n), g2(n), g3(n);\n    g1.read();\n    g2.read();\n    g3.read();\n    g1.calc_grundy();\n    g2.calc_grundy();\n    g3.calc_grundy();\n    vector<long long> res = combine_aggs(g1.agg_grundy, combine_aggs(g2.agg_grundy, g3.agg_grundy));\n    cout << res[0] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\nconstexpr int mod2 = 998244353;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\ntemplate<typename T>\nbool isin(T y, T x, T h, T w) { return (0 <= y && 0 <= x && y < h && x < w); }\ntemplate<typename T>\nbool isin1(T y, T x, T h, T w) { return (0 < y && 0 < x && y <= h && x <= w); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u; return (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\n\ntemplate < unsigned MOD >\nclass Modint {\n\tpublic:\n\t\tusing uint = unsigned;\n\t\tusing u64 = uint64_t;\n\t\tusing i64 = int64_t;\n\n\t\tModint (const i64 dat = 0) : dat(dat >= 0 ? dat % MOD : (MOD - (-dat) % MOD) % MOD) {}\n\n\t\tconstexpr Modint operator + (const Modint &v) const { return ( Modint(dat + v.dat) ); }\n\t\tconstexpr Modint operator - () const { return ( Modint(-((i64)dat)) ); }\n\t\tconstexpr Modint operator - (const Modint &v) const { return ( (*this) + -v ); }\n\t\tconstexpr Modint operator * (const Modint &v) const { return ( Modint((u64)dat * v.dat) ); }\n\n\t\tconstexpr Modint operator ~ () const {\n\t\t\ti64 a = dat, b = MOD, x1 = 1, x2 = 0, t;\n\n\t\t\twhile ( b > 0 ) {\n\t\t\t\tt = a / b;\n\t\t\t\tswap(a -= t * b, b);\n\t\t\t\tswap(x1 -= t * x2, x2);\n\t\t\t}\n\n\t\t\treturn ( Modint(x1) );\n\t\t}\n\n\t\tconstexpr Modint operator / (const Modint &v) const { return ( (*this) * ~v ); }\n\n\t\tModint &operator = (const i64 &v) { return ( (*this) = Modint < MOD > (v) ); }\n\t\tModint &operator += (const Modint &v) { return ( (*this) = (*this) + v ); }\n\t\tModint &operator -= (const Modint &v) { return ( (*this) = (*this) - v ); }\n\t\tModint &operator *= (const Modint &v) { return ( (*this) = (*this) * v ); }\n\t\tModint &operator /= (const Modint &v) { return ( (*this) = (*this) / v ); }\n\n\t\tconstexpr Modint operator ^ (u64 n) const {\n\t\t\tModint < MOD > ret(1), mul(dat);\n\t\t\twhile ( n > 0 ) {\n\t\t\t\tif ( n & 1 ) ret *= mul;\n\t\t\t\tmul *= mul;\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn ( ret );\n\t\t}\n\n\t\tbool operator == (const Modint &v) { return ( dat == v.dat ); }\n\t\tbool operator != (const Modint &v) { return ( dat != v.dat ); }\n\n\t\tfriend ostream& operator << (ostream &os, const Modint &p ) {\n\t\t\treturn ( os << p.dat );\n\t\t}\n\n\t\tfriend istream& operator >> (istream &is, Modint &p ) {\n\t\t\ti64 data;\n\t\t\tis >> data;\n\t\t\tp = Modint < MOD >(data);\n\t\t\treturn ( is );\n\t\t}\n\n\tprivate:\n\t\tuint dat;\n};\n\nint N;\n\nint dfs(vvint &G, vint &grundy, int u) {\n\tif (grundy[u] != -1) return (grundy[u]);\n\tset<int> dat;\n\tfor (auto &v : G[u]) {\n\t\tdat.insert(dfs(G, grundy, v));\n\t}\n\tgrundy[u] = 0;\n\twhile (dat.count(grundy[u])) grundy[u]++;\n\treturn (grundy[u]);\n}\n\nvector<Modint<mod2>> calcGrundy(vvint &G, vint &grundy) {\n\tvector<Modint<mod2>> sum(1005);\n\tfor (int i = 0; i < N; i++) {\n\t\tsum[dfs(G, grundy, i)] += Modint<mod2>(10)^(18*(i+1));\n\t}\n\treturn (sum);\n}\n\nvoid input(vvint &G) {\n\tint M; cin >> M;\n\twhile (M--) {\n\t\tint a, b; cin >> a >> b; --a, --b;\n\t\tif (a > b) swap(a, b);\n\t\tG[a].push_back(b);\n\t}\n}\n\nvoid Main() {\n\tcin >> N;\n\tvvint G1(N), G2(N), G3(N);\n\tvint grundy1(N, -1), grundy2(N, -1), grundy3(N, -1);\n\n\tinput(G1); input(G2); input(G3);\n\tvector<Modint<mod2>> sum1 = calcGrundy(G1, grundy1);\n\tvector<Modint<mod2>> sum2 = calcGrundy(G2, grundy2);\n\tvector<Modint<mod2>> sum3 = calcGrundy(G3, grundy3);\n\t\n\tModint<mod2> ans = 0;\t\n\tfor (int b1 = 0; b1 < 1005; b1++) {\n\t\tfor (int b2 = 0; b2 < 1005; b2++) {\n\t\t\tint b3 = b1 ^ b2;\n\t\t\tans += sum1[b1] * sum2[b2] * sum3[b3];\n\t\t}\n\t}\n\tcout << ans << endl;\n\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\nconst num BASE(int64_t(1e18));\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nvoid slow() {\n\tint N; cin >> N;\n\tvector<vector<vector<int>>> adj(3, vector<vector<int>>(N));\n\tfor (int z = 0; z < 3; z++) {\n\t\tint M; cin >> M;\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tint u, v; cin >> u >> v; u--, v--;\n\t\t\tassert(u != v);\n\t\t\tif (u > v) swap(u, v);\n\t\t\tassert(u < v);\n\t\t\tadj[z][u].push_back(v);\n\t\t}\n\t}\n\tnum ans = 0;\n\tvector<vector<vector<bool>>> take(N, vector<vector<bool>>(N, vector<bool>(N, false)));\n\tfor (int s = 3*(N-1); s >= 0; s--) {\n\t\tfor (int x = 0; x < N; x++) {\n\t\t\tfor (int y = 0; y < N; y++) {\n\t\t\t\tint z = s-x-y;\n\t\t\t\tif (0 <= z && z < N) {\n\t\t\t\t\ttake[x][y][z] = true;\n\t\t\t\t\tfor (int x2 : adj[0][x]) {\n\t\t\t\t\t\tif (take[x2][y][z]) take[x][y][z] = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int y2 : adj[1][y]) {\n\t\t\t\t\t\tif (take[x][y2][z]) take[x][y][z] = false;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int z2 : adj[2][z]) {\n\t\t\t\t\t\tif (take[x][y][z2]) take[x][y][z] = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (take[x][y][z]) {\n\t\t\t\t\t\tcerr << x+1 << ' ' << y+1 << ' ' << z+1 << '\\n';\n\t\t\t\t\t\tans += pow(BASE, x+y+z+3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<num> cost(N);\n\tcost[0] = BASE;\n\tfor (int i = 1; i < N; i++) cost[i] = cost[i-1] * BASE;\n\n\tconst int LG = 9;\n\tconst int S = 1 << LG;\n\n\tvector<num> ans(S, 1);\n\n\tfor (int z = 0; z < 3; z++) {\n\t\tint M; cin >> M;\n\t\tvector<vector<int>> adj(N);\n\t\tfor (int e = 0; e < M; e++) {\n\t\t\tint u, v; cin >> u >> v; u--, v--;\n\t\t\tassert(u != v);\n\t\t\tif (u > v) swap(u, v);\n\t\t\tassert(u < v);\n\t\t\tadj[u].push_back(v);\n\t\t}\n\n\t\tvector<num> cnt(S);\n\t\tvector<int> nimber(N);\n\t\tvector<int> mexTmp(N+1);\n\t\tfor (int i = N-1; i >= 0; i--) {\n\t\t\tfor (int j : adj[i]) {\n\t\t\t\tmexTmp[nimber[j]]++;\n\t\t\t}\n\t\t\tnimber[i] = 0;\n\t\t\twhile (mexTmp[nimber[i]]) nimber[i]++;\n\t\t\tfor (int j : adj[i]) {\n\t\t\t\tmexTmp[nimber[j]]--;\n\t\t\t}\n\t\t\tcnt[nimber[i]] += cost[i];\n\t\t}\n\t\tfor (int l = 0; l < LG; l++) {\n\t\t\tfor (int m = 0; m < S; m++) {\n\t\t\t\tif (m & (1<<l)) continue;\n\t\t\t\tnum s = cnt[m | (1<<l)];\n\t\t\t\tnum a = cnt[m];\n\t\t\t\tcnt[m] = a+s;\n\t\t\t\tcnt[m|(1<<l)] = a-s;\n\t\t\t}\n\t\t}\n\n\t\tfor (int m = 0; m < S; m++) {\n\t\t\tans[m] *= cnt[m];\n\t\t}\n\t}\n\n\tnum tot = 0;\n\tfor (int m = 0; m < S; m++) {\n\t\ttot += ans[m];\n\t}\n\ttot /= S;\n\tcout << tot << '\\n';\n\n\treturn 0;\n}\n\n// sample2:\n// 3,31,32\n//\n// 3,3,3\n// 3,3,2\n// 2,2,3\n// 3,1,3\n// 2,2,2\n// 3,1,2\n// 3,2,1\n// 2,3,1\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M[3];\nvector<int> E[3][101010];\nconst ll mo=998244353;\nll p10[20];\nll pv[303030];\n\nint ok[3][303030];\n\nll comb(ll N_, ll C_) {\n\tconst int NUM_=1400001;\n\tif(C_==3) return N_*(N_-1)*(N_-2)/6;\n\t\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\nll hcomb(int P_,int Q_) { return (P_==0&&Q_==0)?1:comb(P_+Q_-1,Q_);}\n\nll pat(ll num) {\n\tif(num<0) return 0;\n\treturn (num+2)*(num+1)/2;\n}\n\n\nll num(ll tot) {\n\tll ret=pat(tot);\n\tret-=3*pat(tot-N);\n\tret+=3*pat(tot-2*N);\n\tret-=3*pat(tot-3*N);\n\treturn ret;\n\t\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tll sum=0;\n\n\tp10[0]=1;\n\tFOR(i,19) p10[i+1]=p10[i]*10%mo;\n\tpv[0]=p10[18]*p10[18]%mo*p10[18]%mo;\n\tFOR(i,302020) pv[i+1]=pv[i]*p10[18]%mo;\n\t\n\tll from[3]={};\n\tFOR(i,3) {\n\t\tcin>>M[i];\n\t\tFOR(j,M[i]) {\n\t\t\tcin>>x>>y;\n\t\t\tE[i][x-1].push_back(y-1);\n\t\t\tE[i][y-1].push_back(x-1);\n\t\t}\n\t\tfor(j=N-1;j>=0;j--) {\n\t\t\tset<int> S;\n\t\t\tFORR(e,E[i][j]) if(e>j) S.insert(ok[i][e]);\n\t\t\twhile(S.count(ok[i][j])) ok[i][j]++;\n\t\t\tif(ok[i][j]<=2) {\n\t\t\t\tll to[3]={};\n\t\t\t\tll pat=pv[i];\n\t\t\t\tFOR(x,3) (to[(x+ok[i][j])%3]+=pat*from[x])%=mo;\n\t\t\t\tswap(from,to);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t\n\tcout<<from[0]<<endl;\n\t/*\n\t\n\tll ret=0;\n\tfor(i=0;i<=3*(N-1);i++) ret+=pv[i]*num(i)%mo;\n\t\n\tll dp[3]={1,0,0};\n\tFOR(i,3) {\n\t\tfor(j=N-1;j>=0;j--) {\n\t\t\tif(ok[i][j]>=3) {\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\t*/\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct SumNode { UL a, b, c; };\n\nstruct Problem {\n\t/*\n\tUL F[4][4] = {\n\t\t{0, 1, 2, 3},\n\t\t{1, 0, 1, 2},\n\t\t{2, 1, 0, 1},\n\t\t{3, 2, 1, 0}\n\t};\n\n\tUL V[1000000];*/\n\n\tbool G[501][501] = {};\n\n\tvoid Solve() {\n\t\t/*\n\t\tUL N; cin >> N; N--;\n\t\t{\n\t\t\tUL a; cin >> a;\n\t\t\trep(i, N) {\n\t\t\t\tUL t; cin >> t;\n\t\t\t\tV[i] = F[a][t];\n\t\t\t\ta = t;\n\t\t\t}\n\t\t}*/\n\t\tconst ULL M = 998244353;\n\t\tconst ULL Z = 1000000000000000000 % 998244353;\n\n\t\tUL N; cin >> N;\n\t\tUL S[3];\n\t\tvector<vector<UL>> E[3];\n\t\trep(i, 3) {\n\t\t\tcin >> S[i];\n\t\t\tE[i].resize(N);\n\t\t\trep(j, S[i]) {\n\t\t\t\tUL u, v; cin >> u >> v; u--; v--;\n\t\t\t\tE[i][u].push_back(v);\n\t\t\t\tE[i][v].push_back(u);\n\t\t\t}\n\t\t}\n\t\tvector<UL> POWZ(N * 3 + 1); POWZ[0] = 1;\n\t\trep(i, N * 3) POWZ[i + 1] = POWZ[i] * Z % M;\n\t\tvector<ULL> A[3] = {};\n\t\trep(t, 3) {\n\t\t\t//cout << \"t = \" << t << endl;\n\t\t\tA[t].resize(N);\n\t\t\tvector<UL> F(N);\n\t\t\tfor (UL v = N - 1; v != -1; v--) {\n\t\t\t\tA[t][F[v]] = (A[t][F[v]] + POWZ[v + 1]) % M;\n\t\t\t\tfor (UL e : E[t][v]) {\n\t\t\t\t\tif (F[e] == F[v]) F[e] = F[v] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//rep(i, N) cout << F[i] << \" \"; cout << endl;\n\t\t}\n\n\n\t\tvector<SumNode> Q;\n\n\t\t{\n\t\t\tUL SX = min(N - 1, 500u);\n\t\t\tfor (UL s = 0; s <= SX * 3; s++) {\n\t\t\t\tfor (UL a = 0; a <= min(s, SX); a++) {\n\t\t\t\t\tfor (UL b = a; a + b + b <= s; b++) {\n\t\t\t\t\t\tUL c = s - a - b;\n\t\t\t\t\t\tif (c > SX) continue;\n\t\t\t\t\t\tif (G[a][b]) continue;\n\t\t\t\t\t\tif (G[a][c]) continue;\n\t\t\t\t\t\tif (G[b][c]) continue;\n\t\t\t\t\t\tG[a][b] = G[a][c] = G[b][c] = true;\n\t\t\t\t\t\tQ.push_back({ a,b,c });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tULL ans = 0;\n\t\tfor (SumNode s : Q) {\n\t\t\tif (s.a == s.b && s.a == s.c) {\n\t\t\t\tans += A[0][s.a] * A[1][s.a] % M * A[2][s.a] % M;\n\t\t\t}\n\t\t\telse if (s.a != s.b && s.a != s.c && s.b != s.c) {\n\t\t\t\tans += A[0][s.a] * A[1][s.b] % M * A[2][s.c] % M;\n\t\t\t\tans += A[0][s.a] * A[1][s.c] % M * A[2][s.b] % M;\n\t\t\t\tans += A[0][s.b] * A[1][s.a] % M * A[2][s.c] % M;\n\t\t\t\tans += A[0][s.c] * A[1][s.a] % M * A[2][s.b] % M;\n\t\t\t\tans += A[0][s.b] * A[1][s.c] % M * A[2][s.a] % M;\n\t\t\t\tans += A[0][s.c] * A[1][s.b] % M * A[2][s.a] % M;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s.a == s.b) swap(s.a, s.c);\n\t\t\t\telse if (s.a == s.c) swap(s.a, s.b);\n\t\t\t\tans += A[0][s.a] * A[1][s.b] % M * A[2][s.b] % M;\n\t\t\t\tans += A[0][s.b] * A[1][s.a] % M * A[2][s.b] % M;\n\t\t\t\tans += A[0][s.b] * A[1][s.b] % M * A[2][s.a] % M;\n\t\t\t}\n\t\t\tans %= M;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 300100;\nconst int MAXM = 1100;\nconst ll MOD = 998244353;\n\nll pp[MAXN];\nll dp[MAXM];\nll nk[MAXM];\nll ndp[MAXM];\n\nint N, M;\nvector <int> edge[MAXN];\nint mex[MAXN];\n\nvoid go_tree()\n{\n    cin >> M;\n    for (int i = 0; i < N; i++)\n        edge[i].clear();\n\n    for (int i = 0; i < M; i++)\n    {\n        int x, y;\n        cin >> x >> y;\n        x--, y--;\n        if (x > y) swap (x, y);\n        edge[x].push_back(y);\n    }\n\n    for (int i = N - 1; i >= 0; i--)\n    {\n        set <int> s;\n        for (int neigh : edge[i])\n            s.insert(mex[neigh]);\n        int res = 0;\n        while (s.find(res) != s.end()) res++;\n\n        mex[i] = res;\n    }\n\n    for (int i = 0; i < MAXM; i++)\n        nk[i] = ndp[i] = 0;\n    for (int i = 0; i < N; i++)\n    {\n        nk[mex[i]] = (nk[mex[i]] + pp[i+1]) % MOD;\n    }\n\n    for (int i = 0; i < MAXM; i++)\n        for (int j = 0; j < MAXM; j++)\n        {\n            ndp[i^j] = (ndp[i^j] + dp[i] * nk[j]) % MOD;\n        }\n    for (int i = 0; i < MAXM; i++)\n        dp[i] = ndp[i];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    pp[0] = 1;\n    pp[1] = ((ll) 1e18) % MOD;\n    for (int i = 2; i < MAXN; i++)\n    {\n        pp[i] = (pp[i-1] * pp[1]) % MOD;\n    }\n\n    dp[0] = 1;\n\n    for (int i = 0; i < 3; i++)\n    {\n        go_tree();\n    }\n    cout << dp[0] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nnamespace fwht {\n\ntemplate<typename T>\nvoid hadamard(vector<T> &a) {\n  int n = a.size();\n  for (int k = 1; k < n; k <<= 1) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        T x = a[i + j];\n        T y = a[i + j + k];\n        a[i + j] = x + y;\n        a[i + j + k] = x - y;\n      }\n    }\n  }\n}\n\ntemplate<typename T>\nvector<T> multiply(vector<T> a, vector<T> b) {\n  int eq = (a == b);\n  int n = 1;\n  while (n < (int) max(a.size(), b.size())) {\n    n <<= 1;\n  }\n  a.resize(n);\n  b.resize(n);\n  hadamard(a);\n  if (eq) b = a; else hadamard(b);\n  for (int i = 0; i < n; i++) {\n    a[i] *= b[i];\n  }\n  hadamard(a);\n  T q = 1 / static_cast<T>(n);\n  for (int i = 0; i < n; i++) {\n    a[i] *= q;\n  }\n  return a;\n}\n\n}\n\ntemplate <typename T>\nvoid debug_out(T t) {\n  cerr << t;\n}\n\ntemplate <typename A, typename B>\nvoid debug_out(pair<A, B> u) {\n  cerr << \"(\" << u.first << \" \" << u.second << \")\";\n}\n\ntemplate <typename T>\nvoid debug_out(vector<T> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << \", \";\n  }\n}\n\ntemplate <typename T>\nvoid debug_out(vector<vector<T>> t) {\n  int sz = t.size();\n  for(int i = 0; i < sz; i++) {\n    debug_out(t[i]);\n    if(i != sz - 1) cerr << endl;\n  }\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  debug_out(H);\n  cerr << \" \";\n  debug_out(T...);\n}\n\ntemplate <typename T>\nvoid debug_out(set<T> a) {\n  vector<T> _a;\n  for(T t : a) _a.push_back(t);\n  debug_out(_a);\n}\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\" << endl, debug_out(__VA_ARGS__), cerr << endl;\n\nint n, m;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  vector<Mint> p(3 * n + 1);\n  Mint add = 1;\n  range(i, 0, 18) add *= 10;\n  p[0] = 1;\n  range(i, 1, 3 * n + 1) p[i] = p[i - 1] * add;\n  vector<vector<int>> a(n), b(n), c(n);\n  cin >> m;\n  range(i, 0, m) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    a[u].push_back(v);\n    a[v].push_back(u);\n  }\n  cin >> m;\n  range(i, 0, m) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    b[u].push_back(v);\n    b[v].push_back(u);\n  }\n  cin >> m;\n  range(i, 0, m) {\n    int u, v;\n    cin >> u >> v;\n    u--; v--;\n    c[u].push_back(v);\n    c[v].push_back(u);\n  }\n  vector<int> ap(n), bp(n), cp(n);\n  auto solve = [&](vector<vector<int>> &g, vector<int> &dp) {\n    husk(i, n - 2, -1) {\n      vector<int> cur(g[i].size() + 1);\n      for(int j : g[i]) {\n        if(j > i && dp[j] <= (int) g[i].size()) cur[dp[j]] = 1;\n      }\n      while(cur[dp[i]]) dp[i]++;\n    }\n  };\n  solve(a, ap); solve(b, bp); solve(c, cp);\n  // s[x + y + z] += ((ap[x] ^ bp[y] ^ cp[z]) == 0) * (x + y + z)\n  // s[ap[x] ^ bp[y] ^ cp[z]] += p[x] * p[y] * p[z];\n  vector<Mint> sa(n), sb(n), sc(n);\n  range(i, 0, n) {\n    sa[ap[i]] += p[i + 1];\n    sb[bp[i]] += p[i + 1];\n    sc[cp[i]] += p[i + 1];\n  }\n  vector<Mint> s = fwht::multiply(sa, sb);\n  s = fwht::multiply(s, sc);\n  cout << s[0];\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 3e5+10, P = 998244353;\nint n, m, vis[N], sg[N], h[N], f[3][N];\nvector<int> g[N];\nvoid add(int &a, ll b) {a=(a+b)%P;}\n\nint main() {\n\th[1] = 1000000000000000000ll%P;\n\tREP(i,2,N-1) h[i] = (ll)h[i-1]*h[1]%P;\n\tscanf(\"%d\", &n);\n\tREP(i,0,2) {\n\t\tscanf(\"%d\", &m);\n\t\tREP(j,1,n) g[j].clear();\n\t\tREP(j,1,m) {\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif (u>v) swap(u,v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tPER(j,1,n) {\n\t\t\tint sz = g[j].size();\n\t\t\tREP(k,0,sz) vis[k] = 0;\n\t\t\tfor (int k:g[j]) vis[sg[k]] = 1;\n\t\t\tREP(k,0,sz) if (!vis[k]) {\n\t\t\t\tsg[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(f[i][sg[j]],h[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i,0,400) REP(j,0,400) {\n\t\tadd(ans, (ll)f[0][i]*f[1][j]%P*f[2][i^j]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline int fastpo(int x, int n, int mod) {\n\tint res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\n\nconst int N = 131072;\nconst int LOG = 17;\nconst int mod = 998244353;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nvector<int> e[N];\nint vst[N], par[N];\nstruct M {\n\tLL a;\n\tM operator + (const M & b) const {\n\t\tM res;\n\t\tres.a = a + b.a;\n\t\tif(res.a >= mod) res.a -= mod;\n\t\treturn res;\n\t}\n\tM operator - (const M & b) const {\n\t\tM res;\n\t\tres.a = a - b.a;\n\t\tif(res.a < 0) res.a += mod;\n\t\treturn res;\n\t}\n\tM operator * (const M & b) const {\n\t\treturn M{a * b.a % mod};\n\t}\n};\nM s[3][N];\nM pw[N];\nset<int> st[N];\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tpw[0] = M{1};\n\tint bs = 1000000000000000000ll % mod;\n\tfor(int i = 1; i <= n; i++) pw[i] = pw[i - 1] * M{bs};\n\tfor(int d = 0; d < 3; d++) {\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i = 1; i <= n; i++) e[i].clear();\n\t\tfor(int i = 1; i <= m; i++) {\n\t\t\tint x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tif(y < x) swap(x, y);\n//\t\t\te[x].push_back(y);\n\t\t\te[y].push_back(x);\n\t\t}\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tst[i].clear();\n\t\t}\n\t\tfor(int i(n); i >= 1; i--) {\n\t\t\tint val = 0;\n\t\t\twhile(st[i].count(val)) val++;\n\t\t\t//cout << val << endl;\n\t\t\ts[d][val] = s[d][val] + pw[i];\n\t\t\tfor(int y : e[i]) {\n\t\t\t\tst[y].insert(val);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < LOG; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif((j >> i) & 1) {\n\t\t\t\t\tM a = s[d][j], b = s[d][j - (1 << i)];\n\t\t\t\t\ts[d][j] = a + b;\n\t\t\t\t\ts[d][j - (1 << i)] = b - a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\ts[0][i] = s[1][i] * s[0][i] * s[2][i];\n\t}\n\t//cout << s[0][0].a << ' ' << s[0][1].a << endl;\n\tfor(int i = LOG - 1; i >= 0; i--) {\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tif((j >> i) & 1) {\n\t\t\t\tM a = s[0][j], b = s[0][j - (1 << i)];\n\t\t\t\ts[0][j] = (a - b) * M{(mod + 1) / 2};\n\t\t\t\ts[0][j - (1 << i)] = (a + b) * M{(mod + 1) / 2};\n\t\t\t}\n\t\t}\n\t}\n\tcout << s[0][0].a << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n#include<vector>\n\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int library\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\nclass CGiantGraph {\npublic:\n\n    vector<vector<int>> ga, gb, gc;\n    vector<int> gra, grb, grc;\n    vector<int> tmp;\n    void func(vector<vector<int>>& g, vector<int>& gr, int n) {\n      gr[n-1] = 0;\n      for(int i=n-2; i>=0; i--) {\n        vector<int> v;\n        for(auto e : g[i]) {\n          if (e > i) {\n            tmp[gr[e]]++;\n            v.push_back(gr[e]);\n          }\n        }\n        rep(j, 500) {\n          if (tmp[j] == 0) {\n            gr[i] = j;\n            break;\n          }\n        }\n        for(auto e: v) {\n          tmp[e]--;\n        }\n      }\n    }\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      mod = mod9;\n      int n; cin >> n;\n      tmp.resize(500);\n      ga.resize(n, vector<int>());\n      gb.resize(n, vector<int>());\n      gc.resize(n, vector<int>());\n      gra.resize(n);\n      grb.resize(n);\n      grc.resize(n);\n      vector<mint> suma(500), sumb(500), sumc(500);\n      int m; cin >> m;\n      rep(i, m) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        ga[a].push_back(b);\n        ga[b].push_back(a);\n      }\n      cin >> m;\n      rep(i, m) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        gb[a].push_back(b);\n        gb[b].push_back(a);\n      }\n      cin >> m;\n      rep(i, m) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        gc[a].push_back(b);\n        gc[b].push_back(a);\n      }\n      func(ga, gra, n);\n      func(gb, grb, n);\n      func(gc, grc, n);\n\n\n      mint base = mod_pow(mint(10), 18);\n      mint now = base;\n      rep(i, n) {\n        suma[gra[i]] += now;\n        sumb[grb[i]] += now;\n        sumc[grc[i]] += now;\n        now *= base;\n      }\n\n      mint ans = 0;\n      rep(i, 500) {\n        rep(j, 500) {\n          int k = i^j;\n          if (k >= 500) continue;\n          ans += suma[i]*sumb[j]*sumc[k];\n        }\n      }\n      cout << ans.x << endl;\n    }\n};\n\nsigned main() {\n  CGiantGraph solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,abm,mmx,popcnt,avx,avx2,tune=native\")\n           \n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n           \n//#define int long long\n  \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pld;\n\ntemplate<typename T>\nusing kawaii_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n  \nvoid FAST_IO() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    //cout.setf(ios::fixed);\n    //cout.precision(20);\n    #ifndef _offline\n    //freopen(\"mincost.in\", \"r\", stdin);\n    //freopen(\"mincost.out\", \"w\", stdout);\n    #endif\n}\n\nconst ll mod = 998244353;\nconst ll kek = 716070898;\nconst int K = 500;\nconst int MAXN = 1e5 + 100;\nvector<int> g1[MAXN], g2[MAXN], g3[MAXN];\nint v1[MAXN], v2[MAXN], v3[MAXN];\nll s1[K], s2[K], s3[K];\nbool xy[K][K], xz[K][K], yz[K][K];\n\nll binpow(ll a, ll n) {\n    ll res = 1;\n    while (n) {\n        if (n & 1) {\n            res = (res * a) % mod;\n        }\n        a = (a * a) % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nvoid relax1(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g1[u]) {\n        bs[v1[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v1[u] = i;\n            break;\n        }\n    }\n    s1[v1[u]] += binpow(kek, u + 1);\n    if (s1[v1[u]] >= mod) {\n        s1[v1[u]] -= mod;\n    }\n}\n\nvoid relax2(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g2[u]) {\n        bs[v2[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v2[u] = i;\n            break;\n        }\n    }\n    s2[v2[u]] += binpow(kek, u + 1);\n    if (s2[v2[u]] >= mod) {\n        s2[v2[u]] -= mod;\n    }\n}\n\nvoid relax3(int u) {\n    bitset<K> bs;\n    bs.reset();\n    for (int to : g3[u]) {\n        bs[v3[to]] = 1;\n    }\n    for (int i = 0; ; ++i) {\n        if (!bs[i]) {\n            v3[u] = i;\n            break;\n        }\n    }\n    s3[v3[u]] += binpow(kek, u + 1);\n    if (s3[v3[u]] >= mod) {\n        s3[v3[u]] -= mod;\n    }\n}\n\nsigned main() {\n    FAST_IO();\n    int n;\n    cin >> n;\n    int m1;\n    cin >> m1;\n    for (int i = 0; i < m1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g1[u].push_back(v);\n    }\n    int m2;\n    cin >> m2;\n    for (int i = 0; i < m2; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g2[u].push_back(v);\n    }\n    int m3;\n    cin >> m3;\n    for (int i = 0; i < m3; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;\n        v--;\n        if (u > v) {\n            swap(u, v);\n        }\n        g3[u].push_back(v);\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        relax1(i);\n        relax2(i);\n        relax3(i);\n    }\n    vector<tuple<int, int, int>> kektor;\n    for (int i = 0; i < K; ++i) {\n        if (s1[i] == 0) {\n            continue;\n        }\n        for (int j = 0; j < K; ++j) {\n            if (s2[j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < K; ++k) {\n                if (s3[k] == 0) {\n                    continue;\n                }\n                kektor.push_back(make_tuple(i, j, k));\n            }\n        }\n    }\n    /*sort(all(kektor), [&](tuple<int, int, int> a, tuple<int, int, int> b) {\n        return get<0>(a) + get<1>(a) + get<2>(a) < get<0>(b) + get<1>(b) + get<2>(b);\n    });*/\n    ll ans = 0;\n    for (auto t : kektor) {\n        int x, y, z;\n        tie(x, y, z) = t;\n        if (xy[x][y] || xz[x][z] || yz[y][z]) {\n            continue;\n        }\n        ll val = (s1[x] * s2[y]) % mod;\n        val = (val * s3[z]) % mod;\n        ans += val;\n        if (ans >= mod) {\n            ans -= mod;\n        }\n        xy[x][y] = true;\n        xz[x][z] = true;\n        yz[y][z] = true;\n    }\n    cout << ans << '\\n';\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = 998244353;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 100 * 1000 + 13;\nconst int P = 3000;\n\nint n;\nvector<int> g[3][N];\n\nbool read(){\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\tforn(i, n) forn(j, 3)\n\t\tg[j][i].clear();\n\tforn(j, 3){\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tforn(i, m){\n\t\t\tint v, u;\n\t\t\tscanf(\"%d%d\", &v, &u);\n\t\t\t--v, --u;\n\t\t\tif (v > u) swap(v, u);\n\t\t\tg[j][v].pb(u);\n\t\t}\n\t}\n\treturn true;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * li(b) % MOD;\n}\n\nint gr[3][N];\nint cnt[3][P];\nint pw[N];\n\nint calc(int i, int v){\n\tif (gr[i][v] != -1)\n\t\treturn gr[i][v];\n\tvector<int> tmp;\n\tfor (auto u : g[i][v])\n\t\ttmp.pb(calc(i, u));\n\tsort(all(tmp));\n\tforn(j, sz(tmp)) if (tmp[j] != j)\n\t\treturn gr[i][v] = j;\n\treturn gr[i][v] = sz(tmp);\n}\n\nvoid solve() {\n\tmemset(gr, -1, sizeof(gr));\n\tmemset(cnt, 0, sizeof(cnt));\n\tpw[0] = 1;\n\tpw[1] = INF64 % MOD;\n\tfore(i, 2, N) pw[i] = mul(pw[i - 1], pw[1]);\n\tforn(j, 3) forn(i, n) cnt[j][calc(j, i)] = add(cnt[j][calc(j, i)], pw[i + 1]);\n\tint ans = 0;\n\tforn(i, P) forn(j, P) if ((i ^ j) < P && cnt[0][i] && cnt[1][j] && cnt[2][i ^ j])\n\t\tans = add(ans, mul(mul(cnt[0][i], cnt[1][j]), cnt[2][i ^ j]));\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n#ifdef _DEBUG\n\twhile(read()) {\t\n#else\n\tif(read()) {\n#endif\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n\n#define P 998244353\n#define X 716070898\n\nusing namespace std;\n\nint read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)) ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\n\nconst int N = 100005;\n\nint n,m[3];\nstruct node{\n\tint v;\n\tnode *nxt;\n}pool[N*3],*h[3][N];\nint cnt;\nvoid addedge(int ty,int u,int v){\n\tnode *p=&pool[++cnt];\n\tp->v=v;p->nxt=h[ty][u];h[ty][u]=p;\n}\n\nint mx[3],sum[3][N],used[N],sg[N],mul[N];\nint Plus(int x,int y) { return x+y>=P ? x+y-P : x+y; }\nvoid cal(int ty){\n\tfor(int i=0;i<=m[ty];i++) used[i]=0;\n\tint cur=0;\n\tsg[n]=0; sum[ty][0]=Plus(sum[ty][0],mul[n]);\n\tfor(int i=n-1;i>0;i--){\n\t\t++cur;\n\t\tfor(node *p=h[ty][i];p;p=p->nxt) used[sg[p->v]]=cur;\n\t\tsg[i]=-1;\n\t\tfor(int j=0;j<=mx[ty];j++) \n\t\t\tif(used[j]!=cur){ sg[i]=j; break; }\n\t\tif(sg[i]==-1) sg[i]=++mx[ty];\n\t\tsum[ty][sg[i]]=Plus(sum[ty][sg[i]],mul[i]);\n\t}\n}\n\nint main()\n{\n\tint u,v;\n\tn=read();\n\tfor(int i=0;i<3;i++){\n\t\tm[i]=read();\n\t\tfor(int j=0;j<m[i];j++){\n\t\t\tu=read(); v=read();\n\t\t\tif(u>v) swap(u,v);\n\t\t\taddedge(i,u,v);\n\t\t}\n\t}\n\t\n\tmul[0]=1;\n\tfor(int i=1;i<=n;i++) mul[i]=1ll*mul[i-1]*X%P;\n\tcal(0); cal(1); cal(2);\n\t\n\tint ans=0;\n\tfor(int i=0;i<=mx[0];i++)\n\t\tfor(int j=0;j<=mx[1];j++){\n\t\t\tif((i^j)>mx[2]) continue;\n\t\t\tans=Plus(ans,1ll*sum[0][i]*sum[1][j]%P*sum[2][i^j]%P);\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Problem : C - Giant Graph\n// Contest : AtCoder Grand Contest 043\n// URL : https://atcoder.jp/contests/agc043/tasks/agc043_c\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n// By zghtyarecrenj\n\n#include <cstdio>\n#include <cstring>\n\nnamespace io \n{\n\tconst int MaxBuff = 1 << 15;\n\tconst int MaxOut = 1 << 24;\n\tchar b[MaxBuff], *S = b, *T = b;\n\n\tinline char getc() \n\t{ \n\t\treturn S == T && (T = (S = b) + fread(b, 1, MaxBuff, stdin), S == T) ? 0 : *S++; \n\t}\n} // namespace io\n\ninline void in(int &t)\n{\n\tt = 0; register char ch = io::getc();\n\twhile (ch < '0' || ch > '9') ch = io::getc();\n\tdo t = t * 10 + ch - '0', ch = io::getc(); while (ch >= '0' && ch <= '9');\n}\n\nconst int N = 1e5 + 5;\nconst int ix35 = 998244353;\n\nstruct modint { int a; modint(long long x = 0) { a = x; } };\nconst modint inv2((ix35 + 1) >> 1), base(1000000000000000000ll % ix35);\ninline modint operator +(const modint& a, const modint& b) { return (a.a + b.a < ix35 ? a.a + b.a : a.a + b.a - ix35); }\ninline modint operator -(const modint& a, const modint& b) { return (a.a >= b.a ? a.a - b.a : a.a - b.a + ix35); }\ninline modint operator *(const modint& a, const modint& b) { return ((long long)a.a * b.a) % ix35; }\n\nint n, len, tmp[N];\n\ninline void fwt(modint *f) \n{\n\tfor (int i = 1; i < len; i <<= 1)\n\t\tfor (int j = 0; j < len; j += (i << 1))\n\t\t\tfor (int k = 0; k < i; ++k) \n\t\t\t{\n\t\t\t\tmodint u = f[j + k], v = f[i + j + k];\n\t\t\t\tf[j + k] = u + v, f[i + j + k] = u - v;\n\t\t\t}\n}\n\ninline void ifwt(modint *f)\n{\n\tmodint inv = 1;\n\tfor (int i = 1; i < len; i <<= 1) \n\t\tinv = inv * inv2;\n\tfor (int i = 0; i < len; ++i)\n\t\tf[i] = f[i] * inv;\n}\n\nstruct graph\n{\n\tint m, head[N], to[N], nxt[N], tot, f[N];\n  \tmodint x[N * 2];\n  \t\t\n\tinline void addedge(int x, int y)\n\t{\n\t\tnxt[++tot] = head[x], head[x] = tot, to[tot] = y;\n\t}\n\t\n\tinline void read()\n\t{\n\t\tin(m);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x, y;\n\t\t\tin(x), in(y);\n\t\t\tif (x < y)\n\t\t\t\taddedge(x, y);\n\t\t\telse\n\t\t\t\taddedge(y, x);\n\t\t}\n\t}\n\t\n\tinline void init()\n\t{\n\t\tfor (int i = n; i; --i)\n\t\t{\n\t\t\tf[i] = 0;\n\t\t\tfor (int j = head[i]; j; j = nxt[j]) tmp[f[to[j]]] = 1;\n\t\t\twhile (tmp[f[i]]) ++f[i];\n\t\t\tfor (int j = head[i]; j; j = nxt[j]) tmp[f[to[j]]] = 0;\n\t\t}\n\t}\n\t\n\tinline void prep()\n\t{\n\t\tmodint tmp = 1;\n\t\tfor (int i = 1; i <= n; ++i) \n\t\t\ttmp = tmp * base, x[f[i]] = x[f[i]] + tmp;\n\t}\n} g1, g2, g3;\n\nint main()\n{\n\tin(n);\n\tg1.read(), g2.read(), g3.read();\n\tg1.init(), g2.init(), g3.init();\n\tg1.prep(), g2.prep(), g3.prep();\n\tfor (len = 1; len < n; len <<= 1) ;\n\tfwt(g1.x), fwt(g2.x), fwt(g3.x);\n\tfor (int i = 0; i < len; ++i)\n\t\tg1.x[i] = g1.x[i] * g2.x[i] * g3.x[i];\n\tfwt(g1.x), ifwt(g1.x);\n\tprintf(\"%d\\n\", g1.x[0].a);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst int MOD=998244353;\n#define SZ 666666\nint n;\nstruct G\n{\nvector<int> v[SZ];\nint sg[SZ];\nbool b[SZ];\nvoid dfs(int x)\n{\n\tif(b[x]) return;\n\tb[x]=1;\n\tset<int> sp;\n\tfor(auto bb:v[x])\n\t{\n\t\tdfs(bb);\n\t\tsp.insert(sg[bb]);\n\t}\n\tsg[x]=0;\n\twhile(sp.count(sg[x]))\n\t\t++sg[x];\n}\nvoid ip()\n{\n\tint m;\n\tscanf(\"%d\",&m);\n\twhile(m--)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tif(a>b) swap(a,b);\n\t\tv[a].pb(b);\n\t}\n\tfor(int i=n;i>=1;--i) dfs(i);\n}\n}T[3];\nll qp(ll a,ll b)\n{\n\tll x=1; a%=MOD;\n\twhile(b)\n\t{\n\t\tif(b&1) x=x*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn x;\n}\nint c[3][SZ];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tll x[2]={1,0};\n\tfor(int i=0;i<3;++i)\n\t{\n\t\tT[i].ip();\n\t\tfor(int j=1;j<=n;++j) (c[i][T[i].sg[j]]+=qp(1e18,j))%=MOD;\n\t}\n\tll ans=0;\n\tfor(int i=0;i<=n;++i)\n\t\tfor(int j=0;j<=n;++j)\n\t\t\tans+=c[0][i]*(ll)c[1][j]%MOD*c[2][i^j]%MOD;\n\tcout<<(ans%MOD+MOD)%MOD<<\"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<map>\n#define RI register int\n#define CI const int&\n#define VI vector <int>:: iterator\nusing namespace std;\nconst int N=100005,mod=998244353,base=(long long)1e18%mod;\nint n,x,y,ans,pw[N];\ninline void inc(int& x,CI y)\n{\n\tif ((x+=y)>=mod) x-=mod;\n}\nclass Graph\n{\n\tprivate:\n\t\tvector <int> v[N]; int m,sg[N];\n\t\tinline int SG(CI x)\n\t\t{\n\t\t\tif (~sg[x]) return sg[x]; map <int,bool> ext;\n\t\t\tfor (VI to=v[x].begin();to!=v[x].end();++to) ext[SG(*to)]=1;\n\t\t\twhile (ext[++sg[x]]); return sg[x];\n\t\t}\n\tpublic:\n\t\tint mx,c[N];\n\t\tinline void solve(void)\n\t\t{\n\t\t\tRI i; for (scanf(\"%d\",&m),i=1;i<=m;++i)\n\t\t\tif (scanf(\"%d%d\",&x,&y),x<y) v[x].push_back(y); else v[y].push_back(x);\n\t\t\tfor (memset(sg,-1,sizeof(sg)),i=1;i<=n;++i) if (!~sg[i]) sg[i]=SG(i);\n\t\t\tfor (i=1;i<=n;++i) mx=max(mx,sg[i]),inc(c[sg[i]],pw[i]);\n\t\t}\n\t\tinline void output(void)\n\t\t{\n\t\t\tRI i; printf(\"%d\\n\",mx);\n\t\t\tfor (i=1;i<=n;++i) printf(\"%d \",sg[i]); putchar('\\n');\n\t\t\tfor (i=1;i<=n;++i) printf(\"%d \",c[i]); putchar('\\n');\n\t\t}\n}G[3];\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&n),pw[0]=i=1;i<=n;++i) pw[i]=1LL*pw[i-1]*base%mod;\n\tfor (i=0;i<3;++i) G[i].solve();\n\tfor (i=0;i<=G[0].mx;++i) for (j=0;j<=G[1].mx;++j)\n\tinc(ans,1LL*G[0].c[i]*G[1].c[j]%mod*G[2].c[i^j]%mod);\n\treturn printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nint poww(int a , int b){int tms = 1; while(b){if(b & 1) tms = 1ll * tms * a % MOD; a = 1ll * a * a % MOD; b >>= 1;} return tms;}\nint mex[3][503] , N , M , ans; vector < int > nxt[100003];\n\nvoid calc(int *arr){\n\tfor(int i = 1 ; i <= N ; ++i) nxt[i].clear();\n\tcin >> M; for(int i = 1 ; i <= M ; ++i){int p , q; cin >> p >> q; nxt[min(p , q)].push_back(max(p , q));}\n\tstatic int tmp[503] , val[100003]; memset(val , 0 , sizeof(val));\n\tfor(int i = N ; i ; --i){\n\t\tfor(auto t : nxt[i]) tmp[val[t]] = 1;\n\t\twhile(tmp[val[i]]) ++val[i];\n\t\tfor(auto t : nxt[i]) tmp[val[t]] = 0;\n\t\tarr[val[i]] = (arr[val[i]] + poww(10 , 18 * i)) % MOD;\n\t}\n}\n\nint main(){\n\tcin >> N; calc(mex[0]); calc(mex[1]); calc(mex[2]);\n\tfor(int i = 0 ; i <= 500 ; ++i)\n\t\tfor(int j = 0 ; j <= 500 ; ++j)\n\t\t\tans = (ans + 1ll * mex[0][i] * mex[1][j] % MOD * mex[2][i ^ j]) % MOD;\n\tcout << ans; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int MAXN = 1e5 + 11;\nconst int MAXM = 444;\nconst int mod = 998244353;\n#define FOR(i, a, b) for(int i = (a);i <= (b); i++)\n#define ROF(i, a, b) for(int i = (a);i >= (b); i--)\nint n, m;\nint f[3][MAXM], sg[MAXN], mark[MAXM];\nvector<int> G[MAXN];\nvoid Add(int &x, int y){\n    x = x + y - (x + y >= mod ? mod : 0);\n}\nvoid Mu(int &x, int y){\n    x = 1LL * x * y % mod;\n}\nint A(int x, int y){\n    return x + y - (x + y >= mod ? mod : 0);\n}\nint M(int x, int y){\n    return 1LL * x * y % mod;\n}\nint ksm(int base, int x){\n    base %= mod;\n    int ans = 1;\n    while(x){\n        if(x & 1)Mu(ans, base);\n        x >>= 1;\n        Mu(base, base);\n    }\n    return ans;\n}\nint main(){\n    cin>>n;\n    FOR(t, 0, 2){\n        cin>>m;\n        int u, v;\n        memset(sg, -1, sizeof sg);\n        memset(mark, 0, sizeof mark);\n        FOR(i, 1, m){\n            scanf(\"%d%d\", &u, &v);\n            if(u < v)swap(u, v);\n            G[v].push_back(u);\n        }\n        ROF(u, n, 1){\n            for(int v : G[u]){\n                mark[sg[v]] = u;\n            }\n            sg[u] = 0;\n            while(mark[sg[u]] == u)sg[u]++;\n            Add(f[t][sg[u]], ksm((LL)(1e18 + 0) % mod, u));\n            G[u].clear();\n            //printf(\"u=%d sg=%d\\n\", u, sg[u]);\n        }\n    }\n    int ans = 0;\n    FOR(i, 0, 400){\n        FOR(j, 0, 400){\n            Add(ans, M(M(f[0][i],f[1][j]), f[2][i^j]));\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint B(int N, string& a) {\n\tint x, sign;\n\tlong long p;\n\tx = 0;\n\tp = sign = 1;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx = abs(x + sign * p * (a[i] - '0')) % 2;\n\t\tp = p * (N - i - 1) / (i + 1);\n\t\tsign *= -1;\n\t}\n\n\treturn x;\n}\n\nint main() {\n\tint N;\n\tstring a;\n\tcin >> N >> a;\n\tcout << B(N, a) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\nnamespace dfcmd {\n\n    typedef long long LL;\n\n    const int maxn = 100005;\n    const int mod = 998244353;\n    const int di = 1000000000000000000LL % mod;\n\n    int bin[maxn];\n\n    inline void add(int& x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    int n;\n\n    struct myhnb {\n        int m;\n        int sg[maxn];\n        int ss[maxn];\n\n        struct Edge {\n            int to, nxt;\n        } e[maxn];\n\n        int first[maxn];\n\n        inline void add_edge(int u, int v) {\n            static int cnt = 0;\n            if (u > v) {\n                swap(u, v);\n            }\n            e[++cnt].nxt = first[u];\n            first[u] = cnt;\n            e[cnt].to = v;\n        }\n\n        int vis[maxn];\n\n        myhnb() {\n            memset(first, 0, sizeof(first));\n            memset(ss, 0, sizeof(ss));\n            memset(vis, 0, sizeof(vis));\n        }\n\n        inline void Dfs() {\n            for (int now = n; now; --now) {\n                vis[now] = true;\n                set<int> sgg;\n                sgg.clear();\n                for (int i = first[now]; i; i = e[i].nxt) {\n                    sgg.insert(sg[e[i].to]);\n                }\n                sg[now] = 0;\n                while (sgg.count(sg[now])) {\n                    sg[now]++;\n                }\n                add(ss[sg[now]], bin[now]);\n            }\n        }\n\n        inline int& operator [] (int x) {\n            return ss[x];\n        }\n    } d[3];\n\n    int main() {\n        read(n);\n        bin[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            bin[i] = (LL) bin[i - 1] * di % mod;\n        }\n        for (int i = 0; i < 3; ++i) {\n            read(d[i].m);\n            for (int j = 1; j <= d[i].m; ++j) {\n                int u, v;\n                read(u), read(v);\n                d[i].add_edge(u, v);\n            }\n            d[i].Dfs();\n//            cout << \"sg = \";\n//            for (int j = 1; j <= n; ++j) {\n//                cout << d[i].sg[j] << ' ';\n//            }\n//            cout << endl;\n        }\n        int ans = 0;\n        for (int i = 0; i <= 5000; ++i) {\n            for (int j = 0; j <= 5000; ++j) {\n                add(ans, (LL) d[0][i] * d[1][j] % mod * d[2][i ^ j] % mod);\n            }\n        }\n        writeln(ans);\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 100005, P = 998244353, V = 716070898;\n\nint n, m, pw[N];\n\nstruct Graph {\n\tstd::vector<int> E[N];\n\n\tvoid addEdge(int u, int v) {\n\t\tif (u > v) {\n\t\t\tstd::swap(u, v);\n\t\t}\n\t\tE[u].push_back(v);\n\t}\n\n\tint vis[N], sg[N], mx, sum[N];\n\n\tvoid getSG() {\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tvis[i] = 0, sum[i] = 0;\n\t\t}\n\t\tfor (int u = n; u; --u) {\n\t\t\tfor (int v : E[u]) {\n\t\t\t\tvis[sg[v]] = u;\n\t\t\t}\n\t\t\tsg[u] = 0;\n\t\t\twhile (vis[sg[u]] == u) {\n\t\t\t\t++sg[u];\n\t\t\t}\n\t\t\tsum[sg[u]] = (sum[sg[u]] + pw[u]) % P;\n\t\t}\n\t\tmx = n;\n\t\twhile (mx >= 0 && !sum[mx]) {\n\t\t\t--mx;\n\t\t}\n\t}\n} G[3];\n\nvoid solve() {\n\tread(n);\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpw[i] = 1ll * pw[i - 1] * V % P;\n\t}\n\tfor (int k = 0; k < 3; ++k) {\n\t\tread(m);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u, v;\n\t\t\tread(u), read(v);\n\t\t\tG[k].addEdge(u, v);\n\t\t}\n\t\tG[k].getSG();\n\t}\n\tint ans = 0;\n\tfor (int x = 0; x <= G[0].mx; ++x) {\n\t\tfor (int y = 0; y <= G[1].mx; ++y) {\n\t\t\tint z = x ^ y;\n\t\t\tif (z <= G[2].mx) {\n\t\t\t\tans = (ans + 1ll * G[0].sum[x] * G[1].sum[y] % P * G[2].sum[z]) % P;\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n\nint main() {\n\tint T = 1;\n\t// read(T);\n\twhile (T--) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) ((x).size()))\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll mod = 998244353, p18 = (ll) 1e18 % mod;\nconst int mg = 1 << 9;\nint n, m, g[100100];\nll p[100100], r[mg];\nvector<int> e[100100];\n\nvoid solve() {\n  cin >> m;\n  for (int i = 0; i < n; i++)\n    e[i].clear();\n  int a, b;\n  for (int i = 0; i < m; i++) {\n    cin >> a >> b, a--, b--;\n    if (a > b)\n      swap(a, b);\n    e[a].push_back(b);\n  }\n  ll s[mg], nr[mg];\n  for (int i = 0; i < mg; i++)\n    s[i] = nr[i] = 0;\n  for (int i = n - 1; i >= 0; i--) {\n    sort(e[i].begin(), e[i].end(), [&](int a, int b){return g[a] < g[b];});\n    reverse(e[i].begin(), e[i].end());\n    g[i] = 0;\n    while (!e[i].empty() && g[e[i].back()] == g[i]) {\n      g[i]++;\n      while (!e[i].empty() && g[e[i].back()] < g[i])\n        e[i].pop_back();\n    }\n    s[g[i]] += p[i + 1];\n  }\n  for (int i = 0; i < mg; i++)\n    s[i] %= mod;\n  for (int i = 0; i < mg; i++)\n    for (int j = 0; j < mg; j++)\n      nr[i ^ j] = (nr[i ^ j] + s[i] * r[j]) % mod;\n  for (int i = 0; i < mg; i++)\n    r[i] = nr[i];\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  p[0] = 1;\n  for (int i = 1; i <= n; i++)\n    p[i] = (p[i - 1] * p18) % mod;\n  r[0] = 1;\n  solve();\n  solve();\n  solve();\n  cout << r[0] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int S = 500, SSS = S * S * S, N = 1e5 + 5, mod = 998244353;\n \nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n \nconst int base = powmod(10, 18);\n \nbitset<SSS> vis;\n \nint pos(int a, int b, int c) {\n  return ((a * S) + b) * S + c;\n}\n \ntuple<int, int, int> decod(int v) {\n  int c = v % S;\n  v /= S;\n  int b = v % S;\n  v /= S;\n  return make_tuple(v, b, c);\n}\n \nvector<int> g[N];\n \nvector<pair<int, int>> independent(int n, vector<pair<int ,int>> & edges) {\n  for (int i = 0; i < n; ++i)\n    g[i].clear();\n  for (auto e : edges) {\n    g[e.first].push_back(e.second);\n    g[e.second].push_back(e.first);\n  }\n  vector<bool> done(n, false), mark(n);\n  int cnt = 0;\n  vector<pair<int, int>> res;\n  while (cnt < n) {\n    mark = done;\n    int hig = -1, sum = 0;\n    for (int v = n-1; v >= 0; --v) {\n      if (mark[v]) continue;\n      ++cnt;\n      done[v] = 1;\n      hig = max(hig, v+1);\n      sum = (sum + powmod(base, v+1)) % mod;\n      for (int u : g[v]) {\n        mark[u] = 1;\n      }\n    }\n    res.emplace_back(hig, sum);\n  }\n  return res;\n}\n \nvector<pair<int, int>> read_edges() {\n  int m;\n  scanf(\"%d\", &m);\n  vector<pair<int, int>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &edges[i].first, &edges[i].second);\n    --edges[i].first;\n    --edges[i].second;\n  }\n  return edges;\n}\n \nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> ex = read_edges();\n  vector<pair<int, int>> ey = read_edges();\n  vector<pair<int, int>> ez = read_edges();\n  vector<pair<int, int>> rx = independent(n, ex);\n  vector<pair<int, int>> ry = independent(n, ey);\n  vector<pair<int, int>> rz = independent(n, ez);\n  assert(rx.size() < S);\n  assert(ry.size() < S);\n  assert(rz.size() < S);\n  vector<vector<bool>> xy(rx.size(), vector<bool>(ry.size(), false));\n  vector<vector<bool>> xz(rx.size(), vector<bool>(rz.size(), false));\n  vector<vector<bool>> yz(ry.size(), vector<bool>(rz.size(), false));\n  // priority_queue<pair<int, int>> pq;\n  // auto insert_node = [&](int i, int j, int k) {\n  //   if (i >= (int)rx.size() || j >= (int)ry.size() || k >= (int)rz.size())\n  //     return;\n  //   int now = pos(i, j, k);\n  //   if (vis[now])\n  //     return;\n  //   pq.emplace(rx[i].first + ry[j].first + rz[k].first, now);\n  //   vis[now] = 1;\n  // };\n\n  // insert_node(0, 0, 0);\n  vector<pair<int, int>> all;\n  for (int i = 0; i < (int)rx.size(); ++i) {\n    for (int j = 0; j< (int)ry.size(); ++j) {\n      for (int k = 0; k < (int)rz.size(); ++k) {\n        all.emplace_back(-(rx[i].first + ry[j].first + rz[k].first), pos(i, j, k));\n      }\n    }\n  }\n  sort(all.begin(), all.end());\n  long long ans = 0;\n  for (auto it : all) {\n    int i, j, k;\n    tie(i, j, k) = decod(it.second);\n    // insert_node(i+1, j, k);\n    // insert_node(i, j+1, k);\n    // insert_node(i, j, k+1);\n    if (xy[i][j] || xz[i][k] || yz[j][k]) continue;\n    long long cur = rx[i].second * (long long) ry[j].second % mod;\n    cur = cur * rz[k].second % mod;\n    ans = (ans + cur) % mod;\n    xy[i][j] = 1;\n    xz[i][k] = 1;\n    yz[j][k] = 1;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\nmt19937 R(chrono::system_clock().now().time_since_epoch().count());\n\nconst int N = 666666,mo=998244353;\nint n;\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline void sub(int &x, int y){x=x-y>=0?x-y:x-y+mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nstruct Y{\n\tVi e[N];int sg[N],f[N],mx;bool vis[N];\n\tvoid solve(){\n\t\tint m;read(m);\n\t\twhile(m--){\n\t\t\tint u,v;read(u);read(v);if(u>v)swap(u,v);\n\t\t\te[u].pb(v);\n\t\t}\n\t\tper(i,n,1){\n\t\t\tfor(int j:e[i])vis[sg[j]]++;\n\t\t\tfor(;vis[sg[i]];sg[i]++);\n\t\t\tfor(int j:e[i])vis[sg[j]]=0;\n\t\t}\n\t\trep(i,1,n)add(f[sg[i]],power(10,18*i)),umax(mx,sg[i]);\n\t}\n}a,b,c;\nint main() {\n\tread(n);\n\ta.solve();\n\tb.solve();\n\tc.solve();\n\tint res=0;\n\trep(i,0,a.mx)rep(j,0,b.mx)res=(res+1ll*a.f[i]*b.f[j]%mo*c.f[i^j])%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by Ильдар Ялалов on 14.01.2020.\n//\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n\n\n#ifdef zxc\n\n#include <random>\n#include <iostream>\n#include <vector>\n#include <string.h>\n#include <set>\n#include <array>\n#include <math.h>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <sstream>\n#include <unordered_map>\n#include <stack>\n\n#else\n#include <bits/stdc++.h>\n#endif\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int inf_int = 1e9 + 100;\nconst ll inf_ll = 1e18;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef double dbl;\n#define pb push_back\n#define eb emplace_back\nconst double pi = 3.1415926535898;\n#define dout if(debug) cout\n#define fi first\n#define se second\n#define sp setprecision\n#define sz(a) (int(a.size()))\n#define all(a) a.begin(),a.end()\ntypedef unsigned int uint;\n\n\n#ifdef zxc\n\n#include \"debug.h\"\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n\nbool debug = 0;\nconst int MAXN = 2e5 + 100;\nconst int LOG = 20;\nconst int mod = 998244353;\nconst int MX = (1e7);\ntypedef long long li;\n\ntemplate<uint MD>\nstruct ModInt {\n    using M = ModInt;\n    uint v;\n\n    ModInt() : v{0} {}\n\n    ModInt(ll _v) : v{normS(_v % MD + MD)} {}\n\n    explicit operator bool() const { return v != 0; }\n\n    static uint normS(uint x) { return (x < MD) ? x : x - MD; };\n\n    static M make(uint x) {\n        M m;\n        m.v = x;\n        return m;\n    }\n\n    static M inv(const M &x) { return x.pow(MD - 2); }\n\n    M operator+(const M &r) const { return make(normS(v + r.v)); }\n\n    M operator-(const M &r) const { return make(normS(v + MD - r.v)); }\n\n    M operator*(const M &r) const { return make(ull(v) * r.v % MD); }\n\n    M operator/(const M &r) const { return *this * inv(r); }\n\n    M &operator+=(const M &r) { return *this = *this + r; }\n\n    M &operator-=(const M &r) { return *this = *this - r; }\n\n    M &operator*=(const M &r) { return *this = *this * r; }\n\n    M &operator/=(const M &r) { return *this = *this / r; }\n\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n};\n\nusing Mint = ModInt<998244353>;\n\nvector<int> g[MAXN];\n\nMint val[3][MAXN];\n\nint used[MAXN];\nint timer = 1;\n\nint grandy[MAXN];\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    int mx_val = 0;\n    for (int j = 0; j < 3; ++j) {\n        int m;\n        cin >> m;\n        for (int i = 1; i <= n; ++i) {\n            g[i].clear();\n        }\n        for (int i = 1; i <= m; ++i) {\n            int a, b;\n            cin >> a >> b;\n            if (a > b)\n                swap(a, b);\n            g[a].pb(b);\n        }\n\n        Mint start = Mint((ll) 1e18);\n        for (int i = n; i >= 1; --i) {\n            timer++;\n            for (int to:g[i]) {\n                used[grandy[to]] = timer;\n            }\n            int top = 0;\n            while (used[top] == timer) {\n                top++;\n            }\n            grandy[i] = top;\n\n            val[j][grandy[i]] += start.pow(i);\n\n            mx_val = max(mx_val, top);\n        }\n    }\n\n    Mint ans = 0;\n    for (int i = 0; i <= mx_val; ++i) {\n        for (int j = 0; j <= mx_val; ++j) {\n            int last = i ^ j;\n            if(last <= mx_val){\n                ans += val[0][i] * val[1][j] * val[2][last];\n            }\n\n        }\n    }\n    cout << ans.v<<\"\\n\";\n}\n\n\nsigned main() {\n#ifdef zxc\n    freopen(\"../input.txt\", \"r\", stdin);\n//    freopen(\"../output.txt\", \"w\", stdout);\n#else\n    //    freopen(\"input.txt\", \"r\", stdin);\n    //    freopen(\"output.txt\", \"w\", stdout);\n#endif //zxc\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(15);\n\n    int t = 1;\n    while (t--)\n        solve();\n\n\n    debug(1.0 * clock() / CLOCKS_PER_SEC);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nint main(){\n    using namespace std;\n    constexpr unsigned long MOD = 998244353;\n    const auto& modpow = [](unsigned long n, unsigned long b = 1, unsigned long a = 716070898) -> unsigned long {\n        unsigned long r{b % MOD};\n        while(n){\n            if(n & 1)(r *= a) %= MOD;\n            (a *= a) %= MOD;\n            n >>= 1;\n        }\n        return r;\n    };\n    unsigned long N;\n    cin >> N;\n    vector<unsigned long> indpX, indpY, indpZ;\n    for(unsigned long _{0}; _ < 3; ++_){\n        swap(indpX, indpY);\n        swap(indpZ, indpY);\n        unsigned long M;\n        cin >> M;\n        vector<vector<unsigned long>> edge(N);\n        for(unsigned long i{0}, a, b; i < M; ++i){\n            cin >> a >> b;\n            if(a < b)swap(a, b);\n            edge[--a].push_back(--b);\n        }\n        vector<unsigned long> id(N, N - 1);\n        for(unsigned long i{N}; i--; )for(const auto& j : edge[i])id[j] -= id[j] == id[i];\n        map<unsigned long, pair<unsigned long, unsigned long>> mp;\n        for(unsigned long i{0}; i < N; ++i){\n            mp[id[i]].first = i + 1;\n            (mp[id[i]].second += modpow(i + 1)) %= MOD;\n        }\n        vector<pair<unsigned long, unsigned long>> Z;\n        for(const auto& i : mp)Z.emplace_back(i.second);\n        sort(Z.begin(), Z.end(), greater<>());\n        for(const auto& i : Z)indpZ.emplace_back(i.second);\n    }\n    if(indpX.size() > indpZ.size())swap(indpX, indpZ);\n    if(indpY.size() > indpZ.size())swap(indpY, indpZ);\n    if(indpX.size() > indpY.size())swap(indpX, indpY);\n    indpY.resize(indpX.size());\n    assert(indpX.size() < 500);\n    unsigned long MX{indpX.size()}, MY{indpY.size()};\n    string al{string(MX, '1')};\n    vector<bitset<500>> usedY(MY, bitset<500>(al));\n    unsigned long ans{0};\n    for(const auto& i : indpZ){\n        bitset<500> used{al};\n        unsigned long tmp{0};\n        for(unsigned long j{0}; j < MY; ++j){\n            unsigned long k{(usedY[j] & used)._Find_first()};\n            used[k] = false;\n            usedY[j][k] = false;\n            tmp += indpY[j] * indpX[k] % MOD;\n        }\n        tmp %= MOD;\n        ans += i * tmp % MOD;\n    }\n    cout << ans % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = (1 << 17);\nconst int MOD = 998244353;\nconst int INV = (MOD + 1) >> 1;\nconst int POW = (long long)(1E18) % MOD;\n\nvoid fwt(int *a, int n, int type) {\n    for(int s=2;s<=n;s<<=1) {\n        int t = (s>>1);\n        for(int i=0;i<n;i+=s) {\n            for(int j=0;j<t;j++) {\n                int x = a[i+j], y = a[i+j+t];\n                a[i+j] = (type == -1) ? 1LL*(x + y)%MOD*INV%MOD : (x + y)%MOD;\n                a[i+j+t] = (type == -1) ? 1LL*(x + MOD - y)%MOD*INV%MOD : (x + MOD - y)%MOD;\n            }\n        }\n    }\n}\n\nvector<int>G[MAXN + 5];\nint mex[MAXN + 5], sg[MAXN + 5];\n\nint ans[MAXN + 5], tmp[MAXN + 5], pw[MAXN + 5];\nint main() {\n\tpw[0] = 1;\n\tfor(int i=1;i<=MAXN;i++)\n\t\tpw[i] = 1LL*pw[i-1]*POW%MOD;\n\t\t\n\tint N; scanf(\"%d\", &N);\n\tint len; for(len = 1; len < N; len <<= 1);\n\tans[0] = 1; fwt(ans, len, 1);\n\tfor(int o=0;o<3;o++) {\n\t\tint M; scanf(\"%d\", &M);\n\t\tfor(int i=1;i<=N;i++) G[i].clear();\n\t\tfor(int i=1;i<=M;i++) {\n\t\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\t\tif( u > v ) swap(u, v);\n\t\t\tG[u].push_back(v);\n\t\t}\n\t\tfor(int i=N;i>=1;i--) {\n\t\t\tfor(int j=0;j<G[i].size();j++)\n\t\t\t\tmex[sg[G[i][j]]] = true;\n\t\t\tsg[i] = 0;\n\t\t\twhile( mex[sg[i]] ) sg[i]++;\n\t\t\tfor(int j=0;j<G[i].size();j++)\n\t\t\t\tmex[sg[G[i][j]]] = false;\n\t\t}\n\t\tfor(int i=0;i<len;i++) tmp[i] = 0;\n\t\tfor(int i=1;i<=N;i++) tmp[sg[i]] = (tmp[sg[i]] + pw[i]) % MOD;\n\t\tfwt(tmp, len, 1);\n\t\tfor(int i=0;i<len;i++) ans[i] = 1LL*ans[i]*tmp[i]%MOD;\n\t}\n\tfwt(ans, len, -1), printf(\"%d\\n\", ans[0]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem C by cookiedoth\nGenerated 21 Mar 2020 at 04.36 PM\n\n\n______▄███████▄_______\n______█▄█████▄█_______\n______█▼▼▼▼▼█_______\n_____██________ ██______\n______█▲▲▲▲▲█_______\n______█████████_______\n_______██____ ██________\n\n>_<\no_O\n^_^\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nstruct graph {\n\tvector<vector<int> > g;\n\tint n, m;\n\n\tgraph() {}\n\n\tvoid read(int _n) {\n\t\tn = _n;\n\t\tcin >> m;\n\t\tg.resize(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tif (u > v) {\n\t\t\t\tswap(u, v);\n\t\t\t}\n\t\t\tg[u].push_back(v);\n\t\t}\n\t}\n\n\tvector<int> val, used;\n\n\tvector<int> calc_f() {\n\t\tval.resize(n);\n\t\tused.resize(n + 1, -1);\n\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\tfor (auto v : g[i]) {\n\t\t\t\tused[val[v]] = i;\n\t\t\t}\n\t\t\tfor (int j = 0; j <= n; ++j) {\n\t\t\t\tif (used[j] != i) {\n\t\t\t\t\tval[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn val;\n\t}\n};\n\nconst int MOD = 998244353;\nconst int C = (ll)1e18 % (ll)MOD;\n\nint mul(int a, int b) {\n\treturn (1LL * a * b) % MOD;\n}\n\nint power(int a, int deg) {\n\tint res = 1;\n\twhile (deg) {\n\t\tif (deg & 1) {\n\t\t\tres = mul(res, a);\n\t\t}\n\t\ta = mul(a, a);\n\t\tdeg >>= 1;\n\t}\n\treturn res;\n}\n\nvoid add(int &a, int b) {\n\ta = (a + b) % MOD;\n}\n\nint diff(int a, int b) {\n\treturn (a - b + MOD) % MOD;\n}\n\ngraph G1, G2, G3;\nvector<int> v1, v2, v3;\nmap<int, int> mp1, mp2, mp3;\nint sum1, sum2, sum3;\n\nvoid calc_map(vector<int> &v, map<int, int> &mp, int &sum) {\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tadd(mp[v[i]], power(C, i + 1));\n\t\tadd(sum, power(C, i + 1));\n\t}\n}\n\nint n;\n\nsigned main() {\n\tfast_io();\n\tcin >> n;\n\tG1.read(n);\n\tv1 = G1.calc_f();\n\tG2.read(n);\n\tv2 = G2.calc_f();\n\tG3.read(n);\n\tv3 = G3.calc_f();\n\tcalc_map(v1, mp1, sum1);\n\tcalc_map(v2, mp2, sum2);\n\tcalc_map(v3, mp3, sum3);\n\tint ans = 0;\n\tfor (auto pp1 : mp1) {\n\t\tfor (auto pp2 : mp2) {\n\t\t\tadd(ans, mul(mul(pp1.second, pp2.second), mp3[pp1.first ^ pp2.first]));\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ntemplate<unsigned MOD_> struct ModInt {\n    static constexpr unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconstexpr LL MOD = 998244353;\nusing Mint = ModInt<MOD>;\n\nint N;\nint S[100011];\nMint B[100011];\n\nvector<Mint> calc() {\n    int M;\n    scanf(\"%d\", &M);\n    vector<pair<int, int> > E;\n    REP (i, M) {\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tif (x > y) swap(x, y);\n\tE.emplace_back(x, y);\n    }\n    sort(E.begin(), E.end());\n    reverse(E.begin(), E.end());\n\n    for (int v=N, i=0; v>=1; v--) {\n\tVI ar;\n\n\twhile (i < (int)E.size() && E[i].first == v) {\n\t    int p = E[i].second;\n\t    ar.push_back(S[p]);\n\t    i++;\n\t}\n\tsort(ar.begin(), ar.end());\n\tar.erase(unique(ar.begin(), ar.end()), ar.end());\n\tar.push_back(-1);\n\tS[v] = 100;\n\tREP (j, ar.size()) if (ar[j] != j) {\n\t    S[v] = j;\n\t    break;\n\t}\n    }\n\n    int ma = *max_element(S+1, S+N+1);\n    vector<Mint> ret(ma+1);\n    for (int v=1; v<=N; v++) {\n\tret[S[v]] += B[v];\n    }\n    return ret;\n}\n\nvoid MAIN() {\n    B[0] = 1;\n    B[1] = Mint(10).pow(18);\n    for (int i=2; i<100011; i++) B[i] = B[i-1] * B[1];\n\n    scanf(\"%d\", &N);\n    auto X = calc();\n    auto Y = calc();\n    auto Z = calc();\n\n    Mint ans = 0;\n    Mint XE = 0, XO = 0;\n    REP (i, X.size()) (i&1? XO: XE) += X[i];\n    Mint YE = 0, YO = 0;\n    REP (i, Y.size()) (i&1? YO: YE) += Y[i];\n    Mint ZE = 0, ZO = 0;\n    REP (i, Z.size()) (i&1? ZO: ZE) += Z[i];\n\n\n    //ans += XE * YE * ZE;\n    //ans += XO * YO * ZE;\n    //ans += XO * YE * ZO;\n    //ans += XE * YO * ZO;\n\n    ans += X[0] * Y[0] * Z[0];\n    REP (t, 3) {\n        REP (i, min(Y.size(), Z.size())) if (i) {\n\t    ans += X[0] * Y[i] * Z[i];\n        }\n        if (t == 0) swap(X, Y);\n        if (t == 1) swap(X, Z);\n    }\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<vector<int>>> g(3, vector<vector<int>>(n));\n  for (int r = 0; r < 3; r++) {\n    int m;\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      if (x > y) {\n        swap(x, y);\n      }\n      g[r][x].push_back(y);\n    }\n  }\n  Mint p = (long long) 1e18;\n  vector<Mint> pw(n);\n  pw[0] = p;\n  for (int i = 1; i < n; i++) {\n    pw[i] = pw[i - 1] * p;\n  }\n  const int MAX = 512;\n  vector<vector<Mint>> cnt(3, vector<Mint>(MAX));\n  for (int r = 0; r < 3; r++) {\n    vector<int> gr(n);\n    for (int i = n - 1; i >= 0; i--) {\n      set<int> s;\n      for (int j : g[r][i]) {\n        s.insert(gr[j]);\n      }\n      while (s.find(gr[i]) != s.end()) {\n        ++gr[i];\n      }\n      cnt[r][gr[i]] += pw[i];\n    }\n  }\n  Mint ans = 0;\n  for (int x = 0; x < MAX; x++) {\n    for (int y = 0; y < MAX; y++) {\n      ans += cnt[0][x] * cnt[1][y] * cnt[2][x ^ y];\n    }\n  }\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = 998244353;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nstruct edge { ll to; ll d; };\nvector<vector<edge>> adj[3];\nvector<ll> d[3];\nvector<bool> used[3];\n\nvoid dijkstra(int i, int n) {\n  int N = adj[i].size();\n  auto c = [](const p_ll &x, const p_ll &y){return x.second>y.second;};\n  priority_queue<p_ll, vector<p_ll>, decltype(c)> q(c);\n  q.push(make_pair(n,0));\n  while(q.size()) {\n    p_ll now = q.top(); q.pop();\n    ll np = now.first, nd = now.second;\n    if (nd>d[i][np]) continue;\n    for (auto x: adj[i][np]) {\n      if (d[i][x.to]<=d[i][np]+x.d||used[i][x.to]) continue;\n      q.push(make_pair(x.to, d[i][np]+x.d));\n      d[i][x.to] = d[i][np]+x.d;\n    }\n  }\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nint main() {\n  int N; cin >> N;\n  ll p1 = 716070898;\n  // ll p1 = 10;\n  ll p18[N*3+1] = {}; rep(i,N*3+1) p18[i] = i==0 ? 1 : (p18[i-1]*p1)%MOD;\n  ll r[3][2] = {};\n\n  vector<ll> u1[3], u2[3];\n  rep(i,3) {\n    adj[i].resize(N); \n    int M; cin >> M;\n    rep(j,M) {\n      int a, b; cin >> a >> b; a--; b--;\n      adj[i][a].push_back({b,1});\n      adj[i][b].push_back({a,1});\n    }\n\n    d[i].resize(N,LLINF);\n    used[i].resize(N,false);\n    per(j,N) {\n      if (d[i][j]!=LLINF) continue;\n      d[i][j] = 0;\n      dijkstra(i,j);\n    }\n    rep(j,N) {\n      if (d[i][j]%2==0) {\n        u1[i].push_back(j);\n        used[i][j] = true;\n      }\n    }\n\n    rep(j,N) d[i][j] = LLINF;\n    per(j,N) {\n      if (d[i][j]!=LLINF||used[i][j]) continue;\n      d[i][j] = 0;\n      dijkstra(i,j);\n    }\n    rep(j,N) {\n      if (!used[i][j]&&d[i][j]%2==0) {\n        u2[i].push_back(j);\n        used[i][j] = true;\n      }\n    }\n\n    for (auto x: u1[i]) r[i][0] = (r[i][0]+p18[x+1])%MOD;\n    for (auto x: u2[i]) r[i][1] = (r[i][1]+p18[x+1])%MOD;\n\n  }\n  // rep(i,3) { debug(all(u1[i])); debug(all(u2[i])); cout << endl; }\n\n  ll result = 0;\n  result = (result+(r[0][0]*r[1][0])%MOD*r[2][0])%MOD;\n  result = (result+(r[0][1]*r[1][1])%MOD*r[2][0])%MOD;\n  result = (result+(r[0][1]*r[1][0])%MOD*r[2][1])%MOD;\n  result = (result+(r[0][0]*r[1][1])%MOD*r[2][1])%MOD;\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 998244353;\nconst int N = 1e6+7;\nconst long long B = 1000000000000000000;\ntypedef long long LL;\n\nLL pb[N];\nvoid pre() {\n    pb[0] = 1;\n    LL b = B%M;\n    for (int i=1; i<N; i++)\n        pb[i] = (pb[i-1]*b)%M;\n}\n\nvector<int> bfs(vector<vector<int>>adj) {\n    int n = adj.size()-1;\n    vector<int> col(n+1, N), in(n+1, 0);\n\n    for (int i=n; i>0; i--) {\n        bool odd = false, even = false;\n        for (int v: adj[i]) {\n            if (v < i)  continue;\n            if (col[v] == 2)    continue;\n            if (col[v] == 1)    odd = true;\n            if (col[v] == 0)    even = true;\n        }\n        if (!even)      col[i] = 0;\n        else if (!odd)  col[i] = 1;\n        else            col[i] = 2;\n    }\n    return col;\n}\n\nint m[3];\nvector<vector<int>> adj[3];\nvector<int> dis[3];\nLL even[3], odd[3];\nint main() {\n    pre();\n\n    int n;\n    cin>>n;\n\n    for (int g=0; g<3; g++) {\n        cin>>m[g];\n        adj[g].resize(n+1);\n        for (int i=0; i<m[g]; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[g][u].push_back(v);\n            adj[g][v].push_back(u);\n        }\n        dis[g] = bfs(adj[g]);\n//        for (int i=1; i<=n; i++)    cout<<dis[g][i]<<\" \"; cout<<endl;\n\n        for (int i=1; i<=n; i++) {\n            if (dis[g][i] == 1)        odd[g] = (odd[g] + pb[i])%M;\n            else if (dis[g][i]==0)     even[g] = (even[g] + pb[i])%M;\n        }\n    }\n\n    LL ans = 0;\n    for (int mask = 0; mask < 8; mask ++) {\n        if (__builtin_popcount(mask)%2) continue;\n        long long cur = 1;\n        for (int g=0; g<3; g++)\n            if (mask & (1<<g))      cur = (cur * odd[g])%M;\n            else                    cur = (cur * even[g])%M;\n        ans = (ans + cur)%M;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = 998244353;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nstruct edge { ll to; ll d; };\nvector<vector<edge>> adj[3];\nvector<ll> d[3];\nvector<bool> used[3];\n\nvoid dijkstra(int i, int n) {\n  int N = adj[i].size();\n  auto c = [](const p_ll &x, const p_ll &y){return x.second>y.second;};\n  priority_queue<p_ll, vector<p_ll>, decltype(c)> q(c);\n  q.push(make_pair(n,0));\n  while(q.size()) {\n    p_ll now = q.top(); q.pop();\n    ll np = now.first, nd = now.second;\n    if (nd>d[i][np]) continue;\n    for (auto x: adj[i][np]) {\n      if (d[i][x.to]<=d[i][np]+x.d||used[i][x.to]) continue;\n      q.push(make_pair(x.to, d[i][np]+x.d));\n      d[i][x.to] = d[i][np]+x.d;\n    }\n  }\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\nint main() {\n  int N; cin >> N;\n  ll p1 = 716070898;\n  // ll p1 = 10;\n  ll p18[N*3+1] = {}; rep(i,N*3+1) p18[i] = i==0 ? 1 : (p18[i-1]*p1)%MOD;\n  ll r[3][3] = {};\n\n  vector<ll> u1[3], u2[3], u3[3];\n  rep(i,3) {\n    adj[i].resize(N); \n    int M; cin >> M;\n    rep(j,M) {\n      int a, b; cin >> a >> b; a--; b--;\n      adj[i][a].push_back({b,1});\n      adj[i][b].push_back({a,1});\n    }\n\n    d[i].resize(N,LLINF);\n    used[i].resize(N,false);\n    per(j,N) {\n      if (d[i][j]!=LLINF) continue;\n      d[i][j] = 0;\n      dijkstra(i,j);\n    }\n    rep(j,N) {\n      if (d[i][j]%2==0) {\n        u1[i].push_back(j);\n        used[i][j] = true;\n      }\n    }\n\n    rep(j,N) d[i][j] = LLINF;\n    per(j,N) {\n      if (d[i][j]!=LLINF||used[i][j]) continue;\n      d[i][j] = 0;\n      dijkstra(i,j);\n    }\n    rep(j,N) {\n      if (!used[i][j]&&d[i][j]%2==0) {\n        u2[i].push_back(j);\n        used[i][j] = true;\n      }\n    }\n\n    rep(j,N) d[i][j] = LLINF;\n    per(j,N) {\n      if (d[i][j]!=LLINF||used[i][j]) continue;\n      d[i][j] = 0;\n      dijkstra(i,j);\n    }\n    rep(j,N) {\n      if (!used[i][j]&&d[i][j]%2==0) {\n        u23i].push_back(j);\n        used[i][j] = true;\n      }\n    }\n\n    for (auto x: u1[i]) r[i][0] = (r[i][0]+p18[x+1])%MOD;\n    for (auto x: u2[i]) r[i][1] = (r[i][1]+p18[x+1])%MOD;\n    for (auto x: u3[i]) r[i][2] = (r[i][2]+p18[x+1])%MOD;\n\n  }\n  // rep(i,3) { debug(all(u1[i])); debug(all(u2[i])); cout << endl; }\n\n  ll result = 0;\n  result = (result+(r[0][0]*r[1][0])%MOD*r[2][0])%MOD;\n  result = (result+(r[0][1]*r[1][1])%MOD*r[2][0])%MOD;\n  result = (result+(r[0][1]*r[1][0])%MOD*r[2][1])%MOD;\n  result = (result+(r[0][0]*r[1][1])%MOD*r[2][1])%MOD;\n  result = (result+(r[0][2]*r[1][2])%MOD*r[2][0])%MOD;\n  result = (result+(r[0][2]*r[1][0])%MOD*r[2][2])%MOD;\n  result = (result+(r[0][0]*r[1][2])%MOD*r[2][2])%MOD;\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\n \n\n\nll N,M[5];\nvector<ll> vv[5][101010];\nll mk[111][111][111];\nll pans[505050];\nll i, j, k;\nll ans;\n\nll powl(ll a,ll b){\n    if(b==0)\n        return 1;\n    ll c = powl(a * a % MOD, b / 2);\n    if(b&1){\n        return c * a % MOD;\n    }\n    return c;\n}\n\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,0,3){\n        scanf(\"%lld\", &M[i]);\n        fornum(j,0,M[i]){\n            ll a, b;\n            scanf(\"%lld%lld\", &a, &b);\n            vv[i][a].push_back(b);\n            vv[i][b].push_back(a);\n        }\n    }\n    pans[0] = 1;\n    pans[1] = 1e18;\n    pans[1] %= MOD;\n    fornum(i,1,N*3){\n        pans[i + 1] = pans[i] * pans[1] % MOD;\n    }\n    for (i = N * 3; i >= 3;--i){\n        fornum(j,1,i){\n            if(j>N)\n                break;\n            fornum(k,max(1ll,i-j-N),i){\n                if(k>N)\n                    break;\n                ll l = i - j - k;\n                if(l<=0)\n                    break;\n                if(mk[j][k][l])\n                    continue;\n                ans += pans[i];\n                ans %= MOD;\n                ll m;\n                fornum(m,0,vv[0][j].size()){\n                    mk[vv[0][j][m]][k][l] = true;\n                }\n                fornum(m,0,vv[1][k].size()){\n                    mk[j][vv[1][k][m]][l] = true;\n                }\n                fornum(m,0,vv[2][l].size()){\n                    mk[j][k][vv[2][l][m]] = true;\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ri register int\nusing namespace std;\n#define fi first\n#define se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef vector<int> poly;\n#define pb push_back\nconst int rlen=1<<18|1,inf=0x3f3f3f3f;\nconst ll Inf=1e18;\nchar buf[rlen],*ib=buf,*ob=buf;\n#define gc() (((ib==ob)&&(ob=(ib=buf)+fread(buf,1,rlen,stdin)),ib==ob)?-1:*ib++)\ninline int read() {\n  int ans=0;\n  bool f=1;\n  char ch=gc();\n  while(!isdigit(ch)) f^=ch=='-',ch=gc();\n  while(isdigit(ch)) ans=((ans<<2)+ans<<1)+(ch^48),ch=gc();\n  return f?ans:-ans;\n}\ninline ll readl() {\n  ll ans=0;\n  bool f=1;\n  char ch=gc();\n  while(!isdigit(ch)) f^=ch=='-',ch=gc();\n  while(isdigit(ch)) ans=((ans<<2)+ans<<1)+(ch^48),ch=gc();\n  return f?ans:-ans;\n}\ninline int Read(char*s) {\n  int tp=0;\n  char ch=gc();\n  while(!isdigit(ch)&&!isalpha(ch)) ch=gc();\n  while(isdigit(ch)||isalpha(ch)) s[++tp]=ch,ch=gc();\n  return tp;\n}\nnamespace modular {\n  const int mod=998244353;\n  inline int add(int a,int b) { return a+b<mod?a+b:a+b-mod; }\n  inline int dec(int a,int b) { return a<b?a-b+mod:a-b; }\n  inline int mul(int a,int b) { return (ll)a*b%mod; }\n  inline void Add(int&a,int b) { a=a+b<mod?a+b:a+b-mod; }\n  inline void Dec(int&a,int b) { a=a<b?a-b+mod:a-b; }\n  inline void Mul(int&a,int b) { a=(ll)a*b%mod; }\n  inline int ksm(int a,int p) { int ret=1;for(;p;p>>=1,Mul(a,a)) (p&1)&&(Mul(ret,a),1);return ret; }\n  inline int Inv(int a) { return ksm(a,mod-2); }\n  inline int sqr(int a) { return mul(a,a); }\n  inline int cub(int a) { return (ll)a*a%mod*a%mod; }\n}\nusing namespace modular;\ntemplate<typename T> inline void ckmax(T&a,T b) { a<b?a=b:0; }\ntemplate<typename T> inline void ckmin(T&a,T b) { a>b?a=b:0; }\ntemplate<typename T> inline T gcd(T a,T b) { T t;while(b)t=a,a=b,b=t-t/a*a;return a; }\ntemplate<typename T> inline T Abs(T x) { return x<0?-x:x; }\nconst int N=3e5+5;\nint lim,tim,n,m,du[N],dis[N];\npoly f[2];\nvector<int>e[N];\nvector<int>rev[23],w[23];\ninline void init_ntt() {\n  int up=1<<20;\n  w[20].resize(up),w[20][0]=1,w[20][1]=ksm(3,(mod-1)>>21);\n  for(ri i=2;i<up;++i) w[20][i]=mul(w[20][i-1],w[20][1]);\n  for(ri i=19;~i;--i) {\n    w[i].resize(up>>=1);\n    for(ri j=0;j<up;++j) w[i][j]=w[i+1][j<<1];\n  }\n}\ninline void init(int up) {\n  lim=1,tim=0;\n  while(lim<up) lim<<=1,++tim;\n  if(rev[tim].size()) return;\n  rev[tim].resize(lim);\n  for(ri i=1;i<lim;++i) rev[tim][i]=(rev[tim][i>>1]>>1)|((i&1)<<(tim-1));\n}\ninline void ntt(poly&a,int typ) {\n  for(ri i=1;i<lim;++i) if(i<rev[tim][i]) swap(a[i],a[rev[tim][i]]);\n  for(ri i=1,t=0,a0,a1;i<lim;i<<=1,++t) for(ri j=0;j<lim;j+=i<<1) for(ri k=0;k<i;++k) {\n    a0=a[j+k],a1=mul(a[j+k+i],w[t][k]);\n    a[j+k]=add(a0,a1),a[j+k+i]=dec(a0,a1);\n  }\n  if(~typ) return;\n  reverse(++a.begin(),a.end());\n  for(ri iv=Inv(lim),i=0;i<lim;++i) Mul(a[i],iv);\n}\ninline poly operator*(poly a,poly b) {\n  int n=a.size(),m=b.size(),t=n+m-1;\n  if(!t) return poly(0);\n  init(t);\n  a.resize(lim),ntt(a,1);\n  b.resize(lim),ntt(b,1);\n  for(ri i=0;i<lim;++i) Mul(a[i],b[i]);\n  return ntt(a,-1),a.resize(t),a;\n}\ninline poly operator+(poly a,poly b) {\n  int n=b.size();\n  if(a.size()<n) a.resize(n);\n  for(ri i=0;i<n;++i) Add(a[i],b[i]);\n  return a;\n}\nint pw[N];\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\",\"r\",stdin);\n  #endif\n  n=read();\n  pw[0]=1,pw[1]=(1000000000000000000ll)%mod;\n  poly res[2],tmp[2];\n  for(ri i=2;i<=n;++i) pw[i]=mul(pw[i-1],pw[1]);\n  init_ntt();\n  f[0].resize(n+1),f[1].resize(n+1);\n  for(ri tt=1;tt<=3;++tt) {\n    m=read();\n    for(ri i=1;i<=n;++i) e[i].clear(),du[i]=0,dis[i]=inf;\n    for(ri i=1,u,v;i<=m;++i) {\n      u=read(),v=read();\n      e[max(u,v)].pb(min(u,v));\n      ++du[min(u,v)];\n    }\n    queue<int>q;\n    for(ri i=1;i<=n;++i) if(!du[i]) q.push(i),dis[i]=0;\n    while(q.size()) {\n      int x=q.front();\n      q.pop();\n      for(ri i=0,v;i<e[x].size();++i) {\n        --du[v=e[x][i]];\n        ckmin(dis[v],dis[x]+1);\n        if(!du[v]) q.push(v);\n      }\n    }\n    for(ri i=1,t;i<=n;++i) t=dis[i]&1,f[t][i]=pw[i],f[t^1][i]=0;\n    if(tt==1) res[0]=f[0],res[1]=f[1];\n    else {\n      tmp[0]=res[0]*f[0]+res[1]*f[1];\n      tmp[1]=res[1]*f[0]+res[0]*f[1];\n      res[0]=tmp[0],res[1]=tmp[1];\n    }\n  }\n  int ans=0;\n  for(ri i=1;i<=n*3;++i) Add(ans,res[0][i]);\n  cout<<ans;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\n#ifdef LOCAL\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else \n#define dump(x) true\n#endif\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate <unsigned int MOD>\nstruct ModInt {\n\tusing uint = unsigned int;\n\tusing ull = unsigned long long;\n\tusing M = ModInt;\n\n\tuint v;\n\n\tModInt(ll _v = 0) { set_norm(_v % MOD + MOD); }\n\tM& set_norm(uint _v) { //[0, MOD * 2)->[0, MOD)\n\t\tv = (_v < MOD) ? _v : _v - MOD;\n\t\treturn *this;\n\t}\n\n\texplicit operator bool() const { return v != 0; }\n\tM operator+(const M& a) const { return M().set_norm(v + a.v); }\n\tM operator-(const M& a) const { return M().set_norm(v + MOD - a.v); }\n\tM operator*(const M& a) const { return M().set_norm(ull(v) * a.v % MOD); }\n\tM operator/(const M& a) const { return *this * a.inv(); }\n\tM& operator+=(const M& a) { return *this = *this + a; }\n\tM& operator-=(const M& a) { return *this = *this - a; }\n\tM& operator*=(const M& a) { return *this = *this * a; }\n\tM& operator/=(const M& a) { return *this = *this / a; }\n\tM operator-() const { return M() - *this; }\n\tM& operator++(int) { return *this = *this + 1; }\n\tM& operator--(int) { return *this = *this - 1; }\n\n\tM pow(ll n) const {\n\t\tif (n < 0) return inv().pow(-n);\n\t\tM x = *this, res = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) res *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tM inv() const {\n\t\tll a = v, b = MOD, p = 1, q = 0, t;\n\t\twhile (b != 0) {\n\t\t\tt = a / b;\n\t\t\tswap(a -= t * b, b);\n\t\t\tswap(p -= t * q, q);\n\t\t}\n\t\treturn M(p);\n\t}\n\n\tbool operator==(const M& a) const { return v == a.v; }\n\tbool operator!=(const M& a) const { return v != a.v; }\n\tfriend ostream& operator<<(ostream& os, const M& a) { return os << a.v; }\n};\n\nusing Mint = ModInt<998244353>;\n\nconst int maxn = 100010;\nconst Mint W(TEN(18));\n\nV<int> g[3][maxn];\nint M[3];\nbool use[510][510][510];\nbool can[3][8][maxn];\n\nint main() {\n\tint N; cin >> N;\n\trep(i, 3) {\n\t\tcin >> M[i];\n\t\trep(j, M[i]) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\t--x; --y;\n\t\t\tg[i][x].pb(y);\n\t\t\tg[i][y].pb(x);\n\t\t}\n\t}\n\n\tif (N>500) return 0;\n\n\tMint ans;\n\tfor (int s = N*3; s >= 0; --s) {\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tfor (int j = N-1; j >= 0; --j) {\n\t\t\t\tint k = s - i - j;\n\t\t\t\tif (!(k >= 0 && k < N)) { continue; }\n\t\t\t\tif (use[i][j][k]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans += W.pow(i+j+k+3);\n\t\t\t\tfor (int to : g[0][i]) {\n\t\t\t\t\tuse[to][j][k] = 1;\n\t\t\t\t}\n\t\t\t\tfor (int to : g[1][j]) {\n\t\t\t\t\tuse[i][to][k] = 1;\n\t\t\t\t}\n\t\t\t\tfor (int to : g[2][k]) {\n\t\t\t\t\tuse[i][j][to] = 1;\n\t\t\t\t}\t\t\t\t\n\t\t\t\t//cerr << i << \" \" << j << \" \" << k << endl;\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD 998244353\n \n\n\nll N,M[5];\nvector<ll> vv[5][101010];\nll gr[5][101010];\nvector<ll> grmk[5][101010];\nll mk[101010], mk2[101010],mk3[101010];\nll pans[505050];\nll i, j, k;\nll ans;\n\n\nint main(){\n    scanf(\"%lld\", &N);\n    fornum(i,0,3){\n        scanf(\"%lld\", &M[i]);\n        fornum(j,0,M[i]){\n            ll a, b;\n            scanf(\"%lld%lld\", &a, &b);\n            vv[i][a].push_back(b);\n            vv[i][b].push_back(a);\n        }\n    }\n    pans[0] = 1;\n    pans[1] = (ll)1e18 % MOD;\n    fornum(i,0,3*N){\n        pans[i + 1] = pans[i] * pans[1] % MOD;\n    }\n\n    fornum(i,0,3){\n        for (j = N; j >= 1;--j){\n            ll a = 0;\n            sort(grmk[i][j].begin(), grmk[i][j].end());\n            fornum(k,0,grmk[i][j].size()){\n                if(a<grmk[i][j][k]){\n                    break;\n                }\n                a = grmk[i][j][k] + 1;\n            }\n            gr[i][j] = a;\n            fornum(k,0,vv[i][j].size()){\n                ll b = vv[i][j][k];\n                grmk[i][b].push_back(gr[i][j]);\n            }\n        }\n    }\n    mk[0] = 1;\n    fornum(i,0,3){\n        fornum(j,0,1010){\n            mk2[j] = mk[j];\n            mk3[j] = mk[j] = 0;\n        }\n        fornum(j,0,N){\n            mk3[gr[i][j + 1]] += pans[j + 1];\n            mk3[gr[i][j + 1]] %= MOD;\n        }\n        fornum(j,0,1010){\n            fornum(k,0,1010){\n                mk[j ^ k] += mk2[j] * mk3[k] % MOD;\n                mk[j ^ k] %= MOD;\n            }\n        }\n        \n    }\n    printf(\"%lld\\n\", mk[0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <limits.h>\n#include <fstream>\n\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define pll pair <ll, ll>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n#define uint unsigned int\n\nconst int maxn = (int)1e6 + 10, mod = 998244353;\nchar s[maxn];\n\nint mul(int x, int y) {\n\treturn (ll)x * y % mod;\n}\n\nint add(int x, int y) {\n\tx += y;\n\tif (x >= mod) {\n\t\tx -= mod;\n\t}\n\treturn x;\n}\n\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) {\n\t\tx += mod;\n\t}\n\treturn x;\n}\n\nint my_pow(int x, int y) {\n\tint ans = 1;\n\n\twhile (y) {\n\t\tif (y & 1) {\n\t\t\tans = mul(ans, x);\n\t\t}\n\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int maxlog = 23;\nint g[maxlog + 1];\n\nint rev(int x, int st) {\n\tint y = 0;\n\n\tfor (int i = 0; i < st; i++) {\n\t\ty <<= 1;\n\t\ty += x & 1;\n\t\tx >>= 1;\n\t}\n\treturn y;\n}\n\nvoid fft(vector <int> &v, int st, bool fl) {\n\tint n = (1 << st);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = rev(i, st);\n\t\tif (x < i) {\n\t\t\tswap(v[i], v[x]);\n\t\t}\n\t}\n\n\tint pos = 0;\n\n\tfor (int len = 2; len <= n; len <<= 1) {\n\t\tpos++;\n\t\tint wlen = g[pos];\n\n\t\tfor (int i = 0; i < n; i += len) {\n\t\t\tint w = 1;\n\n\t\t\tfor (int j = i; j < i + len / 2; j++) {\n\t\t\t\tint a = v[j];\n\t\t\t\tint b = mul(v[j + len / 2], w);\n\t\t\t\tv[j] = add(a, b);\n\t\t\t\tv[j + len / 2] = sub(a, b);\n\n\t\t\t\tw = mul(w, wlen);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fl) {\n\t\treverse(1 + all(v));\n\t\tint rn = my_pow(n, mod - 2);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = mul(v[i], rn);\n\t\t}\n\t}\n}\n\nint n;\n\nvector <int> red[maxn];\n\nconst int mag = 19;\n\npair <vector <int>, vector <int> > get() {\n\tint m;\n\tcin >> m;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tred[i].clear();\n\t}\n\n\twhile (m--) {\n\t\tint x, y;\n\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tred[y].push_back(x);\n\t\tred[x].push_back(y);\n\t}\n\n\tvector <int> ans(1 << mag, 0);\n\tvector <int> tot(1 << mag, 0);\n\n\tfor (int i = n; i > 0; i--) {\n\t\tbool ok = true;\n\n\t\tfor (int u : red[i]) {\n\t\t\tif (ans[u]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tans[i] = 1;\n\t\t}\n\t\telse {\n\t\t\tok = true;\n\n\t\t\tfor (int u : red[i]) {\n\t\t\t\tif (tot[u]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ok) {\n\t\t\t\ttot[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mp(ans, tot);\n}\n\nint main() {\n\tg[maxlog] = my_pow(3, (mod - 1) / (1 << maxlog));\n\tfor (int i = maxlog - 1; i >= 0; i--) {\n\t\tg[i] = mul(g[i + 1], g[i + 1]);\n\t}\n\n\tcin >> n;\n\tauto a = get();\n\tauto b = get();\n\tauto c = get();\n\n\tfft(a.first, mag, false);\n\tfft(b.first, mag, false);\n\tfft(c.first, mag, false);\n\tfft(a.second, mag, false);\n\tfft(b.second, mag, false);\n\tfft(c.second, mag, false);\n\n\tvector <int> x(1 << mag);\n\n\tfor (int i = 0; i < (int)a.first.size(); i++) {\n\t\tx[i] = mul(a.first[i], mul(b.first[i], c.first[i]));\n\t\tx[i] = add(x[i], mul(a.first[i], mul(b.second[i], c.second[i])));\n\t\tx[i] = add(x[i], mul(a.second[i], mul(b.first[i], c.second[i])));\n\t\tx[i] = add(x[i], mul(a.second[i], mul(b.second[i], c.first[i])));\n\t}\n\n\tfft(x, mag, true);\n\n\tint f = my_pow(10, 18);\n\tint xx = 1;\n\n\tint ans = 0;\n\n\tfor (int i = 0; i < (1 << mag); i++) {\n\t\tans = add(ans, mul(x[i], xx));\n\t\txx = mul(xx, f);\n\t}\n\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint s=0;char ch=getchar();\n\twhile(!isdigit(ch)) ch=getchar();\n\twhile(isdigit(ch)) s=s*10+ch-'0',ch=getchar();\n\treturn s;\n} \nconst int N=1e5+5;\ntypedef long long ll;\nll base=1e18,mod=998244353;\nint n;\nll pw[N*3];\nvector<int> G[N];\nint sg[4][N],mx[4];\nint f[4][N];\ninline void add(int &x,int y){\n\tx+=y;if(x>=mod) x-=mod; \n}\nint main(){\n\tn=read();\n\tpw[0]=1;base%=mod;\n\tfor(int i=1;i<=3*n;i++)  pw[i]=pw[i-1]*base%mod;\n\tfor(int T=1;T<=3;T++){\n\t\tint m=read();\n\t\tfor(int i=1;i<=n;i++) G[i].clear();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint u=read(),v=read();\n\t\t\tif(u>v) swap(u,v);\n\t\t\tG[u].push_back(v);\n\t\t}\n\t\tset<int> s;\n\t\tfor(int i=n;i>=1;i--){\n\t\t\ts.clear();\n\t\t\tfor(int j:G[i]) s.insert(sg[T][j]);\n\t\t\twhile(s.find(sg[T][i])!=s.end()) sg[T][i]++;\n\t\t\tmx[T]=max(mx[T],sg[T][i]);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) add(f[T][sg[T][i]],pw[i]);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<=mx[1];i++)\n\t\tfor(int j=0;j<=mx[2];j++)\n\t\t\tadd(ans,1ll*f[1][i]*f[2][j]%mod*f[3][i^j]%mod);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M = 998244353;\nconst ll X = 1000000000000000000 % M;\nll n;\nll m;\nll a[3][100005];\nll ans[3][100005];\nvector<ll> ve[100005];\nll s[3];\n\nll f(ll p, ll q)\n{\n    if(q == 0) return 1;\n    ll t = f(p, q / 2);\n    if(q % 2 == 1) return t * t % M * p % M;\n    else return t * t % M;\n}\n\nint main()\n{\n    cin>>n;\n    for(ll i = 0; i < 3; i++)\n    {\n        scanf(\"%lld\", &m);\n        for(ll j = 1; j <= n; j++) ve[j].clear();\n        for(ll j = 0; j < m; j++)\n        {\n            ll t1, t2;\n            scanf(\"%lld%lld\", &t1, &t2);\n            if(t1 > t2) swap(t1, t2);\n            ve[t2].push_back(t1);\n        }\n        for(ll j = n; j >= 1; j--)\n        {\n            ans[i][a[i][j]] += f(X, j);\n            ans[i][a[i][j]] %= M;\n            for(ll k = 0; k < ve[j].size(); k++)\n            {\n                if(a[i][ve[j][k]] == a[i][j]) a[i][ve[j][k]]++;\n            }\n        }\n    }\n    ll ans2 = 0;\n    ans2 += ans[0][0] % M * ans[1][0] % M * ans[2][0] % M;\n    for(ll i = n; i >= 0; i--)\n    {\n        ans2 += ans[0][i] * s[0] % M;\n        ans2 %= M;\n        s[0] += ans[1][i] * ans[2][i] % M;\n        s[0] %= M;\n    }\n    for(ll i = n; i >= 0; i--)\n    {\n        ans2 += ans[1][i] * s[1] % M;\n        ans2 %= M;\n        s[1] += ans[2][i] * ans[0][i] % M;\n        s[1] %= M;\n    }\n    for(ll i = n; i >= 0; i--)\n    {\n        ans2 += ans[2][i] * s[2] % M;\n        ans2 %= M;\n        s[2] += ans[0][i] * ans[1][i] % M;\n        s[2] %= M;\n    }\n    cout<<ans2<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\nconst int N = 110000, mod = 998244353;\n\nint n, m, fa[3][N], lim[3];\nll sum[3][N], f[N], ans;\nvector<int> to[N];\nset<int> mex;\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\ninline ll quickpow(ll base, ll pw) {\n\tll ret = 1;\n\twhile (pw) {\n\t\tif (pw & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, pw >>= 1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint x, y;\n\tread(n);\n\tfor (R int i = 0; i <= 2; ++i) {\n\t\tread(m);\n\t\tfor (R int j = 1; j <= n; ++j) to[j].clear();\n\t\tfor (R int j = 1; j <= m; ++j)\n\t\t\tread(x), read(y), to[min(x, y)].push_back(max(x, y));\n\t\tfor (R int j = n; j; --j) {\n\t\t\tmex.clear();\n\t\t\tfor (auto &v : to[j])\n\t\t\t\tmex.insert(fa[i][v]);\n\t\t\twhile (mex.find(fa[i][j]) != mex.end())\n\t\t\t\t++fa[i][j];\n\t\t\tlim[i] = max(lim[i], fa[i][j]);\n\t\t\tsum[i][fa[i][j]] = (sum[i][fa[i][j]] + quickpow(10, 18 * j)) % mod;\n\t\t}\n\t}\n\tfor (R int i = 0; i <= lim[1]; ++i)\n\t\tfor (R int j = 0; j <= lim[2]; ++j)\n\t\t\tf[i ^ j] = (f[i ^ j] + sum[1][i] * sum[2][j]) % mod;\n\tfor (R int i = 0; i <= lim[0]; ++i)\n\t\tans = (ans + sum[0][i] * f[i]) % mod;\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n\ntemplate <int MOD>\nstruct ModInt {\n    using lint = long long;\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt inv() const { return this->pow(MOD - 2); }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt pow(lint n) const {\n        auto x = ModInt(1);\n        auto b = *this;\n        while (n > 0) {\n            if (n & 1) x *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return x;\n    }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= x.inv(); }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n\n    // I/O\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n};\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nconstexpr int MOD = 998244353;\nusing mint = ModInt<MOD>;\n\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nvoid brute() {\n    int n;\n    std::cin >> n;\n\n    std::vector<mint> tens(n + 1);\n    {\n        mint ten = 1;\n        for (int i = 0; i < 18; ++i) ten *= 10;\n\n        tens[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            tens[i] = tens[i - 1] * ten;\n        }\n    }\n\n    std::vector<Graph<>> graphs(3);\n    std::vector<mint> iss, dss;\n    for (auto& graph : graphs) {\n        graph.resize(n);\n\n        int m;\n        std::cin >> m;\n\n        while (m--) {\n            int u, v;\n            std::cin >> u >> v;\n            --u, --v;\n            graph[u].emplace_back(u, v);\n            graph[v].emplace_back(v, u);\n        }\n    }\n\n    mint ans = 0;\n    auto used = vec(n, vec(n, vec(n, false)));\n    for (int s = (n - 1) * 3; s >= 0; --s) {\n        for (int i = 0; i < n && i <= s; ++i) {\n            for (int j = 0; j < n && i + j <= s; ++j) {\n                int k = s - i - j;\n                if (k >= n || used[i][j][k]) continue;\n\n                std::cerr << i + 1 << \" \" << j + 1 << \" \" << k + 1 << std::endl;\n                ans += tens[i + 1] * tens[j + 1] * tens[k + 1];\n\n                for (auto e : graphs[0][i]) {\n                    used[e.dst][j][k] = true;\n                }\n                for (auto e : graphs[1][j]) {\n                    used[i][e.dst][k] = true;\n                }\n                for (auto e : graphs[2][k]) {\n                    used[i][j][e.dst] = true;\n                }\n            }\n        }\n    }\n    std::cout << ans << std::endl;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<mint> tens(n + 1);\n    {\n        mint ten = 1;\n        for (int i = 0; i < 18; ++i) ten *= 10;\n\n        tens[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            tens[i] = tens[i - 1] * ten;\n        }\n    }\n\n    std::vector<Graph<>> graphs(3);\n    std::vector<std::vector<mint>> iss;\n    for (auto& graph : graphs) {\n        graph.resize(n);\n\n        int m;\n        std::cin >> m;\n\n        while (m--) {\n            int u, v;\n            std::cin >> u >> v;\n            --u, --v;\n            graph[u].emplace_back(u, v);\n            graph[v].emplace_back(v, u);\n        }\n\n        std::vector<bool> used(n, false);\n        iss.push_back(std::vector<mint>());\n\n        while (std::any_of(used.begin(), used.end(), [](auto b) { return !b; })) {\n            std::vector<bool> out = used;\n            mint score = 0;\n            for (int v = n - 1; v >= 0; --v) {\n                if (out[v]) continue;\n\n                used[v] = true;\n                score += tens[v + 1];\n                for (auto e : graph[v]) {\n                    out[e.dst] = true;\n                }\n            }\n\n            iss.back().push_back(score);\n        }\n    }\n\n    auto dp = vec(iss[0].size(), vec(iss[1].size(), vec(iss[2].size(), true)));\n    mint ans = 0;\n    for (int i = 0; i < (int)iss[0].size(); ++i) {\n        for (int j = 0; j < (int)iss[1].size(); ++j) {\n            for (int k = 0; k < (int)iss[2].size(); ++k) {\n                if (!dp[i][j][k]) continue;\n                ans += iss[0][i] * iss[1][j] * iss[2][k];\n\n                for (int l = 0; l < (int)iss[0].size(); ++l) {\n                    dp[l][j][k] = false;\n                }\n                for (int l = 0; l < (int)iss[1].size(); ++l) {\n                    dp[i][l][k] = false;\n                }\n                for (int l = 0; l < (int)iss[2].size(); ++l) {\n                    dp[i][j][l] = false;\n                }\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    // brute();\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 0;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  vector<long long> ary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    set<int> usable;\n    for(int i = 1; i<N+1; ++i) {\n      usable.insert(i);\n    }\n    while(!usable.empty()) {\n      set<int> u = usable;\n      long long curr = 0;\n      while(!u.empty()) {\n        auto it = u.end();\n        it--;\n        int next = *it;\n        curr = (curr + pows[next]) % MOD;\n        for(int i = 0; i<adj[next].size(); ++i) {\n          u.erase(adj[next][i]);\n        }\n        u.erase(next);\n        usable.erase(next);\n      }\n      ary[graph].push_back(curr);\n    }\n  }\n\n  ret = ((ary[0][0] * ary[1][0]) % MOD) * ary[2][0];\n  ret = (ret % MOD);\n  for(int i = 1; i<min(ary[0].size(), ary[1].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0];\n    ret = (ret + add) % MOD;\n  }\n  for(int i = 1; i<min(ary[0].size(), ary[2].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][i] * ary[1][0])%MOD) * ary[2][i];\n    ret = (ret + add) % MOD;\n  }\n  for(int i = 1; i<min(ary[1].size(), ary[2].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n    ret = (ret + add) % MOD;\n  }\n\n  /*\n  for(int i = 0; i<min(min(ary[0].size(), ary[1].size()), ary[2].size()); ++i) {\n    long long add = 0;\n    if(i == 0) {\n      add = ((ary[0][i] * ary[1][i]) % MOD) * ary[2][i];\n    }\n    else {\n      //add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0] + ((ary[0][i] * ary[1][0])%MOD) * ary[2][i] + ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n      add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][i-1] + ((ary[0][i] * ary[1][i-1])%MOD) * ary[2][i] + ((ary[0][i-1] * ary[1][i])%MOD) * ary[2][i];\n    }\n    ret = (ret + add) % MOD;\n  }\n  */\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define re register\n#define int long long\n#define pb push_back\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\nconst int inf = 1e18 ; \nconst int P = 998244353 ; \nconst int N = 1e5 + 5 ; \nconst int M = 1e5 + 5 ;\nint n, m1, m2, m3, ans[N], h[N], f[N], g[N], f1[N], f2[N], f3[N], Ans ;\nint book[N] ; \nvector<int> G1[N], G2[N], G3[N] ; \nsigned main()\n{\n\tn = gi(), ans[1] = inf % P ; \n\trep( i, 2, n ) ans[i] = ans[i - 1] * ans[1] % P ; \n\t\n\tint x, y ; m1 = gi() ; \n\trep( i, 1, m1 ) x = gi(), y = gi(), ( x < y ) ? G1[x].pb(y) : G1[y].pb(x) ;\n\tm2 = gi() ; \n\trep( i, 1, m2 ) x = gi(), y = gi(), ( x < y ) ? G2[x].pb(y) : G2[y].pb(x) ;\n\tm3 = gi() ; \n\trep( i, 1, m3 ) x = gi(), y = gi(), ( x < y ) ? G3[x].pb(y) : G3[y].pb(x) ;\n\t\n\tfor( re int i = n, l; i >= 1; -- i ) {\n\t\tfor( int j : G1[i] ) book[f1[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f1[i] = l ;\n\t\tfor( int j : G1[i] ) book[f1[j]] = 0 ; \n\t\t\n\t\tfor( int j : G2[i] ) book[f2[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f2[i] = l ;\n\t\tfor( int j : G2[i] ) book[f2[j]] = 0 ; \n\t\t\n\t\tfor( int j : G3[i] ) book[f3[j]] = 1 ; l = 0 ;\n\t\twhile( book[l] ) ++ l ; f3[i] = l ;\n\t\tfor( int j : G3[i] ) book[f3[j]] = 0 ; \n\t\tf[f1[i]] = ( f[f1[i]] + ans[i] ) % P, \n\t\tg[f2[i]] = ( g[f2[i]] + ans[i] ) % P,\n\t\th[f3[i]] = ( h[f3[i]] + ans[i] ) % P ; \n\t}\n\trep( i, 0, 500 ) rep( j, 0, 500 ) rep( k, 0, 500 ) \n\t( ( i ^ j ^ k ) == 0 ) ? Ans = ( Ans + f[i] * g[j] % P * h[k] % P ) % P : Ans = Ans ; \n\t\n\tcout << Ans << endl ; \n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct SumNode { UL a, b, c; };\n\nstruct Problem {\n\n\tbool G[451][451][3] = {};\n\n\tvoid Solve() {\n\t\tconst ULL M = 998244353;\n\t\tconst ULL Z = 1000000000000000000 % 998244353;\n\n\t\tUL N; cin >> N;\n\t\tUL S[3];\n\t\tvector<vector<UL>> E[3];\n\t\trep(i, 3) {\n\t\t\tcin >> S[i];\n\t\t\tE[i].resize(N);\n\t\t\trep(j, S[i]) {\n\t\t\t\tUL u, v; cin >> u >> v; u--; v--;\n\t\t\t\tE[i][u].push_back(v);\n\t\t\t\tE[i][v].push_back(u);\n\t\t\t}\n\t\t}\n\t\tvector<UL> POWZ(N * 3 + 1); POWZ[0] = 1;\n\t\trep(i, N * 3) POWZ[i + 1] = POWZ[i] * Z % M;\n\t\tvector<ULL> A[3] = {};\n\t\tvector<UL> B[3] = {};\n\t\trep(t, 3) {\n\t\t\tA[t].resize(min(N, 450u));\n\t\t\tB[t].resize(min(N, 450u));\n\t\t\tvector<UL> F(N);\n\t\t\tfor (UL v = N - 1; v != -1; v--) {\n\t\t\t\tA[t][F[v]] = (A[t][F[v]] + POWZ[v + 1]) % M;\n\t\t\t\tB[t][F[v]] = max(B[t][F[v]], v + 1);\n\t\t\t\tfor (UL e : E[t][v]) {\n\t\t\t\t\tif (F[e] == F[v]) F[e] = F[v] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tvector<vector<SumNode>> QQ(N * 3 + 1);\n\t\trep(x, A[0].size()) rep(y, A[1].size()) rep(z, A[2].size()) {\n\t\t\tQQ[B[0][x] + B[1][y] + B[2][z]].push_back({ x,y,z });\n\t\t}\n\n\t\tULL ans = 0;\n\t\t{\n\t\t\tfor (UL s = N * 3; s != -1; s--) {\n\t\t\t\tfor (auto &q : QQ[s]) {\n\t\t\t\t\tif (G[q.a][q.b][0]) continue;\n\t\t\t\t\tif (G[q.a][q.c][1]) continue;\n\t\t\t\t\tif (G[q.b][q.c][2]) continue;\n\t\t\t\t\tG[q.a][q.b][0] = G[q.a][q.c][1] = G[q.b][q.c][2] = true;\n\t\t\t\t\tans += A[0][q.a] * A[1][q.b] % M * A[2][q.c] % M;\n\t\t\t\t\tans %= M;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define inv2 499122177\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n    #define N 100000\n\n    int fac[N+100],invfac[N+100];\n\n    int add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n    int dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n    int mul(int x,int y) {return 1ll*x*y%maxd;}\n    ll qpow(ll x,int y)\n    {\n        ll ans=1;\n        while (y)\n        {\n            if (y&1) ans=mul(ans,x);\n            x=mul(x,x);y>>=1;\n        }\n        return ans;\n    }\n    int getinv(int x) {return qpow(x,maxd-2);}\n\n    int C(int n,int m)\n    {\n        if ((n<m) || (n<0) || (m<0)) return 0;\n        return mul(mul(fac[n],invfac[m]),invfac[n-m]);\n    }\n\n    void math_init()\n    {\n        fac[0]=invfac[0]=1;\n        rep(i,1,N) fac[i]=mul(fac[i-1],i);\n        invfac[N]=getinv(fac[N]);\n        per(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n    }\n    #undef N\n}\nusing namespace My_Math;\n\nvoid fwt(int lim,int *a,int typ)\n{\n    for (int mid=1;mid<lim;mid<<=1)\n    {\n        int len=(mid<<1);\n        for (int sta=0;sta<lim;sta+=len)\n        {\n            rep(j,0,mid-1)\n            {\n                int x=a[sta+j],y=a[sta+j+mid];\n                a[sta+j]=add(x,y);a[sta+j+mid]=dec(x,y);\n                if (typ==-1) {a[sta+j]=mul(a[sta+j],inv2);a[sta+j+mid]=mul(a[sta+j+mid],inv2);}\n            }\n        }\n    }\n}\n\nint n,m,sg[N],a[N<<1],b[N<<1],c[N<<1],pw[N<<2],lim,f[N<<2];\nvi sq[N];\nbool vis[N];\n\nvoid calc(int *a)\n{\n    m=read();\n    rep(i,1,n) {sg[i]=0;sq[i].clear();}\n    rep(i,1,m)\n    {\n        int u=read(),v=read();\n        if (u>v) swap(u,v);\n        sq[u].pb(v);\n    }\n    per(u,n,1)\n    {\n        int len=sq[u].size();\n        rep(i,0,len-1)\n        {\n            int v=sq[u][i];\n            vis[sg[v]]=1;\n        }\n        while (vis[sg[u]]) sg[u]++;\n        a[sg[u]]=add(a[sg[u]],pw[u]);\n        rep(i,0,len-1)\n        {\n            int v=sq[u][i];\n            vis[sg[v]]=0;\n        }\n    }\n    //cout << endl;\n    //rep(i,1,n) cout << sg[i] <<\" \";cout << endl;\n    fwt(lim,a,1);\n}\n\nint main()\n{\n    n=read();\n    lim=1;ll tmp=1e18;tmp%=maxd;\n    while (lim<n) lim<<=1;\n    pw[0]=1;\n    rep(i,1,n) pw[i]=mul(pw[i-1],tmp);\n    //rep(i,0,n) cout << pw[i] << \" \";cout << endl;\n    calc(a);calc(b);calc(c);\n    rep(i,0,lim-1) f[i]=mul(mul(a[i],b[i]),c[i]);\n    fwt(lim,f,-1);\n    printf(\"%d\",f[0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst ll M=1000;\nconst ll val=(1000000000000000000)%mod;\nint n;\n\nvvi f(){\n\tvvi g(n);\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tg[u].push_back(v);\n\t}\n\treturn g;\n}\n\nvl ff(vvi g){\n\tvl a(n),b(M);\n\tfor(int i=n-1;i>=0;i--){\n\t\tset<int> st;\n\t\tfor(auto j:g[i]) st.insert(a[j]);\n\t\tfor(int j=0;;j++) if(st.find(j)==st.end()){\n\t\t\ta[i]=j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tll t=1;\n\tfor(int i=0;i<n;i++){\n\t\t(t*=val)%=mod;\n\t\t(b[a[i]]+=t)%=mod;\n\t}\n\treturn b;\n}\n\nint main(){\n\tcin>>n;\n\tvvi g1=f(),g2=f(),g3=f();\n\tvi used(n);\n\tvl a=ff(g2),b=ff(g3),c;\n\twhile(used!=vi(n,1)){\n\t\tvi b(n);\n\t\tfor(int i=n-1;i>=0;i--) if(!used[i]){\n\t\t\tbool flag=1;\n\t\t\tfor(auto j:g1[i]) if(b[j]) flag=0;\n\t\t\tif(flag){\n\t\t\t\tb[i]++;\n\t\t\t\tused[i]++;\n\t\t\t}\n\t\t}\n\t\tll t=1,s=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t(t*=val)%=mod;\n\t\t\t(s+=t*b[i])%=mod;\n\t\t}\n\t\tc.push_back(s);\n\t}\n\tll res=0;\n\tfor(int i=0;i<M;i++) for(int j=0;j<M;j++){\n\t\tint id=(i^j);\n\t\tif(id<c.size()) (res+=c[id]*a[i]%mod*b[j])%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lld long long int\n#define ld long double\n#define mod 1000000007\n#define modd 998244353\n#define all(v) v.begin(),v.end()\n#define rep(i,a,b)\tfor(lld i=a;i<=b;i++)\n#define repr(i,a,b) for(lld i=a;i>=b;i--)\n#define ar array\n#define pb push_back\n#define mp make_pair\n#define ios ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\nusing namespace std;\nlld n,m;\nlld arr[300000];\nvector<lld> adj[300000][3];\nar<lld,3> siz;\nlld grundy[300000][3];\nmap<lld,lld> sums[3];\nlld fastpower(lld x, unsigned lld y, lld p)\n{\n    lld res = 1;\n    x = x % p;\n    while (y > 0)\n    {\n        if (y & 1)\n            res = (res*x) % p;\n        y = y>>1;\n        x = (x*x) % p;\n    }\n    return res;\n}\nvoid dfs_grundy(lld node,lld grp){\n    if (grundy[node][grp]!=-1)return ;\n    grundy[node][grp]=0;\n    vector<lld> mex;\n    //nums[0][grp]++;\n    for (auto it:adj[node][grp]){\n        if (it<node) continue;\n        dfs_grundy(it,grp);\n        mex.pb(grundy[it][grp]);\n    }\n    if (mex.empty()) {sums[grp][0]+=fastpower(10,18*(node+1),modd);sums[grp][0]%=modd;return;}\n    sort(all(mex));\n    rep(i,0,mex.size()-1){\n        if (i!=mex[i]){\n            grundy[node][grp]=i;\n        //    nums[0][grp]--;\n      //      nums[i][grp]++;\n            sums[grp][i]+=fastpower(10,18*(node+1),modd);sums[grp][i]%=modd;\n            return ;\n        }\n    }\n    grundy[node][grp]=mex.size();\n    //nums[0][grp]--;\n    //nums[mex.size()][grp]++;\n    sums[grp][mex.size()]+=fastpower(10,18*(node+1),modd);sums[grp][mex.size()]%=modd;\n}\nint main()\n{\n     ios;\n     lld TESTS,q,a,s,b,r,k,c,p,h,w,d,x,y,z,xs,ys,t;\n     TESTS=1;\n//     ans=0;\n     //cin>>TESTS;\n     memset(grundy,-1,sizeof(grundy));\n     while(TESTS--)\n     {\n         cin>>n;\n         rep(j,0,2){\n         cin>>siz[j];\n         rep(i,0,siz[j]-1){\n            cin>>a>>b;a--;b--;\n            adj[a][j].pb(b);\n            adj[b][j].pb(a);\n         }\n         }\n         rep(j,0,2) rep(i,0,n-1) dfs_grundy(i,j);\n         lld ans=0;\n         rep(i,0,sums[0].size()-1) rep(j,0,sums[1].size()-1) {\n            lld k=i^j;\n            ans+=(((sums[0][i]*sums[1][j])%modd)*sums[2][k])%modd;\n            ans%=modd;\n         }\n         cout<<ans;\n     }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 998244353;\n\nlong long modPow(long long a, long long p){\n    if(p == 0) return 1;\n    auto res = modPow(a, p/2);\n    res = (res*res)%MOD;\n    if(p%2) res = (res*a)%MOD;\n    return res;\n}\n\nvector<int> grundy(int N){\n    int M; cin >> M;\n    vector<vector<int>> g(N);\n    for(int i=0;i<M;i++){\n        int a, b; cin >> a >> b;\n        --a; --b;\n        if(a > b) swap(a, b);\n        g[a].push_back(b);\n    }\n    vector<int> res(N);\n    vector<int> gr(N, 0);\n    for(int i=N-1;i>=0;i--){\n        for(int j=0;j<=g[i].size();j++) gr[j] = 0;\n        for(auto& t : g[i]) gr[res[t]] = 1;\n        for(int j=0;;j++){\n            if(!gr[j]){ res[i] = j; break; }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N;\n    while(cin >> N){\n        vector<long long> res(1024, 0);\n        res[0] = 1;\n        for(int i=0;i<3;i++){\n            auto gr = grundy(N);\n            vector<long long> dst(1024, 0);\n            vector<long long> next(1024, 0);\n            for(int j=0;j<N;j++){\n                dst[gr[j]] += modPow(10, 18*(j+1));\n                dst[gr[j]] %= MOD;\n            }\n            for(int j=0;j<1024;j++){\n                for(int k=0;k<1024;k++){\n                    next[k^j] += res[k] * dst[j];\n                    next[k^j] %= MOD;\n                }\n            }\n            res = next;\n        }\n        cout << res[0] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 0;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  vector<long long> ary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    set<int> usable;\n    for(int i = 1; i<N+1; ++i) {\n      usable.insert(i);\n    }\n    while(!usable.empty()) {\n      set<int> u = usable;\n      long long curr = 0;\n      while(!u.empty()) {\n        auto it = u.end();\n        it--;\n        int next = *it;\n        curr = (curr + pows[next]) % MOD;\n        for(int i = 0; i<adj[next].size(); ++i) {\n          u.erase(adj[next][i]);\n        }\n        u.erase(next);\n        usable.erase(next);\n      }\n      ary[graph].push_back(curr);\n    }\n  }\n\n  ret = ((ary[0][0] * ary[1][0]) % MOD) * ary[2][0];\n  ret = (ret % MOD);\n  for(int i = 1; i<min(ary[0].size(), ary[1].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0];\n    ret = (ret + add) % MOD;\n  }\n  for(int i = 1; i<min(ary[0].size(), ary[2].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][i] * ary[1][0])%MOD) * ary[2][i];\n    ret = (ret + add) % MOD;\n  }\n  for(int i = 1; i<min(ary[1].size(), ary[2].size()); ++i) {\n    long long add = 0;\n    add = ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n    ret = (ret + add) % MOD;\n  }\n\n  for(int i = 1; i<ary[0].size(); ++i) {\n    for(int j = 1; j<ary[1].size(); ++j) {\n      for(int k = 1; k<ary[2].size(); ++k) {\n        if(i == j || j == k || i ==k) continue;\n        long long add = ((ary[0][i] * ary[1][j]) % MOD) * ary[2][k];\n        ret = (ret + add) % MOD;\n        break;\n      }\n    }\n  }\n\n  /*\n  for(int i = 0; i<min(min(ary[0].size(), ary[1].size()), ary[2].size()); ++i) {\n    long long add = 0;\n    if(i == 0) {\n      add = ((ary[0][i] * ary[1][i]) % MOD) * ary[2][i];\n    }\n    else {\n      //add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0] + ((ary[0][i] * ary[1][0])%MOD) * ary[2][i] + ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n      add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][i-1] + ((ary[0][i] * ary[1][i-1])%MOD) * ary[2][i] + ((ary[0][i-1] * ary[1][i])%MOD) * ary[2][i];\n    }\n    ret = (ret + add) % MOD;\n  }\n  */\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100010\nconst int p=998244353;\ntemplate <typename T>inline T read()\n{\n    register T sum=0;\n    register char cc=getchar();\n    int sym=1;\n    while(cc!='-'&&(cc>'9'||cc<'0'))cc=getchar();\n    if(cc=='-')sym=-1,cc=getchar();\n    sum=sum*10+cc-'0';\n    cc=getchar();\n    while(cc>='0'&&cc<='9')sum=sum*10+cc-'0',cc=getchar();\n    return sym*sum;\n}\ntemplate <typename T>inline T read(T &a)\n{\n    a=read<T>();\n    return a;\n}\ntemplate <typename T,typename... Others> inline void read(T& a, Others&... b)\n{\n    a=read(a);\n\tread(b...);\n}\nint n,m,mx,ans,SG[3][maxn],sum[3][maxn],buck[maxn];\nvector<int>G[3][maxn];\nvoid Add(int &x,int y)\n{\n\tx+=y;\n\tif(x>=p)\n\t\tx-=p;\n}\nint mul(int x,int y)\n{\n\treturn 1ll*x*y%p;\n}\nint fpow(int x,int y)\n{\n\tint res=1;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t\tres=mul(res,x);\n\t\tx=mul(x,x);\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main()\n{\n\tread(n);\n\tfor(int k=0;k<3;k++)\n\t{\n\t\tread(m);\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tread(x,y);\n\t\t\tif(x>y)swap(x,y);\n\t\t\tG[k][x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i>=1;i--)\n\t\t{\n\t\t\tfor(auto j:G[k][i])\n\t\t\t\tbuck[SG[k][j]]=true;\n\t\t\tfor(int j=0;j<=mx+1;j++)\n\t\t\t{\n\t\t\t\tif(buck[j])\n\t\t\t\t\tcontinue;\n\t\t\t\tSG[k][i]=j;\n\t\t\t\tmx=max(mx,j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tAdd(sum[k][SG[k][i]],fpow(10,18*i));\n\t\t\tfor(auto j:G[k][i])\n\t\t\t\tbuck[SG[k][j]]=false;\n\t\t}\n\t}\n\tfor(int a=0;a<=mx;a++)\n\t\tif(sum[0][a])\n\t\t\tfor(int b=0;b<=mx;b++)\n\t\t\t\tif(sum[1][b])\n\t\t\t\t\tAdd(ans,mul(mul(sum[0][a],sum[1][b]),sum[2][a^b]));\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst int mod=998244353,N=1e5+5;\nint n,cnt[3][600],pw[N*3],ans,sg[N],v[N],tag,m,big;\nvector<int> g[N];\n\nint mex(vector<int> &a){\n\ttag++;\n\tfor(int x:a) v[x]=tag;\n\tfor(int i=0;;i++) if(v[i]^tag) return i;\n}\n\nvoid dfs(int x){\n\tvector<int> tp;\n\tfor(int y:g[x]){\n\t\tif(sg[y]==-1) dfs(y);\n\t\ttp.push_back(sg[y]);\n\t}\n\tsg[x]=mex(tp);\n}\n\nvoid init(int T){\n\tread(m);\n\tfor(int i=1;i<=n;i++) g[i].clear(),sg[i]=-1;\n\tfor(int i=1,x,y;i<=m;i++){\n\t\tread(x,y);\n\t\tif(x>y) swap(x,y);\n\t\tg[x].emplace_back(y);\n\t}\n\tfor(int i=1;i<=n;i++) if(sg[i]==-1) dfs(i);\n\tfor(int i=1;i<=n;i++) cnt[T][sg[i]]=(cnt[T][sg[i]]+pw[i])%mod;\n}\n\nsigned main(){\n\tread(n);\n\tpw[0]=big=1;\n\tfor(int i=1;i<=18;i++) big=10ll*big%mod;\n\tfor(int i=1;i<=3*n;i++) pw[i]=1ll*pw[i-1]*big%mod;\n\tfor(int i:{0,1,2}) init(i);\n\tfor(int i=0;i<512;i++) for(int j=0;j<512;j++)\n\t\tans=(ans+1ll*cnt[0][i]*cnt[1][j]%mod*cnt[2][i^j])%mod;\n\twrite(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 1e5 + 10, mod = 998244353, lim = 1 << 10;\n\nint n, m;\nint ans[maxN + 1], g[maxN + 1], pw[maxN + 1];\nint flag[maxN + 1], t[maxN + 1], s[maxN + 1];\nbool vis[maxN + 1];\n\nvector<int> nxt[maxN + 1];\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\ninline int read()\n{\n\tint num = 0, f = 1;\n\tchar ch = getchar();\n\twhile( !isdigit( ch ) ) { if(ch == '-') f = -1; ch = getchar(); }\n\twhile( isdigit( ch ) ) num = (num << 3) + (num << 1) + (ch ^ 48), ch = getchar();\n\treturn num * f;\n}\n\ninline void dfs(int u)\n{\n\tvis[u] = true;\n\tfor(int i = 0; i < nxt[u].size(); i++) dfs(nxt[u][i]);\n\tfor(int i = 0; i < nxt[u].size(); i++) flag[ g[ nxt[u][i] ] ] = u;\n\n\tg[u] = 0;\n\twhile(flag[ g[u] ] == u) g[u] ++;\n}\n\ninline void work()\n{\n\tm = read();\n\tfor(int i = 1; i <= n; i++) vis[i] = false, nxt[i].clear();\n\tfor(int i = 0; i < lim; i++) flag[i] = s[i] = 0;\n\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tint x = read(), y = read();\n\t\tif(x > y) swap(x, y);\n\t\tnxt[x].push_back(y);\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(!vis[i]) dfs(i);\n\t\n\tfor(int i = 1; i <= n; i++) s[ g[i] ] = ADD(s[ g[i] ], pw[i]);\n\n\tfor(int i = 0; i < lim; i++) t[i] = ans[i], ans[i] = 0;\n\tfor(int i = 0; i < lim; i++)\n\t\tfor(int j = 0; j < lim; j++)\n\t\t\tans[i ^ j] = ADD(ans[i ^ j], 1ll * t[i] * s[j] % mod);\n}\n\nint main()\n{\n\tint base = 1;\n\tfor(int i = 1; i <= 18; i++) base = 10ll * base % mod;\n\n\tn = read();\n\tpw[0] = 1;\n\tfor(int i = 1; i <= n; i++) pw[i] = 1ll * base * pw[i - 1] % mod;\n\t\n\tans[0] = 1;\n\tfor(int i = 1; i <= 3; i++) work();\n\n\tprintf(\"%d\", ans[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nconst int MOD = 998244353;\nconst long long w = ((long long)1e18)%MOD;\nlong long wpow[101010];\n\nvector<long long> solve(vector<pair<int, int> > V)\n{\n    vector<vector<int> > conn(N+1);\n    vector<int> sidx(N+1);\n    vector<long long> ret(N);\n    for(auto x: V)\n    {\n        int u, v; tie(u, v) = x;\n        conn[u].push_back(v);\n        conn[v].push_back(u);\n    }\n    for(int i=N; i>=1; --i)\n    {\n        set<int> S;\n        for(auto x: conn[i])\n            S.insert(sidx[x]);\n        for(int t=1; t<=N; ++t)\n            if(S.count(t) == 0)\n            {\n                sidx[i] = t;\n                ret[t-1] = ret[t-1] + wpow[i];\n                if(ret[t-1] >= MOD) ret[t-1] -= MOD;\n                break;\n            }\n    }\n    while(ret.back() == 0) ret.pop_back();\n    return ret;\n}\nint main()\n{\n    scanf(\"%d\", &N);\n    wpow[0] = 1;\n    for(int i=1; i<=N; ++i)\n        wpow[i] = wpow[i-1]*w%MOD;\n    vector<vector<long long> > Q;\n    for(int i=0; i<3; ++i)\n    {\n        vector<pair<int, int> > V;\n        int M; scanf(\"%d\", &M);\n        for(int j=0; j<M; ++j)\n        {\n            int u, v; scanf(\"%d%d\", &u, &v);\n            V.emplace_back(u, v);\n        }\n        Q.push_back(solve(V));\n    }\n    int maxi = max({Q[0].size(), Q[1].size(), Q[2].size()});\n    vector<vector<bool>> adj(maxi+1, vector<bool>(maxi+1, false));\n    long long ans = 0;\n    auto add_ans = [&](int a, int b, int c)\n    {\n        //printf(\"%d %d %d\\n\", a, b, c);\n        --a; --b; --c;\n        if(a<(int)Q[0].size() && b<(int)Q[1].size() && c<(int)Q[2].size())\n            ans += Q[0][a]*Q[1][b]%MOD*Q[2][c]%MOD;\n        if(b!=c && a<(int)Q[0].size() && c<(int)Q[1].size() && b<(int)Q[2].size())\n            ans += Q[0][a]*Q[1][c]%MOD*Q[2][b]%MOD;\n        if(a!=b && b<(int)Q[0].size() && a<(int)Q[1].size() && c<(int)Q[2].size())\n            ans += Q[0][b]*Q[1][a]%MOD*Q[2][c]%MOD;\n        if(a!=b && b<(int)Q[0].size() && c<(int)Q[1].size() && a<(int)Q[2].size())\n            ans += Q[0][b]*Q[1][c]%MOD*Q[2][a]%MOD;\n        if(b!=c && c<(int)Q[0].size() && a<(int)Q[1].size() && b<(int)Q[2].size())\n            ans += Q[0][c]*Q[1][a]%MOD*Q[2][b]%MOD;\n        if(a!=b && b!=c && c<(int)Q[0].size() && b<(int)Q[1].size() && a<(int)Q[2].size())\n            ans += Q[0][c]*Q[1][b]%MOD*Q[2][a]%MOD;\n        ans %= MOD;\n    };\n    for(int i=1; i<=maxi; ++i)\n    {\n        add_ans(1, i, i);\n        adj[i][i] = true;\n    }\n    for(int i=2; i<=maxi; ++i)\n    {\n        vector<bool> used(maxi+1, false);\n        for(int j=i+1; j<=maxi; ++j)\n        {\n            if(used[j]) continue;\n            for(int k=j+1; k<=maxi; ++k)\n            {\n                if(!adj[j][k])\n                {\n                    adj[j][k] = adj[k][j] = true;\n                    used[k] = used[j] = true;\n                    add_ans(i, j, k);\n                    break;\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\n\n\nint xy[410][410],xz[410][410],yz[410][410];\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vec d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,3100000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        D1[d1[i]] += P[i];\n        for(auto e:g1[i]){\n            if(d1[e]==d1[i])d1[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D2[d2[i]]+=P[i];\n        for(auto e:g2[i]){\n            if(d2[e]==d2[i])d2[e]++;\n        }\n    }\n    rep3(i,n,1){\n        D3[d3[i]]+=P[i];\n        for(auto e:g3[i]){\n            if(d3[e]==d3[i])d3[e]++;\n        }\n    }\n    vec a,b;\n    mint ans;\n    int k1=0,k2=0,k3=0;\n    rep(i,4){\n        rep(j,4){\n            rep(k,4){\n                if(i>=n or j>=n or k>=n)break;\n                if(xy[i][j]==0 and xz[i][k]==0 and yz[j][k]==0) {\n                    ans+=D1[i]*D2[j]*D3[k];\n                    xy[i][j]=1;\n                    xz[i][k]=1;\n                    yz[j][k]=1;\n                } \n            }\n        }\n    }\n\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long; \n\ntemplate<uint const& MOD>\nstruct Modular{\n\tstatic constexpr uint const &mod=MOD;\n\tuint v;\n\tModular(long long x=0){c(x%mod+mod);}\n\tModular& c(uint x){\n\t\tv=x<mod?x:x-mod;\n\t\treturn *this;\n\t}\n\tModular pow(int k)const{\n\t\tModular res(1),tmp(v);\n\t\twhile(k){\n\t\t\tif(k&1)res*=tmp;\n\t\t\ttmp*=tmp;\n\t\t\tk>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\n\tModular inv()const{return pow(mod-2);}\n\tModular operator-()const{return Modular(mod-v);}\n\n\tModular& operator+=(const Modular &x){return c(v+x.v);}\n\tModular& operator-=(const Modular &x){return c(v+mod-x.v);}\n\tModular& operator*=(const Modular &x){v=ull(v)*x.v%mod;return *this;}\n\tModular& operator/=(const Modular &x){return *this*=x.inv();}\n\n\tModular operator+(const Modular &x)const{return Modular(*this)+=x;}\n\tModular operator-(const Modular &x)const{return Modular(*this)-=x;}\n\tModular operator*(const Modular &x)const{return Modular(*this)*=x;}\n\tModular operator/(const Modular &x)const{return Modular(*this)/=x;}\n\n\tfriend Modular operator+(long long x,const Modular &y){return Modular(x)+y;}\n\tfriend Modular operator-(long long x,const Modular &y){return Modular(x)-y;}\n\tfriend Modular operator*(long long x,const Modular &y){return Modular(x)*y;}\n\tfriend Modular operator/(long long x,const Modular &y){return Modular(x)/y;}\n\n\tfriend ostream& operator<<(ostream&os,const Modular&x){\n\t\treturn os<<x.v;\n\t}\n\tfriend istream& operator>>(istream&is,Modular&x){\n\t\tlong long p;\n\t\tis>>p;\n\t\tx=Modular(p);\n\t\treturn is;\n\t}\n\tbool operator==(const Modular &x)const{return v==x.v;}\n\tbool operator!=(const Modular &x)const{return v!=x.v;}\n\tbool operator<(const Modular &x)const{return v<x.v;}\n\texplicit operator bool()const{return v;}\n};\n\nuint MODULAR=998244353;\n//uint MODULAR=1000000007;\nusing Mint=Modular<MODULAR>; \n\nvector<Mint>fact,finv,invs;\nvoid Initfact(int n=(1<<21)+10){\n\tfact.resize(n+1),finv.resize(n+1),invs.resize(n+1);\n\tfact[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[n]=fact[n].inv();\n\tfor(int i=n-1;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tinvs[0]=1;\n\tfor(int i=0;i<=n;i++){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\n\nMint comb(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\n\n\n\nint n,m[3],gr[3][100005];\nvi g[3][100005];\nMint sum[3][350],ans;\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\trep(i,3){\n\t\tcin>>m[i];\n\t\trep(j,m[i]){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tg[i][--a].pb(--b);\n\t\t\tg[i][b].pb(a);\n\t\t}\n\t\tvi p;\n\t\trrep(j,n){\n\t\t\tp.clear();\n\t\t\tfor(auto &k:g[i][j]){\n\t\t\t\tif(j<k){\n\t\t\t\t\tp.pb(gr[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(all(p));\n\t\t\tp.erase(unique(all(p)),p.end());\n\t\t\tgr[i][j]=-1;\n\t\t\trep(k,si(p)){\n\t\t\t\tif(k!=p[k]){\n\t\t\t\t\tgr[i][j]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(gr[i][j]==-1)gr[i][j]=si(p);\n\t\t\tcout<<gr[i][j]<<endl;\n\t\t\tsum[i][gr[i][j]]+=Mint(10).pow(18*(j+1));\n\t\t}\n\t}\n\trep(i,340){\n\t\trep(j,340){\n\t\t\trep(k,340){\n\t\t\t\tif(i^j^k==0){\n\t\t\t\t\tans+=sum[0][i]*sum[1][j]*sum[2][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tchar ch;\n\twhile (ch = getchar(), !isdigit(ch));\n\tres = ch ^ 48;\n\twhile (ch = getchar(), isdigit(ch))\n\t\tres = res * 10 + ch - 48;\n}\n\nusing std::vector;\ntypedef long long ll;\nconst int N = 1e5 + 5;\nconst int mod = 998244353;\n\nvector<int> e[N];\nint am, bm, cm, n, m, bas;\nint sg[N], vis[N], ans[N], b[N], c[N], ex[N];\n\ntemplate <class T>\ninline void CkMax(T &x, T y) {x < y ? x = y : 0;}\n\ninline void add(int &x, int y)\n{\n\tx += y;\n\tx >= mod ? x -= mod : 0;\n}\n\ninline void solve()\n{\n\tfor (int i = 1; i <= n; ++i)\n\t\te[i].clear();\n\tread(m);\n\tfor (int i = 1, u, v; i <= m; ++i)\n\t{\n\t\tread(u); read(v);\n\t\tif (u > v)\n\t\t\tstd::swap(u, v);\n\t\te[u].push_back(v);\n\t}\n\tbm = 0;\n\tfor (int i = n; i >= 1; --i)\n\t{\n\t\tsg[i] = 0;\n\t\tfor (int j = 0, jm = e[i].size(); j < jm; ++j)\n\t\t\tvis[sg[e[i][j]]] = i;\n\t\twhile (vis[sg[i]] == i)\n\t\t\t++sg[i];\n\t\tadd(b[sg[i]], ex[i]);\n\t\tCkMax(bm, sg[i]);\n\t}\n\tcm = 0;\n\tfor (int i = 0; i <= am; ++i)\n\tif (ans[i])\n\t\tfor (int j = 0; j <= bm; ++j)\n\t\tif (b[j])\n\t\t{\n\t\t\tc[i ^ j] = (1ll * ans[i] * b[j] + c[i ^ j]) % mod;\n\t\t\tCkMax(cm, i ^ j);\n\t\t}\n\tfor (int i = 0; i <= am; ++i)\n\t\tans[i] = 0;\n\tfor (int i = 0; i <= bm; ++i)\n\t\tb[i] = 0;\n\tam = cm;\n\tfor (int i = 0; i <= cm; ++i)\n\t\tans[i] = c[i], c[i] = 0;\n\tfor (int i = 0; i <= m; ++i)\n\t\tvis[i] = 0; \n}\n\nint main()\n{\n\tread(n);\n\tbas = (ll)(1e18) % mod;\n\tex[0] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tex[i] = 1ll * ex[i - 1] * bas % mod;\n\t\n\tam = 0;\n\tans[0] = 1;\n\tsolve();\n\tsolve();\n\tsolve();\n\tprintf(\"%d\\n\", ans[0]); \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\nvector<int>pat[3][101010];\nint gr[101010];\nll p10[555555];\nvector<ll>calc(int t, int n)\n{\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tvector<int>f;\n\t\tf.resize(pat[t][i].size() + 3);\n\t\tfor (int j = 0; j < pat[t][i].size(); j++)\n\t\t{\n\t\t\tint v = pat[t][i][j];\n\t\t\tif (gr[v] < f.size())f[gr[v]] = 1;\n\t\t}\n\t\tfor (int j = 0; j < f.size(); j++)\n\t\t{\n\t\t\tif (f[j] == 0)\n\t\t\t{\n\t\t\t\tgr[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvector<ll>r;\n\tr.resize(2000);\n\tfor (int i = 0; i < n; i++)r[gr[i]] = (r[gr[i]] + p10[i + 1]) % mod;\n\treturn r;\n}\nint main()\n{\n\tint num;\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tint w;\n\t\tscanf(\"%d\", &w);\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tint za, zb;\n\t\t\tscanf(\"%d%d\", &za, &zb);\n\t\t\tza--, zb--;\n\t\t\tif (za > zb)swap(za, zb);\n\t\t\tpat[i][za].push_back(zb);\n\t\t}\n\t}\n\tp10[0] = 1;\n\tfor (int i = 0; i < 505050; i++)p10[i + 1] = p10[i] * (1000000000000000000LL % mod) % mod;\n\t//for (int i = 0; i < 505050; i++)p10[i + 1] = p10[i] * (10LL % mod) % mod;\n\tvector<ll>v[3];\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tvector<ll>z = calc(i, num);\n\t\t//for (int k = 0; k < z.size(); k++)printf(\"%lld \", z[k]); printf(\"\\n\");\n\t\tv[i] = z;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < min(num, 1000); i++)\n\t{\n\t\tfor (int j = 0; j < min(num, 1000); j++)\n\t\t{\n\t\t\tif ((i^j) < num)\n\t\t\t{\n\t\t\t\t//printf(\"%d %d %d\\n\", i, j, i^j);\n\t\t\t\tans = (ans + v[0][i] * v[1][j] % mod*v[2][i^j]) % mod;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+10, P = 998244353;\nint n, m, vis[N], sg[N], h[N], f[3][N];\nvector<int> g[N];\nvoid add(int &a, ll b) {a=(a+b)%P;}\n\nint main() {\n\th[1] = 1000000000000000000ll%P;\n\tREP(i,2,N-1) h[i] = (ll)h[i-1]*h[1]%P;\n\tscanf(\"%d\", &n);\n\tREP(i,0,2) {\n\t\tscanf(\"%d\", &m);\n\t\tREP(j,1,n) g[i].clear();\n\t\tREP(j,1,m) {\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif (u>v) swap(u,v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tPER(j,1,n) {\n\t\t\tint sz = g[j].size();\n\t\t\tREP(k,0,sz) vis[k] = 0;\n\t\t\tfor (int k:g[j]) vis[sg[k]] = 1;\n\t\t\tREP(k,0,sz) if (!vis[k]) {\n\t\t\t\tsg[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(f[i][sg[j]],h[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i,0,400) REP(j,0,400) {\n\t\tadd(ans, (ll)f[0][i]*f[1][j]%P*f[2][i^j]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cctype>\n#include<cstdio>\n#include<vector>\nconst int N=100007,M=512,P=998244353,base=1000000000000000000%P;\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nvoid inc(int&a,int b){a+=b-P,a+=a>>31&P;}\nint mul(int a,int b){return 1ll*a*b%P;}\nint n;\nstruct graph\n{\n    int f[N],g[M],vis[M];std::vector<int>e[N];\n    void input()\n    {\n\tfor(int m=read(),u,v;m;--m) u=read(),v=read(),e[std::min(u,v)].push_back(std::max(u,v));\n\tfor(int u=n;u;--u)\n\t{\n\t    for(int v:e[u]) vis[f[v]]=1;\n\t    while(vis[f[u]]) ++f[u];\n\t    for(int v:e[u]) vis[f[v]]=0;\n\t}\n\tfor(int i=1,x=1;i<=n;++i) x=mul(x,base),inc(g[f[i]],x);\n    }\n}a[3];\nint main()\n{\n    n=read();int ans=0;\n    for(int i=0;i<3;++i) a[i].input();\n    for(int i=0;i<512;++i) for(int j=0;j<512;++j) inc(ans,1ll*a[0].g[i]*a[1].g[j]%P*a[2].g[i^j]%P);\n    printf(\"%d\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\n#define eb emplace_back\n\nint n, m, sg[maxn], cnt[3][maxn], mx[3], vis[maxn], pw[maxn];\nvector<int> e[maxn];\n\nvoid solve(int *cnt, int &mx)\n{\n\tm = gi();\n\tfor (int i = 1; i <= n; ++i) e[i].clear();\n\tfor (int u, v, i = 1; i <= m; ++i) {\n\t\tu = gi(); v = gi();\n\t\tif (u > v) swap(u, v);\n\t\te[u].eb(v);\n\t}\n\tfill(vis, vis + n + 1, 0);\n\tfor (int u = n; u >= 1; --u) {\n\t\tfor (int v : e[u]) vis[sg[v]] = u;\n\t\tint mex = 0;\n\t\twhile (vis[mex] == u) ++mex;\n\t\tmx = max(mx, sg[u] = mex);\n\t\tcnt[sg[u]] = (cnt[sg[u]] + pw[u]) % mod;\n\t}\n}\n\nint main()\n{\n\tn = gi();\n\tint base = ((ll)1e18) % mod;\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) pw[i] = (ll)pw[i - 1] * base % mod;\n\tfor (int i = 0; i < 3; ++i) solve(cnt[i], mx[i]);\n\n\tint ans = 0;\n\tfor (int i = 0; i <= mx[0]; ++i)\n\t\tfor (int j = 0; j <= mx[1]; ++j)\n\t\t\tans = (ans + (ll)cnt[0][i] * cnt[1][j] % mod * cnt[2][i ^ j]) % mod;\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"avx,avx2,sse,sse2,ssse3,popcnt,sse4.1,sse4.2,tune=native\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\n//using arr = array;\nusing pi = pair<int, int>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vpi = vector<pi>;\nusing ld = long double;\nconst int maxn = 1<<17, mod = 119<<23|1;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint n, m;\nconst int q = 1<<10;\nll res[3][2], p[maxn], a[3][q], b[q], c[q];\n#define mul(x, y) ((x)*1ll*(y)%mod)\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tp[0] = 1;\n\tfor(int i = 1; i < maxn; i++) p[i] = p[i-1]*716070898ll%mod;\n\tcin >> n;\n\t\n\tbitset<q> t;\n\tfor(int i = 0; i < q; i++) t.set(i);\n\t\n\tfor(int i = 0; i < 3; i++) {\n\t\tcin >> m;\n\t\tvvi g(n+1);\n\t\tfor(int f, t, j = 0; j < m; j++) {\n\t\t\tcin >> f >> t;\n\t\t\tg[f].pb(t);\n\t\t\tg[t].pb(f);\n\t\t}\n\t\tvi rem(n+1, 0);\n\t\tfor(int v = n; v; v--) {\n\t\t\tfor(auto u : g[v]) if(u>v) t.set(rem[u], 0);\n\t\t\trem[v] = t._Find_first();\n\t\t\tfor(auto u : g[v]) if(u>v) t.set(rem[u]);\n\t\t\t(a[i][rem[v]]+=p[v])%=mod;\n\t\t}\n\t}\n\tfor(int i = 0; i < q; i++) {\n\t\tfor(int j = 0; j < q; j++) {\n\t\t\t(b[i^j] += a[0][i]*a[1][j])%=mod;\n\t\t}\n\t}\n\tfor(int i = 0; i < q; i++) {\n\t\tfor(int j = 0; j < q; j++) {\n\t\t\t(c[i^j] += b[i]*a[2][j])%=mod;\n\t\t}\n\t}\n\tcout << c[0];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint N;\nlong mod=998244353;\nlong v[1<<17];\nvector<long>calc()\n{\n\tint M;cin>>M;\n\tvector<vector<int> >G(N+1);\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint u,v;cin>>u>>v;\n\t\tif(u>v)swap(u,v);\n\t\tG[u].push_back(v);\n\t}\n\tvector<long>ret(500,0L);\n\tvector<int>gru(N+1);\n\tfor(int i=N;i;i--)\n\t{\n\t\tset<int>S;\n\t\tfor(int v:G[i])S.insert(gru[v]);\n\t\tint id=0;\n\t\twhile(S.find(id)!=S.end())id++;\n\t\tgru[i]=id;\n\t\t(ret[id]+=v[i])%=mod;\n\t}\n\treturn ret;\n}\nmain()\n{\n\tcin>>N;\n\tv[0]=1;\n\tfor(int i=1;i<=N;i++)v[i]=v[i-1]*716070898%mod;\n\tvector<long>A=calc();\n\tvector<long>B=calc();\n\tvector<long>C=calc();\n\tlong ans=0;\n\tfor(int i=0;i<500;i++)for(int j=0;j<500;j++)for(int k=0;k<500;k++)\n\t{\n\t\tif((i^j^k)==0)(ans+=A[i]*B[j]%mod*C[k]%mod)%=mod;\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 555555;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nint n;\nvector<vii> G(3);\nvector<vii> num(3, vii(500));\n\nvoid solve(int idx, vii G) {\n    vi g(n);\n    rrep (u, n) {\n        set<int> st;\n        for (int v: G[u]) {\n            if (v > u) st.insert(g[v]);\n        }\n\n        rep (gl, 50000) {\n            if (not st.count(gl)) {\n                g[u] = gl;\n                num[idx][gl].push_back(u);\n                break;\n            }\n        }\n    }\n}\n\nsigned main() {\n    cin >> n;\n    rep (i, 3) {\n        G[i].resize(n);\n        int m;\n        cin >> m;\n        rep (j, m) {\n            int u, v;\n            cin >> u >> v;\n            u--; v--;\n            G[i][u].push_back(v);\n            G[i][v].push_back(u);\n        }\n    }\n\n    rep (i, 3) {\n        solve(i, G[i]);\n        // DEBUG(i);\n        // rep (j, 5) {\n        //     rep (k, num[i][j].size()) {\n        //         cout << num[i][j][k] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n    }\n\n\n    ll ans = 0;\n    ll base = mod_pow(10, 18);\n    rep (x, 500) {\n        rep (y, 500) {\n            int z = x ^ y;\n            ll mul2 = 0;\n            for (int u: num[2][z]) {\n                (mul2 += mod_pow(base, u + 1)) %= MOD;\n            }\n            ll mul1 = 0;\n            for (int u: num[1][y]) {\n                (mul1 += mod_pow(base, u + 1)) %= MOD;\n            }\n            ll mul0 = 0;\n            for (int u: num[0][x]) {\n                (mul0 += mod_pow(base, u + 1)) %= MOD;\n            }\n            (ans += mul0 * mul1 % MOD * mul2 % MOD) %= MOD;\n            // if (mul0 * mul1 % MOD * mul2 % MOD != 0) {\n            //     DEBUG_VEC(vi({z, y, x}));\n            //     DEBUG_VEC(vl({mul2, mul1, mul0}));\n            // }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//%std\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint out = 0, fh = 1;\n\tchar jp = getchar();\n\twhile ((jp > '9' || jp < '0') && jp != '-')\n\t\tjp = getchar();\n\tif (jp == '-')\n\t\tfh = -1, jp = getchar();\n\twhile (jp >= '0' && jp <= '9')\n\t\tout = out * 10 + jp - '0', jp = getchar();\n\treturn out * fh;\n}\nconst int P = 998244353;\nint add(int a, int b)\n{\n\treturn a + b >= P ? a + b - P : a + b;\n}\nvoid inc(int &a, int b)\n{\n\ta = add(a, b);\n}\nint mul(int a, int b)\n{\n\treturn 1LL * a * b % P;\n}\nint fpow(int a, int b)\n{\n\tint res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\nconst int N = 1e5 + 10;\nvector<int> G[3][N];\nint n, m[3], mx = 0, SG[3][N], sum[3][N], cnt[3][N], bucket[N]; \nint main()\n{\n\tn = read();\n\tfor (int k = 0; k < 3; ++k)\n\t{\n\t\tm[k] = read();\n\t\tfor (int i = 1; i <= m[k]; ++i)\n\t\t{\n\t\t\tint u = read(), v = read();\n\t\t\tif (u > v)\n\t\t\t\tswap(u, v);\n\t\t\tG[k][u].push_back(v);\n\t\t}\n\t\tfor (int i = n; i >= 1; --i)\n\t\t{\n\t\t\tfor (int x : G[k][i])\n\t\t\t\tbucket[SG[k][x]] = 1;\n\t\t\tfor (int val = 0; val <= mx + 1; ++val)\n\t\t\t\tif (!bucket[val])\n\t\t\t\t{\n\t\t\t\t\tSG[k][i] = val;\n\t\t\t\t\tmx = max(mx, val);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tinc(sum[k][SG[k][i]], fpow(10, 18 * i));\n\t\t\tfor (int x : G[k][i])\n\t\t\t\tbucket[SG[k][x]] = 0;\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int x = 0; x <= mx; ++x) if (sum[0][x])\n\t\tfor (int y = 0; y <= mx; ++y) if (sum[1][y])\n\t\t\tinc(ans, mul(sum[0][x], mul(sum[1][y], sum[2][x ^ y])));\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=100005;\nconst int MAXM=525;\nconst ll MOD=998244353;\nconst ll INF=1000000000000000000LL;\nint n,m[3];\nvector<int> G[MAXN];\nint sg[3][MAXN];\nint weight[3][MAXM];\nbool has[MAXM];\nint p[3*MAXN];\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nvoid dec(int &a,int b) {a-=b; if(a<MOD) a+=MOD;}\nint main()\n{\n\n    ll x=INF%MOD;\n    p[0]=1;\n    for(int i=1;i<=300000;i++) p[i]=1LL*p[i-1]*x%MOD;\n    scanf(\"%d\",&n);\n    for(int i=0;i<3;i++)\n    {\n        scanf(\"%d\",&m[i]);\n        for(int j=1;j<=n;j++) G[j].clear();\n        for(int j=0;j<m[i];j++)\n        {\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            if(x>y) swap(x,y);\n            G[x].push_back(y);\n        }\n        for(int j=n;j>=1;j--)\n        {\n            memset(has,false,sizeof(has));\n            for(auto to:G[j]) has[sg[i][to]]=true;\n            int k=0;\n            for(;has[k];k++);\n            sg[i][j]=k;\n            add(weight[i][k],p[j]);\n        }\n    }\n    int ans=0;\n    for(int i=0;i<512;i++)\n        for(int j=0;j<512;j++)\n        {\n            int k=i^j;\n            add(ans,1LL*weight[0][i]*weight[1][j]%MOD*weight[2][k]%MOD);\n        }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int Maxn = 100005;\nconst int mod = 998244353;\nconst int pw = 1000000;\nconst int Maxm = 1005;\n\nint n;\nvector <int> neigh[Maxn];\nvector <int> my[3];\nint col[3][Maxn];\nint res;\n\nint toPower(int a, int p)\n{\n    int res = 1;\n    while (p) {\n        if (p & 1) res = ll(res) * a % mod;\n        p >>= 1; a = ll(a) * a % mod;\n    }\n    return res;\n}\n\nvoid Solve(vector <int> &res, int col[])\n{\n    int m; scanf(\"%d\", &m);\n    for (int i = 1; i <= n; i++)\n        neigh[i].clear();\n    for (int i = 0; i < m; i++) {\n        int a, b; scanf(\"%d %d\", &a, &b);\n        if (a > b) swap(a, b);\n        neigh[a].push_back(b);\n    }\n    for (int i = n; i > 0; i--) {\n        vector <int> seq;\n        for (int j = 0; j < neigh[i].size(); j++)\n            seq.push_back(col[neigh[i][j]]);\n        sort(seq.begin(), seq.end());\n        col[i] = 0;\n        int my = toPower(pw, 3 * i);\n        for (int j = 0; j < seq.size(); j++)\n            if (seq[j] == col[i]) col[i]++;\n        if (col[i] == res.size()) res.push_back(my);\n        else res[col[i]] = (res[col[i]] + my) % mod;\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < 3; i++) {\n        Solve(my[i], col[i]);\n        assert(my[i].size() < Maxm);\n    }\n    if (my[0].size() > my[1].size()) swap(my[0], my[1]);\n    if (my[1].size() > my[2].size()) swap(my[1], my[2]);\n    if (my[0].size() > my[1].size()) swap(my[0], my[1]);\n    for (int i = 0; i < my[0].size(); i++)\n        for (int j = 0; j < my[1].size(); j++) {\n            int nk = (j + i) % int(my[1].size());\n            res = (res + ll(my[0][i]) * my[1][j] % mod * my[2][nk]) % mod;\n        }\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\nusing graph=vector<vector<int>>;\n\nclass mint{\n\tstatic const int MOD=998244353;\n\tint x;\npublic:\n\tmint():x(0){}\n\tmint(long long y){ x=y%MOD; if(x<0) x+=MOD; }\n\n\tmint& operator+=(const mint& m){ x+=m.x; if(x>=MOD) x-=MOD; return *this; }\n\tmint& operator-=(const mint& m){ x-=m.x; if(x<   0) x+=MOD; return *this; }\n\tmint& operator*=(const mint& m){ x=1LL*x*m.x%MOD; return *this; }\n\tmint& operator/=(const mint& m){ return *this*=inverse(m); }\n\tmint operator+(const mint& m)const{ return mint(*this)+=m; }\n\tmint operator-(const mint& m)const{ return mint(*this)-=m; }\n\tmint operator*(const mint& m)const{ return mint(*this)*=m; }\n\tmint operator/(const mint& m)const{ return mint(*this)/=m; }\n\tmint operator-()const{ return mint(-x); }\n\n\tfriend mint inverse(const mint& m){\n\t\tint a=m.x,b=MOD,u=1,v=0;\n\t\twhile(b>0){ int t=a/b; a-=t*b; swap(a,b); u-=t*v; swap(u,v); }\n\t\treturn u;\n\t}\n\n\tfriend istream& operator>>(istream& is,mint& m){ long long t; is>>t; m=mint(t); return is; }\n\tfriend ostream& operator<<(ostream& os,const mint& m){ return os<<m.x; }\n\tint to_int()const{ return x; }\n};\n\nmint operator+(long long y,const mint& m){ return m+y; }\nmint operator*(long long y,const mint& m){ return m*y; }\n\nmint pow(mint m,long long k){\n\tmint res=1;\n\tfor(;k>0;k>>=1,m*=m) if(k&1) res*=m;\n\treturn res;\n}\n\nvector<int> topological_order(const graph& D){\n\tint n=D.size();\n\tvector<int> deg(n);\n\trep(u,n) for(int v:D[u]) deg[v]++;\n\n\tvector<int> res;\n\tqueue<int> Q;\n\trep(u,n) if(deg[u]==0) Q.emplace(u);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\tres.emplace_back(u);\n\t\tfor(int v:D[u]) if(--deg[v]==0) Q.emplace(v);\n\t}\n\treturn res;\n}\n\nvector<int> Grundy(const graph& D){\n\tauto ord=topological_order(D);\n\n\tint n=D.size(),m=0;\n\trep(u,n) m=max(m,(int)D[u].size());\n\n\tvector<int> g(n),last(m+1,-1);\n\trep(i,n){\n\t\tint u=ord[n-i-1];\n\t\tfor(int v:D[u]) last[g[v]]=u;\n\t\twhile(last[g[u]]==u) g[u]++;\n\t}\n\treturn g;\n}\n\nint main(){\n\tint n; scanf(\"%d\",&n);\n\tvector<graph> G(3,graph(n));\n\trep(i,3){\n\t\tint m; scanf(\"%d\",&m);\n\t\trep(j,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tif(u>v) swap(u,v);\n\t\t\tG[i][u].emplace_back(v);\n\t\t}\n\t}\n\n\tvector<vector<int>> g(3);\n\trep(i,3) g[i]=Grundy(G[i]);\n\n\tint g_max=0;\n\trep(i,3) rep(u,n) g_max=max(g_max,g[i][u]);\n\n\tvector<vector<mint>> wt(3,vector<mint>(g_max+1));\n\trep(i,3) rep(u,n) wt[i][g[i][u]]+=pow(mint(10),18*(u+1));\n\n\tmint ans=0;\n\trep(g0,g_max+1) rep(g1,g_max+1) {\n\t\tint g2=g0^g1;\n\t\tif(g2>g_max) continue;\n\t\tans+=wt[0][g0]*wt[1][g1]*wt[2][g2];\n\t}\n\tcout<<ans<<'\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\ntypedef long long LL;\nconst int Mod = 998244353;\nconst int MN = 100005, MS = 1 << 9;\n\ninline void Add(int &x, int y) { x -= (x += y) >= Mod ? Mod : 0; }\n\nint N, f1[MN], f2[MN], f3[MN];\nstd::vector<int> G1[MN], G2[MN], G3[MN];\n\ninline void ReadGraph(std::vector<int> *G) {\n\tint M;\n\tscanf(\"%d\", &M);\n\twhile (M--) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tif (x > y) std::swap(x, y);\n\t\tG[x].push_back(y);\n\t}\n}\ninline void SolveSG(std::vector<int> *G, int *f) {\n\tstatic int buk[MN];\n\tfor (int i = N; i >= 1; --i) {\n\t\tfor (int x : G[i]) buk[f[x]] = 1;\n\t\tf[i] = 0;\n\t\twhile (buk[f[i]]) ++f[i];\n\t\tfor (int x : G[i]) buk[f[x]] = 0;\n\t}\n}\n\nint pw[MN];\nint b1[MS], b2[MS], b3[MS], Ans;\n\nint main() {\n\tscanf(\"%d\", &N);\n\tReadGraph(G1);\n\tReadGraph(G2);\n\tReadGraph(G3);\n\tSolveSG(G1, f1);\n\tSolveSG(G2, f2);\n\tSolveSG(G3, f3);\n\tpw[0] = 1;\n\tfor (int i = 1; i <= N; ++i) pw[i] = pw[i - 1] * 716070898ll % Mod;\n\tfor (int i = 1; i <= N; ++i) Add(b1[f1[i]], pw[i]);\n\tfor (int i = 1; i <= N; ++i) Add(b2[f2[i]], pw[i]);\n\tfor (int i = 1; i <= N; ++i) Add(b3[f3[i]], pw[i]);\n\tfor (int i = 0; i < MS; ++i)\n\t\tfor (int j = 0; j < MS; ++j)\n\t\t\tAns = (Ans + (LL)b1[i] * b2[j] % Mod * b3[i ^ j]) % Mod;\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nconst int MAXN = 100000;\nconst ll MOD = 998244353;\nconst ll PO = 1000000000000000000LL%MOD;\nconst int SQ = 450;\n\nint n;\nvector<int> lis[3][100100];\nll an1[100100];\nll anv[SQ+10];\nint an2[100100];\nll anv2[SQ+10];\nint an3[100100];\nint ma[SQ+10][SQ+10];\nll po[300100];\n\nint chk[100100];\nint chk2[100100][SQ+10];\nint main(){\n\tscanf(\"%d\",&n);\n\tint m;\n\tfor (int t=0;t<3;t++) {\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b); a--; b--;\n\t\t\tif (a>b) swap(a,b);\n\t\t\tlis[t][a].push_back(b);\n\t\t}\n\t}\n\tpo[0] = 1;\n\tfor (int i=1;i<=3*n;i++) po[i] = po[i-1]*PO%MOD;\n\tfor (int i=n-1;i>=0;i--) {\n\t\tfor (int &j : lis[0][i]) chk[an1[j]] = 1;\n\t\tint t;\n\t\tfor (t=0;chk[t];t++);\n\t\tan1[i] = t;\n\t\tanv[t] = (anv[t]+po[i])%MOD;\n\t\tfor (int &j : lis[0][i]) chk[an1[j]] = 0;\n\t}\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int &k : lis[1][i]) chk2[i][an2[k]]=1;\n\t\tint t;\n\t\tfor (t = 0; t<SQ&&chk2[i][t]; t++);\n\t\tan2[i] = t;\n\t\t//anv2[0] = (anv2[0] + anv[t]*po[i]) % MOD;\n\t\tfor (int &k : lis[1][i]) chk2[i][an2[k]]=0;\n\t}\n\tfor (int j=0;j<SQ;j++) {\n\t\tfor (int i=0;i<SQ;i++) {\n\t\t\tfor (int k=0;k<i;k++) chk[ma[j][k]]=1;\n\t\t\tfor (int k=0;k<j;k++) chk[ma[k][i]]=1;\n\t\t\tint t;\n\t\t\tfor (t=0;chk[t];t++);\n\t\t\tma[j][i] = t;\n\t\t\tfor (int k=0;k<i;k++) chk[ma[j][k]]=0;\n\t\t\tfor (int k=0;k<j;k++) chk[ma[k][i]]=0;\n\t\t}\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tanv2[j] = (anv2[j]+anv[ma[j][an2[i]]]*po[i])%MOD;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i=n-1;i>=0;i--) {\n\t\tfor (int &j : lis[2][i]) chk[an3[j]] = 1;\n\t\tint t;\n\t\tfor (t=0;chk[t];t++);\n\t\tan3[i] = t;\n\t\tans = (ans+anv2[t]*po[i])%MOD;\n\t\tfor (int &j : lis[2][i]) chk[an3[j]] = 0;\n\t}\n\tprintf(\"%lld\\n\",ans*po[3]%MOD);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 510200;\nconst long long MOD = 998244353;\nconst long long INF = 1e18;\n\nint n, m;\nint val[3][N];\nvector<int> g[N];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nvoid run1(int id)\n{\n    for (int i = 0; i <= n; i++) g[i].clear();\n    int m;\n    cin >> m;\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    vector<int> gr(n + 1);\n    for (int i = n; i >= 1; i--)\n    {\n        vector<int> cnt(g[i].size() + 2);\n        for (auto u : g[i])\n        {\n            if (i < u && gr[u] < g[i].size() + 2) cnt[gr[u]]++;\n        }\n        for (int j = 0; j < g[i].size() + 2; j++)\n        {\n            if (cnt[j] == 0)\n            {\n                gr[i] = j;\n                val[id][j] = (val[id][j] + inq(INF % MOD, i)) % MOD;\n                break;\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    //ios_base::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    cin >> n;\n    run1(0);\n    run1(1);\n    run1(2);\n    long long ans = 0;\n    int M = 1000;\n    for (int x = 0; x < M; x++)\n    {\n        for (int y = 0; y < M; y++)\n        {\n            int z = x ^ y;\n            ans = (ans + val[0][x] * val[1][y] % MOD * val[2][z]) % MOD;\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DBG1\n  #define LOCAL\n#endif\n\n#ifdef LOCAL\n  #define _GLIBCXX_DEBUG\n#endif\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#ifdef DBG1\n    #define dbg(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dbg(...)\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\n\nconst int MOD = 998244353;\nconst int P = ll(1e18) % MOD;\n\nint prod(int a, int b) {\n  return ll(a) * b % MOD;\n}\n\nint &add(int &a, int b) {\n  if ((a += b) >= MOD) {\n    a -= MOD;\n  }\n  return a;\n}\n\nbool solve() {\n  int n;\n  if (scanf(\"%d\", &n) != 1) { return false; }\n\n  vector<vector<int>> g(3);\n  for (int ii = 0; ii < 3; ++ii) {\n    int m;\n    scanf(\"%d\", &m);\n    vector<vector<int>> ed(n);\n    for (int j = 0; j < m; ++j) {\n      int u, v;\n      scanf(\"%d%d\", &u, &v);\n      --u, --v;\n      if (u > v) { swap(u, v); }\n      ed[u].push_back(v);\n    }\n    vector<int> gr(n);\n    gr[n - 1] = 0;\n    int maxGr = 0;\n    for (int i = n - 2; i >= 0; --i) {\n      set<int> next;\n      for (int v : ed[i]) {\n        next.insert(gr[v]);\n      }\n      int j = 0;\n      for (auto k : next) {\n        if (k != j) break;\n        j++;\n      }\n      gr[i] = j;\n      maxGr = max(maxGr, j);\n    }\n    \n    g[ii].resize(maxGr + 1);\n    int curPow = 1;\n    for (int i = 0; i < n; ++i) {\n      curPow = prod(curPow, P);\n      add(g[ii][gr[i]], curPow);\n    }\n  }\n\n  sort(g.begin(), g.end(), [](const auto &a, const auto &b) { return a.size() < b.size(); });\n  int ans = 0;\n  for (int i0 = 0; i0 < int(g[0].size()); ++i0) {\n    for (int i1 = 0; i1 < int(g[1].size()); ++i1) {\n      int i2 = i0 ^ i1;\n      if (i2 < int(g[2].size())) {\n        add(ans, prod(prod(g[0][i0], g[1][i1]), g[2][i2]));\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n\n  return true;\n}\n\nint main() {\n  int tt = -1;\n  //scanf(\"%d\", &tt);\n  while (tt-- && solve());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define LL long long\n#define ULL unsigned long long \n#define y second\n#define sqr(x) ((x)*(x))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pdd pair<double,double>\n#define MEM(x) memset(x,0,sizeof(x))\n#define pi acos(-1)\n#define MEMS(x) memset(x,-1,sizeof(x))\nusing namespace std;\nint val[3][100005];\nvector<int> v[3][100005];\nvector<int> num[3][100005];\nint number=716070898;\nint mod=998244353;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\nint test[30][30][30];\nvoid T(){\n    //queue<tuple<int,int,int> > q;\n    //q.push(mp(0,0,0));\n    int n=30;\n    while(true){\n        int Min=1e9,x,y,z;\n        for(int i = 0;i<n;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<n;k++){\n                    if(!test[i][j][k]){\n                        if(i+j+k<Min){\n                            Min=i+j+k;\n                            x=i;\n                            y=j;\n                            z=k;\n                        }\n                    }\n                }\n            }\n        }\n        if(Min==1e9)break;\n        if(x<=y&&y<=z&&x!=0&&x!=1)\n        printf(\"%d\\n\",x^y^z);\n        for(int i = 0;i<n;i++){\n            test[x][y][i]=1;\n            test[x][i][z]=1;\n            test[i][y][z]=1;\n        }\n    }\n}\nint main(){ \n   //T();\n    int n;\n    scanf(\"%d\",&n);\n    int Max[3]={0,0,0};\n    for(int i = 0;i<3;i++){\n        int m;\n        scanf(\"%d\",&m);\n        for(int j =0;j<m;j++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            if(x>y)swap(x,y);\n            v[i][x].pb(y);\n        }\n        for(int j = n;j>=1;j--){\n            vector<int> arr;\n            for(auto it:v[i][j]){\n                arr.pb(val[i][it]);\n            }\n            sort(arr.begin(),arr.end());\n            arr.resize(unique(arr.begin(),arr.end())-arr.begin());\n            val[i][j]=arr.size();\n            for(int k = 0;k<arr.size();k++){\n                if(arr[k]!=k){\n                    val[i][j]=k;\n                    break;\n                }\n            }\n           // if(val[i][j]<2){\n            num[i][val[i][j]].pb(j);\n            Max[i]=max(Max[i],val[i][j]);\n            //}\n        }\n    }\n    LL ans=0;\n    LL val[3][100005];//,b[2]={0,0},c[2]={0,0};\n    LL sum[3];\n    MEM(val);\n    MEM(sum);\n    for(int i =0;i<3;i++){\n        for(int j=0;j<100005;j++){\n            for(auto it:num[i][j]){\n                val[i][j]+=f_pow(number,it);\n                val[i][j]%=mod;\n            }\n            if(j>1)sum[i]+=val[i][j],sum[i]%=mod;\n        }\n    }\n    for(int i = 0;i<=Max[0];i++){\n        for(int j = 0;j<=Max[1];j++){\n            ans+=val[0][i]*val[1][j]%mod*val[2][i^j]%mod;\n        }\n    }\n    //ans+=val[0][0]*val[1][0]%mod*val[2][0]%mod;\n    ans=(ans%mod+mod)%mod;\n    printf(\"%lld\\n\",ans);\n    /*\n    for(int i = 0;i<num[0][0].size();i++){\n        a[0]+=f_pow(number,num[0][0][i]);\n        a[0]%=mod;\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][0][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][1][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][0][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][1][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }*/\n    //printf(\"%lld\\n\",ans);\n}\n/*\n\n5\nAACCMMAA\nA\nAA\nMM\nACA\nACMAA\n\n\n5\n0 9 7 1 100\n-1 0 -1 -1 91\n-1 5 0 -1 96\n-1 8 9 0 99\n-1 -1 -1 -1 0\n3 4\n3 5\n5 6\n5 7\n3 or 4\n3 or 5\n5 or 6\n5 or 7\n\ndp[x]=max(dp[x-w_i*j]+j*t_i-delta t_i*j*(j-1)/2)\ndp[x]=max(dp[j]+x*t_i-j*t_i-delta t_i*(x-j)*(x-j-1)/2)\ndp[x]=max(dp[j]-j*t_i-delta t_i *(j^2/2+j/2) - \n        delta t_i * xj + x*t_i + delta t_i * (x^2/2-x/2))\ndp[x]=max(dp[j] + g(j) - delta t_i *xj + w(i) )\ng(j)= dp[j]-j*t_i-delta t_i *(j^2/2+j/2)\nw(i)=  x*t_i + delta t_i * (x^2/2-x/2)\nx^2/2 -xj -x/2  +j^2/2 +j/2\n*/\n\n/*\n \n\n*/"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n/*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n//    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define iostream_untie true\n#include <bits/stdc++.h>\n#include <ext/rope>\n#define __all(v) std::begin(v), std::end(v)\n#define __rall(v) std::rbegin(v), std::rend(v)\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n#else\n    #define dump(...) ((void)0)\n#endif\n\n/* function utility start */\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n/*\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n*/\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n/* using alias end */\n\n/* library start */\n\n\n\n/* library end */\n\n/* The main code follows. */\n\nstruct solver; template <class T = solver> void _main();\nint main() { _main<>(); }\n\ntemplate <class solver>\nvoid _main()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n\n    }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\nnamespace IO{\n\tcs int Rlen=1<<22|1;\n\tinline char gc(){\n\t\tstatic char buf[Rlen],*p1,*p2;\n\t\t(p1==p2)&&(p2=(p1=buf)+fread(buf,1,Rlen,stdin));\n\t\treturn (p1==p2)?EOF:*p1++;\n\t}\n\tint read(){\n\t\tint x=0; bool f=false; char c=gc();\n\t\twhile(!isdigit(c)) f=(c=='-'), c=gc();\n\t\twhile(isdigit(c)) x=(((x<<2)+x)<<1)+(c^48), c=gc(); \n\t\treturn f?-x:x;\n\t}\n} using namespace IO;\ntypedef long long ll;\ncs int Mod = 998244353;\nint add(int a, int b){ return a + b >= Mod ? a + b - Mod : a + b; }\nint dec(int a, int b){ return a - b < 0 ? a - b + Mod : a - b; }\nint mul(int a, int b){ return 1ll * a * b % Mod; }\nvoid Add(int &a, int b){ a = add(a,b); }\nvoid Mul(int &a, int b){ a = mul(a,b); }\nvoid Dec(int &a, int b){ a = dec(a,b); }\nint ksm(int a, int b){ int as=1; for(;b;b>>=1,Mul(a,a)) if(b&1) Mul(as,a); return as; }\nint fx(ll a){ return a % Mod; }\ncs int N = 1e5 + 50;\nint n, a, b, c, up;\nvector<int> A[N], B[N], C[N];\nint af[N], bf[N], cf[N], SG[3][N];\nint clc(int t, cs vector<int> &S){\n\tvector<int> T;\n\tfor(int c : S) T.pb(SG[t][c]); \n\tsort(T.begin(),T.end()); int as=0;\n\tfor(int i=0; i<(int)T.size(); i++)\n\tif(T[i]==as) ++as; else break;\n\treturn as;\n}\nvoid FWT(int *a){\n\tfor(int i=1; i<up; i<<=1)\n\tfor(int j=0; j<up; j+=(i<<1))\n\tfor(int k=0; k<i; k++){\n\t\tint x=a[k+j], y=a[k+j+i];\n\t\ta[k+j]=add(x,y); a[k+j+i]=dec(x,y);\n\t}\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tn=read(), a=read();\n\tfor(int i=1,x,y; i<=a; i++){\n\t\tx=read(), y=read();\n\t\tif(x>y) swap(x,y); A[x].pb(y);\n\t} b=read();\n\tfor(int i=1,x,y; i<=b; i++){\n\t\tx=read(), y=read();\n\t\tif(x>y) swap(x,y); B[x].pb(y);\n\t} c=read();\n\tfor(int i=1,x,y; i<=c; i++){\n\t\tx=read(), y=read();\n\t\tif(x>y) swap(x,y); C[x].pb(y);\n\t}\n\tstatic int pw[N]; pw[0]=1; pw[1]=fx(1e18);\n\tfor(int i=2; i<=n; i++) pw[i]=mul(pw[i-1],pw[1]);\n\tint mx=0;\n\tfor(int i=n,x; i>=1; i--){\n\t\tSG[0][i]=x=clc(0,A[i]); Add(af[x],pw[i]); mx=max(mx,x);\n\t\tSG[1][i]=x=clc(1,B[i]); Add(bf[x],pw[i]); mx=max(mx,x);\n\t\tSG[2][i]=x=clc(2,C[i]); Add(cf[x],pw[i]); mx=max(mx,x);\n\t} up=1; while(up<mx+1) up<<=1;\n\tFWT(af); FWT(bf); FWT(cf);\n\tfor(int i=0; i<up; i++) Mul(af[i],mul(bf[i],cf[i]));\n\tFWT(af); cout<<mul(ksm(up,Mod-2),af[0]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), (x).end())\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr int DX[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\nint sgn(int x) { return (x > 0) - (x < 0); }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\ntemplate<int MOD = 1000000007>\nstruct mod_int {\n    int val;\n    mod_int(long long val_ = 0) : val(val_ % MOD) { if (val < 0) { val += MOD; }}\n    bool operator==(const mod_int &rhs) const { return val == rhs.val; }\n    bool operator!=(const mod_int &rhs) const { return std::rel_ops::operator!=(*this, rhs); }\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((val += rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((val += MOD - rhs.val) >= MOD) { val -= MOD; }\n        return *this;\n    }\n    mod_int &operator*=(const mod_int &rhs) {\n        val = (int) ((long long) val * rhs.val % MOD);\n        return *this;\n    }\n    mod_int &operator/=(const mod_int &rhs) { return *this *= rhs.inv(); }\n    mod_int operator+() const { return *this; }\n    mod_int operator-() const { return -val; }\n    mod_int operator++() { return *this += 1; }\n    mod_int operator--() { return *this -= 1; }\n    mod_int operator++(signed) {\n        const mod_int ret(*this);\n        ++*this;\n        return ret;\n    }\n    mod_int operator--(signed) {\n        const mod_int ret(*this);\n        --*this;\n        return ret;\n    }\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n    mod_int inv() const {\n        assert(val != 0);\n        int a = val, b = MOD, x = 1, u = 0;\n        while (b) {\n            int t = a / b;\n            std::swap(a -= t * b, b);\n            std::swap(x -= t * u, u);\n        }\n        return x;\n    }\n    mod_int pow(long long n) const {\n        if (n < 0) { return pow(-n).inv(); }\n        mod_int ret = 1, mul = *this;\n        while (n) {\n            if (n & 1) { ret *= mul; }\n            mul *= mul;\n            n >>= 1;\n        }\n        return ret;\n    }\n    friend std::istream &operator>>(std::istream &is, mod_int &rhs) {\n        long long v;\n        is >> v;\n        rhs = v;\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const mod_int &rhs) { return os << rhs.val; }\n    struct combination {\n        std::vector<mod_int> fact{1, 1}, f_inv{1, 1}, inv{0, 1};\n        void calc(int n) {\n            while (fact.size() <= n) {\n                int i = fact.size();\n                fact.push_back(fact[i - 1] * i);\n                inv.push_back(-inv[MOD % i] * (MOD / i));\n                f_inv.push_back(f_inv[i - 1] * inv[i]);\n            }\n        }\n        mod_int P(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[n - r]); }\n        mod_int C(int n, int r) { return r < 0 || n < r ? 0 : (calc(n), fact[n] * f_inv[r] * f_inv[n - r]); }\n        mod_int H(int n, int r) { return C(n + r - 1, r); }\n    };\n};\n\nint N;\nint M[3];\nint a[3][110000], b[3][110000];\nvint G[3][110000];\nint grundy[3][110000];\nusing mint = mod_int<998244353>;\nmap<int, mint> mp[3];\nint mex(vint v) {\n    sort(all(v));\n    uniq(v);\n    int cnt = 0;\n    rep(i, v.size()) {\n        if (v[i] != cnt) { return cnt; }\n        cnt++;\n    }\n    return cnt;\n}\nsigned main() {\n    cin >> N;\n    rep(i, 3) {\n        cin >> M[i];\n        rep(j, M[i]) {\n            cin >> a[i][j] >> b[i][j];\n            if (a[i][j] > b[i][j]) { swap(a[i][j], b[i][j]); }\n            G[i][a[i][j]].push_back(b[i][j]);\n        }\n        for (int j = N; j >= 1; j--) {\n            vint v;\n            rep(k, G[i][j].size()) { v.push_back(grundy[i][G[i][j][k]]); }\n            grundy[i][j] = mex(v);\n            mp[i][grundy[i][j]] += mint(10).pow(18 * j);\n        }\n    }\n    mint ans = 0;\n    for (auto p0:mp[0]) {\n        for (auto p1:mp[1]) {\n            ans += p0.second * p1.second * mp[2][p0.first ^ p1.first];\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing V = vector<int>;\nusing Vll = vector<ll>;\nusing Vld = vector<ld>;\nusing Vbo = vector<bool>;\nusing VV = vector<V>;\nusing VVll = vector<Vll>;\nusing VVld = vector<Vld>;\nusing VVbo = vector<Vbo>;\nusing VVV = vector<VV>;\nusing VVVll = vector<VVll>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing Pld = pair<ld, ld>;\n#define rep2(i, m, n) for (int i = (m); i < (n); ++i)\n#define rep(i, n) rep2(i, 0, n)\n#define drep2(i, m, n) for (int i = (m)-1; i >= (n); --i)\n#define drep(i, n) drep2(i, n, 0)\n#define all(a) (a).begin(), (a).end()\nstruct fast_ios { fast_ios(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\ntemplate<typename T> inline int sz(T &x) { return x.size(); }\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << '(' << p.first << \", \" << p.second << ')'; return os; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (auto &e : v) is >> e; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { for (auto &e : v) os << e << ' '; return os; }\ntemplate<typename T> inline int count_between(vector<T> &a, T l, T r) { return lower_bound(all(a), r) - lower_bound(all(a), l); } // [l, r)\ninline int fLog2(const int x) { assert(x > 0); return 31-__builtin_clz(x); } // floor(log2(x))\ninline int fLog2(const ll x) { assert(x > 0); return 63-__builtin_clzll(x); }\ninline int cLog2(const int x) { assert(x > 0); return (x == 1) ? 0 : 32-__builtin_clz(x-1); } // ceil(log2(x))\ninline int cLog2(const ll x) { assert(x > 0); return (x == 1) ? 0 : 64-__builtin_clzll(x-1); }\ninline int popcount(const int x) { return __builtin_popcount(x); }\ninline int popcount(const ll x) { return __builtin_popcountll(x); }\nvoid fail() { cout << -1 << '\\n'; exit(0); }\n// const int INF  = 1<<30;\n// const ll INFll = 1ll<<62;\n// const ld EPS   = 1e-10;\n// const ld PI    = acos(-1.0);\n// const int MOD  = int(1e9)+7;\nconst int MOD  = 998244353;\n\n\ntemplate<int MOD> struct ModInt {\n  int x;\n  ModInt(int _x = 0) : x( (0 <= _x && _x < MOD) ? _x : (_x%MOD+MOD)%MOD) {}\n  constexpr int &value() noexcept { return x; }\n  constexpr ModInt operator-() const noexcept { return ModInt(MOD-x); }\n  constexpr ModInt operator+(const ModInt y) const noexcept { return ModInt(*this) += y; }\n  constexpr ModInt operator-(const ModInt y) const noexcept { return ModInt(*this) -= y; }\n  constexpr ModInt operator*(const ModInt y) const noexcept { return ModInt(*this) *= y; }\n  constexpr ModInt operator/(const ModInt y) const noexcept { return ModInt(*this) /= y; }\n  constexpr ModInt &operator+=(const ModInt y) noexcept { x += y.x; if (x >= MOD) x -= MOD; return *this; }\n  constexpr ModInt &operator-=(const ModInt y) noexcept { x -= y.x; if (x < 0) x += MOD; return *this; }\n  constexpr ModInt &operator*=(const ModInt y) noexcept { x = ll(x) * y.x % MOD; return *this; }\n  constexpr ModInt &operator/=(const ModInt y) noexcept { x = ll(x) * y.inv().x % MOD; return *this; }\n  constexpr ModInt inv() const noexcept {\n    int a = x, b = MOD, u = 1, v = 0;\n    while (b) {\n      int t = a / b;\n      a -= t * b; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    return (u < 0 ? (u + MOD) : u);\n  }\n};\nusing mint = ModInt<MOD>;\nusing Vm = vector<mint>;\nusing VVm = vector<Vm>;\nusing VVVm = vector<VVm>;\n// istream &operator>>(istream &is, mint &a) { return is >> a.x; }\nostream &operator<<(ostream &os, const mint &a) { return os << a.x; }\n\nmint pow(mint a, ll n) {\n  mint x(1);\n  for (; n > 0; n /= 2, a *= a) if (n&1) x *= a;\n  return x;\n}\n\n\nint main() {\n  int n; cin >> n;\n\n  VVV Sc(3, VV(n));\n  rep(i, 3) {\n    int m; cin >> m;\n    VV G(n);\n    rep(_, m) {\n      int u, v; cin >> u >> v;\n      --u, --v;\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n  \n    V cl(n);\n    drep(u, n) {\n      int k = sz(G[u]);\n      Vbo seen(k+1);\n      for (auto v : G[u]) {\n        if (v < u) continue;\n        if (cl[v] > k) continue;\n        seen[cl[v]] = true;\n      }\n      rep(j, k+1) if (!seen[j]) {\n        cl[u] = j;\n        Sc[i][j].push_back(u);\n        break;\n      }\n    }\n  }\n  \n\n  mint ans = 0;\n  Vm s0(3);\n\n  rep(i, 3) {\n    for (auto u : Sc[i][0])  s0[i] += pow(mint(10), 18*(u+1));\n  }\n  ans += s0[0]*s0[1]*s0[2];\n  \n  rep2(i, 1, n) {\n    Vm si(3);\n    rep(j, 3) {\n      for (auto u : Sc[j][i])  si[j] += pow(mint(10), 18*(u+1));\n    }\n    ans += s0[0]*si[1]*si[2];\n    ans += si[0]*s0[1]*si[2];\n    ans += si[0]*si[1]*s0[2];\n  }\n  \n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T, class Op = multiplies<T>>\nconstexpr T power(T a, long long n, Op op = Op(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\ntemplate <unsigned M> struct modular {\n  using m = modular;\n  static constexpr unsigned mod = M;\n  unsigned v;\n  modular(long long x = 0) : v((x %= mod) < 0 ? x + mod : x) {}\n  m operator-() const { return m() -= *this; }\n  m& operator+=(m b) { if ((int)(v += b.v - mod) < 0) v += mod; return *this; }\n  m& operator-=(m b) { if ((int)(v -= b.v) < 0) v += mod; return *this; }\n  m& operator*=(m b) { v = (uint64_t)v * b.v % mod; return *this; }\n  m& operator/=(m b) { return *this *= power(b, mod - 2); }\n  friend m operator+(m a, m b) { return a += b; }\n  friend m operator-(m a, m b) { return a -= b; }\n  friend m operator*(m a, m b) { return a *= b; }\n  friend m operator/(m a, m b) { return a /= b; }\n  friend bool operator==(m a, m b) { return a.v == b.v; }\n};\n\nusing mint = modular<998244353>;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  vector a(3, vector<mint>(512));\n  for (int t = 0; t < 3; ++t) {\n    int m;\n    cin >> m;\n    vector<vector<int>> g(n);\n    while (m--) {\n      int u, v;\n      cin >> u >> v;\n      --u, --v;\n      tie(u, v) = minmax({u, v});\n      g[u].push_back(v);\n    }\n    vector<int> gr(n);\n    for (int v = n; v--; ) {\n      set<int> se;\n      for (int to : g[v]) {\n        se.insert(gr[to]);\n      }\n      for (int x = 0; ; ++x) {\n        if (not se.count(x)) {\n          gr[v] = x;\n          break;\n        }\n      }\n      a[t][gr[v]] += power<mint>(10, 18 * (v + 1));\n    }\n  }\n  mint res;\n  for (int i = 0; i < 512; ++i) {\n    for (int j = 0; j < 512; ++j) {\n      int k = i ^ j;\n      res += a[0][i] * a[1][j] * a[2][k];\n    }\n  }\n  cout << res.v << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\ntypedef Field<998244353> FF;\nclass CGiantGraph {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector2<vector<int>> E(3, N);\n        vector2<set<int>> G(3, N);\n        vector2<int> Mex(3, N, 0);\n        for (int i = 0; i < 3; ++i) {\n            int M; cin >> M;\n            for (int j = 0; j < M; ++j) {\n                int a, b; cin >> a >> b;\n                --a; --b;\n                E[i][a].push_back(b);\n                E[i][b].push_back(a);\n            }\n\n            for (int j = N-1; j >= 0; --j) {\n                while (G[i][j].count(Mex[i][j])) ++Mex[i][j];\n                for (int k : E[i][j]) if (k < j) G[i][k].insert(Mex[i][j]);\n            }\n        }\n\n        FF base = FF{10}.pow(18);\n        vector2<FF> MX(3, 1<<11, 0);\n        for (int i = 0; i < 3; ++i) {\n            for (int j = 0; j < N; ++j) {\n                MX[i][Mex[i][j]] += base.pow(j+1);\n            }\n        }\n\n\n        vector<FF> Ans = MX[0];\n        for (int i = 1; i < 3; ++i) {\n            vector<FF> E(1<<11, 0);\n            for (int j = 0; j < (1<<11); ++j) {\n                for (int k = 0; k < (1<<11); ++k) {\n                    E[j^k] += Ans[j] * MX[i][k];\n                }\n            }\n            swap(E,Ans);\n        }\n        cout << Ans[0] << '\\n';\n\n\n//        FF base = FF{10}.pow(18);\n//        FF ans = 0;\n//        vector2<FF> Q(3, 2, 0);\n//\n//\n////        cout << base.pow(9) + base.pow(7) + base.pow(5) + base.pow(8) + base.pow(6) + base.pow(4) + base.pow(7) + base.pow(5) + base.pow(3) << '\\n';\n////        cout << base.pow(9) + base.pow(8) + base.pow(7) + base.pow(7) + base.pow(6) + base.pow(5) << endl;\n//        for (int k = 0; k < 3; ++k) {\n//            for (int i = 0; i < N; ++i) {\n//                if (A[k][i] && B[k][i]) continue;\n//                Q[k][A[k][i]] += base.pow(i + 1);\n//            }\n//        }\n//\n//        for (int i = 0; i < 2; ++i) {\n//            for (int j = 0; j < 2; ++j) {\n//                for (int k = 0; k < 2; ++k) {\n//                    if (i^j^k) ans += Q[0][i] * Q[1][j] * Q[2][k];\n//                }\n//            }\n//        }\n////\n////            for (int k = 0; k < N; ++k) {\n////                if (A[2][k] && B[2][k]) continue;\n////                if (1 == A[2][k]) {\n////                    ans += (Q[0][0] * Q[1][0] + Q[0][1] * Q[1][1]) * base.pow(k+1);\n////                } else {\n////                    ans += (Q[0][1] * Q[1][0] + Q[0][0] * Q[1][1]) * base.pow(k+1);\n////                }\n////            }\n//////        }\n//        cout << ans << '\\n';\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tCGiantGraph solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nconst int MAXN = 100000;\nconst ll MOD = 998244353;\nconst ll PO = 1000000000000000000LL%MOD;\nconst int SQ = 450;\n\nint n;\nvector<int> lis[3][100100];\nll an1[100100];\nll anv[SQ+10];\nint an2[100100];\nll anv2[SQ+10];\nint an3[100100];\nint ma[SQ+10][SQ+10];\nll po[300100];\n\nint chk[100100];\nint chk2[100100][SQ+10];\nint main(){\n\tscanf(\"%d\",&n);\n\tint m;\n\tfor (int t=0;t<3;t++) {\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b); a--; b--;\n\t\t\tif (a>b) swap(a,b);\n\t\t\tlis[t][a].push_back(b);\n\t\t}\n\t}\n\tpo[0] = 1;\n\tfor (int i=1;i<=3*n;i++) po[i] = po[i-1]*PO%MOD;\n\tfor (int i=n-1;i>=0;i--) {\n\t\tfor (int &j : lis[0][i]) chk[an1[j]] = 1;\n\t\tint t;\n\t\tfor (t=0;chk[t];t++);\n\t\tan1[i] = t;\n\t\tanv[t] = (anv[t]+po[i])%MOD;\n\t\tfor (int &j : lis[0][i]) chk[an1[j]] = 0;\n\t}\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int &k : lis[1][i]) chk2[i][an2[k]]=1;\n\t\tint t;\n\t\tfor (t = 0; chk2[i][t]; t++);\n\t\tan2[i] = t;\n\t\t//anv2[0] = (anv2[0] + anv[t]*po[i]) % MOD;\n\t\tfor (int &k : lis[1][i]) chk2[i][an2[k]]=0;\n\t}\n\tfor (int j=0;j<SQ;j++) {\n\t\tfor (int i=0;i<SQ;i++) {\n\t\t\tfor (int k=0;k<i;k++) chk[ma[j][k]]=1;\n\t\t\tfor (int k=0;k<j;k++) chk[ma[k][i]]=1;\n\t\t\tint t;\n\t\t\tfor (t=0;t<SQ&&chk[t];t++);\n\t\t\tma[j][i] = t;\n\t\t\tfor (int k=0;k<i;k++) chk[ma[j][k]]=0;\n\t\t\tfor (int k=0;k<j;k++) chk[ma[k][i]]=0;\n\t\t}\n\t\tfor (int i=0;i<n;i++) {\n\t\t\tanv2[j] = (anv2[j]+anv[ma[j][an2[i]]]*po[i])%MOD;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i=n-1;i>=0;i--) {\n\t\tfor (int &j : lis[2][i]) chk[an3[j]] = 1;\n\t\tint t;\n\t\tfor (t=0;chk[t];t++);\n\t\tan3[i] = t;\n\t\tans = (ans+anv2[t]*po[i])%MOD;\n\t\tfor (int &j : lis[2][i]) chk[an3[j]] = 0;\n\t}\n\tprintf(\"%lld\\n\",ans*po[3]%MOD);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n/*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n//    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define iostream_untie true\n#include <bits/stdc++.h>\n#include <ext/rope>\n#define __all(v) std::begin(v), std::end(v)\n#define __rall(v) std::rbegin(v), std::rend(v)\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n#else\n    #define dump(...) ((void)0)\n#endif\n\n/* function utility start */\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n/*\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n*/\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n/* using alias end */\n\n/* library start */\n\n\n\n/* library end */\n\n/* The main code follows. */\n\nstruct solver; template <class T = solver> void _main();\nint main() { _main<>(); }\n\ntemplate <class solver>\nvoid _main()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n\n    }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nstruct modint{\n    using i64=int_fast64_t;\n    i64 a;\n    static constexpr i64 MOD=998244353;\n    modint(){a=0;}\n    modint(i64 a_){\n        a=a_%MOD;\n        if(a<0) a+=MOD;\n    }\n    modint inv()const{\n        i64 n=1,m=MOD-2,A=a;\n        while(m){\n            if(m&1)(n*=A)%=MOD;\n            (A*=A)%=MOD;\n            m>>=1;\n        }\n        modint y;\n        y.a=n;\n        return y;\n    }\n    bool operator==(const modint& x){\n        return a==x.a;\n    }\n    bool operator!=(const modint& x){\n        return a!=x.a;\n    }\n    modint& operator=(const modint& x){\n        a=x.a;\n        return *this;\n    }\n    modint operator+(const modint& x){\n        modint y;\n        y.a=a+x.a;\n        if(y.a>=MOD) y.a-=MOD;\n        return y;\n    }\n    modint operator-(const modint& x){\n        modint y;\n        y.a=a-x.a;\n        if(y.a<0) y.a+=MOD;\n        return y;\n    }\n    modint operator*(const modint& x){\n        modint y;\n        y.a=(a*x.a)%MOD;\n        return y;\n    }\n    modint operator/(const modint& x){\n        modint y;\n        y.a=(a*x.inv().a)%MOD;\n        return y;\n    }\n    modint& operator+=(const modint& x){\n        a+=x.a;\n        if(a>=MOD) a-=MOD;\n        return *this;\n    }\n    modint& operator-=(const modint& x){\n        a-=x.a;\n        if(a<0) a+=MOD;\n        return *this;\n    }\n    modint& operator*=(const modint& x){\n        (a*=x.a)%=MOD;\n        return *this;\n    }\n    modint& operator/=(const modint& x){\n        (a*=x.inv().a)%=MOD;\n        return *this;\n    }\n};\nistream& operator>>(istream &in,modint& x){\n    int_fast64_t a_;\n    in>>a_;\n    modint y(a_);\n    x=y;\n    return in;\n}\nostream& operator<<(ostream &out,const modint& x){\n    out<<x.a;\n    return out;\n}\nmodint pwr(int_fast64_t a,int_fast64_t b){\n    modint _;\n    int_fast64_t n=1,A=a;\n    while(b){\n        if(b&1) (n*=A)%=modint::MOD;\n        (A*=A)%=modint::MOD;\n        b>>=1;\n    }\n    _.a=n;\n    return _;\n}\n\nvector<modint> p;\n\nint M[3]={};\nmodint C[1000][3];\n\nvoid solve(int n,int id){\n    int m{},a,b,x;\n    vector<vector<int>> e(n);\n    while((x=getchar_unlocked()-'0')>=0) m*=10,m+=x;\n    fr(i,m){\n        a=0;b=0;\n        while((x=getchar_unlocked()-'0')>=0) a*=10,a+=x;\n        while((x=getchar_unlocked()-'0')>=0) b*=10,b+=x;\n        if(a>b) swap(a,b);\n        e[a-1].emplace_back(b-1);\n    }\n    vector<int> v(n);\n    vector<bool> q(n+1);\n    ifr(i,n){\n        fr(j,e[i].size()+1) q[j]=false;\n        for(auto&j:e[i]) q[v[j]]=true;\n        fr(j,e[i].size()+1) if(!q[j]){\n            if(M[id]<j) M[id]=j;\n            C[id][v[i]=j]+=p[i+1];\n            break;\n        }\n    }\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    istream& in(cin);\n    ostream& out(cout);\n    int n{};\n    int c;\n    while((c=getchar_unlocked()-'0')>=0) n*=10,n+=c;\n    p.resize(n+1);\n    modint e18=pwr(10,18);\n    p[0]=1;\n    fr(i,n) p[i+1]=p[i]*e18;\n    fr(i,3) solve(n,i);\n    modint ans;\n    fr(i,M[0]+1) fr(j,M[1]+1) if((i^j)<=M[2]){\n        ans+=C[0][i]*C[1][j]*C[2][i^j];\n    }\n    stack<char> S;\n    while(ans.a) S.emplace('0'+ans.a%10),ans.a/=10;\n    if(S.empty()) putchar_unlocked('0');\n    for(;!S.empty();S.pop()) putchar_unlocked(S.top());\n    putchar_unlocked('\\n');\n}"
  },
  {
    "language": "C++",
    "code": "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nusing uint = unsigned;\nconst uint MOD = 998244353;\nstruct Z {\n    uint v;\n\n    Z(uint v = 0) : v(v) {}\n\n    Z& operator += (const Z &z) {\n        v += z.v;\n        if (v >= MOD) v -= MOD;\n        return *this;\n    }\n\n    Z& operator -= (const Z &z) {\n        if (v < z.v) v += MOD;\n        v -= z.v;\n        return *this;\n    }\n\n    Z& operator *= (const Z &z) {\n        v = static_cast<uint64_t>(v) * z.v % MOD;\n        return *this;\n    }\n\n    void div2() {\n        if (v & 1) v += MOD;\n        v >>= 1;\n    }\n};\n\nostream& operator << (ostream &os, const Z &z) {\n    return os << z.v;\n}\n\nZ operator + (const Z &x, const Z &y) {\n    return Z(x.v + y.v >= MOD ? x.v + y.v - MOD : x.v + y.v);\n}\n\nZ operator - (const Z &x, const Z &y) {\n    return Z(x.v < y.v ? x.v + MOD - y.v : x.v - y.v);\n}\n\nZ operator * (const Z &x, const Z &y) {\n    return Z(static_cast<uint64_t>(x.v) * y.v % MOD);\n}\n\nZ qpow(Z base, uint e) {\n    Z ret(1);\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret *= base;\n        }\n        base *= base;\n    }\n    return ret;\n}\n\nconst size_t N = 1 << 17;\nconst size_t M = 1 << 10;\n\nvector<int> g[3][N];\nint sg[3][N];\nZ pw[N];\n\nvoid dfs(int id, int u) {\n    if (~sg[id][u]) return;\n    sg[id][u] = 0;\n    for (int v : g[id][u]) {\n        dfs(id, v);\n    }\n    static int lst[N], tot = 0;\n    ++tot;\n    for (int v : g[id][u]) {\n        lst[sg[id][v]] = tot;\n    }\n    while (lst[sg[id][u]] == tot) {\n        ++sg[id][u];\n    }\n}\n\nvoid fwt_xor(Z a[], int n, int flag) {\n    for (int m = 1, l = 2; m < n; m <<= 1, l <<= 1) {\n        Z *x = a, *y = a + m;\n        for (int i = 0; i < n; i += l) {\n            for (int j = 0; j < m; ++j, ++x, ++y) {\n                Z tmp = *y;\n                *y = *x;\n                *x += tmp;\n                *y -= tmp;\n                if (flag == 2) {\n                    x->div2();\n                    y->div2();\n                }\n            }\n            x += m;\n            y += m;\n        }\n    }\n}\n\nint main() {\n    memset(sg, -1, sizeof sg);\n    int n = read();\n    for (int i = 0; i < 3; ++i) {\n        for (int m = read(); m--; ) {\n            int u = read(), v = read();\n            if (u > v) swap(u, v);\n            g[i][u].emplace_back(v);\n        }\n        for (int j = 1; j <= n; ++j) {\n            dfs(i, j);\n        }\n    }\n\n    pw[0] = 1;\n    Z mul = (LL) 1E18 % MOD;\n    for (int i = 1; i <= n; ++i) {\n        pw[i] = pw[i - 1] * mul;\n    }\n\n    static Z f[3][M];\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            f[i][sg[i][j]] += pw[j];\n        }\n    }\n    fwt_xor(f[0], M, 1);\n    fwt_xor(f[1], M, 1);\n    for (uint i = 0; i < M; ++i) {\n        f[0][i] *= f[1][i];\n    }\n    fwt_xor(f[0], M, 2);\n    Z ans = 0;\n    for (uint i = 0; i < M; ++i) {\n        ans += f[0][i] * f[2][i];\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\ntemplate <int32_t P>\nstruct ModInt_t {\n  int32_t value;\n\n  static_assert(P < (1 << 30) - 1, \"2xP must fit into 32-bit signed integer\");\n\n  ModInt_t() : value{0} {};\n\n  explicit ModInt_t(int32_t v) : value(v) {\n    if (value >= P || value <= -P) value %= P;\n    if (value < 0) value += P;\n  };\n\n  explicit operator bool() const { return value != 0; }\n  explicit operator int32_t() const { return value; }\n\n  ModInt_t& operator+=(const ModInt_t& other) {\n    value += other.value;\n    if (value >= P) value -= P;\n    return *this;\n  }\n\n  ModInt_t& operator-=(const ModInt_t& other) {\n    value -= other.value;\n    if (value < 0) value += P;\n    return *this;\n  }\n\n  ModInt_t& operator*=(const ModInt_t& other) {\n    int64_t result = static_cast<int64_t>(value) * other.value;\n    value = static_cast<int32_t>(result % P);\n    return *this;\n  }\n\n  static ModInt_t inverse(ModInt_t x) { return ModInt_t{inverse(x.value)}; }\n\n private:\n  static int32_t inverse(int32_t a) {\n    int32_t b = P, x = 1, y = 0;\n    while (b != 0) {\n      auto k = a / b;\n      a -= k * b;\n      std::swap(a, b);\n      x -= k * y;\n      std::swap(x, y);\n    }\n    assert(a == 1);\n    if (x < 0) x += P;\n    return x;\n  }\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator+(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res += b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator-(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res -= b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator*(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res *= b;\n};\n\ntemplate <int32_t P>\nbool operator==(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  return a.value == b.value;\n};\n\ntemplate <int32_t P>\nstd::ostream& operator<<(std::ostream& os, const ModInt_t<P>& a) {\n  os << a.value;\n  return os;\n}\n\ntemplate <typename T>\nstruct MulMonoid {\n  using value_type = T;\n  constexpr static T identity() { return T{1}; }\n  constexpr static T op(const T& a, const T& b) { return a * b; }\n};\n\ntemplate <typename T, typename U, typename Monoid = MulMonoid<T>>\nT power(T a, U n) {\n  T r{Monoid::identity()};\n  while (n > 0) {\n    if (n % 2) r = Monoid::op(r, a);\n    a = Monoid::op(a, a);\n    n /= 2;\n  }\n  return r;\n}\n\nusing ModInt = ModInt_t<998244353>;\n\nvector<ModInt> read(int N) {\n  int M;\n  cin >> M;\n  vector<vector<int>> E(N);\n  for (int i = 0; i < M; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    E[a].push_back(b);\n    E[b].push_back(a);\n  }\n\n  vector<ModInt> ret;\n  set<int> S;\n  for (int i = 0; i < N; ++i) {\n    S.insert(i);\n  }\n\n  while (S.size()) {\n    ModInt w{0};\n    set<int> nS = S;\n    while (S.size()) {\n      int x = *(--S.end());\n      S.erase(x);\n      nS.erase(x);\n      w += power(ModInt{10}, 18 * (x + 1));\n      for (int y : E[x]) {\n        S.erase(y);\n      }\n    }\n    S = std::move(nS);\n    ret.push_back(w);\n  }\n  return ret;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n\n  auto A = read(N);\n  auto B = read(N);\n  auto C = read(N);\n\n  ModInt ret{0};\n  for (int i = 0; i < N; ++i) {\n    if (i == 0) {\n      ret += A[i] * B[i] * C[i];\n    } else {\n      if (i < B.size() && i < C.size()) ret += A[0] * B[i] * C[i];\n      if (i < A.size() && i < C.size()) ret += A[i] * B[0] * C[i];\n      if (i < A.size() && i < B.size()) ret += A[i] * B[i] * C[0];\n    }\n  }\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int S = 500, SSS = S * S * S, N = 1e5 + 5, mod = 998244353;\n\nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n\nconst int base = powmod(10, 18);\n\nbitset<SSS> vis;\n\nint pos(int a, int b, int c) {\n  return ((a * S) + b) * S + c;\n}\n\ntuple<int, int, int> decod(int v) {\n  int c = v % S;\n  v /= S;\n  int b = v % S;\n  v /= S;\n  return make_tuple(v, b, c);\n}\n\nvector<int> g[N];\n\nvector<pair<int, int>> independent(int n, vector<pair<int ,int>> & edges) {\n  for (int i = 0; i < n; ++i)\n    g[i].clear();\n  for (auto e : edges) {\n    g[e.first].push_back(e.second);\n    g[e.second].push_back(e.first);\n  }\n  vector<bool> done(n, false), mark(n);\n  int cnt = 0;\n  vector<pair<int, int>> res;\n  while (cnt < n) {\n    mark = done;\n    int hig = -1, sum = 0;\n    for (int v = n-1; v >= 0; --v) {\n      if (mark[v]) continue;\n      ++cnt;\n      done[v] = 1;\n      hig = max(hig, v+1);\n      sum = (sum + powmod(base, v+1)) % mod;\n      for (int u : g[v]) {\n        mark[u] = 1;\n      }\n    }\n    res.emplace_back(hig, sum);\n  }\n  return res;\n}\n\nvector<pair<int, int>> read_edges() {\n  int m;\n  scanf(\"%d\", &m);\n  vector<pair<int, int>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &edges[i].first, &edges[i].second);\n    --edges[i].first;\n    --edges[i].second;\n  }\n  return edges;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> ex = read_edges();\n  vector<pair<int, int>> ey = read_edges();\n  vector<pair<int, int>> ez = read_edges();\n  vector<pair<int, int>> rx = independent(n, ex);\n  vector<pair<int, int>> ry = independent(n, ey);\n  vector<pair<int, int>> rz = independent(n, ez);\n  set<pair<int, int>> xy;\n  set<pair<int, int>> xz;\n  set<pair<int, int>> yz;\n  priority_queue<pair<int, int>> pq;\n  auto insert_node = [&](int i, int j, int k) {\n    if (i >= (int)rx.size() || j >= (int)ry.size() || k >= (int)rz.size())\n      return;\n    int now = pos(i, j, k);\n    if (vis[now])\n      return;\n    pq.emplace(rx[i].first + ry[j].first + rz[k].first, now);\n    vis[now] = 1;\n  };\n  insert_node(0, 0, 0);\n  long long ans = 0;\n  while (!pq.empty()) {\n    auto it = pq.top();\n    pq.pop();\n    int i, j, k;\n    tie(i, j, k) = decod(it.second);\n    insert_node(i+1, j, k);\n    insert_node(i, j+1, k);\n    insert_node(i, j, k+1);\n    if (xy.count(make_pair(i, j)) || xz.count(make_pair(i, k)) || yz.count(make_pair(j, k))) continue;\n    long long cur = rx[i].second * (long long) ry[j].second % mod;\n    cur = cur * rz[k].second % mod;\n    ans = (ans + cur) % mod;\n    xy.insert(make_pair(i, j));\n    xz.insert(make_pair(i, k));\n    yz.insert(make_pair(j, k));\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\n\nll duz[nax];\n\nint n;\n\nvi graf[nax];\n\nint kt[3][2];\n\nint zak[nax];\n\nmap <ll,ll> mapa[3];\n\nint ost[nax];\nint czas;\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tduz[0]=1;\n\tduz[1]=1;\n\tfor (int i=1; i<=18; i++)\n\t\tduz[1]=(duz[1]*10)%mod;\n\tfor (int i=2; i<nax; i++)\n\t\tduz[i]=(duz[i-1]*duz[1])%mod;\n\tfor (int h=0; h<3; h++)\n\t{\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tgraf[i].clear();\n\t\t\tzak[i]=0;\n\t\t}\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor (int j=1; j<=m; j++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tgraf[a].push_back(b);\n\t\t\tgraf[b].push_back(a);\n\t\t}\n\t\tfor (int i=n; i; i--)\n\t\t{\n\t\t\tczas++;\n\t\t\tfor (int j : graf[i])\n\t\t\t\tif (j>i)\n\t\t\t\t\tost[zak[j]]=czas;\n\t\t\tint x=0;\n\t\t\twhile(ost[x]==czas)\n\t\t\t\tx++;\n\t\t\tmapa[h][x]=(mapa[h][x]+duz[i])%mod;\n\t\t\tzak[i]=x;\n\t\t}\n\t\t//~ debug() << h << \" \" << range(zak+1, zak+1+n) << \" \" << range(kt[h], kt[h]+2);\n\t}\n\tll wyn=0;\n\t//~ for (int i=0; i<3; i++)\n\t\t//~ wyn=(wyn*kt[i][1])%mod;\n\t//~ for (int i=0; i<3; i++)\n\t//~ {\n\t\t//~ ll x=1;\n\t\t//~ for (int j=0; j<3; j++)\n\t\t\t//~ x=(x*kt[j][i==j])%mod;\n\t\t//~ wyn=(wyn+x)%mod;\n\t//~ }\n\tfor (auto i : mapa[0])\n\t\tfor (auto j : mapa[1])\n\t\t\twyn=(wyn+i.second*j.second%mod*mapa[2][i.first^j.first])%mod;\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int mod=998244353;\nstruct edge\n{\n\tint v,nxt;\n}e[3][500005];\nint n,m[3],h[3][100005],t[3],a[3][1000005],vis[100005],bs,inv2,lim,f[1000005];\nvector<int> b[100005];\ninline int addmod(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int submod(int x)\n{\n\treturn x<0?x+mod:x;\n}\nint fpow(int x,int y)\n{\n\tint ans=1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans=1ll*ans*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty/=2;\n\t}\n\treturn ans;\n}\nvoid add(int u,int v,int fl)\n{\n\te[fl][++t[fl]].v=v;\n\te[fl][t[fl]].nxt=h[fl][u];\n\th[fl][u]=t[fl];\n}\nvoid fwt(int *a)\n{\n\tfor(int k=1;k<lim;k<<=1)\n\t\tfor(int i=0,r=k*2;i<lim;i+=r)\n\t\t\tfor(int j=0;j<k;j++)\n\t\t\t{\n\t\t\t\tint x=a[i+j],y=a[i+j+k];\n\t\t\t\ta[i+j]=addmod(x+y);\n\t\t\t\ta[i+j+k]=submod(x-y);\n\t\t\t}\n}\nvoid ifwt(int *a)\n{\n\tfor(int k=1;k<lim;k<<=1)\n\t\tfor(int i=0,r=k*2;i<lim;i+=r)\n\t\t\tfor(int j=0;j<k;j++)\n\t\t\t{\n\t\t\t\tint x=a[i+j],y=a[i+j+k];\n\t\t\t\ta[i+j]=1ll*addmod(x+y)*inv2%mod;\n\t\t\t\ta[i+j+k]=1ll*submod(x-y)*inv2%mod;\n\t\t\t}\n}\nvoid solve(int fl)\n{\n\tfor(int i=1;i<=n;i++)\n\t\tb[i].clear();\n\tfor(int i=n;i>0;i--)\n\t{\n\t\tint nw=0;\n\t//\tprintf(\"fl=%d,nw=%d,i=%d\\n\",fl,nw,i);\n\t\tfor(int j=0;j<(int)b[i].size();j++)\n\t\t\tvis[b[i][j]]=1;\n\t\twhile(vis[nw]) nw++;\n\t\ta[fl][nw]=addmod(a[fl][nw]+fpow(bs,i));\n\t\tfor(int j=h[fl][i];j;j=e[fl][j].nxt)\n\t\t{\n\t\t\tint v=e[fl][j].v;\n\t\t\tb[v].push_back(nw);\n\t\t}\n\t\tfor(int j=0;j<(int)b[i].size();j++)\n\t\t\tvis[b[i][j]]=0;\n\t}\n}\nint main()\n{\n\tbs=fpow(10,18);\n\tinv2=fpow(2,mod-2);\n\tscanf(\"%d\",&n);\n\tlim=1;\n\twhile(lim<=n) lim<<=1;\n\tfor(int fl=0;fl<3;fl++)\n\t{\n\t\tscanf(\"%d\",&m[fl]);\n\t\tfor(int i=1;i<=m[fl];i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tadd(u,v,fl);\n\t\t\tadd(v,u,fl);\n\t\t}  \n\t\tsolve(fl);\n\t\tfwt(a[fl]);\n\t}\n\tfor(int i=0;i<lim;i++)\n\t\tf[i]=1ll*a[0][i]*a[1][i]%mod*a[2][i]%mod;\n\tifwt(f);\n\tprintf(\"%d\",f[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nint poww(int a , int b){int tms = 1; while(b){if(b & 1) tms = 1ll * tms * a % MOD; a = 1ll * a * a % MOD; b >>= 1;} return tms;}\nint mex[3][503] , N , M , ans; vector < int > nxt[100003];\n\nvoid calc(int *arr){\n\tfor(int i = 1 ; i <= N ; ++i) nxt[i].clear();\n\tcin >> M; for(int i = 1 ; i <= M ; ++i){int p , q; cin >> p >> q; nxt[min(p , q)].push_back(max(p , q));}\n\tstatic int tmp[503] , val[100003]; memset(val , 0 , sizeof(val));\n\tfor(int i = N ; i ; --i){\n\t\tfor(auto t : nxt[i]) tmp[val[t]] = 1;\n\t\twhile(tmp[val[i]]) ++val[i];\n\t\tfor(auto t : nxt[i]) tmp[val[t]] = 0;\n\t\tarr[val[i]] = (arr[val[i]] + poww(10 , 18 * i)) % MOD;\n\t}\n}\n\nint main(){\n\tcin >> N; calc(mex[0]); calc(mex[1]); calc(mex[2]);\n\tfor(int i = 0 ; i <= 500 ; ++i)\n\t\tfor(int j = 0 ; j <= 500 ; ++j)\n\t\t\tans = (ans + 1ll * mex[0][i] * mex[1][j] % MOD * mex[2][i ^ j]) % MOD;\n\tcout << ans; return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvector<Int> edge[3][110000];\nInt grundy[3][110000];\nInt grundysum[3][110000];\nInt n, m[3], a, b;\nbool nums[110000];\n\nInt mod_pow(Int x, Int a, Int m = MOD){\n    if(a == 0)return 1;\n    Int res = mod_pow(x, a / 2, m);\n    res = res * res % m;\n    if(a % 2)res *= x;\n    return res % m;\n}\n\nInt inv(Int x, Int m = MOD){\n    return mod_pow(x, m-2, m);\n}\n\n\nvoid calc(Int x){\n    for(Int i = n;i >= 1;i--){\n        for(Int neib:edge[x][i]){\n            if(neib < i)continue;\n            nums[grundy[x][neib]] = true;\n        }\n        while(nums[grundy[x][i]])grundy[x][i]++;\n        for(Int neib:edge[x][i]){\n            if(neib < i)continue;\n            nums[grundy[x][neib]] = false;\n        }\n        grundysum[x][grundy[x][i]] += mod_pow(10, 18 * i, MOD2);\n        grundysum[x][grundy[x][i]] %= MOD2;\n    }\n}\n\nint main(){\n    cin >> n;\n    for(Int i = 0;i < 3;i++){\n        cin >> m[i];\n        for(Int j = 0;j < m[i];j++){\n            cin >> a >> b;\n            edge[i][a].push_back(b);\n            edge[i][b].push_back(a);\n        }\n        calc(i);\n    }\n\n    Int ans = 0;\n    for(Int i = 0;i < 600;i++){\n        for(Int j = 0;j < 600;j++){\n            ans += grundysum[0][i] * grundysum[1][j] % MOD2 * grundysum[2][i^j] % MOD2;\n            ans %= MOD2;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define lld long double\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 101000,mod = 998244353;\nll p[N];\nint n;\nstruct graph{\n\tint hsh[N],f[N],m,n;\n\tll h[N];\n\tvector<int> e[N];\n\tvoid init(int S){\n\t\tn=S;\n\t\tread(m);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x,y;read(x);read(y);\n\t\t\tif(x>y) swap(x,y);\n\t\t\te[x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i;i--){\n\t\t\tfor(int v:e[i]) hsh[f[v]]++;\n\t\t\twhile(hsh[f[i]]) f[i]++;\n\t\t\th[f[i]]=(h[f[i]]+p[i])%mod;\n\t\t\tfor(int v:e[i]) hsh[f[v]]--;\n\t\t}\n\t}\n}Gx,Gy,Gz;\nint main(){\n\tread(n);\n\tp[0]=1;p[1]=1000000000000000000ll%mod;\n\tfor(int i=2;i<=n;i++) p[i]=p[i-1]*p[1]%mod;\n\tGx.init(n);\n\tGy.init(n);\n\tGz.init(n);\n\tint K=500;\n\tll ans=0;\n\tfor(int i=0;i<=K;i++)\n\t\tfor(int j=0;j<=K;j++)\n\t\t\tans=(ans+Gx.h[i]*Gy.h[j]%mod*Gz.h[i^j])%mod;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nconst int MOD = 998244353;\nconst long long w = ((long long)1e18)%MOD;\nlong long wpow[101010];\n\npair<long long, long long> solve(vector<pair<int, int> > V)\n{\n    long long os = 0, ts = 0;\n    vector<vector<int> > conn(N+1);\n    vector<int> sidx(N+1);\n    for(auto x: V)\n    {\n        int u, v; tie(u, v) = x;\n        conn[u].push_back(v);\n        conn[v].push_back(u);\n    }\n    for(int i=N; i>=1; --i)\n    {\n        bool e1 = false, e2 = false;\n        for(auto x: conn[i])\n        {\n            if(sidx[x] == 1) e1 = true;\n            if(sidx[x] == 2) e2 = true;\n        }\n        if(!e1)\n        {\n            sidx[i] = 1;\n            os = os + wpow[i];\n            if(os>=MOD) os -= MOD;\n        }\n        else if(!e2)\n        {\n            sidx[i] = 2;\n            ts = ts + wpow[i];\n            if(ts>=MOD) ts -= MOD;\n        }\n        else sidx[i] = 0;\n    }\n    return make_pair(os, ts);\n}\n\nint main()\n{\n    scanf(\"%d\", &N);\n    wpow[0] = 1;\n    for(int i=1; i<=N; ++i)\n        wpow[i] = wpow[i-1]*w%MOD;\n    vector<pair<long long, long long> > Q;\n    for(int i=0; i<3; ++i)\n    {\n        vector<pair<int, int> > V;\n        int M; scanf(\"%d\", &M);\n        for(int j=0; j<M; ++j)\n        {\n            int u, v; scanf(\"%d%d\", &u, &v);\n            V.emplace_back(u, v);\n        }\n        Q.push_back(solve(V));\n    }\n    long long ans = 0;\n    long long u1, u2, v1, v2, w1, w2;\n    tie(u1, u2) = Q[0];\n    tie(v1, v2) = Q[1];\n    tie(w1, w2) = Q[2];\n    ans += u1*v1%MOD*w1%MOD;\n    ans += u1*v2%MOD*w2%MOD;\n    ans += u2*v2%MOD*w1%MOD;\n    ans += u2*v1%MOD*w2%MOD;\n    ans %= MOD;\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcount\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int MOD = 998244353;\n\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nconst int C = 1000, N = 1e5 + 7;\nint sum[3][C];\nint dp[N];\nint n;\n\nint b = fp(10, 18);\nvector <int> g[N];\nvoid solve(int t) {\n    for (int i = 1; i <= n; ++i)\n        g[i].clear();\n    \n    int m;\n    cin >> m;\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        if (v < u)  \n            swap(u, v);\n        g[u].app(v);\n    }   \n\n    for (int i = n; i; --i) {\n        vector <int> a;\n        for (int v : g[i])\n            a.app(dp[v]);\n        sort(all(a));\n        a.app(N);\n        if (a[0])\n            dp[i] = 0;\n        else {\n            for (int j = 0; ; ++j)\n                if (a[j] + 1 < a[j + 1]) {\n                    dp[i] = a[j] + 1;\n                    break;\n                }   \n        }             \n        sum[t][dp[i]] = mod(sum[t][dp[i]] + fp(b, i));\n    }   \n\n}   \n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    cin >> n;\n    for (int i = 0; i < 3; ++i)\n        solve(i);\n    int ans = 0;\n    for (int a = 0; a < C; ++a)\n        for (int b = 0; b < C; ++b) \n            ans = mod(ans + mod(mod(sum[0][a] * sum[1][b]) * sum[2][a ^ b]));\n    cout << ans << endl;\n}   "
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int mod = 998244353;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nint powMod(int x, int p) {\n  int res = 1;\n  while (p) {\n    if (p & 1) {\n      res = mul(res, x);\n    }\n    p >>= 1;\n    x = mul(x, x);\n  }\n  return res;\n}\n\nint inv(int x) {\n  return powMod(x, mod - 2);\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n;\nvector<int> g[3][maxn];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int t = 0; t < 3; t++) {\n    int m;\n    scanf(\"%d\", &m);\n    for (int i = 0; i < n; i++) {\n      g[t][i].clear();\n    }\n    for (int i = 0; i < m; i++) {\n      int v, u;\n      scanf(\"%d%d\", &v, &u);\n      v--;\n      u--;\n      g[t][v].push_back(u);\n      g[t][u].push_back(v);\n    }\n  }\n  return true;\n}\n\nconst int X = ((long long) 1e18) % mod;\n\nconst int maxb = 17, maxx = (1 << maxb);\nint d[maxn];\nint mex[maxn];\nint curu;\nint a[3][maxx];\nint b[maxx];\n\nvoid solve() {\n  for (int t = 0; t < 3; t++) {\n    for (int v = n - 1; v >= 0; v--) {\n      curu++;\n      for (int i = 0; i < sz(g[t][v]); i++) {\n        int u = g[t][v][i];\n        if (u > v && d[u] < maxn) {\n          mex[d[u]] = curu;\n        }\n      }\n      auto &cur = d[v];\n      cur = 0;\n      while (mex[cur] == curu) {\n        cur++;\n      }\n    }\n    for (int i = 0; i < maxx; i++) {\n      a[t][i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n      add(a[t][d[i]], powMod(X, i + 1));\n    }\n    for (int bit = 0; bit < maxb; bit++) {\n      for (int i = 0; i < maxx; i++) {\n        if (i & (1 << bit)) {\n          continue;\n        }\n        int x = a[t][i];\n        int y = a[t][i | (1 << bit)];\n        a[t][i] = x;\n        add(a[t][i], y);\n        a[t][i | (1 << bit)] = x;\n        add(a[t][i | (1 << bit)], mod - y);\n      }\n    }\n  }\n  for (int i = 0; i < maxx; i++) {\n    b[i] = mul(mul(a[0][i], a[1][i]), a[2][i]);\n  }\n  for (int bit = 0; bit < maxb; bit++) {\n    for (int i = 0; i < maxx; i++) {\n      if (i & (1 << bit)) {\n        continue;\n      }\n      int x = b[i];\n      int y = b[i | (1 << bit)];\n      b[i] = x;\n      add(b[i], y);\n      b[i | (1 << bit)] = x;\n      add(b[i | (1 << bit)], mod - y);\n    }\n  }\n  printf(\"%d\\n\", mul(b[0], inv(maxx)));\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n#define N 100010\nconst int mod=998244353;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nconst int NUM=qpow(10,18);\nint n,cnt[3][633],pw[N*3],ans,sg[N];\nvector<int> G[N];\nint get_mex(vector<int> &vec){\n\tstatic int vis[N],myh=0;\n\t++myh;\n\tfor(auto x:vec){\n\t\tvis[x]=myh;\n\t}\n\tfor(int k=0;;++k){\n\t\tif(vis[k]^myh)return k;\n\t}\n}\nvoid dfs(int u){\n\tvector<int> tmp;\n\tfor(auto v:G[u]){\n\t\tif(!~sg[v])dfs(v);\n\t\ttmp.push_back(sg[v]);\n\t}\n\tsg[u]=get_mex(tmp);\n}\nvoid Solve(int T){\n\tint m=read();\n\tfor(int i=1;i<=n;++i){\n\t\tG[i].clear();\n\t\tsg[i]=-1;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tint u=read(),v=read();\n\t\tif(u>v)swap(u,v);\n\t\tG[u].push_back(v);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(~sg[i])continue;\n\t\tdfs(i);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tcnt[T][sg[i]]=(cnt[T][sg[i]]+pw[i])%mod;\n\t}\n}\nint main(){\n\tn=read();\n\tpw[0]=1;\n\tfor(int i=1;i<=3*n;++i){\n\t\tpw[i]=1LL*pw[i-1]*NUM%mod;\n\t}\n\tfor(int T=0;T<3;++T){\n\t\tSolve(T);\n\t}\n\tfor(int i=0;i<512;++i){\n\t\tfor(int j=0;j<512;++j){\n\t\t\tint k=i^j;\n\t\t\tans=(ans+1LL*cnt[0][i]*cnt[1][j]%mod*cnt[2][k])%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int S = 500, SSS = S * S * S, N = 1e5 + 5, mod = 998244353;\n \nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n \nconst int base = powmod(10, 18);\n \nbitset<SSS> vis;\n \nint pos(int a, int b, int c) {\n  return ((a * S) + b) * S + c;\n}\n \ntuple<int, int, int> decod(int v) {\n  int c = v % S;\n  v /= S;\n  int b = v % S;\n  v /= S;\n  return make_tuple(v, b, c);\n}\n \nvector<int> g[N];\n \nvector<pair<int, int>> independent(int n, vector<pair<int ,int>> & edges) {\n  for (int i = 0; i < n; ++i)\n    g[i].clear();\n  for (auto e : edges) {\n    g[e.first].push_back(e.second);\n    g[e.second].push_back(e.first);\n  }\n  vector<bool> done(n, false), mark(n);\n  int cnt = 0;\n  vector<pair<int, int>> res;\n  while (cnt < n) {\n    mark = done;\n    int hig = -1, sum = 0;\n    for (int v = n-1; v >= 0; --v) {\n      if (mark[v]) continue;\n      ++cnt;\n      done[v] = 1;\n      hig = max(hig, v+1);\n      sum = (sum + powmod(base, v+1)) % mod;\n      for (int u : g[v]) {\n        mark[u] = 1;\n      }\n    }\n    res.emplace_back(hig, sum);\n  }\n  return res;\n}\n \nvector<pair<int, int>> read_edges() {\n  int m;\n  scanf(\"%d\", &m);\n  vector<pair<int, int>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &edges[i].first, &edges[i].second);\n    --edges[i].first;\n    --edges[i].second;\n  }\n  return edges;\n}\n \nint main() {\n  auto start_t = clock();\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> ex = read_edges();\n  vector<pair<int, int>> ey = read_edges();\n  vector<pair<int, int>> ez = read_edges();\n  vector<pair<int, int>> rx = independent(n, ex);\n  vector<pair<int, int>> ry = independent(n, ey);\n  vector<pair<int, int>> rz = independent(n, ez);\n  assert(rx.size() < S);\n  assert(ry.size() < S);\n  assert(rz.size() < S);\n  vector<vector<bool>> xy(rx.size(), vector<bool>(ry.size(), false));\n  vector<vector<bool>> xz(rx.size(), vector<bool>(rz.size(), false));\n  vector<vector<bool>> yz(ry.size(), vector<bool>(rz.size(), false));\n  priority_queue<pair<int, int>> pq;\n  auto insert_node = [&](int i, int j, int k) {\n    if (i >= (int)rx.size() || j >= (int)ry.size() || k >= (int)rz.size())\n      return;\n    int now = pos(i, j, k);\n    if (vis[now])\n      return;\n    pq.emplace(rx[i].first + ry[j].first + rz[k].first, now);\n    vis[now] = 1;\n  };\n  insert_node(0, 0, 0);\n  long long ans = 0;\n  while (!pq.empty() && (double)(clock() - start_t) / CLOCKS_PER_SE < 1.8) {\n    auto it = pq.top();\n    pq.pop();\n    int i, j, k;\n    tie(i, j, k) = decod(it.second);\n    insert_node(i+1, j, k);\n    insert_node(i, j+1, k);\n    insert_node(i, j, k+1);\n    if (xy[i][j] || xz[i][k] || yz[j][k]) continue;\n    long long cur = rx[i].second * (long long) ry[j].second % mod;\n    cur = cur * rz[k].second % mod;\n    ans = (ans + cur) % mod;\n    xy[i][j] = 1;\n    xz[i][k] = 1;\n    yz[j][k] = 1;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=998244353;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nconst ll M=500;\nconst ll val=(1000000000000000000)%mod;\nint n;\nint tmp[100000][M];\n\nvvi f(){\n\tvvi g(n);\n\tint m;\n\tcin>>m;\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tif(u>v) swap(u,v);\n\t\tg[u].push_back(v);\n\t}\n\treturn g;\n}\n\nint main(){\n\tcin>>n;\n\tvvi g1=f(),g2=f(),g3=f();\n\tvi used(n),gra(n);\n\tvl c,cost(M);\n\twhile(used!=vi(n,1)){\n\t\tvi b(n);\n\t\tfor(int i=n-1;i>=0;i--) if(!used[i]){\n\t\t\tbool flag=1;\n\t\t\tfor(auto j:g2[i]) if(b[j]) flag=0;\n\t\t\tif(flag){\n\t\t\t\tb[i]++;\n\t\t\t\tused[i]++;\n\t\t\t}\n\t\t}\n\t\tll t=1,s=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\t(t*=val)%=mod;\n\t\t\t(s+=t*b[i])%=mod;\n\t\t}\n\t\tc.push_back(s);\n\t}\n\tfor(int i=0;i<M;i++){\n\t\ttmp[n-1][i]=1;\n\t\tvi a(n);\n\t\ta[n-1]=i;\n\t\tfor(int j=n-2;j>=0;j--){\n\t\t\tfor(auto k:g1[j]) tmp[j][a[k]]++;\n\t\t\tfor(int k=0;k<M;k++) if(!tmp[j][k]){\n\t\t\t\ta[j]=k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(auto k:g1[j]) tmp[j][a[k]]--;\n\t\t}\n\t\tll t=1;\n\t\tfor(int j=0;j<n;j++){\n\t\t\t(t*=val)%=mod;\n\t\t\tif(a[j]<c.size()) (cost[i]+=c[a[j]]*t)%=mod;\n\t\t}\n\t}\n\tfor(int i=n-1;i>=0;i--){\n\t\tset<int> st;\n\t\tfor(auto j:g3[i]) st.insert(gra[j]);\n\t\tfor(int j=0;;j++) if(st.find(j)==st.end()){\n\t\t\tgra[i]=j;\n\t\t\tbreak;\n\t\t}\n\t}\n\tll t=1,res=0;\n\tfor(int i=0;i<n;i++){\n\t\t(t*=val)%=mod;\n\t\t(res+=cost[gra[i]]*t)%=mod;\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nstruct edge {\n    ll to, cost;\n};\n\nint V;\nvector<edge> Ga[200000], Gb[200000], Gc[200000];\nbool da0[200000], db0[200000], dc0[200000];\nbool da1[200000], db1[200000], dc1[200000];\n\nvoid addedgea(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    Ga[st].push_back(e);\n}\n\nvoid addedgeb(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    Gb[st].push_back(e);\n}\n\nvoid addedgec(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    Gc[st].push_back(e);\n}\n\nll N;\nll M1, M2, M3;\nvoid setvalue() {\n    PER(i, N - 1, -1) {\n        if (da0[i] == false) {\n            REP(j, 0, Ga[i].size()) {\n                edge e = Ga[i][j];\n                if (e.to < i && da0[e.to] == false) {\n                    da0[e.to] = true;\n                }\n            }\n        } else if (da0[i] == true && da1[i] == false) {\n            REP(j, 0, Ga[i].size()) {\n                edge e = Ga[i][j];\n                if (e.to < i && da1[e.to] == false) {\n                    da1[e.to] = true;\n                }\n            }\n        }\n    }\n    PER(i, N - 1, -1) {\n        if (db0[i] == false) {\n            REP(j, 0, Gb[i].size()) {\n                edge e = Gb[i][j];\n                if (e.to < i && db0[e.to] == false) {\n                    db0[e.to] = true;\n                }\n            }\n        } else if (db0[i] == true && db1[i] == false) {\n            REP(j, 0, Gb[i].size()) {\n                edge e = Gb[i][j];\n                if (e.to < i && db1[e.to] == false) {\n                    db1[e.to] = true;\n                }\n            }\n        }\n    }\n    PER(i, N - 1, -1) {\n        if (dc0[i] == false) {\n            REP(j, 0, Gc[i].size()) {\n                edge e = Gc[i][j];\n                if (e.to < i && dc0[e.to] == false) {\n                    dc0[e.to] = true;\n                }\n            }\n        } else if (dc0[i] == true && dc1[i] == false) {\n            REP(j, 0, Gc[i].size()) {\n                edge e = Gc[i][j];\n                if (e.to < i && dc1[e.to] == false) {\n                    dc1[e.to] = true;\n                }\n            }\n        }\n    }\n    // PER(i, N - 1, -1) {\n    //     if (db0[i] == false) {\n    //         REP(j, 0, Gb[i].size()) {\n    //             edge e = Gb[i][j];\n    //             if (e.to < i && db[e.to] == 0) {\n    //                 db[e.to] = 1;\n    //             }\n    //         }\n    //     } else if (db[i] == 1) {\n    //         REP(j, 0, Gb[i].size()) {\n    //             edge e = Gb[i][j];\n    //             if (e.to < i && db[e.to] == 1) {\n    //                 db[e.to] = 2;\n    //             }\n    //         }\n    //     }\n    // }\n    // fill(dc, dc + N, 0);\n    // PER(i, N - 1, -1) {\n    //     if (dc[i] == 0) {\n    //         REP(j, 0, Gc[i].size()) {\n    //             edge e = Gc[i][j];\n    //             if (e.to < i && dc[e.to] == 0) {\n    //                 dc[e.to] = 1;\n    //             }\n    //         }\n    //     } else if (dc[i] == 1) {\n    //         REP(j, 0, Gc[i].size()) {\n    //             edge e = Gc[i][j];\n    //             if (e.to < i && dc[e.to] == 1) {\n    //                 dc[e.to] = 2;\n    //             }\n    //         }\n    //     }\n    // }\n}\n\nll ten[2000000];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> M1;\n    ten[0] = 1;\n    REP(i, 1, 2000000) {\n        ten[i] = multiply(ten[i - 1], 10);\n    }\n    REP(i, 0, M1) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedgea(a, b, 0);\n        addedgea(b, a, 0);\n    }\n    cin >> M2;\n    REP(i, 0, M2) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedgeb(a, b, 0);\n        addedgeb(b, a, 0);\n    }\n    cin >> M3;\n    REP(i, 0, M3) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedgec(a, b, 0);\n        addedgec(b, a, 0);\n    }\n    // cout << \"aaa\" << endl;\n    setvalue();\n    // cout << \"bbb\" << endl;\n    ll azero = 0, bzero = 0, czero = 0;\n    ll aone = 0, bone = 0, cone = 0;\n    REP(i, 0, N) {\n        if (da0[i] == 0) {\n            azero = modadd(azero, ten[18 * (i + 1)]);\n        } else if (da1[i] == 0) {\n            aone = modadd(aone, ten[18 * (i + 1)]);\n        }\n        if (db0[i] == 0) {\n            bzero = modadd(bzero, ten[18 * (i + 1)]);\n        } else if (db1[i] == 0) {\n            bone = modadd(bone, ten[18 * (i + 1)]);\n        }\n        if (dc0[i] == 0) {\n            czero = modadd(czero, ten[18 * (i + 1)]);\n        } else if (dc1[i] == 0) {\n            cone = modadd(cone, ten[18 * (i + 1)]);\n        }\n    }\n    ll ans = 0;\n    ans = modadd(ans, multiply(azero, multiply(bzero, czero)));\n    ans = modadd(ans, multiply(aone, multiply(bone, czero)));\n    ans = modadd(ans, multiply(aone, multiply(bzero, cone)));\n    ans = modadd(ans, multiply(azero, multiply(bone, cone)));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\n#define eb emplace_back\n\nint n, m, sg[maxn], cnt[3][maxn], mx[3], vis[maxn], pw[maxn];\nvector<int> e[maxn];\n\nvoid solve(int *cnt, int &mx)\n{\n\tm = gi();\n\tfor (int i = 1; i <= n; ++i) e[i].clear();\n\tfor (int u, v, i = 1; i <= m; ++i) {\n\t\tu = gi(); v = gi();\n\t\tif (u > v) swap(u, v);\n\t\te[u].eb(v);\n\t}\n\tfill(vis, vis + n + 1, 0);\n\tfor (int u = n; u >= 1; --u) {\n\t\tfor (int v : e[u]) vis[sg[v]] = u;\n\t\tint mex = 0;\n\t\twhile (vis[mex] == u) ++mex;\n\t\tmx = max(mx, sg[u] = mex);\n\t\tcnt[sg[u]] = (cnt[sg[u]] + pw[u]) % mod;\n\t}\n}\n\nint main()\n{\n\tn = gi();\n\tint base = ((ll)1e18) % mod;\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) pw[i] = (ll)pw[i - 1] * base % mod;\n\tfor (int i = 0; i < 3; ++i) solve(cnt[i], mx[i]);\n\n\tint ans = 0;\n\tfor (int i = 0; i <= mx[0]; ++i)\n\t\tfor (int j = 0; j <= mx[1]; ++j)\n\t\t\tans = (ans + (ll)cnt[0][i] * cnt[1][j] % mod * cnt[2][i ^ j]) % mod;\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate<class T> inline void read(T &x){\n\tx=0; register char c=getchar(); register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\n\nconst int N=1e5+10,M=400,mod=998244353;\nint n,lim,max,m[3],sg[N];\nstd::vector<int> G[3][N];\n\nstruct z {\n\tint x;\n\tz(int x=0):x(x){}\n\tfriend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n\tfriend inline z operator-(z a,z b){return (a.x-=b.x)<0?a.x+mod:a.x;}\n\tfriend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}ans,pw[N],f[3][N],g[N];\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&1)s=s*a;return s;}\n\nvoid SG(int m,std::vector<int> G[N],int sg[N]){\n\tstatic bool vis[N];\n\tfor(int i=n;i>=1;i--){\n\t\tfor(int j:G[i])vis[sg[j]]=1;\n\t\tsg[i]=0;\n\t\twhile(vis[sg[i]])sg[i]++;\n\t\tfor(int j:G[i])vis[sg[j]]=0;\n\t}\n}\n\nvoid fwt(z *a){\n\tfor(int len=1;len<lim;len<<=1)\n\t\tfor(int i=0;i<lim;i+=(len<<1))\n\t\t\tfor(int j=0;j<len;j++){\n\t\t\t\tz x=a[i+j],y=a[i+j+len];\n\t\t\t\ta[i+j]=x+y,a[i+j+len]=x-y;\n\t\t\t}\n}\n\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(n),lim=sqrt(n);\n\tfor(int i=0;i<3;i++){\n\t\tread(m[i]);\n\t\tfor(int u,v,j=1;j<=m[i];j++){\n\t\t\tread(u),read(v);\n\t\t\t// G[i][u].push_back(v);\n\t\t\tG[i][std::min(u,v)].push_back(std::max(u,v));\n\t\t\t// G[i][std::max(u,v)].push_back(std::min(u,v));\n\t\t}\n\t}\n\tpw[0]=1,pw[1]=fpow(10,18);\n\tfor(int i=2;i<=n;i++)pw[i]=pw[i-1]*pw[1];\n\tfor(int i=0;i<3;i++){\n\t\tSG(m[i],G[i],sg);\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmax=std::max(max,sg[j]);\n\t\t\tf[i][sg[j]]=f[i][sg[j]]+pw[j];\n\t\t}\n\t\t// for(int j=1;j<=n;j++){\n\t\t// \tprintf(\"%d%c\",sg[j],\" \\n\"[j==n]);\n\t\t// }\n\t}\n\tlim=1; while(lim<=max)lim<<=1;\n\tfor(int i=0;i<lim;i++)\n\t\tfor(int j=0;j<lim;j++)\n\t\t\tfor(int k=0;k<lim;k++){\n\t\t\t\tg[i^j^k]=g[i^j^k]+f[0][i]*f[1][j]*f[2][k];\n\t\t\t\t// if(f[0][i].x&&f[1][j].x&&f[2][k].x){\n\t\t\t\t// \tprintf(\"%d %d %d : %d\\n\",i,j,k,f[0][i]*f[1][j]*f[2][k]);\n\t\t\t\t// }\n\t\t\t}\n\t// for(int i=0;i<3;i++)fwt(f[i]);\n\t// for(int i=0;i<3;i++)g[i]=f[0][i]*f[1][i]*f[2][i];\n\t// fwt(g);\n\t// z invlim=fpow(lim,mod-2);\n\t// for(int i=0;i<lim;i++)g[i]=g[i]*invlim;\n\t// for(int i=0;i<lim;i++){\n\t// \tprintf(\"%d : %d\\n\",i,g[i]);\n\t// }\n\tprintf(\"%d\\n\",g[0]);\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 998244353\n\nvi adjList[100000];\nint power[100001];\nint grundy[3][100000],num[3][1000];\nint main() {\n    int i,j,k;\n    int N,M,u,v;\n    scanf(\"%d\",&N);\n    power[0] = 1,power[1] = ((LLI) 1e18) % MOD;\n    for (i = 2; i <= N; i++) power[i] = ((LLI) power[i-1]*power[1]) % MOD;\n    for (i = 0; i < 3; i++) {\n        scanf(\"%d\",&M);\n        for (j = 0; j < M; j++) {\n            scanf(\"%d %d\",&u,&v);\n            u--,v--;\n            if (u > v) swap(u,v);\n            adjList[u].pb(v);\n        }\n        for (j = N-1; j >= 0; j--) {\n            set<int> S;\n            for (k = 0; k < adjList[j].size(); k++) S.insert(grundy[i][adjList[j][k]]);\n            while (S.count(grundy[i][j])) grundy[i][j]++;\n            num[i][grundy[i][j]] += power[j+1],num[i][grundy[i][j]] %= MOD;\n            adjList[j].clear();\n        }\n    }\n\n    int ans = 0;\n    for (i = 0; i < 1000; i++) {\n        for (j = 0; j < 1000; j++) ans += ((((LLI) num[0][i]*num[1][j]) % MOD)*num[2][i^j]) % MOD,ans %= MOD;\n    }\n    printf(\"%d\\n\",ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=100005;\nconst int mod=998244353;\nconst int base=716070898;\nconst int inv2=(mod+1)/2;\nint n,m,sz;\nvector<int>edge[maxn];\nint pw[maxn],dp[maxn],F[4][maxn*4];\nbool occ[maxn];\n\nvoid fwt(int *x,int sz,int tp){\n\tfor(int m=2;m<=sz;m<<=1){\n\t\tint mm=m>>1;\n\t\tfor(int i=0;i<sz;i+=m){\n\t\t\tint *p1=x+i,*p2=x+i+mm;\n\t\t\tfor(int j=0;j<mm;j++,p1++,p2++){\n\t\t\t\tint u=*p1,v=*p2;\n\t\t\t\t*p1=u+v>=mod?u+v-mod:u+v;\n\t\t\t\t*p2=u-v<0?u-v+mod:u-v;\n\t\t\t\tif(tp<0){\n\t\t\t\t\t*p1=1LL*(*p1)*inv2%mod;\n\t\t\t\t\t*p2=1LL*(*p2)*inv2%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++)pw[i]=1LL*pw[i-1]*base%mod;\n\tfor(sz=1;sz<n;sz<<=1);\n\tfor(int t=1;t<=3;t++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tdp[i]=0;\n\t\t\tedge[i].clear();\n\t\t}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tedge[u].push_back(v);\n\t\t\tedge[v].push_back(u);\n\t\t}\n\t\tfor(int i=n;i>=1;i--){\n\t\t\tfor(int j=0;j<int(edge[i].size());j++)\n\t\t\t\tif(edge[i][j]>i)occ[dp[edge[i][j]]]=true;\n\t\t\twhile(occ[dp[i]])dp[i]++;\n\t\t\tF[t][dp[i]]+=pw[i];\n\t\t\tif(F[t][dp[i]]>=mod)F[t][dp[i]]-=mod;\n\t\t\tfor(int j=0;j<int(edge[i].size());j++)\n\t\t\t\tif(edge[i][j]>i)occ[dp[edge[i][j]]]=false;\n\t\t}\n\t\tfwt(F[t],sz,1);\n\t}\n\tfor(int i=0;i<sz;i++)F[0][i]=1LL*F[1][i]*F[2][i]%mod*F[3][i]%mod;\n\tfwt(F[0],sz,-1);\n\tprintf(\"%d\\n\",F[0][0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\n\nconst int MAXN = 100000;\nconst ll MOD = 998244353;\nconst ll PO = 1000000000000000000LL%MOD;\nconst int SQ = 450;\n\nint n;\nvector<int> lis[3][100100];\nll an1[100100];\nll anv[SQ+10];\nint an2[SQ+10][100100];\nll anv2[SQ+10];\nint an3[100100];\nll po[300100];\n\nint chk[100100];\nint chk2[100100][SQ+10];\nint main(){\n\tscanf(\"%d\",&n);\n\tint m;\n\tfor (int t=0;t<3;t++) {\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b); a--; b--;\n\t\t\tif (a>b) swap(a,b);\n\t\t\tlis[t][a].push_back(b);\n\t\t}\n\t}\n\tpo[0] = 1;\n\tfor (int i=1;i<=3*n;i++) po[i] = po[i-1]*PO%MOD;\n\tfor (int i=n-1;i>=0;i--) {\n\t\tfor (int &j : lis[0][i]) chk[an1[j]] = 1;\n\t\tint t;\n\t\tfor (t=0;chk[t];t++);\n\t\tan1[i] = t;\n\t\tanv[t] = (anv[t]+po[i])%MOD;\n\t\tfor (int &j : lis[0][i]) chk[an1[j]] = 0;\n\t}\n\tfor (int j=0;j<SQ;j++) {\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int &k : lis[1][i]) chk2[i][an2[j][k]]++;\n\t\t\tint t;\n\t\t\tfor (t = 0; chk2[i][t]; t++);\n\t\t\tan2[j][i] = t;\n\t\t\tanv2[j] = (anv2[j] + anv[t]*po[i]) % MOD;\n\t\t\tfor (int &k : lis[1][i]) chk2[i][an2[j][k]]--;\n\t\t}\n\t\t//printf(\"%d : %lld\\n\",j,anv2[j]);\n\t\tfor (int i=0;i<n;i++) chk2[i][an2[j][i]]++;\n\t}\n\tll ans = 0;\n\tfor (int i=n-1;i>=0;i--) {\n\t\tfor (int &j : lis[2][i]) chk[an3[j]] = 1;\n\t\tint t;\n\t\tfor (t=0;chk[t];t++);\n\t\tan3[i] = t;\n\t\tans = (ans+anv2[t]*po[i])%MOD;\n\t\tfor (int &j : lis[2][i]) chk[an3[j]] = 0;\n\t}\n\tprintf(\"%lld\\n\",ans*po[3]%MOD);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define sz(x) (int)(x).size()\n#define trav(a,x) for(auto &a:x)\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nconst ll MOD=998244353;\nvector<int> labels(vector<vector<int>> g) {\n    int n = sz(g);\n    vector<int> label(n);\n    for(int i=n-1;i>=0;--i) {\n        vector<int> others;\n        for(int j:g[i]) if(j>i) others.push_back(label[j]);\n        sort(all(others));\n        int k=0;\n        for(int x:others) {\n            if(x==k) ++k;\n            else if(x>k) break;\n        }\n        label[i]=k;\n    }\n    return label;\n}\nvector<vector<int>> getgraph(int n) {\n    int m;\n    cin>>m;\n    vector<vector<int>> g(n);\n    rep(i,0,m) {\n        int a,b;\n        cin>>a>>b;\n        --a;--b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    return g;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin>>n;\n    ll B = 1;\n    rep(i,0,18) B=(B*10)%MOD;\n    vector<ll> power(n,B);\n    rep(i,1,n) power[i]=(B*power[i-1])%MOD;\n    auto g1 = getgraph(n);\n    auto g2 = getgraph(n);\n    auto g3 = getgraph(n);\n    auto l1 = labels(g1), l2 = labels(g2), l3=labels(g3);\n    vector<ll> w1(2*n), w2(2*n), w3(2*n);\n    rep(i,0,n) {\n        w1[l1[i]]=(w1[l1[i]]+power[i])%MOD;\n        w2[l2[i]]=(w2[l2[i]]+power[i])%MOD;\n        w3[l3[i]]=(w3[l3[i]]+power[i])%MOD;\n    }\n    // rep(i,0,n) {\n    //     cerr<<w1[i]<<\" \"<<w2[i]<<\" \"<<w3[i]<<\"\\n\";\n    // }\n    int mxl1=0,mxl2=0;\n    rep(i,0,n) {\n        if(w1[i]!=0) mxl1=i;\n        if(w2[i]!=0) mxl2=i;\n    }\n    ll ans=0;\n    rep(i,0,mxl1+1) rep(j,0,mxl2+1) {\n        ll x=(w1[i]*w2[j])%MOD;\n        ans=(ans+x*w3[i^j])%MOD;\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <limits.h>\n#include <fstream>\n\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define pll pair <ll, ll>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n#define uint unsigned int\n\nconst int maxn = (int)1e6 + 10, mod = 998244353;\nchar s[maxn];\n\nint mul(int x, int y) {\n\treturn (ll)x * y % mod;\n}\n\nint add(int x, int y) {\n\tx += y;\n\tif (x >= mod) {\n\t\tx -= mod;\n\t}\n\treturn x;\n}\n\nint sub(int x, int y) {\n\tx -= y;\n\tif (x < 0) {\n\t\tx += mod;\n\t}\n\treturn x;\n}\n\nint my_pow(int x, int y) {\n\tint ans = 1;\n\n\twhile (y) {\n\t\tif (y & 1) {\n\t\t\tans = mul(ans, x);\n\t\t}\n\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\n\nconst int maxlog = 23;\nint g[maxlog + 1];\n\nint rev(int x, int st) {\n\tint y = 0;\n\n\tfor (int i = 0; i < st; i++) {\n\t\ty <<= 1;\n\t\ty += x & 1;\n\t\tx >>= 1;\n\t}\n\treturn y;\n}\n\nvoid fft(vector <int> &v, int st, bool fl) {\n\tint n = (1 << st);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = rev(i, st);\n\t\tif (x < i) {\n\t\t\tswap(v[i], v[x]);\n\t\t}\n\t}\n\n\tfor (int len = 2; len <= n; len <<= 1) {\n\t\tfor (int i = 0; i < n; i += len) {\n\t\t\tfor (int j = i; j < i + len / 2; j++) {\n\t\t\t\tint a = v[j];\n\t\t\t\tint b = v[j + len / 2];\n\t\t\t\tv[j] = add(a, b);\n\t\t\t\tv[j + len / 2] = sub(a, b);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (fl) {\n\t\tint rn = my_pow(n, mod - 2);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i] = mul(v[i], rn);\n\t\t}\n\t}\n}\n\nint n;\n\nvector <int> red[maxn];\n\nconst int mag = 19;\n\nint mex(vector <int> a) {\n\tvector <int> cnt((int)a.size() + 1, 0);\n\n\tfor (int x : a) {\n\t\tif (x < (int)cnt.size()) {\n\t\t\tcnt[x]++;\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\twhile (cnt[ans]) {\n\t\tans++;\n\t}\n\n\treturn ans;\n}\n\nvector <int> get() {\n\tint m;\n\tcin >> m;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tred[i].clear();\n\t}\n\n\twhile (m--) {\n\t\tint x, y;\n\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tred[y].push_back(x);\n\t\tred[x].push_back(y);\n\t}\n\n\tvector <int> ans(1 << mag, 0);\n\n\tint f = my_pow(10, 18);\n\tint x = 1;\n\n\tvector <int> ps(n + 1);\n\n\tfor (int i = n; i > 0; i--) {\n\t\tvector <int> a;\n\n\t\tfor (int u : red[i]) {\n\t\t\tif (u > i) {\n\t\t\t\ta.push_back(ps[u]);\n\t\t\t}\n\t\t}\n\n\t\tps[i] = mex(a);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tx = mul(x, f);\n\n\t\tans[ps[i]] = add(ans[ps[i]], x);\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tg[maxlog] = my_pow(3, (mod - 1) / (1 << maxlog));\n\tfor (int i = maxlog - 1; i >= 0; i--) {\n\t\tg[i] = mul(g[i + 1], g[i + 1]);\n\t}\n\n\tcin >> n;\n\tauto a = get();\n\tauto b = get();\n\tauto c = get();\n\n\tfft(a, mag, false);\n\tfft(b, mag, false);\n\tfft(c, mag, false);\n\n\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\ta[i] = mul(mul(a[i], b[i]), c[i]);\n\t}\n\n\tfft(a, mag, true);\n\tcout << a[0] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cctype>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define gc getchar()//(p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++)\n#define mk make_pair\n#define pi pair<int,int>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int N=1e5+10,size=1<<20,mod=998244353;\n\n//char buf[size],*p1=buf,*p2=buf;\ntemplate<class o> void qr(o &x) {\n\tchar c=gc; x=0; int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=gc;}\n\twhile(isdigit(c)) x=x*10+c-'0',c=gc;\n\tx*=f;\n}\ntemplate<class o> void qw(o x) {\n\tif(x/10) qw(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class o> void pr1(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x); putchar(' ');\n}\ntemplate<class o> void pr2(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x); puts(\"\");\n}\n\nstruct edge{int y,next;}a[N];int len,last[N];\nvoid ins(int x,int y) {a[++len]=(edge){y,last[x]};last[x]=len;}\n\nvoid upd(int &x) {x+=x>>31&mod;}\n\nll power(ll a,ll b=mod-2) {\n\tll c=1;\n\tfor(   ;b;b>>=1,a=a*a%mod)\n\t\tif(b&1) c=c*a%mod;\n\treturn c;\n}\n\nint n,m,f[N],sum[3][N],sz[3],g[N],num,ans,fir,inv=power(fir=power(10,18));\n\nint main() {\n\tqr(n);\n\tfor(int graph=0;graph<3;graph++) {\n\t\tif(len) memset(last+1,0,n<<2),len=0;\n\t\tqr(m); for(int j=1,x,y;j<=m;j++) {\n\t\t\tqr(x),qr(y);\n\t\t\tif(x>y) swap(x,y);\n\t\t\tins(x,y);\n\t\t}\n\t\tint now=power(fir,n);\n\t\tfor(int i=n; i;i--) {\n\t\t\t//求sg函数(f)\n\t\t\t++num;\n\t\t\tfor(int k=last[i];k;k=a[k].next)\n\t\t\t\tg[f[a[k].y]]=num;\n\t\t\tf[i]=0;\n\t\t\twhile(g[f[i]]==num) f[i]++;\n\t\t\tsz[graph]=max(sz[graph],f[i]);\n\t\t\tupd(sum[graph][f[i]]+=now-mod);\n\t\t\tnow=(ll)now*inv%mod;\n\t\t}\n\t}\n\tfor(int i=0;i<=sz[0];i++)\n\t\tfor(int j=0,k;j<=sz[1];j++) {\n\t\t\tk=i^j;\n\t\t\tupd(ans+=(ll)sum[0][i]*sum[1][j]%mod*sum[2][k]%mod-mod);\n\t\t}\n\tpr2(ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int MOD = 998244353;\n\nvoid sadd(int &a, int b)\n{\n    a += b;\n    if (a >= MOD)\n        a -= MOD;\n}\nint add(int a, int b)\n{\n    sadd(a, b);\n    return a;\n}\nint mul(int a, int b)\n{\n    return (a * 1LL * b) % MOD;\n}\n\nint fpow(int x, int n)\n{\n    if (n == 0)\n        return 1;\n    int a = fpow(x, n >> 1);\n    a = mul(a, a);\n    if (n & 1)\n        a = mul(a, x);\n    return a;\n}\n\n\nconst int N = (int) 1e5 + 100;\nvector <int> g[N];\nint used[N];\nint val[3][N];\n\nvoid solve(int t, int n)\n{\n    for (int i = 0; i <= n; i++)\n    {\n        used[i] = 0;\n        g[i].clear();\n    }\n    int m;\n    scanf(\"%d\", &m);\n\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        scanf(\"%d%d\", &a, &b);\n        if (a > b) swap(a, b);\n        g[a].push_back(b);\n    }\n\n    set <int> s;\n    for (int i = n; i >= 1; i--)\n    {\n        s.clear();\n        for (int to : g[i])\n            s.insert(used[to]);\n        while (s.count(used[i]))\n            used[i]++;\n        int x = fpow(10, 18 * i);\n        sadd(val[t][used[i]], x);\n    }\n}\n\nint sum[3];\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int n;\n    scanf(\"%d\", &n);\n\n    int ans = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        solve(i, n);\n    }\n    \n    sadd(ans, mul(val[0][0], mul(val[1][0], val[2][0])));\n\n    for (int i = 1; i < n; i++)\n    {\n        for (int t = 0; t < 3; t++)\n            sadd(sum[t], val[t][i - 1]);\n        sadd(ans, mul(sum[0], mul(val[1][i], val[2][i])));\n        sadd(ans, mul(val[0][i], mul(sum[1], val[2][i])));\n        sadd(ans, mul(val[0][i], mul(val[1][i], sum[2])));\n    }\n    \n    \n    printf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <set>\n\nconst int P=998244353;\ninline int mul(const int &a,const int &b){return 1ll*a*b%P;}\ninline int add(int a,const int &b){a+=b;return(a>=P)?a-P:a;}\ninline int sub(int a,const int &b){a-=b;return (a<0)?a+P:a;}\nint qsm(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=mul(ans,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nint Pow[100001],f[131072],lim,n,head[100001],nxt[100001],b[100001],k,m,v[100001],g[131072];\nvoid push(int s,int t){\n\tnxt[++k]=head[s];\n\thead[s]=k;\n\tb[k]=t;\n}\nstd::set<int>set;\nvoid FWT(int *a){\n\tfor(int i=1;i<lim;i<<=1)\n\t\tfor(int j=0;j<lim;j+=(i<<1))\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tconst int Ny=a[i+j+k];\n\t\t\t\ta[i+j+k]=sub(a[j+k],Ny);\n\t\t\t\ta[j+k]=add(a[j+k],Ny);\n\t\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tlim=1;\n\twhile(lim<=n)lim<<=1;\n\tfor(int i=0;i<lim;i++)g[i]=1;\n\tPow[0]=1;\n\tfor(int i=1;i<=n;i++)Pow[i]=mul(Pow[i-1],(1000000000000000000ll)%P);\n//\tfor(int i=1;i<=n;i++)printf(\"%d \",Pow[i]);putchar('\\n');\n\tfor(int fd=0;fd<3;fd++){\n\t\tfor(int j=1;j<=n;j++)head[j]=v[j]=0;\n\t\tk=0;\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1,u,v;j<=m;j++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tif(u>v)push(v,u);\n\t\t\telse push(u,v);\n\t\t}\n\t\tfor(int i=n;i;i--){\n\t\t\tset.clear();\n\t\t\tfor(int j=head[i];j;j=nxt[j])\n\t\t\t\tset.insert(v[b[j]]);\n\t\t\tfor(v[i]=0;set.count(v[i]);v[i]++);\n\t\t}\n\t\tfor(int j=0;j<lim;j++)f[j]=0;\n\t\tfor(int j=1;j<=n;j++)f[v[j]]=add(f[v[j]],Pow[j]); \n\t\tFWT(f);\n\t\tfor(int j=0;j<lim;j++)g[j]=mul(g[j],f[j]);\n\t}\n\tint inv=qsm(lim,P-2),ans=0;\n\tfor(int i=0;i<lim;i++)ans=add(ans,g[i]);\n\tprintf(\"%d\\n\",mul(ans,inv));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nconstexpr auto pow(long long x, long long n, const long long mod) {\n    long long ret = 1;\n    while(n > 0) {\n        if ((n & 1) == 1) ret = (ret * x) % mod;\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return ret;\n}\n\nint main() {\n    constexpr i64 mod = 998244353, base = pow(10, 18, mod);\n    int n, m[3];\n    std::cin >> n;\n\n    auto f = [&](int n) { return pow(base, n, mod); };\n\n    std::vector<std::vector<int>> g[3], par(3);\n    i64 b[3][2] {};\n    for (int i = 0; i < 3; i++) {\n        std::cin >> m[i];\n        g[i].resize(n + 1); par[i].resize(n + 1);\n        for (int j = 0; j < m[i]; j++) {\n            int u, v;\n            std::cin >> u >> v;\n            if (u < v) std::swap(u, v);\n            g[i][v].push_back(u);\n        }\n\n        for (int j = n; j > 0; j--) {\n            if (g[i][j].empty()) {\n                b[i][0] = (b[i][0] + f(j)) % mod;\n                continue;\n            }\n            int x = 0;\n            for (int p : g[i][j]) {\n                if (par[i][p] == -1) continue;\n                x |= 1 << par[i][p];\n            }\n\n            if (x == 3) par[i][j] = -1;\n            else if (x == 1) par[i][j] = 1;\n\n            if (par[i][j] >= 0) b[i][par[i][j]] = (b[i][par[i][j]] + f(j)) % mod;\n        }\n    }\n\n    i64 ret = (b[0][0] * (b[1][0] * b[2][0] % mod + b[1][1] * b[2][1] % mod) % mod\n        + b[0][1] * (b[1][0] * b[2][1] % mod + b[1][1] * b[2][0] % mod) % mod) % mod;\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\nint read();\nint n;\nint m1, m2, m3;\nvoid Add(int& x, int y) { (x += y) >= mod ? x -= mod : x; }\n\nvector<int> e[3][100005];\nvoid add(int f, int t, int d) { e[d][f].push_back(t), e[d][t].push_back(f); }\nint sg[3][100005];\nvector<int> nx[100005];\nvoid solve(int d) {\n    for (int i = 1; i <= n; ++i) nx[i].clear();\n    for (int u = n; u >= 1; --u) {\n        sort(nx[u].begin(), nx[u].end());\n        for (int v : nx[u]) {\n            if (sg[d][u] == v) sg[d][u]++;\n            if (sg[d][u] < v) break;\n        }\n        for (int v : e[d][u]) nx[v].push_back(sg[d][u]);\n    }\n}\n\nint fsp(int base, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = 1ll * rt * base % mod;\n        base = 1ll * base * base % mod, p >>= 1;\n    }\n    return rt;\n}\nint M(int x) { return x + (x >> 31 & mod); }\nstruct Poly {\n    int x[300005];\n    int& operator[](int p) { return x[p]; }\n    void fwt(int len) {\n        for (int l = 2; l <= len; l <<= 1)\n            for (int i = 0, m = l >> 1; i < len; i += l)\n                for (int j = i, t; j < i + m; ++j)\n                    t = x[j + m], x[j + m] = M(x[j] - t), Add(x[j], t);\n    }\n} F[3];\n\nint main() {\n    n = read(), m1 = read();\n    for (int i = 1; i <= m1; ++i) add(read(), read(), 0);\n    m2 = read();\n    for (int i = 1; i <= m2; ++i) add(read(), read(), 1);\n    m3 = read();\n    for (int i = 1; i <= m3; ++i) add(read(), read(), 2);\n    for (int i = 0; i < 3; ++i) {\n        solve(i);\n        for (int j = 1, t = 1, p = fsp(10, 18); j <= n; ++j)\n            t = 1ll * t * p % mod, Add(F[i][sg[i][j]], t);\n    }\n    int len = 1;\n    while (len <= n) len <<= 1;\n    F[0].fwt(len), F[1].fwt(len), F[2].fwt(len);\n    for (int i = 0; i < len; ++i)\n        F[0][i] = 1ll * F[0][i] * F[1][i] % mod * F[2][i] % mod;\n\n    F[0].fwt(len);\n    printf(\"%d\\n\", 1ll * F[0][0] * fsp(len, mod - 2) % mod);\n    return 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int W = 716070898, P = 998244353, I2 = 499122177;\n\nvoid add(int&x , int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int N;\n  cin >> N;\n  vector<int> pw(N);\n  pw[0] = 1;\n  for (int i = 1; i < N; ++i) pw[i] = pw[i - 1] * (ll)W % P;\n  int l = 0;\n  while ((1 << l) <= N) ++l;\n  vector<int> SG1, SG2, SG3;\n  auto getSG = [&]() {\n    vector<int> ret(N);\n    int M;\n    cin >> M;\n    vector<vector<int>> G(N);\n    while (M--) {\n      int u, v;\n      cin >> u >> v;\n      --u; --v;\n      if (u > v) swap(u, v);\n      G[u].push_back(v);\n    }\n    for (int i = N - 1; i >= 0; --i) {\n      vector<bool> vis(G[i].size() + 1);\n      for (int v : G[i])\n        vis[ret[v]] = true;\n      while (vis[ret[i]]) ++ret[i];\n    }\n    return ret;\n  };\n  SG1 = getSG();\n  SG2 = getSG();\n  SG3 = getSG();\n  auto toWt = [&](const vector<int>& SG) {\n    vector<int> ret(1 << l);\n    for (int i = 0; i < N; ++i)\n      add(ret[SG[i]], pw[i]);\n    return ret;\n  };\n  auto A1 = toWt(SG1), A2 = toWt(SG2), A3 = toWt(SG3);\n  auto FWT = [&](vector<int>& A) -> void {\n    for (int i = 0; i < l; ++i)\n      for (int j = 0; j < (1 << l); ++j)\n        if (!((j >> i) & 1)) {\n          int a0 = A[j], a1 = A[j ^ (1 << i)];\n          A[j] = (a0 + a1) % P;\n          A[j ^ (1 << i)] = (a0 - a1 + P) % P;\n        }\n  };\n  FWT(A1);\n  FWT(A2);\n  FWT(A3);\n  for (int i = 0; i < (1 << l); ++i)\n    A1[i] = A1[i] * (ll)A2[i] % P * A3[i] % P;\n  FWT(A1);\n  int ans = A1[0] * (ll)W % P * W % P * W % P;\n  for (int i = 0; i < l; ++i)\n    ans = ans * (ll)I2 % P;\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cstdint>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <chrono>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <utility>\n#include <limits>\n#include <list>\n\n/* template start */\n \n#define rep(i, a, b) for (long long i = (a); (i) < (b); (i)++)\n#define all(i) i.begin(), i.end()\n\n#ifdef LOCAL\n#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nvoid debug_out(){std::cerr<<std::endl;}\n\ntemplate<typename Head,typename... Tail>\nvoid debug_out(Head h,Tail... t){\n  std::cerr<<\" \"<<h;\n  if(sizeof...(t)>0)std::cout<<\" :\";\n  debug_out(t...);\n}\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (std::size_t i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n\ntemplate<typename Num>\nconstexpr Num mypow(Num a, long long b) {\n  if(b==0)return 1;\n  if (a==0)return 0;\n  Num x = 1;\n  while (b > 0) {\n    if(b & 1)x*=a;\n    a*=a;\n    b >>= 1;\n  }\n  return x;\n}\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr bool operator==(const modint rhs) const noexcept {return a==rhs.a;}\n  constexpr bool operator!=(const modint rhs) const noexcept {return !(*this==rhs);}\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\n/* template end */\n\nusing ll = long long;\nusing P=std::pair<long long,long long>;\n\nconstexpr ll MOD=998244353;\nusing mint=modint<MOD>;\n\nint main() {\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  std::cin>>n;\n\n  std::vector<std::vector<ll>> x(n),y(n),z(n);\n\n  ll m1;\n  std::cin>>m1;\n  rep(i,0,m1){\n    ll a,b;\n    std::cin>>a>>b;\n    a--;b--;\n    if(a>b)std::swap(a,b);\n    x[a].emplace_back(b);\n  }\n\n  ll m2;\n  std::cin>>m2;\n  rep(i,0,m2){\n    ll a,b;\n    std::cin>>a>>b;\n    a--;b--;\n    if(a>b)std::swap(a,b);\n    y[a].emplace_back(b);\n  }\n\n  ll m3;\n  std::cin>>m3;\n  rep(i,0,m3){\n    ll a,b;\n    std::cin>>a>>b;\n    a--;b--;\n    if(a>b)std::swap(a,b);\n    z[a].emplace_back(b);\n  }\n\n  ll m=std::max({m1,m2,m3});\n\n  constexpr mint INF=mypow(mint(10),18);\n  std::vector<mint> pow(n+1,1);\n  rep(i,1,n+1)pow[i]=pow[i-1]*INF;\n\n  ll root=0;\n  while(root*(root+1)<=2*m)root++;\n\n  std::vector<ll> gru_x(n),gru_y(n),gru_z(n);\n  std::vector<mint> val_x(root,0),val_y(root,0),val_z(root,0);\n\n  for(ll i=n-1;i>=0;i--){\n    std::vector<ll> flag(root,0);\n    for(auto&& e:x[i])flag[gru_x[e]]=1;\n    rep(j,0,root){\n      if(flag[j]==0){\n        gru_x[i]=j;\n        val_x[j]+=pow[i+1];\n        break;\n      }\n    }\n  }\n\n  for(ll i=n-1;i>=0;i--){\n    std::vector<ll> flag(root,0);\n    for(auto&& e:y[i])flag[gru_y[e]]=1;\n    rep(j,0,root){\n      if(flag[j]==0){\n        gru_y[i]=j;\n        val_y[j]+=pow[i+1];\n        break;\n      }\n    }\n  }\n\n  for(ll i=n-1;i>=0;i--){\n    std::vector<ll> flag(root,0);\n    for(auto&& e:z[i])flag[gru_z[e]]=1;\n    rep(j,0,root){\n      if(flag[j]==0){\n        gru_z[i]=j;\n        val_z[j]+=pow[i+1];\n        break;\n      }\n    }\n  }\n\n  mint ans=0;\n\n  rep(i,0,root){\n    rep(j,0,root){\n      if((i^j)<root)ans+=val_x[i]*val_y[j]*val_z[i^j];\n    }\n  }\n\n  std::cout<<ans.value()<<\"\\n\";\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//const ll MOD = 1000000007;\nconst ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nconst int MAXN = 555555;\n\nvl fact(MAXN);\nvl rfact(MAXN);\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  if (p < 0) {\n    x = mod_pow(x, M - 2, M);\n    p = -p;\n  }\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\nvoid set_fact(ll n, ll M = MOD) {\n  fact[0] = fact[1] = rfact[0] = rfact[1] = 1;\n  for (ll i = 2; i <= n; i++) {\n    fact[i] = i * fact[i - 1] % M;\n    // rfact[i] = mod_inverse(fact[i], M);\n  }\n}\n\n//http://drken1215.hatenablog.com/entry/2018/06/08/210000\n//n���傫��fact���v�Z�ł��Ȃ��Ƃ��̂ق��̌v�Z���@�ɂ��ď����Ă���\nll nCr(ll n, ll r, ll M = MOD) {\n  if (r > n) return 0;\n  assert(fact[2] == 2);\n  ll ret = fact[n];\n  if (rfact[r] == 0) {\n    rfact[r] = mod_inverse(fact[r], M);\n  }\n  ret = (ret*rfact[r]) % M;\n  if (rfact[n - r] == 0) {\n    rfact[n - r] = mod_inverse(fact[n - r], M);\n  }\n  ret = (ret*rfact[n - r]) % M;\n  return ret;\n}\n\nll nHr(ll n, ll r) {\n  return nCr(n+r-1, r);\n}\n\nint n;\nvector<vii> G(3);\nvector<vii> num(3, vii(500));\n\nvoid solve(int idx, vii G) {\n    vi g(n);\n    rrep (u, n) {\n        set<int> st;\n        for (int v: G[u]) {\n            if (v > u) st.insert(g[v]);\n        }\n\n        rep (gl, 50000) {\n            if (not st.count(gl)) {\n                g[u] = gl;\n                num[idx][gl].push_back(u);\n                break;\n            }\n        }\n    }\n}\n\nsigned main() {\n    cin >> n;\n    rep (i, 3) {\n        G[i].resize(n);\n        int m;\n        cin >> m;\n        rep (j, m) {\n            int u, v;\n            cin >> u >> v;\n            u--; v--;\n            G[i][u].push_back(v);\n            G[i][v].push_back(u);\n        }\n    }\n\n    rep (i, 3) {\n        solve(i, G[i]);\n        // DEBUG(i);\n        // rep (j, 3) {\n        //     rep (k, num[i][j].size()) {\n        //         cout << num[i][j][k] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n    }\n\n    ll base = mod_pow(10, 18);\n    vll sum(3, vl(1000));\n    rep (i, 3) {\n        rep (j, 1000) {\n            for (int u: num[i][j]) {\n                (sum[i][j] += mod_pow(base, u + 1)) %= MOD;\n            }\n        }\n    }\n\n    ll ans = 0;\n    rep (x, 1000) {\n        rep (y, 1000) {\n            int z = x ^ y;\n            if (z >= 1000) continue;\n            ll mul2 = sum[2][z];\n            ll mul1 = sum[1][y];\n            ll mul0 = sum[0][x];\n            (ans += mul0 * mul1 % MOD * mul2 % MOD) %= MOD;\n            // if (mul0 * mul1 % MOD * mul2 % MOD != 0) {\n            //     DEBUG_VEC(vi({z, y, x}));\n            //     DEBUG_VEC(vl({mul2, mul1, mul0}));\n            // }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tconst ll MOD=998244353;\n\tll w[100010];\n\tw[0]=1, w[1]=1000000000000000000ll%MOD;\n\tfor(int i=2; i<=n; i++) w[i]=w[i-1]*w[1]%MOD;\n\tint m[3];\n\tvector<ll> c[3];\n\tfor(int t=0; t<3; t++){\n\t\tcin>>m[t];\n\t\tvector<vector<int>> g(n);\n\t\tvector<int> v(n);\n\t\tfor(int i=0; i<m[t]; i++){\n\t\t\tint x, y; cin>>x>>y; x--; y--;\n\t\t\tif(x>y) swap(x, y);\n\t\t\tg[x].push_back(y);\n\t\t}\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tset<int> st;\n\t\t\tfor(auto y:g[i]){\n\t\t\t\tst.insert(v[y]);\n\t\t\t}\n\t\t\tfor(int k=0; ; k++){\n\t\t\t\tif(st.find(k)==st.end()){\n\t\t\t\t\tv[i]=k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mx=0;\n\t\tfor(int i=0; i<n; i++) mx=max(mx, v[i]);\n\t\tc[t].resize(mx+1);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tc[t][v[i]]+=w[i+1];\n\t\t\tif(c[t][v[i]]>=MOD) c[t][v[i]]-=MOD;\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0; i<c[0].size(); i++){\n\t\tfor(int j=0; j<c[1].size(); j++){\n\t\t\tint k=(i^j);\n\t\t\tif(k>=c[2].size()) continue;\n\t\t\t(ans+=c[0][i]*c[1][j]%MOD*c[2][k])%=MOD;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>   \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 100000;\nconst int MOD = 998244353;\nconst ll BASE = 1000000000000000000LL;\nvoid inc(int &a, int b) { if ((a += b) >= MOD) a -= MOD; }\n\nstruct G {\n\tint n;\n\tvector<int> adj[MAXN];\n\tint level[MAXN];\n\tint seenby[MAXN];\n\n\tvoid init(int _n) { n = _n; REP(i, n) adj[i].clear(); }\n\tvoid calc() {\n\t\tREP(i, n) seenby[i] = -1;\n\t\tfor (int at = n - 1; at >= 0; --at) {\n\t\t\tREPSZ(i, adj[at]) {\n\t\t\t\tint to = adj[at][i]; if (to <= at) continue;\n\t\t\t\tseenby[level[to]] = at;\n\t\t\t}\n\t\t\tlevel[at] = 0; while (seenby[level[at]] == at) ++level[at];\n\t\t}\n\t\t//printf(\"level:\"); REP(i, n) printf(\" %d\", level[i]); puts(\"\");\n\t}\n};\n\n\nint n;\nG g[3];\nint basepw[MAXN + 1];\n\nint solve() {\n\tREP(i, 3) g[i].calc();\n\tint mxlevel = 0; REP(i, 3) REP(j, n) mxlevel = max(mxlevel, g[i].level[j]);\n\tint mxbit = 0; while (mxlevel >= (2 << mxbit)) ++mxbit;\n\tvector<int> ways(2 << mxbit, 0);\n\tinc(ways[0], 1);\n\tbasepw[0] = 1; basepw[1] = BASE%MOD; FORE(i, 2, n) basepw[i] = (ll)basepw[i - 1] * basepw[1] % MOD;\n\tREP(i, 3) {\n\t\tvector<int> nways(2 << mxbit, 0);\n\t\tvector<int> sum(mxlevel + 1, 0); REP(j, n) inc(sum[g[i].level[j]], basepw[j + 1]);\n\t\tREPSZ(a, ways) REPSZ(b, sum) nways[a^b] = (nways[a^b] + (ll)ways[a] * sum[b]) % MOD;\n\t\tways = nways;\n\t}\n\treturn ways[0];\n}\n\nvoid run() {\n\tscanf(\"%d\", &n);\n\tREP(i, 3) {\n\t\tint m; scanf(\"%d\", &m);\n\t\tg[i].init(n);\n\t\tREP(j, m) { int a, b; scanf(\"%d%d\", &a, &b); --a, --b; g[i].adj[a].PB(b); g[i].adj[b].PB(a); }\n\t}\n\tprintf(\"%d\\n\", solve());\n}\n\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\nnamespace dfcmd {\n\n    typedef long long LL;\n\n    const int maxn = 100005;\n    const int mod = 998244353;\n    const int di = 1000000000000000000LL % mod;\n    \n    int bin[maxn * 3];\n    \n    inline void add(int& x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    int n;\n\n    struct myhnb {\n        int m;\n        int sg[maxn];\n        int ss[maxn];\n\n        struct Edge {\n            int to, nxt;\n        } e[maxn];\n\n        int first[maxn];\n\n        inline void add_edge(int u, int v) {\n            static int cnt = 0;\n            if (u > v) {\n                swap(u, v);\n            }\n            e[++cnt].nxt = first[u];\n            first[u] = cnt;\n            e[cnt].to = v;\n        }\n        \n        int vis[maxn];\n\n        myhnb() {\n            memset(first, 0, sizeof(first));\n            memset(ss, 0, sizeof(ss));\n            memset(vis, 0, sizeof(vis));\n        }\n    \n        inline void dfs(int now) {\n            vis[now] = true;\n            set<int> sgg;\n            sgg.clear();\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!vis[to]) {\n                    dfs(to);\n                }\n                sgg.insert(sg[to]);\n            }\n            sg[now] = 0;\n            while (sgg.count(sg[now])) {\n                sg[now]++;\n            }\n//            cout << \"alb \" << now << ' ' << sg[now] << ' ' << bin[now] << endl;\n            add(ss[sg[now]], bin[now]);\n        }\n        \n        inline void Dfs() {\n            for (int i = 1; i <= n; ++i) {\n                if (!vis[i]) {\n                    dfs(i);\n                }\n            }\n        }\n        \n        inline int& operator [] (int x) {\n            return ss[x];\n        }\n    } d[3];\n\n    int main() {\n        read(n);\n        bin[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            bin[i] = (LL) bin[i - 1] * di % mod;\n        }\n        for (int i = 0; i < 3; ++i) {\n            read(d[i].m);\n            for (int j = 1; j <= d[i].m; ++j) {\n                int u, v;\n                read(u), read(v);\n                d[i].add_edge(u, v);\n            }\n            d[i].Dfs();\n//            cout << \"sg = \";\n//            for (int j = 1; j <= n; ++j) {\n//                cout << d[i].sg[j] << ' ';\n//            }\n//            cout << endl;\n        }\n        int ans = 0;\n        for (int i = 0; i <= 1000; ++i) {\n            for (int j = 0; j <= 1000; ++j) {\n                add(ans, (LL) d[0][i] * d[1][j] % mod * d[2][i ^ j] % mod);\n            }\n        }\n        writeln(ans);\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,mmx,avx\")\n#include \"bits/stdc++.h\"\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\nconst int MOD=998244353;\n#define endl \"\\n\"\n#define fst first\n#define snd second\nconst int UNDEF = -1;\nconst int INF=1<<30;\ntemplate<typename T> inline bool chkmax(T &aa, T bb) { return aa < bb ? aa = bb, true : false; }\ntemplate<typename T> inline bool chkmin(T &aa, T bb) { return aa > bb ? aa = bb, true : false; }\ntypedef pair<ll,ll> pll;typedef vector<ll> vll;typedef pair<int,int> pii;typedef vector<int> vi;typedef vector<vi> vvi;\n#ifdef ONLINE_JUDGE\n#define assert(...) /* nothing */\n#endif\n#define DEBUG_CAT\n#ifdef DEBUG_CAT\n#define dbg(...)   printf( __VA_ARGS__ )\n#else \n#define dbg(...)   /****nothing****/\n#endif\nint rint();char rch();long long rlong();\n// mt19937 rng; rng.seed(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n// template<typename T> int bins(vector<T> &v, T key) {int imin=0,imax=v.size();while(imin<imax) {int imid=(imin+imax)>>1;if (v[imid]<key) imin=imid+1;else imax=imid;}return imin;}\n\nstruct mint {\n  unsigned x;\n  inline int _norm(int x) {\n    if (x<0) x+=MOD;\n    return x;\n  }\n  mint() : x(0) {}\n  mint(signed sig) {sig=_norm(sig); x=sig;}\n  mint(signed long long sig) {sig=_norm(sig%MOD); x=sig;}\n  int get() const { return (int)x; }\n \n  mint &operator+=(mint that) { if((x += that.x) >= MOD) x -= MOD; return *this; }\n  mint &operator-=(mint that) { if((x += MOD - that.x) >= MOD) x -= MOD; return *this; }\n  mint &operator*=(mint that) { x = ((unsigned long long)x * that.x) % MOD; return *this; }\n  mint &operator/=(mint that) { return *this *= that.inverse(); }\n\n  mint &operator+=(int that) {that=_norm(that); if((x += that) >= MOD) x -= MOD; return *this; }\n  mint &operator-=(int that) {that=_norm(that); if((x += MOD - that) >= MOD) x -= MOD; return *this; }\n  mint &operator*=(int that) {that=_norm(that); x = ((unsigned long long)x * that) % MOD; return *this; }\n  mint &operator/=(int that) {that=_norm(that); return *this *= mint(that).inverse(); }\n\n  mint operator+(mint that) const { return mint(*this) += that; }\n  mint operator-(mint that) const { return mint(*this) -= that; }\n  mint operator*(mint that) const { return mint(*this) *= that; }\n  mint operator/(mint that) const { return mint(*this) /= that; }\n\n  mint operator+(int that) const { return mint(*this) += that; }\n  mint operator-(int that) const { return mint(*this) -= that; }\n  mint operator*(int that) const { return mint(*this) *= that; }\n  mint operator/(int that) const { return mint(*this) /= that; }\n\n\n  mint inverse() const {\n    signed a = x, b = MOD, u = 1, v = 0;\n    while(b) {\n      signed t = a / b;\n      a -= t * b; std::swap(a, b);\n      u -= t * v; std::swap(u, v);\n    }\n    if(u < 0) u += MOD;\n    mint res; res.x = (unsigned)u;\n    return res;\n  }\n \n  bool operator==(mint that) const { return x == that.x; }\n  bool operator!=(mint that) const { return x != that.x; }\n  mint operator-() const { mint t; t.x = x == 0 ? 0 : MOD - x; return t; }\n  mint operator^(unsigned long long k) const {\n    // 0^0 is 1. k must be taken modulo phi(MOD) (MOD-1 if prime) and NOT MOD itself\n    mint a=(*this);\n    mint r = 1;\n    while(k) {\n      if(k & 1) r *= a;\n      a *= a;\n      k >>= 1;\n    }\n    return r;\n  }\n};\n\nint mex(vi a) {\n  int n=a.size();\n  for (int p=0;p<n;p++) {\n    while(a[p]!=p) {\n      int v=a[p];\n      if (0<=v && v<n && a[v]!=v) {\n        swap(a[p],a[v]);\n      } else {\n        break;\n      }\n    }\n  }\n  for (int p=0;p<n;p++) {\n    if (a[p]!=p) return p;\n  }\n  return n;\n}\n\nvector<mint> pten;\nvector<mint> getnim(int n) {\n  int m; cin>>m;\n  vvi g(n+1);\n  for (int k=0;k<m;k++) {\n    int a,b; cin>>a>>b;\n    if (a>b) swap(a,b);\n    g[a].PB(b);\n  }\n  vi nim(n+1);\n  nim[n]=0;\n  for (int x=n-1;x>=1;x--) {\n    vi v; for (auto &y:g[x]) v.PB(nim[y]);\n    nim[x]=mex(v);\n  }\n  int maxnim=0;\n  for (auto &w:nim) chkmax(maxnim,w);\n  vector<mint> a(maxnim+1);\n  for (int x=1;x<=n;x++) {\n    a[nim[x]]+=pten[x];\n  }\n  return a;\n}\nint ilog2(int x) {return 31-__builtin_clz(x);}\nvoid rst(vector<mint> & f) {\n  for (auto &w:f) w=0;\n}\nint main() \n{\n  int n; cin>>n;\n  pten.resize(n+1);\n  pten[0]=1;\n  int ten=(1000000000000000000LL % MOD);\n  for (int x=1;x<=n;x++) pten[x]=pten[x-1]*ten;\n  vector<mint> a[3];\n  int maxnim=0;\n  for (int k=0;k<3;k++) {\n    a[k]=getnim(n);\n    chkmax(maxnim, (int)a[k].size());\n  }\n  maxnim = 1<<(1+ilog2(maxnim-1));\n  for (int k=0;k<3;k++) a[k].resize(maxnim);\n  vector<mint> f[2];\n  for (int k=0;k<2;k++) f[k].resize(maxnim);\n  int cur=0,nxt=1;\n  f[cur]=a[0];\n  for (int k=1;k<3;k++) {\n    rst(f[nxt]);\n    for (int x=0;x<maxnim;x++) {\n      mint now=f[cur][x];\n      if (now.get()) {\n        if (k==2) {\n          f[nxt][0]+=now * a[k][x];\n        } else {\n          for (int y=0;y<maxnim;y++) {\n            f[nxt][x^y]+=now * a[k][y];\n          }\n        }\n      }\n    }\n    swap(cur,nxt);\n  }\n  mint ans=f[cur][0];\n  printf(\"%d\\n\",ans.get());\n}\n\n/*\nint mex2(vi a) {\n  sort(a.begin(),a.end());\n  int ans=0;\n  for (auto &w:a) {\n    if (w==ans) ++ans;\n  }\n  return ans;\n}\nvoid bf() {\n  int n=1+rand()%7;\n  vi a(n);\n  for (int x=0;x<n;x++) {\n    a[x]=(rand()%10)-4;\n  }\n  int ans1=mex(a);\n  int ans2=mex2(a);\n  if (ans1!=ans2) {\n    for (auto &w:a) printf(\"%d \",w);\n    printf(\"\\nsmart:%d bf:%d\\n\",ans1,ans2);\n    exit(1);\n  }\n}\n  srand(time(0));\n  for (int k=0;k<10000000;k++) {\n    bf();\n  }\n  printf(\"OK\\n\");\n*/\n\n\n\n\nstatic char stdinBuffer[1024];\nstatic char* stdinDataEnd = stdinBuffer + sizeof (stdinBuffer);\nstatic const char* stdinPos = stdinDataEnd;\n\nvoid readAhead(size_t amount)\n{\n    size_t remaining = stdinDataEnd - stdinPos;\n    if (remaining < amount) {\n       memmove(stdinBuffer, stdinPos, remaining);\n       size_t sz = fread(stdinBuffer + remaining, 1, sizeof (stdinBuffer) - remaining, stdin);\n       stdinPos = stdinBuffer;\n       stdinDataEnd = stdinBuffer + remaining + sz;\n       if (stdinDataEnd != stdinBuffer + sizeof (stdinBuffer))\n         *stdinDataEnd = 0;\n    }\n}\n\nint rint()\n{\n    readAhead(16);\n\n    int x = 0;\n    bool neg = false;\n    while(*stdinPos==' '||*stdinPos=='\\n') ++stdinPos;\n    if (*stdinPos == '-') {\n       ++stdinPos;\n       neg = true;\n    }\n\n    while (*stdinPos >= '0' && *stdinPos <= '9') {\n       x *= 10;\n       x += *stdinPos - '0';\n       ++stdinPos;\n    }\n\n    return neg ? -x : x;\n}\nchar rch()\n{\n    readAhead(16);\n    while(*stdinPos==' '||*stdinPos=='\\n') ++stdinPos;\n    char ans=*stdinPos;\n    ++stdinPos;\n    return ans;\n}\nlong long rlong()\n{\n    readAhead(32);\n\n    long long x = 0;\n    bool neg = false;\n    while(*stdinPos==' '||*stdinPos=='\\n') ++stdinPos;\n    if (*stdinPos == '-') {\n       ++stdinPos;\n       neg = true;\n    }\n\n    while (*stdinPos >= '0' && *stdinPos <= '9') {\n       x *= 10;\n       x += *stdinPos - '0';\n       ++stdinPos;\n    }\n\n    return neg ? -x : x;\n}"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\n\n\nint xy[410][410],xz[410][410],yz[410][410];\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vector<int> d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,310000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g1[i]){\n            if(e>i)se.insert(d1[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d1[i]=gr;\n        D1[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g2[i]){\n            if(e>i)se.insert(d2[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d2[i]=gr;\n        D2[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g3[i]){\n            if(e>i)se.insert(d3[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d3[i]=gr;\n        D3[gr] += P[i];\n    }\n    vec a,b;\n    mint ans;\n    int k1=0,k2=0,k3=0;\n    rep(i,400){\n        rep(j,400){\n            rep(k,400){\n                if(i>=n or j>=n or k>=n)break;\n                if(xy[i][j]==0 and xz[i][k]==0 and yz[j][k]==0) {\n                    ans+=D1[i]*D2[j]*D3[k];\n                    xy[i][j]=1;\n                    xz[i][k]=1;\n                    yz[j][k]=1;\n                } \n            }\n        }\n    }\n\n    cout<<ans.a<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 100010\n#define maxm 500010\n#define inf 1000000007\n#define mod 998244353\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n;\nvector<int>e[3][maxn];\nint val[maxn],sg[3][maxn],f[3][maxn];\nint main()\n{\n    n=read();\n    val[0]=1;\n    int base=(int)(1000000000000000000ll%mod);\n    for(int i=1;i<=n;i++)  val[i]=1ll*val[i-1]*base%mod;\n    for(int i=0;i<3;i++)\n    {\n        int m=read();\n        while(m--)\n        {\n            int u=read(),v=read();\n            if(u<v)  e[i][u].push_back(v);\n            else     e[i][v].push_back(u);\n        }\n        for(int j=n;j>=1;j--)\n        {\n            if(e[i][j].size())\n            {\n                set<int>s;\n                for(int k=0;k<e[i][j].size();k++)  s.insert(sg[i][e[i][j][k]]);\n                while(s.count(sg[i][j]))  sg[i][j]++;\n            }\n        }\n        for(int j=1;j<=n;j++)  f[i][sg[i][j]]=(f[i][sg[i][j]]+val[j])%mod;\n    }\n    int ans=0;\n    for(int i=0;i<500;i++)\n      for(int j=0;j<500;j++)  ans=(ans+1ll*f[0][i]*f[1][j]%mod*f[2][i^j])%mod;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int S = 500, SSS = S * S * S, N = 1e5 + 5, mod = 998244353;\n \nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n \nconst int base = powmod(10, 18);\n \nbitset<SSS> vis;\n \nint pos(int a, int b, int c) {\n  return ((a * S) + b) * S + c;\n}\n \ntuple<int, int, int> decod(int v) {\n  int c = v % S;\n  v /= S;\n  int b = v % S;\n  v /= S;\n  return make_tuple(v, b, c);\n}\n \nvector<int> g[N];\n \nvector<pair<int, int>> independent(int n, vector<pair<int ,int>> & edges) {\n  for (int i = 0; i < n; ++i)\n    g[i].clear();\n  for (auto e : edges) {\n    g[e.first].push_back(e.second);\n    g[e.second].push_back(e.first);\n  }\n  vector<bool> done(n, false), mark(n);\n  int cnt = 0;\n  vector<pair<int, int>> res;\n  while (cnt < n) {\n    mark = done;\n    int hig = -1, sum = 0;\n    for (int v = n-1; v >= 0; --v) {\n      if (mark[v]) continue;\n      ++cnt;\n      done[v] = 1;\n      hig = max(hig, v+1);\n      sum = (sum + powmod(base, v+1)) % mod;\n      for (int u : g[v]) {\n        mark[u] = 1;\n      }\n    }\n    res.emplace_back(hig, sum);\n  }\n  return res;\n}\n \nvector<pair<int, int>> read_edges() {\n  int m;\n  scanf(\"%d\", &m);\n  vector<pair<int, int>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &edges[i].first, &edges[i].second);\n    --edges[i].first;\n    --edges[i].second;\n  }\n  return edges;\n}\n \nint main() {\n  auto start_t = clock();\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> ex = read_edges();\n  vector<pair<int, int>> ey = read_edges();\n  vector<pair<int, int>> ez = read_edges();\n  vector<pair<int, int>> rx = independent(n, ex);\n  vector<pair<int, int>> ry = independent(n, ey);\n  vector<pair<int, int>> rz = independent(n, ez);\n  assert(rx.size() < S);\n  assert(ry.size() < S);\n  assert(rz.size() < S);\n  vector<vector<bool>> xy(rx.size(), vector<bool>(ry.size(), false));\n  vector<vector<bool>> xz(rx.size(), vector<bool>(rz.size(), false));\n  vector<vector<bool>> yz(ry.size(), vector<bool>(rz.size(), false));\n  priority_queue<pair<int, int>> pq;\n  auto insert_node = [&](int i, int j, int k) {\n    if (i >= (int)rx.size() || j >= (int)ry.size() || k >= (int)rz.size())\n      return;\n    int now = pos(i, j, k);\n    if (vis[now])\n      return;\n    pq.emplace(rx[i].first + ry[j].first + rz[k].first, now);\n    vis[now] = 1;\n  };\n  insert_node(0, 0, 0);\n  long long ans = 0;\n  while (!pq.empty() && (double)(clock() - start_t) / CLOCKS_PER_SEC < 1.8) {\n    auto it = pq.top();\n    pq.pop();\n    int i, j, k;\n    tie(i, j, k) = decod(it.second);\n    insert_node(i+1, j, k);\n    insert_node(i, j+1, k);\n    insert_node(i, j, k+1);\n    if (xy[i][j] || xz[i][k] || yz[j][k]) continue;\n    long long cur = rx[i].second * (long long) ry[j].second % mod;\n    cur = cur * rz[k].second % mod;\n    ans = (ans + cur) % mod;\n    xy[i][j] = 1;\n    xz[i][k] = 1;\n    yz[j][k] = 1;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int maxn=100010,mod=998244353,w=1000000000000000000%mod;\n#define MP make_pair\n#define PB push_back\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline ll read(){\n\tchar ch=getchar();ll x=0,f=0;\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\ninline int qmo(int x){return x+(x>>31)*mod;}\nint n,m,sq[3],sg[3][maxn],sum[3][maxn],cnt[maxn],el,head[maxn],to[maxn],nxt[maxn],pw[maxn],ans;\ninline void add(int u,int v){\n\tto[++el]=v;nxt[el]=head[u];head[u]=el;\n}\nint main(){\n\tn=read();\n\tpw[0]=1;\n\tFOR(i,1,n) pw[i]=1ll*pw[i-1]*w%mod;\n\tFOR(_,0,2){\n\t\tm=read();\n\t\tsq[_]=sqrt(2*m);\n\t\tFOR(i,1,m){\n\t\t\tint u=read(),v=read();\n\t\t\tif(u>v) swap(u,v);\n\t\t\tadd(u,v);\n\t\t}\n\t\tROF(i,n,1){\n\t\t\tfor(int j=head[i];j;j=nxt[j]) cnt[sg[_][to[j]]]++;\n\t\t\twhile(cnt[sg[_][i]]) sg[_][i]++;\n\t\t\tfor(int j=head[i];j;j=nxt[j]) cnt[sg[_][to[j]]]--;\n\t\t}\n\t\tFOR(i,1,n) sum[_][sg[_][i]]=(sum[_][sg[_][i]]+pw[i])%mod;\n\t\tFOR(i,1,n) head[i]=0;\n\t\tFOR(i,1,el) to[i]=nxt[i]=0;\n\t\tel=0;\n\t}\n\tFOR(i,0,sq[0]) FOR(j,0,sq[1]) ans=(ans+1ll*sum[0][i]*sum[1][j]%mod*sum[2][i^j])%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// C.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 200, mod = 998244353;\n\ntypedef long long ll;\n\nint n, m[3], base, vis[MAX_N], sg[MAX_N];\nvector<int> G[MAX_N], sum[3];\n\nint fpow(int bas, int tim)\n{\n    int ret = 1;\n    while (tim)\n    {\n        if (tim & 1)\n            ret = 1LL * ret * bas % mod;\n        bas = 1LL * bas * bas % mod;\n        tim >>= 1;\n    }\n    return ret;\n}\n\nint main()\n{\n    scanf(\"%d\", &n), base = fpow(ll(1e18) % mod, mod - 2);\n    for (int rd = 0; rd < 3; rd++)\n    {\n        scanf(\"%d\", &m[rd]);\n        for (int i = 1; i <= n; i++)\n            G[i].clear();\n        for (int i = 1, u, v; i <= m[rd]; i++)\n        {\n            scanf(\"%d%d\", &u, &v);\n            if (u > v)\n                swap(u, v);\n            G[u].push_back(v);\n        }\n        memset(sg, 0, sizeof(sg)), memset(vis, -1, sizeof(vis));\n        int cbase = fpow(10, 18 * n);\n        for (int i = n; i >= 1; i--)\n        {\n            for (int v : G[i])\n                vis[sg[v]] = i;\n            while (vis[sg[i]] == i)\n                sg[i]++;\n            while (sum[rd].size() <= sg[i])\n                sum[rd].push_back(0);\n            sum[rd][sg[i]] = (0LL + sum[rd][sg[i]] + cbase) % mod, cbase = 1LL * cbase * base % mod;\n        }\n    }\n    int ans = 0;\n    for (int i = 0, siz1 = sum[0].size(); i < siz1; i++)\n        for (int j = 0, siz2 = sum[1].size(); j < siz2; j++)\n        {\n            int k = i ^ j;\n            if (k < sum[2].size())\n                ans = (0LL + ans + 1LL * sum[0][i] * sum[1][j] % mod * sum[2][k] % mod) % mod;\n        }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 998244353;\nconst int N = 1e5+7;\nconst long long B = 1000000000000000000;\ntypedef long long LL;\n\nLL pb[N];\nvoid pre() {\n    pb[0] = 1;\n    LL b = B%M;\n    for (int i=1; i<N; i++)\n        pb[i] = (pb[i-1]*b)%M;\n}\n\nvector<int> bfs(vector<vector<int>>adj) {\n    int n = adj.size()-1;\n    vector<int> col(n+1, N);\n\n    vector<bool> vis(n);\n    for (int i=n; i>0; i--) {\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 1;\n        }\n\n        for (int ii=0; ii<=n; ii++)\n            if (!vis[ii]) {\n                col[i] = ii;\n                break;\n            }\n\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 0;\n        }\n    }\n    return col;\n}\n\nint m[3];\nvector<vector<int>> adj[3];\nvector<int> dis[3];\nvector<LL> con[3];\n\nLL power(LL a, LL p) {\n    if (p == 0) return 1;\n    LL ans = power(a, p/2);\n    ans = (ans * ans)%M;\n    if (p%2)    ans = (ans * a)%M;\n    return ans;\n}\n\nvoid FWHT(vector< LL >&p, bool inverse) {\n    int n = p.size();\n    assert((n&(n-1))==0);\n\n    for (int len = 1; 2*len <= n; len <<= 1) {\n        for (int i = 0; i < n; i += len+len) {\n            for (int j = 0; j < len; j++) {\n                LL u = p[i+j];\n                LL v = p[i+len+j];\n                p[i+j] = u+v;\n                if (p[i+j] >= M)    p[i+j] -= M;\n                p[i+len+j] = u-v;\n                of (p[i+len+j] < 0) p[i+len+j] += M;\n            }\n        }\n    }\n    if (inverse) {\n        LL inv = power(n, M-2);\n        for (int i = 0; i < n; i++) {\n            p[i] = (p[i] * inv)%M;\n        }\n    }\n}\n\nint main() {\n    pre();\n\n    int n;\n    cin>>n;\n    const int MX = 1<<17;\n\n    for (int g=0; g<3; g++) {\n        cin>>m[g];\n        adj[g].resize(n+1);\n        for (int i=0; i<m[g]; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[g][u].push_back(v);\n            adj[g][v].push_back(u);\n        }\n        dis[g] = bfs(adj[g]);\n\n        con[g].resize(MX);\n        for (int i=1; i<=n; i++) {\n            con[g][dis[g][i]] = (con[g][dis[g][i]] + pb[i])%M;\n        }\n    }\n\n    vector<LL> ans(MX,1);\n    for (int g=0; g<3; g++) {\n        FWHT(con[g], false);\n        for (int i=0; i<MX; i++)\n            ans[i] = (ans[i] * con[g][i])%M;\n    }\n\n    FWHT(ans, true);\n    cout<<ans[0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define maxn 100005 /*rem*/\n#define mod 998244353\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\nusing namespace std;\nint n;\nll qs = 1; \nll pw[maxn];\nint fl[maxn];\nvi eg[maxn];\nint main() {\n\tfor (int i = 0; i < 18; i++) qs *= 10;\n\tqs %= mod;\n\tpw[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tpw[i] = pw[i - 1] * qs % mod;\n\tint n;\n\tcin >> n;\n\tll mt = 1;\n\tvector<ll> c[3];\n\tfor (int s = 0; s < 3; s++) {\n\t\tint m;\n\t\tcin >> m;\n\t\tfor (int i = 1; i <= n; i++) eg[i].clear();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\teg[u].pb(v), eg[v].pb(u);\n\t\t}\n\t\tset<int> x;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tx.insert(i);\n\t\twhile (1) {\n\t\t\tll cu = 0;\n\t\t\tif (!x.size()) break;\n\t\t\tset<int> y;\n\t\t\twhile (x.size()) {\n\t\t\t\tint r = *(--x.end());\n\t\t\t\tcu = (cu + pw[r]) % mod;\n\t\t\t\tx.erase(r);\n\t\t\t\tfor (auto v : eg[r]) {\n\t\t\t\t\tif (x.find(v) != x.end()) {\n\t\t\t\t\t\ty.insert(v);\n\t\t\t\t\t\tx.erase(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\t\t\tc[s].pb(cu);\n\t\t\tx = y;\n\t\t}\n\t}\n\tll ans = c[0][0] * c[1][0] % mod * c[2][0] % mod;\n\tfor (int i = 0; i < 3; i++) {\n\t\tint u = (i + 1) % 3, v = (i + 2) % 3;\n\t\tfor (int k = 1; k < min(c[u].size(), c[v].size()); k++) {\n\t\t\tll cur = c[i][0] * c[u][k] % mod * c[v][k] % mod;\n\t\t\tans = (ans + cur) % mod;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\n#define MP make_pair\n#define fi first\n#define se second\n#define PB push_back\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\nconst int N = 100003, M = 1024, mod = 998244353;\ntemplate<typename T>\nvoid read(T &x){\n\tint ch = getchar(); x = 0; bool f = false;\n\tfor(;ch < '0' || ch > '9';ch = getchar()) f |= ch == '-';\n\tfor(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';\n\tif(f) x = -x;\n}\nvoid qmo(int &x){x += (x >> 31) & mod;}\nint ksm(int a, int b){\n\tint res = 1;\n\tfor(;b;b >>= 1, a = (LL) a * a % mod) if(b & 1) res = (LL) res * a % mod;\n\treturn res;\n}\ntemplate<typename T>\ninline bool chmax(T &a, const T &b){if(a < b) return a = b, 1; return 0;}\ntemplate<typename T>\ninline bool chmin(T &a, const T &b){if(a > b) return a = b, 1; return 0;}\nint n, m, head[N], to[N], nxt[N], cnt, f[3][M], sg[N], pw[N], ans; bool vis[N];\nvoid add(int a, int b){\n\tstatic int cnt = 0;\n\tto[++ cnt] = b; nxt[cnt] = head[a]; head[a] = cnt;\n}\nvoid solve(int t){\n\tcnt = 0; read(m);\n\tfor(Rint i = 1;i <= n;++ i) head[i] = sg[i] = 0;\n\tfor(Rint i = 1, u, v;i <= m;++ i){\n\t\tread(u); read(v); if(u > v) swap(u, v); add(u, v);\n\t}\n\tfor(Rint i = n;i;-- i){\n\t\tfor(Rint j = head[i];j;j = nxt[j]) vis[sg[to[j]]] = true;\n\t\tfor(;vis[sg[i]];++ sg[i]); qmo(f[t][sg[i]] += pw[i] - mod);\n\t\tfor(Rint j = head[i];j;j = nxt[j]) vis[sg[to[j]]] = false;\n\t}\n}\nint main(){\n\tread(n); pw[0] = 1; pw[1] = 716070898;\n\tfor(Rint i = 2;i <= n;++ i) pw[i] = (LL) pw[i-1] * pw[1] % mod;\n\tfor(Rint t = 0;t < 3;++ t) solve(t);\n\tfor(Rint i = 0;i < M;++ i)\n\t\tfor(Rint j = 0;j < M;++ j)\n\t\t\tqmo(ans += (LL) f[0][i] * f[1][j] % mod * f[2][i^j] % mod - mod);\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nconstexpr int P = 998244353 , V = 1000000000000000000 % P, INV2 = (P + 1) / 2;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n;\n    std::cin >> n;\n    std::vector<int> f{1};\n    auto work = [&]() {\n        std::vector<std::vector<int>> e(n);\n        std::vector<int> c(n);\n        int m;\n        std::cin >> m;\n        for (int i = 0; i < m; ++i) {\n            int u, v;\n            std::cin >> u >> v;\n            --u;\n            --v;\n            if (u > v)\n                std::swap(u, v);\n            e[u].push_back(v);\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            std::vector<bool> vis(e[i].size() + 1);\n            for (int v : e[i])\n                if (c[v] <= int(e[i].size()))\n                    vis[c[v]] = true;\n            while (vis[c[i]])\n                ++c[i];\n        }\n        std::vector<int> g;\n        for (int i = 0, j = V; i < n; ++i, j = 1ll * j * V % P) {\n            if (c[i] >= int(g.size()))\n                g.resize(c[i] + 1);\n            g[c[i]] = (g[c[i]] + j) % P;\n        }\n        std::vector<int> h;\n        for (int i = 0; i < int(f.size()); ++i) {\n            for (int j = 0; j < int(g.size()); ++j) {\n                if ((i ^ j) >= int(h.size()))\n                    h.resize((i ^ j) + 1);\n                h[i ^ j] = (h[i ^ j] + 1ll * f[i] * g[j]) % P;\n            }\n        }\n        f = h;\n    };\n    work();\n    work();\n    work();\n    std::cout << f[0] << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\nconst int   mod = 998244353;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\n\ntypedef pair<int,int>   ii;\ntypedef vector<int>     vi;\n\nvector<int> g[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    auto calc = [&]()   {\n        int m;  cin >> m;\n\n        set<int> S;\n        set<int> R;\n\n        for(int i = 1 ; i <= n ; ++i)   {\n            g[i].clear();\n            S.insert(i);\n        }\n        for(int i = 1 ; i <= m ; ++i)   {\n            int x;  cin >> x;\n            int y;  cin >> y;\n\n            g[x].pb(y);\n            g[y].pb(x);\n        }\n        vector<int> res;\n\n        while (S.size() || R.size())    {\n            int val = 0;\n\n            while (S.size())    {\n                int x = (*S.rbegin());\n                S.erase(x);\n\n                add(val,Pow(10,18 * x));\n\n                for(int u : g[x])\n                    if (S.count(u)) {\n                        S.erase(u);\n                        R.insert(u);\n                    }\n            }\n            res.pb(val);\n            S.swap(R);\n        }\n        return  res;\n    };\n    vector<int> v1 = calc();\n    vector<int> v2 = calc();\n    vector<int> v3 = calc();\n\n    int S = 0;\n\n    S = max(S,sz(v1));\n    S = max(S,sz(v2));\n    S = max(S,sz(v3));\n\n    v1.resize(S);\n    v2.resize(S);\n    v3.resize(S);\n\n    vector<vi>  ok(S,vi(S,1));\n\n    int ans = 0;\n\n    for(int i = 0 ; i < S ; ++i)    {\n        vector<bool> used(S,0);\n\n        for(int j = 0 ; j < S ; ++j)\n        for(int k = 0 ; k < S ; ++k)    if (ok[j][k] && !used[k])   {\n            int val = 1;\n            val = mul(val,v3[i]);\n            val = mul(val,v2[j]);\n            val = mul(val,v1[k]);\n\n            add(ans,val);\n\n            ok[j][k] = 0;\n            used [k] = 1;\n            break;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 998244353\nusing namespace std;\nint read()\n{\n\tchar c=0;\n\tint sum=0;\n\twhile (c<'0'||c>'9')\n\t\tc=getchar();\n\twhile ('0'<=c&&c<='9')\n\t\tsum=sum*10+c-'0',c=getchar();\n\treturn sum; \n};\nstruct node\n{\n\tint v,nxt;\n};\nnode edge[3][2000001];\nlong long n,m,head[3][2000001],len[3],d[3],d2[3];\nlong long Base;\nbool used[3][2000001],vis[3][2000001];\nvoid add(int k,int x,int y)\n{\n\tedge[k][++len[k]].v=y,edge[k][len[k]].nxt=head[k][x],head[k][x]=len[k];\n\tedge[k][++len[k]].v=x,edge[k][len[k]].nxt=head[k][y],head[k][y]=len[k];\n\treturn;\n}\nlong long fast_pow(long long a,int b)\n{\n\tif (b==0)\n\t\treturn 1;\n\tif (b&1)\n\t\treturn fast_pow(a*a%mod,b/2)*a%mod;\n\telse\n\t\treturn fast_pow(a*a%mod,b/2); \n}\nvoid solve(int op,int k1,int k2)\n{\n\tfor (int i=1;i<=n;++i)\n\t\td[op]=d2[op]=(d[op]+k1*fast_pow(10,18*i)%mod)%mod;\n\tfor (int i=n;i>=1;--i)\n\t\tif (!vis[op][i])\n\t\t{\n\t\t\td[op]=(d[op]+fast_pow(10,18*i)*(k2-k1)%mod)%mod;\n\t\t\tfor (int j=head[op][i];j>0;j=edge[op][j].nxt)\n\t\t\t\tvis[op][edge[op][j].v]=1;\n\t\t}\n\tfor (int i=1;i<=n;++i)\n\t\tvis[op][i]=!vis[op][i];\n\tfor (int i=n;i>=1;--i)\n\t\tif (!vis[op][i])\n\t\t{\n\t\t\td2[op]=(d2[op]+fast_pow(10,18*i)*(k2-k1)%mod)%mod;\n\t\t\tfor (int j=head[op][i];j>0;j=edge[op][j].nxt)\n\t\t\t\tvis[op][edge[op][j].v]=1;\n\t\t}\n\treturn;\n}\nint main()\n{\n\tint x,y;\n\tn=read();\n\tfor (int op=0;op<=2;++op)\n\t{\n\t\tm=read();\n\t\tfor (int i=1;i<=m;++i) x=read(),y=read(),add(op,x,y);\n\t}\n\tsolve(0,0,1),solve(1,d2[0],d[0]),solve(2,d2[1],d[1]);\n\tprintf(\"%lld\\n\",(d[2]+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nlong long T=1000000000000000000LL%mod;\nvector<int>g[3][110000];\nint s[3];\nint f[3][110000];\nint f2[3][110000];\nint dp[3][110000];\nlong long gr[3][110000];\nint calc(int a,int b){\n\tif(dp[a][b]>=0)return dp[a][b];\n\tvector<int>t;\n\tfor(int i=0;i<g[a][b].size();i++){\n\t\tt.push_back(calc(a,g[a][b][i]));\n\t}\n\tstd::sort(t.begin(),t.end());\n\tint ret=0;\n\tfor(int i=0;i<t.size();i++){\n\t\tif(ret<t[i])break;\n\t\tif(ret==t[i])ret++;\n\t}\n\treturn dp[a][b]=ret;\n}\nlong long pT[110000];\nlong long key[3];\npair<int,int>q[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<3;i++)for(int j=0;j<a;j++)dp[i][j]=-1;\n\n\tpT[0]=1;\n\tfor(int i=1;i<110000;i++){\n\t\tpT[i]=pT[i-1]*T%mod;\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tscanf(\"%d\",&s[j]);\n\t\tfor(int i=0;i<s[j];i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\tif(p>q)swap(p,q);\n\t\t\tg[j][p].push_back(q);\n\t\t}\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint at=calc(j,i);\n\t\t\t// printf(\"%d %d: %d\\n\",j,i,at);\n\t\t\tgr[j][at]=(gr[j][at]+pT[i])%mod;\n\t\t}\n\t}\n\n\tlong long ret=0;\n\tint M=2*sqrt(a)+1;\n\tfor(int i=0;i<=M;i++){\n\t\tfor(int j=0;j<=M;j++)for(int k=0;k<=M;k++){\n\t\t\tif(i^j^k)continue;\n\t\t\tret=(ret+gr[0][i]*gr[1][j]%mod*gr[2][k])%mod;\n\t}}\n\n\tret=ret*T%mod;\n\tret=ret*T%mod;\n\tret=ret*T%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin>>N;    \n    vector<vector<int>> E[3];\n    for (int i=0; i<3; i++)\n    {\n        int M;\n        cin>>M;\n        E[i].resize(N);\n        for (int j=0; j<M; j++)\n        {\n            int a, b;\n            cin>>a>>b;\n            E[i][a-1].push_back(b-1);\n            E[i][b-1].push_back(a-1);\n        }\n    }\n\n    vector<int> G[3];\n    set<int> S;\n    for (int i=0; i<3; i++)\n    {\n        G[i] = vector<int>(N);\n        for (int j=N-1; j>=0; j--)\n        {\n            S.clear();\n            for (int e: E[i][j])\n                if (e>j)\n                    S.insert(G[i][e]);\n            for (int k=0; ; k++)\n                if (S.count(k)==0)\n                {\n                    G[i][j] = k;\n                    break;\n                }\n        }\n    }\n\n    long long M = 998244353LL;\n    vector<long long> P10(N+1);\n    P10[0] = 1;\n    for (int i=1; i<=N; i++)\n        P10[i] = P10[i-1]*(1000000000000000000%M)%M;\n\n    vector<long long> GS[3];\n    int MG[3];\n    for (int i=0; i<3; i++)\n    {\n        GS[i] = vector<long long>(N);\n        for (int j=0; j<N; j++)\n        {\n            GS[i][G[i][j]] += P10[j+1];\n            GS[i][G[i][j]] %= M;\n            MG[i] = max(MG[i], G[i][j]);\n        }\n    }\n\n    long long ans = 0;\n    for (int i=0; i<=MG[0]; i++)\n        for (int j=0; j<=MG[1]; j++)\n        {\n            int k = i^j;\n            if (k<=MG[2])\n            {\n                ans += GS[0][i]*GS[1][j]%M*GS[2][k]%M;\n                ans %= M;\n            }\n        }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Let's join Kaede Takagaki Fun Club !!\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define all(x) x.begin(),x.end()\ntemplate<class T>\nvoid dmp(T a){\n\trep(i,a.size()) cout << a[i] << \" \";\n\tcout << endl;\n}\ntemplate<class T>\nbool chmax(T&a, T b){\n\tif(a < b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nbool chmin(T&a, T b){\n\tif(a > b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nvoid g(T &a){\n\tcin >> a;\n}\ntemplate<class T>\nvoid o(const T &a,bool space=false){\n\tcout << a << (space?' ':'\\n');\n}\n//ios::sync_with_stdio(false);\nconst ll mod = 998244353;\ntemplate<class T>\nvoid add(T&a,T b){\n\ta+=b;\n\tif(a >= mod) a-=mod;\n}\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll b = 1000000000000000000LL%mod;\nint n;\nvector<ll>make(){\n\tint m; g(m);\n\tvector<vector<int>>adj(n);\n\trep(i,m){\n\t\tint a,b; g(a); g(b); a--; b--;\n\t\tadj[a].pb(b);\n\t\tadj[b].pb(a);\n\t}\n\tvector<int>num(n);\n\tfor(int i=n-1;i>=0;i--){\n\t\tset<int>S;\n\t\tfor(auto at:adj[i]){\n\t\t\tif(at > i) S.insert(num[i]);\n\t\t}\n\t\tfor(int v=0;;v++) if(S.find(v) == S.end()){\n\t\t\tnum[i] = v; \n\t\t\tbreak;\n\t\t}\n\t}\n\tvector<ll>ret(n);\n\trep(j,n){\n\t\tadd(ret[num[j]], modpow(b,j+1));\n\t}\n\twhile(ret.back() == 0) ret.pop_back();\n\treturn ret;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tg(n);\n\tvector<vector<ll>>gr;\n\trep(i,3){\n\t\tgr.pb(make());\n\t}\n\tll ans = 0;\n\trep(i,gr[0].size()){\n\t\trep(j,gr[1].size()){\n\t\t\tint k = (i^j);\n\t\t\tif(gr[2].size() > k){\n\t\t\t\tadd(ans, gr[0][i]*gr[1][j]%mod*gr[2][k]%mod);\n\t\t\t}\n\t\t}\n\t}\n\to(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define P 998244353\n#define B ((ll)1e18%P)\n#define MAX 500005\nusing namespace std;\n\nint n, m, cnt, id;\nint head[MAX], vet[MAX], Next[MAX], sg[3][MAX];\nll p[MAX], f[3][MAX];\n\nvoid add(int x, int y){\n    cnt++;\n    Next[cnt] = head[x];\n    head[x] = cnt;\n    vet[cnt] = y;\n}\n\nint dfs(int x){\n    if(sg[id][x] != -1) return sg[id][x];\n    sg[id][x] = 0;\n    map<int, bool> mp;\n    for(int i = head[x]; i; i = Next[i]){\n        int v = vet[i];\n        mp[dfs(v)] = true;\n    }\n    while(mp[sg[id][x]]) sg[id][x]++;\n    return sg[id][x];\n}\n\nint main()\n{\n    cin >> n;\n    p[0] = 1;\n    for(int i = 1; i < MAX; i++){\n        p[i] = p[i-1]*B%P;\n    }\n    memset(sg, -1, sizeof(sg));\n    for(id = 0; id < 3; id++){\n        memset(head, 0, sizeof(head));\n        cnt = 0;\n        cin >> m;\n        int x, y;\n        for(int i = 1; i <= m; i++){\n            scanf(\"%d%d\", &x, &y);\n            if(x > y) swap(x, y);\n            add(x, y);\n        }\n        for(int i = 1; i <= n; i++){\n            if(sg[id][i] == -1) dfs(i);\n        }\n        for(int i = 1; i <= n; i++){\n            (f[id][sg[id][i]] += p[i]) %= P;\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i < 500; i++){\n        for(int j = 0; j < 500; j++){\n            ans = (ans + f[0][i]*f[1][j]%P*f[2][i^j]%P)%P;\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nlong long T=1000000000000000000LL%mod;\nvector<int>g[3][110000];\nint s[3];\nint f[3][110000];\nint f2[3][110000];\nint dp[3][110000];\nlong long gr[3][110000];\nint calc(int a,int b){\n\tif(dp[a][b]>=0)return dp[a][b];\n\tvector<int>t;\n\tfor(int i=0;i<g[a][b].size();i++){\n\t\tt.push_back(calc(a,g[a][b][i]));\n\t}\n\tstd::sort(t.begin(),t.end());\n\tint ret=0;\n\tfor(int i=0;i<t.size();i++){\n\t\tif(ret<t[i])break;\n\t\tif(ret==t[i])ret++;\n\t}\n\treturn dp[a][b]=ret;\n}\nlong long pT[110000];\nlong long key[3];\npair<int,int>q[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<3;i++)for(int j=0;j<a;j++)dp[i][j]=-1;\n\n\tpT[0]=1;\n\tfor(int i=1;i<110000;i++){\n\t\tpT[i]=pT[i-1]*T%mod;\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tscanf(\"%d\",&s[j]);\n\t\tfor(int i=0;i<s[j];i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\tif(p>q)swap(p,q);\n\t\t\tg[j][p].push_back(q);\n\t\t}\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint at=calc(j,i);\n\t\t\t// printf(\"%d %d: %d\\n\",j,i,at);\n\t\t\tgr[j][at]=(gr[j][at]+pT[i])%mod;\n\t\t}\n\t}\n\n\tlong long ret=0;\n\tint M=500;\n\tfor(int i=0;i<=M;i++){\n\t\tfor(int j=0;j<=M;j++)for(int k=0;k<=M;k++){\n\t\t\tif(i^j^k)continue;\n\t\t\tret=(ret+gr[0][i]*gr[1][j]%mod*gr[2][k])%mod;\n\t}}\n\n\tret=ret*T%mod;\n\tret=ret*T%mod;\n\tret=ret*T%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n/*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n//    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define iostream_untie true\n#include <bits/stdc++.h>\n#include <ext/rope>\n#define __all(v) std::begin(v), std::end(v)\n#define __rall(v) std::rbegin(v), std::rend(v)\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n#else\n    #define dump(...) ((void)0)\n#endif\n\n/* function utility start */\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n/*\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n*/\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n/* using alias end */\n\n/* library start */\n\n\n\n/* library end */\n\n/* The main code follows. */\n\nstruct solver; template <class T = solver> void _main();\nint main() { _main<>(); }\n\ntemplate <class solver>\nvoid _main()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n\n    }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nconst int mod=998244353;\ninline int pl(int a,int b){return (a+=b)>=mod?a-mod:a;}\nint kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nvoid fwt(int f[],int opt,int lim)\n{\n\tint x,y;\n\tfor(int len=1;len<lim;len<<=1)\n\t\tfor(int j=0;j<lim;j+=len<<1)\n\t\t\tfor(int k=0;k<len;++k)\n\t\t\t{\n\t\t\t\tx=f[j+k],y=f[j+k+len];\n\t\t\t\tf[j+k]=pl(x,y);\n\t\t\t\tf[j+k+len]=pl(x,mod-y);\n\t\t\t}\n\tif(opt==-1)\n\t{\n\t\tint inv=kpow(lim,mod-2);\n\t\tfor(int i=0;i<lim;++i)f[i]=1ll*f[i]*inv%mod;\n\t}\n}\nint n,ans,lim;\nint po[100010],s[131072];\nstruct graph\n{\n\tint m;\n\tvector<int>E[100010];\n\tint sg[100010];\n\tint st[100010],tp,a[131072];\n\tvoid init()\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=1,x,y;i<=m;++i)\n\t\t{\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tif(x>y)swap(x,y);\n\t\t\tE[x].emplace_back(y);\n\t\t}\n\t\tfor(int i=n;i;--i)\n\t\t{\n\t\t\ttp=0;\n\t\t\tfor(auto u:E[i])st[++tp]=sg[u];\n\t\t\tsort(st+1,st+1+tp);\n\t\t\tint cur=-1;\n\t\t\tfor(int j=1;j<=tp;++j)\n\t\t\t{\n\t\t\t\tif(st[j]==cur||st[j]==cur+1)cur=st[j];\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tsg[i]=cur+1;\n\t\t\ta[sg[i]]=(a[sg[i]]+po[i])%mod;\n\t\t}\n\t\tfwt(a,1,lim);\n\t}\n}g1,g2,g3;\nint main()\n{\n\tpo[0]=1;\n\tint w=1000000000000000000%mod;\n\tfor(int i=1;i<=100000;++i)po[i]=1ll*po[i-1]*w%mod;\n\tscanf(\"%d\",&n);\n\tlim=1;\n\twhile(lim<n)lim<<=1;\n\tg1.init();\n\tg2.init();\n\tg3.init();\n\tfor(int i=0;i<lim;++i)s[i]=1ll*g1.a[i]*g2.a[i]%mod*g3.a[i]%mod;\n\tfwt(s,-1,lim);\n\tprintf(\"%d\",s[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(0);\n  cin.sync_with_stdio(0);\n\n  int N; cin >> N;\n  long long ret = 0;\n\n  long long MOD = 998244353;\n  long long ten = 1;\n  for(int i = 0; i<18; ++i) {\n    ten = (ten * 10) % MOD;\n  }\n  long long pows[100000+1];\n  pows[0] = 1;\n  for(int i = 1; i<=100000; ++i) {\n    pows[i] = (pows[i-1] * ten) % MOD;\n  }\n\n  vector<long long> ary[3];\n\n  for(int graph = 0; graph<3; ++graph) {\n    int M; cin >> M;\n\n    vector<vector<int> > adj(N+1);\n    for(int i = 0; i<M; ++i) {\n      int u, v; cin >> u >> v;\n      adj[u].push_back(v);\n      adj[v].push_back(u);\n    }\n\n    set<int> usable;\n    for(int i = 1; i<N+1; ++i) {\n      usable.insert(i);\n    }\n    while(!usable.empty()) {\n      set<int> u = usable;\n      long long curr = 0;\n      while(!u.empty()) {\n        auto it = u.end();\n        it--;\n        int next = *it;\n        curr = (curr + pows[next]) % MOD;\n        for(int i = 0; i<adj[next].size(); ++i) {\n          u.erase(adj[next][i]);\n        }\n        u.erase(next);\n        usable.erase(next);\n      }\n      ary[graph].push_back(curr);\n    }\n  }\n\n  for(int i = 0; i<min(min(ary[0].size(), ary[1].size()), ary[2].size()); ++i) {\n    long long add = 0;\n    if(i == 0) {\n      add = ((ary[0][i] * ary[1][i]) % MOD) * ary[2][i];\n    }\n    else {\n      //add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][0] + ((ary[0][i] * ary[1][0])%MOD) * ary[2][i] + ((ary[0][0] * ary[1][i])%MOD) * ary[2][i];\n      add = ((ary[0][i] * ary[1][i])%MOD) * ary[2][i-1] + ((ary[0][i] * ary[1][i-1])%MOD) * ary[2][i] + ((ary[0][i-1] * ary[1][i])%MOD) * ary[2][i];\n    }\n    ret = (ret + add) % MOD;\n  }\n\n  cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nconst ll MOD=998244353;\n\nll x[100010];\nvoid init(){\n\tx[0]=1e+18;\n\t//x[0]=2;\n\tx[0]%=MOD;\n\tfor(int i=1;i<100010;i++){\n\t\tx[i]=x[i-1]*x[0];\n\t\tx[i]%=MOD;\n\t}\n}\n\nll modpow(ll x,ll k){\n\tif(k==0)return 1;\n\tll ret=modpow(x,k/2);\n\tret*=ret;\n\tret%=MOD;\n\tif(k%2==1){\n\t\tret*=x;\n\t\tret%=MOD;\n\t}\n\treturn ret;\n}\n\nstruct Graph{\n\tint n,m;\n\tvector<int> G[100010];\n\tint k;\n\tll ret[100010];\n\tbool used[100010];\n\tbool used2[100010];\n\tint run(){\n\t\tmemset(used,0,sizeof used);\n\t\tint zan=n;\n\t\tk=0;\n\t\twhile(zan>0){\n\t\t\tret[k]=0;\n\t\t\tmemset(used2,0,sizeof used2);\n\t\t\tfor(int i=n;i>=1;i--){\n\t\t\t\tif(used[i])continue;\n\t\t\t\tused2[i]=true;\n\t\t\t\tfor(int v: G[i]){\n\t\t\t\t\tif(used2[v]){\n\t\t\t\t\t\tused2[i]=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(used2[i]){\n\t\t\t\t\tret[k]+=x[i-1];\n\t\t\t\t\tif(ret[k]>=MOD)ret[k]-=MOD;\n\t\t\t\t\tzan--;\n\t\t\t\t\tused[i]=true;\n\t\t\t\t\t//cerr<<i<<\" \"<<k<<\" \"<<x[i]<<\" \"<<ret[k]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\t/*cerr<<k<<endl;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcerr<<ret[i]<<\" \";\n\t\t}cerr<<endl;*/\n\t\treturn k;\n\t}\n}G[3];\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&G[0].n);\n\tG[1].n=G[0].n;\n\tG[2].n=G[0].n;\n\tint k=MOD;\n\tfor(int t=0;t<3;t++){\n\t\tscanf(\"%d\",&G[t].m);\n\t\tfor(int i=0;i<G[t].m;i++){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tif(a>b)G[t].G[b].push_back(a);\n\t\t\telse G[t].G[a].push_back(b);\n\t\t}\n\t\tchmin(k,G[t].run());\n\t}\n\t\n\tstatic ll a[1<<17];\n\tfor(int i=0;i<G[1].k;i++){\n\t\tfor(int j=0;j<G[2].k;j++){\n\t\t\ta[i^j]+=G[1].ret[i]*G[2].ret[j];\n\t\t\ta[i^j]%=MOD;\n\t\t}\n\t}\n\t\n\tll ret=0;\n\tfor(int i=0;i<k;i++){\n\t\ta[i]*=G[0].ret[i];\n\t\tret+=a[i]; ret%=MOD;\n\t}\n\tcout<<ret%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ for(auto it : P) { s << \"<\" << it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ for(auto it : P) { s << \"<\" << it.first << \"->\" << it.second << \"> \"; } return s << endl; }\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nconst int MOD = 998244353;\nusing mint = Fp<MOD>;\n\nusing Graph = vector<vector<int>>;\nint N;\nvector<int> M;\nvector<Graph> G;\nvector<mint> ten;\n\nvoid pre() {\n    int MAX = 510000;\n    ten.assign(MAX, 1);\n    mint fac = modpow(mint(10), 18);\n    for (int i = 1; i <= MAX; ++i) ten[i] = ten[i-1] * fac;\n}\n\nmint solve() {\n    vector<vector<int>> grundy(3, vector<int>(N, -1));\n    vector<vector<mint>> memo(3, vector<mint>(1000, 0));\n    for (int iter = 0; iter < 3; ++iter) {\n        for (int v = N-1; v >= 0; --v) {\n            set<int> gse;\n            for (auto e : G[iter][v]) gse.insert(grundy[iter][e]);\n            int gres = 0;\n            while (gse.count(gres)) ++gres;\n            grundy[iter][v] = gres;\n            memo[iter][gres] += ten[v+1];\n        }\n    }\n    mint res = 0;\n    for (int a = 0; a < 1000; ++a) {\n        if (memo[0][a] == 0) break;\n        for (int b = 0; b < 1000; ++b) {\n            if (memo[1][b] == 0) break;\n            int c = a^b;\n            res += memo[0][a] * memo[1][b] * memo[2][c];\n        }\n    }\n    return res;\n}\n\nint main() {\n    pre();\n    cin >> N;\n    M.assign(3, 0);\n    G.assign(3, Graph(N, vector<int>()));\n    for (int iter = 0; iter < 3; ++iter) {\n        cin >> M[iter];\n        for (int i = 0; i < M[iter]; ++i) {\n            int a, b; cin >> a >> b; --a, --b;\n            G[iter][a].push_back(b);\n            G[iter][b].push_back(a);\n        }\n    }\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\n//const int mod = 1000000007;\nconst int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nmint pow1018[100001];\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    vec num;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        num = vec(N, -1);\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    mvec calc(){\n        mvec val(N, 0);\n        int sz = 0;\n        IREP(i, N){\n            set<int> s;\n            for(auto e: G[i]) if(num[e.to] >= 0) s.insert(num[e.to]);\n\n            REP(j, N) if(s.count(j) == 0){\n                num[i] = j;\n                val[j] += pow1018[i + 1];\n                Max(sz, j + 1);\n                break;\n            }\n        }\n        val.resize(sz);\n        return val;\n    }\n\n};\n\nsigned main(){\n\n    pow1018[0] = 1;\n    mint v_1018 = ((mint)10).pow(18);\n    REP(i, 100000) pow1018[i + 1] = pow1018[i] * v_1018;\n\n    int N; cin >> N;\n    Graph X(N), Y(N), Z(N);\n    \n    int M1; cin >> M1;\n    REP(i, M1){\n        int a, b; cin >> a >> b;\n        a--; b--;\n        X.add_Undirected_edge(a, b);\n    }\n\n    int M2; cin >> M2;\n    REP(i, M2){\n        int a, b; cin >> a >> b;\n        a--; b--;\n        Y.add_Undirected_edge(a, b);\n    }\n\n    int M3; cin >> M3;\n    REP(i, M3){\n        int a, b; cin >> a >> b;\n        a--; b--;\n        Z.add_Undirected_edge(a, b);\n    }\n\n    mvec x = X.calc(), y = Y.calc(), z = Z.calc();\n\n    mint ans = 0;\n    REP(i, SZ(x)) REP(j, SZ(y)){\n        if((i ^ j) < SZ(z)) ans += x[i] * y[j] * z[i ^ j];\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n;\n  cin>>n;\n\n  vector<vector<int>> G[3];\n  for(int t=0;t<3;t++){\n    G[t].resize(n);\n    int m;\n    cin>>m;\n    for(int i=0;i<m;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      if(a>b) swap(a,b);\n      G[t][a].emplace_back(b);\n    }\n  }\n\n  const int MAX = 1010;\n  using M = Mint<int, 998244353>;\n  M base=M(10).pow(18);\n\n  vector<M> cnt[3];\n  for(int t=0;t<3;t++){\n    vector<int> dp(n);\n    dp.resize(n,0);\n    for(int i=n-1;i>=0;i--){\n      set<int> used;\n      for(int j:G[t][i])\n        used.emplace(dp[j]);\n      while(used.count(dp[i])) dp[i]++;\n    }\n    cnt[t].resize(MAX,0);\n    for(int i=0;i<n;i++) cnt[t][dp[i]]+=base.pow(i+1);\n  }\n\n  M ans{0};\n  for(int x=0;x<MAX;x++)\n    for(int y=0;y<MAX;y++)\n      ans+=cnt[0][x]*cnt[1][y]*cnt[2][x^y];\n\n  cout<<ans<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int W = 716070898, P = 998244353, I2 = 499122177;\n\nvoid add(int&x , int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int N;\n  cin >> N;\n  vector<int> pw(N);\n  pw[0] = 1;\n  for (int i = 1; i < N; ++i) pw[i] = pw[i - 1] * (ll)W % P;\n  int l = 0;\n  while ((1 << l) < N) ++l;\n  vector<int> SG1, SG2, SG3;\n  auto getSG = [&]() {\n    vector<int> ret(N);\n    int M;\n    cin >> M;\n    vector<vector<int>> G(N);\n    while (M--) {\n      int u, v;\n      cin >> u >> v;\n      --u; --v;\n      if (u > v) swap(u, v);\n      G[u].push_back(v);\n    }\n    for (int i = N - 1; i >= 0; --i) {\n      vector<bool> vis(G[i].size() + 1);\n      for (int v : G[i])\n        if (ret[v] <= G[i].size())\n          vis[ret[v]] = true;\n      while (vis[ret[i]]) ++ret[i];\n    }\n    return ret;\n  };\n  SG1 = getSG();\n  SG2 = getSG();\n  SG3 = getSG();\n  auto toWt = [&](const vector<int>& SG) {\n    vector<int> ret(1 << l);\n    for (int i = 0; i < N; ++i)\n      add(ret[SG[i]], pw[i]);\n    return ret;\n  };\n  auto A1 = toWt(SG1), A2 = toWt(SG2), A3 = toWt(SG3);\n  auto FWT = [&](vector<int>& A) -> void {\n    for (int i = 0; i < l; ++i)\n      for (int j = 0; j < (1 << l); ++j)\n        if (!((j >> i) & 1)) {\n          int a0 = A[j], a1 = A[j ^ (1 << i)];\n          A[j] = (a0 + a1) % P;\n          A[j ^ (1 << i)] = (a0 - a1 + P) % P;\n        }\n  };\n  FWT(A1);\n  FWT(A2);\n  FWT(A3);\n  for (int i = 0; i < (1 << l); ++i)\n    A1[i] = A1[i] * (ll)A2[i] % P * A3[i] % P;\n  FWT(A1);\n  int ans = A1[0] * (ll)W % P * W % P * W % P;\n  for (int i = 0; i < l; ++i)\n    ans = ans * (ll)I2 % P;\n  cout << ans;\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 998244353;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\nvoid yesno(bool ok, string yes = \"Yes\", string no = \"No\") {\n    if (ok) {\n        cout << yes << endl;\n    } else {\n        cout << no << endl;\n    }\n}\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nstruct edge {\n    ll to, cost;\n};\n\nint V;\nvector<edge> Ga[200000], Gb[200000], Gc[200000];\nll da[1000000], db[200000], dc[200000];\n\nvoid addedgea(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    Ga[st].push_back(e);\n}\n\nvoid addedgeb(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    Gb[st].push_back(e);\n}\n\nvoid addedgec(int st, int ed, ll co) {\n    edge e;\n    e.to = ed;\n    e.cost = co;\n    Gc[st].push_back(e);\n}\n\nll N;\nll M1, M2, M3;\nvoid setvalue() {\n    fill(da, da + N, 0);\n    PER(i, N - 1, -1) {\n        if (da[i] == 0) {\n            REP(j, 0, Ga[i].size()) {\n                edge e = Ga[i][j];\n                if (e.to < i && da[e.to] == 0) {\n                    da[e.to] = 1;\n                }\n            }\n        } else if (da[i] == 1) {\n            REP(j, 0, Ga[i].size()) {\n                edge e = Ga[i][j];\n                if (e.to < i && da[e.to] == 1) {\n                    da[e.to] = 2;\n                }\n            }\n        }\n    }\n    fill(db, db + N, 0);\n    PER(i, N - 1, -1) {\n        if (db[i] == 0) {\n            REP(j, 0, Gb[i].size()) {\n                edge e = Gb[i][j];\n                if (e.to < i && db[e.to] == 0) {\n                    db[e.to] = 1;\n                }\n            }\n        } else if (db[i] == 1) {\n            REP(j, 0, Gb[i].size()) {\n                edge e = Gb[i][j];\n                if (e.to < i && db[e.to] == 1) {\n                    db[e.to] = 2;\n                }\n            }\n        }\n    }\n    fill(dc, dc + N, 0);\n    PER(i, N - 1, -1) {\n        if (dc[i] == 0) {\n            REP(j, 0, Gc[i].size()) {\n                edge e = Gc[i][j];\n                if (e.to < i && dc[e.to] == 0) {\n                    dc[e.to] = 1;\n                }\n            }\n        } else if (dc[i] == 1) {\n            REP(j, 0, Gc[i].size()) {\n                edge e = Gc[i][j];\n                if (e.to < i && dc[e.to] == 1) {\n                    dc[e.to] = 2;\n                }\n            }\n        }\n    }\n}\n\nll ten[2000000];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> M1;\n    ten[0] = 1;\n    REP(i, 1, 2000000) {\n        ten[i] = multiply(ten[i - 1], 10);\n    }\n    REP(i, 0, M1) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedgea(a, b, 0);\n        addedgea(b, a, 0);\n    }\n    cin >> M2;\n    REP(i, 0, M2) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedgeb(a, b, 0);\n        addedgeb(b, a, 0);\n    }\n    cin >> M3;\n    REP(i, 0, M3) {\n        ll a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        addedgec(a, b, 0);\n        addedgec(b, a, 0);\n    }\n    // cout << \"aaa\" << endl;\n    setvalue();\n    // cout << \"bbb\" << endl;\n    ll azero = 0, bzero = 0, czero = 0;\n    ll aone = 0, bone = 0, cone = 0;\n    REP(i, 0, N) {\n        if (da[i] == 0) {\n            azero = modadd(azero, ten[18 * (i + 1)]);\n        } else if (da[i] == 1) {\n            aone = modadd(aone, ten[18 * (i + 1)]);\n        }\n        if (db[i] == 0) {\n            bzero = modadd(bzero, ten[18 * (i + 1)]);\n        } else if (db[i] == 1) {\n            bone = modadd(bone, ten[18 * (i + 1)]);\n        }\n        if (dc[i] == 0) {\n            czero = modadd(czero, ten[18 * (i + 1)]);\n        } else if (dc[i] == 1) {\n            cone = modadd(cone, ten[18 * (i + 1)]);\n        }\n    }\n    ll ans = 0;\n    ans = modadd(ans, multiply(azero, multiply(bzero, czero)));\n    ans = modadd(ans, multiply(aone, multiply(bone, czero)));\n    ans = modadd(ans, multiply(aone, multiply(bzero, cone)));\n    ans = modadd(ans, multiply(azero, multiply(bone, cone)));\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\nusing std::queue;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nconst int mod = 998244353;\n\nint add(int a, int b) {\n    return (a + b >= mod ? a + b - mod : a + b);\n}\n\nint sub(int a, int b) {\n    return (a >= b ? a - b : mod + a - b);\n}\n\nint mult(int a, int b) {\n    return (int64_t(a)* b) % mod;\n}\n\nint fpow(int a, int n, int r = 1) {\n    while (n) {\n        if (n % 2)\n            r = mult(r, a);\n        a = mult(a, a);\n        n /= 2;\n    }\n    return r;\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n = input<int>();\n\n    vector<vector<int>> X(n + 1), Y(n + 1), Z(n+ 1);\n\n    for (int t = input<int>(); t != 0; --t) {\n        int v, u;\n        cin >> v >> u;\n        X[min(v, u)].push_back(max(v, u));\n    }\n    \n    for (int t = input<int>(); t != 0; --t) {\n        int v, u;\n        cin >> v >> u;\n        Y[min(v, u)].push_back(max(v, u));\n    }\n\n    for (int t = input<int>(); t != 0; --t) {\n        int v, u;\n        cin >> v >> u;\n        Z[min(v, u)].push_back(max(v, u));\n    }\n\n    vector<int> xrank(n + 1);\n    for (int v = n; v >= 1; --v) {\n        vector<char> ban(SZ(X[v]) + 1);\n\n        for (int u: X[v])\n            if (xrank[u] < SZ(ban))\n                ban[xrank[u]] = 1;\n\n        int it = 0;\n        while (ban[it])\n            ++it;\n\n        xrank[v] = it;\n    }\n\n    vector<int> yrank(n + 1);\n    for (int v = n; v >= 1; --v) {\n        vector<char> ban(SZ(Y[v]) + 1);\n\n        for (int u: Y[v])\n            if (yrank[u] < SZ(ban))\n                ban[yrank[u]] = 1;\n\n        int it = 0;\n        while (ban[it])\n            ++it;\n\n        yrank[v] = it;\n    }\n\n    vector<int> zrank(n + 1);\n    for (int v = n; v >= 1; --v) {\n        vector<char> ban(SZ(Z[v]) + 1);\n\n        for (int u: Z[v])\n            if (zrank[u] < SZ(ban))\n                ban[zrank[u]] = 1;\n\n        int it = 0;\n        while (ban[it])\n            ++it;\n\n        zrank[v] = it;\n    }\n    \n    auto BIG = fpow(10, 18);\n    \n    vector<int> x_by_rank(3 * n + 1);\n    for (int v = 1; v <= n; ++v)\n        x_by_rank[xrank[v]] = add(x_by_rank[xrank[v]], fpow(BIG, v));\n\n    vector<int> A(1 << 18), B(1 << 18);\n    for (int v = 1; v <= n; ++v)\n        A[yrank[v]] = add(A[yrank[v]], fpow(BIG, v));\n\n    for (int v = 1; v <= n; ++v)\n        B[zrank[v]] = add(B[zrank[v]], fpow(BIG, v));\n\n    for (int lvl = 0; lvl <= 17; ++lvl) {\n        for (int off = 0; off < SZ(A); off += (2 << lvl)) {\n            for (int i = 0; i < (1 << lvl); ++i) {\n                int a = A[off + i];\n                int b = A[off + (1 << lvl) + i];\n\n                A[off + i] = add(a, b);\n                A[off + (1 << lvl) + i] = sub(a, b);\n            }\n        }\n    }\n\n    for (int lvl = 0; lvl <= 17; ++lvl) {\n        for (int off = 0; off < SZ(A); off += (2 << lvl)) {\n            for (int i = 0; i < (1 << lvl); ++i) {\n                int a = B[off + i];\n                int b = B[off + (1 << lvl) + i];\n\n                B[off + i] = add(a, b);\n                B[off + (1 << lvl) + i] = sub(a, b);\n            }\n        }\n    }\n\n    for (int i = 0; i < SZ(A); ++i)\n        A[i] = mult(A[i], B[i]);\n\n    int d2 = fpow(2, mod - 2);\n    for (int lvl = 17; lvl >= 0; --lvl) {\n        for (int off = 0; off < SZ(A); off += (2 << lvl)) {\n            for (int i = 0; i < (1 << lvl); ++i) {\n                int a = A[off + i];\n                int b = A[off + (1 << lvl) + i];\n\n                A[off + i] = mult(add(a, b), d2);\n                A[off + (1 << lvl) + i] = mult(sub(a, b), d2);\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < SZ(A) and i < SZ(x_by_rank); ++i)\n        ans = add(ans, mult(A[i], x_by_rank[i]));\n    \n    \n    // int ans = 0;\n    // for (int v = 1; v <= n; ++v)\n    //     for (int u = 1; u <= n; ++u)\n    //         ans = add(ans, mult(fpow(BIG, v + u), x_by_rank[yrank[v] xor zrank[u]]));\n\n    cout << ans << \"\\n\";\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 120000\n\nconst LL mod=998244353;\nLL n,m,p,f[3][N],F[N],pw[N*18],sg[N];\nbool vis[N];\nvector<LL> g[N];\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nvoid solve(LL op){\n\tscanf(\"%lld\",&m);\n\tfor (LL i=1;i<=n;++i) g[i].clear();\n\tfor (LL i=1;i<=m;++i){\n\t\tLL x,y; scanf(\"%lld%lld\",&x,&y);\n\t\tif (x>y) swap(x,y);\n\t\tg[x].push_back(y);\n\t}\n\tfor (LL i=n;i;--i){\n\t\tfor (LL j:g[i]) vis[sg[j]]=1;\n\t\tfor (sg[i]=0;vis[sg[i]];++sg[i]);\n\t\tupd(f[op][sg[i]],pw[i*18]);\n\t\tfor (LL j:g[i]) vis[sg[j]]=0;\n\t}\n}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\tpw[0]=1; for (LL i=1;i<=n*18;++i) pw[i]=pw[i-1]*10%mod;\n\tsolve(0); solve(1); solve(2);\n\tp=600;\n\tfor (LL i=1;i<=2;++i){\n\t\tmemset(F,0,sizeof F);\n\t\tfor (LL j=0;j<=p;++j)\n\t\t\tfor (LL k=0;k<=p;++k){\n\t\t\t\tupd(F[j^k],f[i][j]*f[i-1][k]);\n\t\t\t}\n\t\tfor (LL j=0;j<=p;++j) f[i][j]=F[j];\n\t}\n\tprintf(\"%lld\\n\",f[2][0]);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define mod 998244353\nusing namespace std;\nint read()\n{\n\tchar c=0;\n\tint sum=0;\n\twhile (c<'0'||c>'9')\n\t\tc=getchar();\n\twhile ('0'<=c&&c<='9')\n\t\tsum=sum*10+c-'0',c=getchar();\n\treturn sum; \n};\nstruct node\n{\n\tint v,nxt;\n};\nnode edge[3][2000001];\nint n,m,head[3][2000001],len[3],d[3],d2[3];\nlong long Base;\nbool used[3][2000001],vis[3][2000001];\nvoid add(int k,int x,int y)\n{\n\tedge[k][++len[k]].v=y,edge[k][len[k]].nxt=head[k][x],head[k][x]=len[k];\n\tedge[k][++len[k]].v=x,edge[k][len[k]].nxt=head[k][y],head[k][y]=len[k];\n\treturn;\n}\nlong long fast_pow(long long a,int b)\n{\n\tif (b==0)\n\t\treturn 1;\n\tif (b&1)\n\t\treturn fast_pow(a*a%mod,b/2)*a%mod;\n\telse\n\t\treturn fast_pow(a*a%mod,b/2); \n}\nvoid solve(int op,int k1,int k2)\n{\n\tfor (int i=1;i<=n;++i)\n\t\td[op]=d2[op]=(d[op]+k1*fast_pow(10,18*i)%mod)%mod;\n\tfor (int i=n;i>=1;--i)\n\t\tif (!vis[op][i])\n\t\t{\n\t\t\td[op]=(d[op]+fast_pow(10,18*i)*(k2-k1)%mod)%mod;\n\t\t\tfor (int j=head[op][i];j>0;j=edge[op][j].nxt)\n\t\t\t\tvis[op][edge[op][j].v]=1;\n\t\t}\n\tfor (int i=1;i<=n;++i)\n\t\tvis[op][i]=!vis[op][i];\n\tfor (int i=n;i>=1;--i)\n\t\tif (!vis[op][i])\n\t\t{\n\t\t\td2[op]=(d2[op]+fast_pow(10,18*i)*(k2-k1)%mod)%mod;\n\t\t\tfor (int j=head[op][i];j>0;j=edge[op][j].nxt)\n\t\t\t\tvis[op][edge[op][j].v]=1;\n\t\t}\n\treturn;\n}\nint main()\n{\n\tint x,y;\n\tn=read();\n\tfor (int op=0;op<=2;++op)\n\t{\n\t\tm=read();\n\t\tfor (int i=1;i<=m;++i) x=read(),y=read(),add(op,x,y);\n\t}\n\tsolve(0,0,1),solve(1,d2[0],d[0]),solve(2,d2[1],d[1]);\n\tprintf(\"%d\\n\",(d[2]+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\nusing i8 = std::int_fast8_t;\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\nusing u8 = std::uint_fast8_t;\nusing u32 = std::uint_fast32_t;\nusing u64 = std::uint_fast64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nstruct rep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\nstruct revrep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) noexcept {\n  return a < b ? b - a : a - b;\n}\ntemplate <class T> void chmin(T &a, const T &b) noexcept {\n  if (b < a)\n    a = b;\n}\ntemplate <class T> void chmax(T &a, const T &b) noexcept {\n  if (a < b)\n    a = b;\n}\ntemplate <class F> class rec_lambda {\n  F f;\n\npublic:\n  rec_lambda(F &&f) : f(std::move(f)) {}\n  template <class... Args> auto operator()(Args &&... args) const {\n    return f(*this, std::forward<Args>(args)...);\n  }\n};\ntemplate <class F> auto make_rec(F &&f) { return rec_lambda<F>(std::move(f)); }\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\n\n} // namespace n91\n\n#include <cstdint>\n\nnamespace n91 {\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  using value_type = u64;\n\n  static constexpr u64 mod = Modulus;\n\nprivate:\n  static_assert(mod < static_cast<u64>(1) << 32,\n                \"Modulus must be less than 2**32\");\n\n  u64 v;\n\n  constexpr modint &negate() noexcept {\n    if (v != 0)\n      v = mod - v;\n    return *this;\n  }\n\npublic:\n  constexpr modint(const u64 x = 0) noexcept : v(x % mod) {}\n  constexpr u64 &value() noexcept { return v; }\n  constexpr const u64 &value() const noexcept { return v; }\n  constexpr modint operator+() const noexcept { return modint(*this); }\n  constexpr modint operator-() const noexcept { return modint(*this).negate(); }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    v += rhs.v;\n    if (v >= mod)\n      v -= mod;\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (v < rhs.v)\n      v += mod;\n    v -= rhs.v;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    v = v * rhs.v % mod;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = mod - 2;\n    while (exp) {\n      if (exp % 2 != 0)\n        *this *= rhs;\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return v == rhs.v;\n  }\n  constexpr bool operator!=(const modint rhs) const noexcept {\n    return v != rhs.v;\n  }\n};\ntemplate <std::uint_fast64_t Modulus>\nconstexpr typename modint<Modulus>::u64 modint<Modulus>::mod;\n\n} // namespace n91\n\n#include <vector>\n\nnamespace n91 {\n\ntemplate <class T> void f(std::vector<T> &a) {\n  const usize n = a.size();\n  for (usize d = 1; d < n; d *= 2) {\n    for (usize m = d * 2, i = 0; i < n; i += m) {\n      for (usize j = 0; j < d; j += 1) {\n        T x = a[i + j], y = a[i + j + d];\n        a[i + j] = x + y;\n        a[i + j + d] = x - y;\n      }\n    }\n  }\n}\n\ntemplate <class T> void inv_f(std::vector<T> &a) {\n  const T i2 = T(1) / T(2);\n  const usize n = a.size();\n  for (usize d = 1; d < n; d *= 2) {\n    for (usize m = d * 2, i = 0; i < n; i += m) {\n      for (usize j = 0; j < d; j += 1) {\n        T x = a[i + j], y = a[i + j + d];\n        a[i + j] = (x + y) * i2;\n        a[i + j + d] = (x - y) * i2;\n      }\n    }\n  }\n}\n\n} // namespace n91\n\n#include <set>\n\nnamespace n91 {\n\nusing mint = modint<998244353>;\n\nconstexpr usize Size = 1 << 17;\n\nstd::vector<mint> calc(const std::vector<std::vector<usize>> &g) {\n  mint uc = 1;\n  for (const usize i : rep(0, 18)) {\n    uc *= 10;\n  }\n  const usize n = g.size();\n  std::vector<mint> pows(n + 1);\n  pows[0] = 1;\n  for (const usize i : rep(0, n)) {\n    pows[i + 1] = pows[i] * uc;\n  }\n  std::vector<mint> ans(Size, 0);\n  std::vector<usize> grundy(n, n + 1);\n  for (const usize i : revrep(0, n)) {\n    std::set<usize> st;\n    for (const usize e : g[i]) {\n      st.insert(grundy[e]);\n    }\n    usize k = 0;\n    while (st.count(k)) {\n      k += 1;\n    }\n    grundy[i] = k;\n    ans[k] += pows[i + 1];\n  }\n  return ans;\n}\n\nvoid main_() {\n  /*\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  //*/\n  const usize n = scan<usize>();\n  std::vector<mint> ans(Size, 0);\n  ans[0] = 1;\n  for (const usize loop : rep(0, 3)) {\n    const usize m = scan<usize>();\n    auto g = md_vec(n, 0, usize());\n    for (const usize i : rep(0, m)) {\n      usize a = scan<usize>() - 1;\n      usize b = scan<usize>() - 1;\n      if (a > b)\n        std::swap(a, b);\n      g[a].push_back(b);\n    }\n    auto v = calc(g);\n    f(ans);\n    f(v);\n    for (const usize i : rep(0, Size)) {\n      ans[i] *= v[i];\n    }\n    inv_f(ans);\n  }\n  std::cout << ans[0].value() << std::endl;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=100010;\nconst ll P=998244353,T=1000000000000000000%P;\nint n,x,y,eg[3],m[3],hd[3][MAXN],nx[3][MAXN*2],ver[3][MAXN*2],mx[3],sg[3][MAXN],tmp[MAXN];\nll cnt[3][MAXN],ans;\nll qpow (ll a,ll b) {\n\tll res=1;\n\twhile (b) {\n\t\tif (b&1) {res=(res*a)%P;}\n\t\ta=(a*a)%P,b>>=1;\n\t}\n\treturn res;\n}\nvoid add_edge (int t,int x,int y) {\n\tver[t][++eg[t]]=y;\n\tnx[t][eg[t]]=hd[t][x];\n\thd[t][x]=eg[t];\n\treturn;\n}\nint main () {\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<=2;i++) {\n\t\tscanf(\"%d\",&m[i]);\n\t\tfor (int j=1;j<=m[i];j++) {\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tadd_edge(i,min(x,y),max(x,y));\n\t\t}\n\t\tfor (int j=n;j>=1;j--) {\n\t\t\tint cur=0;\n\t\t\tfor (int k=hd[i][j];k;k=nx[i][k]) {\n\t\t\t\ttmp[sg[i][ver[i][k]]]++;\n\t\t\t\twhile (tmp[cur]) {cur++;}\n\t\t\t}\n\t\t\tsg[i][j]=cur;\n\t\t\tfor (int k=hd[i][j];k;k=nx[i][k]) {tmp[sg[i][ver[i][k]]]--;}\n\t\t\tcnt[i][cur]=(cnt[i][cur]+qpow(T,j))%P,mx[i]=max(mx[i],cur);\n\t\t}\n\t}\n\tfor (int i=0;i<=mx[0];i++) {\n\t\tfor (int j=0;j<=mx[1];j++) {\n\t\t\tans=(ans+((cnt[0][i]*cnt[1][j])%P)*cnt[2][i^j])%P;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n\nconstexpr ll MOD = 998244353;\nconstexpr int IMAX = 450;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    vb usedrow(IMAX, false);\n    vector<vb> used(IMAX, usedrow);\n\n    vector<tuple<int, int, int>> good;\n    for (int i=0;i<IMAX;i++) {\n        good.push_back(tuple<int, int, int>{0, i , i});\n        // cout << 0 << \" \" << i << \" \" << i << endl;\n    }\n\n    for (int i=1;i<IMAX;i++) {\n        // cout << \"i = \" << i << endl;\n        int j = i+1;\n        while (j < IMAX) {\n            while (j < IMAX && used[i][j]) {\n                j++;\n            }\n            if (j < IMAX) {\n                int k = j+1;\n                while (k < IMAX && (used[i][k] || used[j][k])) {\n                    k++;\n                }\n                if (k < IMAX) {\n                    good.push_back(tuple<int, int, int>{i, j, k});\n                    // cout << i << \" \" << j << \" \" << k << endl;\n                    used[i][j] = true;\n                    used[i][k] = true;\n                    used[j][k] = true;\n                }\n            }\n            j++;\n        }\n    }\n\n    // cout << good.size() << endl;\n\n    int N;\n    cin >> N;\n    vvi adj1(N);\n    vvi adj2(N);\n    vvi adj3(N);\n\n    int M1;\n    cin >> M1;\n    for (int i=0;i<M1;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj1[u].push_back(v);\n        adj1[v].push_back(u);\n    }\n\n    int M2;\n    cin >> M2;\n    for (int i=0;i<M2;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj2[u].push_back(v);\n        adj2[v].push_back(u);\n    }\n\n    int M3;\n    cin >> M3;\n    for (int i=0;i<M3;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj3[u].push_back(v);\n        adj3[v].push_back(u);\n    }\n\n    vi label1(N, 0);\n    vi label2(N, 0);\n    vi label3(N, 0);\n\n    vb levels(IMAX, false);\n    int max_label = 0;\n    for (int i=N-1;i>=0;i--) {\n        for (int nbr : adj1[i]) {\n            if (nbr > i) levels[label1[nbr]] = true;\n            \n        }\n        while(levels[label1[i]]) label1[i]++;\n        max_label = max(max_label, label1[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj2[i]) {\n            if (nbr > i) levels[label2[nbr]] = true;\n            \n        }\n        while(levels[label2[i]]) label2[i]++;\n        max_label = max(max_label, label2[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj3[i]) {\n            if (nbr > i) levels[label3[nbr]] = true;\n            \n        }\n        while(levels[label3[i]]) label3[i]++;\n        max_label = max(max_label, label3[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n    }\n\n    // for (int i=0;i<N;i++) {\n    //     cout << i << \" \" << label1[i] << \" \" << label2[i] << \" \" << label3[i] << endl;\n    // }\n\n    vector<modnum<MOD>> wts1(IMAX+1, 0);\n    vector<modnum<MOD>> wts2(IMAX+1, 0);\n    vector<modnum<MOD>> wts3(IMAX+1, 0);\n\n    modnum<MOD> base = modnum<MOD>(10).pow(18);\n    for (int i=0;i<N;i++) {\n        wts1[label1[i]] += base.pow(i+1);\n        wts2[label2[i]] += base.pow(i+1);\n        wts3[label3[i]] += base.pow(i+1);\n    }\n\n    // cout << \"weights: \" << endl;\n    // for (int i=0;i<5;i++) {\n    //     cout << i << \" \" << wts1[i] << \" \" << wts2[i] << \" \" << wts3[i] << endl;\n    // }\n\n    modnum<MOD> ans = 0;\n\n    for (auto gtrip : good) {\n        int x = get<0>(gtrip);\n        int y = get<1>(gtrip);\n        int z = get<2>(gtrip);\n\n        if (x == y  && x == z) {\n            ans += wts1[x] * wts2[y] * wts3[z];\n        } else if (y == z) {\n            ans += wts1[x] * wts2[y] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[y];\n            ans += wts1[y] * wts2[y] * wts3[x];\n        } else {\n            ans += wts1[x] * wts2[y] * wts3[z];\n            ans += wts1[x] * wts2[z] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[z];\n            ans += wts1[y] * wts2[z] * wts3[x];\n            ans += wts1[z] * wts2[x] * wts3[y];\n            ans += wts1[z] * wts2[y] * wts3[x];\n        }\n    }\n\n    cout << ans << endl;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 998244353; // 998244853; \n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nvoid solve() {\n    int n; cin >> n;\n    vector<vector<mint>> dp(3);\n    mint P = mint(10).exp(18);\n    mint iP = 1/P;\n    for (int i = 0; i < 3; i++) {\n        vector<vector<int>> g(n);\n        int m; cin >> m;\n        for (int _ = 0; _ < m; _++) {\n            int x,y;\n            cin >> x >> y;\n            x--;y--;\n            if(x > y) swap(x,y);\n            g[x].push_back(y);\n        }\n        vector<int> sg(n), trk(n,-1);\n        mint val = P.exp(n);\n        for (int u = n-1; u >= 0; u--) {\n            for (int v:g[u]) trk[sg[v]] = u;\n            while (trk[sg[u]] == u) ++sg[u];\n            while (sg[u] >= dp[i].size()) dp[i].emplace_back();\n            dp[i][sg[u]] += val;\n            val *= iP;\n        }\n    }\n    mint res = 0;\n    for (int i = 0; i < dp[0].size(); i++) {\n        for (int j = 0; j < dp[1].size(); j++) {\n            int k = i^j;\n            if (k < dp[2].size()) res += dp[0][i]*dp[1][j]*dp[2][k];\n        }\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define so(a) ((int)((a).size()))\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007 , D = 3 , __ = _ * D , LIM = 512 , mo = 998244353;\nconst lint linf = 1000000000000000000;\n\ntemplate<typename T1,typename T2> inline T1 ad(T1 &a,T2 b){return a=a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 dl(T1 &a,T2 b){return a=a>=b?a-b:a-b+mo;}\ntemplate<typename T1,typename T2> inline T1 add(T1 a,T2 b){return a+b>=mo?a+b-mo:a+b;}\ntemplate<typename T1,typename T2> inline T1 del(T1 a,T2 b){return a>=b?a-b:a-b+mo;}\n\nlint powa(lint a,lint t)\n{\n\tlint b=1;\n\twhile(t){if(t&1)b=b*a%mo;a=a*a%mo,t>>=1;}\n\treturn b;\n}\n\ninline lint inva(lint a){return powa(a,mo-2);}\n\nvector<int> e[_];\nlint bas[__];\nint n,sg[_];\n\nvoid makef(lint f[])\n{\n\tint m=ty();\n\tfor(int i=1;i<=n;i++)sg[i]=0,e[i].clear();\n\tfor(int i=1,a,b;i<=m;i++)a=ty(),b=ty(),e[min(a,b)].emplace_back(max(a,b));\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tunordered_set<int> hav;\n\t\tfor(auto b:e[i])hav.emplace(sg[b]);\n\t\tsg[i]=0;\n\t\twhile(hav.count(sg[i]))sg[i]++;\n\t}\n\tfor(int i=0;i<LIM;i++)f[i]=0;\n\tfor(int i=1;i<=n;i++)ad(f[sg[i]],bas[i]);\t\n}\n\nlint f[D][LIM];\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tbas[0]=1;\n\tfor(int i=1;i<__;i++)bas[i]=bas[i-1]*(linf%mo)%mo;\n\tfor(int i=0;i<D;i++)makef(f[i]);\n\n\tlint ans=0;\n\tfor(int i=0;i<LIM;i++)\n\t\tfor(int j=0;j<LIM;j++)\n\t\t\tad(ans,f[0][i]*f[1][j]%mo*f[2][i^j]%mo);\n\tcout<<ans<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 998244353\nlong long p[100010];\n\nvoid init() {\n    p[0] = p[1] = 1;\n    for (int i = 0; i < 18; i++) {\n        p[1] = p[1] * 10 % mod;\n    }\n    for (int i = 1; i <= 100000; i++) {\n        p[i+1] = p[i] * p[1] % mod;\n    }\n}\n\nvoid calc(int n, vector<long long> &v) {\n    int m; cin >> m;\n    vector<int> e[n+1];\n    vector<int> g(n+1, -1);\n    for (int i = 0; i < m; i++) {\n        int a, b; cin >> a >> b;\n        e[a].emplace_back(b);\n        e[b].emplace_back(a);\n    }\n    for (int i = n; i > 0; i--) {\n        set<int> s;\n        for (auto &to: e[i]) {\n            s.emplace(g[to]);\n        }\n        int t = 0;\n        for (auto &x: s) {\n            if (x == -1) continue;\n            if (x != t) break;\n            t++;\n        }\n        g[i] = t;\n    }\n    for (int i = 1; i <= n; i++) {\n        v[g[i]] = (v[g[i]] + p[i]) % mod;\n    }\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    init();\n    int n; cin >> n;\n    vector<long long> x(512, 0), y(512, 0), z(512, 0);\n    calc(n, x); calc(n, y); calc(n, z);\n    long long ans = 0;\n    for (int i = 0; i < 512; i++) {\n        for (int j = 0; j < 512; j++) {\n            ans = (ans + x[i] * y[j] % mod * z[i^j] % mod) % mod;\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, m;\nlong long Mod = 998244353, po[101000];\nstruct Graph {\n\tvector<int>E[101000];\n\tint D[101000], m, v[100010], Mx;\n\tlong long C[100010];\n\tvoid Input() {\n\t\tint i, a, b, j;\n\t\tscanf(\"%d\", &m);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tif (a > b)swap(a, b);\n\t\t\tE[a].push_back(b);\n\t\t}\n\t\tfor (i = n; i >= 1; i--) {\n\t\t\tfor (auto &t : E[i])v[D[t]] = 1;\n\t\t\tfor (j = 0; v[j]; j++);\n\t\t\tD[i] = j;\n\t\t\tfor (auto &t : E[i])v[D[t]] = 0;\n\t\t\tMx = max(Mx, D[i]);\n\t\t\tC[D[i]] = (C[D[i]] + po[i]) % Mod;\n\t\t}\n\t}\n}A, B, C;\nint main() {\n\tint i;\n\tlong long z = 1e18;\n\tscanf(\"%d\", &n);\n\tpo[0] = 1;\n\tfor (i = 1; i <= n; i++)po[i] = po[i - 1] * (z%Mod) % Mod;\n\tA.Input();\n\tB.Input();\n\tC.Input();\n\tlong long res = 0;\n\tfor (i = 0; i <= A.Mx; i++) {\n\t\tfor (int j = 0; j <= B.Mx; j++) {\n\t\t\tres = (res + A.C[i] * B.C[j] % Mod*C.C[i^j]) % Mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define N 524289\n#define mod 998244353\nconst int val=1000000000000000000%mod;\ninline int M(int x){return (x>=mod)?(x-mod):x;}\ninline int M1(int x){return (x<0)?(x+mod):x;}\ninline int ksm(int p,int k){int res=1;while(k){if(k&1)res=1ll*res*p%mod;k>>=1;p=1ll*p*p%mod;}return res;}\nint n,m,all,len,s[N],f[N],g[N],h[N],cnt=0;\nstruct Edge{int to,next;}e[N<<1];\ninline void AddEdge(int x,int y){e[++cnt]=(Edge){y,h[x]};h[x]=cnt;}\ninline void FWT(int f[],int len)\n{\n\tint i,j,x,y;\n\tfor(int j=1;j<len;j<<=1)\n\tfor(int i=0;i<len;i++)if(i&j){x=f[i^j];y=f[i];f[i^j]=M(x+y);f[i]=M1(x-y);}\n}\ninline void IFWT(int f[],int len)\n{\n\tint i,j,x,y,inv;\n\tfor(int j=1;j<len;j<<=1)\n\tfor(int i=0;i<len;i++)if(i&j){x=f[i^j];y=f[i];f[i^j]=M(x+y);f[i]=M1(x-y);}\n\tinv=ksm(len,mod-2);for(i=0;i<len;i++)f[i]=1ll*f[i]*inv%mod;\n}\nint tmp[N],P[N];\ninline void solve()\n{\n\tscanf(\"%d\",&m);int i,x,y;\n\tfor(i=1;i<=m;i++){scanf(\"%d%d\",&x,&y);AddEdge(x,y);AddEdge(y,x);}\n\ts[n]=0;\n\tfor(x=n-1;x>=1;x--)\n\t{\n\t\tfor(i=h[x];i;i=e[i].next)if((y=e[i].to)>=x)tmp[s[y]]=1;\n\t\ts[x]=0;while(tmp[s[x]])++s[x];\n\t\tfor(i=h[x];i;i=e[i].next)if((y=e[i].to)>=x)tmp[s[y]]=0;\n\t}\n\tfor(i=1;i<=n;i++)f[s[i]]=M(f[s[i]]+P[i]);FWT(f,len);\n\tfor(i=0;i<len;i++)g[i]=1ll*g[i]*f[i]%mod;\n\tfor(i=1;i<=n;i++)s[i]=h[i]=0;cnt=0;\n\tfor(i=0;i<len;i++)f[i]=0;\n}\nint main(){\n\tP[0]=1;for(int i=1;i<N;i++)P[i]=1ll*P[i-1]*val%mod;\n\tscanf(\"%d\",&n);all=3*n;len=1;while(len<all)len<<=1;\n\tg[0]=1;FWT(g,len);solve();solve();solve();IFWT(g,len);printf(\"%d\",g[0]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nll min(ll a, ll b) {return a < b ? a : b;}\nll min(int a, ll b) {return a < b ? a : b;}\nll min(ll a, int b) {return a < b ? a : b;}\nll min(int a, int b) {return a < b ? a : b;}\n\nll max(ll a, ll b) {return a > b ? a : b;}\nll max(int a, ll b) {return a > b ? a : b;}\nll max(ll a, int b) {return a > b ? a : b;}\nll max(int a, int b) {return a > b ? a : b;}\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst int N = 510200;\nconst long long MOD = 998244353;\nconst long long INF = 1e18;\n\nint n, m;\nint val[3][N];\nvector<int> g[N];\n\nlong long inq(long long x, long long y)\n{\n    if (y == 0) return 1;\n    long long l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nvoid run1(int id)\n{\n    for (int i = 0; i <= n; i++) g[i].clear();\n    int m;\n    cin >> m;\n    for (int i = 0; i < m; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    vector<int> gr(n + 1);\n    for (int i = n; i >= 1; i--)\n    {\n        vector<int> cnt(g[i].size() + 2);\n        for (auto u : g[i])\n        {\n            if (i < u) cnt[gr[u]]++;\n        }\n        for (int j = 0; j < g[i].size() + 2; j++)\n        {\n            if (cnt[j] == 0)\n            {\n                gr[i] = j;\n                val[id][j] = (val[id][j] + inq(INF % MOD, i)) % MOD;\n                break;\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    //ios_base::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    cin >> n;\n    run1(0);\n    run1(1);\n    run1(2);\n    long long ans = 0;\n    int M = 1000;\n    for (int x = 0; x < M; x++)\n    {\n        for (int y = 0; y < M; y++)\n        {\n            int z = x ^ y;\n            ans = (ans + val[0][x] * val[1][y] % MOD * val[2][z]) % MOD;\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n\nconstexpr ll MOD = 998244353;\nconstexpr int IMAX = 450;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    vb usedrow(IMAX, false);\n    vector<vb> used(IMAX, usedrow);\n\n    vector<tuple<int, int, int>> good;\n    for (int i=0;i<IMAX;i++) {\n        good.push_back(tuple<int, int, int>{0, i , i});\n        // cout << 0 << \" \" << i << \" \" << i << endl;\n    }\n\n    for (int i=1;i<IMAX;i++) {\n        // cout << \"i = \" << i << endl;\n        int j = i+1;\n        while (j < IMAX) {\n            while (j < IMAX && used[i][j]) {\n                j++;\n            }\n            if (j < IMAX) {\n                int k = j+1;\n                while (k < IMAX && (used[i][k] || used[j][k])) {\n                    k++;\n                }\n                if (k < IMAX) {\n                    good.push_back(tuple<int, int, int>{i, j, k});\n                    // cout << i << \" \" << j << \" \" << k << endl;\n                    used[i][j] = true;\n                    used[i][k] = true;\n                    used[j][k] = true;\n                }\n            }\n            j++;\n        }\n    }\n\n    // cout << good.size() << endl;\n\n    int N;\n    cin >> N;\n    vvi adj1(N);\n    vvi adj2(N);\n    vvi adj3(N);\n\n    int M1;\n    cin >> M1;\n    for (int i=0;i<M1;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj1[u].push_back(v);\n        adj1[v].push_back(u);\n    }\n\n    int M2;\n    cin >> M2;\n    for (int i=0;i<M2;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj2[u].push_back(v);\n        adj2[v].push_back(u);\n    }\n\n    int M3;\n    cin >> M3;\n    for (int i=0;i<M3;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj3[u].push_back(v);\n        adj3[v].push_back(u);\n    }\n\n    vi label1(N, 0);\n    vi label2(N, 0);\n    vi label3(N, 0);\n\n    vb levels(IMAX, false);\n    int max_label = 0;\n    for (int i=N-1;i>=0;i--) {\n        for (int nbr : adj1[i]) {\n            if (nbr > i) levels[label1[nbr]] = true;\n            \n        }\n        while(levels[label1[i]]) label1[i]++;\n        max_label = max(max_label, label1[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj2[i]) {\n            if (nbr > i) levels[label2[nbr]] = true;\n            \n        }\n        while(levels[label2[i]]) label2[i]++;\n        max_label = max(max_label, label2[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj3[i]) {\n            if (nbr > i) levels[label3[nbr]] = true;\n            \n        }\n        while(levels[label3[i]]) label3[i]++;\n        max_label = max(max_label, label3[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n    }\n\n    // for (int i=0;i<N;i++) {\n    //     cout << i << \" \" << label1[i] << \" \" << label2[i] << \" \" << label3[i] << endl;\n    // }\n\n    vector<modnum<MOD>> wts1(IMAX+1, 0);\n    vector<modnum<MOD>> wts2(IMAX+1, 0);\n    vector<modnum<MOD>> wts3(IMAX+1, 0);\n\n    modnum<MOD> base = modnum<MOD>(10).pow(18);\n    for (int i=0;i<N;i++) {\n        wts1[label1[i]] += base.pow(i+1);\n        wts2[label2[i]] += base.pow(i+1);\n        wts3[label3[i]] += base.pow(i+1);\n    }\n\n    // cout << \"weights: \" << endl;\n    // for (int i=0;i<5;i++) {\n    //     cout << i << \" \" << wts1[i] << \" \" << wts2[i] << \" \" << wts3[i] << endl;\n    // }\n\n    modnum<MOD> ans = 0;\n\n    for (auto gtrip : good) {\n        int x = get<0>(gtrip);\n        int y = get<1>(gtrip);\n        int z = get<2>(gtrip);\n\n        if (x == y  && x == z) {\n            ans += wts1[x] * wts2[y] * wts3[z];\n        } else if (y == z) {\n            ans += wts1[x] * wts2[y] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[y];\n            ans += wts1[y] * wts2[y] * wts3[x];\n        } else {\n            ans += wts1[x] * wts2[y] * wts3[z];\n            ans += wts1[x] * wts2[z] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[z];\n            ans += wts1[y] * wts2[z] * wts3[x];\n            ans += wts1[z] * wts2[x] * wts3[y];\n            ans += wts1[z] * wts2[y] * wts3[x];\n        }\n    }\n\n    cout << ans << endl;\n    \n\n    return 0;\n}#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        for (assert(n >= 0); fact.size() <= n; )\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum finv(int n) {\n        static vector<modnum<MOD>> finv = { 1 };\n        for (assert(n >= 0); finv.size() <= n; )\n            finv.push_back(finv.back() / finv.size());\n        return finv[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) * finv(r) * finv(n - r);\n    }\n};\n\nconstexpr ll MOD = 998244353;\nconstexpr int IMAX = 450;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    vb usedrow(IMAX, false);\n    vector<vb> used(IMAX, usedrow);\n\n    vector<tuple<int, int, int>> good;\n    for (int i=0;i<IMAX;i++) {\n        good.push_back(tuple<int, int, int>{0, i , i});\n        // cout << 0 << \" \" << i << \" \" << i << endl;\n    }\n\n    for (int i=1;i<IMAX;i++) {\n        // cout << \"i = \" << i << endl;\n        int j = i+1;\n        while (j < IMAX) {\n            while (j < IMAX && used[i][j]) {\n                j++;\n            }\n            if (j < IMAX) {\n                int k = j+1;\n                while (k < IMAX && (used[i][k] || used[j][k])) {\n                    k++;\n                }\n                if (k < IMAX) {\n                    good.push_back(tuple<int, int, int>{i, j, k});\n                    // cout << i << \" \" << j << \" \" << k << endl;\n                    used[i][j] = true;\n                    used[i][k] = true;\n                    used[j][k] = true;\n                }\n            }\n            j++;\n        }\n    }\n\n    // cout << good.size() << endl;\n\n    int N;\n    cin >> N;\n    vvi adj1(N);\n    vvi adj2(N);\n    vvi adj3(N);\n\n    int M1;\n    cin >> M1;\n    for (int i=0;i<M1;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj1[u].push_back(v);\n        adj1[v].push_back(u);\n    }\n\n    int M2;\n    cin >> M2;\n    for (int i=0;i<M2;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj2[u].push_back(v);\n        adj2[v].push_back(u);\n    }\n\n    int M3;\n    cin >> M3;\n    for (int i=0;i<M3;i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        adj3[u].push_back(v);\n        adj3[v].push_back(u);\n    }\n\n    vi label1(N, 0);\n    vi label2(N, 0);\n    vi label3(N, 0);\n\n    vb levels(IMAX, false);\n    int max_label = 0;\n    for (int i=N-1;i>=0;i--) {\n        for (int nbr : adj1[i]) {\n            if (nbr > i) levels[label1[nbr]] = true;\n            \n        }\n        while(levels[label1[i]]) label1[i]++;\n        max_label = max(max_label, label1[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj2[i]) {\n            if (nbr > i) levels[label2[nbr]] = true;\n            \n        }\n        while(levels[label2[i]]) label2[i]++;\n        max_label = max(max_label, label2[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n\n        for (int nbr : adj3[i]) {\n            if (nbr > i) levels[label3[nbr]] = true;\n            \n        }\n        while(levels[label3[i]]) label3[i]++;\n        max_label = max(max_label, label3[i]);\n        for (int j=0;j<=max_label;j++) levels[j] = false;\n    }\n\n    // for (int i=0;i<N;i++) {\n    //     cout << i << \" \" << label1[i] << \" \" << label2[i] << \" \" << label3[i] << endl;\n    // }\n\n    vector<modnum<MOD>> wts1(IMAX+1, 0);\n    vector<modnum<MOD>> wts2(IMAX+1, 0);\n    vector<modnum<MOD>> wts3(IMAX+1, 0);\n\n    modnum<MOD> base = modnum<MOD>(10).pow(18);\n    for (int i=0;i<N;i++) {\n        wts1[label1[i]] += base.pow(i+1);\n        wts2[label2[i]] += base.pow(i+1);\n        wts3[label3[i]] += base.pow(i+1);\n    }\n\n    // cout << \"weights: \" << endl;\n    // for (int i=0;i<5;i++) {\n    //     cout << i << \" \" << wts1[i] << \" \" << wts2[i] << \" \" << wts3[i] << endl;\n    // }\n\n    modnum<MOD> ans = 0;\n\n    for (auto gtrip : good) {\n        int x = get<0>(gtrip);\n        int y = get<1>(gtrip);\n        int z = get<2>(gtrip);\n\n        if (x == y  && x == z) {\n            ans += wts1[x] * wts2[y] * wts3[z];\n        } else if (y == z) {\n            ans += wts1[x] * wts2[y] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[y];\n            ans += wts1[y] * wts2[y] * wts3[x];\n        } else {\n            ans += wts1[x] * wts2[y] * wts3[z];\n            ans += wts1[x] * wts2[z] * wts3[y];\n            ans += wts1[y] * wts2[x] * wts3[z];\n            ans += wts1[y] * wts2[z] * wts3[x];\n            ans += wts1[z] * wts2[x] * wts3[y];\n            ans += wts1[z] * wts2[y] * wts3[x];\n        }\n    }\n\n    cout << ans << endl;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define oo 1000000010\n#define mod  998244353\nconst int N = 200010;\nconst int M = 3 * N;\n\nint n , m , u , v;\n\nint po[M];\n\nvector< vector< int > > g[3];\n\nvector< int > arr[3];\n\nvoid make(vector< vector< int > > &g , vector< int > &v){\n\tv.resize(n);\n\tfor(int i = n - 1; i >= 0;i--){\n\t\tvector< bool > has ((int)g[i].size() + 2 , false);\n\t\tfor(int j = 0 ;j < (int)g[i].size();j++){\n\t\t\thas[v[g[i][j]]] = true;\n\t\t}\n\t\twhile(has[v[i]]) v[i]++;\n\t}\n}\n\nint dp[4][N];\n\nint calc(int i,int x){\n\tif(i == 3){\n\t\treturn (x == 0 ? 1 : 0);\n\t}\n\tif(dp[i][x] != -1)\n\t\treturn dp[i][x];\n\tdp[i][x] = 0;\n\tfor(int j = 0 ;j < (int)arr[i].size();j++){\n\t\tdp[i][x] += (long long)calc(i + 1 , (x ^ arr[i][j])) * po[j + 1] % mod;\n\t\tif(dp[i][x] >= mod) \n\t\t\tdp[i][x] -= mod;\n\t}\n\treturn dp[i][x];\n}\n\n\n\nint main(){\n\tpo[0] = 1;\n\tpo[1] = ((long long)1e18) % mod;\n\tfor(int i = 2;i < M;i++){\n\t\tpo[i] = (long long)po[i - 1] * po[1] % mod;\n\t}\n\tscanf(\"%d\",&n);\n\tfor(int i = 0 ;i < 3;i++){\n\t\tg[i].resize(n);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j = 0 ;j < m;j++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--,v--;\n\t\t\tif(u > v) swap(u , v);\n\t\t\tg[i][u].push_back(v);\n\t\t}\n\t\tmake(g[i] , arr[i]);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(\"%d\\n\",calc(0 , 0));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n//#define MOD 1000000007\n#define MOD 998244353\n\n// auto mod int\n// https://youtu.be/L8grWxBlIZ4?t=9858\n// https://youtu.be/ERZuLAxZffQ?t=4807 : optimize\n// https://youtu.be/8uowVvQ_-Mo?t=1329 : division\n//const int mod = 1000000007;\nconst int mod = 998244353;\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%mod+mod)%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this;}\n  mint operator+(const mint a) const { return mint(*this) += a;}\n  mint operator-(const mint a) const { return mint(*this) -= a;}\n  mint operator*(const mint a) const { return mint(*this) *= a;}\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n\n  // for prime mod\n  mint inv() const { return pow(mod-2);}\n  mint& operator/=(const mint a) { return *this *= a.inv();}\n  mint operator/(const mint a) const { return mint(*this) /= a;}\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x;}\nostream& operator<<(ostream& os, const mint& a) { return os << a.x;}\n\nstd::vector<std::vector<int>> iig(int vn, int en) { \n        std::vector<std::vector<int>> res(vn); \n        for(int i = 0; i < en; i++) { \n                int s, t; \n                std::cin >> s >> t; \n                s--; t--; \n\t\tif (s > t) swap(s, t);\n                res[t].push_back(s); \n        } \n        return res; \n}\n\nstd::vector<int> assign_grundy(std::vector<std::vector<int>>& dg) {\n\tint gsize = dg.size();\n\tstd::vector<int> incomings(gsize);\n\tfor(int i = 0; i < gsize; i++) {\n\t\tfor(int j: dg[i]) {\n\t\t\tincomings[j]++;\n\t\t}\n\t}\n\tstd::vector<int> vs_ready;\n\tfor(int i = 0; i < gsize; i++) {\n\t\tif (incomings[i] == 0) vs_ready.push_back(i);\n\t}\n\tstd::vector<std::set<int>> prohibited_grundy(gsize);\n\tstd::vector<int> grundy(gsize);\n\twhile(!vs_ready.empty()) {\n\t\tint i = vs_ready.back();\n\t\tvs_ready.pop_back();\n\t\tint g = 0;\n\t\tfor(int pg: prohibited_grundy[i]) {\n\t\t\tif (g == pg) g++;\n\t\t\telse break;\n\t\t}\n\t\tgrundy[i] = g;\n\t\tfor(int j: dg[i]) {\n\t\t\tprohibited_grundy[j].insert(g);\n\t\t\tif ((--incomings[j]) == 0) vs_ready.push_back(j);\n\t\t}\n\t}\n\treturn grundy;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n;\n\tcin >> m;\n\tauto g1 = iig(n, m);\n\tcin >> m;\n\tauto g2 = iig(n, m);\n\tcin >> m;\n\tauto g3 = iig(n, m);\n\t// assume that each edge direction is reversed\n\tauto grn1 = assign_grundy(g1);\n\tauto grn2 = assign_grundy(g2);\n\tauto grn3 = assign_grundy(g3);\t\n\t// gmax * (gmax + 1) <= E * 2\n\n\tvector<mint> w(n + 1);\n\tmint step = mint(10).pow(18);\n\tw[0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tw[i] = w[i-1] * step;\n\t}\n\n\tvector<mint> gcount1(500), gcount2(500), gcount3(500);\n\tfor(int i = 0; i < n; i++) {\n\t\tgcount1[grn1[i]] += w[i+1];\n\t\tgcount2[grn2[i]] += w[i+1];\n\t\tgcount3[grn3[i]] += w[i+1];\n\t}\n\n\tmint res = 0;\n\n\tfor(int i = 0; i < 500; i++)\n\t\tfor(int j = 0; j < 500; j++) {\n\t\t\tint k = i ^ j;\n\t\t\tres += gcount1[i] * gcount2[j] * gcount3[k];\n\t\t}\n\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nconst int MOD = 998244353;\nconst long long w = ((long long)1e18)%MOD;\nlong long wpow[101010];\n\nvector<long long> solve(vector<pair<int, int> > V)\n{\n    vector<vector<int> > conn(N+1);\n    vector<int> sidx(N+1);\n    vector<long long> ret(N);\n    for(auto x: V)\n    {\n        int u, v; tie(u, v) = x;\n        conn[u].push_back(v);\n        conn[v].push_back(u);\n    }\n    for(int i=N; i>=1; --i)\n    {\n        set<int> S;\n        for(auto x: conn[i])\n            S.insert(sidx[x]);\n        for(int t=1; t<=N; ++t)\n            if(S.count(t) == 0)\n            {\n                sidx[i] = t;\n                ret[t-1] = ret[t-1] + wpow[i];\n                if(ret[t-1] >= MOD) ret[t-1] -= MOD;\n                break;\n            }\n    }\n    while(ret.back() == 0) ret.pop_back();\n    return ret;\n}\nint main()\n{\n    scanf(\"%d\", &N);\n    wpow[0] = 1;\n    for(int i=1; i<=N; ++i)\n        wpow[i] = wpow[i-1]*w%MOD;\n    vector<vector<long long> > Q;\n    for(int i=0; i<3; ++i)\n    {\n        vector<pair<int, int> > V;\n        int M; scanf(\"%d\", &M);\n        for(int j=0; j<M; ++j)\n        {\n            int u, v; scanf(\"%d%d\", &u, &v);\n            V.emplace_back(u, v);\n        }\n        Q.push_back(solve(V));\n    }\n    int maxi = max({Q[0].size(), Q[1].size(), Q[2].size()});\n    vector<vector<bool>> adj(maxi+1, vector<bool>(maxi+1, false));\n    long long ans = 0;\n    auto add_ans = [&](int a, int b, int c)\n    {\n        --a; --b; --c;\n        if(a<(int)Q[0].size() && b<(int)Q[1].size() && c<(int)Q[2].size())\n            ans += Q[0][a]*Q[1][b]%MOD*Q[2][c]%MOD;\n        if(b!=c && a<(int)Q[0].size() && c<(int)Q[1].size() && b<(int)Q[2].size())\n            ans += Q[0][a]*Q[1][c]%MOD*Q[2][b]%MOD;\n        if(a!=b && b<(int)Q[0].size() && a<(int)Q[1].size() && c<(int)Q[2].size())\n            ans += Q[0][b]*Q[1][a]%MOD*Q[2][c]%MOD;\n        if(a!=b && b<(int)Q[0].size() && c<(int)Q[1].size() && a<(int)Q[2].size())\n            ans += Q[0][b]*Q[1][c]%MOD*Q[2][a]%MOD;\n        if(b!=c && c<(int)Q[0].size() && a<(int)Q[1].size() && b<(int)Q[2].size())\n            ans += Q[0][c]*Q[1][a]%MOD*Q[2][b]%MOD;\n        if(a!=b && b!=c && c<(int)Q[0].size() && b<(int)Q[1].size() && a<(int)Q[2].size())\n            ans += Q[0][c]*Q[1][b]%MOD*Q[2][a]%MOD;\n        ans %= MOD;\n    };\n    for(int i=1; i<=maxi; ++i)\n    {\n        add_ans(1, i, i);\n        adj[i][i] = true;\n    }\n    for(int i=2; i<=maxi; ++i)\n    {\n        vector<bool> used(maxi+1, false);\n        for(int j=i+1; j<=maxi; ++j)\n        {\n            if(used[j]) continue;\n            for(int k=j+1; k<=maxi; ++k)\n            {\n                if(!adj[j][k])\n                {\n                    adj[j][k] = adj[k][j] = true;\n                    used[k] = used[j] = true;\n                    add_ans(i, j, k);\n                }\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\ntypedef long long LL;\n\nconst int N=100005;\nconst int MOD=998244353;\n\nint n,val[N],sg[3][N],s[3][N*2],tim[N],tmp[N*2];\nstd::vector<int> e[N];\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tval[1]=1;\n\tfor (int i=1;i<=18;i++) val[1]=(LL)val[1]*10%MOD;\n\tfor (int i=2;i<=n;i++) val[i]=(LL)val[i-1]*val[1]%MOD;\n\tint mx[3]={0},now=0;\n\tfor (int k=0;k<3;k++)\n\t{\n\t\tint m;scanf(\"%d\",&m);\n\t\tfor (int i=1;i<=m;i++)\n\t\t{\n\t\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\t\te[x].pb(y);e[y].pb(x);\n\t\t}\n\t\tfor (int i=n;i>=1;i--)\n\t\t{\n\t\t\tnow++;\n\t\t\tfor (int to:e[i]) if (to>i) tim[sg[k][to]]=now;\n\t\t\tfor (sg[k][i]=0;tim[sg[k][i]]==now;sg[k][i]++);\n\t\t\tmx[k]=std::max(mx[k],sg[k][i]);\n\t\t\te[i].clear();\n\t\t}\n\t}\n\tfor (int k=0;k<3;k++)\n\t\tfor (int i=1;i<=n;i++)\n\t\t\t(s[k][sg[k][i]]+=val[i])%=MOD;\n\tfor (int i=0;i<=mx[0];i++)\n\t\tfor (int j=0;j<=mx[1];j++)\n\t\t\t(tmp[i^j]+=(LL)s[0][i]*s[1][j]%MOD)%=MOD;\n\tint ans=0;\n\tfor (int i=0;i<=mx[2];i++)\n\t\t(ans+=(LL)s[2][i]*tmp[i]%MOD)%=MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<long double> base;\nconst double pi=acos(-1.);\nconst int MX=132132,md=998244353;\nint n,m,it,ut,i,x,y,res,u[MX],a[3][MX],mx[3];\nlong long cnt[3][MX];\nvector<int> g[MX];\nlong long pw10(long long x) {\n  if (x==0) return 1LL;\n  if (x&1) return (pw10(x-1)*10LL)%md;\n  long long z=pw10(x/2);\n  return (z*z)%md;\n}\nint main() {\n  scanf(\"%d\",&n);\n  for (it=0; it<3; it++) {\n    for (i=1; i<=n; i++) g[i].clear();\n    scanf(\"%d\",&m);\n    while (m--) {\n      scanf(\"%d%d\",&x,&y);\n      g[min(x,y)].push_back(max(x,y));\n    }\n    for (i=n; i>0; i--) {\n      ++ut;\n      for (x=0; x<g[i].size(); x++) u[a[it][g[i][x]]]=ut;\n      for (a[it][i]=0; u[a[it][i]]==ut; a[it][i]++);\n      cnt[it][a[it][i]]=(cnt[it][a[it][i]]+pw10(18*i))%md;\n      mx[it]=max(mx[it],a[it][i]);\n    }\n  }\n  for (i=0; i<=mx[0]; i++) if (cnt[0][i]) for (x=0; x<=mx[1]; x++) if (cnt[1][x] && cnt[2][i^x])\n    res=(res+((cnt[0][i]*cnt[1][x])%md)*cnt[2][i^x])%md;\n  printf(\"%d\\n\",res);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mod=998244353;\n#define Rint register int\n#define C(n,m) (n<m?0:1ll*fac[n]*invfac[n-m]%mod*invfac[m]%mod)\nusing namespace std;\nint T,n,m,p,k,dp[3][100010],sg[100010],ans=0,ksm_18[100010];\nbool vis[1010];\nstruct edge{\n\tint to,link,w;\n};\nstruct graph{\n\tint head[100010],o;\n\tedge e[2000010];\n\tvoid clear(){\n\t\tmemset(head,0,sizeof(head));\n\t\to=0;\n\t}\n\tvoid add_edge(int u,int v){\n\t\te[++o].to=v,e[o].link=head[u],head[u]=o;\n\t\te[++o].to=u,e[o].link=head[v],head[v]=o;\n\t}\n}g[3];\nint main(){\n\tscanf(\"%d\",&n);\n\tksm_18[0]=1,ksm_18[1]=(1000000000000000000ll)%mod;\n\tfor(int i=2;i<=n;i++) ksm_18[i]=1ll*ksm_18[i-1]*ksm_18[1]%mod; \n\tfor(int t=0;t<3;t++){\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=1,u,v;i<=m;i++) scanf(\"%d%d\",&u,&v),g[t].add_edge(u,v);\n\t\tfor(int u=n;u>=1;u--){\n\t\t\tsg[u]=0;\n\t\t\tfor(int i=g[t].head[u];i;i=g[t].e[i].link) if(g[t].e[i].to>u) vis[sg[g[t].e[i].to]]=true;\n\t\t\twhile(vis[sg[u]]) sg[u]++;\n//\t\t\tcout<<sg[u]<<\" \";\n\t\t\tdp[t][sg[u]]=(dp[t][sg[u]]+ksm_18[u])%mod;\n\t\t\tfor(int i=g[t].head[u];i;i=g[t].e[i].link) if(g[t].e[i].to>u) vis[sg[g[t].e[i].to]]=false;\n\t\t}\n//\t\tcout<<\"\\n\";\n\t}\n\tfor(int i=0;i<=1000;i++) for(int j=0;j<=1000;j++) ans=(ans+1ll*dp[0][i]*dp[1][j]%mod*dp[2][i^j])%mod;\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define TR(X) ({ if(1) cerr << \"TR: \" << (#X) << \" = \" << (X) << endl; })\n\n// const ll N = 3e5 + 10, MOD = 998244353*1e9, A = 100;\nconst ll N = 3e5 + 10, MOD = 998244353, A = ll(1e18) % MOD;\nll Apow[N];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tApow[0] = 1;\n\tFOR(i,1,N) Apow[i] = A*Apow[i-1] % MOD;\n\n\tll n; cin >> n;\n\n\tvl u = {1,0};\n\t\n\tFOR(dim,0,3) {\n\t\tll m; cin >> m;\n\t\tvvl adj(n);\n\t\twhile (m--) {\n\t\t\tll a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tif (a < b) swap(a,b);\n\t\t\tadj[a].pb(b);\n\t\t}\n\t\n\t\tvl col(n);\n\t\tFORD(i,0,n) if (col[i] == 0) {\n\t\t\tfor (ll j: adj[i]) col[j] = 1;\n\t\t}\n\t\t\n\t\tFORD(i,0,n) if (col[i] == 1) {\n\t\t\tfor (ll j: adj[i]) if (col[j] == 1) col[j] = 2;\n\t\t}\n\n\t\tvl v(2);\n\t\tFOR(i,0,n) if (col[i] < 2) v[col[i]] = (v[col[i]] + Apow[i+1]) % MOD;\n\t\t\n\t\tvl w(2);\n\t\tFOR(i,0,2) FOR(j,0,2) {\n\t\t\tw[i^j] += u[i]*v[j];\t\n\t\t}\n\t\tFOR(i,0,2) w[i] %= MOD;\n\t\tu = w;\n\t\t// cerr << u[0] << \" \" << u[1] << endl;\n\t}\n\tcout << u[0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\n#ifdef zxc\n\n#include \"debug.h\"\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nusing ll = int64_t;\nusing ld = long double;\nconst ld EPS = 1e-8;\nconst ll MOD = 998244353;\nconst ld PI = 3.141592653589793;\nconst int maxn = 100001;\n\nvoid fast_io() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n}\n\nvector<int> g[3][maxn];\nint grun[3][maxn];\nll cnt[3][maxn];\nll pw[3 * maxn];\n\nsigned main() {\n#ifdef zxc\n    mt19937 mt(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n    freopen(\"../kolya_input.txt\", \"r\", stdin);\n//    freopen(\"../kolya_output.txt\", \"w\", stdout);\n#else\n    mt19937 mt(228);\n//            freopen(\"\", \"r\", stdin);\n//        freopen(\"hack.out\", \"w\", stdout);\n#endif\n    fast_io();\n    cout.precision(10);\n    cout << fixed;\n    auto start = chrono::steady_clock::now();\n///\n\n    int n;\n    cin>>n;\n    int m[3];\n    for (int i = 0; i < 3; ++i) {\n        cin >> m[i];\n        for (int j = 1; j <= m[i]; ++j) {\n            int a, b;\n            cin >> a >> b;\n            if (a > b) {\n                swap(a, b);\n            }\n            g[i][a].push_back(b);\n        }\n    }\n    vector<int> vals;\n    vals.reserve(n + 1);\n    vector<int> used(n + 1);\n    for (int i = 0; i < 3; ++i) {\n        for (int j = n; j >= 1; --j) {\n            for (int to:g[i][j]) {\n                vals.push_back(to);\n                used[grun[i][to]] = 1;\n            }\n            for (int e = 0; e <= n; ++e) {\n                if (!used[e]) {\n                    grun[i][j] = e;\n                    break;\n                }\n            }\n            while (!vals.empty()) {\n                used[grun[i][vals.back()]] = 0;\n                vals.pop_back();\n            }\n        }\n    }\n//    for (int i = 1; i <= n; ++i) {\n//        debug(i,grun[2][i]);\n//    }\n    ll bs = (ll) 1e18 % MOD;\n    pw[0] = 1;\n    for (int i = 1; i <= 3 * n; ++i) {\n        pw[i] = pw[i - 1] * bs % MOD;\n    }\n\n\n    int mx_val = 0;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            cnt[i][grun[i][j]] += pw[j];\n            if (cnt[i][grun[i][j]] >= MOD) {\n                cnt[i][grun[i][j]] -= MOD;\n            }\n            mx_val = max(mx_val, grun[i][j]);\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 0; i <= mx_val; ++i) {\n        for (int h = 0; h <= mx_val; ++h) {\n            int need = i ^h;\n            ans += cnt[0][i] * cnt[1][h] % MOD * cnt[2][need] % MOD;\n            if (ans >= MOD) {\n                ans -= MOD;\n            }\n        }\n    }\n    cout << ans;\n\n///\n    auto end = chrono::steady_clock::now();\n    debug(\"time\", chrono::duration_cast<chrono::milliseconds>(end - start).count() / 1000.0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 998244353;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\ntemplate<typename T>\nvector<T> compress(vector<T> A){\n    sort(A.begin(), A.end());\n    A.erase(unique(A.begin(), A.end()), A.end());\n    return A;\n}\n\nint main(){\n    int N;\n    cin >> N;\n\n    vector<int64_t> pw18(N+1, 1);\n    int64_t B = int64_t(1e18) % MOD;\n    for(int i=1; i<=N; i++) pw18[i] = pw18[i-1] * B % MOD;\n\n    auto mex = [](vector<int>& V){\n        V = compress(V);\n        int sz = V.size();\n        for(int i=0; i<sz; i++) if(V[i] != i) return i;\n        return sz;\n    };\n    \n    vector<int64_t> sum[3];\n    int sz[3];\n    for(int k=0; k<3; k++){\n        int M;\n        cin >> M;\n        vector<int> edges[100000];\n        while(M--){\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            if(a > b) swap(a, b);\n            edges[a].push_back(b);\n        }\n        vector<int> G(N);\n        for(int i=N-1; i>=0; i--){\n            vector<int> V;\n            for(int j : edges[i]) V.push_back(G[j]);\n            G[i] = mex(V);\n        }\n        sz[k] = *max_element(G.begin(), G.end()) + 1;\n        sum[k].resize(sz[k]);\n        for(int i=0; i<N; i++) add(sum[k][G[i]], pw18[i+1]);\n    }\n\n    int64_t ans = 0;\n    for(int i=0; i<sz[0]; i++) for(int j=0; j<sz[1]; j++){\n        int k = i^j;\n        if(k < sz[2]) add(ans, sum[0][i] * sum[1][j] % MOD * sum[2][k]);\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5, mod = 998244353;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\n#define eb emplace_back\n\nint n, m, sg[maxn], cnt[3][maxn], mx[3], vis[maxn], pw[maxn];\nvector<int> e[maxn];\n\nvoid solve(int *cnt, int &mx)\n{\n\tm = gi();\n\tfor (int i = 1; i <= n; ++i) e[i].clear();\n\tfor (int u, v, i = 1; i <= m; ++i) {\n\t\tu = gi(); v = gi();\n\t\tif (u > v) swap(u, v);\n\t\te[u].eb(v);\n\t}\n\tfill(vis, vis + n + 1, 0);\n\tfor (int u = n; u >= 1; --u) {\n\t\tfor (int v : e[u]) vis[sg[v]] = u;\n\t\tint mex = 0;\n\t\twhile (vis[mex] == u) ++mex;\n\t\tmx = max(mx, sg[u] = mex);\n\t\tcnt[sg[u]] = (cnt[sg[u]] + pw[u]) % mod;\n\t}\n}\n\nint main()\n{\n\tn = gi();\n\tint base = ((ll)1e18) % mod;\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) pw[i] = (ll)pw[i - 1] * base % mod;\n\tfor (int i = 0; i < 3; ++i) solve(cnt[i], mx[i]);\n\n\tint ans = 0;\n\tfor (int i = 0; i <= mx[0]; ++i)\n\t\tfor (int j = 0; j <= mx[1]; ++j)\n\t\t\tans = (ans + (ll)cnt[0][i] * cnt[1][j] % mod * cnt[2][i ^ j]) % mod;\n\tprintf(\"%d\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <cmath>\n#include <utility>\n#include <functional>\n#include <map>\n#include <set>\n#include <cctype>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <cstring>\nusing namespace std;\nusing ll = long long;\n#define ALL(a) (a).begin(), (a).end()\n\n#define FOR(i, a, b) for (long long int i = (a); i <= (b); i++)\n#define RFOR(i, a, b) for (long long int i = (a); i >= (b); i--)\n\n//#define MOD 1000000007\nconst int MOD = 2;\n\n#define LLONG_MAXs 9223372036854775800 / 2\n//#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\n#define ALL(a) (a).begin(), (a).end()\n\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nbool isPrimeNum(ll x)\n{ // 素数である場合 true を返す\n    if (x <= 1)\n    { // 1以下である場合は素数でないことがすぐにわかる\n        return false;\n    }\n    // sqrt( double型 ) は引数の平方根を double型で返すので、int型でキャスト\n    int n = (int)sqrt((double)x);\n    for (int i = 2; i <= n; i++)\n    {\n        if (x % i == 0)\n        { // 割り切る整数がある場合、即判定終了\n            return false;\n        }\n    }\n    return true; // 割り切る整数がない場合、素数である\n}\n\nll myPow(ll x, ll n, ll m)\n{\n    if (n == 0)\n        return 1;\n    if (n % 2 == 0)\n        return myPow(x * x % m, n / 2, m);\n    else\n        return x * myPow(x, n - 1, m) % m;\n}\n\nconstexpr ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nconstexpr ll lcm(ll a, ll b) { return a * b / gcd(a, b); }\nconstexpr ll abs(ll a, ll b)\n{\n    if (a >= b)\n        return a - b;\n    if (a < b)\n        return b - a;\n}\nconstexpr double dabs(double a, double b)\n{\n    if (a >= b)\n        return a - b;\n    if (a < b)\n        return b - a;\n}\nconstexpr ll min(ll a, ll b)\n{\n    if (a >= b)\n        return b;\n    if (a < b)\n        return a;\n}\n\nconstexpr ll max(ll a, ll b)\n{\n    if (a >= b)\n        return a;\n    if (a < b)\n        return b;\n}\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint dx8[8] = {1, 0, -1, 0, 1, -1, 1, -1};\nint dy8[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nclass UnionFind\n{\npublic:\n    //親の番号を格納する。親だった場合は-(その集合のサイズ)\n    vector<int> Parent;\n\n    //作るときはParentの値を全て-1にする\n    //こうすると全てバラバラになる\n    UnionFind(int N)\n    {\n        Parent = vector<int>(N, -1);\n    }\n\n    //Aがどのグループに属しているか調べる\n    int root(int A)\n    {\n        if (Parent[A] < 0)\n            return A;\n        return Parent[A] = root(Parent[A]);\n    }\n\n    //自分のいるグループの頂点数を調べる\n    int size(int A)\n    {\n        return -Parent[root(A)]; //親をとってきたい]\n    }\n    bool issame(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    //AとBをくっ付ける\n    bool connect(int A, int B)\n    {\n        //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        if (A == B)\n        {\n            //すでにくっついてるからくっ付けない\n            return false;\n        }\n\n        //大きい方(A)に小さいほう(B)をくっ付けたい\n        //大小が逆だったらひっくり返しちゃう。\n        if (size(A) < size(B))\n            swap(A, B);\n\n        //Aのサイズを更新する\n        Parent[A] += Parent[B];\n        //Bの親をAに変更する\n        Parent[B] = A;\n\n        return true;\n    }\n};\n\nlong long fac[1010000], finv[1010000], inv[1010000];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < 1010000; i++)\n    {\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n    if (n < k)\n        return 0;\n    if (n < 0 || k < 0)\n        return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long modinv(long long a, long long m)\n{\n    long long b = m, u = 1, v = 0;\n    while (b)\n    {\n        long long t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n\nvoid yn(bool flag)\n{\n    if (flag)\n    {\n        cout << \"Yes\" << endl;\n    }\n    else\n    {\n        cout << \"No\" << endl;\n    }\n    return;\n}\nvoid YN(bool flag)\n{\n    if (flag)\n    {\n        cout << \"YES\" << endl;\n    }\n    else\n    {\n        cout << \"NO\" << endl;\n    }\n    return;\n}\n\nstd::vector<ll> enum_div(ll n) //nの約数を列挙\n{\n    std::vector<ll> ret;\n    for (ll i = 1; i * i <= n; ++i)\n    {\n        if (n % i == 0)\n        {\n            ret.push_back(i);\n            if (i != 1 && i * i != n)\n            {\n                ret.push_back(n / i);\n            }\n        }\n    }\n    ret.push_back(n);\n    return ret;\n}\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate <int MOD>\nstruct Fp\n{\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD)\n    {\n        if (val < 0)\n            val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator-() const noexcept\n    {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator+(const Fp &r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator-(const Fp &r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator*(const Fp &r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator/(const Fp &r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp &operator+=(const Fp &r) noexcept\n    {\n        val += r.val;\n        if (val >= MOD)\n            val -= MOD;\n        return *this;\n    }\n    constexpr Fp &operator-=(const Fp &r) noexcept\n    {\n        val -= r.val;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr Fp &operator*=(const Fp &r) noexcept\n    {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp &operator/=(const Fp &r) noexcept\n    {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b)\n        {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0)\n            val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const Fp &r) const noexcept\n    {\n        return this->val == r.val;\n    }\n    constexpr bool operator!=(const Fp &r) const noexcept\n    {\n        return this->val != r.val;\n    }\n    friend constexpr ostream &operator<<(ostream &os, const Fp<MOD> &x) noexcept\n    {\n        return os << x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept\n    {\n        if (n == 0)\n            return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1)\n            t = t * a;\n        return t;\n    }\n};\n\nusing mint = Fp<MOD>;\n\n// グラフセット\nstruct Edge\n{\n    ll to;     // 辺の行き先\n    ll weight; // 辺の重み\n    Edge(int t, int w) : to(t), weight(w) {}\n};\n//using Graph = vector<vector<Edge>>;\n#define def 0\ntemplate <class V, int NV>\nstruct SegTree\n{ //[l,r)\n    V comp(V &l, V &r) { return max(l, r); };\n\n    vector<V> val;\n    SegTree() { val = vector<V>(NV * 2, def); }\n    V get(int x, int y, int l = 0, int r = NV, int k = 1)\n    {\n        if (r <= x || y <= l)\n            return def;\n        if (x <= l && r <= y)\n            return val[k];\n        auto a = get(x, y, l, (l + r) / 2, k * 2);\n        auto b = get(x, y, (l + r) / 2, r, k * 2 + 1);\n        return comp(a, b);\n    }\n    void update(int i, V v)\n    {\n        i += NV;\n        val[i] = v;\n        while (i > 1)\n            i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);\n    }\n    void add(int i, V v) { update(i, val[i + NV] + v); }\n    V operator[](int x) { return get(x, x + 1); }\n};\n\ntypedef vector<vector<long long>> matrix;\nmatrix mul_mod(matrix A, matrix B)\n{\n    int H = A.size();\n    int W = B[0].size();\n    int K = A[0].size();\n\n    matrix C(H, vector<ll>(W, 0));\n    for (int i = 0; i < H; i++)\n    {\n        for (int j = 0; j < W; j++)\n        {\n            for (int k = 0; k < K; k++)\n            {\n                C[i][j] += A[i][k] * B[k][j];\n                C[i][j] %= MOD;\n            }\n        }\n    }\n    return C;\n}\nmatrix pow_mod_matrix(matrix A, ll p)\n{\n    matrix ret = matrix(A.size(), vector<long long>(A.size(), 0));\n    for (int i = 0; i < A.size(); i++)\n        ret[i][i] = 1;\n\n    while (p > 0)\n    {\n        if (p & 1)\n            ret = mul_mod(ret, A);\n        A = mul_mod(A, A);\n        p >>= 1;\n    }\n    return ret;\n}\n// 区間加算にも対応した BIT\ntemplate <class Abel>\nstruct BIT\n{\n    vector<Abel> dat[2];\n    Abel UNITY_SUM = 0; // to be set\n\n    /* [1, n] */\n    BIT(int n) { init(n); }\n    void init(int n)\n    {\n        for (int iter = 0; iter < 2; ++iter)\n            dat[iter].assign(n + 1, UNITY_SUM);\n    }\n\n    /* a, b are 1-indexed, [a, b) */\n    inline void sub_add(int p, int a, Abel x)\n    {\n        for (int i = a; i < (int)dat[p].size(); i += i & -i)\n            dat[p][i] = dat[p][i] + x;\n    }\n    inline void add(int a, int b, Abel x)\n    {\n        sub_add(0, a, x * -(a - 1));\n        sub_add(1, a, x);\n        sub_add(0, b, x * (b - 1));\n        sub_add(1, b, x * (-1));\n    }\n\n    /* a is 1-indexed, [a, b) */\n    inline Abel sub_sum(int p, int a)\n    {\n        Abel res = UNITY_SUM;\n        for (int i = a; i > 0; i -= i & -i)\n            res = res + dat[p][i];\n        return res;\n    }\n    inline Abel sum(int a, int b)\n    {\n        return sub_sum(0, b - 1) + sub_sum(1, b - 1) * (b - 1) - sub_sum(0, a - 1) - sub_sum(1, a - 1) * (a - 1);\n    }\n\n    /* debug */\n    void print()\n    {\n        for (int i = 1; i < (int)dat[0].size(); ++i)\n            cout << sum(i, i + 1) << \",\";\n        cout << endl;\n    }\n};\n//cout << std::setprecision(30) << ans << endl;\n\nusing Graph = vector<vector<Edge>>;\n\nint main(void)\n{\n    COMinit();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e5+10, mod = 998244353;\nint n,m,pw[N],s[3][N],mx[3];\n\nstruct Graph{\n\tvector<int>e[N];\n\tinline void Add(int x,int y){\n\t\tif (x>y) swap(x,y);\n\t\te[x].pb(y);\n\t}\n\tint sg[N],vis[N];\n\tinline void Get(){\n\t\tDow(i,n,1){\n\t\t\tfor (auto j:e[i]) vis[sg[j]]++;\n\t\t\twhile (vis[sg[i]]) ++sg[i];\n\t\t\tfor (auto j:e[i]) vis[sg[j]]--;\n\t\t}\n\t}\n}G[3];\n\ninline void upd(int &x,int y){\n\tx+=y;\n\tif (x>=mod) x-=mod;\n}\n\nint main(){\n\tn=read();\n\tFor(i,0,2){\n\t\tm=read();\n\t\tFor(j,1,m) G[i].Add(read(),read());\n\t\tG[i].Get();\n\t}\n\tpw[0]=1,pw[1]=1000000000000000000ll%mod;\n\tFor(i,2,n) pw[i]=1ll*pw[i-1]*pw[1]%mod;\n\tFor(i,0,2) For(j,1,n) upd(s[i][G[i].sg[j]],pw[j]),mx[i]=max(mx[i],G[i].sg[j]);\n\tint ans=0;\n\tFor(i,0,mx[0]) For(j,0,mx[1]) ans=(ans+1ll*s[0][i]*s[1][j]%mod*s[2][i^j])%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5+10, P = 998244353;\nint n, m, vis[N], sg[N], h[N], f[3][N];\nvector<int> g[N];\nvoid add(int &a, ll b) {a=(a+b)%P;}\n\nint main() {\n\th[1] = 1000000000000000000ll%P;\n\tREP(i,2,N-1) h[i] = (ll)h[i-1]*h[1]%P;\n\tscanf(\"%d\", &n);\n\tREP(i,0,2) {\n\t\tscanf(\"%d\", &m);\n\t\tREP(j,1,n) g[j].clear();\n\t\tREP(j,1,m) {\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\tif (u>v) swap(u,v);\n\t\t\tg[u].pb(v);\n\t\t}\n\t\tPER(j,1,n) {\n\t\t\tint sz = g[j].size();\n\t\t\tREP(k,0,sz) vis[k] = 0;\n\t\t\tfor (int k:g[j]) vis[sg[k]] = 1;\n\t\t\tREP(k,0,sz) if (!vis[k]) {\n\t\t\t\tsg[j] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tadd(f[i][sg[j]],h[j]);\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i,0,400) REP(j,0,400) {\n\t\tadd(ans, (ll)f[0][i]*f[1][j]%P*f[2][i^j]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* preprocessor start */\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n/*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n//    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define iostream_untie true\n#include <bits/stdc++.h>\n#include <ext/rope>\n#define __all(v) std::begin(v), std::end(v)\n#define __rall(v) std::rbegin(v), std::rend(v)\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n/* preprocessor end */\n\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n#else\n    #define dump(...) ((void)0)\n#endif\n\n/* function utility start */\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n/*\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n#define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n*/\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n/* functon utility end */\n\n/* using alias start */\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n/* using alias end */\n\n/* library start */\n\n\n\n/* library end */\n\n/* The main code follows. */\n\nstruct solver; template <class T = solver> void _main();\nint main() { _main<>(); }\n\ntemplate <class solver>\nvoid _main()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\nstruct solver\n{\n\n    solver()\n    {\n\n    }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int mod=998244353;\n#define Rint register int\n#define C(n,m) (n<m?0:1ll*fac[n]*invfac[n-m]%mod*invfac[m]%mod)\nusing namespace std;\nint T,n,m,p,k,dp[3][100010],sg[100010],ans=0,ksm_18[100010];\nbool vis[1010];\nstruct edge{\n\tint to,link,w;\n};\nstruct graph{\n\tint head[100010],o;\n\tedge e[2000010];\n\tvoid clear(){\n\t\tmemset(head,0,sizeof(head));\n\t\to=0;\n\t}\n\tvoid add_edge(int u,int v){\n\t\te[++o].to=v,e[o].link=head[u],head[u]=o;\n\t\te[++o].to=u,e[o].link=head[v],head[v]=o;\n\t}\n}g[3];\nint main(){\n\tscanf(\"%d\",&n);\n\tksm_18[0]=1,ksm_18[1]=(1000000000000000000ll)%mod;\n\tfor(int i=2;i<=n;i++) ksm_18[i]=1ll*ksm_18[i-1]*ksm_18[1]%mod; \n\tfor(int t=0;t<3;t++){\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=1,u,v;i<=m;i++) scanf(\"%d%d\",&u,&v),g[t].add_edge(u,v);\n\t\tfor(int u=n;u>=1;u--){\n\t\t\tsg[u]=0;\n\t\t\tfor(int i=g[t].head[u];i;i=g[t].e[i].link) if(g[t].e[i].to>u) vis[sg[g[t].e[i].to]]=true;\n\t\t\twhile(vis[sg[u]]) sg[u]++;\n//\t\t\tcout<<sg[u]<<\" \";\n\t\t\tdp[t][sg[u]]=(dp[t][sg[u]]+ksm_18[u])%mod;\n\t\t\tfor(int i=g[t].head[u];i;i=g[t].e[i].link) if(g[t].e[i].to>u) vis[sg[g[t].e[i].to]]=false;\n\t\t}\n//\t\tcout<<\"\\n\";\n\t}\n\tfor(int i=0;i<=1000;i++) for(int j=0;j<=1000;j++) ans=(ans+1ll*dp[0][i]*dp[1][j]%mod*dp[2][i^j])%mod;\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\nconst int MAXN = 1e5 + 11;\nconst int MAXM = 444;\nconst int mod = 998244353;\n#define FOR(i, a, b) for(int i = (a);i <= (b); i++)\n#define ROF(i, a, b) for(int i = (a);i >= (b); i--)\nint n, m;\nint f[3][MAXM], sg[MAXN], mark[MAXM];\nvector<int> G[MAXN];\nvoid Add(int &x, int y){\n    x = x + y - (x + y >= mod ? mod : 0);\n}\nvoid Mu(int &x, int y){\n    x = 1LL * x * y % mod;\n}\nint A(int x, int y){\n    return x + y - (x + y >= mod ? mod : 0);\n}\nint M(int x, int y){\n    return 1LL * x * y % mod;\n}\nint ksm(int base, int x){\n    base %= mod;\n    int ans = 1;\n    while(x){\n        if(x & 1)Mu(ans, base);\n        x >>= 1;\n        Mu(base, base);\n    }\n    return ans;\n}\nint main(){\n    cin>>n;\n    FOR(t, 0, 2){\n        cin>>m;\n        int u, v;\n        memset(sg, -1, sizeof sg);\n        memset(mark, 0, sizeof mark);\n        FOR(i, 1, m){\n            scanf(\"%d%d\", &u, &v);\n            if(u < v)swap(u, v);\n            G[v].push_back(u);\n        }\n        ROF(u, n, 1){\n            for(int v : G[u]){\n                mark[sg[v]] = u;\n            }\n            sg[u] = 0;\n            while(mark[sg[u]] == u)sg[u]++;\n            Add(f[t][sg[u]], ksm((LL)(1e18 + 0) % mod, u));\n            G[u].clear();\n            //printf(\"u=%d sg=%d\\n\", u, sg[u]);\n        }\n    }\n    int ans = 0;\n    FOR(i, 0, 500){\n        FOR(j, 0, 500){\n            Add(ans, M(M(f[0][i],f[1][j]), f[2][i^j]));\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < (n); i++)\n#define forr(i,a,b) for (int i = (a); i <= (b); i++)\n#define all(v) v.begin(), v.end()\n#define pb push_back\n \nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ii> vii;\n\nconst int MX = 100005, mod = 998244353, SQ = (1 << 9);\nint n, m, inv2, f[MX];\nll a[3][SQ], res;\nvi adj[MX];\n\nll pot (ll b, int p) {\n\tll res = 1;\n\twhile (p) {\n\t\tif (p & 1) (res *= b) %= mod;\n\t\t(b *= b) %= mod;\n\t\tp /= 2;\n\t}\n\treturn res;\n}\n\nvoid dfs (int u) {\n\tif (f[u] != -1) return;\n\n\tset<int> st;\n\tfor (int v : adj[u])\n\t\tif (v > u) {\n\t\t\tdfs(v);\n\t\t\tst.insert(f[v]);\n\t\t}\n\n\tfor (int i = 0;; i++)\n\t\tif (!st.count(i)) {\n\t\t\tf[u] = i;\n\t\t\tbreak;\n\t\t}\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinv2 = pot(2, mod - 2);\n\n\tcin >> n;\n\tforn (i, 3) {\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tadj[j].clear();\n\n\t\tcin >> m;\n\t\twhile (m--) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tadj[a].pb(b);\n\t\t\tadj[b].pb(a);\n\t\t}\n\n\t\tmemset(f, -1, sizeof(f));\n\t\tfor (int j = 1; j<= n; j++) {\n\t\t\tdfs(j);\n\t\t\t(a[i][f[j]] += pot(10, 18 * j)) %= mod;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < SQ; i++)\n\t\tfor (int j = 0; j < SQ; j++)\n\t\t\t(res += a[0][i] * a[1][j] % mod * a[2][i ^ j]) %= mod;\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 998244353;\nconst int N = 1e5+7;\nconst long long B = 1000000000000000000;\ntypedef long long LL;\n\nLL pb[N];\nvoid pre() {\n    pb[0] = 1;\n    LL b = B%M;\n    for (int i=1; i<N; i++)\n        pb[i] = (pb[i-1]*b)%M;\n}\n\nvector<int> bfs(vector<vector<int>>adj) {\n    int n = adj.size()-1;\n    vector<int> col(n+1, N);\n\n    vector<bool> vis(n);\n    for (int i=n; i>0; i--) {\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 1;\n        }\n\n        for (int ii=0; ii<=n; ii++)\n            if (!vis[ii]) {\n                col[i] = ii;\n                break;\n            }\n\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 0;\n        }\n    }\n    return col;\n}\n\nint m[3];\nvector<vector<int>> adj[3];\nvector<int> dis[3];\nvector<LL> con[3];\n\nint main() {\n    pre();\n\n    int n;\n    cin>>n;\n    const int MX = 1<<17;\n\n    for (int g=0; g<3; g++) {\n        cin>>m[g];\n        adj[g].resize(n+1);\n        for (int i=0; i<m[g]; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[g][u].push_back(v);\n            adj[g][v].push_back(u);\n        }\n        dis[g] = bfs(adj[g]);\n\n        con[g].resize(MX);\n        for (int i=1; i<=n; i++) {\n            con[g][dis[g][i]] = (con[g][dis[g][i]] + pb[i])%M;\n        }\n    }\n    LL ans = 0;\n    for (int i=0; i<MX; i++) {\n        if (con[0][i] == 0) continue;\n        for (int j=0; j<MX; j++) {\n            if (con[1][j] == 0)  continue;\n            ans = (ans + ((con[0][i]*con[1][j])%M)*con[2][i^j])%M;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100000,mod=998244353;\n \nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m[3];\nstruct side{\n  int y,next;\n}e[N*6+9];\nint lin[3][N+9],cs;\n\nvoid Ins(int id,int x,int y){e[++cs].y=y;e[cs].next=lin[id][x];lin[id][x]=cs;}\nvoid Ins2(int id,int x,int y){Ins(id,x,y);Ins(id,y,x);}\n\nvoid into(){\n  scanf(\"%d\",&n);\n  for (int i=0;i<3;++i){\n\tscanf(\"%d\",&m[i]);\n\tfor (int j=1;j<=m[i];++j){\n\t  int x,y;\n\t  scanf(\"%d%d\",&x,&y);\n\t  Ins2(i,x,y);\n\t}\n  }\n}\n\nint pw[N+9];\n\nvoid Get_pw(){\n  int pw18=1;\n  for (int i=1;i<=18;++i) smul(pw18,10);\n  pw[0]=1;\n  for (int i=1;i<=n;++i) pw[i]=mul(pw[i-1],pw18);\n}\n\nint sg[3][N+9],b[N+9];\nint sum[3][N+9],mx[3];\n\nvoid Get_sg(int id){\n  for (int i=n;i>=1;--i){\n\tfor (int j=lin[id][i];j;j=e[j].next)\n\t  if (e[j].y>i) b[sg[id][e[j].y]]=1;\n    for (;b[sg[id][i]];++sg[id][i]);\n\tsadd(sum[id][sg[id][i]],pw[i]);\n\tmx[id]=max(mx[id],sg[id][i]);\n\tfor (int j=lin[id][i];j;j=e[j].next) b[sg[id][e[j].y]]=0;\n  }\n}\n\nint ans;\n\nvoid Get_ans(){\n  for (int i=0;i<=mx[0];++i)\n\tfor (int j=0;j<=mx[1];++j) sadd(ans,mul(mul(sum[0][i],sum[1][j]),sum[2][i^j]));\n}\n\nvoid work(){\n  Get_pw();\n  Get_sg(0);\n  Get_sg(1);\n  Get_sg(2);\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<climits>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<set>\n#include<map>\n#define ll long long\nusing namespace std;\n//{{{ read()\ninline int read(){\n\tregister int x=0,f=1;\n\tregister char ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-')\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\tx=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\n//}}}\nconst int N=1e5+5;\nconst int P=998244353;\nconst int d=1000000000000000000ll%P;\nvector<int>A[N],B[N],C[N];\nint n,m,mx,f[N],a[N],b[N],f1[N],f2[N],f3[N],vi[N];\nvoid Add(int &x,int y){\n\tx+=y,x-=x>=P?P:0;\n}\nll fsp(ll x,int y){\n\tll ans=1;\n\twhile(y){\n\t\tif(y&1)\tans=ans*x%P;\n\t\tx=x*x%P,y>>=1;\n\t}\n\treturn ans;\n}\nint main(){\n\tn=read();\n\tmx=max(mx,m=read());\twhile(m--){\n\t\tint x=read(),y=read();\n\t\tif(x>y)\tswap(x,y);\t\n\t\tA[x].push_back(y);\n\t}\n\tmx=max(mx,m=read());\twhile(m--){\n\t\tint x=read(),y=read();\n\t\tif(x>y)\tswap(x,y);\t\n\t\tB[x].push_back(y);\n\t}\n\tmx=max(mx,m=read());\twhile(m--){\n\t\tint x=read(),y=read();\n\t\tif(x>y)\tswap(x,y);\t\n\t\tC[x].push_back(y);\n\t}\n\tfor(int i=n;i;i--){\n\t\tint k=0,si=A[i].size();\n\t\tfor(int j=0;j<si;j++)\tvi[f1[A[i][j]]]=1;\n\t\twhile(vi[k])\t++k;\n\t\tf1[i]=k;\n\t\tfor(int j=0;j<si;j++)\tvi[f1[A[i][j]]]=0;\n\t}\n\tfor(int i=n;i;i--){\n\t\tint k=0,si=B[i].size();\n\t\tfor(int j=0;j<si;j++)\tvi[f2[B[i][j]]]=1;\n\t\twhile(vi[k])\t++k;\n\t\tf2[i]=k;\n\t\tfor(int j=0;j<si;j++)\tvi[f2[B[i][j]]]=0;\n\t}\n\tfor(int i=n;i;i--){\n\t\tint k=0,si=C[i].size();\n\t\tfor(int j=0;j<si;j++)\tvi[f3[C[i][j]]]=1;\n\t\twhile(vi[k])\t++k;\n\t\tf3[i]=k;\n\t\tfor(int j=0;j<si;j++)\tvi[f3[C[i][j]]]=0;\n\t}\n\tfor(int i=1;i<=n;i++)\tAdd(a[f1[i]],fsp(d,i));\n\tfor(int i=1;i<=n;i++)\tAdd(b[f2[i]],fsp(d,i));\n\tint k=sqrt(mx)*2;\n\tfor(int i=0;i<=k;i++)\t\n\t\tfor(int j=0;j<=k;j++)\n\t\t\tAdd(f[i^j],1LL*a[i]*b[j]%P);\n\tfor(int i=0;i<=k;i++)\ta[i]=f[i],f[i]=0,b[i]=0;\n\tfor(int i=1;i<=n;i++)\tAdd(b[f3[i]],fsp(d,i));\n\tfor(int i=0;i<=k;i++)\t\n\t\tfor(int j=0;j<=k;j++)\n\t\t\tAdd(f[i^j],1LL*a[i]*b[j]%P);\n\tprintf(\"%d\\n\",f[0]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define MOD 1000000007\n#define MOD 998244353\n\nclass mint {\n\tpublic:\n\t\tint i;\n\n\t\tmint() : i(0) {}\n\n\t\ttemplate<class T>\n\t\t\tmint(T x) {\n\t\t\t\ti = int(x % MOD);\n\t\t\t\tif (i < 0) i += MOD;\n\t\t\t}\n\n\t\tmint operator+(mint x) {\n\t\t\treturn i + x.i;\n\t\t}\n\n\t\tmint operator-(mint x) {\n\t\t\treturn i - x.i;\n\t\t}\n\n\t\tmint operator*(mint x) {\n\t\t\treturn (long long)i * x.i;\n\t\t}\n\n\t\tmint operator/(mint x) {\n\t\t\treturn (long long)i * x.pow(MOD - 2).i;\n\t\t}\n\n\t\tmint inv() {\n\t\t\treturn pow(MOD - 2);\n\t\t}\n\n\t\ttemplate<class T>\n\t\t\tmint pow(T p) {\n\t\t\t\tlong long r = 1;\n\t\t\t\tlong long t = i;\n\t\t\t\tfor(; p > 0; p >>= 1) {\n\t\t\t\t\tif (p & 1) r = r * t % MOD;\n\t\t\t\t\tt = t * t % MOD;\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\ttemplate<class T1, class T2>\n\t\t\tstatic mint pow(T1 a, T2 b) {\n\t\t\t\tlong long r = 1;\n\t\t\t\tlong long t = (long long)(a % MOD);\n\t\t\t\tfor(; b > 0; b >>= 1) {\n\t\t\t\t\tif (b & 1) r = r * t % MOD;\n\t\t\t\t\tt = t * t % MOD;\n\t\t\t\t}\n\t\t\t\treturn r;\n\t\t\t}\n\n\t\tmint& operator+=(mint x) {\n\t\t\ti = (i + x.i) % MOD;\n\t\t\treturn *this;\n\t\t}\n\n\t\tmint& operator-=(mint x) {\n\t\t\ti = i - x.i;\n\t\t\tif (i < 0) i += MOD;\n\t\t\treturn *this;\n\t\t}\n\n\t\tmint& operator*=(mint x) {\n\t\t\ti = (int)((long long)i * x.i % MOD);\n\t\t\treturn *this;\n\t\t}\n\n\t\tmint& operator/=(mint x) {\n\t\t\ti = (long long)i * x.pow(MOD - 2).i % MOD;\n\t\t\treturn *this;\n\t\t}\n};\n\nstd::ostream& operator<<(std::ostream& os, const mint& m) {\n\treturn os << m.i;\n}\n\nstd::vector<std::vector<int>> iig(int vn, int en) { \n        std::vector<std::vector<int>> res(vn); \n        for(int i = 0; i < en; i++) { \n                int s, t; \n                std::cin >> s >> t; \n                s--; t--;\n\t\tif (s > t) swap(s, t);\n                res[s].push_back(t);\n        } \n        return res; \n}\n\nstd::vector<int> compute_grundy(std::vector<std::vector<int>>& to) {\n\tint sz = to.size();\n\tstd::vector<int> vsorted(sz);\n\tstd::vector<int> indeg(sz);\n\tfor(int i = 0; i < sz; i++) for(int j: to[i]) indeg[j]++;\n\tstd::vector<int> avail;\n\tfor(int i = 0; i < sz; i++) if (indeg[i] == 0) avail.push_back(i);\n\tint nxt_idx = 0;\n\twhile(!avail.empty()) {\n\t\tint u = avail.back(); avail.pop_back();\n\t\tvsorted[nxt_idx++] = u;\n\t\tfor(int v: to[u]) if (--indeg[v] == 0) avail.push_back(v);\n\t}\n\tstd::vector<int> grundy(sz), used(sz, -1);\n\tfor(int i = sz - 1; i >= 0; i--) {\n\t\tint u = vsorted[i];\n\t\tfor(int v: to[u]) used[grundy[v]] = u;\n\t\tint g = 0;\n\t\twhile(used[g] == u) g++;\n\t\tgrundy[u] = g;\n\t}\n\treturn grundy;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n;\n\tcin >> m;\n\tauto g1 = iig(n, m);\n\tcin >> m;\n\tauto g2 = iig(n, m);\n\tcin >> m;\n\tauto g3 = iig(n, m);\n\tauto grn1 = compute_grundy(g1);\n\tauto grn2 = compute_grundy(g2);\n\tauto grn3 = compute_grundy(g3);\t\n\t// gmax * (gmax + 1) <= E * 2\n\n\tvector<mint> w(n + 1);\n\tmint step = mint::pow(10, 18);\n\tw[0] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tw[i] = w[i-1] * step;\n\t}\n\n\tvector<mint> gcount1(500), gcount2(500), gcount3(500);\n\tfor(int i = 0; i < n; i++) {\n\t\tgcount1[grn1[i]] += w[i+1];\n\t\tgcount2[grn2[i]] += w[i+1];\n\t\tgcount3[grn3[i]] += w[i+1];\n\t}\n\n\tmint res = 0;\n\n\tfor(int i = 0; i < 500; i++)\n\t\tfor(int j = 0; j < 500; j++) {\n\t\t\tint k = i ^ j;\n\t\t\tif (k >= 500) continue;\n\t\t\tres += gcount1[i] * gcount2[j] * gcount3[k];\n\t\t}\n\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\") \n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define all(a) a.begin(), a.end()\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 2e5;\nconst ll mod = 998244353;\n\nll n, m1, m2, m3, k;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nvector <ll> A[maxn];\nvector <ll> B[maxn];\nvector <ll> C[maxn];\n\nll GA[maxn];\nll GB[maxn];\nll GC[maxn];\n\nll SA[maxn];\nll SB[maxn];\nll SC[maxn];\n\nint main() {\n    ll q, w, e, a, b, c, d, t;\n    cin >> n;\n    cin >> m1;\n    for (q = 0; q < m1; q++) {\n        cin >> a >> b;\n        a--; b--;\n        A[a].pb(b);\n        A[b].pb(a);\n    }\n    cin >> m2;\n    for (q = 0; q < m2; q++) {\n        cin >> a >> b;\n        a--; b--;\n        B[a].pb(b);\n        B[b].pb(a);\n    }\n    cin >> m3;\n    for (q = 0; q < m3; q++) {\n        cin >> a >> b;\n        a--; b--;\n        C[a].pb(b);\n        C[b].pb(a);\n    }\n    ll osn = 1000000000;\n    osn = osn * osn % mod;\n    ll mx = 0;\n    // GA[n - 1] = GB[n - 1] = GC[n - 1] = 0;\n    for (q = n - 1; q >= 0; q--) {\n        set <ll> S;\n        for (auto v1 : A[q]) {\n            if (v1 <= q) {\n                continue;\n            }\n            S.insert(GA[v1]);\n            // I.pb(GA[v1]);\n        }\n        for (w = 0; w <= n; w++) {\n            if (S.find(w) == S.end()) {\n                break;\n            }\n        }\n        GA[q] = w;\n        mx = max(GA[q], mx);\n        SA[GA[q]] += step(osn, q + 1);\n        SA[GA[q]] %= mod;\n    }\n    for (q = n - 1; q >= 0; q--) {\n        set <ll> S;\n        for (auto v1 : B[q]) {\n            if (v1 <= q) {\n                continue;\n            }\n            S.insert(GB[v1]);\n            // I.pb(GA[v1]);\n        }\n        for (w = 0; w <= n; w++) {\n            if (S.find(w) == S.end()) {\n                break;\n            }\n        }\n        GB[q] = w;\n        mx = max(GB[q], mx);\n        SB[GB[q]] += step(osn, q + 1);\n        SB[GB[q]] %= mod;\n    }\n    for (q = n - 1; q >= 0; q--) {\n        set <ll> S;\n        for (auto v1 : C[q]) {\n            if (v1 <= q) {\n                continue;\n            }\n            S.insert(GC[v1]);\n            // I.pb(GA[v1]);\n        }\n        for (w = 0; w <= n; w++) {\n            if (S.find(w) == S.end()) {\n                break;\n            }\n        }\n        GC[q] = w;\n        mx = max(GC[q], mx);\n        SC[GC[q]] += step(osn, q + 1);\n        SC[GC[q]] %= mod;\n    }\n    // ll suma = 0;\n    ll ans = 0;\n    for (q = 0; q <= mx; q++) {\n        for (w = 0; w <= mx; w++) {\n            ll x = q ^ w;\n            ll dans = SA[q] * SB[w] % mod * SC[x] % mod;\n            ans += dans;\n            ans %= mod;\n        }\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Etavioxy\n#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define il inline\n#define ll long long\n#define rep(i,s,t) for(register int i=(s);i<=(t);i++)\n#define rev_rep(i,s,t) for(register int i=(s);i>=(t);i--)\n#define each(i,u) for(int i=head[u];i;i=bow[i].nxt)\n#define file(s) freopen(s\".in\" ,\"r\",stdin),freopen(s\".out\",\"w\",stdout)\n#define pt(x) putchar(x)\nusing namespace std;\nil int ci(){\n\tregister char ch;int f=1;\n\twhile(!isdigit(ch=getchar()))f=ch=='-'?-1:1;\n\tregister int x=ch^'0';\n\twhile(isdigit(ch=getchar()))x=(x*10)+(ch^'0');\n\treturn f*x;\n}\n\nconst int mod = 998244353;\nenum{N=100023};\nil ll qpow(ll a,ll b){\n\tll ans= 1;\n\tfor(; b; b>>=1,a=a*a%mod) if( b&1 ){\n\t\tans= ans*a%mod;\n\t} return ans;\n}\nil ll inv(ll x){ return qpow(x,mod-2); }\nconst ll inv2 = inv(2);\nconst int fn = 1<<10;\nvoid FWT_XOR(ll*A,int n,int IFWT){\n\tfor(int t=1;t<n;t<<=1){\n\t\tfor(int l=0;l<n;l+=t*2){\n\t\t\trep(i,0,t-1){\n\t\t\t\tll x=A[l+i], y=A[l+t+i];\n\t\t\t\tA[l+i] = (x+y)%mod;\n\t\t\t\tA[l+t+i] = (x-y)%mod;\n\t\t\t}\n\t\t}\n\t\tif( IFWT==-1 ){\n\t\t\trep(i,0,n-1) A[i] = A[i]*inv2%mod;\n\t\t}\n\t}\n}\n\nstruct Edge{ int nxt,to; } bow[N*4];\nint head[N],tot_e;\nil void add(int x,int y){\n\tbow[++tot_e] = (Edge){head[x],y};\n\thead[x] = tot_e;\n}\n\nint s[N];\nbool vis[N];\nint dfs(int u){\n\tif( vis[u] ) return s[u];\n\tvis[u] = 1;\n\tvector<int>vec;\n\teach(i,u){\n\t\tint v = bow[i].to;\n\t\tvec.push_back(dfs(v));\n\t}\n\tsort(vec.begin(),vec.end());\n\tint n = unique(vec.begin(),vec.end())-vec.begin()-1;\n\tvec.resize(n+2); vec[n+1] = -1;\n\tint ans = -1;\n\trep(i,0,n+1) if( vec[i]!=i ){ ans = i; break; }\n\treturn s[u] = ans;\n}\n\nll f[N],g[N];\n\nint main(){\n\tint n = ci();\n\tstatic ll pow1[N];\n\tll P = qpow(10,18); pow1[0]=1;\n\trep(i,1,n) pow1[i] = pow1[i-1]*P%mod;\n\trep(i,0,fn-1) f[i] = 1;\n\tint T = 3;\n\twhile( T-- ){\n\t\tint m = ci();\n\t\tmemset(head,0,sizeof(head));\n\t\tmemset(vis,0,sizeof(vis));\n\t\trep(i,1,m){\n\t\t\tint x[] = {ci(),ci()};\n\t\t\tif( x[0]>x[1] ) swap(x[0],x[1]);\n\t\t\tadd(x[0],x[1]);\n\t\t}\n\t\trep(i,1,n) if( vis[i]==0 ) dfs(i);\n\t\tmemset(g,0,sizeof(g));\n\t\trep(i,1,n) g[s[i]] = (g[s[i]]+pow1[i])%mod;\n\t\tFWT_XOR(g,fn,1);\n\t\trep(i,0,fn-1) f[i] = f[i]*g[i]%mod;\n\t}\n\tFWT_XOR(f,fn,-1);\n\tprintf(\"%lld\\n\",(f[0]+mod)%mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define LL long long\n#define ULL unsigned long long \n#define y second\n#define sqr(x) ((x)*(x))\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define pdd pair<double,double>\n#define MEM(x) memset(x,0,sizeof(x))\n#define pi acos(-1)\n#define MEMS(x) memset(x,-1,sizeof(x))\nusing namespace std;\nint val[3][100005];\nvector<int> v[3][100005];\nvector<int> num[3][100005];\nint number=716070898;\nint mod=998244353;\nLL f_pow(LL a,LL b){\n    LL res=1,temp=a;\n    while(b){\n        if(b&1)res=res*temp%mod;\n        temp=temp*temp%mod;\n        b>>=1;\n    }\n    return res;\n}\n//int val[10][10][10];\nint main(){ \n    int n;\n    scanf(\"%d\",&n);\n    for(int i = 0;i<3;i++){\n        int m;\n        scanf(\"%d\",&m);\n        for(int j =0;j<m;j++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            if(x>y)swap(x,y);\n            v[i][x].pb(y);\n        }\n        for(int j = n;j>=1;j--){\n            vector<int> arr;\n            for(auto it:v[i][j]){\n                arr.pb(val[i][it]);\n            }\n            sort(arr.begin(),arr.end());\n            arr.resize(unique(arr.begin(),arr.end())-arr.begin());\n            val[i][j]=arr.size();\n            for(int k = 0;k<arr.size();k++){\n                if(arr[k]!=k){\n                    val[i][j]=k;\n                    break;\n                }\n            }\n           // if(val[i][j]<2){\n            num[i][val[i][j]].pb(j);\n            //}\n        }\n    }\n    LL ans=0;\n    LL val[3][100005];//,b[2]={0,0},c[2]={0,0};\n    LL sum[3];\n    MEM(val);\n    MEM(sum);\n    for(int i =0;i<3;i++){\n        for(int j=0;j<100005;j++){\n            for(auto it:num[i][j]){\n                val[i][j]+=f_pow(number,it);\n                val[i][j]%=mod;\n            }\n            if(j>1)sum[i]+=val[i][j],sum[i]%=mod;\n        }\n    }\n    ans+=val[0][0]*val[1][0]%mod*val[2][0]%mod;\n    ans+=val[0][1]*sum[1]%mod*sum[2]%mod;\n    ans+=sum[0]*val[1][1]%mod*sum[2]%mod;\n    ans+=sum[0]*sum[1]%mod*val[2][1]%mod;\n    for(int j=1;j<100005;j++){\n        ans+=val[0][0]*val[1][j]%mod*val[2][j]%mod;\n        ans+=val[0][j]*val[1][0]%mod*val[2][j]%mod;\n        ans+=val[0][j]*val[1][j]%mod*val[2][0]%mod;\n        if(j>1){\n            ans-=val[0][1]*val[1][j]%mod*val[2][j]%mod;\n            ans-=val[0][j]*val[1][1]%mod*val[2][j]%mod;\n            ans-=val[0][j]*val[1][j]%mod*val[2][1]%mod;\n        }\n    }\n    ans=(ans%mod+mod)%mod;\n    printf(\"%lld\\n\",ans);\n    /*\n    for(int i = 0;i<num[0][0].size();i++){\n        a[0]+=f_pow(number,num[0][0][i]);\n        a[0]%=mod;\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][0][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][0].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][0][i]+num[1][1][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][0].size();j++){\n            for(int k=0;k<num[2][1].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][0][j]+num[2][1][k]);\n                ans%=mod;\n            }\n        }\n    }\n    for(int i = 0;i<num[0][1].size();i++){\n        for(int j=0;j<num[1][1].size();j++){\n            for(int k=0;k<num[2][0].size();k++){\n                ans+=f_pow(number,num[0][1][i]+num[1][1][j]+num[2][0][k]);\n                ans%=mod;\n            }\n        }\n    }*/\n    //printf(\"%lld\\n\",ans);\n}\n/*\n\n5\nAACCMMAA\nA\nAA\nMM\nACA\nACMAA\n\n\n5\n0 9 7 1 100\n-1 0 -1 -1 91\n-1 5 0 -1 96\n-1 8 9 0 99\n-1 -1 -1 -1 0\n3 4\n3 5\n5 6\n5 7\n3 or 4\n3 or 5\n5 or 6\n5 or 7\n\ndp[x]=max(dp[x-w_i*j]+j*t_i-delta t_i*j*(j-1)/2)\ndp[x]=max(dp[j]+x*t_i-j*t_i-delta t_i*(x-j)*(x-j-1)/2)\ndp[x]=max(dp[j]-j*t_i-delta t_i *(j^2/2+j/2) - \n        delta t_i * xj + x*t_i + delta t_i * (x^2/2-x/2))\ndp[x]=max(dp[j] + g(j) - delta t_i *xj + w(i) )\ng(j)= dp[j]-j*t_i-delta t_i *(j^2/2+j/2)\nw(i)=  x*t_i + delta t_i * (x^2/2-x/2)\nx^2/2 -xj -x/2  +j^2/2 +j/2\n*/\n\n/*\n \n\n*/"
  },
  {
    "language": "C++",
    "code": "// ███▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓╬╬╬╬╬╬▓█\n// ███▓███████▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▓▓▓█▓╬╬╬▓█\n// ███████▓█████▓▓╬╬╬╬╬╬╬╬▓███▓╬╬╬╬╬╬╬▓╬╬▓█\n// ████▓▓▓▓╬╬▓█████╬╬╬╬╬╬███▓╬╬╬╬╬╬╬╬╬╬╬╬╬█\n// ███▓▓▓▓╬╬╬╬╬╬▓██╬╬╬╬╬╬▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬╬╬╬▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓███████▓▓███▓╬╬╬╬╬╬▓███████▓╬╬╬╬▓█\n// ████████████████▓█▓╬╬╬╬╬▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬█\n// ███▓▓▓▓▓▓▓╬╬▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬▓▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓▓█▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓██▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// █████▓▓▓▓▓████▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓█▓▓▓▓██▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓▓███▓▓▓▓▓▓▓██▓╬╬╬╬╬╬╬╬╬╬╬╬█▓╬▓╬╬▓██\n// █████▓███▓▓▓▓▓▓▓▓████▓▓╬╬╬╬╬╬╬█▓╬╬╬╬╬▓██\n// █████▓▓█▓███▓▓▓████╬▓█▓▓╬╬╬▓▓█▓╬╬╬╬╬╬███\n// ██████▓██▓███████▓╬╬╬▓▓╬▓▓██▓╬╬╬╬╬╬╬▓███\n// ███████▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬████\n// ███████▓▓██▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓████\n// ████████▓▓▓█████▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█████\n// █████████▓▓▓█▓▓▓▓▓███▓╬╬╬╬╬╬╬╬╬╬╬▓██████\n// ██████████▓▓▓█▓▓▓╬▓██╬╬╬╬╬╬╬╬╬╬╬▓███████\n// ███████████▓▓█▓▓▓▓███▓╬╬╬╬╬╬╬╬╬▓████████\n// ██████████████▓▓▓███▓▓╬╬╬╬╬╬╬╬██████████\n// ███████████████▓▓▓██▓▓╬╬╬╬╬╬▓███████████\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst int M = 998244353;\n\nstring to_string(string s)\n{\n    return '\"' + s + '\"';\n}\nstring to_string(const char* s)\n{\n    return to_string((string) s);\n}\nstring to_string(bool b)\n{\n    return (b ? \"true\" : \"false\");\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p)\n{\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v)\n{\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v)\n    {\n        if (!first)\n        {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\nvoid debug_out()\n{\n    cerr << endl;\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T)\n{\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n//#define LOCAL\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main()\n{\n    ios::sync_with_stdio(0),cin.tie(0);\n\n    // total O(M)\n    int n, m;\n    cin>>n;\n\n    vector<long long> pw(n);\n    pw[0] = 1000000000000000000 % M;\n    for(int i=1;i<n;i++){\n        pw[i] = pw[i-1] * pw[0] % M;\n    }\n\n\n\n    int u, v;\n    vector<vector<vector<int>>> mex;\n\n    vector<int> p(3);\n\n    vector<vector<int>> g(n, vector<int>());\n    vector<int> rk(n);\n\n\n    for(int j=0; j<3; j++)\n    {\n        for(int i=0; i<n; i++)\n        {\n            g[i].clear();\n        }\n        cin>>m;\n        for(int i=0; i<m; i++)\n        {\n            cin>>u>>v;\n            u--,v--;\n            if(u>v)\n            {\n                swap(u,v);\n            }\n            g[u].push_back(v);\n        }\n\n//    debug(g);\n        mex.push_back(vector<vector<int>>());\n\n\n        vector<int> nums(n);\n\n        for(int i=n-1; i>=0; i--)\n        {\n            int num=0;\n            int sz = mex[j].size();\n\n\n            for(int j : g[i])\n            {\n                nums[rk[j]]=i+1;\n            }\n\n//            debug(nums);\n            num=sz;\n            for(int j=0;j<sz;j++){\n                if(nums[j]!=i+1){\n                    num=j;\n                    break;\n                }\n            }\n            if(num == sz)\n            {\n                mex[j].push_back(vector<int>());\n            }\n            mex[j][num].push_back(i);\n            rk[i]=num;\n        }\n        p[j]=mex[j].size();\n    }\n\n    debug(mex);\n\n    long long ans=0;\n    for(int i=0; i<p[0]; i++)\n        for(int j=0; j<p[1]; j++)\n        {\n            int k=i^j;\n            if(k>=p[2])\n                continue;\n            if(mex[0][i].size()==0)\n                continue;\n            if(mex[1][j].size()==0)\n                continue;\n            if(mex[2][k].size()==0)\n                continue;\n            //i,j,k\n            long long sum=0, tmp=1;\n//    debug(mex[0][i]);\n            for(int a1 : mex[0][i])\n            {\n                sum = sum + tmp * pw[a1] % M;\n                sum %= M;\n            }\n            tmp = sum;\n\n            sum = 0 ;\n\n//    debug(mex[1][j]);\n            for(int a2 : mex[1][j])\n            {\n                sum = sum + tmp * pw[a2] % M;\n                sum %= M;\n            }\n            tmp = sum;\n\n            sum = 0;\n//    debug(mex[2][k]);\n\n            for(int a3 : mex[2][k])\n            {\n                sum = sum + tmp * pw[a3] % M;\n                sum %= M;\n            }\n//    debug(sum);\n            ans = ans + sum;\n            ans %= M;\n        }\n    debug(ans);\n    cout << ans << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": " #pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vecll>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\n#define INF 100000000\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\n\n\n\n\nvoid go();\n\nint main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    int tc=1;\n    // tc=in();\n    while(tc--){\n        go();\n    }\n    return 0;\n}\n\nconst ll MOD=998244353;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\n\n\n\nint xy[410][410],xz[410][410],yz[410][410];\n\n\nvoid go(){\n    int n=in();\n    vector<vec> g1(n+1),g2(n+1),g3(n+1);\n    int m1=in();\n    rep(i,m1){\n        int x=in(),y=in();\n        g1[x].pb(y);\n        g1[y].pb(x);\n    }\n    int m2=in();\n    rep(i,m2){\n        int x=in(),y=in();\n        g2[x].pb(y);\n        g2[y].pb(x);\n    }\n    int m3=in();\n    rep(i,m3){\n        int x=in(),y=in();\n        g3[x].pb(y);\n        g3[y].pb(x);\n    }\n    vector<int> d1(n+1),d2(n+1),d3(n+1);\n    mint T = modpow(10,18);\n    vmint P={1};\n    rep(i,310000)P.pb(P.back()*T);\n    vmint D1(n+1),D2(n+1),D3(n+1);\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g1[i]){\n            if(e>i)se.insert(d1[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d1[i]=gr;\n        D1[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g2[i]){\n            if(e>i)se.insert(d2[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d2[i]=gr;\n        D2[gr] += P[i];\n    }\n    rep3(i,n,1){\n        set<int> se;\n        for(auto e:g3[i]){\n            if(e>i)se.insert(d3[e]);\n        }\n        int gr=0;\n        for(auto e:se)if(e==gr)gr++;else break;\n        d3[i]=gr;\n        D3[gr] += P[i];\n    }\n    vec a,b;\n    mint ans;\n    int k1=0,k2=0,k3=0;\n    rep(i,700){\n        rep(j,700){\n            rep(k,700){\n                if(i>=n or j>=n or k>=n)break;\n                if(xy[i][j]==0 and xz[i][k]==0 and yz[j][k]==0) {\n                    ans+=D1[i]*D2[j]*D3[k];\n                    xy[i][j]=1;\n                    xz[i][k]=1;\n                    yz[j][k]=1;\n                } \n            }\n        }\n    }\n\n    cout<<ans.a<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nconstexpr LL mod = 998244353;\nconstexpr int maxn = 100000;\nint N, sg[maxn + 1], s[maxn + 1];\nLL p[maxn + 1];\nvector<int> G[maxn + 1];\nvector<LL> g(){\n    vector<LL> res;\n    int M;\n    cin >> M;\n    for(int i = 1; i <= N; i += 1) G[i].clear();\n    for(int i = 0, u, v; i < M; i += 1){\n        cin >> u >> v;\n        if(u > v) swap(u, v);\n        G[u].push_back(v);\n    }\n    for(int i = N; i; i -= 1){\n        sg[i] = 0;\n        for(int v : G[i]) s[sg[v]] = 1;\n        while(s[sg[i]]) sg[i] += 1;\n        for(int v : G[i]) s[sg[v]] = 0;\n        if(res.size() <= sg[i]) res.resize(sg[i] + 1);\n        res[sg[i]] = (res[sg[i]] + p[i]) % mod;\n    }\n    return res;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cin >> N;\n    p[1] = 1000000000000000000LL % mod;\n    for(int i = 2; i <= N; i += 1) p[i] = p[i - 1] * p[1] % mod;\n    auto g1 = g();\n    auto g2 = g();\n    auto g3 = g();\n    LL ans = 0;\n    for(int i = 0; i < (int)g1.size(); i += 1)\n        for(int j = 0; j < (int)g2.size(); j += 1){\n            int k = i ^ j;\n            if(k < (int)g3.size()) ans += g1[i] * g2[j] % mod * g3[k] % mod;\n        }\n    cout << ans % mod;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=100005;\nconst int mod=998244353;\nnamespace {\n    inline int Add(int x,int y){return (x+=y)>=mod?x-mod:x;}\n    inline int Sub(int x,int y){return (x-=y)<0?x+mod:x;}\n    inline int Mul(int x,int y) {return 1ll*x*y%mod;}\n    inline int Pow(int x,int y=mod-2){if(y==0)return 1;int res=1;while(y){if(y&1)res=1ll*res*x%mod;x=1ll*x*x%mod;y>>=1;}return res;}\n}\nint n,m;\nvector<int> G[max_n];\nvector<int> solve(vector<int> a,vector<int> b){\n    vector<int> c;\n    c.assign(1024,0);\n    for(int i=0;i<1024;i++){\n        for(int j=0;j<1024;j++)c[i^j]=Add(c[i^j],Mul(a[i],b[j]));\n    }\n    return c;\n}\nint p[max_n];\nint sg[max_n];\nint SG(int u){\n    if(~sg[u])return sg[u];\n    set<int> s;\n    for(auto v:G[u]){\n        if(v>u)s.insert(SG(v));\n    }\n    for(int i=0;;i++)if(s.count(i)==0)return sg[u]=i;\n}\nint main(){\n    p[0]=1,p[1]=Pow(10,18);\n    for(int i=2;i<1024;i++)p[i]=Mul(p[i-1],p[1]);\n    scanf(\"%d\",&n);\n    vector<int> f;f.assign(1024,0);f[0]=1;\n    vector<int> a;\n    scanf(\"%d\",&m);\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        assert(x<1024);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        assert(x<1024);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++)G[i].clear();\n    for(int i=0;i<m;i++){\n        int u,v;scanf(\"%d%d\",&u,&v);\n        G[u].push_back(v),G[v].push_back(u);\n    }\n    for(int i=1;i<=n;i++)sg[i]=-1;\n    a.assign(1024,0);\n    for(int i=n;i>=1;i--){\n        int x=SG(i);\n        assert(x<1024);\n        a[x]=Add(a[x],p[i]);\n    }\n    f=solve(a,f);\n    printf(\"%d\\n\",f[0]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unordered_map <int, int> umap;\n\nconst int MAXN = 1e5 + 5;\nconst int MOD = 998244353;\n\nint N;\numap G1, G2, G3;\nvector <int> adj[MAXN];\nint pot[MAXN];\nint mex[MAXN];\n\ninline void add(int &x, int y) {\n\tx += y;\n\tif (x >= MOD)\n\t\tx -= MOD;\n}\n\ninline int mul(int x, int y) {\n\treturn (ll)x * y % MOD;\n}\n\nint dfs(int x) {\n\tif (mex[x] != -1)\n\t\treturn mex[x];\n\tumap occ;\n\tfor (auto it : adj[x])\n\t\tocc[dfs(it)] = 1;\n\tocc[-1] = 1;\n\twhile (occ[mex[x]])\n\t\tmex[x]++;\n\treturn mex[x];\n}\n\nvoid input(umap &G) {\n\tmemset(mex, -1, sizeof mex);\n\tfor (int i = 1; i <= N; i++)\n\t\tadj[i].clear();\n\tint M;\n\tscanf(\"%d\", &M);\n\twhile (M--) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tadj[min(a, b)].push_back(max(a, b));\n\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tadd(G[dfs(i)], pot[i]);\n}\n\nvoid load() {\n\tscanf(\"%d\", &N);\n\tpot[0] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tpot[i] = mul(pot[i - 1], (ll)1e18 % MOD);\n\tinput(G1);\n\tinput(G2);\n\tinput(G3);\n}\n\nint solve() {\n\tumap conv;\n\tfor (auto it1 : G1)\n\t\tfor (auto it2 : G2)\n\t\t\tadd(conv[it1.first ^ it2.first], mul(it1.second, it2.second));\n\tint sol = 0;\n\tfor (auto it : G3)\n\t\tadd(sol, mul(conv[it.first], it.second));\n\treturn sol;\n}\n\nint main() {\n\tload();\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 3;\nconst int mod = 998244353;\n\nint n, m[4];\nvector <int> adj[4][maxn];\nvoid read()\n{\n    cin >> n;\n    for (int i = 1; i <= 3; i++)\n    {\n        cin >> m[i];\n        for (int j = 1; j <= m[i]; j++)\n        {\n            int a, b;\n            cin >> a >> b;\n\n            adj[i][a].push_back(b);\n            adj[i][b].push_back(a);\n        }\n    }\n}\n\nlong long add(long long a, long long b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n\n    return a;\n}\n\nlong long pow10[maxn*2];\nint gr[4][maxn];\nmap <int, long long> mp[4];\nvoid solve()\n{\n    pow10[0] = 1;\n    for (int i = 1; i <= 2 * n; i++)\n        pow10[i] = pow10[i-1] * 1000000000 % mod;\n\n    for (int i = 1; i <= 3; i++)\n    {\n        mp[i][0] = add(mp[i][0], pow10[n*2]);\n        for (int j = n-1; j >= 1; j--)\n        {\n            set <int> s;\n            for (auto k: adj[i][j])\n                if (k > j)\n                s.insert(gr[i][k]);\n\n            while (s.find(gr[i][j]) != s.end())\n                gr[i][j]++;\n\n            mp[i][gr[i][j]] = add(mp[i][gr[i][j]], pow10[j*2]);\n        }\n    }\n\n    int p = sqrt(max({m[1], m[2], m[3]})) + 10;\n    long long ans = 0;\n    for (int i = 0; i <= p; i++)\n        if (mp[1].count(i))\n        for (int j = 0; j <= p; j++)\n        if (mp[2].count(j))\n            ans = add(ans, mp[1][i] * mp[2][j] % mod * mp[3][i^j] % mod);\n\n    cout << ans << endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    read();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\nusing namespace std;\ninline int read(){\n\tint v=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0' || c>'9'){\n\t\tif (c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile (c>='0' && c<='9'){\n\t\tv=v*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn v*f;\n}\nconst int Maxn=100005;\nconst LL mod=998244353;\nint n,m1,m2,m3;\nint F1[Maxn],F2[Maxn],F3[Maxn];\nint cnt[Maxn];\nLL w[Maxn],S1[1024],S2[1024],S3[1024];\nLL dp[1024],ndp[1024];\nvector<int> G1[Maxn],G2[Maxn],G3[Maxn];\nvoid Add(LL &x,LL y){\n\tx+=y;\n\tif (x>=mod) x-=mod;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%d\",&m1);\n\tfor (int i=0;i<m1;i++){\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tG1[u].pb(v);G1[v].pb(u);\n\t}\n\tfor (int i=1;i<=n;i++) F1[i]=F2[i]=F3[i]=0;\n\tfor (int i=n;i>=1;i--){\n\t\tfor (int j=0;j<G1[i].size();j++){\n\t\t\tint v=G1[i][j];\n\t\t\tif (v>i) cnt[F1[v]]++;\n\t\t}\n\t\tint t=0;\n\t\twhile (cnt[t]) t++;\n\t\tF1[i]=t;\n\t\tfor (int j=0;j<G1[i].size();j++){\n\t\t\tint v=G1[i][j];\n\t\t\tif (v>i) cnt[F1[v]]--;\n\t\t}\n\t}\n\tscanf(\"%d\",&m2);\n\tfor (int i=0;i<m2;i++){\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tG2[u].pb(v);G2[v].pb(u);\n\t}\n\tfor (int i=n;i>=1;i--){\n\t\tfor (int j=0;j<G2[i].size();j++){\n\t\t\tint v=G2[i][j];\n\t\t\tif (v>i) cnt[F2[v]]++;\n\t\t}\n\t\tint t=0;\n\t\twhile (cnt[t]) t++;\n\t\tF2[i]=t;\n\t\tfor (int j=0;j<G2[i].size();j++){\n\t\t\tint v=G2[i][j];\n\t\t\tif (v>i) cnt[F2[v]]--;\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&m3);\n\tfor (int i=0;i<m3;i++){\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tG3[u].pb(v);G3[v].pb(u);\n\t}\n\tfor (int i=n;i>=1;i--){\n\t\tfor (int j=0;j<G3[i].size();j++){\n\t\t\tint v=G3[i][j];\n\t\t\tif (v>i) cnt[F3[v]]++;\n\t\t}\n\t\tint t=0;\n\t\twhile (cnt[t]) t++;\n\t\tF3[i]=t;\n\t\tfor (int j=0;j<G3[i].size();j++){\n\t\t\tint v=G3[i][j];\n\t\t\tif (v>i) cnt[F3[v]]--;\n\t\t}\n\t}\n\t\n\tLL tmp=1e18;\n\ttmp%=mod;\n\tw[0]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tw[i]=w[i-1]*tmp%mod;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tAdd(S1[F1[i]],w[i]);\n\t\tAdd(S2[F2[i]],w[i]);\n\t\tAdd(S3[F3[i]],w[i]);\n\t}\n\tdp[0]=1;\n\tmemset(ndp,0,sizeof(ndp));\n\tfor (int i=0;i<1024;i++){\n\t\tfor (int j=0;j<1024;j++){\n\t\t\tAdd(ndp[i^j],1ll*dp[i]*S1[j]%mod);\n\t\t}\n\t} \n\tfor (int i=0;i<1024;i++) dp[i]=ndp[i];\n\t\n\t\n\tmemset(ndp,0,sizeof(ndp));\n\tfor (int i=0;i<1024;i++){\n\t\tfor (int j=0;j<1024;j++){\n\t\t\tAdd(ndp[i^j],1ll*dp[i]*S2[j]%mod);\n\t\t}\n\t} \n\tfor (int i=0;i<1024;i++) dp[i]=ndp[i];\n\t\n\tmemset(ndp,0,sizeof(ndp));\n\tfor (int i=0;i<1024;i++){\n\t\tfor (int j=0;j<1024;j++){\n\t\t\tAdd(ndp[i^j],1ll*dp[i]*S3[j]%mod);\n\t\t}\n\t} \n\tfor (int i=0;i<1024;i++) dp[i]=ndp[i];\n\tprintf(\"%lld\\n\",dp[0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef vector<ll> vll;\n#define INF 0x3f3f3f3f\n#define MOD 998244353LL\n#define EPSILON 0.00001\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n \n#define FOR(i, a, b) for (int i=(a); i<=(signed)(b); i++)\n#define F0R(i, a) for (int i=0; i<(signed)(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 100005\n#define RT 500\nint n;\nint m[3];\nvi e[3][MN];\nll lol;\nll exps[MN];\n\nbool tch[3][MN][RT];\nll sm[3][RT];\n\nll sym(int a, int b, int c){\n    //cout << \"doing \" << a << \" \" << b << \" \" << c << \"\\n\";\n    int ree[3] = {a, b, c};\n    ll ans = 0;\n    do{\n        ll pro = ((sm[0][ree[0]]*sm[1][ree[1]])%MOD*sm[2][ree[2]])%MOD;\n        ans = (ans+pro)%MOD;\n    } while(next_permutation(ree, ree+3));\n    //cout << \"adding \" << ans << \"\\n\";\n    return ans;\n}\n\nint used[RT][RT];\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    lol = 1000000000000000000LL % MOD;\n    //lol = 3;\n    exps[0] = 1;\n    FOR(i, 1, MN-2){\n        exps[i] = (exps[i-1]*lol)%MOD;\n    }\n    cin >> n;\n    F0R(i, 3){\n        cin >> m[i];\n        F0R(_, m[i]){\n            int u, v;\n            cin >> u >> v;\n            e[i][u].pb(v);\n            e[i][v].pb(u);\n        }\n    }\n    \n    /*ll sm = 0;\n    RFOR(i, n, 1){\n        if(tch[i]){\n            sm = (sm+exps[i])%MOD;\n        } else{\n            for(auto u : e[0][i]) if(u < i){\n                tch[u] = true;\n            }\n        }\n    }*/\n    ll totsm = 0;\n    FOR(i, 1, n) totsm = (totsm+exps[i])%MOD;\n\n    int mx = 0;\n    F0R(i, 3){\n        //cout << \"doing \" << i << \"\\n\";\n        RFOR(cn, n, 1){\n            F0R(j, RT){\n                if(!tch[i][cn][j]){\n                    //cout << cn << \" on \" << j << \"\\n\";\n                    mx = max(mx, j);\n                    sm[i][j] = (sm[i][j]+exps[cn])%MOD;\n                    for(auto nn : e[i][cn]) if(nn < cn){\n                        tch[i][nn][j] = true;\n                    }\n                    break;\n                }\n            }\n            /*if(tch[i][cn] == 3){\n                //cout << cn << \" bad\\n\";\n                continue;\n            } else if(tch[i][cn] == 2){\n                //cout << cn << \" ok\\n\";\n                ot[i] += exps[cn];\n                ot[i] %= MOD;\n                for(auto nn : e[i][cn]) if(nn < cn){\n                    if(tch[i][nn] % 2 == 0) tch[i][nn]++;\n                }\n            } else{\n                //cout << cn << \" good\\n\";\n                sm[i] += exps[cn];\n                sm[i] %= MOD;\n                for(auto nn : e[i][cn]) if(nn < cn){\n                    if(tch[i][nn] < 2) tch[i][nn] += 2;\n                }\n            }*/\n        }\n        //cout << sm[i] << \" \" << ot[i] << \"\\n\";\n    }\n\n    ll ans = 0;\n    FOR(i, 0, mx){\n        FOR(j, i, mx){\n            FOR(k, j, mx){\n                if(!used[i][j] && !used[i][k] && !used[j][k]){\n                    //cout << \"using \" << i << \" \" << j << \" \" << k << \"\\n\";\n                    ans += sym(i, j, k);\n                    ans %= MOD;\n                    used[i][j] = true;\n                    used[i][k] = true;\n                    used[j][k] = true;\n                }\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n\n    /*ll ans = ((sm[0]*sm[1])%MOD*sm[2])%MOD;\n    ans += ((sm[0]*ot[1])%MOD*ot[2])%MOD;\n    ans %= MOD;\n    ans += ((ot[0]*sm[1])%MOD*ot[2])%MOD;\n    ans %= MOD;\n    ans += ((ot[0]*ot[1])%MOD*sm[2])%MOD;\n    ans %= MOD;\n    cout << ans << \"\\n\";*/\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nconst int MM = 500;\nconst ll M = 998244353;\nconst int MN = 100100;\nbitset<MM> bs[MM][2];\nll mul(ll a, ll b) {\n\treturn (a*b)%M;\n}\nll bp(ll b, ll p) {\n\tll ac = 1;\n\twhile(p) {\n\t\tif(p&1) {ac = mul(ac,b);}\n\t\tb = mul(b,b);\n\t\tp >>= 1;\n\t}\n\treturn ac;\n}\nll wor[MM][3];\nvvi g[3];\nint ro[3];\nll po[MN];\nint main() {\n\tios::sync_with_stdio(0);cin.tie(0);\n\tmemset(wor,0,sizeof(wor));\n\tint n;\n\tcin >> n;\n\tpo[0] = 1;\n\tll B = bp(10,18);\n\tfor(int i=1;i<MN;i++) {\n\t\tpo[i] = mul(po[i-1],B);\n\t}\n\tfor(int i=0;i<3;i++) {\n\t\tg[i].assign(n,vi());\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;a--;b--;\n\t\t\tif(a < b) {swap(a,b);}\n\t\t\tg[i][a].push_back(b);\n\t\t}\n\t\tint ctr = 0;\n\t\tvi cu,nu;\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tcu.push_back(j);\n\t\t}\n\t\tbitset<MN> ko;\n\t\twhile(!cu.empty()) {\n\t\t\tko.reset();\n\t\t\tnu.clear();\n\t\t\tfor(int j=cu.size()-1;j>=0;j--) {\n\t\t\t\tint u = cu[j];\n\t\t\t\tif(ko[u]) {\n\t\t\t\t\tnu.push_back(u);continue;}\n\t\t\t\twor[ctr][i] += po[u+1];\n\t\t\t\tif(wor[ctr][i] >= M) {wor[ctr][i] -= M;}\n\t\t\t\tfor(int k=0;k<g[i][u].size();k++) {\n\t\t\t\t\tko.set(g[i][u][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tctr++;\n\t\t\tcu = nu;\n\t\t\treverse(cu.begin(),cu.end());\n\t\t}\n\t\tro[i] = ctr;\n\t}\n\tll res = 0;\n\tfor(int i=0;i<ro[0];i++) {\n\t\tfor(int j=0;j<ro[1];j++) {\n\t\t\tint re = i^j;\n\t\t\tif(re < ro[2]) {\n\t\t\t\tres += mul(wor[i][0],mul(wor[j][1],wor[re][2]));\n\t\t\t}\n\t\t}\n\t}\n\tres %= M;\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=100005,INF=1<<30;\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\n\nll f(ll x){\n    return rui(10,18*x);\n}\n\nvector<int> G[MAX][3];\nint grundy[MAX][3];\n\nll sum[MAX][3];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    \n    for(int q=0;q<3;q++){\n        int M;cin>>M;\n        for(int i=0;i<M;i++){\n            int a,b;cin>>a>>b;\n            if(a>b) swap(a,b);\n            G[a][q].push_back(b);\n        }\n        for(int i=N;i>=1;i--){\n            set<int> SE;\n            for(int to:G[i][q]) SE.insert(grundy[to][q]);\n            \n            for(int j=0;;j++){\n                if(SE.count(j)==0){\n                    grundy[i][q]=j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int j=1;j<=N;j++){\n        sum[grundy[j][1]][0]+=f(j);\n        sum[grundy[j][1]][0]%=mod;\n    }\n    for(int j=1;j<=N;j++){\n        sum[grundy[j][2]][1]+=f(j);\n        sum[grundy[j][2]][1]%=mod;\n    }\n    \n    for(int j=0;j<1024;j++){\n        for(int k=0;k<1024;k++){\n            sum[j^k][2]+=sum[j][0]*sum[k][1];\n            sum[j^k][2]%=mod;\n        }\n    }\n    \n    for(int i=1;i<=N;i++){\n        ans+=f(i)*sum[grundy[i][0]][2];\n        ans%=mod;\n    }\n    \n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n// #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define FAST std::ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define DECIMAL(n)  std::cout << std::fixed;std::cout << std::setprecision(n);\n#define hell 1000000007\n#define narak 998244353\n#define PI 3.14159265358979323844\n#define mp make_pair\n#define eb emplace_back\n#define pb push_back\n#define fi first \n#define se second\n#define all(v) v.begin(), v.end()\n#define endl \"\\n\"\n#define sqr(a) (a)*(a)\n#define __lcm(m,n) m*(n/__gcd(m,n))\n#define inputarr(a,n) for(int xxx=0;xxx<n;++xxx) cin>>(a)[xxx]\n#define sz(a) (int)a.size()\n#define sl(a) (int)a.length()\n#define display(x) for(auto &a:x) cout<<a<<\" \";cout<<endl\n#define debug cerr<<\"bhau\"<<endl\n#define between(n,a,b) (a<=n&&n<=b)\n#define elasped_time 1.0 * clock() / CLOCKS_PER_SEC \n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n    std::cerr << name << \" : \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n    const char* comma = strchr(names + 1, ',');std::cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n\n\ntemplate<typename T, typename U> static inline void amin(T &x, U y) { \n    if (y < x) \n        x = y; \n}\n\ntemplate<typename T, typename U> static inline void amax(T &x, U y) { \n    if (x < y) \n        x = y; \n}\n\ntemplate<typename T,typename U> std::ostream& operator<<(std::ostream& out, std::pair<T,U> a) {\n    out<<a.fi<<\" \"<<a.se;\n    return out;\n}\n\ntemplate<typename T,typename U> std::istream& operator>>(std::istream& in, std::pair<T,U> &a) {\n    in>>a.fi>>a.se;\n    return in;\n}\n\ninline long long toint(const std::string &s) {std::stringstream ss; ss << s; long long x; ss >> x; return x;}\ninline std::string tostring(long long number) {std::stringstream ss; ss << number; return ss.str();}\ninline std::string tobin(long long x) {return std::bitset<63>(x).to_string();}\n\nstd::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());\n\n#define ll long long\n#define pii std::pair<int, int>\n#define vi vector<int>  \n#define vvi vector<vi > \n#define vii vector<pii >\n#define point complex<ll>\n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n\n/*----------------------Graph Moves----------------*/\n//const int fx[]={+1,-1,+0,+0};\n//const int fy[]={+0,+0,+1,-1};\n//const int fx[]={+0,+0,+1,-1,-1,+1,-1,+1};   // Kings Move\n//const int fy[]={-1,+1,+0,+0,+1,+1,-1,-1};  // Kings Move\n//const int fx[]={-2, -2, -1, -1,  1,  1,  2,  2};  // Knights Move\n//const int fy[]={-1,  1, -2,  2, -2,  2, -1,  1}; // Knights Move\n/*------------------------------------------------*/\n\n//primes for hashing 937,991,1013,1409,1741\n\nusing namespace std;\nusing namespace __gnu_pbds;\nconst int MOD = narak;\nstruct mod_int {\n    int val;\n \n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n \n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n \n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n \n        return x < 0 ? x + m : x;\n    }\n \n    explicit operator int() const {\n        return val;\n    }\n \n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n \n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n \n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n \n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n \n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n \n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n \n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n \n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n \n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n \n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n \n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n \n    mod_int inv() const {\n        return mod_inv(val);\n    }\n \n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n \n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n \n            a *= a;\n            p >>= 1;\n        }\n \n        return result;\n    }\n \n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n    friend istream& operator>>(istream &stream, mod_int &m) {\n        return stream >> m.val;\n    }\n};\nmod_int base;\nconst int maxn=100005;\nvi adj[3][maxn];\nint grundy[3][maxn];\nmod_int g[3][400];\nvoid meowmeow321()\n{\n    int n;\n    cin>>n;\n    int m[3];\n    cin>>m[0];\n    for (int i = 0; i < m[0]; ++i) {\n    \tint a,b;\n    \tcin>>a>>b;\n    \tif(a>b)swap(a,b);\n    \tadj[0][a].pb(b);\n    }\n    cin>>m[1];\n    for (int i = 0; i < m[1]; ++i) {\n    \tint a,b;\n    \tcin>>a>>b;\n    \tif(a>b)swap(a,b);\n    \tadj[1][a].pb(b);\n    }\n    cin>>m[2];\n    for (int i = 0; i < m[2]; ++i) {\n    \tint a,b;\n    \tcin>>a>>b;\n    \tif(a>b)swap(a,b);\n    \tadj[2][a].pb(b);\n    }\n    for (int j = 0; j < 3; ++j) {\n    \tfor (int i = n; i >=1 ; --i) {\n    \t\tvi vals;\n    \t\tfor(auto u:adj[j][i]){\n    \t\t\tvals.pb(grundy[j][u]);\n    \t\t}\n    \t\tsort(all(vals));\n    \t\tint cur=0;\n    \t\tfor(auto x:vals){\n    \t\t\tif(x==cur){\n    \t\t\t\tcur++;\n    \t\t\t}\n    \t\t\tif(x>cur)break;\n    \t\t}\n    \t\tgrundy[j][i]=cur;\n    \t\tg[j][grundy[j][i]]+=base.pow(i);\n    \t}\n    }\n    mod_int ans=0;\n    for (int i = 0; i < 400; ++i) {\n    \tfor (int j = 0; j < 400; ++j) {\n    \t\tans+=g[0][i]*g[1][j]*g[2][i^j];\n    \t}\n    }\n    cout<<ans;\n}\nsigned main()\n{\n    FAST;\n    int testcases=1;\n    base=1;\n    for (int i = 0; i < 18; ++i) {\n    \tbase*=10;\n    }\n    //cin>>testcases;\n    for(int i=0;i<testcases;++i)\n    {\n        meowmeow321();\n    }\n    cerr<<endl<<\"Time Elasped : \"<<elasped_time<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:TYPE();}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:TYPE();}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=100005,MOD=998244353,BASE=716070898;\n\nint n;\nvector<int> G[3][MAXN];\nint sg[3][MAXN];\nint m,a[3][MAXN];\nint b[MAXN],c[MAXN],pw[MAXN];\n\nint main()\n{\n\treadint(n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;++i)pw[i]=1ll*pw[i-1]*BASE%MOD;\n\tfor(int t=0;t<3;++t)\n\t{\n\t\tint E,u,v;\n\t\treadint(E);\n\t\twhile(E--)readint(u),readint(v),G[t][u].pb(v),G[t][v].pb(u);\n\t\tfor(int i=n;i;--i)\n\t\t{\n\t\t\tunordered_set<int> st;\n\t\t\tfor(auto j:G[t][i])if(j>i)st.insert(sg[t][j]);\n\t\t\tfor(int k=0;;++k)if(!st.count(k)){sg[t][i]=k;break;}\n\t\t\ta[t][sg[t][i]]=(a[t][sg[t][i]]+pw[i])%MOD;\n\t\t\tchkmax(m,sg[t][i]+1);\n\t\t}\n\t}\n\tint M;\n\tfor(M=1;M<=m;M<<=1);\n\tfor(int i=0;i<M;++i)\n\t\tfor(int j=0;j<M;++j)\n\t\t\tc[i^j]=(c[i^j]+1ll*a[0][i]*a[1][j])%MOD;\n\tfor(int i=0;i<M;++i)\n\t\tfor(int j=0;j<M;++j)\n\t\t\tb[i^j]=(b[i^j]+1ll*c[i]*a[2][j])%MOD;\n\tprintf(\"%d\\n\",b[0]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt<998244353>;\n\nconst Mint ibase = Mint(10).pow(18).inv();\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    VV<Mint> sum(3);\n    for (int ph = 0; ph < 3; ph++) {\n        VV<int> g(n);\n        int m;\n        scanf(\"%d\", &m);\n        for (int i = 0; i < m; i++) {\n            int a, b;\n            scanf(\"%d %d\", &a, &b); a--; b--;\n            if (a > b) swap(a, b);\n            g[a].push_back(b);\n        }\n        Mint now = Mint(10).pow(18 * n);\n        V<int> grundy(n), used(n, -1);\n        for (int i = n - 1; i >= 0; i--) {            \n            for (int j: g[i]) {\n                used[grundy[j]] = i;\n            }\n            while (used[grundy[i]] == i) grundy[i]++;\n            while (int(sum[ph].size()) <= grundy[i]) sum[ph].push_back(Mint(0));\n            sum[ph][grundy[i]] += now;\n            now *= ibase;\n        }\n    }\n    Mint answer = 0;\n    for (int i = 0; i < int(sum[0].size()); i++) {\n        for (int j = 0; j < int(sum[1].size()); j++) {\n            int k = i ^ j;\n            if (k < int(sum[2].size())) {\n                answer += sum[0][i] * sum[1][j] * sum[2][k];\n            }\n        }\n    }\n    printf(\"%d\\n\", answer.v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nconst ll MOD=998244353;\n\nll x[100010];\nvoid init(){\n\tx[0]=1e+18;\n\t//x[0]=2;\n\tx[0]%=MOD;\n\tfor(int i=1;i<100010;i++){\n\t\tx[i]=x[i-1]*x[0];\n\t\tx[i]%=MOD;\n\t}\n}\n\nll modpow(ll x,ll k){\n\tif(k==0)return 1;\n\tll ret=modpow(x,k/2);\n\tret*=ret;\n\tret%=MOD;\n\tif(k%2==1){\n\t\tret*=x;\n\t\tret%=MOD;\n\t}\n\treturn ret;\n}\n\nstruct Graph{\n\tint n,m;\n\tvector<int> G[100010];\n\tint k;\n\tll ret[100010];\n\tbool used[100010];\n\tbool used2[100010];\n\tint run(){\n\t\tmemset(used,0,sizeof used);\n\t\tint zan=n;\n\t\tk=0;\n\t\twhile(zan>0){\n\t\t\tret[k]=0;\n\t\t\tmemset(used2,0,sizeof used2);\n\t\t\tfor(int i=n;i>=1;i--){\n\t\t\t\tif(used[i])continue;\n\t\t\t\tused2[i]=true;\n\t\t\t\tfor(int v: G[i]){\n\t\t\t\t\tif(used2[v]){\n\t\t\t\t\t\tused2[i]=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(used2[i]){\n\t\t\t\t\tret[k]+=x[i-1];\n\t\t\t\t\tif(ret[k]>=MOD)ret[k]-=MOD;\n\t\t\t\t\tzan--;\n\t\t\t\t\tused[i]=true;\n\t\t\t\t\t//cerr<<i<<\" \"<<k<<\" \"<<x[i]<<\" \"<<ret[k]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\t/*cerr<<k<<endl;\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcerr<<ret[i]<<\" \";\n\t\t}cerr<<endl;*/\n\t\treturn k;\n\t}\n}G[3];\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&G[0].n);\n\tG[1].n=G[0].n;\n\tG[2].n=G[0].n;\n\tint k=MOD;\n\tfor(int t=0;t<3;t++){\n\t\tscanf(\"%d\",&G[t].m);\n\t\tfor(int i=0;i<G[t].m;i++){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tif(a>b)G[t].G[b].push_back(a);\n\t\t\telse G[t].G[a].push_back(b);\n\t\t}\n\t\tchmin(k,G[t].run());\n\t}\n\t\n\tstatic ll a[1<<17];\n\tfor(int i=0;i<G[1].k;i++){\n\t\tfor(int j=0;j<G[2].k;j++){\n\t\t\ta[i^j]+=G[1].ret[i]*G[2].ret[j];\n\t\t\ta[i^j]%=MOD;\n\t\t}\n\t}\n\t\n\tll ret=0;\n\tfor(int i=0;i<G[0].k;i++){\n\t\ta[i]*=G[0].ret[i];\n\t\tret+=a[i]; ret%=MOD;\n\t}\n\tcout<<ret%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n \n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x) {\n    return x * x;\n}\n\nint mysqrt(ll x) {\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1) {\n        int m = (l + r) / 2;\n        if (m * (ll) m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\n#ifdef ONPC\nmt19937 rnd(231);\nmt19937_64 rndll(231);\n#else\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n    mt19937_64 rndll(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\ntemplate<typename T>\nT gcd(T a, T b) {\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod = 998244353;\n\nint Bpow(int x, ll y) {\n    int ret = 1;\n    int w = x;\n    while (y) {\n        if (y & 1)\n            ret = (ret * (ll) w) % Mod;\n        w = (w * (ll) w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x) {\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y) {\n    return (x * (ll) Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y) {\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y) {\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y) {\n    return (x * (ll) y) % Mod;\n}\n\nint inv(int a) {\n    int b = Mod, x = 0, y = 1;\n    while (a) {\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y) {\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y) {\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y) {\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y) {\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 2e5 + 10, maxw = 1e6 + 100, inf = 1e9 + 100, sq = 100, LG = 18;\n\nint q[3][maxn], mas[3][maxn];\n\nint n;\n\nvector<int> e[3][maxn];\n\nint main() {\n#ifdef ONPC\n    freopen(\"../a.in\", \"r\", stdin);\n    freopen(\"../a.out\", \"w\", stdout);\n#else\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n#endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    int big[3];\n    memset(big, 0, sizeof(big));\n    int vl = Bpow(10, 18);\n    for (int t = 0; t < 3; t++) {\n        int w;\n        cin >> w;\n        while (w--) {\n            int v, u;\n            cin >> v >> u;\n            if (v > u)\n                swap(v, u);\n            e[t][v - 1].push_back(u - 1);\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            vector<int> ms;\n            for (int j : e[t][i])\n                ms.push_back(q[t][j]);\n            sort(ms.begin(), ms.end());\n            unique(ms);\n            for (int j = 0; j <= ms.size(); j++)\n                if (j == ms.size() || ms[j] != j) {\n                    q[t][i] = j;\n                    break;\n                }\n            mas[t][q[t][i]] = ad(mas[t][q[t][i]], Bpow(vl, i + 1));\n            setmax(big[t], q[t][i]);\n        }\n    }\n    int val = 0;\n    for (int a = 0; a <= big[0]; a++)\n        for (int b = 0; b <= big[1]; b++)\n            for (int c = 0; c <= big[2]; c++)\n                if ((a ^ b ^ c) == 0)\n                    val = ad(val, mul(mas[0][a], mul(mas[1][b], mas[2][c])));\n    cout << val;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define lld long double\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 101000,mod = 998244353;\nll p[N];\nint n;\nstruct graph{\n\tint hsh[N],f[N],m,n;\n\tll h[N];\n\tvector<int> e[N];\n\tvoid init(int S){\n\t\tn=S;\n\t\tread(m);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x,y;read(x);read(y);\n\t\t\tif(x>y) swap(x,y);\n\t\t\te[x].push_back(y);\n\t\t}\n\t\tfor(int i=n;i;i--){\n\t\t\tfor(int v:e[i]) hsh[f[v]]++;\n\t\t\twhile(hsh[f[i]]) f[i]++;\n\t\t\th[f[i]]=(h[f[i]]+p[i])%mod;\n\t\t\tfor(int v:e[i]) hsh[f[v]]--;\n\t\t}\n\t}\n}Gx,Gy,Gz;\nint main(){\n\tread(n);\n\tp[0]=1;p[1]=1000000000000000000ll%mod;\n\tfor(int i=2;i<=n;i++) p[i]=p[i-1]*p[1]%mod;\n\tGx.init(n);\n\tGy.init(n);\n\tGz.init(n);\n\tint K=340;\n\tll ans=0;\n\tfor(int i=0;i<=K;i++)\n\t\tfor(int j=0;j<=K;j++)\n\t\t\tans=(ans+Gx.h[i]*Gy.h[j]%mod*Gz.h[i^j])%mod;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int M = 998244353;\nconst int N = 1e5+7;\nconst long long B = 1000000000000000000;\ntypedef long long LL;\n\nLL pb[N];\nvoid pre() {\n    pb[0] = 1;\n    LL b = B%M;\n    for (int i=1; i<N; i++)\n        pb[i] = (pb[i-1]*b)%M;\n}\n\nvector<int> bfs(vector<vector<int>>adj) {\n    int n = adj.size()-1;\n    vector<int> col(n+1, N);\n\n    vector<bool> vis(n);\n    for (int i=n; i>0; i--) {\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 1;\n        }\n\n        for (int ii=0; ii<=n; ii++)\n            if (!vis[ii]) {\n                col[i] = ii;\n                break;\n            }\n\n        for (int v: adj[i]) {\n            if (v > i)    vis[col[v]] = 0;\n        }\n    }\n    return col;\n}\n\nint m[3];\nvector<vector<int>> adj[3];\nvector<int> dis[3];\nvector<LL> con[3];\n\nLL power(LL a, LL p) {\n    if (p == 0) return 1;\n    LL ans = power(a, p/2);\n    ans = (ans * ans)%M;\n    if (p%2)    ans = (ans * a)%M;\n    return ans;\n}\n\nvoid FWHT(vector< LL >&p, bool inverse) {\n    int n = p.size();\n    assert((n&(n-1))==0);\n\n    for (int len = 1; 2*len <= n; len <<= 1) {\n        for (int i = 0; i < n; i += len+len) {\n            for (int j = 0; j < len; j++) {\n                LL u = p[i+j];\n                LL v = p[i+len+j];\n                p[i+j] = u+v;\n                p[i+len+j] = u-v;\n            }\n        }\n    }\n    if (inverse) {\n        LL inv = power(n, M-2);\n        for (int i = 0; i < n; i++) {\n            p[i] %= M;\n            if (p[i] < 0)   p[i] += M;\n            p[i] = (p[i] * inv)%M;\n        }\n    }\n}\n\nint main() {\n    pre();\n\n    int n;\n    cin>>n;\n    const int MX = 1<<17;\n\n    for (int g=0; g<3; g++) {\n        cin>>m[g];\n        adj[g].resize(n+1);\n        for (int i=0; i<m[g]; i++) {\n            int u, v;\n            cin>>u>>v;\n            adj[g][u].push_back(v);\n            adj[g][v].push_back(u);\n        }\n        dis[g] = bfs(adj[g]);\n\n        con[g].resize(MX);\n        for (int i=1; i<=n; i++) {\n            con[g][dis[g][i]] = (con[g][dis[g][i]] + pb[i])%M;\n        }\n    }\n    \n    vector<LL> ans(MX,1);\n    for (int g=0; g<3; g++) {\n        FWHT(con[g], false);\n        for (int i=0; i<MX; i++)\n            ans[i] = (ans[i] * con[g][i])%M;\n    }\n\n    FWHT(ans, true);\n    cout<<ans[0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\nint read();\nint n;\nint m1, m2, m3;\nvoid Add(int& x, int y) { (x += y) >= mod ? x -= mod : x; }\n\nvector<int> e[3][100005];\nvoid add(int f, int t, int d) { e[d][f].push_back(t), e[d][t].push_back(f); }\nint sg[3][100005];\nvector<int> nx[100005];\nvoid solve(int d) {\n    for (int i = 1; i <= n; ++i) nx[i].clear();\n    for (int u = n; u >= 1; --u) {\n        sort(nx[u].begin(), nx[u].end());\n        for (int v : nx[u]) {\n            if (sg[d][u] == v) sg[d][u]++;\n            if (sg[d][u] < v) break;\n        }\n        for (int v : e[d][u]) nx[v].push_back(sg[d][u]);\n    }\n}\n\nint fsp(int base, int p) {\n    int rt = 1;\n    while (p) {\n        if (p & 1) rt = 1ll * rt * base % mod;\n        base = 1ll * base * base % mod, p >>= 1;\n    }\n    return rt;\n}\nint M(int x) { return x + (x >> 31 & mod); }\nstruct Poly {\n    int x[300005];\n    int& operator[](int p) { return x[p]; }\n    void fwt(int len) {\n        for (int l = 2; l <= len; l <<= 1)\n            for (int i = 0, m = l >> 1; i < len; i += l)\n                for (int j = i, t; j < i + m; ++j)\n                    t = x[j + m], x[j + m] = M(x[j] - t), Add(x[j], t);\n    }\n} F[3];\n\nint main() {\n    n = read(), m1 = read();\n    for (int i = 1; i <= m1; ++i) add(read(), read(), 0);\n    m2 = read();\n    for (int i = 1; i <= m2; ++i) add(read(), read(), 1);\n    m3 = read();\n    for (int i = 1; i <= m3; ++i) add(read(), read(), 2);\n    for (int i = 0; i < 3; ++i) {\n        solve(i);\n        for (int j = 1, t = 1, p = fsp(10, 18); j <= n; ++j)\n            t = 1ll * t * p % mod, Add(F[i][sg[i][j]], t);\n    }\n    int len = 1;\n    while (len <= n) len <<= 1;\n    F[0].fwt(len), F[1].fwt(len), F[2].fwt(len);\n    for (int i = 0; i < len; ++i)\n        F[0][i] = 1ll * F[0][i] * F[1][i] % mod * F[2][i] % mod;\n\n    F[0].fwt(len);\n    printf(\"%d\\n\", 1ll * F[0][0] * fsp(len, mod - 2) % mod);\n    return 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Problem : C - Giant Graph\n// Contest : AtCoder Grand Contest 043\n// URL : https://atcoder.jp/contests/agc043/tasks/agc043_c\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n// By zghtyarecrenj\n\n#include <cstdio>\n#include <cstring>\n\nnamespace io \n{\n\tconst int MaxBuff = 1 << 15;\n\tconst int MaxOut = 1 << 24;\n\tchar b[MaxBuff], *S = b, *T = b;\n\n\tinline char getc() \n\t{ \n\t\treturn S == T && (T = (S = b) + fread(b, 1, MaxBuff, stdin), S == T) ? 0 : *S++; \n\t}\n} // namespace io\n\ninline void in(int &t)\n{\n\tt = 0; register char ch = io::getc();\n\twhile (ch < '0' || ch > '9') ch = io::getc();\n\tdo t = t * 10 + ch - '0', ch = io::getc(); while (ch >= '0' && ch <= '9');\n}\n\nconst int N = 1e5 + 5;\nconst int ix35 = 998244353;\n\nstruct modint { int a; modint(long long x = 0) { a = x; } };\nconst modint inv2((ix35 + 1) >> 1), base(1000000000000000000ll % ix35);\ninline modint operator +(const modint& a, const modint& b) { return (a.a + b.a < ix35 ? a.a + b.a : a.a + b.a - ix35); }\ninline modint operator -(const modint& a, const modint& b) { return (a.a >= b.a ? a.a - b.a : a.a - b.a + ix35); }\ninline modint operator *(const modint& a, const modint& b) { return ((long long)a.a * b.a) % ix35; }\n\nint n, len, tmp[N];\n\ninline void fwt(modint *f) \n{\n\tfor (int i = 1; i < len; i <<= 1)\n\t\tfor (int j = 0; j < len; j += (i << 1))\n\t\t\tfor (int k = 0; k < i; ++k) \n\t\t\t{\n\t\t\t\tmodint u = f[j + k], v = f[i + j + k];\n\t\t\t\tf[j + k] = u + v, f[i + j + k] = u - v;\n\t\t\t}\n}\n\ninline void ifwt(modint *f)\n{\n\tmodint inv = 1;\n\tfor (int i = 1; i < len; i <<= 1) \n\t\tinv = inv * inv2;\n\tfor (int i = 0; i < len; ++i)\n\t\tf[i] = f[i] * inv;\n}\n\nstruct graph\n{\n\tint m, head[N], to[N], nxt[N], tot, f[N];\n  \tmodint x[N * 2];\n  \t\t\n\tinline void addedge(int x, int y)\n\t{\n\t\tnxt[++tot] = head[x], head[x] = tot, to[tot] = y;\n\t}\n\t\n\tinline void read()\n\t{\n\t\tin(m);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint x, y;\n\t\t\tin(x), in(y);\n\t\t\tif (x < y)\n\t\t\t\taddedge(x, y);\n\t\t\telse\n\t\t\t\taddedge(y, x);\n\t\t}\n\t}\n\t\n\tinline void init()\n\t{\n\t\tfor (int i = n; i; --i)\n\t\t{\n\t\t\tf[i] = 0;\n\t\t\tfor (int j = head[i]; j; j = nxt[j]) tmp[f[to[j]]] = 1;\n\t\t\twhile (tmp[f[i]]) ++f[i];\n\t\t\tfor (int j = head[i]; j; j = nxt[j]) tmp[f[to[j]]] = 0;\n\t\t}\n\t}\n\t\n\tinline void prep()\n\t{\n\t\tmodint tmp = 1;\n\t\tfor (int i = 1; i <= n; ++i) \n\t\t\ttmp = tmp * base, x[f[i]] = x[f[i]] + tmp;\n\t}\n} g1, g2, g3;\n\nint main()\n{\n\tin(n);\n\tg1.read(), g2.read(), g3.read();\n\tg1.init(), g2.init(), g3.init();\n\tg1.prep(), g2.prep(), g3.prep();\n\tfor (len = 1; len < n; len <<= 1) ;\n\tfwt(g1.x), fwt(g2.x), fwt(g3.x);\n\tfor (int i = 0; i < len; ++i)\n\t\tg1.x[i] = g1.x[i] * g2.x[i] * g3.x[i];\n\tfwt(g1.x), ifwt(g1.x);\n\tprintf(\"%d\\n\", g1.x[0].a);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <set>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\ntemplate <int32_t P>\nstruct ModInt_t {\n  int32_t value;\n\n  static_assert(P < (1 << 30) - 1, \"2xP must fit into 32-bit signed integer\");\n\n  ModInt_t() : value{0} {};\n\n  explicit ModInt_t(int32_t v) : value(v) {\n    if (value >= P || value <= -P) value %= P;\n    if (value < 0) value += P;\n  };\n\n  explicit operator bool() const { return value != 0; }\n  explicit operator int32_t() const { return value; }\n\n  ModInt_t& operator+=(const ModInt_t& other) {\n    value += other.value;\n    if (value >= P) value -= P;\n    return *this;\n  }\n\n  ModInt_t& operator-=(const ModInt_t& other) {\n    value -= other.value;\n    if (value < 0) value += P;\n    return *this;\n  }\n\n  ModInt_t& operator*=(const ModInt_t& other) {\n    int64_t result = static_cast<int64_t>(value) * other.value;\n    value = static_cast<int32_t>(result % P);\n    return *this;\n  }\n\n  static ModInt_t inverse(ModInt_t x) { return ModInt_t{inverse(x.value)}; }\n\n private:\n  static int32_t inverse(int32_t a) {\n    int32_t b = P, x = 1, y = 0;\n    while (b != 0) {\n      auto k = a / b;\n      a -= k * b;\n      std::swap(a, b);\n      x -= k * y;\n      std::swap(x, y);\n    }\n    assert(a == 1);\n    if (x < 0) x += P;\n    return x;\n  }\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator+(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res += b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator-(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res -= b;\n};\n\ntemplate <int32_t P>\nModInt_t<P> operator*(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  auto res = a;\n  return res *= b;\n};\n\ntemplate <int32_t P>\nbool operator==(const ModInt_t<P>& a, const ModInt_t<P>& b) {\n  return a.value == b.value;\n};\n\ntemplate <int32_t P>\nstd::ostream& operator<<(std::ostream& os, const ModInt_t<P>& a) {\n  os << a.value;\n  return os;\n}\n\ntemplate <typename T>\nstruct MulMonoid {\n  using value_type = T;\n  constexpr static T identity() { return T{1}; }\n  constexpr static T op(const T& a, const T& b) { return a * b; }\n};\n\ntemplate <typename T, typename U, typename Monoid = MulMonoid<T>>\nT power(T a, U n) {\n  T r{Monoid::identity()};\n  while (n > 0) {\n    if (n % 2) r = Monoid::op(r, a);\n    a = Monoid::op(a, a);\n    n /= 2;\n  }\n  return r;\n}\n\nusing ModInt = ModInt_t<998244353>;\n\nvector<ModInt> read(int N) {\n  int M;\n  cin >> M;\n  vector<vector<int>> E(N);\n  for (int i = 0; i < M; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    E[a].push_back(b);\n    E[b].push_back(a);\n  }\n\n  vector<ModInt> ret;\n  set<int> S;\n  for (int i = 0; i < N; ++i) {\n    S.insert(i);\n  }\n\n  while (S.size()) {\n    ModInt w{0};\n    set<int> nS = S;\n    while (S.size()) {\n      int x = *(--S.end());\n      S.erase(x);\n      nS.erase(x);\n      w += power(ModInt{10}, 18 * (x + 1));\n      for (int y : E[x]) {\n        S.erase(y);\n      }\n    }\n    S = std::move(nS);\n    ret.push_back(w);\n  }\n  return ret;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n\n  int N;\n  cin >> N;\n\n  auto A = read(N);\n  auto B = read(N);\n  auto C = read(N);\n\n  ModInt ret{0};\n  for (uint32_t i = 0; i < A.size() && i < B.size() && i < C.size(); ++i) {\n    if (i == 0) {\n      ret += A[i] * B[i] * C[i];\n    } else {\n      ret += A[0] * B[i] * C[i];\n      ret += A[i] * B[0] * C[i];\n      ret += A[i] * B[i] * C[0];\n    }\n  }\n  cout << ret << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nconst int MOD = 998244353;\n\ninline int add(int x, int y) {\n\treturn (x + y) % MOD;\n}\n\ninline int sub(int x, int y) {\n\treturn (x + MOD - y) % MOD;\n}\n\ninline int mul(int x, int y) {\n\treturn (long long)x * y % MOD;\n}\n\ninline int mod_pow(int a, int b) {\n\tint res = 1;\n\twhile (b) {\n\t\tif (b & 1) {\n\t\t\tres = mul(res, a);\n\t\t}\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\n//xor convolution\nvoid fwht(vector<int>& poly, bool rev = false) {\n\tint n = (int)poly.size();\n\tfor (int i = 1; i < n; i *= 2) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tfor (int k = 0; k < n; k += i * 2) {\n\t\t\t\tint u = poly[j + k], v = poly[j + k + i];\n\t\t\t\tpoly[j + k] = add(u, v);\n\t\t\t\tpoly[j + k + i] = sub(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif (rev) {\n\t\tint inv = mod_pow(n, MOD - 2);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpoly[i] = mul(poly[i], inv);\n\t\t}\n\t}\n}\n\nvector<int> mul(vector<int> a, vector<int> b) {\n\tint sm = (int)a.size() + (int)b.size() - 1, size_ = 1;\n\twhile (size_ < sm) size_ *= 2;\n\ta.resize(size_, 0), b.resize(size_, 0);\n\tfwht(a), fwht(b);\n\tfor (int i = 0; i < size_; i++) {\n\t\ta[i] = mul(a[i], b[i]);\n\t}\n\tfwht(a, true);\n\ta.resize(sm);\n\treturn a;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<vector<int> > g[3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tg[i].resize(N);\n\t\tint M;\n\t\tcin >> M;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif (a > b) swap(a, b);\n\t\t\tg[i][a].push_back(b);\n\t\t}\n\t}\n\tpair<vector<int>, vector<int> > v[3];\n\tvector<int> X(3 * N + 5);\n\tX[0] = 1;\n\tX[1] = ((int)1e18) % MOD;\n\tfor (int i = 2; i < X.size(); i++) {\n\t\tX[i] = (X[i - 1] * X[1]) % MOD;\n\t}\n\tvector<int> A[3];\n\n\tfor (int i = 0; i < 3; i++) {\n\t\tA[i].resize(N + 1, 0);\n\t\tvector<int> mk(N, 0);\n\t\tvector<int> G(N, 0);\n\t\tfor (int j = N - 1; j >= 0; j--) {\n\t\t\tset<int> st;\n\t\t\tfor (const int& k : g[i][j]) {\n\t\t\t\tst.insert(G[k]);\n\t\t\t}\n\t\t\twhile (st.count(G[j]) != 0) {\n\t\t\t\tG[j]++;\n\t\t\t}\n\t\t\tA[i][G[j]] = add(A[i][G[j]], X[j + 1]);\n\t\t}\n\t}\n\tvector<int> T = mul(A[0], A[1]);\n\tint res = 0;\n\tfor (int i = 0; i < min(T.size(), A[2].size()); i++) {\n\t\tres = add(res, T[i] * A[2][i] % MOD);\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int B=716070898,mod=998244353,N=5e5+50;\nint n,m,pw[N],sum[3][N],mx,f[N],ans;bool vis[N];\nvector<int>v[N];\nvoid init(int id){\n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++)v[i].clear();\n    for(int i=1,x,y;i<=m;i++){\n        scanf(\"%d%d\",&x,&y);\n        if(x>y)swap(x,y);v[x].pb(y);\n    }\n    for(int i=n;i;i--){\n        for(int j=0;j<v[i].size();j++)vis[f[v[i][j]]]=1;\n        for(int j=0;;j++)if(!vis[j]){f[i]=j;break;}\n        for(int j=0;j<v[i].size();j++)vis[f[v[i][j]]]=0;\n        (sum[id][f[i]]+=pw[i])%=mod;mx=max(mx,f[i]);\n    }\n}\nint main(){\n    scanf(\"%d\",&n);pw[0]=1;\n    for(int i=1;i<=n;i++)pw[i]=1ll*pw[i-1]*B%mod;\n    init(0);init(1);init(2);\n    for(int i=0;i<=mx;i++)for(int j=0;j<=mx;j++)\n        ans=(ans+1ll*sum[0][i]*sum[1][j]%mod*sum[2][i^j])%mod;\n    cout<<ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\nconst int   mod = 998244353;\n\nvoid add(int &a,int b)  {\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvoid sub(int &a,int b)  {\n    a -= b;\n    if (a <  0)\n        a += mod;\n}\nint mul(int a,int b)    {\n    return  1ll * a * b % mod;\n}\nint Pow(int a,int b)    {\n    int ans = 1;\n    while (b)   {\n        if(b & 1)   ans = mul(ans,a);\n        a = mul(a,a);   b >>= 1;\n    }\n    return  ans;\n}\nint inv(int a,int p)    {\n    return  a == 1 ? 1 : p - 1ll * p * inv(p % a,a) / a;\n}\n\ntypedef pair<int,int>   ii;\ntypedef vector<int>     vi;\n\nvector<int> g[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    auto calc = [&]()   {\n        int m;  cin >> m;\n\n        set<int> S;\n        set<int> R;\n\n        for(int i = 1 ; i <= n ; ++i)   {\n            g[i].clear();\n            S.insert(i);\n        }\n        for(int i = 1 ; i <= m ; ++i)   {\n            int x;  cin >> x;\n            int y;  cin >> y;\n\n            g[x].pb(y);\n            g[y].pb(x);\n        }\n        vector<int> res;\n\n        while (S.size() || R.size())    {\n            int val = 0;\n\n            while (S.size())    {\n                int x = (*S.rbegin());\n                S.erase(x);\n\n                add(val,Pow(10,18 * x));\n\n                for(int u : g[x])\n                    if (S.count(u)) {\n                        S.erase(u);\n                        R.insert(u);\n                    }\n            }\n            res.pb(val);\n            S.swap(R);\n        }\n        return  res;\n    };\n    vector<int> v1 = calc();\n    vector<int> v2 = calc();\n    vector<int> v3 = calc();\n\n    int S = 1e9;\n\n    S = min(S,sz(v1));\n    S = min(S,sz(v2));\n    S = min(S,sz(v3));\n\n    v1.resize(S);\n    v2.resize(S);\n    v3.resize(S);\n\n    vector<vi>  ok(S,vi(S,1));\n\n    int ans = 0;\n\n    for(int i = 0 ; i < S ; ++i)    {\n        vector<bool> used(S,0);\n\n        for(int j = 0 ; j < S ; ++j)\n        for(int k = 0 ; k < S ; ++k)    if (ok[j][k] && !used[k])   {\n            int val = 1;\n            val = mul(val,v1[i]);\n            val = mul(val,v2[j]);\n            val = mul(val,v3[k]);\n\n            add(ans,val);\n\n            ok[j][k] = 0;\n            used [k] = 1;\n            break;\n        }\n        for(int j = 0 ; j < S ; ++j)\n        for(int k = 0 ; k < S ; ++k)\n            assert(ok[j][k] == ok[k][j]);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate<class T> inline void read(T &x){\n\tx=0; register char c=getchar(); register bool f=0;\n\twhile(!isdigit(c))f^=c=='-',c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\n\nconst int N=1e5+10,M=400,mod=998244353;\nint n,lim,max,m[3],sg[N];\nstd::vector<int> G[3][N];\n\nstruct z {\n\tint x;\n\tz(int x=0):x(x){}\n\tfriend inline z operator*(z a,z b){return (long long)a.x*b.x%mod;}\n\tfriend inline z operator-(z a,z b){return (a.x-=b.x)<0?a.x+mod:a.x;}\n\tfriend inline z operator+(z a,z b){return (a.x+=b.x)>=mod?a.x-mod:a.x;}\n}ans,pw[N],f[3][N],g[N];\ninline z fpow(z a,int b){z s=1;for(;b;b>>=1,a=a*a)if(b&1)s=s*a;return s;}\n\nvoid SG(int m,std::vector<int> G[N],int sg[N]){\n\tstatic bool vis[N];\n\tfor(int i=n;i>=1;i--){\n\t\tfor(int j:G[i])vis[sg[j]]=1;\n\t\tsg[i]=0;\n\t\twhile(vis[sg[i]])sg[i]++;\n\t\tfor(int j:G[i])vis[sg[j]]=0;\n\t}\n}\n\nvoid fwt(z *a){\n\tfor(int len=1;len<lim;len<<=1)\n\t\tfor(int i=0;i<lim;i+=(len<<1))\n\t\t\tfor(int j=0;j<len;j++){\n\t\t\t\tz x=a[i+j],y=a[i+j+len];\n\t\t\t\ta[i+j]=x+y,a[i+j+len]=x-y;\n\t\t\t}\n}\n\nint main(){\n#ifdef memset0\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tread(n),lim=sqrt(n);\n\tfor(int i=0;i<3;i++){\n\t\tread(m[i]);\n\t\tfor(int u,v,j=1;j<=m[i];j++){\n\t\t\tread(u),read(v);\n\t\t\t// G[i][u].push_back(v);\n\t\t\tG[i][std::min(u,v)].push_back(std::max(u,v));\n\t\t\t// G[i][std::max(u,v)].push_back(std::min(u,v));\n\t\t}\n\t}\n\tpw[0]=1,pw[1]=fpow(10,18);\n\tfor(int i=2;i<=n;i++)pw[i]=pw[i-1]*pw[1];\n\tfor(int i=0;i<3;i++){\n\t\tSG(m[i],G[i],sg);\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tmax=std::max(max,sg[j]);\n\t\t\tf[i][sg[j]]=f[i][sg[j]]+pw[j];\n\t\t}\n\t\t// for(int j=1;j<=n;j++){\n\t\t// \tprintf(\"%d%c\",sg[j],\" \\n\"[j==n]);\n\t\t// }\n\t}\n\tlim=1; while(lim<=max)lim<<=1;\n\t// for(int i=0;i<lim;i++)\n\t// \tfor(int j=0;j<lim;j++)\n\t// \t\tfor(int k=0;k<lim;k++){\n\t// \t\t\tg[i^j^k]=g[i^j^k]+f[0][i]*f[1][j]*f[2][k];\n\t// \t\t\t// if(f[0][i].x&&f[1][j].x&&f[2][k].x){\n\t// \t\t\t// \tprintf(\"%d %d %d : %d\\n\",i,j,k,f[0][i]*f[1][j]*f[2][k]);\n\t// \t\t\t// }\n\t// \t\t}\n\tfor(int i=0;i<3;i++)fwt(f[i]);\n\tfor(int i=0;i<lim;i++)g[i]=f[0][i]*f[1][i]*f[2][i];\n\tfwt(g);\n\tz invlim=fpow(lim,mod-2);\n\tfor(int i=0;i<lim;i++)g[i]=g[i]*invlim;\n\t// for(int i=0;i<lim;i++){\n\t// \tprintf(\"%d : %d\\n\",i,g[i]);\n\t// }\n\tprintf(\"%d\\n\",g[0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PP;\n\n/*\n freopen(\"input\",\"r\",stdin);\n freopen(\"output\",\"w\",stdout);\n*/\n\nll MOD = 998244353;\n\nvector<vector<int>> A, B, C;\nvector<ll> X,Y,Z;\n\nint N, M;\n\nll power(ll a, ll b) {\n    ll res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res *= a;\n            res %= MOD;\n        }\n        a *= a;\n        a %= MOD;\n        b /= 2;\n    }\n    return res;\n}\n\nll cal(const unordered_set<int>& s) {\n    ll v = 0;\n    for (const int t : s) {\n        v += power(10, t * 18);\n        v %= MOD;\n    }\n    return v;\n}\n\nvector<ll> process(const vector<vector<int>>& x) {\n    unordered_set<int> u;\n    vector<ll> res;\n    for (int i = N;i > 0;i--) {\n        if (u.find(i) != u.end()) continue;\n        unordered_set<int> s;\n        s.insert(i);\n        u.insert(i);\n        unordered_set<int> r;\n        r.insert(i);\n        for (auto m : x[i]) r.insert(m);\n        for (int j = i - 1;j > 0;j--) {\n            if (r.find(j) != r.end() || u.find(j) != u.end()) continue;\n            s.insert(j);\n            u.insert(j);\n            r.insert(j);\n            for (auto m : x[j]) r.insert(m);\n        }\n        res.push_back(cal(s));\n    }\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    cin >> N;\n    A.resize(N+1);\n    B.resize(N+1);\n    C.resize(N+1);\n    int a, b;\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        A[a].push_back(b);\n        A[b].push_back(a);\n    }\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        B[a].push_back(b);\n        B[b].push_back(a);\n    }\n    cin >> M;\n    for (int i = 0;i < M;i++) {\n        cin >> a >> b;\n        C[a].push_back(b);\n        C[b].push_back(a);\n    }\n    X = process(A);\n    Y = process(B);\n    Z = process(C);\n    ll ans = 0;\n    vector<set<int>> yx(Y.size());\n    for (int i = 0;i < Y.size();i++) {\n        for (int j = 0;j < X.size();j++) yx[i].insert(j);\n    }\n    for (int i = 0;i < Z.size();i++) {\n        ll z = Z[i];\n        unordered_set<int> use;\n        for (int j = 0;j < Y.size();j++) {\n            ll y = z * Y[j];\n            y %= MOD;\n            for (int k : yx[j]) {\n                if (use.find(k) == use.end()) {\n                    use.insert(k);\n                    yx[j].erase(k);\n                    ans += (y * X[k]) % MOD;\n                    ans %= MOD;\n                    break;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = 998244353;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 100 * 1000 + 13;\nconst int P = 800;\n\nint n;\nvector<int> g[3][N];\n\nbool read () {\n\tif (scanf(\"%d\", &n) != 1)\n\t\treturn false;\n\tforn(i, n) forn(j, 3)\n\t\tg[j][i].clear();\n\tforn(j, 3){\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tforn(i, m){\n\t\t\tint v, u;\n\t\t\tscanf(\"%d%d\", &v, &u);\n\t\t\t--v, --u;\n\t\t\tg[j][v].pb(u);\n\t\t\tg[j][u].pb(v);\n\t\t}\n\t}\n\treturn true;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * li(b) % MOD;\n}\n\nint binpow(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1)\n\t\t\tres = mul(res, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nint gr[3][N];\nint cnt[3][P];\n\nint calc(int i, int v){\n\tif (gr[i][v] != -1)\n\t\treturn gr[i][v];\n\tvector<int> tmp;\n\tfor (auto u : g[i][v]) if (u > v)\n\t\ttmp.pb(calc(i, u));\n\tsort(all(tmp));\n\tforn(i, sz(tmp)) if (tmp[i] != i)\n\t\treturn gr[i][v] = i;\n\treturn gr[i][v] = sz(tmp);\n}\n\nvoid solve() {\n\tmemset(gr, -1, sizeof(gr));\n\tmemset(cnt, 0, sizeof(cnt));\n\tint num = INF64 % MOD;\n\tforn(j, 3) forn(i, n) cnt[j][calc(j, i)] = add(cnt[j][calc(j, i)], binpow(num, i + 1));\n\tint ans = 0;\n\tforn(i, P) forn(j, P) if ((i ^ j) < P && cnt[0][i] && cnt[1][j] && cnt[2][i ^ j])\n\t\tans = add(ans, mul(mul(cnt[0][i], cnt[1][j]), cnt[2][i ^ j]));\n\tprintf(\"%d\\n\", ans);\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n#ifdef _DEBUG\n\twhile(read()) {\t\n#else\n\tif(read()) {\n#endif\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=998244353;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tint i,j,n;cin>>n;\n\tllint S=1000000000000000000LL%mod;\n\t\n\t\n\tvector<llint>kei(n);\n\tkei[0]=S;\n\tfor(i=0;i<n-1;i++){kei[i+1]=kei[i]*S%mod;}\n\tint Lq=1;\n\twhile(Lq*Lq<n){Lq++;}\n\tLq+=10;\n\tllint L=1;\n\twhile(L<Lq){L*=2;}\n\t//cerr<<\"L=\"<<L<<endl;\n\tvector<llint>ans(L);ans[0]=1;\n\tfor(int kai=0;kai<3;kai++){\n\t\tint m;cin>>m;\n\t\tvector<vector<int>>go(n);\n\t\twhile(m--){\n\t\t\tint a,b;cin>>a>>b;a--;b--;\n\t\t\tif(a<b){swap(a,b);}\n\t\t\tgo[b].pub(a);\n\t\t}\n\t\tvector<int>gru(n);\n\t\tvector<int>hyo(L,mod);\n\t\tvector<llint>gen(L,0);\n\t\tfor(i=n-1;i>=0;i--){\n\t\t\tfor(auto it:go[i]){hyo[gru[it]]=i;}\n\t\t\tint g=0;\n\t\t\twhile(hyo[g]==i){g++;}\n\t\t\tgru[i]=g;\n\t\t\tgen[g]+=kei[i];gen[g]%=mod;\n\t\t}\n\t\tvector<llint>dp(L,0);\n\t\tfor(i=0;i<L;i++){\n\t\t\t//cerr<<gen[i]<<endl;\n\t\t\tfor(j=0;j<L;j++){\n\t\t\t\tdp[i^j]+=ans[i]*gen[j];\n\t\t\t\tdp[i^j]%=mod;\n\t\t\t}\n\t\t}\n\t\tans=dp;\n\t}\n\tcout<<ans[0]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nconstexpr long long MOD = 998244353;\nconstexpr long long U = 1000000000000000000 % MOD;\n\nvoid input(vector<vector<int> >& V) {\n\tint M;\n\tcin >> M;\n\tfor (int i = 0; i < M; i++) {\n\t\tint A, B;\n\t\tcin >> A >> B;\n\t\tA--, B--;\n\t\tif (A > B) swap(A, B);\n\t\tV[A].push_back(B);\n\t}\n}\n\nvoid Grundy(vector<int>& G, vector<vector<int> >& V) {\n\tfor (int i = (int)V.size() - 1; i >= 0; i--) {\n\t\tif (V[i].empty()) {\n\t\t\tG[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> Gs;\n\t\tfor (int j : V[i]) {\n\t\t\tGs.push_back(G[j]);\n\t\t}\n\t\tsort(Gs.begin(), Gs.end());\n\t\tGs.erase(unique(Gs.begin(), Gs.end()), Gs.end());\n\t\tif (Gs[Gs.size() - 1] == Gs.size() - 1) {\n\t\t\tG[i] = Gs.size();\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < Gs.size(); j++) {\n\t\t\tif (Gs[j] != j) {\n\t\t\t\tGs[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long Pow(int A) {\n\tif (A == 0) return 1;\n\tif (A % 2 == 0) {\n\t\tlong long B = Pow(A / 2);\n\t\treturn (B * B) % MOD;\n\t}\n\treturn (U * Pow(A - 1)) % MOD;\n}\n\nvoid Count(vector<long long>& C, vector<int>& G) {\n\tfor (int i = 0; i < G.size(); i++) {\n\t\tC[G[i]] += Pow(i + 1);\n\t\tC[G[i]] %= MOD;\n\t}\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<vector<int> > X(N), Y(N), Z(N);\n\tvector<int> GX(N), GY(N), GZ(N);\n\tvector<long long> CX(512, 0), CY(512, 0), CZ(512, 0);\n\tinput(X), input(Y), input(Z);\n\tGrundy(GX, X), Grundy(GY, Y), Grundy(GZ, Z);\n\tCount(CX, GX), Count(CY, GY), Count(CZ, GZ);\n\tlong long ANS = 0;\n\tfor (int i = 0; i < 512; i++) {\n\t\tfor (int j = 0; j < 512; j++) {\n\t\t\tlong long MUL = (CX[i] * CY[j]) % MOD;\n\t\t\tMUL *= CZ[i ^ j];\n\t\t\tMUL %= MOD;\n\t\t\tANS += MUL;\n\t\t\tANS %= MOD;\n\t\t}\n\t}\n\tcout << ANS << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// ███▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓╬╬╬╬╬╬▓█\n// ███▓███████▓▓╬╬╬╬╬╬╬╬╬╬╬╬▓███▓▓▓▓█▓╬╬╬▓█\n// ███████▓█████▓▓╬╬╬╬╬╬╬╬▓███▓╬╬╬╬╬╬╬▓╬╬▓█\n// ████▓▓▓▓╬╬▓█████╬╬╬╬╬╬███▓╬╬╬╬╬╬╬╬╬╬╬╬╬█\n// ███▓▓▓▓╬╬╬╬╬╬▓██╬╬╬╬╬╬▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬╬╬╬▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓███████▓▓███▓╬╬╬╬╬╬▓███████▓╬╬╬╬▓█\n// ████████████████▓█▓╬╬╬╬╬▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬█\n// ███▓▓▓▓▓▓▓╬╬▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ████▓▓▓╬╬╬╬▓▓▓▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// ███▓█▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓▓█▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█\n// █████▓▓▓▓▓▓▓██▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// █████▓▓▓▓▓████▓▓▓█▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓█▓▓▓▓██▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n// ████▓▓███▓▓▓▓▓▓▓██▓╬╬╬╬╬╬╬╬╬╬╬╬█▓╬▓╬╬▓██\n// █████▓███▓▓▓▓▓▓▓▓████▓▓╬╬╬╬╬╬╬█▓╬╬╬╬╬▓██\n// █████▓▓█▓███▓▓▓████╬▓█▓▓╬╬╬▓▓█▓╬╬╬╬╬╬███\n// ██████▓██▓███████▓╬╬╬▓▓╬▓▓██▓╬╬╬╬╬╬╬▓███\n// ███████▓██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬████\n// ███████▓▓██▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓████\n// ████████▓▓▓█████▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓█████\n// █████████▓▓▓█▓▓▓▓▓███▓╬╬╬╬╬╬╬╬╬╬╬▓██████\n// ██████████▓▓▓█▓▓▓╬▓██╬╬╬╬╬╬╬╬╬╬╬▓███████\n// ███████████▓▓█▓▓▓▓███▓╬╬╬╬╬╬╬╬╬▓████████\n// ██████████████▓▓▓███▓▓╬╬╬╬╬╬╬╬██████████\n// ███████████████▓▓▓██▓▓╬╬╬╬╬╬▓███████████\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 10;\nconst int M = 998244353;\n\nstring to_string(string s)\n{\n    return '\"' + s + '\"';\n}\nstring to_string(const char* s)\n{\n    return to_string((string) s);\n}\nstring to_string(bool b)\n{\n    return (b ? \"true\" : \"false\");\n}\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p)\n{\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v)\n{\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v)\n    {\n        if (!first)\n        {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\nvoid debug_out()\n{\n    cerr << endl;\n}\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T)\n{\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n//#define LOCAL\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main()\n{\n    ios::sync_with_stdio(0),cin.tie(0);\n\n    // total O(M)\n    int n, m;\n    cin>>n;\n\n    vector<long long> pw(n);\n    pw[0] = 1000000000000000000 % M;\n    for(int i=1;i<n;i++){\n        pw[i] = pw[i-1] * pw[0] % M;\n    }\n\n\n\n    int u, v;\n    vector<vector<vector<int>>> mex;\n\n    vector<int> p(3);\n\n    vector<vector<int>> g(n, vector<int>());\n    vector<int> rk(n);\n\n\n    for(int j=0; j<3; j++)\n    {\n        for(int i=0; i<n; i++)\n        {\n            g[i].clear();\n        }\n        cin>>m;\n        for(int i=0; i<m; i++)\n        {\n            cin>>u>>v;\n            u--,v--;\n            if(u>v)\n            {\n                swap(u,v);\n            }\n            g[u].push_back(v);\n        }\n\n//    debug(g);\n        mex.push_back(vector<vector<int>>());\n\n\n        vector<int> nums(n);\n\n        for(int i=n-1; i>=0; i--)\n        {\n            int num=0;\n            int sz = mex[j].size();\n//            debug(sz);\n            for(int k=0;k<sz;k++){\n                nums[k]=0;\n            }\n\n            for(int j : g[i])\n            {\n                nums[rk[j]]=1;\n            }\n\n//            debug(nums);\n            num=sz;\n            for(int j=0;j<sz;j++){\n                if(nums[j]==0){\n                    num=j;\n                    break;\n                }\n            }\n            if(num == sz)\n            {\n                mex[j].push_back(vector<int>());\n            }\n            mex[j][num].push_back(i);\n            rk[i]=num;\n        }\n        p[j]=mex[j].size();\n    }\n\n    debug(mex);\n\n    long long ans=0;\n    for(int i=0; i<p[0]; i++)\n        for(int j=0; j<p[1]; j++)\n        {\n            int k=i^j;\n            if(k>=p[2])\n                continue;\n            if(mex[0][i].size()==0)\n                continue;\n            if(mex[1][j].size()==0)\n                continue;\n            if(mex[2][k].size()==0)\n                continue;\n            //i,j,k\n            long long sum=0, tmp=1;\n//    debug(mex[0][i]);\n            for(int a1 : mex[0][i])\n            {\n                sum = sum + tmp * pw[a1] % M;\n                sum %= M;\n            }\n            tmp = sum;\n\n            sum = 0 ;\n\n//    debug(mex[1][j]);\n            for(int a2 : mex[1][j])\n            {\n                sum = sum + tmp * pw[a2] % M;\n                sum %= M;\n            }\n            tmp = sum;\n\n            sum = 0;\n//    debug(mex[2][k]);\n\n            for(int a3 : mex[2][k])\n            {\n                sum = sum + tmp * pw[a3] % M;\n                sum %= M;\n            }\n//    debug(sum);\n            ans = ans + sum;\n            ans %= M;\n        }\n    debug(ans);\n    cout << ans << \"\\n\";\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\nnamespace dfcmd {\n\n    typedef long long LL;\n\n    const int maxn = 100005;\n    const int mod = 998244353;\n    const int di = 1000000000000000000LL % mod;\n\n    int bin[maxn];\n\n    inline void add(int& x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    int n;\n\n    struct myhnb {\n        int m;\n        int sg[maxn];\n        int ss[maxn];\n\n        struct Edge {\n            int to, nxt;\n        } e[maxn];\n\n        int first[maxn];\n        int cnt = 0;\n        \n        inline void add_edge(int u, int v) {\n            if (u > v) {\n                swap(u, v);\n            }\n            e[++cnt].nxt = first[u];\n            first[u] = cnt;\n            e[cnt].to = v;\n        }\n\n        int vis[maxn];\n\n        myhnb() {\n            memset(first, 0, sizeof(first));\n            memset(ss, 0, sizeof(ss));\n            memset(vis, 0, sizeof(vis));\n        }\n\n        inline void Dfs() {\n            for (int now = n; now; --now) {\n                vis[now] = true;\n                set<int> sgg;\n                sgg.clear();\n                for (int i = first[now]; i; i = e[i].nxt) {\n                    sgg.insert(sg[e[i].to]);\n                }\n                sg[now] = 0;\n                while (sgg.count(sg[now])) {\n                    sg[now]++;\n                }\n                add(ss[sg[now]], bin[now]);\n            }\n        }\n\n        inline int& operator [] (int x) {\n            return ss[x];\n        }\n    } d[3];\n\n    int main() {\n        read(n);\n        bin[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            bin[i] = (LL) bin[i - 1] * di % mod;\n        }\n        for (int i = 0; i < 3; ++i) {\n            read(d[i].m);\n            for (int j = 1; j <= d[i].m; ++j) {\n                int u, v;\n                read(u), read(v);\n                d[i].add_edge(u, v);\n            }\n            d[i].Dfs();\n//            cout << \"sg = \";\n//            for (int j = 1; j <= n; ++j) {\n//                cout << d[i].sg[j] << ' ';\n//            }\n//            cout << endl;\n        }\n        int ans = 0;\n        for (int i = 0; i <= 1000; ++i) {\n            for (int j = 0; j <= 1000; ++j) {\n                add(ans, (LL) d[0][i] * d[1][j] % mod * d[2][i ^ j] % mod);\n            }\n        }\n        writeln(ans);\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int S = 500, SSS = S * S * S, N = 1e5 + 5, mod = 998244353;\n \nlong long powmod(long long b, long long p) {\n  long long r = 1;\n  for (; p; p >>= 1, b = b * b % mod)\n    if (p & 1)\n      r = r * b % mod;\n  return r;\n}\n \nconst int base = powmod(10, 18);\n \nbitset<SSS> vis;\n \nint pos(int a, int b, int c) {\n  return ((a * S) + b) * S + c;\n}\n \ntuple<int, int, int> decod(int v) {\n  int c = v % S;\n  v /= S;\n  int b = v % S;\n  v /= S;\n  return make_tuple(v, b, c);\n}\n \nvector<int> g[N];\n \nvector<pair<int, int>> independent(int n, vector<pair<int ,int>> & edges) {\n  for (int i = 0; i < n; ++i)\n    g[i].clear();\n  for (auto e : edges) {\n    g[e.first].push_back(e.second);\n    g[e.second].push_back(e.first);\n  }\n  vector<bool> done(n, false), mark(n);\n  int cnt = 0;\n  vector<pair<int, int>> res;\n  while (cnt < n) {\n    mark = done;\n    int hig = -1, sum = 0;\n    for (int v = n-1; v >= 0; --v) {\n      if (mark[v]) continue;\n      ++cnt;\n      done[v] = 1;\n      hig = max(hig, v+1);\n      sum = (sum + powmod(base, v+1)) % mod;\n      for (int u : g[v]) {\n        mark[u] = 1;\n      }\n    }\n    res.emplace_back(hig, sum);\n  }\n  return res;\n}\n \nvector<pair<int, int>> read_edges() {\n  int m;\n  scanf(\"%d\", &m);\n  vector<pair<int, int>> edges(m);\n  for (int i = 0; i < m; ++i) {\n    scanf(\"%d %d\", &edges[i].first, &edges[i].second);\n    --edges[i].first;\n    --edges[i].second;\n  }\n  return edges;\n}\n \nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vector<pair<int, int>> ex = read_edges();\n  vector<pair<int, int>> ey = read_edges();\n  vector<pair<int, int>> ez = read_edges();\n  vector<pair<int, int>> rx = independent(n, ex);\n  vector<pair<int, int>> ry = independent(n, ey);\n  vector<pair<int, int>> rz = independent(n, ez);\n  assert(rx.size() < S);\n  assert(ry.size() < S);\n  assert(rz.size() < S);\n  vector<vector<bool>> xy(rx.size(), vector<bool>(ry.size(), false));\n  vector<vector<bool>> xz(rx.size(), vector<bool>(rz.size(), false));\n  vector<vector<bool>> yz(ry.size(), vector<bool>(rz.size(), false));\n  // priority_queue<pair<int, int>> pq;\n  // auto insert_node = [&](int i, int j, int k) {\n  //   if (i >= (int)rx.size() || j >= (int)ry.size() || k >= (int)rz.size())\n  //     return;\n  //   int now = pos(i, j, k);\n  //   if (vis[now])\n  //     return;\n  //   pq.emplace(rx[i].first + ry[j].first + rz[k].first, now);\n  //   vis[now] = 1;\n  // };\n\n  // insert_node(0, 0, 0);\n  vector<pair<int, int>> all;\n  for (int i = 0; i < (int)rx.size(); ++i) {\n    for (int j = 0; j< (int)ry.size(); ++j) {\n      for (int k = 0; k < (int)rz.size(); ++k) {\n        all.emplace_back(rx[i].first + ry[j].first + rz[k].first, pos(i, j, k));\n      }\n    }\n  }\n  sort(all.begin(), all.end());\n  reverse(all.begin(), all.end());\n  long long ans = 0;\n  for (auto it : all) {\n    int i, j, k;\n    tie(i, j, k) = decod(it.second);\n    // insert_node(i+1, j, k);\n    // insert_node(i, j+1, k);\n    // insert_node(i, j, k+1);\n    if (xy[i][j] || xz[i][k] || yz[j][k]) continue;\n    long long cur = rx[i].second * (long long) ry[j].second % mod;\n    cur = cur * rz[k].second % mod;\n    ans = (ans + cur) % mod;\n    xy[i][j] = 1;\n    xz[i][k] = 1;\n    yz[j][k] = 1;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\nint\tmain(void)\n{\n\tint L;\n\tscanf(\"%d\", &L);\n\tif(L%3 == 0)\n\t{\n\t\tint c = L/3;\n\t\tprintf(\"%d\\n\", c*c*c);\n\t\treturn(0);\n\t}\n\tlong double c_ld_L;\n\tc_ld_L = L*L*L;\n\tprintf(\"%.16Lf\\n\", c_ld_L/9);\n\treturn (0);\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            CGiantGraph solver = new CGiantGraph();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class CGiantGraph {\n        Modular mod = new Modular(998244353);\n        IntegerVersionArray iva = new IntegerVersionArray(10000);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            Node[][] nodes = new Node[3][n];\n\n            int sqrt = (int) Math.sqrt(2e5) + 1;\n            int[][] sum = new int[3][sqrt + 1];\n\n            int base = mod.valueOf((long) 1e18);\n            CachedPow pow = new CachedPow(base, mod);\n\n\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < n; j++) {\n                    nodes[i][j] = new Node();\n                    nodes[i][j].id = j + 1;\n                }\n                int m = in.readInt();\n                for (int j = 0; j < m; j++) {\n                    Node a = nodes[i][in.readInt() - 1];\n                    Node b = nodes[i][in.readInt() - 1];\n                    if (a.id > b.id) {\n                        Node tmp = a;\n                        a = b;\n                        b = tmp;\n                    }\n                    a.next.add(b);\n                }\n\n                for (int j = 0; j < n; j++) {\n                    dfsForSG(nodes[i][j]);\n                }\n                for (Node node : nodes[i]) {\n                    sum[i][node.sg] = mod.plus(sum[i][node.sg], pow.pow(node.id));\n                }\n            }\n\n            int ans = 0;\n            for (int i = 0; i <= sqrt; i++) {\n                for (int j = 0; j <= sqrt; j++) {\n                    int k = i ^ j;\n                    if (k > sqrt) {\n                        continue;\n                    }\n                    int local = mod.mul(sum[0][i], mod.mul(sum[1][j], sum[2][k]));\n                    ans = mod.plus(ans, local);\n                }\n            }\n\n            out.println(ans);\n        }\n\n        public void dfsForSG(Node root) {\n            if (root.visited) {\n                return;\n            }\n            root.visited = true;\n            for (Node node : root.next) {\n                dfsForSG(node);\n            }\n            iva.clear();\n            for (Node node : root.next) {\n                iva.set(node.sg, 1);\n            }\n            while (iva.get(root.sg) == 1) {\n                root.sg++;\n            }\n        }\n\n    }\n\n    static class Node {\n        List<Node> next = new ArrayList<>();\n        int sg;\n        int id;\n        boolean visited;\n\n    }\n\n    static class IntegerVersionArray {\n        int[] data;\n        int[] version;\n        int now;\n        int def;\n\n        public IntegerVersionArray(int cap) {\n            this(cap, 0);\n        }\n\n        public IntegerVersionArray(int cap, int def) {\n            data = new int[cap];\n            version = new int[cap];\n            now = 0;\n            this.def = def;\n        }\n\n        public void clear() {\n            now++;\n        }\n\n        public void visit(int i) {\n            if (version[i] < now) {\n                version[i] = now;\n                data[i] = def;\n            }\n        }\n\n        public void set(int i, int v) {\n            version[i] = now;\n            data[i] = v;\n        }\n\n        public int get(int i) {\n            visit(i);\n            return data[i];\n        }\n\n    }\n\n    static class CachedPow {\n        private int[] first;\n        private int[] second;\n        private Modular mod;\n        private Modular powMod;\n        private static int step = 16;\n        private static int limit = 1 << step;\n        private static int mask = limit - 1;\n\n        public CachedPow(int x, Modular mod) {\n            this.mod = mod;\n            this.powMod = mod.getModularForPowerComputation();\n            first = new int[limit];\n            second = new int[Integer.MAX_VALUE / limit + 1];\n            first[0] = 1;\n            for (int i = 1; i < first.length; i++) {\n                first[i] = mod.mul(x, first[i - 1]);\n            }\n            second[0] = 1;\n            int step = mod.mul(x, first[first.length - 1]);\n            for (int i = 1; i < second.length; i++) {\n                second[i] = mod.mul(second[i - 1], step);\n            }\n        }\n\n        public int pow(int exp) {\n            return mod.mul(first[exp & mask], second[exp >> step]);\n        }\n\n    }\n\n    static class Modular {\n        int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public Modular(long m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public Modular(double m) {\n            this.m = (int) m;\n            if (this.m != m) {\n                throw new IllegalArgumentException();\n            }\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        public Modular getModularForPowerComputation() {\n            return new Modular(m - 1);\n        }\n\n        public String toString() {\n            return \"mod \" + m;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.copyOf;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic class IntList {\n\n\t\tint data[] = new int[3];\n\t\tint size = 0;\n\n\t\tboolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\tint size() {\n\t\t\treturn size;\n\t\t}\n\n\t\tint get(int index) {\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\treturn data[index];\n\t\t}\n\n\t\tvoid clear() {\n\t\t\tsize = 0;\n\t\t}\n\n\t\tvoid set(int index, int value) {\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\tdata[index] = value;\n\t\t}\n\n\t\tvoid expand() {\n\t\t\tif (size >= data.length) {\n\t\t\t\tdata = copyOf(data, (data.length << 1) + 1);\n\t\t\t}\n\t\t}\n\n\t\tvoid insert(int index, int value) {\n\t\t\tif (index < 0 || index > size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\texpand();\n\t\t\tarraycopy(data, index, data, index + 1, size++ - index);\n\t\t\tdata[index] = value;\n\t\t}\n\n\t\tint delete(int index) {\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\tint value = data[index];\n\t\t\tarraycopy(data, index + 1, data, index, --size - index);\n\t\t\treturn value;\n\t\t}\n\n\t\tvoid push(int value) {\n\t\t\texpand();\n\t\t\tdata[size++] = value;\n\t\t}\n\n\t\tint pop() {\n\t\t\tif (size == 0) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\treturn data[--size];\n\t\t}\n\n\t\tvoid unshift(int value) {\n\t\t\texpand();\n\t\t\tarraycopy(data, 0, data, 1, size++);\n\t\t\tdata[0] = value;\n\t\t}\n\n\t\tint shift() {\n\t\t\tif (size == 0) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tint value = data[0];\n\t\t\tarraycopy(data, 1, data, 0, --size);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tstatic final int MOD = 998244353;\n\tstatic final int MUL = 716070898;\n\tstatic final int HALF = 499122177;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic void hadamard(int n, int a[]) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 1 << i; j < 1 << n; j = (j + 1) | (1 << i)) {\n\t\t\t\tint x = a[j - (1 << i)], y = a[j];\n\t\t\t\ta[j - (1 << i)] = add(x, y);\n\t\t\t\ta[j] = sub(x, y);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int[] readGraph(int n) throws IOException {\n\t\tint m = scanInt();\n\t\tIntList edges[] = new IntList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tedges[i] = new IntList();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a = scanInt() - 1, b = scanInt() - 1;\n\t\t\tif (a > b) {\n\t\t\t\tint t = a;\n\t\t\t\ta = b;\n\t\t\t\tb = t;\n\t\t\t}\n\t\t\tif (a != b) {\n\t\t\t\tedges[a].push(b);\n\t\t\t}\n\t\t}\n\t\tint gr[] = new int[n];\n\t\tboolean mex[] = new boolean[n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < edges[i].size; j++) {\n\t\t\t\tmex[gr[edges[i].data[j]]] = true;\n\t\t\t}\n\t\t\tfor (int j = 0;; j++) {\n\t\t\t\tif (!mex[j]) {\n\t\t\t\t\tgr[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < edges[i].size; j++) {\n\t\t\t\tmex[gr[edges[i].data[j]]] = false;\n\t\t\t}\n\t\t}\n\t\tint p2 = Integer.highestOneBit(n - 1) << 1;\n\t\tint cnt[] = new int[p2];\n\t\tfor (int i = 0, v = MUL; i < n; i++, v = mul(v, MUL)) {\n\t\t\tcnt[gr[i]] = add(cnt[gr[i]], v);\n\t\t}\n\t\thadamard(Integer.numberOfTrailingZeros(p2), cnt);\n\t\treturn cnt;\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tint a[] = readGraph(n), b[] = readGraph(n), c[] = readGraph(n);\n\t\tint mul = 1;\n\t\tfor (int i = Integer.numberOfTrailingZeros(a.length); i > 0; i--) {\n\t\t\tmul = mul(mul, HALF);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tans = add(ans, mul(mul(mul(a[i], b[i]), c[i]), mul));\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Set;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic int mod = 998244353;\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint h = Integer.highestOneBit(n)*2;\n\t\tlong[] a = fwht(Arrays.copyOf(go(n), h), mod);\n\t\tlong[] b = fwht(Arrays.copyOf(go(n), h), mod);\n\t\tlong[] c = fwht(Arrays.copyOf(go(n), h), mod);\n\t\t\n\t\tlong[] d = new long[h];\n\t\tfor(int i = 0;i < h;i++){\n\t\t\td[i] = a[i] * b[i] % mod * c[i]%mod;\n\t\t}\n\t\td = fwht(d, mod);\n\t\t\n\t\tout.println(d[0]*invl(h, mod) % mod);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tstatic long Z = 1000000000000000000L % mod;\n\tstatic long[] pows = enumPows((int)Z, 100005, mod);\n\t\n\tstatic long[] go(int n)\n\t{\n\t\tint m = ni();\n\t\tint[] from = new int[m];\n\t\tint[] to = new int[m];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t}\n\t\tint[][] g = packU(n, from, to);\n\t\t\n\t\tint[] ved = new int[n];\n\t\tArrays.fill(ved, -1);\n\t\tlong[] ret = new long[n];\n\t\t\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tSet<Integer> set = new HashSet<>();\n\t\t\tfor(int e : g[i]){\n\t\t\t\tset.add(ved[e]);\n\t\t\t}\n\t\t\tfor(int j = 0;;j++){\n\t\t\t\tif(!set.contains(j)){\n\t\t\t\t\tved[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ph = ved[i];\n\t\t\tret[ph] += pows[i+1];\n\t\t\tif(ret[ph] >= mod)ret[ph] -= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tpublic static long[] enumPows(int a, int n, int mod)\n\t{\n\t\ta %= mod;\n\t\tlong[] pows = new long[n+1];\n\t\tpows[0] = 1;\n\t\tfor(int i = 1;i <= n;i++)pows[i] = pows[i-1] * a % mod;\n\t\treturn pows;\n\t}\n\n\t\n\tpublic static long[] fwht(long[] a, int mod)\n\t{\n\t\tint n = a.length;\n\t\tassert (n&n-1) == 0;\n\t\ta = Arrays.copyOf(a, n);\n\t\tfor(int w = Integer.numberOfTrailingZeros(n)-1;w >= 0;w--){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(i<<~w>=0){\n\t\t\t\t\tlong nal = a[i]+a[i|1<<w];\n\t\t\t\t\tlong nar = a[i]-a[i|1<<w];\n\t\t\t\t\tif(nal >= mod)nal -= mod;\n\t\t\t\t\tif(nar < 0)nar += mod;\n\t\t\t\t\ta[i] = nal; a[i|1<<w] = nar;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\t\n\tpublic static long pow(long a, long n, long mod) {\n\t\t//\t\ta %= mod;\n\t\tlong ret = 1;\n\t\tint x = 63 - Long.numberOfLeadingZeros(n);\n\t\tfor (; x >= 0; x--) {\n\t\t\tret = ret * ret % mod;\n\t\t\tif (n << 63 - x < 0)\n\t\t\t\tret = ret * a % mod;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    final int mod = 998244353;\n\n    int mul(int x, int y) {\n        return (int) ((x * 1L * y) % mod);\n    }\n\n    int add(int x, int y) {\n        x += y;\n        return x >= mod ? (x - mod) : x;\n    }\n\n    void solve() {\n        int n = in.nextInt();\n        List<Integer>[] g1 = readGraph(n), g2 = readGraph(n), g3 = readGraph(n);\n        boolean[] p1 = new boolean[n];\n        for (int i = n - 1; i >= 0; i--) {\n            p1[i] = true;\n            for (int to : g1[i]) {\n                if (p1[to]) {\n                    p1[i] = false;\n                    break;\n                }\n            }\n        }\n        boolean[] np1 = new boolean[n];\n        for (int i = n - 1; i >= 0; i--) {\n            np1[i] = true;\n            if (p1[i]) {\n                np1[i] = false;\n            } else {\n                for (int to : g1[i]) {\n                    if (np1[to]) {\n                        np1[i] = false;\n                        break;\n                    }\n                }\n            }\n        }\n        pow = new int[n + 2];\n        pow[0] = 1;\n        pow[1] = (int) (((long) 1e18) % mod);\n        for (int i = 2; i < pow.length; i++) {\n            pow[i] = mul(pow[i - 1], pow[1]);\n        }\n        int cp1 = calc(p1), cnp1 = calc(np1);\n        int[] type = getTypeByGraph(g2);\n        int costSquare = 0, costNotSquare = 0;\n        for (int i = 0; i < n; i++) {\n            if (type[i] == 1) {\n                costSquare = add(costSquare, mul(cp1, pow[i + 1]));\n                costNotSquare = add(costNotSquare, mul(cnp1, pow[i + 1]));\n            } else if (type[i] == 2) {\n                costSquare = add(costSquare, mul(cnp1, pow[i + 1]));\n                costNotSquare = add(costNotSquare, mul(cp1, pow[i + 1]));\n            }\n        }\n        int[] type3 = getTypeByGraph(g3);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (type3[i] == 1) {\n                res = add(res, mul(costSquare, pow[i + 1]));\n            } else if (type3[i] == 2) {\n                res = add(res, mul(costNotSquare, pow[i + 1]));\n            }\n        }\n        out.println(res);\n    }\n\n    int[] getTypeByGraph(List<Integer>[] g2) {\n        int n = g2.length;\n        int[] type = new int[n];\n        for (int i = n - 1; i >= 0; i--) {\n            boolean existP1 = false, existP2 = false;\n            for (int to : g2[i]) {\n                if (type[to] == 1) {\n                    existP1 = true;\n                } else if (type[to] == 2) {\n                    existP2 = true;\n                }\n            }\n            if (!existP1) {\n                type[i] = 1;\n            } else if (!existP2) {\n                type[i] = 2;\n            }\n        }\n        return type;\n    }\n\n    int calc(boolean[] a) {\n        int res = 0;\n        for (int i = 0; i < a.length; i++) {\n            if (a[i]) {\n                res = add(res, pow[i + 1]);\n            }\n        }\n        return res;\n    }\n\n    int[] pow;\n\n    List<Integer>[] readGraph(int n) {\n        List<Integer>[] g = new List[n];\n        for (int i = 0; i < n; i++) {\n            g[i] = new ArrayList<>();\n        }\n        int m = in.nextInt();\n        for (int i = 0; i < m; i++) {\n            int x = in.nextInt() - 1;\n            int y = in.nextInt() - 1;\n            g[Math.min(x, y)].add(Math.max(x, y));\n        }\n        return g;\n    }\n\n    void run() {\n        try {\n            in = new FastScanner(new File(\"Main.in\"));\n            out = new PrintWriter(new File(\"Main.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void runIO() {\n\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\n\npublic static class P\n{\n    static ModInt pow = new ModInt((long)1e18);\n    //static ModInt pow = new ModInt(10);\n    public static void Main()\n    {\n        #region READ_INPUT\n        int n = int.Parse(Console.ReadLine());\n\n        var m1 = int.Parse(Console.ReadLine());\n        List<int>[] graph1 = Enumerable.Repeat(0, n).Select(_ => new List<int>()).ToArray();\n        for (int i = 0; i < m1; i++)\n        {\n            var st = Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray();\n            graph1[st[0]].Add(st[1]);\n            graph1[st[1]].Add(st[0]);\n        }\n\n        var m2 = int.Parse(Console.ReadLine());\n        List<int>[] graph2 = Enumerable.Repeat(0, n).Select(_ => new List<int>()).ToArray();\n        for (int i = 0; i < m2; i++)\n        {\n            var st = Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray();\n            graph2[st[0]].Add(st[1]);\n            graph2[st[1]].Add(st[0]);\n        }\n\n        var m3 = int.Parse(Console.ReadLine());\n        List<int>[] graph3 = Enumerable.Repeat(0, n).Select(_ => new List<int>()).ToArray();\n        for (int i = 0; i < m3; i++)\n        {\n            var st = Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray();\n            graph3[st[0]].Add(st[1]);\n            graph3[st[1]].Add(st[0]);\n        }\n        #endregion   \n\n        var greedyRes1 = GetGreedyRes(graph1);\n        var greedyRes2 = GetGreedyRes(graph2);\n        var greedyRes3 = GetGreedyRes(graph3);\n\n        var res1 = GetHighDRes(new Tuple<ModInt, ModInt>(1, 0), greedyRes1);\n        var res2 = GetHighDRes(res1, greedyRes2);\n        var res3 = GetHighDRes(res2, greedyRes3);\n        Console.WriteLine(res3.Item1 * pow * pow * pow);\n    }\n    static Tuple<ModInt, ModInt> GetHighDRes(Tuple<ModInt, ModInt> lowDRes, Tuple<bool[], bool[]> greedyRes)\n    {\n        bool[] freeMatch = greedyRes.Item1;\n        bool[] strictedMatch = greedyRes.Item2;\n        ModInt freeRes = 0;\n        ModInt strictedRes = 0;\n        ModInt curPowedFreeRes = lowDRes.Item1;\n        ModInt curPowedStrictedRes = lowDRes.Item2;\n        for (int i = 0; i < freeMatch.Length; i++)\n        {\n            if (freeMatch[i]) freeRes += curPowedFreeRes;\n            else freeRes += curPowedStrictedRes;\n            \n            if (strictedMatch[i]) strictedRes += curPowedFreeRes;\n            else strictedRes += curPowedStrictedRes;\n\n            curPowedFreeRes *= pow;\n            curPowedStrictedRes *= pow;\n        }\n        return new Tuple<ModInt, ModInt>(freeRes, strictedRes);\n    }\n    static Tuple<bool[], bool[]> GetGreedyRes(List<int>[] graph)\n    {\n        var freeRes = Enumerable.Repeat(true, graph.Length).ToArray();\n        for (int i = freeRes.Length - 1; i >= 0; i--)\n        {\n            if (!freeRes[i]) continue;\n            foreach (var adj in graph[i])\n            {\n                //if (i < adj) throw new Exception();\n                freeRes[adj] = false;\n            }\n        }\n        //↓ 上のやつとつながってて、だめですよ用に計算したもの\n        var strictedRes = Enumerable.Repeat(true, graph.Length).ToArray();\n        for (int i = freeRes.Length - 1; i >= 0; i--)\n        {\n            if (!strictedRes[i]) continue;\n            if (freeRes[i]) //もし上がOKだったら、\n            {\n                strictedRes[i] = false; //当然だめ\n                continue;\n            }\n            foreach (var adj in graph[i])\n            {\n                //if (i < adj) throw new Exception();\n                strictedRes[adj] = false;\n            }\n        }\n\n        return new Tuple<bool[], bool[]>(freeRes, strictedRes);\n    }\n}\n\n\nstruct ModInt\n{\n    public const int Mod = 998244353;\n    const long POSITIVIZER = ((long)Mod) << 31;\n    long Data;\n    public ModInt(long data) { if ((Data = data % Mod) < 0) Data += Mod; }\n    public static implicit operator long(ModInt modInt) => modInt.Data;\n    public static implicit operator ModInt(long val) => new ModInt(val);\n    public static ModInt operator +(ModInt a, int b) => new ModInt() { Data = (a.Data + b + POSITIVIZER) % Mod };\n    public static ModInt operator +(ModInt a, long b) => new ModInt(a.Data + b);\n    public static ModInt operator +(ModInt a, ModInt b) { long res = a.Data + b.Data; return new ModInt() { Data = res >= Mod ? res - Mod : res }; }\n    public static ModInt operator -(ModInt a, int b) => new ModInt() { Data = (a.Data - b + POSITIVIZER) % Mod };\n    public static ModInt operator -(ModInt a, long b) => new ModInt(a.Data - b);\n    public static ModInt operator -(ModInt a, ModInt b) { long res = a.Data - b.Data; return new ModInt() { Data = res < 0 ? res + Mod : res }; }\n    public static ModInt operator *(ModInt a, int b) => new ModInt(a.Data * b);\n    public static ModInt operator *(ModInt a, long b) => a * new ModInt(b);\n    public static ModInt operator *(ModInt a, ModInt b) => new ModInt() { Data = a.Data * b.Data % Mod };\n    public static ModInt operator /(ModInt a, ModInt b) => new ModInt() { Data = a.Data * GetInverse(b) % Mod };\n    public static bool operator ==(ModInt a, ModInt b) => a.Data == b.Data;\n    public static bool operator !=(ModInt a, ModInt b) => a.Data != b.Data;\n    public override string ToString() => Data.ToString();\n    public override bool Equals(object obj) => (ModInt)obj == this;\n    public override int GetHashCode() => (int)Data;\n    static long GetInverse(long a)\n    {\n        long div, p = Mod, x1 = 1, y1 = 0, x2 = 0, y2 = 1;\n        while (true)\n        {\n            if (p == 1) return x2 + Mod; div = a / p; x1 -= x2 * div; y1 -= y2 * div; a %= p;\n            if (a == 1) return x1 + Mod; div = p / a; x2 -= x1 * div; y2 -= y1 * div; p %= a;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ClassLibrary1\n{\n    public class ListNode\n    {\n        public int val;\n        public ListNode next;\n        public ListNode(int x) { val = x; }\n    }\n\n\n    public class Class1\n    {\n        //static Dictionary<Tuple<long, long>, long> dic = new Dictionary<Tuple<long, long>, long>();\n\n        static long mod = 1000000007;\n        static long[] factorial = new long[1000001];\n        static long[] invFactorial = new long[1000001];\n\n        private static void calcFanctorial(long N)\n        {\n            factorial[0] = 1;\n            for (int i = 1; i < N + 1; i++)\n            {\n                factorial[i] = factorial[i - 1] * i;\n                factorial[i] %= mod;\n            }\n            invFactorial[N] = inv(factorial[N]);\n            for (int i = (int)N; i > 0; i--)\n            {\n                invFactorial[i - 1] = invFactorial[i] * i % mod;\n            }\n\n        }\n\n        static void Main(string[] args)\n        {\n            var N = ReadLongArr();\n\n            var mtx = ReadCharMatrix(N[0]);\n\n            \n\n            Console.WriteLine(count(mtx, 0, N[0]-1, 0, N[1]-1, false));\n\n\n        }\n\n        static long count(char[][] mtx, long hstart, long hend, long wstart, long wend, bool rev)\n        {\n            if(hstart > hend || wstart > wend)\n            {\n                return long.MaxValue;\n            }\n            if(wstart == wend && hstart == hend)\n            {\n                if ((mtx[hstart][wstart] == '.' || mtx[hstart][wstart] != '.' && rev)) return 0;\n                else return 1;\n            }\n\n            if ((mtx[hstart][wstart] == '.' && !rev || mtx[hstart][wstart] != '.' && rev))\n            {\n                return Math.Min(count(mtx, hstart + 1, hend, wstart, wend, rev), count(mtx, hstart, hend, wstart + 1, wend, rev));\n            }else\n            {\n                return 1 + Math.Min(count(mtx, hstart + 1, hend, wstart, wend, rev), count(mtx, hstart, hend, wstart + 1, wend, !rev));\n            }\n\n        }\n\n        class Tree\n        {\n            public HashSet<long> conn = new HashSet<long>();\n        }\n\n\n        static long bin(long a, long x, long n)\n        {\n            long y = a;\n            long res = 1;\n            while(x>0)\n            {\n                if (x%2 == 1){\n                    res = res * y % n;\n                }\n                x /= 2;\n                y = y * y % n;\n            }\n            return res ;\n        }\n\n        int cmp(string a, string b) { \n            for (var i = 0; i < Math.Min(a.Length, b.Length); i++)\n                if (a[i] < b[i]) return -1;\n                else if (a[i] > b[i]) return 1;\n            if (a.Length == b.Length) return 0;\n            if (a.Length > b.Length) return 1;\n            else return -1;\n        }\n\n        private static long nCm(long n, long m)\n        {\n            if (n < m) return 0;\n            if (m < 0) return 0;\n\n            return (factorial[n] * invFactorial[m] % mod) * invFactorial[n - m] % mod;\n        }\n\n        private static long nCm2(long n, long m)\n        {\n            if (n < m) return 0;\n            if (m < 0) return 0;\n\n            long res = 1;\n            for(long i = n; i>n-m; i--)\n            {\n                res *= i;\n                res %= mod;\n            }\n\n            return res * invFactorial[m] % mod;\n        }\n\n        public static long pow(long a, long b, long mod)\n        {\n            a %= mod;\n\n            if (b <= 0) return 1;\n            var t = pow(a, b / 2, mod);\n            if ((b & 1) == 0) return t * t % mod;\n            return t * t % mod * a % mod;\n        }\n\n        public static long Lcm(long a, long b)\n        {\n            return a * b % mod * inv(Gcd(a, b)) % mod;\n        }\n\n        public static long Lcm(long[] a)\n        {\n            List<long> vect = new List<long>();\n            long lcm = 1;\n            for (int i = 0; i < a.Count(); i++)\n            {\n                var factor = a[i] / GcdVector(vect, a[i]);\n                vect.Add(factor);\n                lcm = lcm * factor % mod;\n            }\n            return lcm;\n        }\n\n        static long GcdVector(List<long> a, long b)\n        {\n            long ma = 1;\n            for (int i = 0; i < a.Count; i++)\n                ma = ma * a[i] % b;\n            return Gcd(b, ma);\n        }\n\n        public static long Gcd(long a, long b)\n        {\n            if (a < b)\n                // 引数を入替えて自分を呼び出す\n                return Gcd(b, a);\n            while (b != 0)\n            {\n                var remainder = a % b;\n                a = b;\n                b = remainder;\n            }\n            return a;\n        }\n\n        public static long pow(long a, long b) => pow(a, b, mod);\n        public static long inv(long a) => pow(a, mod - 2);\n\n        private static char[][] ReadCharMatrix(long h)\n        {\n            char[][] mtx = new char[h][];\n            for (int i = 0; i < h; i++)\n            {\n                var s = ReadString();\n                mtx[i] = s.ToCharArray();\n            }\n            return mtx;\n        }\n\n        private static int[][] CreateIntMatrix(long h, long w)\n        {\n            int[][] mtx = new int[h][];\n            for (int i = 0; i < h; i++)\n            {\n                mtx[i] = new int[w];\n            }\n            return mtx;\n        }\n\n\n        private static string ReadString()\n        {\n            return Console.ReadLine();\n        }\n        private static string[] ReadStringArr()\n        {\n            return Console.ReadLine().Split(' ');\n        }\n        private static long ReadLong()\n        {\n            return long.Parse(Console.ReadLine());\n        }\n        private static long[] ReadLongArr()\n        {\n            string[] s = ReadStringArr();\n            long[] l = new long[s.Length];\n            for (int i = 0; i < l.Length; i++)\n            {\n                l[i] = long.Parse(s[i]);\n            }\n\n            return l;\n        }\n    }\n    class StringComparator2 : IComparer<string>\n    {\n        int IComparer<string>.Compare(string a, string b)\n        {\n            int length = Math.Min(a.Length, b.Length);\n            //Console.WriteLine(\"Comparing with length {0}\", length);\n            for (int i = 0; i < length; i++)\n            {\n                if (a[i] < b[i])\n                {\n                    //Console.WriteLine(\"returning -1\");\n                    return -1;\n                }\n                else if (a[i] > b[i]) return 1;\n            }\n            if (a.Length < b.Length) return -1;\n            if (a.Length > b.Length) return 1;\n\n            //Console.WriteLine(\"Why are we at the end?\");\n            return 0;\n        }\n    }\n\n    public class PriorityQueue<T> where T : IComparable\n    {\n        private IComparer<T> _comparer = null;\n        private int _type = 0;\n\n        private T[] _heap;\n        private int _sz = 0;\n\n        private int _count = 0;\n\n        /// <summary>\n        /// Priority Queue with custom comparer\n        /// </summary>\n        public PriorityQueue(int maxSize, IComparer<T> comparer)\n        {\n            _heap = new T[maxSize];\n            _comparer = comparer;\n        }\n\n        /// <summary>\n        /// Priority queue\n        /// </summary>\n        /// <param name=\"maxSize\">max size</param>\n        /// <param name=\"type\">0: asc, 1:desc</param>\n        public PriorityQueue(int maxSize, int type = 0)\n        {\n            _heap = new T[maxSize];\n            _type = type;\n        }\n\n        private int Compare(T x, T y)\n        {\n            if (_comparer != null) return _comparer.Compare(x, y);\n            return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n        }\n\n        public void Push(T x)\n        {\n            _count++;\n\n            //node number\n            var i = _sz++;\n\n            while (i > 0)\n            {\n                //parent node number\n                var p = (i - 1) / 2;\n\n                if (Compare(_heap[p], x) <= 0) break;\n\n                _heap[i] = _heap[p];\n                i = p;\n            }\n\n            _heap[i] = x;\n        }\n\n        public T Pop()\n        {\n            _count--;\n\n            T ret = _heap[0];\n            T x = _heap[--_sz];\n\n            int i = 0;\n            while (i * 2 + 1 < _sz)\n            {\n                //children\n                int a = i * 2 + 1;\n                int b = i * 2 + 2;\n\n                if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n                if (Compare(_heap[a], x) >= 0) break;\n\n                _heap[i] = _heap[a];\n                i = a;\n            }\n\n            _heap[i] = x;\n\n            return ret;\n        }\n\n        public int Count()\n        {\n            return _count;\n        }\n\n        public T Peek()\n        {\n            return _heap[0];\n        }\n\n        public bool Contains(T x)\n        {\n            for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n            return false;\n        }\n\n        public void Clear()\n        {\n            while (this.Count() > 0) this.Pop();\n        }\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            var ret = new List<T>();\n\n            while (this.Count() > 0)\n            {\n                ret.Add(this.Pop());\n            }\n\n            foreach (var r in ret)\n            {\n                this.Push(r);\n                yield return r;\n            }\n        }\n\n        public T[] ToArray()\n        {\n            T[] array = new T[_sz];\n            int i = 0;\n\n            foreach (var r in this)\n            {\n                array[i++] = r;\n            }\n\n            return array;\n        }\n    }\n\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        long bs = MyMath.pow(10, 18);\n        int n = sc.Int;\n        var edge = new List<int>[3][];\n        var mexsum = new long[3][];\n        for (int i = 0; i < 3; i++)\n        {\n            edge[i] = new List<int>[n];\n            for (int j = 0; j < n; j++)\n            {\n                edge[i][j] = new List<int>();\n            }\n            int m = sc.Int;\n            for (int j = 0; j < m; j++)\n            {\n                int u, v;\n                sc.Multi(out u, out v);\n                --u;\n                --v;\n                edge[i][u].Add(v);\n                edge[i][v].Add(u);\n            }\n            var mex = new int[n];\n            mexsum[i] = new long[1010];\n            for (int j = n - 1; j >= 0 ; j--)\n            {\n                var se = new HashSet<int>();\n                foreach (var item in edge[i][j])\n                {\n                    if (item < j) continue;\n                    se.Add(mex[item]);\n                }\n                for (int k = 0; ; k++)\n                {\n                    if (!se.Contains(k)) {\n                        mex[j] = k;\n                        // Assert(k < 1010);\n                        mexsum[i][k] = (mexsum[i][k] + MyMath.pow(bs, j + 1)) % M;\n                        break;\n                    }\n                }\n            }\n        }\n        long ans = 0;\n        for (int i = 0; i < 1010; i++)\n        {\n            for (int j = 0; j < 1010; j++)\n            {\n                if ((i ^ j) < 1010) {\n                    ans = (ans + mexsum[0][i] * mexsum[1][j] % M * mexsum[2][i ^ j]) % M;\n                }\n            }\n        }\n        Prt(ans);\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    // public static readonly int M = 1000000007;\n    public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        foreach (var cond in conds) if (!cond) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a) {\n        a = v[0];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b) {\n        a = v[0]; b = v[1];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c) {\n        a = v[0]; b = v[1]; c = v[2];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d, out T e) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3]; e = v[4];\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n\nstatic class MyMath {\n    public static long Mod = util.M;\n    // public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static int[] sieve2(int n) {\n        var p = new int[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = i;\n        for (int i = 2; i * i <= n; i++) {\n            if (p[i] == i)\n                for (int j = i * i; j <= n; j += i)\n                    p[j] = Math.Min(p[j], i);\n        }\n        return p;\n    }\n    public static bool[] segmentSieve(long l, long r) {\n        int sqn = (int)Math.Sqrt(r + 9);\n        var ps = getprimes(sqn);\n        return segmentSieve(l, r,ps);\n    }\n    public static bool[] segmentSieve(long l, long r, List<int> ps) {\n        var sieve = new bool[r - l + 1];\n        for (long i = l; i <= r; i++) sieve[i - l] = true;\n        foreach (long p in ps) {\n            if (p * p > r) break;\n            for (long i = p >= l ? p * p : (l + p - 1) / p * p; i <= r; i += p) sieve[i - l] = false;\n        }\n        return sieve;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long pow(long a, long b, long mod) {\n        a %= mod;\n        if (b < 0) Console.Error.WriteLine($\"power number is negative ({a}^{b}).\");\n        if (b <= 0) return 1;\n        var t = pow(a, b / 2, mod);\n        if ((b & 1) == 0) return t * t % mod;\n        return t * t % mod * a % mod;\n    }\n    public static long pow(long a, long b) => pow(a, b, Mod);\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) {\n            var t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n\n    // return (r, m): x = r (mod. m)\n    // return (0, -1) if no answer\n    public static pair<long, long> chineserem(IList<long> b, IList<long> m) {\n        long r = 0, M = 1;\n        for (int i = 0; i < b.Count; ++i) {\n            long p, q;\n            long d = extgcd(M, m[i], out p, out q); // p is inv of M/d (mod. m[i]/d)\n            if ((b[i] - r) % d != 0) return new pair<long, long>(0, -1);\n            long tmp = (b[i] - r) / d * p % (m[i]/d);\n            r += M * tmp;\n            M *= m[i]/d;\n        }\n        return new pair<long, long>((r % M + M) % M, M);\n    }\n\n    // return k: x^k = y (mod. mod) O(sqrt(mod))\n    public static long modlog(long x, long y, long mod) {\n        if (y == 1) return 0;\n        long H = (long)Math.Sqrt(mod) + 1;\n        var baby = new Dictionary<long, long>();\n        for (long b = 0, xby = y; b < H; b++, xby = (xby * x) % mod) {\n            if (!baby.ContainsKey(xby))\n                baby.Add(xby, b);\n            else\n                baby[xby] = b;\n        }\n\n        long xH = 1;\n        for (int i = 0; i < H; ++i) xH = xH * x % mod;\n        for (long a = 1, xaH = xH; a <= H; a++, xaH = (xaH * xH) % mod)\n            if (baby.ContainsKey(xaH))\n                return a * H - baby[xaH];\n\n        return -1;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts, invs;\n    public static void setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 1; i <= n; i++) facts[i] = facts[i - 1] * i % Mod;\n        invs = new long[n + 1];\n        invs[n] = inv(facts[n]);\n        for (int i = n; i > 0 ; i--) invs[i - 1] = invs[i] * i % Mod;\n    }\n    public static long fact(long n) {\n        if (n < 0) return 0;\n        if (facts != null && facts.Length > n) return facts[n];\n        long numer = 1;\n        for (long i = 1; i <= n; i++) numer = numer * (i % Mod) % Mod;\n        return numer;\n    }\n    public static long perm(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[n - r] % Mod;\n        long numer = 1;\n        for (long i = 0; i < r; i++) numer = numer * ((n - i) % Mod) % Mod;\n        return numer;\n    }\n    public static long comb(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[r] % Mod * invs[n - r] % Mod;\n        if (n - r < r) r = n - r;\n        long numer = 1, denom = 1;\n        for (long i = 0; i < r; i++) {\n            numer = numer * ((n - i) % Mod) % Mod;\n            denom = denom * ((i + 1) % Mod) % Mod;\n        }\n        return numer * inv(denom) % Mod;\n    }\n    public static long multi_choose(long n, long r) => comb(n + r - 1, r);\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n\n    public static class ModMatrix {\n        public static long[][] E(int n) {\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n            return ret;\n        }\n        public static long[][] pow(long[][] A, long n) {\n            if (n == 0) return E(A.Length);\n            var t = pow(A, n / 2);\n            if ((n & 1) == 0) return mul(t, t);\n            return mul(mul(t, t), A);\n        }\n        public static long dot(long[] x, long[] y) {\n            int n = x.Length;\n            long ret = 0;\n            for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n            return ret;\n        }\n        public static long[][] trans(long[][] A) {\n            int n = A[0].Length, m = A.Length;\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) { ret[i] = new long[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n            return ret;\n        }\n        public static long[] mul(long a, long[] x) {\n            int n = x.Length;\n            var ret = new long[n];\n            for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n            return ret;\n        }\n        public static long[] mul(long[][] A, long[] x) {\n            int n = A.Length;\n            var ret = new long[n];\n            for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n            return ret;\n        }\n        public static long[][] mul(long a, long[][] A) {\n            int n = A.Length;\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n            return ret;\n        }\n        public static long[][] mul(long[][] A, long[][] B) {\n            int n = A.Length;\n            var Bt = trans(B);\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n            return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\n\npublic static class P\n{\n    static ModInt pow = new ModInt((long)1e18);\n    //static ModInt pow = new ModInt(10);\n    public static void Main()\n    {\n        #region READ_INPUT\n        int n = int.Parse(Console.ReadLine());\n\n        var m1 = int.Parse(Console.ReadLine());\n        List<int>[] graph1 = Enumerable.Repeat(0, n).Select(_ => new List<int>()).ToArray();\n        for (int i = 0; i < m1; i++)\n        {\n            var st = Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray();\n            graph1[st[0]].Add(st[1]);\n            graph1[st[1]].Add(st[0]);\n        }\n\n        var m2 = int.Parse(Console.ReadLine());\n        List<int>[] graph2 = Enumerable.Repeat(0, n).Select(_ => new List<int>()).ToArray();\n        for (int i = 0; i < m2; i++)\n        {\n            var st = Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray();\n            graph2[st[0]].Add(st[1]);\n            graph2[st[1]].Add(st[0]);\n        }\n\n        var m3 = int.Parse(Console.ReadLine());\n        List<int>[] graph3 = Enumerable.Repeat(0, n).Select(_ => new List<int>()).ToArray();\n        for (int i = 0; i < m3; i++)\n        {\n            var st = Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray();\n            graph3[st[0]].Add(st[1]);\n            graph3[st[1]].Add(st[0]);\n        }\n        #endregion   \n\n        var greedyRes1 = GetGreedyRes(graph1);\n        var greedyRes2 = GetGreedyRes(graph2);\n        var greedyRes3 = GetGreedyRes(graph3);\n\n        var res1 = GetHighDRes(new Tuple<ModInt, ModInt>(1, 0), greedyRes1);\n        var res2 = GetHighDRes(res1, greedyRes2);\n        var res3 = GetHighDRes(res2, greedyRes3);\n        Console.WriteLine(res3.Item1);\n    }\n    static Tuple<ModInt, ModInt> GetHighDRes(Tuple<ModInt, ModInt> lowDRes, Tuple<bool[], bool[]> greedyRes)\n    {\n        bool[] freeMatch = greedyRes.Item1;\n        bool[] strictedMatch = greedyRes.Item2;\n        ModInt freeRes = 0;\n        ModInt strictedRes = 0;\n        ModInt curPowedFreeRes = lowDRes.Item1 * pow;\n        ModInt curPowedStrictedRes = lowDRes.Item2 * pow;\n        for (int i = 0; i < freeMatch.Length; i++)\n        {\n            if (freeMatch[i]) freeRes += curPowedFreeRes;\n            else freeRes += curPowedStrictedRes;\n            \n            if (strictedMatch[i]) strictedRes += curPowedFreeRes;\n            else strictedRes += curPowedStrictedRes;\n\n            curPowedFreeRes *= pow;\n            curPowedStrictedRes *= pow;\n        }\n        return new Tuple<ModInt, ModInt>(freeRes, strictedRes);\n    }\n    static Tuple<bool[], bool[]> GetGreedyRes(List<int>[] graph)\n    {\n        var freeRes = Enumerable.Repeat(true, graph.Length).ToArray();\n        for (int i = freeRes.Length - 1; i >= 0; i--)\n        {\n            if (!freeRes[i]) continue;\n            foreach (var adj in graph[i])\n            {\n                //if (i < adj) throw new Exception();\n                freeRes[adj] = false;\n            }\n        }\n        //↓ 上のやつとつながってて、だめですよ用に計算したもの\n        var strictedRes = Enumerable.Repeat(true, graph.Length).ToArray();\n        for (int i = freeRes.Length - 1; i >= 0; i--)\n        {\n            if (!strictedRes[i]) continue;\n            if (freeRes[i]) //もし上がOKだったら、\n            {\n                strictedRes[i] = false; //当然だめ\n                continue;\n            }\n            foreach (var adj in graph[i])\n            {\n                //if (i < adj) throw new Exception();\n                strictedRes[adj] = false;\n            }\n        }\n\n        return new Tuple<bool[], bool[]>(freeRes, strictedRes);\n    }\n}\n\n\nstruct ModInt\n{\n    public const int Mod = 998244353;\n    const long POSITIVIZER = ((long)Mod) << 31;\n    long Data;\n    public ModInt(long data) { if ((Data = data % Mod) < 0) Data += Mod; }\n    public static implicit operator long(ModInt modInt) => modInt.Data;\n    public static implicit operator ModInt(long val) => new ModInt(val);\n    public static ModInt operator +(ModInt a, int b) => new ModInt() { Data = (a.Data + b + POSITIVIZER) % Mod };\n    public static ModInt operator +(ModInt a, long b) => new ModInt(a.Data + b);\n    public static ModInt operator +(ModInt a, ModInt b) { long res = a.Data + b.Data; return new ModInt() { Data = res >= Mod ? res - Mod : res }; }\n    public static ModInt operator -(ModInt a, int b) => new ModInt() { Data = (a.Data - b + POSITIVIZER) % Mod };\n    public static ModInt operator -(ModInt a, long b) => new ModInt(a.Data - b);\n    public static ModInt operator -(ModInt a, ModInt b) { long res = a.Data - b.Data; return new ModInt() { Data = res < 0 ? res + Mod : res }; }\n    public static ModInt operator *(ModInt a, int b) => new ModInt(a.Data * b);\n    public static ModInt operator *(ModInt a, long b) => a * new ModInt(b);\n    public static ModInt operator *(ModInt a, ModInt b) => new ModInt() { Data = a.Data * b.Data % Mod };\n    public static ModInt operator /(ModInt a, ModInt b) => new ModInt() { Data = a.Data * GetInverse(b) % Mod };\n    public static bool operator ==(ModInt a, ModInt b) => a.Data == b.Data;\n    public static bool operator !=(ModInt a, ModInt b) => a.Data != b.Data;\n    public override string ToString() => Data.ToString();\n    public override bool Equals(object obj) => (ModInt)obj == this;\n    public override int GetHashCode() => (int)Data;\n    static long GetInverse(long a)\n    {\n        long div, p = Mod, x1 = 1, y1 = 0, x2 = 0, y2 = 1;\n        while (true)\n        {\n            if (p == 1) return x2 + Mod; div = a / p; x1 -= x2 * div; y1 -= y2 * div; a %= p;\n            if (a == 1) return x1 + Mod; div = p / a; x2 -= x1 * div; y2 -= y1 * div; p %= a;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        long bs = MyMath.pow(10, 18);\n        int n = sc.Int;\n        var edge = new List<int>[3][];\n        var mexsum = new long[3][];\n        for (int i = 0; i < 3; i++)\n        {\n            edge[i] = new List<int>[n];\n            for (int j = 0; j < n; j++)\n            {\n                edge[i][j] = new List<int>();\n            }\n            int m = sc.Int;\n            for (int j = 0; j < m; j++)\n            {\n                int u, v;\n                sc.Multi(out u, out v);\n                --u;\n                --v;\n                edge[i][u].Add(v);\n                edge[i][v].Add(u);\n            }\n            var mex = new int[n];\n            mexsum[i] = new long[1010];\n            for (int j = n - 1; j >= 0 ; j--)\n            {\n                var se = new HashSet<int>();\n                foreach (var item in edge[i][j])\n                {\n                    if (item < j) continue;\n                    se.Add(mex[item]);\n                }\n                for (int k = 0; ; k++)\n                {\n                    if (!se.Contains(k)) {\n                        mex[j] = k;\n                        // Assert(k < 1010);\n                        mexsum[i][k] = (mexsum[i][k] + MyMath.pow(bs, j + 1)) % M;\n                        break;\n                    }\n                }\n            }\n        }\n        long ans = 0;\n        for (int i = 0; i < 1010; i++)\n        {\n            for (int j = 0; j < 1010; j++)\n            {\n                if ((i ^ j) < 410) {\n                    ans = (ans + mexsum[0][i] * mexsum[1][j] % M * mexsum[2][i ^ j]) % M;\n                }\n            }\n        }\n        Prt(ans);\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    // public static readonly int M = 1000000007;\n    public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        foreach (var cond in conds) if (!cond) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a) {\n        a = v[0];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b) {\n        a = v[0]; b = v[1];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c) {\n        a = v[0]; b = v[1]; c = v[2];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d, out T e) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3]; e = v[4];\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n\nstatic class MyMath {\n    public static long Mod = util.M;\n    // public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static int[] sieve2(int n) {\n        var p = new int[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = i;\n        for (int i = 2; i * i <= n; i++) {\n            if (p[i] == i)\n                for (int j = i * i; j <= n; j += i)\n                    p[j] = Math.Min(p[j], i);\n        }\n        return p;\n    }\n    public static bool[] segmentSieve(long l, long r) {\n        int sqn = (int)Math.Sqrt(r + 9);\n        var ps = getprimes(sqn);\n        return segmentSieve(l, r,ps);\n    }\n    public static bool[] segmentSieve(long l, long r, List<int> ps) {\n        var sieve = new bool[r - l + 1];\n        for (long i = l; i <= r; i++) sieve[i - l] = true;\n        foreach (long p in ps) {\n            if (p * p > r) break;\n            for (long i = p >= l ? p * p : (l + p - 1) / p * p; i <= r; i += p) sieve[i - l] = false;\n        }\n        return sieve;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long pow(long a, long b, long mod) {\n        a %= mod;\n        if (b < 0) Console.Error.WriteLine($\"power number is negative ({a}^{b}).\");\n        if (b <= 0) return 1;\n        var t = pow(a, b / 2, mod);\n        if ((b & 1) == 0) return t * t % mod;\n        return t * t % mod * a % mod;\n    }\n    public static long pow(long a, long b) => pow(a, b, Mod);\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) {\n            var t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n\n    // return (r, m): x = r (mod. m)\n    // return (0, -1) if no answer\n    public static pair<long, long> chineserem(IList<long> b, IList<long> m) {\n        long r = 0, M = 1;\n        for (int i = 0; i < b.Count; ++i) {\n            long p, q;\n            long d = extgcd(M, m[i], out p, out q); // p is inv of M/d (mod. m[i]/d)\n            if ((b[i] - r) % d != 0) return new pair<long, long>(0, -1);\n            long tmp = (b[i] - r) / d * p % (m[i]/d);\n            r += M * tmp;\n            M *= m[i]/d;\n        }\n        return new pair<long, long>((r % M + M) % M, M);\n    }\n\n    // return k: x^k = y (mod. mod) O(sqrt(mod))\n    public static long modlog(long x, long y, long mod) {\n        if (y == 1) return 0;\n        long H = (long)Math.Sqrt(mod) + 1;\n        var baby = new Dictionary<long, long>();\n        for (long b = 0, xby = y; b < H; b++, xby = (xby * x) % mod) {\n            if (!baby.ContainsKey(xby))\n                baby.Add(xby, b);\n            else\n                baby[xby] = b;\n        }\n\n        long xH = 1;\n        for (int i = 0; i < H; ++i) xH = xH * x % mod;\n        for (long a = 1, xaH = xH; a <= H; a++, xaH = (xaH * xH) % mod)\n            if (baby.ContainsKey(xaH))\n                return a * H - baby[xaH];\n\n        return -1;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts, invs;\n    public static void setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 1; i <= n; i++) facts[i] = facts[i - 1] * i % Mod;\n        invs = new long[n + 1];\n        invs[n] = inv(facts[n]);\n        for (int i = n; i > 0 ; i--) invs[i - 1] = invs[i] * i % Mod;\n    }\n    public static long fact(long n) {\n        if (n < 0) return 0;\n        if (facts != null && facts.Length > n) return facts[n];\n        long numer = 1;\n        for (long i = 1; i <= n; i++) numer = numer * (i % Mod) % Mod;\n        return numer;\n    }\n    public static long perm(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[n - r] % Mod;\n        long numer = 1;\n        for (long i = 0; i < r; i++) numer = numer * ((n - i) % Mod) % Mod;\n        return numer;\n    }\n    public static long comb(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[r] % Mod * invs[n - r] % Mod;\n        if (n - r < r) r = n - r;\n        long numer = 1, denom = 1;\n        for (long i = 0; i < r; i++) {\n            numer = numer * ((n - i) % Mod) % Mod;\n            denom = denom * ((i + 1) % Mod) % Mod;\n        }\n        return numer * inv(denom) % Mod;\n    }\n    public static long multi_choose(long n, long r) => comb(n + r - 1, r);\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n\n    public static class ModMatrix {\n        public static long[][] E(int n) {\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n            return ret;\n        }\n        public static long[][] pow(long[][] A, long n) {\n            if (n == 0) return E(A.Length);\n            var t = pow(A, n / 2);\n            if ((n & 1) == 0) return mul(t, t);\n            return mul(mul(t, t), A);\n        }\n        public static long dot(long[] x, long[] y) {\n            int n = x.Length;\n            long ret = 0;\n            for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n            return ret;\n        }\n        public static long[][] trans(long[][] A) {\n            int n = A[0].Length, m = A.Length;\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) { ret[i] = new long[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n            return ret;\n        }\n        public static long[] mul(long a, long[] x) {\n            int n = x.Length;\n            var ret = new long[n];\n            for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n            return ret;\n        }\n        public static long[] mul(long[][] A, long[] x) {\n            int n = A.Length;\n            var ret = new long[n];\n            for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n            return ret;\n        }\n        public static long[][] mul(long a, long[][] A) {\n            int n = A.Length;\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n            return ret;\n        }\n        public static long[][] mul(long[][] A, long[][] B) {\n            int n = A.Length;\n            var Bt = trans(B);\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n            return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        long bs = MyMath.pow(10, 18);\n        int n = sc.Int;\n        var edge = new List<int>[3][];\n        var mexsum = new long[3][];\n        for (int i = 0; i < 3; i++)\n        {\n            edge[i] = new List<int>[n];\n            for (int j = 0; j < n; j++)\n            {\n                edge[i][j] = new List<int>();\n            }\n            int m = sc.Int;\n            for (int j = 0; j < m; j++)\n            {\n                int u, v;\n                sc.Multi(out u, out v);\n                --u;\n                --v;\n                edge[i][u].Add(v);\n                edge[i][v].Add(u);\n            }\n            var mex = new int[n];\n            mexsum[i] = new long[1010];\n            for (int j = n - 1; j >= 0 ; j--)\n            {\n                var se = new HashSet<int>();\n                foreach (var item in edge[i][j])\n                {\n                    if (item < j) continue;\n                    se.Add(mex[item]);\n                }\n                for (int k = 0; ; k++)\n                {\n                    if (!se.Contains(k)) {\n                        mex[j] = k;\n                        // Assert(k < 1010);\n                        mexsum[i][k] = (mexsum[i][k] + MyMath.pow(bs, j + 1)) % M;\n                        break;\n                    }\n                }\n            }\n        }\n        long ans = 0;\n        for (int i = 0; i < 510; i++)\n        {\n            for (int j = 0; j < 510; j++)\n            {\n                if ((i ^ j) < 510) {\n                    ans = (ans + mexsum[0][i] * mexsum[1][j] % M * mexsum[2][i ^ j]) % M;\n                }\n            }\n        }\n        Prt(ans);\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    // public static readonly int M = 1000000007;\n    public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        foreach (var cond in conds) if (!cond) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a) {\n        a = v[0];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b) {\n        a = v[0]; b = v[1];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c) {\n        a = v[0]; b = v[1]; c = v[2];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d, out T e) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3]; e = v[4];\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n\nstatic class MyMath {\n    public static long Mod = util.M;\n    // public static long Mod = 1000000007;\n    public static bool isprime(long a) {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public static bool[] sieve(int n) {\n        var p = new bool[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = true;\n        for (int i = 2; i * i <= n; i++) if (p[i]) for (int j = i * i; j <= n; j += i) p[j] = false;\n        return p;\n    }\n    public static int[] sieve2(int n) {\n        var p = new int[n + 1];\n        for (int i = 2; i <= n; i++) p[i] = i;\n        for (int i = 2; i * i <= n; i++) {\n            if (p[i] == i)\n                for (int j = i * i; j <= n; j += i)\n                    p[j] = Math.Min(p[j], i);\n        }\n        return p;\n    }\n    public static bool[] segmentSieve(long l, long r) {\n        int sqn = (int)Math.Sqrt(r + 9);\n        var ps = getprimes(sqn);\n        return segmentSieve(l, r,ps);\n    }\n    public static bool[] segmentSieve(long l, long r, List<int> ps) {\n        var sieve = new bool[r - l + 1];\n        for (long i = l; i <= r; i++) sieve[i - l] = true;\n        foreach (long p in ps) {\n            if (p * p > r) break;\n            for (long i = p >= l ? p * p : (l + p - 1) / p * p; i <= r; i += p) sieve[i - l] = false;\n        }\n        return sieve;\n    }\n    public static List<int> getprimes(int n) {\n        var prs = new List<int>();\n        var p = sieve(n);\n        for (int i = 2; i <= n; i++) if (p[i]) prs.Add(i);\n        return prs;\n    }\n    public static long pow(long a, long b, long mod) {\n        a %= mod;\n        if (b < 0) Console.Error.WriteLine($\"power number is negative ({a}^{b}).\");\n        if (b <= 0) return 1;\n        var t = pow(a, b / 2, mod);\n        if ((b & 1) == 0) return t * t % mod;\n        return t * t % mod * a % mod;\n    }\n    public static long pow(long a, long b) => pow(a, b, Mod);\n    public static long inv(long a) => pow(a, Mod - 2);\n    public static long gcd(long a, long b) {\n        while (b > 0) {\n            var t = a % b;\n            a = b;\n            b = t;\n        }\n        return a;\n    }\n    // a x + b y = gcd(a, b)\n    public static long extgcd(long a, long b, out long x, out long y) {\n        long g = a; x = 1; y = 0;\n        if (b > 0) { g = extgcd(b, a % b, out y, out x); y -= a / b * x; }\n        return g;\n    }\n\n    // return (r, m): x = r (mod. m)\n    // return (0, -1) if no answer\n    public static pair<long, long> chineserem(IList<long> b, IList<long> m) {\n        long r = 0, M = 1;\n        for (int i = 0; i < b.Count; ++i) {\n            long p, q;\n            long d = extgcd(M, m[i], out p, out q); // p is inv of M/d (mod. m[i]/d)\n            if ((b[i] - r) % d != 0) return new pair<long, long>(0, -1);\n            long tmp = (b[i] - r) / d * p % (m[i]/d);\n            r += M * tmp;\n            M *= m[i]/d;\n        }\n        return new pair<long, long>((r % M + M) % M, M);\n    }\n\n    // return k: x^k = y (mod. mod) O(sqrt(mod))\n    public static long modlog(long x, long y, long mod) {\n        if (y == 1) return 0;\n        long H = (long)Math.Sqrt(mod) + 1;\n        var baby = new Dictionary<long, long>();\n        for (long b = 0, xby = y; b < H; b++, xby = (xby * x) % mod) {\n            if (!baby.ContainsKey(xby))\n                baby.Add(xby, b);\n            else\n                baby[xby] = b;\n        }\n\n        long xH = 1;\n        for (int i = 0; i < H; ++i) xH = xH * x % mod;\n        for (long a = 1, xaH = xH; a <= H; a++, xaH = (xaH * xH) % mod)\n            if (baby.ContainsKey(xaH))\n                return a * H - baby[xaH];\n\n        return -1;\n    }\n    public static long lcm(long a, long b) => a / gcd(a, b) * b;\n\n    static long[] facts, invs;\n    public static void setfacts(int n) {\n        facts = new long[n + 1];\n        facts[0] = 1;\n        for (int i = 1; i <= n; i++) facts[i] = facts[i - 1] * i % Mod;\n        invs = new long[n + 1];\n        invs[n] = inv(facts[n]);\n        for (int i = n; i > 0 ; i--) invs[i - 1] = invs[i] * i % Mod;\n    }\n    public static long fact(long n) {\n        if (n < 0) return 0;\n        if (facts != null && facts.Length > n) return facts[n];\n        long numer = 1;\n        for (long i = 1; i <= n; i++) numer = numer * (i % Mod) % Mod;\n        return numer;\n    }\n    public static long perm(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[n - r] % Mod;\n        long numer = 1;\n        for (long i = 0; i < r; i++) numer = numer * ((n - i) % Mod) % Mod;\n        return numer;\n    }\n    public static long comb(long n, long r) {\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (facts != null && facts.Length > n) return facts[n] * invs[r] % Mod * invs[n - r] % Mod;\n        if (n - r < r) r = n - r;\n        long numer = 1, denom = 1;\n        for (long i = 0; i < r; i++) {\n            numer = numer * ((n - i) % Mod) % Mod;\n            denom = denom * ((i + 1) % Mod) % Mod;\n        }\n        return numer * inv(denom) % Mod;\n    }\n    public static long multi_choose(long n, long r) => comb(n + r - 1, r);\n    public static long[][] getcombs(int n) {\n        var ret = new long[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            ret[i] = new long[i + 1];\n            ret[i][0] = ret[i][i] = 1;\n            for (int j = 1; j < i; j++) ret[i][j] = (ret[i - 1][j - 1] + ret[i - 1][j]) % Mod;\n        }\n        return ret;\n    }\n    // nC0, nC2, ..., nCn\n    public static long[] getcomb(int n) {\n        var ret = new long[n + 1];\n        ret[0] = 1;\n        for (int i = 0; i < n; i++) ret[i + 1] = ret[i] * (n - i) % Mod * inv(i + 1) % Mod;\n        return ret;\n    }\n\n    public static class ModMatrix {\n        public static long[][] E(int n) {\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) { ret[i] = new long[n]; ret[i][i] = 1; }\n            return ret;\n        }\n        public static long[][] pow(long[][] A, long n) {\n            if (n == 0) return E(A.Length);\n            var t = pow(A, n / 2);\n            if ((n & 1) == 0) return mul(t, t);\n            return mul(mul(t, t), A);\n        }\n        public static long dot(long[] x, long[] y) {\n            int n = x.Length;\n            long ret = 0;\n            for (int i = 0; i < n; i++) ret = (ret + x[i] * y[i]) % Mod;\n            return ret;\n        }\n        public static long[][] trans(long[][] A) {\n            int n = A[0].Length, m = A.Length;\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) { ret[i] = new long[m]; for (int j = 0; j < m; j++) ret[i][j] = A[j][i]; }\n            return ret;\n        }\n        public static long[] mul(long a, long[] x) {\n            int n = x.Length;\n            var ret = new long[n];\n            for (int i = 0; i < n; i++) ret[i] = a * x[i] % Mod;\n            return ret;\n        }\n        public static long[] mul(long[][] A, long[] x) {\n            int n = A.Length;\n            var ret = new long[n];\n            for (int i = 0; i < n; i++) ret[i] = dot(x, A[i]);\n            return ret;\n        }\n        public static long[][] mul(long a, long[][] A) {\n            int n = A.Length;\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) ret[i] = mul(a, A[i]);\n            return ret;\n        }\n        public static long[][] mul(long[][] A, long[][] B) {\n            int n = A.Length;\n            var Bt = trans(B);\n            var ret = new long[n][];\n            for (int i = 0; i < n; i++) ret[i] = mul(Bt, A[i]);\n            return ret;\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  import std.conv : to;\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      if (a < 0) return (this = inv()^^(-a));\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e > 0; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op: \"-\")() const { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const {\n    return mixin(\"ModInt(this) \" ~ op ~ \"= a\");\n  }\n  ModInt opBinaryRight(string op)(long a) const {\n    return mixin(\"ModInt(a) \" ~ op ~ \"= this\");\n  }\n  bool opCast(T: bool)() const { return (x != 0); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 998_244_353;\nalias Mint = ModInt!MO;\n\nenum K = 3;\nenum W = Mint(10L^^18);\n\nvoid main() {\n  try {\n    for (; ; ) {\n      const N = readInt;\n      auto M = new int[K];\n      auto A = new int[][K];\n      auto B = new int[][K];\n      foreach (k; 0 .. K) {\n        M[k] = readInt();\n        A[k] = new int[M[k]];\n        B[k] = new int[M[k]];\n        foreach (i; 0 .. M[k]) {\n          A[k][i] = readInt() - 1;\n          B[k][i] = readInt() - 1;\n        }\n      }\n      \n      const l = bsr(N) + 1;\n      auto xs = new Mint[1 << l];\n      xs[] = Mint(1);\n      foreach (k; 0 .. K) {\n        auto graph = new int[][N];\n        foreach (i; 0 .. M[k]) {\n          graph[A[k][i]] ~= B[k][i];\n          graph[B[k][i]] ~= A[k][i];\n        }\n        auto gs = new int[N];\n        foreach_reverse (u; 0 .. N) {\n          bool[int] app;\n          foreach (v; graph[u]) {\n            if (u < v) {\n              app[gs[v]] = true;\n            }\n          }\n          for (int g = 0; ; ++g) {\n            if (g !in app) {\n              gs[u] = g;\n              break;\n            }\n          }\n        }\n        debug {\n          if (N <= 10) {\n            writeln(\"gs = \", gs);\n          }\n        }\n        auto ys = new Mint[1 << l];\n        Mint weight = 1;\n        foreach (u; 0 .. N) {\n          weight *= W;\n          ys[gs[u]] += weight;\n        }\n        foreach (i; 0 .. l) {\n          foreach (h; 0 .. 1 << l) {\n            if (!(h & 1 << i)) {\n              const tmp = ys[h] - ys[h | 1 << i];\n              ys[h] += ys[h | 1 << i];\n              ys[h | 1 << i] = tmp;\n            }\n          }\n        }\n        xs[] *= ys[];\n      }\n      foreach (i; 0 .. l) {\n        foreach (h; 0 .. 1 << l) {\n          if (!(h & 1 << i)) {\n            const tmp = xs[h] - xs[h | 1 << i];\n            xs[h] += xs[h | 1 << i];\n            xs[h | 1 << i] = tmp;\n          }\n        }\n      }\n      const ans = xs[0] / (1 << l);\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\nconst MOD = 998244353\n\n# Graph {{{\nimport sequtils\n\ntype\n  Edge[T] = object\n    src,dst:int\n    weight:T\n    rev:int\n  Edges[T] = seq[Edge[T]]\n  Graph[T] = seq[seq[Edge[T]]]\n\nproc initEdge[T](src,dst:int,weight:T,rev:int = -1):Edge[T] =\n  var e:Edge[T]\n  e.src = src\n  e.dst = dst\n  e.weight = weight\n  e.rev = rev\n  return e\n\nproc initGraph[T](n:int):Graph[T] =\n  return newSeqWith(n,newSeq[Edge[T]]())\n\nproc addBiEdge[T](g:var Graph[T],e:Edge[T]):void =\n  var e_rev = e\n  swap(e_rev.src, e_rev.dst)\n  let (r, s) = (g[e.src].len, g[e.dst].len)\n  g[e.src].add(e)\n  g[e.dst].add(e_rev)\n  g[e.src][^1].rev = s\n  g[e.dst][^1].rev = r\nproc addBiEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addBiEdge(initEdge(src, dst, weight))\n\nproc initUndirectedGraph[T](n:int, a,b,c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], c[i])\nproc initUndirectedGraph[T](n:int, a,b:seq[T]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addBiEdge(a[i], b[i], T(1))\nproc initGraph[T](n:int, a,b:seq[int],c:seq[T]):Graph[T] =\n  var result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], c[i])\nproc initGraph[T](n:int, a,b:seq[int]):Graph[T] =\n  result = initGraph[T](n)\n  for i in 0..<a.len: result.addEdge(a[i], b[i], T(1))\n\n\nproc addEdge[T](g:var Graph[T],e:Edge[T]):void =\n  g[e.src].add(e)\nproc addEdge[T](g:var Graph[T],src,dst:int,weight:T=1):void =\n  g.addEdge(initEdge(src, dst, weight, -1))\n\nproc `<`[T](l,r:Edge[T]):bool = l.weight < r.weight\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int32\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a.int32\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0.int32: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v = ((self.v.int * initModInt(a, Mod).v.int) mod MOD).int32\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\nlet N = nextInt()\ngs := newSeq[Graph[int]]()\nfor c in 0..<3:\n  M := nextInt()\n  g := initGraph[int](N)\n  for i in 0..<M:\n    let a, b = nextInt() - 1\n    g.addBiEdge(a, b)\n  gs.add(g)\n\nproc calc(g:Graph[int]):seq[int] =\n  result = newSeq[int](N)\n  for u in countdown(N - 1, 0):\n    s := initSet[int]()\n    for e in g[u]:\n      if e.dst <= u: continue\n      s.incl result[e.dst]\n    var g = 0\n    while true:\n      if g notin s: break\n      g.inc\n    result[u] = g\n\nsts := newSeq[HashSet[int]]()\ngr := @[@[2,1,0],@[0,1,0],@[1,0,0]]\n\nproc naive() =\n  ban := initSet[(int,int,int)]()\n  v := newSeq[(int,(int,int,int))]()\n  for x in 0..<N:\n    for y in 0..<N:\n      for z in 0..<N:\n        v.add((x + y + z, (x, y, z)))\n  v.sort();v.reverse()\n  ans := initMint(0)\n  echo sts\n  for v in v:\n    let (s, p) = v\n    if p in ban: continue\n    ans += initMint(10)^(18 * (p[0] + p[1] + p[2] + 3))\n    echo p\n    ss := 0\n    if p[0] notin sts[0]: ss += 1\n    if p[1] notin sts[1]: ss += 1\n    if p[2] notin sts[2]: ss += 1\n    dump(ss)\n    block:\n      for e in gs[0][p[0]]:\n        if e.dst > p[0]: continue\n        var p = p\n        p[0] = e.dst\n        ban.incl p\n    block:\n      for e in gs[1][p[1]]:\n        if e.dst > p[0]: continue\n        var p = p\n        p[1] = e.dst\n        ban.incl p\n    block:\n      for e in gs[2][p[2]]:\n        if e.dst > p[2]: continue\n        var p = p\n        p[2] = e.dst\n        ban.incl p\n  echo ans\n  for u in 0..<N:\n    for v in 0..<N:\n      for w in 0..<N:\n        ss := 0\n        if u notin sts[0]: ss.inc\n        if v notin sts[1]: ss.inc\n        if w notin sts[2]: ss.inc\n        if ss mod 2 == 0:\n          echo \"found: \", u, \" \", v, \" \", w, \" \", ss, \" \", (gr[0][u] xor gr[1][v] xor gr[2][w])\n\nproc main() =\n  let d = initMint(10)^18\n  vs := newSeq[seq[Mint]]()\n  for c in 0..<3:\n    v := calc(gs[c])\n    v0 := newSeqWith(v.max + 1, initMint(0))\n    var p = initMint(1)\n    for u in 0..<N:\n      p *= d\n      v0[v[u]] += p\n    vs.add(v0)\n  ans := initMint(0)\n  for bi in 0..<vs[0].len:\n    for bj in 0..<vs[1].len:\n      let bk = (bi xor bj)\n      if vs[2].len <= bk: continue\n      let p = vs[0][bi] * vs[1][bj] * vs[2][bk]\n      ans += p\n  echo ans\n  return\n\nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef mod_inv(a):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, M\n  while z1 != 1:\n    d, m = divmod(z2, z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1%M\n\ndef mex(s):\n  s = set(s)\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex(map(lambda x:g.get(x, 0), e[i]))\n    if m:\n      g[i] = m\n  return g\n\ndef sum_grundy(grundy):\n  sum_g = [defaultdict(int, {0:B_sum}) for i in range(3)]\n  W, prev = B, 1\n  for i in range(1, N+1):\n    for s, g in zip(sum_g, grundy):\n      if i in g:\n        if prev != i:\n          W, prev = W * pow(B, i-prev, M) % M, i\n        s[g[i]] =  (s[g[i]] + W) % M\n        s[0] =  (s[0] - W) % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\nN = int(input())\nM = 998244353\nB = pow(10, 18, M)\nB_sum = (pow(B, N+1, M) - B) * mod_inv(B-1) % M\n\nedge = [read_edge() for i in range(3)]\ngrundy = list(map(calc_grundy, edge))\nsum_g = sum_grundy(grundy)\nans = 0\nfor gx, sx in sum_g[0].items():\n  for gy, sy in sum_g[1].items():\n    gz = gx^gy\n    if gz in sum_g[2]:\n      ans = (ans + sx*sy*sum_g[2][gz]) % M\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8, f8\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 998_244_353\n\n@njit((i8, i8[:, :]), cache=True)\ndef precompute(N, G):\n    ng = np.zeros(N + 10, np.bool_)\n    g = np.zeros(N + 1, np.int64)\n    ind = np.searchsorted(G[:, 0], np.arange(N + 10))\n    for v in range(N - 1, 0, -1):\n        for i in range(ind[v], ind[v + 1]):\n            w = G[i, 1]\n            ng[g[w]] = 1\n        for n in range(N + 10):\n            if ng[n]:\n                continue\n            break\n        g[v] = n\n        for i in range(ind[v], ind[v + 1]):\n            w = G[i, 1]\n            ng[g[w]] = 0\n\n    B = 10**18 % MOD\n    power = 1\n    A = np.zeros(1024, np.int64)\n    for i in range(1, N + 1):\n        power = power * B % MOD\n        A[g[i]] += power\n    return A % MOD\n\n@njit((i8[:], i8[:]), cache=True)\ndef convolve(A, B):\n    C = np.zeros(1024, np.int64)\n    for i in range(1024):\n        for j in range(1024):\n            C[i ^ j] += A[i] * B[j] % MOD\n    return C % MOD\n\nN = int(readline())\nnums = np.array(read().split(), np.int64)\ngraphs = []\nfor _ in range(3):\n    M = nums[0]\n    G = nums[1:1 + 2 * M].reshape(M, 2)\n    G.sort(axis=1)\n    G = G[np.argsort(G[:, 0])]\n    graphs.append(G)\n    nums = nums[1 + 2 * M:]\n\nG1, G2, G3 = map(lambda G: precompute(N, G), graphs)\n\nprint(convolve(convolve(G1, G2), G3)[0])"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in set(e[i])})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0]  = (sum_g[0] - BB[i]) % M\n\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  prev_i = N\n  prev_W = pow(B, N, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      W = inv_mod(pow(B, prev_i-i, M), prev_W, M)\n      sum_g[g[i]] = (sum_g[g[i]] + W) % M\n      sum_g[0]  = (sum_g[0] - W) % M\n      prev_i, prev_W = i, W\n  \n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "import itertools\nimport os\nimport sys\nfrom collections import defaultdict\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\n# MOD = 10 ** 9 + 7\nMOD = 998244353\n\n# 解説\n# 大きい方から貪欲に取るのの見方を変えるとゲームになる\n\nN = int(sys.stdin.buffer.readline())\nM = []\nm = int(sys.stdin.buffer.readline())\nM.append(m)\nXVU = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(m)]\nm = int(sys.stdin.buffer.readline())\nM.append(m)\nYVU = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(m)]\nm = int(sys.stdin.buffer.readline())\nM.append(m)\nZVU = [list(map(int, sys.stdin.buffer.readline().split())) for _ in range(m)]\n\nX = [[] for _ in range(N)]\nY = [[] for _ in range(N)]\nZ = [[] for _ in range(N)]\nfor G, VU in zip([X, Y, Z], (XVU, YVU, ZVU)):\n    for v, u in VU:\n        v -= 1\n        u -= 1\n        if v > u:\n            v, u = u, v\n        G[v].append(u)\n\n\ndef grundy(graph):\n    ret = [-1] * N\n    for v in reversed(range(N)):\n        gs = set()\n        for u in graph[v]:\n            gs.add(ret[u])\n        g = 0\n        while g in gs:\n            g += 1\n        ret[v] = g\n    return ret\n\n\ngrundy_x = defaultdict(list)\ngrundy_y = defaultdict(list)\ngrundy_z = defaultdict(list)\nfor x, g in enumerate(grundy(X), 1):\n    grundy_x[g].append(x)\nfor y, g in enumerate(grundy(Y), 1):\n    grundy_y[g].append(y)\nfor z, g in enumerate(grundy(Z), 1):\n    grundy_z[g].append(z)\n\n# base[i]: (10^18)^i\nbase = [1]\nfor _ in range(N * 3 + 10):\n    base.append(base[-1] * pow(10, 18, MOD) % MOD)\n\nans = 0\nfor xg, yg in itertools.product(grundy_x.keys(), grundy_y.keys()):\n    zg = xg ^ yg\n    # 10^(x1+y1+z1) + 10^(x1+y1+z2) + ... + 10^(x1+y2+z1) + ...\n    # = (10^x1 + 10^x2 + ...) * (10^y1 + ...) * (10^z1 + ...)\n    xs = 0\n    ys = 0\n    zs = 0\n    for x in grundy_x[xg]:\n        xs += base[x]\n    for y in grundy_y[yg]:\n        ys += base[y]\n    for z in grundy_z[zg]:\n        zs += base[z]\n    ans += xs % MOD * ys % MOD * zs % MOD\n    ans %= MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\nclass mod_int(int):\n  def __new__(cls, i=0, *args, **kwargs):\n    return int.__new__(cls, i%M, *args, **kwargs)\n  \n  def __add__(self, x):\n    return self.__class__(int.__add__(self, x))\n    \n  def __sub__(self, x):\n    return self.__class__(int.__sub__(self, x))\n    \n  def __neg__(self):\n    return self.__class__(int.__neg__(self, x))\n  \n  def __mul__(self, x):\n    return self.__class__(int.__mul__(self, x))\n  \n  def __floordiv__(self, x):\n    a, b = ext_euc(x, M)\n    return self * a\n  \n  def __pow__(self, x):\n    return self.__class__(int.__pow__(self, x, M))\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  sum_g = defaultdict(mod_int)\n  sum_g[0] = (B**(N+1) - B) // (B-1)\n  prev = 0\n  W = mod_int(1)\n  for i in range(1, N+1):\n    if i in g:\n      W *= B**(i-prev)\n      sum_g[g[i]] +=  W\n      sum_g[0]  -= W\n      prev, W = i, W\n  \n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = mod_int(0)\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret += sx*sy*sz\n  return ret\n\n\nM = 998244353\nB = mod_int(10) ** 18\nN = int(input())\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in set(e[i])})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n  sum_g[0] = (inv_mod(B-1, pow(B, N+1, M)-B, M) - sum(sum_g.values())) % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef mod_inv(a):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, M\n  while z1 != 1:\n    d, m = divmod(z2, z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1%M\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(edge):\n  grundy = [{} for i in range(3)]\n  sum_g = [defaultdict(int, {0:W_sum}) for i in range(3)]\n  W = W_last\n  for i in range(N, 0, -1):\n    for g, s, e in zip(grundy, sum_g, edge):\n      if i in e:\n        m = mex({g.get(j, 0) for j in e[i]})\n        if m:\n          g[i] = m\n          s[g[i]] =  (s[g[i]] + W) % M\n          s[0] =  (s[0] - W) % M\n    W = W * B_inv % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\nN = int(input())\nM = 998244353\nB = pow(10, 18, M)\nB_inv = mod_inv(B)\nW_last = pow(B, N, M)\nW_sum = (W_last - 1) * B * mod_inv(B-1) % M\n\nedge = [read_edge() for i in range(3)]\nsum_g = calc_grundy(edge)\nans = 0\nfor gx, sx in sum_g[0].items():\n  for gy, sy in sum_g[1].items():\n    gz = gx^gy\n    sz = sum_g[2][gz]\n    if sz:\n      ans = (ans + sx*sy*sz) % M\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in set(e[i])})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0]  = (sum_g[0] - BB[i]) % M\n\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  x = 1\n  for i in range(1, N+1):\n    x = (x * B) % M\n    if i in g:\n      sum_g[g[i]] = (sum_g[g[i]] + x) % M\n      sum_g[0]  = (sum_g[0] - x) % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\n\nn, *mabs = map(int, sys.stdin.buffer.read().split())\nMOD = 998244353\nbase = 10 ** 18 % MOD\nbase_costs = [base]\nfor i in range(n - 1):\n    base_costs.append(base_costs[-1] * base % MOD)\ngraphs = []\ni = 0\nfor _ in range(3):\n    m = mabs[i]\n    i += 1\n    j = i + 2 * m\n    parents = [set() for _ in range(n)]\n    for a, b in zip(mabs[i:j:2], mabs[i + 1:j:2]):\n        a -= 1\n        b -= 1\n        if a > b:\n            a, b = b, a\n        parents[a].add(b)\n    grundy = [0] * n\n    weights = defaultdict(int)\n    for v in range(n - 1, -1, -1):\n        pgs = {grundy[p] for p in parents[v]}\n        for g in range(m + 1):\n            if g not in pgs:\n                grundy[v] = g\n                weights[g] += base_costs[v]\n                break\n\n    for g in weights:\n        weights[g] %= MOD\n\n    graphs.append(dict(weights))\n    i = j\n\nans = 0\ngraph_x, graph_y, graph_z = graphs\nfor gx, cx in graph_x.items():\n    for gy, cy in graph_y.items():\n        gz = gx ^ gy\n        if gz in graph_z:\n            ans = (ans + cx * cy * graph_z[gz]) % MOD\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353 # < (1 << 30)\n\ndef mod_inv(a, M=M):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, M\n  while abs(z1) != 1:\n    d, m = divmod(z2, z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1*z1%M\n\nR_bits = 30\nR = 1 << R_bits\nR_dec = R - 1\nR2 = pow(R, 2, M)\nM_neg_inv = mod_inv(-M, R)\n\ndef MR(x):\n  b = (x * M_neg_inv) & R_dec\n  t = x + b * M\n  c = t >> R_bits\n  d = c - M\n  return d if 0 <= d else c\n\ndef Montgomery(x):\n  return MR(x*R2)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(edge):\n  grundy = [{} for i in range(3)]\n  sum_g = [defaultdict(int, {0:M_W_sum}) for i in range(3)]\n  M_W = M_W_last\n  for i in range(N, 0, -1):\n    for g, s, e in zip(grundy, sum_g, edge):\n      if i in e:\n        m = mex({g.get(j, 0) for j in e[i]})\n        if m:\n          g[i] = m\n          s[g[i]] +=  M_W\n          s[0] -=  M_W\n    M_W = MR(M_W * M_B_inv)\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\nN = int(input())\nB = pow(10, 18, M)\nM_B_inv = Montgomery(mod_inv(B))\nM_W_last = Montgomery(pow(B, N, M))\nM_W_sum = MR((M_W_last - Montgomery(1)) * MR(Montgomery(B) * Montgomery(mod_inv(B-1))))\n\nedge = [read_edge() for i in range(3)]\nsum_g = calc_grundy(edge)\nans = 0\nfor gx, sx in sum_g[0].items():\n  for gy, sy in sum_g[1].items():\n    gz = gx^gy\n    sz = sum_g[2][gz]\n    if sz:\n      ans += MR(MR(sx*sy)*sz)\nprint(MR(ans))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef mod_inv(a):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, M\n  while z1 != 1:\n    d, m = divmod(z2, z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1%M\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  return g\n\ndef sum_grundy(grundy):\n  sum_g = [defaultdict(int, {0:B_sum}) for i in range(3)]\n  W, prev = B, 1\n  for i in range(1, N+1):\n    for s, g in zip(sum_g, grundy):\n      if i in g:\n        if prev != i:\n          W, prev = W * pow(B, i-prev, M) % M, i\n        s[g[i]] =  (s[g[i]] + W) % M\n        s[0] =  (s[0] - W) % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\nN = int(input())\nM = 998244353\nB = pow(10, 18, M)\nB_sum = (pow(B, N+1, M) - B) * mod_inv(B-1) % M\n\nedge = [read_edge() for i in range(3)]\ngrundy = list(map(calc_grundy, edge))\nsum_g = sum_grundy(grundy)\nans = 0\nfor gx, sx in sum_g[0].items():\n  for gy, sy in sum_g[1].items():\n    gz = gx^gy\n    if gz in sum_g[2]:\n      ans = (ans + sx*sy*sum_g[2][gz]) % M\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nn = int(readline())\ndata = tuple(map(int,read().split()))\nm1 = data[0]\nab = data[1:1+2*m1]\nm2 = data[1+2*m1]\ncd = data[2+2*m1:2+2*(m1+m2)]\nm3 = data[2+2*(m1+m2)]\nef = data[3+2*(m1+m2):]\n\nmod = 998244353\nmods = [1] * (n+10)\nbase = pow(10,18,mod)\nfor i in range(1,n+1):\n    mods[i] = (mods[i-1] * base)%mod\n\ndef calc_node(xy):\n    links = [[] for _ in range(n+1)]\n    it = iter(xy)\n    for x,y in zip(it,it):\n        links[x].append(y)\n        links[y].append(x)\n\n    group = [-1] * (n+1)\n    group[-1] = 0\n    num_max = 1\n    for i in range(n,0,-1):\n        remain = set(range(num_max+2))\n        for j in links[i]:\n            if(i < j):\n                remain.discard(group[j])\n        num = min(remain)\n        group[i] = num\n        num_max = max(num_max,num)\n\n    res = [0] * (num_max+1)\n    for i,num in enumerate(group[1:],1):\n        res[num] += mods[i]\n        res[num] %= mod\n\n    return res\n\nx = calc_node(ab)\ny = calc_node(cd)\nz = calc_node(ef)\n\n\nif(len(x) < len(y)):\n    x,y = y,x\nif(len(y) < len(z)):\n    y,z = z,y\nif(len(x) < len(y)):\n    x,y = y,x\n\n\nlen_2 = 2**(len(y)-1).bit_length()\nyz = [0] * (len_2)\nfor j in range(len(y)):\n    for k in range(len(z)):\n        yz[j^k] += y[j]*z[k]\n        yz[j^k] %= mod\n\nans = 0\nfor i,j in zip(x,yz):\n    ans += i*j\n    ans %= mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353 # < (1 << 30)\n\ndef mod_inv(a, M=M):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, M\n  while abs(z1) != 1:\n    d, m = divmod(z2, z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1*z1%M\n\nR_bits = 30\nR = 1 << R_bits\nR_dec = R - 1\nR2 = pow(R, 2, M)\nM_neg_inv = mod_inv(-M, R)\n\ndef MR(x):\n  b = (x * M_neg_inv) & R_dec\n  t = x + b * M\n  c = t >> R_bits\n  d = c - M\n  return d if 0 <= d else c\n\ndef Montgomery(x):\n  return MR(x*R2)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(edge):\n  grundy = [{} for i in range(3)]\n  sum_g = [defaultdict(int, {0:M_W_sum}) for i in range(3)]\n  M_W = M_W_last\n  for i in range(N, 0, -1):\n    for g, s, e in zip(grundy, sum_g, edge):\n      if i in e:\n        m = mex({g.get(j, 0) for j in e[i]})\n        if m:\n          g[i] = m\n          s[g[i]] +=  M_W\n          s[0] +=  M - M_W\n    M_W = MR(M_W * M_B_inv)\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\nN = int(input())\nB = pow(10, 18, M)\nM_B_inv = Montgomery(mod_inv(B))\nM_W_last = Montgomery(pow(B, N, M))\nM_W_sum = MR((M_W_last + Montgomery(-1)) * Montgomery(B * mod_inv(B-1) % M))\n\nedge = [read_edge() for i in range(3)]\nsum_g = calc_grundy(edge)\nans = 0\nfor gx, sx in sum_g[0].items():\n  for gy, sy in sum_g[1].items():\n    gz = gx^gy\n    sz = sum_g[2][gz]\n    if sz:\n      ans += Montgomery(MR(sx)*MR(sy)*MR(sz))\nprint(MR(ans))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.buffer.readline\nN,mod=int(input()),998244353\ndef data():\n    edge=[[] for i in range(N)]\n    for i in range(int(input())):\n        a,b=map(int,input().split())\n        if a>b:\n            a,b=b,a\n        edge[a-1].append(b-1)\n    mex=[0]*N\n    for i in range(N-1,-1,-1):\n        used=[False]*(len(edge[i])+1)\n        for pv in edge[i]:\n            if mex[pv]<=len(edge[i]):\n                used[mex[pv]]=True\n        for j in range(len(used)):\n            if not used[j]:\n                mex[i]=j\n                break\n    res=[0]*(max(mex)+1)\n    for i in range(N):\n        res[mex[i]]+=pow(10,18*(i+1),mod)\n        res[mex[i]]%=mod\n    return res\nData,ans=[data() for i in range(3)],0\nfor i in range(len(Data[0])):\n    for j in range(len(Data[1])):\n        if i^j<len(Data[2]):\n            ans+=Data[0][i]*Data[1][j]*Data[2][i^j]\n            ans%=mod\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  prev_i = 1\n  prev_W = B\n  for i in range(1, N+1):\n    if i in g:\n      W = (B * pow(B, prev_i-i, M)) % M\n      sum_g[g[i]] = (sum_g[g[i]] + W) % M\n      sum_g[0]  = (sum_g[0] - W) % M\n      prev_i, prev_W = i, W\n  \n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef mod_inv(a):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, M\n  while z1 != 1:\n    d, m = divmod(z2, z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1%M\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(edge):\n  grundy = [{} for i in range(3)]\n  sum_g = [defaultdict(int, {0:W_sum}) for i in range(3)]\n  W = W_last\n  for i in range(N, 0, -1):\n    for g, s, e in zip(grundy, sum_g, edge):\n      if i in e:\n        m = mex({g.get(j, 0) for j in e[i]})\n        if m:\n          g[i] = m\n          s[g[i]] =  (s[g[i]] + W) % M\n          s[0] =  (s[0] - W) % M\n    W = W * B_inv % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\nN = int(input())\nM = 998244353\nB = pow(10, 18, M)\nB_inv = mod_inv(B)\nW_last = pow(B, N, M)\nW_sum = (W_last - 1) * B * mod_inv(B-1) % M\n\nedge = [read_edge() for i in range(3)]\nsum_g = calc_grundy(edge)\nans = 0\nfor gx, sx in sum_g[0].items():\n  for gy, sy in sum_g[1].items():\n    gz = gx^gy\n    sz = sum_g[2][gz]\n    if sz:\n      ans = (ans + sx*sy*sz) % M\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    \"\"\"\"ここに今までのコード\"\"\"\n    import sys\n    read = sys.stdin.buffer.read\n    readline = sys.stdin.buffer.readline\n    readlines = sys.stdin.buffer.readlines\n\n    n = int(readline())\n    data = tuple(map(int,read().split()))\n    m1 = data[0]\n    ab = data[1:1+2*m1]\n    m2 = data[1+2*m1]\n    cd = data[2+2*m1:2+2*(m1+m2)]\n    m3 = data[2+2*(m1+m2)]\n    ef = data[3+2*(m1+m2):]\n\n    mod = 998244353\n    mods = [1] * (n+10)\n    base = pow(10,18,mod)\n    for i in range(1,n+1):\n        mods[i] = (mods[i-1] * base)%mod\n\n    def calc_node(xy):\n        links = [[] for _ in range(n+1)]\n        it = iter(xy)\n        for x,y in zip(it,it):\n            if(x < y):\n                x,y = y,x\n            links[y].append(x)\n\n        group = [-1] * (n+1)\n        group[-1] = 0\n        num_max = 1\n        for i in range(n,0,-1):\n            remain = set(range(num_max+2))\n            for j in links[i]:\n                remain.discard(group[j])\n            num = min(remain)\n            group[i] = num\n            num_max = max(num_max,num)\n\n        res = [0] * (num_max+1)\n        for i,num in enumerate(group[1:],1):\n            res[num] += mods[i]\n            res[num] %= mod\n\n        return res\n\n    x = calc_node(ab)\n    y = calc_node(cd)\n    z = calc_node(ef)\n\n    if(len(x) < len(y)):\n        x,y = y,x\n    if(len(y) < len(z)):\n        y,z = z,y\n    if(len(x) < len(y)):\n        x,y = y,x\n\n\n    len_2 = 2**(len(y)-1).bit_length()\n    yz = [0] * (len_2)\n    for j in range(len(y)):\n        for k in range(len(z)):\n            yz[j^k] += y[j]*z[k]\n            yz[j^k] %= mod\n\n    ans = 0\n    for i,j in zip(x,yz):\n        ans += i*j\n        ans %= mod\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nn = int(readline())\ndata = tuple(map(int,read().split()))\nm1 = data[0]\nab = data[1:1+2*m1]\nm2 = data[1+2*m1]\ncd = data[2+2*m1:2+2*(m1+m2)]\nm3 = data[2+2*(m1+m2)]\nef = data[3+2*(m1+m2):]\n\nmod = 998244353\nmods = [1] * (n+10)\nbase = pow(10,18,mod)\nfor i in range(1,n+1):\n    mods[i] = (mods[i-1] * base)%mod\n\ndef calc_node(xy):\n    links = [[] for _ in range(n+1)]\n    it = iter(xy)\n    for x,y in zip(it,it):\n        links[x].append(y)\n        links[y].append(x)\n\n    group = [-1] * (n+1)\n    group[-1] = 0\n    num_max = 1\n    for i in range(n,0,-1):\n        remain = set(range(num_max+2))\n        for j in links[i]:\n            if(i < j):\n                remain.discard(group[j])\n        num = min(remain)\n        group[i] = num\n        num_max = max(num_max,num)\n\n    res = [0] * (num_max+1)\n    for i,num in enumerate(group[1:],1):\n        res[num] += mods[i]\n        res[num] %= mod\n\n    return res\n\nx = calc_node(ab)\ny = calc_node(cd)\nz = calc_node(ef)\n\n\nif(len(x) < len(y)):\n    x,y = y,x\nif(len(y) < len(z)):\n    y,z = z,y\nif(len(x) < len(y)):\n    x,y = y,x\n\n\nlen_2 = 2**(len(y)-1).bit_length()\ncomb = [[] for _ in range(len_2)]\nfor j in range(len(y)):\n    for k in range(len(z)):\n        comb[j^k].append((j,k))\n\nans = 0\nfor i,x_tmp in enumerate(x):\n    if(len(comb) == i):\n        break\n\n    yz = 0\n    for j,k in comb[i]:\n        yz += y[j]*z[k]\n        yz %= mod\n    ans += x_tmp * yz\n    ans %= mod\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0] += (sum_g[0] + BB[i]) % M\n  sum_g[0] = (inv_mod(B-1, pow(B, N+1, M)-B, M) - sum_g[0]) % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  prev_i = 1\n  prev_W = B\n  for i in range(1, N+1):\n    if i in g:\n      W = (W * pow(B, i-prev_i, M)) % M\n      sum_g[g[i]] = (sum_g[g[i]] + W) % M\n      sum_g[0]  = (sum_g[0] - W) % M\n      prev_i, prev_W = i, W\n  \n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  prev_i = 1\n  prev_W = B\n  for i in range(1, N+1):\n    if i in g:\n      W = (B * pow(B, i-prev_i, M)) % M\n      sum_g[g[i]] = (sum_g[g[i]] + W) % M\n      sum_g[0]  = (sum_g[0] - W) % M\n      prev_i, prev_W = i, W\n  \n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = 10**18 % M\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in sorted(e.keys(), reverse=True):\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      x = pow(B, i, M)\n      sum_g[m] += x\n      sum_g[0] -= x\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz)%M\n  return ret\n\nN = int(input())\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0]  = (sum_g[0] - BB[i]) % M\n\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "mod=998244353\ninv=pow(2,mod-2,mod)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\nimport sys\n\ninput=sys.stdin.buffer.readline\n\nN=int(input())\n\ndef data():\n    edge=[[] for i in range(N)]\n    for i in range(int(input())):\n        a,b=map(int,input().split())\n        if a>b:\n            a,b=b,a\n        edge[a-1].append(b-1)\n    mex=[0 for i in range(N)]\n    for i in range(N-1,-1,-1):\n        used=[False]*(len(edge[i])+1)\n        for pv in edge[i]:\n            if mex[pv]<=len(edge[i]):\n                used[mex[pv]]=True\n        for j in range(len(used)):\n            if not used[j]:\n                mex[i]=j\n                break\n    res=[0]*(max(mex)+1)\n    for i in range(N):\n        res[mex[i]]+=pow(10,18*(i+1),mod)\n        res[mex[i]]%=mod\n\n    return res\n\nXdata=data()\nYdata=data()\nZdata=data()\n\nn=0\nm=max(len(Xdata),len(Ydata),len(Zdata))\nwhile 2**n<m:\n    n+=1\n\nX=[0 for i in range(2**n)]\nY=[0 for i in range(2**n)]\nZ=[0 for i in range(2**n)]\n\nfor i in range(len(Xdata)):\n    X[i]=Xdata[i]\n\nfor i in range(len(Ydata)):\n    Y[i]=Ydata[i]\n\nfor i in range(len(Zdata)):\n    Z[i]=Zdata[i]\n\nYZ=xorconv(n,Y,Z)\n\nans=0\nfor i in range(2**n):\n    ans+=X[i]*YZ[i]\n    ans%=mod\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nmod=998244353\n\nN=int(input())\nM1=int(input())\nE1=[[] for i in range(N+1)]\nfor i in range(M1):\n    x,y=map(int,input().split())\n    E1[x].append(y)\n    E1[y].append(x)\n\nM2=int(input())\nE2=[[] for i in range(N+1)]\nfor i in range(M2):\n    x,y=map(int,input().split())\n    E2[x].append(y)\n    E2[y].append(x)\n\nM3=int(input())\nE3=[[] for i in range(N+1)]\nfor i in range(M3):\n    x,y=map(int,input().split())\n    E3[x].append(y)\n    E3[y].append(x)\n\nG1=[-1]*(N+1)\nG1[N]=0\nfor i in range(N-1,-1,-1):\n    GS=set()\n    for to in E1[i]:\n        GS.add(G1[to])\n    for j in range(N+1):\n        if j in GS:\n            continue\n        else:\n            G1[i]=j\n            break\n\nG2=[-1]*(N+1)\nG2[N]=0\nfor i in range(N-1,-1,-1):\n    GS=set()\n    for to in E2[i]:\n        GS.add(G2[to])\n    for j in range(N+1):\n        if j in GS:\n            continue\n        else:\n            G2[i]=j\n            break\n\nG3=[-1]*(N+1)\nG3[N]=0\nfor i in range(N-1,-1,-1):\n    GS=set()\n    for to in E3[i]:\n        GS.add(G3[to])\n    for j in range(N+1):\n        if j in GS:\n            continue\n        else:\n            G3[i]=j\n            break\n\nfrom collections import Counter\nC1=Counter()\nC2=Counter()\nC3=Counter()\n\nfor i in range(1,N+1):\n    C1[G1[i]]=(C1[G1[i]]+pow(10,18*i,mod))%mod\n    C2[G2[i]]=(C2[G2[i]]+pow(10,18*i,mod))%mod\n    C3[G3[i]]=(C3[G3[i]]+pow(10,18*i,mod))%mod\n        \nC12=Counter()\n\nfor c1 in C1:\n    for c2 in C2:\n        C12[c1^c2]=(C12[c1^c2]+C1[c1]*C2[c2])%mod\n\nANS=0\nfor c3 in C3:\n    ANS=(ANS+C3[c3]*C12[c3])%mod\n\nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  e = set(e)\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0]  = (sum_g[0] - BB[i]) % M\n\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  x = 1\n  for i in range(1, N+1):\n    x = (x * B) % M\n    if i in g:\n      j = g.pop(i)\n      sum_g[j] = (sum_g[j] + x) % M\n      sum_g[0]  = (sum_g[0] - x) % M\n      if not g:\n        break\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret += (sx*sy*sz) % M\n  return ret%M\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in set(e[i])})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0]  = (sum_g[0] - BB[i]) % M\n\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  prev_i = 0\n  W = 1\n  for i in range(1, N+1):\n    if i in g:\n      if i-prev_i != 1:\n        W = (W * pow(B, i-prev_i, M)) % M\n      else:\n        W = (W * B) % M\n      sum_g[g[i]] = (sum_g[g[i]] + W) % M\n      sum_g[0]  = (sum_g[0] - W) % M\n      prev_i, W = i, W\n  \n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0]  = (sum_g[0] - BB[i]) % M\n\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nmod=998244353\n\nN=int(input())\nM1=int(input())\nE1=[[] for i in range(N+1)]\nfor i in range(M1):\n    x,y=map(int,input().split())\n    E1[x].append(y)\n    E1[y].append(x)\n\nM2=int(input())\nE2=[[] for i in range(N+1)]\nfor i in range(M2):\n    x,y=map(int,input().split())\n    E2[x].append(y)\n    E2[y].append(x)\n\nM3=int(input())\nE3=[[] for i in range(N+1)]\nfor i in range(M3):\n    x,y=map(int,input().split())\n    E3[x].append(y)\n    E3[y].append(x)\n\nG1=[-1]*(N+1)\nG1[N]=0\nfor i in range(N-1,-1,-1):\n    GS=set()\n    for to in E1[i]:\n        GS.add(G1[to])\n    for j in range(N+1):\n        if j in GS:\n            continue\n        else:\n            G1[i]=j\n            break\n\nG2=[-1]*(N+1)\nG2[N]=0\nfor i in range(N-1,-1,-1):\n    GS=set()\n    for to in E2[i]:\n        GS.add(G2[to])\n    for j in range(N+1):\n        if j in GS:\n            continue\n        else:\n            G2[i]=j\n            break\n\nG3=[-1]*(N+1)\nG3[N]=0\nfor i in range(N-1,-1,-1):\n    GS=set()\n    for to in E3[i]:\n        GS.add(G3[to])\n    for j in range(N+1):\n        if j in GS:\n            continue\n        else:\n            G3[i]=j\n            break\n\nfrom collections import Counter\nC1=Counter()\nC2=Counter()\nC3=Counter()\n\nfor i in range(1,N+1):\n    C1[G1[i]]=(C1[G1[i]]+pow(10,18*i,mod))%mod\n    C2[G2[i]]=(C2[G2[i]]+pow(10,18*i,mod))%mod\n    C3[G3[i]]=(C3[G3[i]]+pow(10,18*i,mod))%mod\n        \nC12=Counter()\n\nfor c1 in C1:\n    for c2 in C2:\n        C12[c1^c2]=(C12[c1^c2]+C1[c1]*C2[c2])%mod\n\nANS=0\nfor c3 in C3:\n    ANS=(ANS+C3[c3]*C12[c3])%mod\n\nprint(ANS)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  x = 1\n  for i in range(1, N+1)\n    x = (x * B) % M\n    if g[i]:\n      sum_g[g[i]] += x\n      sum_g[0] -= x\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret += (sx*sy*sz) % M\n  return ret%M\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  prev_i = 1\n  W = B\n  for i in range(1, N+1):\n    if i in g:\n      W = (W * pow(B, i-prev_i, M)) % M\n      sum_g[g[i]] = (sum_g[g[i]] + W) % M\n      sum_g[0]  = (sum_g[0] - W) % M\n      prev_i, W = i, W\n  \n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  x = 1\n  for i in range(1, N+1):\n    x = (x * B) % M\n    if i in g:\n      sum_g[g[i]] += x\n      sum_g[0] -= x\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret += (sx*sy*sz) % M\n  return ret%M\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0] = (sum_g[0] + BB[i]) % M\n  sum_g[0] = (inv_mod(B-1, pow(B, N+1, M)-B, M) - sum_g[0]) % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      x = pow(B, i, M)\n      sum_g[m] += x\n      sum_g[0] -= x\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret += (sx*sy*sz) % M\n  return ret%M\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef calc():\n    def mex(i):\n        t = 0\n        for j in X[i]:\n            t |= 1 << G[j]\n        t = ~t\n        return (t & -t).bit_length() - 1\n    M = int(input())\n    X = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        X[N - min(a, b)].append(N - max(a, b))\n    G = [0] * N\n    for i in range(N):\n        G[i] = mex(i)\n    H = [0] * 1024\n    a = 1\n    for i in range(N)[::-1]:\n        a = a * A % P\n        H[G[i]] = (H[G[i]] + a) % P\n    return H\n\nP = 998244353\nA = pow(10, 18, P)\nN = int(input())\nH1, H2, H3 = calc(), calc(), calc()\nans = 0\nfor i in range(1024):\n    if H1[i] == 0: continue\n    for j in range(1024):\n        if H2[j] == 0: continue\n        ans = (ans + H1[i] * H2[j] * H3[i^j]) % P\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      x = pow(B, i, M)\n      sum_g[m] = (sum_g[m] + x) % M\n      sum_g[0] = (sum_g[0] - x) % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz)%M\n  return ret\n\nN = int(input())\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nimport numba\nfrom numba import njit, b1, i4, i8, f8\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 998_244_353\n\n@njit((i8, i8[:, :]), cache=True)\ndef precompute(N, G):\n    ng = np.zeros(N + 10, np.bool_)\n    g = np.zeros(N + 1, np.int64)\n    ind = np.searchsorted(G[:, 0], np.arange(N + 10))\n    for v in range(N - 1, 0, -1):\n        for i in range(ind[v], ind[v + 1]):\n            w = G[i, 1]\n            ng[g[w]] = 1\n        for n in range(N + 10):\n            if ng[n]:\n                continue\n            break\n        g[v] = n\n        for i in range(ind[v], ind[v + 1]):\n            w = G[i, 1]\n            ng[g[w]] = 0\n\n    B = 10**18 % MOD\n    power = 1\n    A = np.zeros(1024, np.int64)\n    for i in range(1, N + 1):\n        power = power * B % MOD\n        A[g[i]] += power\n    return A % MOD\n\n@njit((i8[:], i8[:]), cache=True)\ndef convolve(A, B):\n    C = np.zeros(1024, np.int64)\n    for i in range(1024):\n        for j in range(1024):\n            C[i ^ j] += A[i] * B[j] % MOD\n    return C % MOD\n\nN = int(readline())\nnums = np.array(read().split(), np.int64)\ngraphs = []\nfor _ in range(3):\n    M = nums[0]\n    G = nums[1:1 + 2 * M].reshape(M, 2)\n    G.sort(axis=1)\n    graphs.append(G)\n    nums = nums[1 + 2 * M:]\n\nG1, G2, G3 = map(lambda G: precompute(N, G), graphs)\n\nprint(convolve(convolve(G1, G2), G3)[0])"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353 # < (1 << 30)\n\ndef mod_inv(a, M=M):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, M\n  while abs(z1) != 1:\n    d, m = divmod(z2, z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1*z1%M\n\nR_bits = 30\nR = 1 << R_bits\nR_dec = R - 1\nR2 = pow(R, 2, M)\nM_neg_inv = mod_inv(-M, R)\n\ndef MR(x):\n  b = (x * M_neg_inv) & R_dec\n  t = x + b * M\n  c = t >> R_bits\n  d = c - M\n  return d if 0 <= d else c\n\ndef Montgomery(x):\n  return MR(x*R2)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(edge):\n  grundy = [{} for i in range(3)]\n  sum_g = [defaultdict(int, {0:M_W_sum}) for i in range(3)]\n  M_W = M_W_last\n  for i in range(N, 0, -1):\n    for g, s, e in zip(grundy, sum_g, edge):\n      if i in e:\n        m = mex({g.get(j, 0) for j in e[i]})\n        if m:\n          g[i] = m\n          s[g[i]] +=  M_W\n          s[0] -=  M_W\n    M_W = MR(M_W * M_B_inv)\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\nN = int(input())\nB = pow(10, 18, M)\nM_B_inv = Montgomery(mod_inv(B))\nM_W_last = Montgomery(pow(B, N, M))\nM_W_sum = MR((M_W_last - Montgomery(1)) * MR(Montgomery(B) * Montgomery(mod_inv(B-1))))\n\nedge = [read_edge() for i in range(3)]\nsum_g = calc_grundy(edge)\nans = 0\nfor gx, sx in sum_g[0].items():\n  for gy, sy in sum_g[1].items():\n    gz = gx^gy\n    sz = sum_g[2][gz]\n    if sz:\n      ans += MR(MR(sx*sy)*sz)\nprint(MR(ans)%M)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      x = pow(B, i, M)\n      sum_g[m] += x\n      sum_g[0] -= x\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = ret + sx*sy*sz\n  return ret%M\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = 10**18 % M\n\ndef mex(s):\n  for i in range(max(s)+2):\n    if i not in s:\n      return i\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in sorted(e.keys(), reverse=True):\n    m = mex({g.get(j,0) for j in e[i]})\n    if m:\n      g[i] = m\n      x = pow(B, i, M)\n      sum_g[m] += x\n      sum_g[0] -= x\n  return sum_g\n\ndef get_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, x in sum_g[0].items():\n    for gy, y in sum_g[1].items():\n      gz = gx^gy\n      z = sum_g[2][gz]\n      ret = (ret + x*y*z)%M\n  return ret\n\nN = int(input())\nedge = [get_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = 10**18 % M\n\ndef mex(s):\n  for i in range(max(s)+2):\n    if i not in s:\n      return i\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in sorted(e.keys(), reverse=True):\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      x = pow(B, i, M)\n      sum_g[m] += x\n      sum_g[0] -= x\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz)%M\n  return ret\n\nN = int(input())\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0]  = (sum_g[0] - BB[i]) % M\n\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "def calc():\n    def mex(i):\n        D = {}\n        for j in X[i]:\n            D[G[j]] = 1\n        for g in range(N + 1):\n            if g not in D:\n                return g\n    M = int(input())\n    X = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        X[N - min(a, b)].append(N - max(a, b))\n    G = [0] * N\n    for i in range(N):\n        G[i] = mex(i)\n    H = [0] * 1024\n    a = 1\n    for i in range(N)[::-1]:\n        a = a * A % P\n        H[G[i]] = (H[G[i]] + a) % P\n    return H\n\nP = 998244353\nA = pow(10, 18, P)\nN = int(input())\nH1, H2, H3 = calc(), calc(), calc()\nans = 0\nfor i in range(1024):\n    if H1[i] == 0: continue\n    for j in range(1024):\n        if H2[j] == 0: continue\n        ans = (ans + H1[i] * H2[j] * H3[i^j]) % P\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = 10**18 % M\n\ndef mex(s):\n  for i in range(max(s)+2):\n    if i not in s:\n      return i\n\ndef calc_grandy(e):\n  g = {}\n  rev_g = defaultdict(set)\n  rev_g[0] = set(range(1, N+1))\n  for i in sorted(e.keys(), reverse=True):\n    m = mex({g.get(j,0) for j in e[i]})\n    if m:\n      g[i] = m\n      rev_g[m].add(i)\n      rev_g[0].remove(i)\n  return defaultdict(int, ((k,sum(map(lambda x:pow(B, x, M), v))%M) for k, v in rev_g.items()))\n\ndef get_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  grandy = list(map(calc_grandy, edge))\n  ret = 0\n  for gx, x in grandy[0].items():\n    for gy, y in grandy[1].items():\n      gz = gx^gy\n      z = grandy[2][gz]\n      ret = (ret + x*y*z)%M\n  return ret\n\nN = int(input())\nedge = [get_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\nclass mod_int(int):\n  def __new__(cls, i=0, *args, **kwargs):\n    return int.__new__(cls, i%M, *args, **kwargs)\n  \n  def __add__(self, x):\n    return self.__class__(int.__add__(self, x))\n    \n  def __sub__(self, x):\n    return self.__class__(int.__sub__(self, x))\n    \n  def __neg__(self):\n    return self.__class__(int.__neg__(self, x))\n  \n  def __mul__(self, x):\n    return self.__class__(int.__mul__(self, x))\n  \n  def __floordiv__(self, x):\n    a, b = ext_euc(x, M)\n    return self * a\n  \n  def __inv__(self):\n    a, b = ext_euc(self, M)\n    return self.__class__(a)\n  \n  def __pow__(self, x):\n    return self.__class__(int.__pow__(self, x, M))\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(mod_int)\n  sum_g[0] = (B**(N+1) - B) // (B-1)\n  prev = N\n  W = B**N\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      W *= B_inv**(prev-i)\n      sum_g[g[i]] +=  W\n      sum_g[0]  -= W\n      prev, W = i, W\n  \n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = mod_int(0)\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret += sx*sy*sz\n  return ret\n\n\nM = 998244353\nB = mod_int(10) ** 18\nB_inv = ~B\nN = int(input())\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  x = 1\n  for i in range(1, N+1):\n    x = (x * B) % M\n    if g[i]:\n      sum_g[g[i]] += x\n      sum_g[0] -= x\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret += (sx*sy*sz) % M\n  return ret%M\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\nclass mod_int(int):\n  def __new__(cls, i=0, *args, **kwargs):\n    return int.__new__(cls, i%M, *args, **kwargs)\n  \n  def __add__(self, x):\n    return self.__class__(int.__add__(self, x))\n    \n  def __sub__(self, x):\n    return self.__class__(int.__sub__(self, x))\n    \n  def __neg__(self):\n    return self.__class__(int.__neg__(self, x))\n  \n  def __mul__(self, x):\n    return self.__class__(int.__mul__(self, x))\n  \n  def __floordiv__(self, x):\n    a, b = ext_euc(x, M)\n    return self * a\n  \n  def __invert__(self):\n    a, b = ext_euc(self, M)\n    return self.__class__(a)\n  \n  def __pow__(self, x):\n    return self.__class__(int.__pow__(self, x, M))\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(mod_int)\n  sum_g[0] = (B**(N+1) - B) // (B-1)\n  prev = N\n  W = B**N\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      W *= B_inv**(prev-i)\n      sum_g[g[i]] +=  W\n      sum_g[0]  -= W\n      prev, W = i, W\n  \n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = mod_int(0)\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret += sx*sy*sz\n  return ret\n\n\nM = 998244353\nB = mod_int(10) ** 18\nB_inv = ~B\nN = int(input())\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  sum_g[0] = inv_mod(B-1, pow(B, N+1, M)-B, M)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0]  = (sum_g[0] - BB[i]) % M\n\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef calc():\n    def mex(i):\n        D = {}\n        for j in X[i]:\n            D[G[j]] = 1\n        for g in range(N + 1):\n            if g not in D:\n                return g\n    M = int(input())\n    X = [[] for _ in range(N)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        X[N - min(a, b)].append(N - max(a, b))\n    G = [0] * N\n    for i in range(N):\n        G[i] = mex(i)\n    H = [0] * 1024\n    a = 1\n    for i in range(N)[::-1]:\n        a = a * A % P\n        H[G[i]] = (H[G[i]] + a) % P\n    return H\n\nP = 998244353\nA = pow(10, 18, P)\nN = int(input())\nH1, H2, H3 = calc(), calc(), calc()\nans = 0\nfor i in range(1024):\n    if H1[i] == 0: continue\n    for j in range(1024):\n        if H2[j] == 0: continue\n        ans = (ans + H1[i] * H2[j] * H3[i^j]) % P\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def main():\n    \"\"\"\"ここに今までのコード\"\"\"\n    import sys\n    read = sys.stdin.buffer.read\n    readline = sys.stdin.buffer.readline\n    readlines = sys.stdin.buffer.readlines\n\n    n = int(readline())\n    data = tuple(map(int,read().split()))\n    m1 = data[0]\n    ab = data[1:1+2*m1]\n    m2 = data[1+2*m1]\n    cd = data[2+2*m1:2+2*(m1+m2)]\n    m3 = data[2+2*(m1+m2)]\n    ef = data[3+2*(m1+m2):]\n\n    mod = 998244353\n    mods = [1] * (n+10)\n    base = pow(10,18,mod)\n    for i in range(1,n+1):\n        mods[i] = (mods[i-1] * base)%mod\n\n    def calc_node(xy):\n        links = [[] for _ in range(n+1)]\n        it = iter(xy)\n        for x,y in zip(it,it):\n            if(x < y):\n                x,y = y,x\n            links[y].append(x)\n\n        group = [-1] * (n+1)\n        g_bit = [0] * (n+1)\n        group[-1] = 0\n        g_bit[-1] = 1\n        num_max = 1\n        for i in range(n,0,-1):\n            tmp = 0\n            for j in links[i]:\n                tmp |= g_bit[j]\n            cnt = 0\n            while(tmp&1):\n                tmp = tmp>>1\n                cnt+=1\n            group[i] = cnt\n            g_bit[i] = 1 << cnt\n            num_max = max(num_max,cnt)\n\n        res = [0] * (num_max+1)\n        for i,num in enumerate(group[1:],1):\n            res[num] += mods[i]\n            res[num] %= mod\n\n        return res\n\n    x = calc_node(ab)\n    y = calc_node(cd)\n    z = calc_node(ef)\n\n    if(len(x) < len(y)):\n        x,y = y,x\n    if(len(y) < len(z)):\n        y,z = z,y\n    if(len(x) < len(y)):\n        x,y = y,x\n\n\n    len_2 = 2**(len(y)-1).bit_length()\n    yz = [0] * (len_2)\n    for j in range(len(y)):\n        for k in range(len(z)):\n            yz[j^k] += y[j]*z[k]\n            yz[j^k] %= mod\n\n    ans = 0\n    for i,j in zip(x,yz):\n        ans += i*j\n        ans %= mod\n\n    print(ans)\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nM = 998244353\nB = pow(10, 18, M)\nN = int(input())\n\ndef geometric_mod(a, r, m, n):\n  x = a\n  for i in range(n):\n    yield x\n    x = (x*r)%m\n\nBB = list(geometric_mod(1, B, M, N+2))\n\ndef ext_euc(a, b):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, b\n  while z1 != 1:\n    d, m = divmod(z2,z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1, y1\n\ndef inv_mod(a, b, m):\n  x, y = ext_euc(a, m)\n  return (x * b % m)\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  sum_g = defaultdict(int)\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n      sum_g[g[i]] = (sum_g[g[i]] + BB[i]) % M\n      sum_g[0] = (sum_g[0] + BB[i]) % M\n  sum_g[0] = (inv_mod(B-1, pow(B, N+1, M)-B, M) - sum_g[0]) % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(set)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].add(b)\n  return e\n\ndef solve(N, edge):\n  sum_g = list(map(calc_grundy, edge))\n  ret = 0\n  for gx, sx in sum_g[0].items():\n    for gy, sy in sum_g[1].items():\n      gz = gx^gy\n      sz = sum_g[2][gz]\n      if sz:\n        ret = (ret + sx*sy*sz) % M\n  return ret\n\n\nedge = [read_edge() for i in range(3)]\n\nprint(solve(N, edge))"
  },
  {
    "language": "Python",
    "code": "mod=998244353\ninv=pow(2,mod-2,mod)\n\ndef xorconv(n,X,Y):\n    if n==0:\n        res=[(X[0]*Y[0])%mod]\n        return res\n    x=[X[i]+X[i+2**(n-1)] for i in range(2**(n-1))]\n    y=[Y[i]+Y[i+2**(n-1)] for i in range(2**(n-1))]\n    z=[X[i]-X[i+2**(n-1)] for i in range(2**(n-1))]\n    w=[Y[i]-Y[i+2**(n-1)] for i in range(2**(n-1))]\n    res1=xorconv(n-1,x,y)\n    res2=xorconv(n-1,z,w)\n    former=[(res1[i]+res2[i])*inv for i in range(2**(n-1))]\n    latter=[(res1[i]-res2[i])*inv for i in range(2**(n-1))]\n    former=list(map(lambda x:x%mod,former))\n    latter=list(map(lambda x:x%mod,latter))\n    return former+latter\n\nimport sys\n\ninput=sys.stdin.buffer.readline\n\nN=int(input())\n\ndef data():\n    edge=[[] for i in range(N)]\n    for i in range(int(input())):\n        a,b=map(int,input().split())\n        if a>b:\n            a,b=b,a\n        edge[a-1].append(b-1)\n    mex=[0 for i in range(N)]\n    for i in range(N-1,-1,-1):\n        used=[False]*(len(edge[i])+1)\n        for pv in edge[i]:\n            if mex[pv]<=len(edge[i]):\n                used[mex[pv]]=True\n        for j in range(len(used)):\n            if not used[j]:\n                mex[i]=j\n                break\n    res=[0]*(max(mex)+1)\n    for i in range(N):\n        res[mex[i]]+=pow(10,18*(i+1),mod)\n        res[mex[i]]%=mod\n\n    return res\n\nXdata=data()\nYdata=data()\nZdata=data()\n\nn=0\nm=max(len(Xdata),len(Ydata),len(Zdata))\nwhile 2**n<m:\n    n+=1\n\nX=[0 for i in range(2**n)]\nY=[0 for i in range(2**n)]\nZ=[0 for i in range(2**n)]\n\nfor i in range(len(Xdata)):\n    X[i]=Xdata[i]\n\nfor i in range(len(Ydata)):\n    Y[i]=Ydata[i]\n\nfor i in range(len(Zdata)):\n    Z[i]=Zdata[i]\n\nans=0\nfor i in range(2**n):\n    for j in range(2**n):\n        ans+=X[i]*Y[j]*Z[i^j]\n        ans%=mod\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\n\ninput = lambda: sys.stdin.readline().rstrip()\n\ndef mod_inv(a):\n  x1, y1, z1 = 1, 0, a\n  x2, y2, z2 = 0, 1, M\n  while z1 != 1:\n    d, m = divmod(z2, z1)\n    x1, x2 = x2-d*x1, x1\n    y1, y2 = y2-d*y1, y1\n    z1, z2 = m, z1\n  return x1%M\n\ndef mex(s):\n  for i in range(N+1):\n    if i not in s:\n      return i\n\ndef calc_grundy(e):\n  g = {}\n  for i in range(N, 0, -1):\n    if i not in e:\n      continue\n    m = mex({g.get(j, 0) for j in e[i]})\n    if m:\n      g[i] = m\n  return g\n\ndef sum_grundy(grundy):\n  sum_g = [defaultdict(int, {0:B_sum}) for i in range(3)]\n  W = 1\n  for i in range(1, N+1):\n    W = W * B % M\n    for s, g in zip(sum_g, grundy):\n      if i in g:\n        s[g[i]] =  (s[g[i]] + W) % M\n        s[0] =  (s[0] - W) % M\n  return sum_g\n\ndef read_edge():\n  M = int(input())\n  e = defaultdict(list)\n  for i in range(M):\n    a, b = sorted(map(int, input().split()))\n    e[a].append(b)\n  return e\n\nN = int(input())\nM = 998244353\nB = pow(10, 18, M)\nB_sum = (pow(B, N+1, M) - B) * mod_inv(B-1) % M\n\nedge = [read_edge() for i in range(3)]\ngrundy = list(map(calc_grundy, edge))\nsum_g = sum_grundy(grundy)\nans = 0\nfor gx, sx in sum_g[0].items():\n  for gy, sy in sum_g[1].items():\n    gz = gx^gy\n    sz = sum_g[2][gz]\n    if sz:\n      ans = (ans + sx*sy*sz) % M\nprint(ans)\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\nconst MOD: i64 = 998_244_353;\n#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\npub struct Modi64(pub i64);\nimpl Modi64 {\n    #[inline]\n    pub fn new(i: i64) -> Modi64 {\n        Modi64(Modi64::modulo(i, MOD))\n    }\n    #[inline]\n    pub fn modulo(i: i64, m: i64) -> i64 {\n        if i < 0 {\n            i % m + m\n        } else {\n            i % m\n        }\n    }\n    pub fn pow(self, y: i64) -> Modi64 {\n        let mut y = Modi64(Modi64::modulo(y, MOD - 1));\n        let mut x = 1.into();\n        let mut base = self;\n        while y.0 > 0 {\n            if y.0 & 1 == 1 {\n                x *= base;\n            }\n            base *= base;\n            y = Modi64(y.0 >> 1);\n        }\n        x\n    }\n    #[inline]\n    pub fn inv(self) -> Modi64 {\n        self.pow(MOD - 2)\n    }\n}\nimpl From<i64> for Modi64 {\n    fn from(i: i64) -> Modi64 {\n        Modi64::new(i)\n    }\n}\nimpl std::ops::Add for Modi64 {\n    type Output = Modi64;\n    fn add(self, rhs: Modi64) -> Modi64 {\n        (self.0 + rhs.0).into()\n    }\n}\nimpl std::ops::AddAssign for Modi64 {\n    fn add_assign(&mut self, rhs: Modi64) {\n        *self = *self + rhs;\n    }\n}\nimpl std::ops::Sub for Modi64 {\n    type Output = Modi64;\n    fn sub(self, rhs: Modi64) -> Modi64 {\n        (self.0 - rhs.0).into()\n    }\n}\nimpl std::ops::SubAssign for Modi64 {\n    fn sub_assign(&mut self, rhs: Modi64) {\n        *self = *self - rhs;\n    }\n}\nimpl std::ops::Mul for Modi64 {\n    type Output = Modi64;\n    fn mul(self, rhs: Modi64) -> Modi64 {\n        (self.0 * rhs.0).into()\n    }\n}\nimpl std::ops::MulAssign for Modi64 {\n    fn mul_assign(&mut self, rhs: Modi64) {\n        *self = *self * rhs;\n    }\n}\nimpl std::ops::Div for Modi64 {\n    type Output = Modi64;\n    fn div(self, rhs: Modi64) -> Modi64 {\n        self * rhs.inv()\n    }\n}\nimpl std::ops::DivAssign for Modi64 {\n    fn div_assign(&mut self, rhs: Modi64) {\n        *self = *self / rhs;\n    }\n}\nimpl std::ops::Neg for Modi64 {\n    type Output = Modi64;\n    fn neg(self) -> Modi64 {\n        (-self.0).into()\n    }\n}\nimpl std::iter::Sum for Modi64 {\n    fn sum<I: Iterator<Item = Modi64>>(iter: I) -> Modi64 {\n        iter.fold(0.into(), std::ops::Add::add)\n    }\n}\nimpl<'a> std::iter::Sum<&'a Modi64> for Modi64 {\n    fn sum<I: Iterator<Item = &'a Modi64>>(iter: I) -> Modi64 {\n        iter.fold(0.into(), |x, &y| x + y)\n    }\n}\nimpl std::fmt::Display for Modi64 {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> Result<(), std::fmt::Error> {\n        write!(f, \"{}\", self.0)\n    }\n}\n#[derive(Clone, Copy, Debug, Default)]\npub struct Adjacent {\n    pub to: usize,\n    pub id: usize,\n}\nimpl Adjacent {\n    pub fn new(to: usize, id: usize) -> Adjacent {\n        Adjacent { to: to, id: id }\n    }\n}\n#[derive(Clone, Debug, Default)]\npub struct Graph {\n    pub vsize: usize,\n    pub esize: usize,\n    pub graph: Vec<Vec<Adjacent>>,\n}\nimpl Graph {\n    pub fn new(vsize: usize) -> Graph {\n        Graph {\n            vsize: vsize,\n            esize: 0,\n            graph: vec![vec![]; vsize],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(Adjacent::new(to, self.esize));\n        self.esize += 1;\n    }\n    pub fn add_undirected_edge(&mut self, u: usize, v: usize) {\n        self.graph[u].push(Adjacent::new(v, self.esize));\n        self.graph[v].push(Adjacent::new(u, self.esize));\n        self.esize += 1;\n    }\n    pub fn vertexes(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    pub fn adjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.graph[from]\n    }\n    pub fn grundy(&self) -> Vec<usize> {\n        let mut res = vec![0; self.vsize];\n        for u in self.vertexes().rev() {\n            let mut set = std::collections::HashSet::new();\n            for v in self.adjacency(u) {\n                if u < v.to {\n                    set.insert(res[v.to]);\n                }\n            }\n            for i in 0.. {\n                if !set.contains(&i) {\n                    res[u] = i;\n                    break;\n                }\n            }\n        }\n        res\n    }\n}\nfn main() {\n    input! {\n        n,\n        m1, e1: [(usize1, usize1); m1],\n        m2, e2: [(usize1, usize1); m2],\n        m3, e3: [(usize1, usize1); m3]\n    };\n    let mut g1 = Graph::new(n);\n    let mut g2 = Graph::new(n);\n    let mut g3 = Graph::new(n);\n    for &(u, v) in e1.iter() {\n        g1.add_undirected_edge(u, v);\n    }\n    for &(u, v) in e2.iter() {\n        g2.add_undirected_edge(u, v);\n    }\n    for &(u, v) in e3.iter() {\n        g3.add_undirected_edge(u, v);\n    }\n    let pow10_18 = Modi64(10).pow(18);\n    let mut tb = vec![Modi64(1); n + 1];\n    for i in 0..n {\n        tb[i + 1] = tb[i] * pow10_18;\n    }\n    let p1 = g1.grundy();\n    let p2 = g2.grundy();\n    let p3 = g3.grundy();\n    let mut q1 = std::collections::HashMap::new();\n    let mut q2 = std::collections::HashMap::new();\n    let mut q3 = std::collections::HashMap::new();\n    for i in 0..n {\n        *q1.entry(p1[i]).or_insert(Modi64(0)) += tb[i + 1];\n        *q2.entry(p2[i]).or_insert(Modi64(0)) += tb[i + 1];\n        *q3.entry(p3[i]).or_insert(Modi64(0)) += tb[i + 1];\n    }\n    let mut ans = Modi64(0);\n    for (&k1, &c1) in q1.iter() {\n        for (&k2, &c2) in q2.iter() {\n            for (&k3, &c3) in q3.iter() {\n                if k1 ^ k2 ^ k3 == 0 {\n                    ans += c1 * c2 * c3;\n                }\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{self, BufRead};\nuse std::collections::{HashSet, BinaryHeap};\nuse std::cmp::Ordering;\n\nconst M: i64 = 998244353;\nconst ten18: i64 = 1_000_000_000_000_000_000 % M;\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\nstruct Vertex(usize, usize, usize, usize);\n\nimpl PartialOrd for Vertex {\n    #[inline]\n    fn partial_cmp(&self, other: &Vertex) -> Option<Ordering> {\n        self.0.partial_cmp(&other.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        self.0 < other.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        self.0 <= other.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        self.0 > other.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        self.0 >= other.0\n    }\n}\n\nimpl Ord for Vertex {\n    #[inline]\n    fn cmp(&self, other: &Vertex) -> Ordering {\n        self.0.cmp(&other.0)\n    }\n}\n\nfn find_adjacent_vertices(edges: &Vec<Vec<HashSet<usize>>>, x: usize, y: usize, z: usize) -> Vec<(usize, usize, usize)> {\n  let mut result = Vec::new();\n  for i in &edges[0][x] {\n    result.push((*i, y, z));\n  }\n  for i in &edges[1][y] {\n    result.push((x, *i, z));\n  }\n  for i in &edges[2][z] {\n    result.push((x, y, *i));\n  }\n  result\n}\n\nfn bfs(edges: &Vec<Vec<HashSet<usize>>>, passed: &mut HashSet<(usize, usize, usize)>, checked: &mut HashSet<(usize, usize, usize)>, forbidden: &mut HashSet<(usize, usize, usize)>, queue: &mut BinaryHeap<Vertex>) {\n  while let Some(Vertex(p, x, y, z)) = queue.pop() {\n    if passed.contains(&(x, y, z)) {\n      continue;\n    }\n    passed.insert((x, y, z));\n    if !forbidden.contains(&(x, y, z)) {\n      checked.insert((x, y, z));\n      for (x1, y1, z1) in find_adjacent_vertices(edges, x, y, z) {\n        if !passed.contains(&(x1, y1, z1)) {\n          forbidden.insert((x1, y1, z1));\n        }\n      }\n    }\n    for (x1, y1, z1) in find_adjacent_vertices(edges, x, y, z) {\n      if !checked.contains(&(x1, y1, z1)) {\n        queue.push(Vertex(x1+y1+z1, x1, y1, z1));\n      }\n    }\n  }\n}\n\nfn main() {\n  let stdin = io::stdin();\n  let mut lines = stdin.lock().lines();\n  let line = lines.next().unwrap().unwrap();\n  let n: usize = line.parse().unwrap();\n  let mut edges: Vec<Vec<HashSet<usize>>> = vec![vec![HashSet::new(); n]; 3];\n  for i in 0..3 {\n    let line = lines.next().unwrap().unwrap();\n    let m: usize = line.parse().unwrap();\n    for _ in 0..m {\n      let line = lines.next().unwrap().unwrap();\n      let vs: Vec<usize> = line.split(' ').map(|x| x.parse().unwrap()).map(|v: usize| v - 1).collect();\n      let j = vs[0];\n      let k = vs[1];\n      edges[i][j].insert(k);\n      edges[i][k].insert(j);\n    }\n  }\n\n  let mut checked: HashSet<(usize, usize, usize)> = HashSet::new();\n  let mut forbidden: HashSet<(usize, usize, usize)> = HashSet::new();\n  let mut passed: HashSet<(usize, usize, usize)> = HashSet::new();\n  let mut queue: BinaryHeap<Vertex> = BinaryHeap::new();\n  queue.push(Vertex(3*n-3, n-1, n-1, n-1));\n  bfs(&edges, &mut passed, &mut checked, &mut forbidden, &mut queue);\n\n  let mut memo: Vec<i64> = vec![0; 3*n+1];\n  memo[0] = (ten18 * ten18 % M) * ten18 % M;\n  for i in 1..(3*n+1) {\n    memo[i] = memo[i-1] * ten18 % M;\n  }\n  let mut ans: i64 = 0;\n  for (x, y, z) in checked {\n    ans = (ans + memo[x + y + z]) % M;\n  }\n\n  println!(\"{}\", ans);\n}"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\nuse std::collections::HashSet;\n\nfn main() {\n    input!{\n        n: usize,\n        m1: usize,\n        es1: [(usize1, usize1); m1],\n        m2: usize,\n        es2: [(usize1, usize1); m2],\n        m3: usize,\n        es3: [(usize1, usize1); m3]\n    }\n    let d = 998244353;\n    let mut g1 = vec![vec![]; n];\n    for &(a, b) in &es1 {\n        g1[a].push(b);\n        g1[b].push(a);\n    }\n    let mut g2 = vec![vec![]; n];\n    for &(a, b) in &es2 {\n        g2[a].push(b);\n        g2[b].push(a);\n    }\n    let mut g3 = vec![vec![]; n];\n    for &(a, b) in &es3 {\n        g3[a].push(b);\n        g3[b].push(a);\n    }\n    let a1 = independent(&g1, d);\n    let a2 = independent(&g2, d);\n    let a3 = independent(&g3, d);\n    println!(\"{}\", (a1.0 * a2.0 % d * a3.0 % d + a1.0 * a2.1 % d * a3.1 % d + a1.1 * a2.0 % d * a3.1 % d + a1.1 * a2.1 % d * a3.0 % d) % d);\n}\n\nfn independent(g: &Vec<Vec<usize>>, d: usize) -> (usize, usize) {\n    let n = g.len();\n    let mut set = HashSet::new();\n    let mut i1 = HashSet::new();\n    let mut i2 = HashSet::new();\n    for i in (0..n).rev() {\n        if set.contains(&i) {\n            continue;\n        }\n        i1.insert(i);\n        set.insert(i);\n        for &j in &g[i] {\n            set.insert(j);\n        }\n    }\n    set = i1.clone();\n    for i in (0..n).rev() {\n        if set.contains(&i) {\n            continue;\n        }\n        i2.insert(i);\n        set.insert(i);\n        for &j in &g[i] {\n            set.insert(j);\n        }\n    }\n    let ret1: usize = i1.iter().fold(0, |ac, &x| (ac + pow_m(10, 18 * (x + 1), d)) % d);\n    let ret2: usize = i2.iter().fold(0, |ac, &x| (ac + pow_m(10, 18 * (x + 1), d)) % d);\n    (ret1, ret2)\n}\n\nfn pow_m(n: usize, mut p: usize, d: usize) -> usize {\n    let mut r = n;\n    let mut ret = 1;\n    while p > 0 {\n        if p % 2 == 0 {\n            r = r * r % d;\n            p /= 2;\n        } else {\n            ret = ret * r % d;\n            p -= 1;\n        }\n    }\n    ret\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin Scanner(require delimiter) ----------\nmod scanner {\n    use std;\n    pub struct Scanner<R> {\n        reader: R,\n        buf: Vec<u8>,\n    }\n    #[allow(dead_code)]\n    impl<R: std::io::BufRead> Scanner<R> {\n        pub fn new(reader: R) -> Self {\n            Scanner {\n                reader: reader,\n                buf: Vec::with_capacity(1024),\n            }\n        }\n        fn read(&mut self, del: u8) {\n            self.buf.clear();\n            self.reader.read_until(del, &mut self.buf).ok();\n            assert!(self.buf.pop().unwrap() == del);\n        }\n        pub fn next<T: std::str::FromStr>(&mut self, del: u8) -> T {\n            self.read(del);\n            std::str::from_utf8(&self.buf)\n                .unwrap()\n                .trim()\n                .parse::<T>()\n                .ok()\n                .unwrap()\n        }\n        pub fn next_bytes(&mut self, del: u8) -> Vec<u8> {\n            self.read(del);\n            std::str::from_utf8(&self.buf)\n                .unwrap()\n                .trim()\n                .bytes()\n                .collect()\n        }\n    }\n}\n// ---------- end scanner(require delimiter) ----------\n// ---------- begin ModInt ----------\nconst MOD: u32 = 998_244_353;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\nimpl From<usize> for ModInt {\n    fn from(val: usize) -> ModInt {\n        ModInt((val % MOD as usize) as u32)\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        assert!(self.0 > 0);\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n\n// 解説読んだ\n// 大きいやつから貪欲 -> まあ明らか\n// これがGame DP と似てると気づく -> 不可能\n// Grundy 数で解ける -> Game DP だとわかれば理解できるが...\nfn run() {\n    let stdin = std::io::stdin();\n    let mut sc = scanner::Scanner::new(stdin.lock());\n    let n: usize = sc.next(b'\\n');\n    let rad = ModInt((1_000_000_000_000_000_000u64 % MOD as u64) as u32);\n    let mut pow = vec![ModInt::one(); n + 1];\n    for i in 1..(n + 1) {\n        pow[i] = pow[i - 1] * rad;\n    }\n    let mut memo = vec![];\n    for _ in 0..3 {\n        let m: usize = sc.next(b'\\n');\n        let mut deg = vec![0; n];\n        let mut e = Vec::with_capacity(m);\n        for _ in 0..m {\n            let a = sc.next::<usize>(b' ') - 1;\n            let b = sc.next::<usize>(b'\\n') - 1;\n            if a < b {\n                deg[a] += 1;\n                e.push((a, b));\n            } else {\n                deg[b] += 1;\n                e.push((b, a));\n            }\n        }\n        let mut g: Vec<_> = deg.into_iter().map(|d| Vec::with_capacity(d)).collect();\n        for (a, b) in e {\n            g[a].push(b);\n        }\n        let mut dp = vec![0; n];\n        let mut elem = vec![false; n];\n        for (v, g) in g.iter().enumerate().rev() {\n            for &u in g.iter() {\n                elem[dp[u]] = true;\n            }\n            dp[v] = elem.iter().position(|b| !*b).unwrap();\n            for &u in g.iter() {\n                elem[dp[u]] = false;\n            }\n        }\n        let w = *dp.iter().max().unwrap();\n        let mut sum = vec![ModInt::zero(); w + 1];\n        for (dp, &p) in dp.into_iter().zip(pow.iter().skip(1)) {\n            sum[dp] += p;\n        }\n        memo.push(sum);\n    }\n    let a = memo.pop().unwrap();\n    let b = memo.pop().unwrap();\n    let c = memo.pop().unwrap();\n    let mut ans = ModInt::zero();\n    for (i, &a) in a.iter().enumerate() {\n        for (j, &b) in b.iter().enumerate() {\n            ans += a * b * c.get(i ^ j).cloned().unwrap_or(ModInt::zero());\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            let (mut a, mut b, _) = red(self.x, M::m());\n            if b < 0 {\n                a = -a;\n                b = -b;\n            }\n            write!(f, \"{}/{}\", a, b)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n    // Finds the simplest fraction x/y congruent to r mod p.\n    // The return value (x, y, z) satisfies x = y * r + z * p.\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 998244353;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\nfn get_g(n: usize, ab: &[(usize, usize)]) -> Vec<HashSet<usize>> {\n    let mut g = vec![HashSet::new(); n];\n    for &(a, b) in ab {\n        g[a].insert(b);\n        g[b].insert(a);\n    }\n    g\n}\n\nfn calc(g: &[HashSet<usize>]) -> Vec<ModInt> {\n    let n = g.len();\n    let mut gr = vec![0; n];\n    let mut dp = vec![];\n    let p18 = ModInt::new(10).pow(18);\n    for i in (0..n).rev() {\n        let mut seen = HashSet::new();\n        for &w in &g[i] {\n            if w > i {\n                seen.insert(gr[w]);\n            }\n        }\n        let mut mex = 0;\n        while seen.contains(&mex) {\n            mex += 1;\n        }\n        gr[i] = mex;\n    }\n    for i in 0..n {\n        while dp.len() <= gr[i] {\n            dp.push(ModInt::new(0));\n        }\n        dp[gr[i]] += p18.pow(i as i64 + 1);\n    }\n    dp\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize,\n        ab: [(usize1, usize1)],\n        cd: [(usize1, usize1)],\n        ef: [(usize1, usize1)],\n    }\n    let g1 = get_g(n, &ab);\n    let g2 = get_g(n, &cd);\n    let g3 = get_g(n, &ef);\n    let dp1 = calc(&g1);\n    let dp2 = calc(&g2);\n    let dp3 = calc(&g3);\n    let mut tot = ModInt::new(0);\n    for i in 0..dp1.len() {\n        for j in 0..dp2.len() {\n            for k in 0..dp3.len() {\n                if (i ^ j ^ k) == 0 {\n                    tot += dp1[i] * dp2[j] * dp3[k];\n                }\n            }\n        }\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin Scanner(require delimiter) ----------\nmod scanner {\n    pub struct Scanner<R> {\n        reader: R,\n        buf: Vec<u8>,\n    }\n    #[allow(dead_code)]\n    impl<R: std::io::BufRead> Scanner<R> {\n        pub fn new(reader: R) -> Self {\n            Scanner {\n                reader: reader,\n                buf: Vec::with_capacity(1024),\n            }\n        }\n        fn read(&mut self, del: u8) {\n            self.buf.clear();\n            self.reader.read_until(del, &mut self.buf).ok();\n            assert!(self.buf.pop().unwrap() == del);\n        }\n        pub fn next<T: std::str::FromStr>(&mut self, del: u8) -> T {\n            self.read(del);\n            std::str::from_utf8(&self.buf)\n                .unwrap()\n                .trim()\n                .parse::<T>()\n                .ok()\n                .unwrap()\n        }\n        pub fn next_bytes(&mut self, del: u8) -> Vec<u8> {\n            self.read(del);\n            std::str::from_utf8(&self.buf)\n                .unwrap()\n                .trim()\n                .bytes()\n                .collect()\n        }\n    }\n}\n// ---------- end scanner(require delimiter) ----------\n// ---------- begin ModInt ----------\nconst MOD: u32 = 998_244_353;\n\n#[derive(Clone, Copy)]\nstruct ModInt(u32);\n\nimpl std::ops::Add for ModInt {\n    type Output = ModInt;\n    fn add(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::AddAssign for ModInt {\n    fn add_assign(&mut self, rhs: ModInt) {\n        *self = *self + rhs;\n    }\n}\n\nimpl std::ops::Sub for ModInt {\n    type Output = ModInt;\n    fn sub(self, rhs: ModInt) -> Self::Output {\n        let mut d = self.0 + MOD - rhs.0;\n        if d >= MOD {\n            d -= MOD;\n        }\n        ModInt(d)\n    }\n}\n\nimpl std::ops::SubAssign for ModInt {\n    fn sub_assign(&mut self, rhs: ModInt) {\n        *self = *self - rhs;\n    }\n}\n\nimpl std::ops::Mul for ModInt {\n    type Output = ModInt;\n    fn mul(self, rhs: ModInt) -> Self::Output {\n        ModInt((self.0 as u64 * rhs.0 as u64 % MOD as u64) as u32)\n    }\n}\n\nimpl std::ops::MulAssign for ModInt {\n    fn mul_assign(&mut self, rhs: ModInt) {\n        *self = *self * rhs;\n    }\n}\n\nimpl std::ops::Neg for ModInt {\n    type Output = ModInt;\n    fn neg(self) -> Self::Output {\n        ModInt(if self.0 == 0 {0} else {MOD - self.0})\n    }\n}\n\nimpl std::fmt::Display for ModInt {\n    fn fmt<'a>(&self, f: &mut std::fmt::Formatter<'a>) -> std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::str::FromStr for ModInt {\n    type Err = std::num::ParseIntError;\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        let val = s.parse::<u32>()?;\n        Ok(ModInt::new(val))\n    }\n}\n\nimpl From<usize> for ModInt {\n    fn from(val: usize) -> ModInt {\n        ModInt((val % MOD as usize) as u32)\n    }\n}\n\n#[allow(dead_code)]\nimpl ModInt {\n    pub fn new(n: u32) -> ModInt {\n        ModInt(n % MOD)\n    }\n    pub fn zero() -> ModInt {\n        ModInt(0)\n    }\n    pub fn one() -> ModInt {\n        ModInt(1)\n    }\n    pub fn pow(self, mut n: u32) -> ModInt {\n        let mut t = ModInt::one();\n        let mut s = self;\n        while n > 0 {\n            if n & 1 == 1 {\n                t *= s;\n            }\n            s *= s;\n            n >>= 1;\n        }\n        t\n    }\n    pub fn inv(self) -> ModInt {\n        assert!(self.0 > 0);\n        self.pow(MOD - 2)\n    }\n}\n// ---------- end ModInt ----------\n\n// 解説読んだ\n// 大きいやつから貪欲 -> まあ明らか\n// これがGame DP と似てると気づく -> 不可能\n// Grundy 数で解ける -> Game DP だとわかれば理解できるが...\nfn run() {\n    let stdin = std::io::stdin();\n    let mut sc = scanner::Scanner::new(stdin.lock());\n    let n: usize = sc.next(b'\\n');\n    let rad = ModInt((1_000_000_000_000_000_000u64 % MOD as u64) as u32);\n    let mut pow = vec![ModInt::one(); n + 1];\n    for i in 1..(n + 1) {\n        pow[i] = pow[i - 1] * rad;\n    }\n    let mut memo = vec![];\n    for _ in 0..3 {\n        let m: usize = sc.next(b'\\n');\n        let mut deg = vec![0; n];\n        let mut e = Vec::with_capacity(m);\n        for _ in 0..m {\n            let a = sc.next::<usize>(b' ') - 1;\n            let b = sc.next::<usize>(b'\\n') - 1;\n            if a < b {\n                deg[a] += 1;\n                e.push((a, b));\n            } else {\n                deg[b] += 1;\n                e.push((b, a));\n            }\n        }\n        let mut g: Vec<_> = deg.into_iter().map(|d| Vec::with_capacity(d)).collect();\n        for (a, b) in e {\n            g[a].push(b);\n        }\n        let mut dp = vec![0; n];\n        let mut elem = vec![false; n];\n        for (v, g) in g.iter().enumerate().rev() {\n            for &u in g.iter() {\n                elem[dp[u]] = true;\n            }\n            dp[v] = elem.iter().position(|b| !*b).unwrap();\n            for &u in g.iter() {\n                elem[dp[u]] = false;\n            }\n        }\n        let w = *dp.iter().max().unwrap();\n        let mut sum = vec![ModInt::zero(); w + 1];\n        for (dp, &p) in dp.into_iter().zip(pow.iter().skip(1)) {\n            sum[dp] += p;\n        }\n        memo.push(sum);\n    }\n    let a = memo.pop().unwrap();\n    let b = memo.pop().unwrap();\n    let c = memo.pop().unwrap();\n    let mut ans = ModInt::zero();\n    for (i, &a) in a.iter().enumerate() {\n        for (j, &b) in b.iter().enumerate() {\n            ans += a * b * c.get(i ^ j).cloned().unwrap_or(ModInt::zero());\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  }
]