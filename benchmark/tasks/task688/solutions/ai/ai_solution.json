[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n#define MAX_N 100\n#define MAX_M 10000\n#define MAX_V 1000000\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nint N, M;\nEdge graphX[MAX_M], graphY[MAX_M], graphZ[MAX_M];\nint graph_w[MAX_V][3];\nint adj_w[MAX_V][MAX_V];\n\nlong long max_independent_set(int vertices) {\n    long long dp[MAX_V];\n    memset(dp, 0, sizeof(dp));\n    \n    dp[0] = 0;\n    for (int i = 1; i < vertices; i++) {\n        dp[i] = dp[i-1];\n        for (int j = 0; j < i; j++) {\n            if (adj_w[i][j] == 0) {\n                dp[i] = fmax(dp[i], dp[j] + graph_w[i][0] + graph_w[i][1] + graph_w[i][2]);\n            }\n        }\n        dp[i] %= MOD;\n    }\n    \n    return dp[vertices-1];\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &graphX[i].u, &graphX[i].v);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &graphY[i].u, &graphY[i].v);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &graphZ[i].u, &graphZ[i].v);\n    }\n    \n    int vertices = 0;\n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            for (int z = 0; z < N; z++) {\n                graph_w[vertices][0] = x;\n                graph_w[vertices][1] = y;\n                graph_w[vertices][2] = z;\n                vertices++;\n            }\n        }\n    }\n    \n    memset(adj_w, 0, sizeof(adj_w));\n    \n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < vertices; j++) {\n            for (int k = j + 1; k < vertices; k++) {\n                if ((graph_w[j][0] == graphX[i].u && graph_w[k][0] == graphX[i].v) ||\n                    (graph_w[j][0] == graphX[i].v && graph_w[k][0] == graphX[i].u) ||\n                    (graph_w[j][1] == graphY[i].u && graph_w[k][1] == graphY[i].v) ||\n                    (graph_w[j][1] == graphY[i].v && graph_w[k][1] == graphY[i].u) ||\n                    (graph_w[j][2] == graphZ[i].u && graph_w[k][2] == graphZ[i].v) ||\n                    (graph_w[j][2] == graphZ[i].v && graph_w[k][2] == graphZ[i].u)) {\n                    adj_w[j][k] = adj_w[k][j] = 1;\n                }\n            }\n        }\n    }\n    \n    long long result = max_independent_set(vertices);\n    printf(\"%lld\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:34:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 998244353\n#define MAXN 100\n\nint N, M;\nint adjX[MAXN][MAXN], adjY[MAXN][MAXN], adjZ[MAXN][MAXN];\nlong long dp[MAXN][MAXN][MAXN];\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    \n    memset(adjX, 0, sizeof(adjX));\n    memset(adjY, 0, sizeof(adjY));\n    memset(adjZ, 0, sizeof(adjZ));\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        adjX[u][v] = adjX[v][u] = 1;\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        adjY[u][v] = adjY[v][u] = 1;\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        adjZ[u][v] = adjZ[v][u] = 1;\n    }\n    \n    memset(dp, 0, sizeof(dp));\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                long long current = 1LL + i + j + k;\n                dp[i][j][k] = current;\n                \n                for (int prev_i = 0; prev_i < i; prev_i++) {\n                    if (!adjX[prev_i][i]) {\n                        dp[i][j][k] = max(dp[i][j][k], dp[prev_i][j][k] + current);\n                    }\n                }\n                \n                for (int prev_j = 0; prev_j < j; prev_j++) {\n                    if (!adjY[prev_j][j]) {\n                        dp[i][j][k] = max(dp[i][j][k], dp[i][prev_j][k] + current);\n                    }\n                }\n                \n                for (int prev_k = 0; prev_k < k; prev_k++) {\n                    if (!adjZ[prev_k][k]) {\n                        dp[i][j][k] = max(dp[i][j][k], dp[i][j][prev_k] + current);\n                    }\n                }\n            }\n        }\n    }\n    \n    long long result = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                if (dp[i][j][k] > result) {\n                    result = dp[i][j][k];\n                }\n            }\n        }\n    }\n    \n    printf(\"%lld\\n\", result % MOD);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:34:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<bool>> adjX(N, vector<bool>(N, false));\n    vector<vector<bool>> adjY(N, vector<bool>(N, false));\n    vector<vector<bool>> adjZ(N, vector<bool>(N, false));\n\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        adjX[u][v] = adjX[v][u] = true;\n    }\n\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        adjY[u][v] = adjY[v][u] = true;\n    }\n\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        adjZ[u][v] = adjZ[v][u] = true;\n    }\n\n    vector<vector<vector<long long>>> dp(N, vector<vector<long long>>(N, vector<long long>(N, 0)));\n    long long max_total = 0;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            for (int k = 0; k < N; ++k) {\n                long long current = 1;\n                bool can_add = true;\n\n                for (int x = 0; x < i; ++x) {\n                    if (adjX[x][i]) {\n                        can_add = false;\n                        break;\n                    }\n                }\n                if (!can_add) continue;\n\n                for (int y = 0; y < j; ++y) {\n                    if (adjY[y][j]) {\n                        can_add = false;\n                        break;\n                    }\n                }\n                if (!can_add) continue;\n\n                for (int z = 0; z < k; ++z) {\n                    if (adjZ[z][k]) {\n                        can_add = false;\n                        break;\n                    }\n                }\n                if (!can_add) continue;\n\n                long long max_prev = 0;\n                for (int x = 0; x < i; ++x) {\n                    for (int y = 0; y < j; ++y) {\n                        for (int z = 0; z < k; ++z) {\n                            if (!adjX[x][i] && !adjY[y][j] && !adjZ[z][k]) {\n                                if (dp[x][y][z] > max_prev) {\n                                    max_prev = dp[x][y][z];\n                                }\n                            }\n                        }\n                    }\n                }\n                dp[i][j][k] = max_prev + current;\n                if (dp[i][j][k] > max_total) {\n                    max_total = dp[i][j][k];\n                }\n            }\n        }\n    }\n\n    cout << max_total % MOD << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:35:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n\n        boolean[][] x = new boolean[N][N];\n        boolean[][] y = new boolean[N][N];\n        boolean[][] z = new boolean[N][N];\n\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken()) - 1;\n            int b = Integer.parseInt(st.nextToken()) - 1;\n            x[a][b] = x[b][a] = true;\n        }\n\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken()) - 1;\n            int b = Integer.parseInt(st.nextToken()) - 1;\n            y[a][b] = y[b][a] = true;\n        }\n\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken()) - 1;\n            int b = Integer.parseInt(st.nextToken()) - 1;\n            z[a][b] = z[b][a] = true;\n        }\n\n        long[][][] dp = new long[N][N][N];\n        long res = 0;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int k = 0; k < N; k++) {\n                    long max = 0;\n                    if (i > 0) max = Math.max(max, dp[i-1][j][k]);\n                    if (j > 0) max = Math.max(max, dp[i][j-1][k]);\n                    if (k > 0) max = Math.max(max, dp[i][j][k-1]);\n                    if (i > 0 && j > 0) max = Math.max(max, dp[i-1][j-1][k]);\n                    if (i > 0 && k > 0) max = Math.max(max, dp[i-1][j][k-1]);\n                    if (j > 0 && k > 0) max = Math.max(max, dp[i][j-1][k-1]);\n                    if (i > 0 && j > 0 && k > 0) max = Math.max(max, dp[i-1][j-1][k-1]);\n\n                    boolean canAdd = true;\n                    for (int l = 0; l < i; l++) {\n                        if (x[l][i] && dp[l][j][k] > 0) {\n                            canAdd = false;\n                            break;\n                        }\n                    }\n                    if (!canAdd) {\n                        dp[i][j][k] = max;\n                        continue;\n                    }\n                    for (int l = 0; l < j; l++) {\n                        if (y[l][j] && dp[i][l][k] > 0) {\n                            canAdd = false;\n                            break;\n                        }\n                    }\n                    if (!canAdd) {\n                        dp[i][j][k] = max;\n                        continue;\n                    }\n                    for (int l = 0; l < k; l++) {\n                        if (z[l][k] && dp[i][j][l] > 0) {\n                            canAdd = false;\n                            break;\n                        }\n                    }\n                    if (canAdd) {\n                        dp[i][j][k] = max + 1;\n                    } else {\n                        dp[i][j][k] = max;\n                    }\n                    res = Math.max(res, dp[i][j][k]);\n                }\n            }\n        }\n\n        System.out.println(res % MOD);\n    }\n}",
    "timestamp": "2025-08-05 22:35:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class GraphVertexWeightIndependentSet {\n    static final int MOD = 998244353;\n    static int N, M;\n    static List<List<Integer>> graphX, graphY, graphZ;\n    static long[][] weights;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        \n        graphX = new ArrayList<>(N);\n        graphY = new ArrayList<>(N);\n        graphZ = new ArrayList<>(N);\n        \n        for (int i = 0; i < N; i++) {\n            graphX.add(new ArrayList<>());\n            graphY.add(new ArrayList<>());\n            graphZ.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken()) - 1;\n            int v = Integer.parseInt(st.nextToken()) - 1;\n            graphX.get(u).add(v);\n            graphX.get(v).add(u);\n        }\n        \n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken()) - 1;\n            int v = Integer.parseInt(st.nextToken()) - 1;\n            graphY.get(u).add(v);\n            graphY.get(v).add(u);\n        }\n        \n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken()) - 1;\n            int v = Integer.parseInt(st.nextToken()) - 1;\n            graphZ.get(u).add(v);\n            graphZ.get(v).add(u);\n        }\n        \n        weights = new long[N][N][N];\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                for (int z = 0; z < N; z++) {\n                    weights[x][y][z] = (long)x * y * z;\n                }\n            }\n        }\n        \n        long maxIndependentSetWeight = findMaxIndependentSetWeight();\n        System.out.println(maxIndependentSetWeight % MOD);\n    }\n    \n    static long findMaxIndependentSetWeight() {\n        long[][] dp = new long[2][1 << N];\n        \n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                for (int z = 0; z < N; z++) {\n                    int curr = 0, next = 1;\n                    dp[curr][0] = 0;\n                    \n                    for (int vx = 0; vx < N; vx++) {\n                        Arrays.fill(dp[next], 0);\n                        \n                        for (int mask = 0; mask < (1 << N); mask++) {\n                            dp[next][mask] = Math.max(dp[next][mask], dp[curr][mask]);\n                            \n                            if ((mask & (1 << vx)) == 0) {\n                                boolean canAdd = true;\n                                \n                                for (int nx : graphX.get(vx)) {\n                                    if ((mask & (1 << nx)) != 0) {\n                                        canAdd = false;\n                                        break;\n                                    }\n                                }\n                                \n                                for (int ny : graphY.get(y)) {\n                                    if ((mask & (1 << ny)) != 0) {\n                                        canAdd = false;\n                                        break;\n                                    }\n                                }\n                                \n                                for (int nz : graphZ.get(z)) {\n                                    if ((mask & (1 << nz)) != 0) {\n                                        canAdd = false;\n                                        break;\n                                    }\n                                }\n                                \n                                if (canAdd) {\n                                    dp[next][mask | (1 << vx)] = Math.max(\n                                        dp[next][mask | (1 << vx)],\n                                        dp[curr][mask] + weights[vx][y][z]\n                                    );\n                                }\n                            }\n                        }\n                        \n                        long temp = curr;\n                        curr = next;\n                        next = (int)temp;\n                    }\n                }\n            }\n        }\n        \n        long maxWeight = 0;\n        for (int mask = 0; mask < (1 << N); mask++) {\n            maxWeight = Math.max(maxWeight, dp[curr][mask]);\n        }\n        \n        return maxWeight;\n    }\n}",
    "timestamp": "2025-08-05 22:36:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MAXN = 50;\n\nvector<pair<int, int>> edgesX, edgesY, edgesZ;\nint N, M;\nlong long weight[MAXN * MAXN * MAXN];\n\nbool isIndependent(int u, int v) {\n    int x1 = u / (N * N), y1 = (u / N) % N, z1 = u % N;\n    int x2 = v / (N * N), y2 = (v / N) % N, z2 = v % N;\n    \n    return x1 != x2 && y1 != y2 && z1 != z2;\n}\n\nlong long maxIndependentSet() {\n    int V = N * N * N;\n    vector<long long> dp(1 << 20, 0);\n    \n    for (int mask = 0; mask < (1 << 20); mask++) {\n        for (int v = 0; v < V; v++) {\n            bool valid = true;\n            for (int u = 0; u < v; u++) {\n                if ((mask & (1 << u)) && !isIndependent(u, v)) {\n                    valid = false;\n                    break;\n                }\n            }\n            \n            if (valid) {\n                dp[mask | (1 << v)] = max(dp[mask | (1 << v)], dp[mask] + weight[v]);\n            }\n        }\n    }\n    \n    long long maxWeight = 0;\n    for (int mask = 0; mask < (1 << 20); mask++) {\n        maxWeight = max(maxWeight, dp[mask]);\n    }\n    \n    return maxWeight % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    cin >> N >> M;\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        edgesX.emplace_back(u-1, v-1);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        edgesY.emplace_back(u-1, v-1);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        edgesZ.emplace_back(u-1, v-1);\n    }\n    \n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            for (int z = 0; z < N; z++) {\n                int v = x * N * N + y * N + z;\n                weight[v] = (x + 1) * (y + 1) * (z + 1);\n            }\n        }\n    }\n    \n    cout << maxIndependentSet() << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:36:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 998244353\n\ndef max_independent_set_weight(N, M, X_edges, Y_edges, Z_edges):\n    # Graph adjacency matrices\n    X_adj = [[False] * N for _ in range(N)]\n    Y_adj = [[False] * N for _ in range(N)]\n    Z_adj = [[False] * N for _ in range(N)]\n\n    # Fill adjacency matrices\n    for u, v in X_edges:\n        X_adj[u][v] = X_adj[v][u] = True\n    for u, v in Y_edges:\n        Y_adj[u][v] = Y_adj[v][u] = True\n    for u, v in Z_edges:\n        Z_adj[u][v] = Z_adj[v][u] = True\n    \n    # Generate graph W with N^3 vertices\n    vertex_weight = [[[i + j + k for k in range(N)] for j in range(N)] for i in range(N)]\n    \n    # A dp array to compute the maximum independent set weight\n    dp = [[[0] * (1 << N) for _ in range(N)] for _ in range(N)]\n    \n    # Dynamic programming to find maximum weight of independent set\n    for x in range(N):\n        for y in range(N):\n            for z_mask in range(1 << N):\n                # Check if (x, y, z) is an independent set\n                independent = True\n                for i in range(N):\n                    if z_mask & (1 << i):\n                        for j in range(N):\n                            if z_mask & (1 << j):\n                                if (i != j and (Z_adj[i][j] or X_adj[x][x] or Y_adj[y][y] or X_adj[x][y] or X_adj[y][x] or \n                                                Y_adj[x][y] or Y_adj[y][x])):\n                                    independent = False\n                                    break\n                        if not independent:\n                            break\n                \n                if not independent:\n                    continue\n                \n                # Calculate weight for current configuration\n                weight = sum(vertex_weight[x][y][i] for i in range(N) if z_mask & (1 << i))\n                \n                # Update dp with the maximum weight for configuration (x, y, z_mask)\n                dp[x][y][z_mask] = max(dp[x][y][z_mask], weight)\n                \n                # Traverse all neighbors\n                for xx in range(N):\n                    if not X_adj[x][xx]:\n                        continue\n                    for yy in range(N):\n                        if not Y_adj[y][yy]:\n                            continue\n                        for zz in range(1 << N):\n                            if not (z_mask & zz == 0):\n                                continue\n                            dp[xx][yy][zz | z_mask] = max(dp[xx][yy][zz | z_mask], dp[x][y][z_mask] + dp[xx][yy][zz])\n\n    # Return the max value found in dp modulo MOD\n    result = 0\n    for x in range(N):\n        for y in range(N):\n            for z_mask in range(1 << N):\n                result = max(result, dp[x][y][z_mask])\n    \n    return result % MOD\n\n# Example usage:\n# N, M, X_edges, Y_edges, Z_edges should be defined here\n# print(max_independent_set_weight(N, M, X_edges, Y_edges, Z_edges))",
    "timestamp": "2025-08-13 11:28:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphConstruction {\n    \n    public static final int MODULO = 998244353;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        \n        boolean[][] graphX = new boolean[N][N];\n        boolean[][] graphY = new boolean[N][N];\n        boolean[][] graphZ = new boolean[N][N];\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            graphX[u][v] = graphX[v][u] = true;\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            graphY[u][v] = graphY[v][u] = true;\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            graphZ[u][v] = graphZ[v][u] = true;\n        }\n        \n        Map<Integer, Integer> vertexWeights = new HashMap<>();\n        int[][][] W = new int[N][N][N];\n        \n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                for (int z = 0; z < N; z++) {\n                    int weight = x + y + z;\n                    W[x][y][z] = weight;\n                    int mappedVertex = x * N * N + y * N + z;\n                    vertexWeights.put(mappedVertex, weight);\n                }\n            }\n        }\n        \n        List<List<Integer>> adjacencyListW = new ArrayList<>(N * N * N);\n        \n        for (int i = 0; i < N * N * N; i++) {\n            adjacencyListW.add(new ArrayList<>());\n        }\n        \n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                for (int z = 0; z < N; z++) {\n                    int vertexW = x * N * N + y * N + z;\n                    \n                    for (int nx = 0; nx < N; nx++) {\n                        if (graphX[x][nx]) {\n                            int neighborW = nx * N * N + y * N + z;\n                            adjacencyListW.get(vertexW).add(neighborW);\n                        }\n                    }\n                    \n                    for (int ny = 0; ny < N; ny++) {\n                        if (graphY[y][ny]) {\n                            int neighborW = x * N * N + ny * N + z;\n                            adjacencyListW.get(vertexW).add(neighborW);\n                        }\n                    }\n                    \n                    for (int nz = 0; nz < N; nz++) {\n                        if (graphZ[z][nz]) {\n                            int neighborW = x * N * N + y * N + nz;\n                            adjacencyListW.get(vertexW).add(neighborW);\n                        }\n                    }\n                }\n            }\n        }\n        \n        int maxWeight = 0;\n        \n        boolean[] visited = new boolean[N * N * N];\n        \n        for (int i = 0; i < N * N * N; i++) {\n            if (!visited[i]) {\n                maxWeight += dfsFindIndependentSet(i, adjacencyListW, vertexWeights, visited);\n                maxWeight %= MODULO;\n            }\n        }\n        \n        System.out.println(maxWeight);\n    }\n    \n    private static int dfsFindIndependentSet(int node, List<List<Integer>> adjacencyListW, Map<Integer, Integer> vertexWeights, boolean[] visited) {\n        Stack<Integer> stack = new Stack<>();\n        stack.push(node);\n        \n        int totalWeight = 0;\n        \n        while (!stack.isEmpty()) {\n            int current = stack.pop();\n            \n            if (!visited[current]) {\n                visited[current] = true;\n                totalWeight += vertexWeights.get(current);\n                totalWeight %= MODULO;\n\n                for (int neighbor : adjacencyListW.get(current)) {\n                    if (!visited[neighbor]) {\n                        stack.push(neighbor);\n                    }\n                }\n            }\n        }\n        \n        return totalWeight;\n    }\n}",
    "timestamp": "2025-08-13 11:28:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MOD 998244353\n\ntypedef struct {\n    int u, v;\n} Edge;\n\ntypedef struct {\n    int neighbors;\n    int *adj;\n} Graph;\n\nGraph createGraph(int n, int m, Edge *edges) {\n    Graph g;\n    g.neighbors = n;\n    g.adj = calloc(n, sizeof(int));\n    for (int i = 0; i < m; ++i) {\n        g.adj[edges[i].u] |= (1 << edges[i].v);\n        g.adj[edges[i].v] |= (1 << edges[i].u);\n    }\n    return g;\n}\n\nint maxIndependentSetWeight(int Nx, int Ny, int Nz, Graph xGraph, Graph yGraph, Graph zGraph) {\n    int N = Nx * Ny * Nz;\n    long long *dp = calloc(N, sizeof(long long));\n \n    int maxWeight = 0;\n    \n    for (int i = 0; i < Nx; ++i) {\n        for (int j = 0; j < Ny; ++j) {\n            for (int k = 0; k < Nz; ++k) {\n                int idx = i * Ny * Nz + j * Nz + k;\n                int weight = i + j + k + 3;\n                \n                dp[idx] = weight;\n                \n                for (int x = 0; x < Nx; ++x) {\n                    if (xGraph.adj[i] & (1 << x)) continue;\n                    for (int y = 0; y < Ny; ++y) {\n                        if (yGraph.adj[j] & (1 << y)) continue;\n                        for (int z = 0; z < Nz; ++z) {\n                            if (zGraph.adj[k] & (1 << z)) continue;\n                            \n                            int prevIdx = x * Ny * Nz + y * Nz + z;\n                            dp[idx] = (dp[idx] > dp[prevIdx] + weight ? dp[idx] : dp[prevIdx] + weight);\n                        }\n                    }\n                }\n                \n                if (dp[idx] > maxWeight) maxWeight = dp[idx];\n            }\n        }\n    }\n    \n    free(dp);\n    \n    return maxWeight % MOD;\n}\n\nint main() {\n    int N, M;\n    Edge xEdges[50], yEdges[50], zEdges[50];\n    \n    scanf(\"%d %d\", &N, &M);\n    \n    for (int i = 0; i < M; ++i) scanf(\"%d %d\", &xEdges[i].u, &xEdges[i].v);\n    for (int i = 0; i < M; ++i) scanf(\"%d %d\", &yEdges[i].u, &yEdges[i].v);\n    for (int i = 0; i < M; ++i) scanf(\"%d %d\", &zEdges[i].u, &zEdges[i].v);\n    \n    Graph xGraph = createGraph(N, M, xEdges);\n    Graph yGraph = createGraph(N, M, yEdges);\n    Graph zGraph = createGraph(N, M, zEdges);\n    \n    int result = maxIndependentSetWeight(N, N, N, xGraph, yGraph, zGraph);\n    printf(\"%d\\n\", result);\n    \n    free(xGraph.adj);\n    free(yGraph.adj);\n    free(zGraph.adj);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:28:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction maxIndependentSetWeight(XEdges, YEdges, ZEdges, N, vertexWeights) {\n    const DP = Array(N).fill(null).map(() => \n                Array(N).fill(null).map(() => Array(N).fill(0)));\n    \n    const markEdges = (edges, markList) => {\n        for (let [u, v] of edges) {\n            markList[u][v] = markList[v][u] = true;\n        }\n    };\n\n    let Xadj = Array.from(Array(N), () => Array(N).fill(false));\n    let Yadj = Array.from(Array(N), () => Array(N).fill(false));\n    let Zadj = Array.from(Array(N), () => Array(N).fill(false));\n\n    markEdges(XEdges, Xadj);\n    markEdges(YEdges, Yadj);\n    markEdges(ZEdges, Zadj);\n\n    let result = 0;\n\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            for (let k = 0; k < N; k++) {\n                DP[i][j][k] = vertexWeights[i][j][k];\n                for (let ii = 0; ii < N; ii++) {\n                    if (Xadj[i][ii]) continue;\n                    for (let jj = 0; jj < N; jj++) {\n                        if (Yadj[j][jj]) continue;\n                        for (let kk = 0; kk < N; kk++) {\n                            if (Zadj[k][kk]) continue;\n                            DP[i][j][k] = Math.max(DP[i][j][k], DP[ii][jj][kk] + vertexWeights[i][j][k]);\n                        }\n                    }\n                }\n                result = Math.max(result, DP[i][j][k]);\n            }\n        }\n    }\n\n    return result % MOD;\n}\n\n// Example usage:\n// const XEdges = [[0, 1], [1, 2]];\n// const YEdges = [[0, 1]];\n// const ZEdges = [[1, 2]];\n// const N = 3;\n// const vertexWeights = Array.from({ length: N }, (_, i) =>\n//     Array.from({ length: N }, (_, j) =>\n//         Array.from({ length: N }, (_, k) => (i + 1) * (j + 1) * (k + 1))\n//     )\n// );\n\n// console.log(maxIndependentSetWeight(XEdges, YEdges, ZEdges, N, vertexWeights));",
    "timestamp": "2025-08-13 11:29:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(X, Y, Z, N, M):\n    MOD = 998244353\n    \n    # Create adjacency lists for graphs X, Y, Z\n    graph_X = [[] for _ in range(N)]\n    graph_Y = [[] for _ in range(N)]\n    graph_Z = [[] for _ in range(N)]\n    \n    # Populate graphs\n    for u, v in X:\n        graph_X[u].append(v)\n        graph_X[v].append(u)\n    \n    for u, v in Y:\n        graph_Y[u].append(v)\n        graph_Y[v].append(u)\n    \n    for u, v in Z:\n        graph_Z[u].append(v)\n        graph_Z[v].append(u)\n    \n    # Create weight matrix for graph W\n    weights = [[[0 for _ in range(N)] for _ in range(N)] for _ in range(N)]\n    \n    # Calculate weights for each vertex in W\n    for x in range(N):\n        for y in range(N):\n            for z in range(N):\n                weights[x][y][z] = x + y + z\n    \n    # Create conflict graph for W\n    conflicts = [[[False for _ in range(N)] for _ in range(N)] for _ in range(N)]\n    \n    # Add conflicts based on original graphs\n    for x1 in range(N):\n        for x2 in range(N):\n            if x1 in graph_X[x2]:\n                for y in range(N):\n                    for z in range(N):\n                        conflicts[x1][y][z] = True\n                        conflicts[x2][y][z] = True\n    \n    for y1 in range(N):\n        for y2 in range(N):\n            if y1 in graph_Y[y2]:\n                for x in range(N):\n                    for z in range(N):\n                        conflicts[x][y1][z] = True\n                        conflicts[x][y2][z] = True\n    \n    for z1 in range(N):\n        for z2 in range(N):\n            if z1 in graph_Z[z2]:\n                for x in range(N):\n                    for y in range(N):\n                        conflicts[x][y][z1] = True\n                        conflicts[x][y][z2] = True\n    \n    # Maximum independent set solver using dynamic programming\n    @lru_cache(None)\n    def max_independent_set(x, y, z):\n        if x == N or y == N or z == N:\n            return 0\n        \n        # Skip current vertex\n        skip = max_independent_set(x+1, y, z)\n        \n        # Take current vertex if possible\n        take = 0\n        if not conflicts[x][y][z]:\n            take = weights[x][y][z] + max_independent_set(x+1, y+1, z+1)\n        \n        return max(skip, take)\n    \n    # Solve and return result\n    result = max_independent_set(0, 0, 0)\n    return result % MOD\n\n# Example usage and input parsing can be added as needed",
    "timestamp": "2025-08-13 11:29:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, M, graphX, graphY, graphZ) {\n    const MOD = 998244353n;\n    const W = new Array(N * N * N).fill(0n);\n    const edges = new Array(N * N * N).fill(false);\n\n    // Calculate vertex weights\n    for (let x = 0; x < N; x++) {\n        for (let y = 0; y < N; y++) {\n            for (let z = 0; z < N; z++) {\n                let idx = x * N * N + y * N + z;\n                W[idx] = BigInt(x * x + y * y + z * z);\n            }\n        }\n    }\n\n    // Add edges from original graphs\n    const addEdges = (graph) => {\n        for (let [u, v] of graph) {\n            for (let x = 0; x < N; x++) {\n                for (let y = 0; y < N; y++) {\n                    for (let z = 0; z < N; z++) {\n                        let idxU = u * N * N + x * N + y;\n                        let idxV = v * N * N + x * N + y;\n                        edges[idxU] = true;\n                        edges[idxV] = true;\n                    }\n                }\n            }\n        }\n    };\n\n    addEdges(graphX);\n    addEdges(graphY);\n    addEdges(graphZ);\n\n    // Independent set algorithm (greedy with random order)\n    let totalWeight = 0n;\n    let order = Array.from({length: N * N * N}, (_, i) => i);\n    order.sort(() => Math.random() - 0.5);\n\n    for (let idx of order) {\n        if (!edges[idx]) {\n            totalWeight += W[idx];\n            // Mark adjacent vertices\n            for (let j = 0; j < N * N * N; j++) {\n                if (Math.abs(idx - j) <= N * N) {\n                    edges[j] = true;\n                }\n            }\n        }\n    }\n\n    return Number(totalWeight % MOD);\n}",
    "timestamp": "2025-08-13 11:29:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 998244353\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    \n    # Read graph X\n    X_adj = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        X_adj[u].append(v)\n        X_adj[v].append(u)\n    \n    # Read graph Y\n    Y_adj = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        Y_adj[u].append(v)\n        Y_adj[v].append(u)\n    \n    # Read graph Z\n    Z_adj = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        Z_adj[u].append(v)\n        Z_adj[v].append(u)\n    \n    # Weights for each vertex (i, j, k) is (i+1)*(j+1)*(k+1)\n    # We need to find maximum weight independent set in W\n    \n    # The graph W is a tensor product of X, Y, Z. An independent set in W corresponds to\n    # a set where for any two vertices (i1,j1,k1) and (i2,j2,k2), at least two of the following hold:\n    # i1 and i2 are not adjacent in X, j1 and j2 are not adjacent in Y, k1 and k2 are not adjacent in Z.\n    # The maximum weight independent set can be found by taking the maximum over all possible combinations\n    # of independent sets in X, Y, Z and multiplying their weights.\n    \n    # Precompute the maximum weight independent set for X, Y, Z independently\n    # Using dynamic programming with bitmask for small N (N <= 20)\n    \n    def max_independent_set(adj, N):\n        # Precompute for all subsets S, whether S is independent\n        is_independent = [True] * (1 << N)\n        for mask in range(1 << N):\n            ok = True\n            for u in range(N):\n                if not (mask & (1 << u)):\n                    continue\n                for v in adj[u]:\n                    if u < v and (mask & (1 << v)):\n                        ok = False\n                        break\n                if not ok:\n                    break\n            is_independent[mask] = ok\n        \n        # DP[mask] = max weight for mask\n        dp = [0] * (1 << N)\n        for mask in range(1 << N):\n            if not is_independent[mask]:\n                continue\n            # The weight is sum of (u+1) for u in mask\n            weight = 0\n            for u in range(N):\n                if mask & (1 << u):\n                    weight += (u + 1)\n            dp[mask] = weight\n        \n        # Now take max over all masks\n        max_total = 0\n        for mask in range(1 << N):\n            if dp[mask] > max_total:\n                max_total = dp[mask]\n        return max_total\n    \n    max_X = max_independent_set(X_adj, N)\n    max_Y = max_independent_set(Y_adj, N)\n    max_Z = max_independent_set(Z_adj, N)\n    \n    total = (max_X * max_Y) % MOD\n    total = (total * max_Z) % MOD\n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 11:29:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    let ptr = 0;\n    const [N, M] = input[ptr++].split(' ').map(Number);\n    \n    const adjX = Array.from({ length: N }, () => new Set());\n    const adjY = Array.from({ length: N }, () => new Set());\n    const adjZ = Array.from({ length: N }, () => new Set());\n    \n    for (let i = 0; i < M; i++) {\n        const [a, b] = input[ptr++].split(' ').map(Number);\n        adjX[a - 1].add(b - 1);\n        adjX[b - 1].add(a - 1);\n    }\n    for (let i = 0; i < M; i++) {\n        const [a, b] = input[ptr++].split(' ').map(Number);\n        adjY[a - 1].add(b - 1);\n        adjY[b - 1].add(a - 1);\n    }\n    for (let i = 0; i < M; i++) {\n        const [a, b] = input[ptr++].split(' ').map(Number);\n        adjZ[a - 1].add(b - 1);\n        adjZ[b - 1].add(a - 1);\n    }\n    \n    const w = Array.from({ length: N }, () => \n        Array.from({ length: N }, () => \n            Array.from({ length: N }, () => 0)));\n    \n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            for (let k = 0; k < N; k++) {\n                w[i][j][k] = 1 + i + j + k;\n            }\n        }\n    }\n    \n    const dp = Array.from({ length: N }, () => \n        Array.from({ length: N }, () => \n            Array.from({ length: N }, () => 0)));\n    \n    const q = [];\n    const inQueue = Array.from({ length: N }, () => \n        Array.from({ length: N }, () => \n            Array.from({ length: N }, () => false)));\n    \n    let maxTotal = 0;\n    \n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            for (let k = 0; k < N; k++) {\n                dp[i][j][k] = w[i][j][k];\n                q.push([i, j, k]);\n                inQueue[i][j][k] = true;\n                if (dp[i][j][k] > maxTotal) {\n                    maxTotal = dp[i][j][k];\n                }\n            }\n        }\n    }\n    \n    const directions = [];\n    for (const a of adjX) {\n        for (const b of a) {\n            directions.push([b, 0, 0]);\n        }\n        break;\n    }\n    for (const a of adjY) {\n        for (const b of a) {\n            directions.push([0, b, 0]);\n        }\n        break;\n    }\n    for (const a of adjZ) {\n        for (const b of a) {\n            directions.push([0, 0, b]);\n        }\n        break;\n    }\n    \n    while (q.length > 0) {\n        const [i, j, k] = q.shift();\n        inQueue[i][j][k] = false;\n        \n        for (const [di, dj, dk] of directions) {\n            const ni = i + di;\n            const nj = j + dj;\n            const nk = k + dk;\n            if (ni >= 0 && ni < N && nj >= 0 && nj < N && nk >= 0 && nk < N) {\n                if (dp[ni][nj][nk] < dp[i][j][k] + w[ni][nj][nk]) {\n                    dp[ni][nj][nk] = dp[i][j][k] + w[ni][nj][nk];\n                    if (dp[ni][nj][nk] > maxTotal) {\n                        maxTotal = dp[ni][nj][nk];\n                    }\n                    if (!inQueue[ni][nj][nk]) {\n                        q.push([ni, nj, nk]);\n                        inQueue[ni][nj][nk] = true;\n                    }\n                }\n            }\n        }\n    }\n    \n    console.log(maxTotal % MOD);\n}\n\nsolve();",
    "timestamp": "2025-08-13 11:30:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\n\nstruct Graph {\n    int N, M;\n    vector<vector<int>> adj;\n\n    Graph(int n, int m) : N(n), M(m), adj(n) {}\n\n    void add_edge(int u, int v) {\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n};\n\nint max_weight_independent_set(const vector<vector<int>>& edges, int N3) {\n    vector<int> dp(1 << N3, 0);\n    vector<int> forbidden(1 << N3, 0);\n\n    for (const auto& edge : edges) {\n        for (int mask = 0; mask < (1 << N3); ++mask) {\n            if ((mask & (1 << edge[0])) && (mask & (1 << edge[1]))) {\n                forbidden[mask] = 1;\n            }\n        }\n    }\n\n    int max_weight = 0;\n    for (int mask = 0; mask < (1 << N3); ++mask) {\n        if (forbidden[mask]) continue;\n        int weight = 0;\n        for (int i = 0; i < N3; ++i) {\n            if (mask & (1 << i)) {\n                weight += i + 1;\n            }\n        }\n        max_weight = max(max_weight, weight);\n\n        for (const auto& edge : edges) {\n            if ((mask & (1 << edge[0])) == 0) {\n                dp[mask | (1 << edge[0])] =\n                    max(dp[mask | (1 << edge[0])], dp[mask] + edge[0] + 1);\n            }\n            if ((mask & (1 << edge[1])) == 0) {\n                dp[mask | (1 << edge[1])] =\n                    max(dp[mask | (1 << edge[1])], dp[mask] + edge[1] + 1);\n            }\n        }\n    }\n\n    return max_weight;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    Graph X(N, M), Y(N, M), Z(N, M);\n\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        X.add_edge(u, v);\n    }\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        Y.add_edge(u, v);\n    }\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        Z.add_edge(u, v);\n    }\n\n    int N3 = N * N * N;\n    vector<vector<int>> edges;\n    for (int u = 0; u < N; ++u) {\n        for (int v : X.adj[u]) {\n            for (int py = 0; py < N; ++py) {\n                for (int pz = 0; pz < N; ++pz) {\n                    int idx1 = u * N * N + py * N + pz;\n                    int idx2 = v * N * N + py * N + pz;\n                    edges.push_back({idx1, idx2});\n                }\n            }\n        }\n    }\n    for (int py = 0; py < N; ++py) {\n        for (int qy : Y.adj[py]) {\n            for (int u = 0; u < N; ++u) {\n                for (int pz = 0; pz < N; ++pz) {\n                    int idx1 = u * N * N + py * N + pz;\n                    int idx2 = u * N * N + qy * N + pz;\n                    edges.push_back({idx1, idx2});\n                }\n            }\n        }\n    }\n    for (int pz = 0; pz < N; ++pz) {\n        for (int qz : Z.adj[pz]) {\n            for (int u = 0; u < N; ++u) {\n                for (int py = 0; py < N; ++py) {\n                    int idx1 = u * N * N + py * N + pz;\n                    int idx2 = u * N * N + py * N + qz;\n                    edges.push_back({idx1, idx2});\n                }\n            }\n        }\n    }\n\n    cout << max_weight_independent_set(edges, N3) % MOD << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 12:04:03"
  }
]