[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int ball;\n    int weight;\n} Box;\n\nint find_min_cost(int N, int M, int K, int* operations, int* weights) {\n    Box* boxes = (Box*)malloc(M * sizeof(Box));\n    for (int i = 0; i < M; i++) {\n        boxes[i].ball = -1;\n        boxes[i].weight = 0;\n    }\n\n    int total_cost = 0;\n\n    for (int i = 0; i < K; i++) {\n        int ball = operations[i];\n        int found = -1;\n\n        for (int j = 0; j < M; j++) {\n            if (boxes[j].ball == ball) {\n                found = j;\n                break;\n            }\n        }\n\n        if (found != -1) {\n            continue;\n        }\n\n        int min_weight = INT_MAX;\n        int replace_idx = 0;\n\n        for (int j = 0; j < M; j++) {\n            if (boxes[j].weight < min_weight) {\n                min_weight = boxes[j].weight;\n                replace_idx = j;\n            }\n        }\n\n        total_cost += weights[ball - 1];\n        boxes[replace_idx].ball = ball;\n        boxes[replace_idx].weight = weights[ball - 1];\n    }\n\n    free(boxes);\n    return total_cost;\n}\n\nint main() {\n    int N, M, K;\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    int* weights = (int*)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &weights[i]);\n    }\n\n    int* operations = (int*)malloc(K * sizeof(int));\n    for (int i = 0; i < K; i++) {\n        scanf(\"%d\", &operations[i]);\n    }\n\n    int result = find_min_cost(N, M, K, operations, weights);\n    printf(\"%d\\n\", result);\n\n    free(weights);\n    free(operations);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Ball {\n    int id;\n    int weight;\n    int next_use;\n};\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    \n    vector<int> weights(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        cin >> weights[i];\n    }\n    \n    vector<int> operations(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> operations[i];\n    }\n    \n    unordered_map<int, vector<int>> positions;\n    for (int i = 0; i < K; ++i) {\n        positions[operations[i]].push_back(i);\n    }\n    \n    vector<Ball> balls;\n    for (int i = 0; i < K; ++i) {\n        int ball_id = operations[i];\n        auto& pos_list = positions[ball_id];\n        auto it = upper_bound(pos_list.begin(), pos_list.end(), i);\n        int next_use = (it != pos_list.end()) ? *it : K;\n        balls.push_back({ball_id, weights[ball_id], next_use});\n    }\n    \n    set<pair<int, int>> cache; // {next_use, ball_id}\n    unordered_map<int, set<pair<int, int>>::iterator> cache_map;\n    int total_cost = 0;\n    \n    for (int i = 0; i < K; ++i) {\n        int ball_id = balls[i].id;\n        int next_use = balls[i].next_use;\n        \n        if (cache_map.find(ball_id) != cache_map.end()) {\n            cache.erase(cache_map[ball_id]);\n            cache_map.erase(ball_id);\n        } else {\n            if (cache.size() == M) {\n                auto last = prev(cache.end());\n                int evicted_id = last->second;\n                cache.erase(last);\n                cache_map.erase(evicted_id);\n            }\n            total_cost += balls[i].weight;\n        }\n        \n        auto it = cache.insert({next_use, ball_id}).first;\n        cache_map[ball_id] = it;\n    }\n    \n    cout << total_cost << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:19:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CacheStrategy {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n        \n        int[] weights = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n            weights[i] = scanner.nextInt();\n        }\n        \n        int[] operations = new int[K];\n        for (int i = 0; i < K; i++) {\n            operations[i] = scanner.nextInt();\n        }\n        \n        int totalCost = 0;\n        Set<Integer> cache = new HashSet<>();\n        \n        for (int i = 0; i < K; i++) {\n            int ball = operations[i];\n            if (cache.contains(ball)) {\n                continue;\n            }\n            \n            totalCost += weights[ball];\n            \n            if (cache.size() >= M) {\n                int farthest = -1;\n                int toRemove = -1;\n                for (int b : cache) {\n                    int nextPos = -1;\n                    for (int j = i + 1; j < K; j++) {\n                        if (operations[j] == b) {\n                            nextPos = j;\n                            break;\n                        }\n                    }\n                    if (nextPos == -1) {\n                        toRemove = b;\n                        break;\n                    } else if (nextPos > farthest) {\n                        farthest = nextPos;\n                        toRemove = b;\n                    }\n                }\n                cache.remove(toRemove);\n            }\n            cache.add(ball);\n        }\n        \n        System.out.println(totalCost);\n    }\n}",
    "timestamp": "2025-08-05 21:19:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CacheStrategyOptimizer {\n    public static int minimizeCacheCost(int M, int N, int[] weights, int[] operations) {\n        int[] currentCache = new int[M];\n        Arrays.fill(currentCache, -1);\n        \n        Map<Integer, Integer> ballWeights = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            ballWeights.put(i + 1, weights[i]);\n        }\n        \n        int totalCost = 0;\n        \n        for (int operation : operations) {\n            int ballToCache = operation;\n            \n            // Check if ball is already in cache\n            boolean inCache = false;\n            for (int i = 0; i < M; i++) {\n                if (currentCache[i] == ballToCache) {\n                    inCache = true;\n                    break;\n                }\n            }\n            \n            if (!inCache) {\n                // Find least used or empty box\n                int replaceIndex = findReplacementIndex(currentCache);\n                \n                // Compute cost of reading\n                totalCost += ballWeights.get(ballToCache);\n                \n                // Update cache\n                currentCache[replaceIndex] = ballToCache;\n            }\n        }\n        \n        return totalCost;\n    }\n    \n    private static int findReplacementIndex(int[] cache) {\n        for (int i = 0; i < cache.length; i++) {\n            if (cache[i] == -1) {\n                return i;\n            }\n        }\n        return 0; // Default to first box if no empty box\n    }\n    \n    public static void main(String[] args) {\n        int M = 3; // Number of cache boxes\n        int N = 5; // Number of balls\n        int[] weights = {2, 3, 1, 4, 5}; // Weights of balls\n        int[] operations = {1, 2, 3, 4, 5, 1, 2}; // Sequence of ball placements\n        \n        int minimumCost = minimizeCacheCost(M, N, weights, operations);\n        System.out.println(\"Minimum Cache Cost: \" + minimumCost);\n    }\n}",
    "timestamp": "2025-08-05 21:19:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_M 100\n#define MAX_N 1000\n#define MAX_K 10000\n\nint ballWeights[MAX_N + 1];\nint sequence[MAX_K];\nint cache[MAX_M];\nint cacheTime[MAX_M];\n\nint minimumCost(int M, int N, int K) {\n    int totalCost = 0;\n    int currentTime = 0;\n\n    for (int i = 0; i < M; i++) {\n        cache[i] = 0;\n        cacheTime[i] = -1;\n    }\n\n    for (int k = 0; k < K; k++) {\n        int ball = sequence[k];\n        int found = 0;\n\n        // Check if ball is already in cache\n        for (int i = 0; i < M; i++) {\n            if (cache[i] == ball) {\n                found = 1;\n                cacheTime[i] = currentTime;\n                break;\n            }\n        }\n\n        // If ball not in cache\n        if (!found) {\n            int replacementIndex = 0;\n            int oldestTime = cacheTime[0];\n\n            // Find least recently used box\n            for (int i = 1; i < M; i++) {\n                if (cacheTime[i] < oldestTime) {\n                    oldestTime = cacheTime[i];\n                    replacementIndex = i;\n                }\n            }\n\n            // Add cost of reading ball\n            totalCost += ballWeights[ball];\n\n            // Replace ball in cache\n            cache[replacementIndex] = ball;\n            cacheTime[replacementIndex] = currentTime;\n        }\n\n        currentTime++;\n    }\n\n    return totalCost;\n}\n\nint main() {\n    int M, N, K;\n    scanf(\"%d %d %d\", &M, &N, &K);\n\n    // Read ball weights\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &ballWeights[i]);\n    }\n\n    // Read sequence of operations\n    for (int i = 0; i < K; i++) {\n        scanf(\"%d\", &sequence[i]);\n    }\n\n    int result = minimumCost(M, N, K);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:19:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass CacheStrategy {\nprivate:\n    int M, N, K;\n    vector<int> ballWeights;\n    vector<int> operations;\n\npublic:\n    CacheStrategy(int boxes, int ballCount, const vector<int>& weights, const vector<int>& ops)\n        : M(boxes), N(ballCount), ballWeights(weights), operations(ops) {}\n\n    int minimumCacheCost() {\n        vector<vector<int>> dp(K + 1, vector<int>(M + 1, INT_MAX));\n        dp[0][0] = 0;\n\n        for (int op = 1; op <= K; op++) {\n            int currentBall = operations[op - 1];\n            int ballWeight = ballWeights[currentBall - 1];\n\n            for (int boxes = 1; boxes <= M; boxes++) {\n                // Not placing the ball\n                dp[op][boxes] = dp[op - 1][boxes];\n\n                // Trying to place the ball in a new box\n                if (dp[op - 1][boxes - 1] != INT_MAX) {\n                    dp[op][boxes] = min(dp[op][boxes], \n                        dp[op - 1][boxes - 1] + ballWeight);\n                }\n\n                // Replacing an existing ball\n                for (int replaceBox = 0; replaceBox < boxes; replaceBox++) {\n                    if (dp[op - 1][boxes] != INT_MAX) {\n                        dp[op][boxes] = min(dp[op][boxes], \n                            dp[op - 1][boxes] + ballWeight);\n                    }\n                }\n            }\n        }\n\n        int minCost = INT_MAX;\n        for (int boxes = 1; boxes <= M; boxes++) {\n            minCost = min(minCost, dp[K][boxes]);\n        }\n\n        return minCost;\n    }\n};\n\nint main() {\n    int M, N, K;\n    cin >> M >> N >> K;\n\n    vector<int> ballWeights(N);\n    for (int i = 0; i < N; i++) {\n        cin >> ballWeights[i];\n    }\n\n    vector<int> operations(K);\n    for (int i = 0; i < K; i++) {\n        cin >> operations[i];\n    }\n\n    CacheStrategy cacheStrategy(M, N, ballWeights, operations);\n    cout << cacheStrategy.minimumCacheCost() << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_cache_cost(M, N, operations, weights):\n    cache = []  # List to store balls currently in cache\n    total_cost = 0\n\n    # Iterate over each operation\n    for op in operations:\n        if op in cache:\n            continue  # If ball is already in cache, no cost.\n\n        if len(cache) < M:\n            cache.append(op)  # If cache has space, add ball to cache\n        else:\n            # Find pos of ball to evict, based on least access in future\n            future_access = {ball: float('inf') for ball in cache}\n            for i in range(len(cache)):\n                try:\n                    future_access[cache[i]] = operations.index(\n                        cache[i], operations.index(op) + 1)\n                except ValueError:\n                    continue\n\n            # Choose the ball with the furthest future access or not accessed again\n            to_evict = max(future_access, key=lambda x: future_access[x])\n\n            cache.remove(to_evict)\n            cache.append(op)  # Replace evicted ball with new ball\n\n        total_cost += weights[op - 1]  # Add cost of placing ball\n\n    return total_cost\n\n\n# Example usage\nM = 2\nN = 5\noperations = [1, 2, 1, 3, 1, 4]\nweights = [1, 2, 3, 4, 5]\nprint(min_cache_cost(M, N, operations, weights))",
    "timestamp": "2025-08-13 06:01:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CacheStrategy {\n\n    static class Ball {\n        int number, weight;\n\n        Ball(int number, int weight) {\n            this.number = number;\n            this.weight = weight;\n        }\n    }\n\n    static class Operation {\n        int ballNumber;\n\n        Operation(int ballNumber) {\n            this.ballNumber = ballNumber;\n        }\n    }\n\n    public static int minCostCacheStrategy(int M, int[] weights, int[] operations) {\n        Map<Integer, Ball> balls = new HashMap<>();\n        for (int i = 0; i < weights.length; i++) {\n            balls.put(i + 1, new Ball(i + 1, weights[i]));\n        }\n\n        Map<Integer, Integer> futureUseIdx = new HashMap<>();\n        for (int i = operations.length - 1; i >= 0; i--) {\n            futureUseIdx.put(operations[i], i);\n        }\n\n        Set<Integer> cache = new HashSet<>();\n        int cost = 0;\n        for (int opIdx = 0; opIdx < operations.length; opIdx++) {\n            int ballNumber = operations[opIdx];\n\n            if (!cache.contains(ballNumber)) {\n                if (cache.size() == M) {\n                    int farthestIdx = -1;\n                    int ballToEvict = -1;\n\n                    for (int cachedBall : cache) {\n                        int cachedBallIdx = futureUseIdx.getOrDefault(cachedBall, Integer.MAX_VALUE);\n                        if (cachedBallIdx > farthestIdx) {\n                            farthestIdx = cachedBallIdx;\n                            ballToEvict = cachedBall;\n                        }\n                    }\n\n                    cache.remove(ballToEvict);\n                }\n\n                cache.add(ballNumber);\n                cost += balls.get(ballNumber).weight;\n            }\n\n            futureUseIdx.remove(ballNumber, opIdx);\n        }\n\n        return cost;\n    }\n\n    public static void main(String[] args) {\n        int M = 2;\n        int[] weights = {5, 10, 3, 7};\n        int[] operations = {1, 2, 3, 2, 1, 3};\n        System.out.println(minCostCacheStrategy(M, weights, operations)); // Output: Minimum cost\n    }\n}",
    "timestamp": "2025-08-13 06:01:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAXN 1000\n#define MAXM 100\n\nint weights[MAXN + 1];\nint sequence[MAXN + 1];\nint cost[MAXM][MAXN + 1];\n\nbool inCache[MAXN + 1];\nint lookup[MAXN + 1];\nint cache[MAXM];\nint M, N, K;\n\nint minCost(int index, int cachedCount) {\n    if (index == K) return 0;\n    \n    int ball = sequence[index];\n    if (inCache[ball]) {\n        return minCost(index + 1, cachedCount);\n    }\n    \n    int minAdditionalCost = INT_MAX;\n    for (int i = 0; i < M; i++) {\n        int originalBall = cache[i];\n        \n        inCache[originalBall] = false;\n        inCache[ball] = true;\n        cache[i] = ball;\n        \n        int currentCost = cost[i][ball] + minCost(index + 1, cachedCount);\n        if (currentCost < minAdditionalCost) {\n            minAdditionalCost = currentCost;\n        }\n        \n        inCache[originalBall] = true;\n        inCache[ball] = false;\n        cache[i] = originalBall;\n    }\n    \n    return minAdditionalCost;\n}\n\nint main() {\n    freopen(\"input.txt\", \"r\", stdin);\n    scanf(\"%d %d %d\", &M, &N, &K);\n    \n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &weights[i]);\n    }\n    \n    for (int i = 0; i < K; i++) {\n        scanf(\"%d\", &sequence[i]);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        for (int j = 1; j <= N; j++) {\n            cost[i][j] = weights[j];\n        }\n    }\n    \n    for (int i = 0; i < M; i++) {\n        cache[i] = -1;\n    }\n    \n    printf(\"%d\\n\", minCost(0, 0));\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 06:01:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def optimal_cache_strategy(M, N, balls_weights, operations):\n    def calculate_cost(current_cache, ball):\n        for i, cached_ball in enumerate(current_cache):\n            if cached_ball == ball:\n                return 0\n        return balls_weights[ball - 1]\n\n    def solve(operations):\n        total_cost = 0\n        current_cache = []\n\n        for op in operations:\n            # Check if ball is already in cache\n            if op in current_cache:\n                continue\n\n            # If cache is not full, add ball\n            if len(current_cache) < M:\n                current_cache.append(op)\n                total_cost += calculate_cost(current_cache, op)\n                continue\n\n            # Find ball to replace with minimum future cost\n            max_distance_ball = current_cache[0]\n            max_distance = 0\n\n            for cached_ball in current_cache:\n                future_distance = float('inf')\n                for future_op in operations[operations.index(op) + 1:]:\n                    if cached_ball == future_op:\n                        future_distance = operations[operations.index(op) + 1:].index(future_op)\n                        break\n\n                if future_distance > max_distance:\n                    max_distance = future_distance\n                    max_distance_ball = cached_ball\n\n            # Replace max distance ball\n            current_cache.remove(max_distance_ball)\n            current_cache.append(op)\n            total_cost += calculate_cost(current_cache, op)\n\n        return total_cost\n\n    return solve(operations)\n\n# Example usage\nM = 3  # Number of cache boxes\nN = 5  # Number of balls\nballs_weights = [1, 2, 3, 4, 5]  # Weights of balls\noperations = [1, 2, 3, 4, 5, 1, 2, 3]  # Sequence of operations\n\nresult = optimal_cache_strategy(M, N, balls_weights, operations)\nprint(result)",
    "timestamp": "2025-08-13 06:02:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N, M, K = map(int, data[idx:idx+3])\n    idx +=3\n    \n    weights = list(map(int, data[idx:idx+N]))\n    idx +=N\n    \n    ops = list(map(int, data[idx:idx+K]))\n    idx +=K\n    \n    # The optimal strategy is to keep the heaviest balls in the cache (boxes)\n    # We need to track the current balls in the boxes and replace the lightest one when necessary\n    \n    cache = set()\n    total_cost = 0\n    \n    for ball in ops:\n        if ball in cache:\n            continue\n        total_cost += weights[ball - 1]  # ball is 1-based\n        if len(cache) < M:\n            cache.add(ball)\n        else:\n            # Find the ball in cache with the smallest weight\n            min_weight = float('inf')\n            min_ball = -1\n            for b in cache:\n                if weights[b - 1] < min_weight:\n                    min_weight = weights[b - 1]\n                    min_ball = b\n            cache.remove(min_ball)\n            cache.add(ball)\n    \n    print(total_cost)\n\nsolve()",
    "timestamp": "2025-08-13 06:02:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nstruct Ball {\n    int id;\n    int weight;\n};\n\nstruct Box {\n    int totalWeight;\n    std::vector<int> balls;\n};\n\nusing namespace std;\n\nint main() {\n    int M, N, K;\n    cin >> M >> N >> K;\n    \n    vector<Ball> balls(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        int weight;\n        cin >> weight;\n        balls[i] = {i, weight};\n    }\n    \n    vector<int> operations(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> operations[i];\n    }\n    \n    vector<Box> boxes(M);\n    int totalCost = 0;\n    \n    for (int op : operations) {\n        Ball &currentBall = balls[op];\n        \n        int minCost = INT_MAX;\n        int targetBox = -1;\n        \n        for (int i = 0; i < M; ++i) {\n            int cost = 0;\n            if (find(boxes[i].balls.begin(), boxes[i].balls.end(), currentBall.id) == boxes[i].balls.end()) {\n                cost = currentBall.weight;\n            }\n            if (cost < minCost) {\n                minCost = cost;\n                targetBox = i;\n            }\n        }\n        \n        boxes[targetBox].balls.push_back(currentBall.id);\n        totalCost += minCost;\n    }\n    \n    cout << totalCost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:34"
  }
]