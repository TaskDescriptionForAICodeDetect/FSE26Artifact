[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nimport scala.io.StdIn._\n\nobject Main extends App {\n\n  val Array(m, n, k) = readLine.trim.split(' ').map(_.toInt)\n  val weight = Array.tabulate(n){_ ⇒ readLine.trim.toInt}\n  val request = Array.tabulate(k){_ ⇒ readLine.trim.toInt - 1}\n  val nodes = Array.fill(k + 1){ArrayBuffer[Edge]()}\n  val prev = Array.fill(10001){k}\n  for (i ← nodes.indices.tail) {\n    nodes(i).append(Edge(i - 1, -10000, 0))\n    nodes(i - 1).append(Edge(i, 10000, m))\n    nodes(i).last.pair = nodes(i - 1).last\n    nodes(i - 1).last.pair = nodes(i).last\n  }\n  var default = 0L\n  for (i ← request.indices.reverse) {\n    if (prev(request(i)) != k) {\n      if (prev(request(i)) - 1 == i) {\n        default += weight(request(i))\n      } else {\n        nodes(i).append(Edge(prev(request(i)) - 1, 10000 * (prev(request(i)) - 1 - i) - weight(request(i)), 1))\n        nodes(prev(request(i)) - 1).append(Edge(i, weight(request(i)) - 10000 * (prev(request(i))  - 1 - i), 0))\n        nodes(i).last.pair = nodes(prev(request(i)) - 1).last\n        nodes(prev(request(i)) - 1).last.pair = nodes(i).last\n      }\n    }\n    prev(request(i)) = i\n  }\n  println(pushFlow(nodes, m - 1) - 10000 * k * (m - 1) + request.map(weight).sum - default)\n  def pushFlow[I <: Iterable[Edge]](nodes: Array[I], flow: Int): Long = {\n    val potential = Array.fill(nodes.length){0L}\n    val minCost = Array.fill(nodes.length){Long.MaxValue}\n    val queue = mutable.PriorityQueue()(Ordering.by[(Int, Long), Long](_._2).reverse)\n    val prev = nodes.map{_.head}\n    var result = 0L\n    for (_ ← 0 until flow) {\n      minCost.indices.foreach(i ⇒ minCost(i) = Long.MaxValue)\n      minCost(0) = 0L\n      queue.enqueue((0, 0L))\n      while(queue.nonEmpty) {\n        val (current, currentCost) = queue.dequeue()\n        if (current != nodes.length - 1 && minCost(current) == currentCost) {\n          for (e@Edge(to, cost, flow) ← nodes(current) if flow > 0) {\n            if (minCost(to) > potential(current) + cost - potential(to) + currentCost) {\n              minCost(to) = potential(current) + cost - potential(to) + currentCost\n              prev(to) = e\n              queue.enqueue((to, minCost(to)))\n            }\n          }\n        }\n      }\n      if (minCost.last != Long.MaxValue) {\n        for (i ← nodes.indices if minCost(i) != Long.MaxValue) potential(i) += minCost(i)\n        result += potential.last\n        var last = nodes.length - 1\n        while(last != 0){\n          prev(last).flow -= 1\n          prev(last).pair.flow += 1\n          last = prev(last).pair.to\n        }\n      }\n    }\n    result\n  }\n\n}\n\ncase class Edge(to: Int, cost: Long, var flow: Int) {\n  private var mPair: Option[Edge] = None\n  def pair: Edge = mPair.get\n  def pair_=(edge: Edge) = mPair = Some(edge)\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#define all(x) (x).begin(),(x).end()\n#define size(x) ((int)(x).size()) \nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int inf = 1e8;\nconst int maxn = 2e4;\nstruct edge\n{\n\tint v, r, w, c;\n};\nvector<edge> G[maxn];\nint h[maxn], dist[maxn];\nint pv[maxn], pe[maxn];\nint V;\nint n, m, k;\n\nvoid init(){\n\tfor(int i = 0; i < V; i++){\n\t\tG[i].clear();\n\t}\n}\n\nvoid add(int u, int v, int w, int cost){\n\tG[u].push_back((edge){v, size(G[v]), w, cost});\n\tG[v].push_back((edge){u, size(G[u])-1, 0, -cost});\n} \n\nvoid bellman(int s){\n\tint update = 1;\n\tfill(dist, dist+V, inf);\n\tdist[s] = 0;\n\twhile(update){\n\t\tupdate = 0;\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tfor(int j = 0; j < size(G[u]); j++){\n\t\t\t\tedge &e = G[u][j];\n\t\t\t\tif(e.w > 0 && dist[e.v] > dist[u] + e.c){\n\t\t\t\t\tdist[e.v] = dist[u] + e.c;\n\t\t\t\t\tupdate = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min_cost_flow(int s, int t, int flow){\n\tint res = 0;\n\tfill(h, h+V, 0);\n\tbellman(s);\n\tfor(int i = 0; i < V; i++){\n\t\th[i] += dist[i];\n\t}\n\twhile(flow > 0){\n\t\tfill(dist, dist+V, inf);\n\t\tdist[s] = 0;\n\t\tpriority_queue<pii, std::vector<pii>, greater<pii> > q;\n\t\tq.push(pii(0, s));\n\t\twhile(!q.empty()){\n\t\t\tpii x = q.top(); q.pop();\n\t\t\tint u = x.second;\n\t\t\tif(dist[u] < x.first) continue;\n\t\t\tfor(int i = 0; i < size(G[u]); i++){\n\t\t\t\tedge &e = G[u][i];\n\t\t\t\tint k = h[u] + dist[u] + e.c - h[e.v];\n\t\t\t\tif(k < dist[e.v] && e.w > 0){\n\t\t\t\t\tdist[e.v] = k;\n\t\t\t\t\tq.push(pii(k, e.v));\n\t\t\t\t\tpv[e.v] = u;\n\t\t\t\t\tpe[e.v] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == inf) {\n\t\t\treturn -1;\t//不能再增广\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\th[i] += dist[i];\n\t\t}   \n\t\tint tf = flow;\n\t\tfor(int v = t; v != s; v = pv[v]){\n\t\t\ttf = min(tf, G[pv[v]][pe[v]].w);\n\t\t}\t\n\t\tif(tf){\n\t\t\tfor(int v = t; v != s; v = pv[v]){\n\t\t\t\tedge &e = G[pv[v]][pe[v]];\n\t\t\t\te.w -= tf;\n\t\t\t\tG[v][e.r].w += tf;\n\t\t\t}\n\t\t\tres += tf * h[t];\n\t\t\tflow -= tf;\n\t\t}\n\t}\n\treturn res;\t\n}\n\nint a[maxn], w[maxn], vis[maxn];\n\nint main(int argc, char const *argv[])\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> m >> n >> k;\n\tint res = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> w[i];\n\t} \n\tfor(int i = 0; i < k; i++){\n\t\tcin >> a[i];\n\t}\n\tk = unique(a, a+k) - a;\n\tint s = 0, t = k - 1;\n\tfor(int i = 0; i < k-1; i++){\n\t\tadd(i, i+1, inf, 0);\n\t}\n\tV = k;\n\tfor(int i = 0; i < k; i++){\n\t\tres += w[a[i]];\n\t\tif(vis[a[i]]){\n\t\t\tadd(vis[a[i]], i, 1, -w[a[i]]);\n\t\t}\n\t\tvis[a[i]] = i+1;\n\t}\n\tcout << res + min_cost_flow(s, t, m-1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10000\ntypedef pair<int,int> P; //firstは最短距離、secondは頂点の番号\n\n//辺を表す構造体{行先、容量、コスト、逆辺のインデックス}\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nint N,M,K;\nint weight[NUM],ball_array[NUM];\nint index_table[NUM];\nvector<int> LOC[NUM];\n\n\nint V; //頂点数\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint h[NUM]; //ポテンシャル\nint dist[NUM]; //最短距離\nint pre_node[NUM],pre_edge[NUM]; //直前の頂点と辺\n\n//fromからtoへ向かう容量capacity,コストcostの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\n//sourceからsinkへの、流量flowの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)h[i] = 0; //ポテンシャルを0にする\n\twhile(flow > 0){\n\t\t//ダイクストラ法を用いてhを更新する\n\t\tpriority_queue<P,vector<P>,greater<P>> Q;\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tQ.push(P(0,source));\n\n\t\twhile(!Q.empty()){\n\t\t\tP p = Q.top();\n\t\t\tQ.pop();\n\t\t\tint node_id = p.second;\n\t\t\tif(dist[node_id] < p.first)continue; //最短でなければSKIP\n\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost+h[node_id]-h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost+h[node_id]-h[e.to];\n\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\tQ.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\t//これ以上流せない\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor(int node_id = 0; node_id < V; node_id++)h[node_id] += dist[node_id];\n\n\t\t//source-sink間最短路に沿って目いっぱい流す\n\t\tint tmp_flow = flow;\n\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*h[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n\nint main(){\n\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&weight[i]);\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d\",&ball_array[i]);\n\t\tball_array[i]--;\n\n\t\tLOC[ball_array[i]].push_back(i); //ボールを投入する必要のある時刻の配列\n\t\tans += weight[ball_array[i]];\n\t}\n\n\tint source = 0,sink = 1,index = 2;\n\t//時刻0～K-1に、ノード番号を割り当てる\n\tfor(int i = 0; i < K; i++){\n\t\tindex_table[i] = index++;\n\t}\n\n\tadd_edge(source,index_table[0],M,0);\n\n\t//時刻ノード同士を、十分大きな容量かつコスト0の辺で結ぶ\n\tfor(int i = 0; i < K-1; i++){\n\t\tadd_edge(index_table[i],index_table[i+1],M,0);\n\t}\n\n\tadd_edge(index_table[K-1],sink,M,0);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(LOC[i].size() <= 1)continue; //入れない、または1回しか入れないボールは無視\n\n\t\tfor(int a = 0; a < LOC[i].size()-1; a++){\n\t\t\tif(LOC[i][a]+1 == LOC[i][a+1]){ //入れる時刻が連続している場合\n\t\t\t\tans -= weight[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tadd_edge(index_table[LOC[i][a]+1],index_table[LOC[i][a+1]],1,-weight[i]);\n\t\t}\n\t}\n\n\tV = index;\n\n\t//★★時刻→時刻に、必ず[今入れたばかりの球]が存在するので、区間の重なりはM-1まで★★\n\tans += min_cost_flow(source,sink,M-1);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int INT_INF = 1 << 29;\nconst ll INF = 1LL<<55;\n\ntypedef pair<int, int> P;\nstruct edge {\n\tint to;\n\tint cap;\n\tll cost;\n\tint rev;\n};\n\nconst int MAX_V = 20010;\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, ll cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nll min_cost_flow(int s, int t, int f, bool bell = false) {\n\tll res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\tif (bell) {\n\t\t\tbell = false;\n\t\t\tbool update;\n\t\t\tdo {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t}\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 10010, MAX_K = 10010;\n\nint main(int argc, char *argv[]) {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tint w[MAX_N];\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tint a[MAX_K], r = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t\tr+= w[a[i]];\n\t}\n\tint b[MAX_N];\n\tfill_n(b, MAX_N, -1);\n\tfor (int i = 0; i < K; i++) {\n\t\tadd_edge(i, i+1, INT_INF, 0);\n\t\tif (b[a[i]] != -1) {\n\t\t\tadd_edge(b[a[i]], i, 1, -w[a[i]]);\n\t\t}\n\t\tb[a[i]] = i+1;\n\t}\n\tV = K+1;\n\tprintf(\"%lld\\n\", r + min_cost_flow(0, K, M-1, true));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef long long LL;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=10010;\nint V,dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update=1;\n        while(update){\n            update=0;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=1;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF)return -1;\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }return res;\n}\nvoid clear(){for(int i=0;i<=V;i++)G[i].clear();}\nconst int MAX_N=10010;\nint M,N,K,w[MAX_N],lst[MAX_N],a[MAX_N];\nint solve(){\n    for(int i=1;i<=N;i++)scanf(\"%d\",&w[i]);\n    for(int i=1;i<=K;i++)scanf(\"%d\",&a[i]);\n    int cnt=K;\n    int res=0;\n    memset(lst,0,sizeof(lst));\n    V=cnt+1; clear();\n    for(int i=1;i<=cnt;i++){\n        res+=w[a[i]];\n        if(lst[a[i]])add_edge(lst[a[i]],i-1,1,-w[a[i]]);\n        lst[a[i]]=i;\n    }for(int i=1;i<cnt;i++)add_edge(i,i+1,INF,0);\n    printf(\"%d\\n\",res+min_cost_flow(1,cnt,M-1));\n}\nint main(){\n    while(~scanf(\"%d%d%d\",&M,&N,&K))solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <iterator>\n\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int INF = 10000000;\n\ntypedef pair<int, int>P;\nstruct edge {int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()} );\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h+V, 0);\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (dist[v] < p.first) continue;\n      for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if (dist[t] == INF) {\n      return -1;\n    }\n    for (int v = 0; v < V; v++) h[v] += dist[v];\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nconst int MAX_N = 10;\nint M, N, K;\nint w[MAX_N];\nvector<int> a[MAX_N];\n\nint main(){\n  int all_res = 0;\n  scanf(\"%d %d %d\", &M, &N, &K);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; i++) {\n    int j = 0;\n    scanf(\"%d\", &j);\n    a[j-1].push_back(i);\n    all_res += w[j-1];\n  }\n\n  int s = K, t = s + 1;\n  V = t + 1;\n  int res = 0;\n  add_edge(s, 0, M-1, 0);\n  add_edge(K - 1, t, M-1, 0);\n  for (int i =0; i + 1 < K; i++) {\n    add_edge(i, i + 1, INF, 0);\n  }\n  int NE = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < (int)a[i].size()-1; j++) {\n      if(a[i][j+1]- a[i][j]==0) {\n        res += w[i];\n      } else {\n        add_edge(a[i][j+1], a[i][j]+1, 1, w[i]);\n        add_edge(s, a[i][j+1], 1, 0);\n        add_edge(a[i][j]+1, t, 1, 0);\n        res -= w[i];\n        NE++;\n      }\n    }\n  }\n\n  res += min_cost_flow(s, t, M+NE-1);\n  printf(\"%d\\n\", all_res+res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int INT_INF = 1 << 29;\nconst ll INF = 1LL<<55;\n\ntypedef pair<int, int> P;\nstruct edge {\n\tint to;\n\tint cap;\n\tll cost;\n\tint rev;\n};\n\nconst int MAX_V = 20010;\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, ll cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nll min_cost_flow(int s, int t, int f, bool bell = false) {\n\tll res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\tif (bell) {\n\t\t\t//bell = false;\n\t\t\tbool update;\n\t\t\tdo {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[v] != INF && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t} else {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 10010, MAX_K = 10010;\nconst ll OFFSET = 1LL<<30;\nint main(int argc, char *argv[]) {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tint w[MAX_N];\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tint a[MAX_K], r = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t\tr+= w[a[i]];\n\t}\n\tint b[MAX_N];\n\tfill_n(b, MAX_N, -1);\n\tfor (int i = 0; i < K; i++) {\n\t\tadd_edge(i, i+1, M, 0);\n\t\tif (b[a[i]] != -1) {\n\t\t\tadd_edge(b[a[i]], i, 1, -w[a[i]]);\n\t\t}\n\t\tb[a[i]] = i+1;\n\t}\n\tV = K+1;\n\tprintf(\"%lld\\n\", r + min_cost_flow(0, K, M-1, true));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\n// (?????????, ??????, ?????????, ??????)\nstruct edge{ int to,cap,cost,rev; };\n\nint V; // TODO:initialize\nconst int MAX_V = 30303; // TODO:initialize\nconst ll INF = LLONG_MAX/5; // TODO:initialize\nvector<edge> G[MAX_V];\nll h[MAX_V]; // ??????????????£???\nll dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,(int)G[to].size()});\n    G[to].pb({from,0,-cost,(int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???(???????????????-1)\nll min_cost_flow(int s, int t, int f){\n    ll res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        // dijkstra??§h?????´??°\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        pq.push(pi(0,s));\n        while(!pq.empty()){\n            pi p = pq.top();\n            pq.pop();\n            int v = p.se;\n            if(p.fi>dist[v]) continue;\n            rep(i,G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    pq.push(pi(dist[e.to],e.to));\n                }\n            }\n        }\n\n        // ????????\\???????????????\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t???????????????????????£??????????????????\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nconst ll M=191919191;\n\nvector<int> num[10000];\n\nint main()\n{\n    int F,n,k;\n    scanf(\" %d %d %d\", &F, &n, &k);\n    vector<int> w(n),a(k);\n    rep(i,n) scanf(\" %d\", &w[i]);\n    rep(i,k)\n    {\n        scanf(\" %d\", &a[i]);\n        --a[i];\n        num[a[i]].pb(i);\n    }\n\n    V = 3*k+2;\n    int S=3*k, T=S+1;\n    add_edge(S,0,F,0);\n\n    rep(i,k)\n    {\n        add_edge(3*i,3*i+1,1,w[a[i]]);\n        add_edge(3*i+1,3*i+2,1,-M);\n        if(i<k-1)\n        {\n            add_edge(3*i+2,3*(i+1),1,0);\n            add_edge(3*i,3*(i+1),F,0);\n        }\n    }\n\n    rep(i,n)\n    {\n        int SZ = num[i].size();\n        if(SZ<2) continue;\n        rep(j,SZ-1)\n        {\n            int u=num[i][j], v=num[i][j+1];\n            add_edge(3*u+2,3*v+1,1,0);\n        }\n    }\n\n    add_edge(3*k-3,T,F,0);\n    add_edge(3*k-1,T,F,0);\n\n    printf(\"%lld\\n\", min_cost_flow(S,T,F)+M*k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef long long LL;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=10010;\nint V,dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update=1;\n        while(update){\n            update=0;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=1;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF)return -1;\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d; \n        }\n    }return res;\n}\nvoid clear(){for(int i=0;i<V;i++)G[i].clear();}\nconst int MAX_N=10010;\nint M,N,K,w[MAX_N],lst[MAX_N],a[MAX_N];\nint solve(){\n    for(int i=1;i<=N;i++)scanf(\"%d\",&w[i]);\n    for(int i=1;i<=K;i++)scanf(\"%d\",&a[i]);\n    int cnt=unique(a+1,a+K+1)-(a+1);\n    int res=0;\n    memset(lst,0,sizeof(lst));\n    V=cnt; clear();\n    for(int i=1;i<cnt;i++){\n        res+=w[a[i]];\n        if(lst[a[i]])add_edge(lst[a[i]],i-1,1,-w[a[i]]);\n        lst[a[i]]=i;\n    }for(int i=1;i<cnt-1;i++)add_edge(i,i+1,INF,0);\n    printf(\"%d\\n\",res+min_cost_flow(1,cnt-1,M-1));\n}\nint main(){\n    while(~scanf(\"%d%d%d\",&M,&N,&K))solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL BASE = 10000LL * 10000LL * 100;\nconst LL INF = 1LL << 60;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow cap, flow;\n    Cost cost;\n    Edge *back;\n\n    Edge(int from, int to, Flow cap, Cost cost, Edge *back) : from(from), to(to), cap(cap), cost(cost), back(back) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    Edge<Flow,Cost> *ea = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    Edge<Flow,Cost> *eb = new Edge<Flow,Cost>(dst, src, 0, -d, ea);\n    ea->back = eb;\n    g[src].push_back(ea);\n    g[dst].push_back(eb);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow,Cost>\nprimal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, int max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> dist(N);\n    vector<Edge<Flow,Cost>*> prev(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        fill(prev.begin(), prev.end(), nullptr);\n        dist[src] = 0;\n\n        for(int turn = 0; turn < N; ++turn) {\n            bool updated = false;\n            for(int i = 0; i < N; ++i) {\n                for(auto *e : g[i]) {\n                    if(e->cap - e->flow > 0) {\n                        Cost nc = dist[e->from] + e->cost;\n                        if(nc < dist[e->to]) {\n                            dist[e->to] = nc;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(!updated) break;\n        }\n        if(prev[sink] == nullptr) break;\n\n        Flow aug = f;\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            aug = min(aug, e->cap - e->flow);\n        }\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            res.second += aug * e->cost;\n            e->flow += aug;\n            e->back->flow -= aug;\n        }\n        f -= aug;\n        res.first += aug;\n    }\n\n    return res;\n}\n\nbool solve() {\n    int M, N, K;\n    if(!(cin >> M >> N >> K)) return false;\n\n    vector<LL> ws(N);\n    vector<int> as(K);\n    vector<vector<Edge<int,LL>*>> graph(K+2);\n    const int SRC = K;\n    const int SINK = K+1;\n    for(int i = 0; i < N; ++i) {\n        cin >> ws[i];\n    }\n    LL sum = 0;\n    for(int i = 0; i < K; ++i) {\n        cin >> as[i];\n        --as[i];\n        sum += ws[as[i]];\n    }\n    for(int i = 0; i < K; ++i) {\n        // Edge to neighbor\n        if(i+1 < K) {\n            add_edge(graph, i, i+1, M, 0LL);\n        }\n        // Edge to next same number\n        auto it = find(as.begin()+i+1, as.end(), as[i]);\n        if(it != as.end()) {\n            add_edge(graph, i+1, it-as.begin(), 1, -ws[as[i]]);\n        }\n    }\n    add_edge(graph, SRC, 0, M, 0LL);\n    add_edge(graph, K-1, SINK, M, 0LL);\n    auto res = primal_dual(graph, SRC, SINK, M-1);\n    cout << sum + res.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntypedef int weight;\ntypedef pair<weight, int> P;\n\nstruct edge {\n\tint to;\n\tint cap;\n\tweight cost;\n\tint rev;\n\tedge(int to_, int cap_, weight cost_, int rev_):to(to_), cap(cap_), cost(cost_), rev(rev_){};\n};\n\nvector<vector<edge>> G;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n}\n\nvoid add_edge(int from, int to, int cap, weight cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\n\nweight min_cost_flow(int s, int t, weight f) {\n\tconst int n = G.size();\n\tweight res = 0;\n\tvector<int> prevv(n), preve(n);\n\tvector<weight> h(n, 0);\n\twhile(f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tvector<weight> dist(n, INT_MAX);\n\t\tdist[s] = 0;\n\t\tque.push({0, s});\n\t\twhile(!que.empty()) {\n\t\t\tconst auto d = que.top().first;\n\t\t\tconst auto v = que.top().second;\n\t\t\tque.pop();\n\n\t\t\tif(dist[v] < d) continue;\n\n\t\t\tfor(unsigned i = 0; i < G[v].size(); ++i) {\n\t\t\t\tconst edge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > d + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = d + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push({dist[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t] == INT_MAX) return -1;\n\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint m, n, k;\n\tcin >> m >> n >> k;\n\n\tvector<int> w(n);\n\tfor(auto &e : w) cin >> e;\n\n\tinit(k + 1);\n\n\tvector<int> prev(n, -1);\n\tint ans = 0;\n\n\trep(i, k) {\n\t\tint a;\n\t\tcin >> a;\n\t\t--a;\n\n\t\tans += w[a];\n\n\t\tadd_edge(i, i + 1, INT_MAX, 0);\n\t\tif(prev[a] != -1) add_edge(prev[a] + 1, i, 1, -w[a]);\n\t\tprev[a] = i;\n\t}\n\n\tcout << ans + min_cost_flow(0, k, m - 1) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nstruct EdgeC{\n  int to, cap, cost, rev;\n  EdgeC(int to_=0, int cap_ = 0, int cost_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), cost(cost_), rev(rev_){}\n};\nusing GraphC = vector<vector<EdgeC>>;\n\nvoid add_edge(GraphC& G, int from, int to, int cap, int cost){\n  G[from].emplace_back(to, cap, cost, G[to].size());\n  G[to].emplace_back(from, 0, -cost, G[from].size()-1);\n}\n\nint min_cost_flow(GraphC& G, int s, int t, int f){\n  int V = G.size();\n  vector<int> dist(V);\n  vector<int> prevv(V), preve(V);\n  int res = 0;\n  \n  while(f > 0){\n\tfill(begin(dist), end(dist), INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile(update){\n\t  update = false;\n\t  for(int v=0;v<V;++v){\n\t\tif(dist[v] == INF) continue;\n\t\tfor(unsigned int i=0;i<G[v].size();++i){\n\t\t  auto& e = G[v][i];\n\t\t  if(e.cap > 0 && dist[v] + e.cost < dist[e.to]){\n\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\tif(dist[t] == INF) return -INF;\n\n\tint d = f;\n\tfor(int v=t;v!=s;v=prevv[v])\n\t  d = min(d, G[prevv[v]][preve[v]].cap);\n\n\tf -= d;\n\tres += d * dist[t];\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t  auto& e = G[prevv[v]][preve[v]];\n\t  e.cap -= d;\n\t  G[v][e.rev].cap += d;\n\t}\n  }\n  \n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int BOX, BALL, K;\n  cin >> BOX >> BALL >> K;\n  VI xs(BALL);\n  cin >> xs;\n\n  VI qs(K);\n  cin >> qs;\n\n  VI last(BALL+1,-1);\n  VI post(K,-1);\n  for(int i=K-1;i>=0;--i){\n\tpost[i] = last[qs[i]];\n\tlast[qs[i]] = i;\n  }\n\n  int ans = 0;\n  GraphC G(K+1);\n  REP(k,K){\n\tadd_edge(G, k, k+1, BOX, 0);\n\tans += xs[qs[k]-1];\n\tif(post[k] >= 0){\n\t  add_edge(G, k, post[k]-1, 1, -xs[qs[k]-1]);\n\t}\n  }\n  cout << ans + min_cost_flow(G, 0, K, BOX-1) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<string>\n#include<assert.h>\n#include<math.h>\n#include<stdio.h>\n#include<ctype.h>\n#endif\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define DEBUG if(0)\n#endif\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r) { bool a = l>r; if (a)l = r; return a; }\ntemplate <typename T>inline bool chmax(T &l, T r) { bool a = l<r; if (a)l = r; return a; }\n\nstruct input {\n\tbool success;\n\tinput(){success = true;}\n#ifdef BTK\n\ttemplate<typename T>inline input& operator>>(T& x) {success = !!(cin >> x);return *this;}\n#else\n\tinline input& operator>>(LL& x) {success = (scanf(\"%lld\", &x) != EOF);return *this;}\n\tinline input& operator>>(int& x) {success = (scanf(\"%d\", &x) != EOF);return *this;}\n\tinline input& operator>>(char* x) {success = (scanf(\"%s\", x) != EOF);return *this;}\n\tinline input& operator>>(double& x) {success = (scanf(\"%llf\", &x) != EOF);return *this;}\n#endif\n}in;\n\nconst char space = ' ';\nconst char ln = '\\n';\nstruct output {\n#ifdef BTK\n\ttemplate<typename T>inline output& operator<<(T x) {cout << x; return (*this);}\n\tinline void fp(const double x, const char* s) { char buf[20];sprintf(buf, s, x); cout << buf;}\n#else\n\tinline output& operator<<(const string& x) { printf(\"%s\", x.c_str()); return *this; }\n\tinline output& operator<<(const int x) { printf(\"%d\", x); return *this;}\n\tinline output& operator<<(const char x) { putchar(x); return *this;}\n\tinline output& operator<<(const LL x) { printf(\"%lld\", x); return *this;}\n\tinline output& operator<<(const double x) { printf(\"%lf\", x); return *this;}\n\tinline void fp(const double x, const char* s) {printf(s, x);}\n#endif\n}out;\ntypedef int FLOW;\ntypedef LL COST;\nnamespace MinCostFlow {\n\tconst FLOW FLOW_INF = 1e7;\n\tconst COST COST_INF = 1e15;\n\tstruct edge {\n\t\tFLOW flow; COST cost;\n\t\tint to, rev;\n\t};\n\ttypedef vector<edge> E;\n\ttypedef vector<E> Graph;\n\tvoid addedge(Graph&g, int from, int to, FLOW f, COST c) {\n\t\tint x = g[from].size();\n\t\tint y = g[to].size();\n\t\tedge a = { f,c,to,y };\n\t\tedge b = { (FLOW)0,-c,from,x };\n\t\tg[from].push_back(a);\n\t\tg[to].push_back(b);\n\t}\n\n\tconst int BUF = 11234;\n\tCOST h[BUF];\n\tCOST d[BUF];\n\tint pV[BUF];\n\tint pE[BUF];\n\tvoid init(int size = BUF) {\n\t\tREP(i, size)h[i] = 0;\n\t}\n\ttypedef pair<COST, int> P;\n\tpriority_queue<P> que;\n}\n\n\n\npair<FLOW, COST> maxflow(MinCostFlow::Graph &g, int s, int t, bool init = true) {\n\tconst int V = g.size();\n\tif (init)MinCostFlow::init();\n\tusing namespace MinCostFlow;\n\tCOST c = 0;\n\tFLOW f = 0;\n\twhile (true) {\n\t\tfill(d, d + V, COST_INF);\n\t\td[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (que.size()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tCOST cost = -p.first;\n\t\t\tint v = p.second;\n\t\t\tif (d[v]<cost)continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tedge &e = g[v][i];\n\t\t\t\tif (e.flow>0 && d[e.to]>d[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\td[e.to] = d[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tpV[e.to] = v;\n\t\t\t\t\tpE[e.to] = i;\n\t\t\t\t\tque.push(P(-d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t] == COST_INF)break;\n\n\t\tREP(v, V)h[v] += d[v];\n\t\tFLOW ff = FLOW_INF;\n\t\tfor (int v = t; v != s; v = pV[v]) {\n\t\t\tedge& e = g[pV[v]][pE[v]];\n\t\t\tchmin(ff, e.flow);\n\t\t}\n\t\tf += ff;\n\t\tc += ff*h[t];\n\t\tfor (int v = t; v != s; v = pV[v]) {\n\t\t\tedge &e = g[pV[v]][pE[v]];\n\t\t\te.flow -= ff;\n\t\t\tg[v][e.rev].flow += ff;\n\t\t}\n\t}\n\treturn pair<FLOW, COST>(f, c);\n}\n\nint w[112345];\nint pos[112345];\nint main() {\n\tint M, N, K;\n\tin >> M >> N >> K;\n\tM--;\n\tREP(i, N)in >> w[i];\n\tREP(i, N)pos[i] = -1;\n\tint V = K + 1;\n\tint S = V++;\n\tint T = V++;\n\tint s = 0;\n\tint t = K;\n\tMinCostFlow::Graph g(V);\n\tREP(i, K)MinCostFlow::addedge(g, i, i + 1, M, 0);\n\tMinCostFlow::addedge(g, S, s, M, 0);\n\tMinCostFlow::addedge(g, t, T, M, 0);\n\tLL tot = 0;\n\tLL cost = 0;\n\tREP(i, K) {\n\t\tint a;\n\t\tin >> a;\n\t\ta--;\n\t\ttot += w[a];\n\t\tif (pos[a] != -1&&pos[a]!=i) {\n\t\t\tMinCostFlow::addedge(g, S, i, 1, 0);\n\t\t\tMinCostFlow::addedge(g, i, pos[a], 1, w[a]);\n\t\t\tMinCostFlow::addedge(g, pos[a], T, 1, 0);\n\t\t\tcost -= w[a];\n\t\t}\n\t\tif (pos[a] == i)tot -= w[a];\n\t\tpos[a] = i + 1;\n\t}\n\tpair<FLOW, COST> fc = maxflow(g, S, T);\n\tcost += fc.second;\n\tout << tot + cost<<ln;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* ???M?????±????????????????£???????????????¨???????¬¬????????±??????\n * ???????????????????????????????????????????????????????¬¬????????±\n * ?????????????????????????????¶???????????±????????¶???????????????\n * ?????????????????°???????°±?????????????????????\n * ?°???????????????°???????????????(INF/0)????°???????????????????\n * ??????a???b?????¨a?????????????????????b?????????????¢????(w/1)\n * ???M-1????°??????¨??????\n */\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<utility>\n#include<cstring>\n#define INF 1000000000\n#define MAX_V 10000\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev) {}\n};\nint N, M, K, V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size()-1));\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\twhile(f > 0){\n\t\t//Bellman-Ford\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v = 0; v < V; v++){\n\t\t\t\tif(dist[v] == INF) continue;\n\t\t\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += dist[t];\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint w[MAX_V], s[MAX_V], last[MAX_V];\nint main(){\n\tcin>>M>>N>>K;\n\tint sum = 0;\n\tfor(int i = 0; i < N; i++) scanf(\"%d\", &w[i]);\n\tint index = 0;\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d\", &s[index]);\n\t\tif(index == 0 || s[index] != s[index-1]){\n\t\t\tsum += w[s[index]-1];\n\t\t\tindex++;\n\t\t}\n\t}\n\tV = index;\n\tmemset(last, -1 ,sizeof(last));\n\tfor(int i = 0; i < V; i++){\n\t\tif(last[s[i]] >= 0) add_edge(last[s[i]] + 1, i, 1, -w[s[i]-1]);\n\t\tif(i < V-1) add_edge(i, i+1, INF, 0);\n\t\tlast[s[i]] = i;\n\t}\n\tprintf(\"%d\\n\",sum + min_cost_flow(0, V-1, M-1));\n\treturn 0;\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef long long LL;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=10010;\nint V,dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update=1;\n        while(update){\n            update=0;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=1;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF)return -1;\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }return res;\n}\nvoid clear(){for(int i=0;i<=V;i++)G[i].clear();}\nconst int MAX_N=10010;\nint M,N,K,w[MAX_N],lst[MAX_N],a[MAX_N];\nint solve(){\n    for(int i=1;i<=N;i++)scanf(\"%d\",&w[i]);\n    for(int i=1;i<=K;i++)scanf(\"%d\",&a[i]);\n    int cnt=K;\n    int res=0;\n    memset(lst,0,sizeof(lst));\n    V=cnt+1; clear();\n    for(int i=1;i<=cnt;i++){\n        res+=w[a[i]];\n        if(lst[a[i]])add_edge(lst[a[i]],i-1,1,-w[a[i]]);\n        lst[a[i]]=i;\n    }for(int i=1;i<cnt;i++)add_edge(i,i+1,INF,0);\n    printf(\"%d\\n\",res+min_cost_flow(1,cnt,M-1));\n}\nint main(){\n    while(~scanf(\"%d%d%d\",&M,&N,&K))solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\nstruct edge\n{\n    int from,to,c,cost;\n    edge(int _from,int _to,int _c,int _cost)\n    {\n        from=_from,to=_to,c=_c,cost=_cost;\n    }\n};\nvector<int> same[10005];\nvector<int> G[10005];\nvector<edge> p;\nint N,M,K,inf=1e9;\nint w[10005],a[10005];\nvoid input(int &sum)\n{\n    sum=0;\n    for(int i=0; i<M; i++) scanf(\"%d\",&w[i]);\n    int k=0,t;\n    for(int i=0; i<K; i++)\n    {\n        scanf(\"%d\",&t); t--;\n        if(k==0||t!=a[k-1])\n        {\n            same[t].push_back(k);\n            a[k]=t;\n            sum+=w[t];\n            k++;\n        }\n    }\n    K=k;\n}\nvoid add(int from,int to,int c,int cost)\n{\n    G[from].push_back(p.size());\n    p.push_back(edge(from,to,c,cost));\n    G[to].push_back(p.size());\n    p.push_back(edge(to,from,0,-cost));\n}\nvoid get_map(int s,int d)\n{\n    for(int i=0;i<K-1;i++) add(i,i + 1, M, 0);\n    for(int i=0;i<M;i++) for(int j=0;j<same[i].size()-1;j++) add(same[i][j]+1,same[i][j+1],1,-w[a[same[i][j]]]);\n    add(s,0,M,0);\n    add(K-1,d,M,0);\n}\nint pre[10005],dist[10005];\nbool vis[10005];\nbool spfa(int s,int d)\n{\n    int u,v;\n    queue<int> q;\n    for(int i=0;i<=d+2;i++){\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=inf;\n    }\n    vis[s]=1;\n    dist[s]=0;\n    q.push(s);\n    while(!q.empty()){\n        u=q.front();\n       /* cout<<u<<\":\"<<endl;\n        for(int i=0;i<=d;i++) printf(\"%4d\",p[pre[i]].from); cout<<endl;\n        for(int i=0;i<=d;i++) printf(\"%4d\",dist[i]); cout<<endl;*/\n        q.pop();\n        vis[u]=0;\n        for(int j=0;j<G[u].size();j++){\n            int i=G[u][j];\n            if(p[i].c>0){\n                v=p[i].to;\n                if(dist[v]>dist[u]+p[i].cost){\n                    dist[v]=dist[u]+p[i].cost;\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    return dist[d]!=inf;\n}\n\nint MCMF(int s,int d){\n    int ans=0,flow;\n    int flow_sum=0;\n    while(spfa(s,d)){\n        flow=inf;\n        for(int i=pre[d];i!=-1;i=pre[p[i].from])\n            if(p[i].c<flow)\n                flow=p[i].c;\n        for(int i=pre[d];i!=-1;i=pre[p[i].from]){\n            p[i].c-=flow;\n            p[i^1].c+=flow;\n        }\n        ans+=dist[d]*flow;\n        //cout<<dist[d]<<\"*\"<<flow<<endl;\n        flow_sum += flow;\n        if(flow_sum>=N-1) return ans;\n    }\n    //cout << flow_sum << endl;\n    //cout<<ans<<endl;\n    //return ans;\n}\nvoid init()\n{\n    for(int i=0;i<10005;i++) G[i].clear(),same[i].clear();\n    p.clear();\n}\nint main()\n{\n    while(cin>>N>>M>>K)\n    {\n        init();\n        int sum;\n        input(sum);\n        int s=K,d=K+1;\n        get_map(s,d);\n        cout<<sum+MCMF(s,d)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<ll,int>;\n\n// (?????????, ??????, ?????????, ??????)\nstruct edge{\n    int to,cap;\n    ll cost;\n    int rev;\n};\n\nint V; // TODO:initialize\nconst int MAX_V = 30303; // TODO:initialize\nconst ll INF = 123456789012345LL; // TODO:initialize\nvector<edge> G[MAX_V];\nll h[MAX_V]={}; // ??????????????£???\nll dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,(int)G[to].size()});\n    G[to].pb({from,0,-cost,(int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???(???????????????-1)\nll min_cost_flow(int s, int t, int f, bool neg = false){\n    ll res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        // dijkstra??§h?????´??°\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        if(neg)\n        {\n            neg = false;\n            bool update;\n            do{\n                update = false;\n                rep(v,V){\n                    if(dist[v] == INF) continue;\n                    rep(i,G[v].size()){\n                        edge &e = G[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }while(update);\n        }\n        else\n        {\n            pq.push(pi(0,s));\n            while(!pq.empty()){\n                pi p = pq.top();\n                pq.pop();\n                int v = p.se;\n                if(p.fi>dist[v]) continue;\n                rep(i,G[v].size()){\n                    edge &e = G[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        pq.push(pi(dist[e.to],e.to));\n                    }\n                }\n            }\n        }\n\n        // ????????\\???????????????\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t???????????????????????£??????????????????\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nconst ll M=10000000;\n\nvector<int> num[10000];\n\nint main()\n{\n    int F,n,k;\n    scanf(\" %d %d %d\", &F, &n, &k);\n    vector<int> w(n),a(k);\n    rep(i,n) scanf(\" %d\", &w[i]);\n    rep(i,k)\n    {\n        scanf(\" %d\", &a[i]);\n        --a[i];\n        num[a[i]].pb(i);\n    }\n\n    V = 3*k+3;\n    int S=3*k, T=S+1;\n    add_edge(S,0,F,0);\n\n    rep(i,k)\n    {\n        add_edge(3*i, 3*i+1, 1, w[a[i]]);\n        add_edge(3*i+1, 3*i+2, 1, -M);\n        if(i<k-1)\n        {\n            add_edge(3*i+2, 3*(i+1), 1, 0);\n            add_edge(3*i, 3*(i+1), F-1, 0);\n        }\n    }\n\n    rep(i,n)\n    {\n        int SZ = num[i].size();\n        rep(j,SZ-1)\n        {\n            int u=num[i][j], v=num[i][j+1];\n            add_edge(3*u+2, 3*v+1, 1, 0);\n        }\n    }\n\n    add_edge(3*k-3, T, F, 0);\n    add_edge(3*k-1, T, 1, 0);\n\n    printf(\"%lld\\n\", min_cost_flow(S,T,F,true)+M*k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n \nusing namespace std;\ntypedef pair<int,int> P;\n \nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n \nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n \nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n \n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n \n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n \n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      if(M!=1){\n        for(j=MAX(i+1,initial);j<nxt;j++){        \n          nbr[i].push_back(j);\n          cost[i].push_back(w[a[i]]);\n          num_nbr[i]++;\n          if(j >= MAX(i+1,initial) + 10) break;\n        }\n        nbr[i].push_back(nxt);\n        num_nbr[i]++;\n        cost[i].push_back(0);\n      }\n      else{\n        nbr[i].push_back(i+1);\n        cost[i].push_back((nxt == i+1)? 0:w[a[i]]);\n        num_nbr[i]++;\n      }\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n  /*\n  for(i=0;i<K-M;i++)for(j=0;j<num_nbr[i];j++){\n    printf(\"cost[%d][%d]=%d\\n\",i,nbr[i][j],cost[i][j]);\n  }\n   */\n}\n \nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n   \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n   \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n \n  int cnt = 0;\n  for(int s=0;s<K-M;s++){\n    fill(dist,dist+K+1,INT_MAX);\n      dist[s] = 0;\n      que.push(P(0,s));\n//    printf(\"\\n%d-th loop\",++cnt);\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n//      printf(\"node %d established.\\n\",u);\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    for(i = 0;i < K-M;i++) h[i] += (dist[i] == INT_MAX)? 0:dist[i];\n    h[t] += (dist[t] == INT_MAX)? 0:dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n  return res;\n}\n \nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n \nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n#define pb push_back\n#define PB pop_back\n#define bk back()\n#define fs first\n#define se second\n#define sq(x) (x) * (x)\n#define eps (1e-10)\n#define INF (1000000300)\n#define clr(x) memset((x), 0, sizeof(x))\n#define cp(a, b) memcpy((a), (b), sizeof(b))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair< int, int > P;\ntypedef pair< ll, int > D;\n\nconst int MAXV = 1e4 + 300;\nint V;\nconst int s = MAXV - 1, t = MAXV - 2;\nstruct EDGE\n{\n  int to, cap, cost, next;\n} ES[MAXV * 10];\nint eh;\nint h[MAXV];\nint dis[MAXV];\nint prevv[MAXV], preve[MAXV];\nint head[MAXV];\nvoid addedge(int from, int to, int cap, int cost)\n{\n  ES[eh].to = to;\n  ES[eh].cap = cap;\n  ES[eh].cost = cost;\n  ES[eh].next = head[from];\n  head[from] = eh++;\n  ES[eh].to = from;\n  ES[eh].cap = 0;\n  ES[eh].cost = -cost;\n  ES[eh].next = head[to];\n  head[to] = eh++;\n}\nbool inq[MAXV];\nll min_cost_flow(int s, int t, int f)\n{\n  V = MAXV; // default V size maxed\n  ll res = 0;\n  memset(h, 0, sizeof h);\n  queue< P > Q; ////spfa计算势h\n  fill(dis, dis + V, INF);\n  dis[s] = 0;\n  Q.push(P(0, s));\n  inq[s] = 1;\n  while (!Q.empty())\n  {\n    P p = Q.front();\n    Q.pop();\n    int v = p.se;\n    inq[v] = 0;\n    for (int i = head[v]; i != -1; i = ES[i].next)\n    {\n      EDGE &e = ES[i];\n      if (e.cap > 0 && dis[e.to] > dis[v] + e.cost + h[v] - h[e.to])\n      {\n        dis[e.to] = dis[v] + e.cost + h[v] - h[e.to];\n        prevv[e.to] = v;\n        preve[e.to] = i;\n        if (!inq[e.to])\n          Q.push(P(dis[e.to], e.to)), inq[e.to] = 1;\n      }\n    }\n  }\n  for (int v = 0; v < V; v++)\n    h[v] += dis[v];\n  while (f > 0)\n  {\n    priority_queue< P, vector< P >, greater< P > > Q; ////Dijkstra计算势h\n    fill(dis, dis + V, INF);\n    dis[s] = 0;\n    Q.push(P(0, s));\n    while (!Q.empty())\n    {\n      P p = Q.top();\n      Q.pop();\n      int v = p.se;\n      if (dis[v] < p.fs)\n        continue;\n      for (int i = head[v]; i != -1; i = ES[i].next)\n      {\n        EDGE &e = ES[i];\n        if (e.cap > 0 && dis[e.to] > dis[v] + e.cost + h[v] - h[e.to])\n        {\n          dis[e.to] = dis[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          Q.push(P(dis[e.to], e.to));\n        }\n      }\n    }\n    if (dis[t] == INF)\n      return -1;\n    for (int v = 0; v < V; v++)\n      h[v] += dis[v];\n    int d = f;\n    for (int v = t; v != s; v = prevv[v])\n      d = min(d, ES[preve[v]].cap);\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v])\n    {\n      EDGE &e = ES[preve[v]];\n      e.cap -= d;\n      ES[preve[v] ^ 1].cap += d;\n    }\n  }\n  return res;\n}\nvoid clear_G()\n{\n  eh = 0;\n  memset(head, -1, sizeof head);\n}\n\nconst int maxn = 1e4 + 300;\nint M, N, K;\nint a[maxn], w[maxn];\nint last[maxn];\nint tol;\nint hh;\nvoid build()\n{\n  for (int i = 1; i < hh; i++)\n  {\n    tol += w[a[i]];\n    if (last[a[i]])\n      addedge(last[a[i]], i - 1, 1, -w[a[i]]);\n    last[a[i]] = i;\n  }\n  for (int i = 1; i < hh - 1; i++)\n    addedge(i, i + 1, INF, 0);\n}\nint main()\n{\n  // freopen(\"/home/slyfc/CppFiles/in\", \"r\", stdin);\n  // freopen(\"/home/slyfc/CppFiles/out\",\"w\",stdout);\n  clear_G();\n  cin >> M >> N >> K;\n  for (int i = 1; i <= N; i++)\n    scanf(\"%d\", &w[i]);\n  for (int i = 1; i <= K; i++)\n    scanf(\"%d\", &a[i]);\n  hh = unique(a + 1, a + K + 1) - a;\n  build();\n  int ans = min_cost_flow(1, hh - 1, M - 1);\n  cout << tol + ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nint cost[max_k][max_k];\nint back_cost[max_k][max_k];\nint nbr[max_k][max_k];\nint num_nbr[max_k];\n\nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n\nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n\n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n\n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n\n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      for(j=MAX(i+1,initial);j<nxt;j++){        \n        nbr[i][(num_nbr[i])++] = j;\n        cost[i][j] = w[a[i]];\n      }\n      nbr[i][(num_nbr[i])++] = nxt;\n      cost[i][nxt] = 0;\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i][(num_nbr[i])++] = j;\n        cost[i][j] = 0;\n      }\n    }\n  }\n}\n\nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n  \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n  \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n  \n  while(1){\n    fill(dist,dist+K+1,INT_MAX);\n    for(i = 0;i<K-M;i++){\n      if(prev[i] != -1) continue;\n      dist[i] = 0;\n      que.push(P(0,i));\n    }\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == v) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][v] + (-cost[w][v]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][v] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    if(dist[t] == INT_MAX) return res;\n    for(i = 0;i < K-M;i++) h[i] += dist[i];\n    h[t] += dist[t];\n    \n    for(v=prev_mid[t],u=prev[t];true;v=prev_mid[u],u=prev[u]){\n      flow[u] = v;\n      used[v] = u;\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n}\n\nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n\nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL BASE = 10000LL * 10000LL * 100;\nconst LL INF = 1LL << 60;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow cap, flow;\n    Cost cost;\n    Edge *back;\n\n    Edge(int from, int to, Flow cap, Cost cost, Edge *back) : from(from), to(to), cap(cap), cost(cost), back(back) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    Edge<Flow,Cost> *ea = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    Edge<Flow,Cost> *eb = new Edge<Flow,Cost>(dst, src, 0, -d, ea);\n    ea->back = eb;\n    g[src].push_back(ea);\n    g[dst].push_back(eb);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow,Cost>\nprimal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, int max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> dist(N);\n    vector<Edge<Flow,Cost>*> prev(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        fill(prev.begin(), prev.end(), nullptr);\n        dist[src] = 0;\n\n        for(int turn = 0; turn < N; ++turn) {\n            bool updated = false;\n            for(int i = 0; i < N; ++i) {\n                for(auto *e : g[i]) {\n                    if(e->cap - e->flow > 0) {\n                        Cost nc = dist[e->from] + e->cost;\n                        if(nc < dist[e->to]) {\n                            dist[e->to] = nc;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(!updated) break;\n        }\n        if(prev[sink] == nullptr) break;\n\n        Flow aug = f;\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            aug = min(aug, e->cap - e->flow);\n        }\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            res.second += aug * e->cost;\n            e->flow += aug;\n            e->back->flow -= aug;\n        }\n        f -= aug;\n        res.first += aug;\n    }\n\n    return res;\n}\n\nbool solve() {\n    int M, N, K;\n    if(!(cin >> M >> N >> K)) return false;\n\n    vector<LL> ws(N);\n    vector<int> as(K);\n    vector<vector<Edge<int,LL>*>> graph(K*2+2);\n    const int SRC = K*2;\n    const int SINK = K*2+1;\n    for(int i = 0; i < N; ++i) {\n        cin >> ws[i];\n    }\n    for(int i = 0; i < K; ++i) {\n        cin >> as[i];\n        --as[i];\n    }\n    for(int i = 0; i < K; ++i) {\n        add_edge(graph, 2*i, 2*i+1, 1, -BASE);\n        // Edge to neighbor\n        if(i+1 < K) add_edge(graph, 2*i+1, 2*(i+1), 1, ws[as[i]]);\n        // Edge to next same number\n        auto it = find(as.begin()+i+1, as.end(), as[i]);\n        if(it != as.end()) {\n            add_edge(graph, 2*i+1, 2*(it-as.begin()), 1, 0LL);\n        }\n        // Edge to sink\n        add_edge(graph, 2*i+1, SINK, 1, ws[as[i]]);\n        // Edge from source\n        add_edge(graph, SRC, 2*i, 1, 0LL);\n    }\n    auto res = primal_dual(graph, SRC, SINK, M);\n    cout << res.second + BASE * K << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n \nusing namespace std;\ntypedef pair<int,int> P;\n \nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n \nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n \nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n \n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n \n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n \n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      if(M!=1){\n        for(j=MAX(i+1,initial);j<nxt;j++){        \n          nbr[i].push_back(j);\n          cost[i].push_back(w[a[i]]);\n          num_nbr[i]++;\n          if(j >= MAX(i+1,initial) + 6) break;\n        }\n        nbr[i].push_back(nxt);\n        num_nbr[i]++;\n        cost[i].push_back(0);\n      }\n      else{\n        nbr[i].push_back(i+1);\n        cost[i].push_back((nxt == i+1)? 0:w[a[i]]);\n        num_nbr[i]++;\n      }\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n  /*\n  for(i=0;i<K-M;i++)for(j=0;j<num_nbr[i];j++){\n    printf(\"cost[%d][%d]=%d\\n\",i,nbr[i][j],cost[i][j]);\n  }\n   */\n}\n \nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n   \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n   \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n \n  int cnt = 0;\n  for(int s=0;s<K-M;s++){\n    fill(dist,dist+K+1,INT_MAX);\n      dist[s] = 0;\n      que.push(P(0,s));\n//    printf(\"\\n%d-th loop\",++cnt);\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n//      printf(\"node %d established.\\n\",u);\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    for(i = 0;i < K-M;i++) h[i] += (dist[i] == INT_MAX)? 0:dist[i];\n    h[t] += (dist[t] == INT_MAX)? 0:dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n  return res;\n}\n \nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n \nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n \nusing namespace std;\ntypedef pair<int,int> P;\n \nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n \nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n \nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n \n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n \n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n \n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      for(j=MAX(i+1,initial);j<nxt;j++){        \n        nbr[i].push_back(j);\n        cost[i].push_back(w[a[i]]);\n        num_nbr[i]++;\n//        if(j > MAX(i+1,initial) + 10) break;\n      }\n      nbr[i].push_back(nxt);\n      num_nbr[i]++;\n      cost[i].push_back(0);\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n}\n \nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n   \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n   \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n \n  int cnt = 0;\n  for(int s=0;s<K-M;s++){\n    fill(dist,dist+K+1,INT_MAX);\n      dist[s] = 0;\n      que.push(P(0,s));\n//    printf(\"\\n%d-th loop\",++cnt);\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n//      printf(\"node %d established.\\n\",u);\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    for(i = 0;i < K-M;i++) h[i] += (dist[i] == INT_MAX)? 0:dist[i];\n    h[t] += (dist[t] == INT_MAX)? 0:dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n  return res;\n}\n \nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n \nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <iterator>\n\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int INF = 10000000;\n\ntypedef pair<int, int>P;\nstruct edge {int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()} );\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h+V, 0);\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (dist[v] < p.first) continue;\n      for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if (dist[t] == INF) {\n      return -1;\n    }\n    for (int v = 0; v < V; v++) h[v] += dist[v];\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nconst int MAX_N = 100000;\nint M, N, K;\nint w[MAX_N];\nvector<int> a[MAX_N];\n\nint main(){\n  int all_res = 0;\n  scanf(\"%d %d %d\", &M, &N, &K);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; i++) {\n    int j = 0;\n    scanf(\"%d\", &j);\n    a[j-1].push_back(i);\n    all_res += w[j-1];\n  }\n\n  int s = K, t = s + 1;\n  V = t + 1;\n  int res = 0;\n  add_edge(s, 0, M-1, 0);\n  add_edge(K - 1, t, M-1, 0);\n  for (int i =0; i + 1 < K; i++) {\n    add_edge(i, i + 1, INF, 0);\n  }\n  int NE = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < (int)a[i].size()-1; j++) {\n      if(a[i][j+1]- a[i][j]-1==0) {\n        res += w[i];\n      } else {\n        add_edge(a[i][j+1], a[i][j]+1, 1, w[i]);\n        add_edge(s, a[i][j+1], 1, 0);\n        add_edge(a[i][j]+1, t, 1, 0);\n        res -= w[i];\n        NE++;\n      }\n    }\n  }\n\n  res += min_cost_flow(s, t, M+NE-1);\n  printf(\"%d\\n\", all_res+res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n\nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n\nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n\n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n\n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n\n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      for(j=MAX(i+1,initial);j<nxt;j++){        \n        nbr[i].push_back(j);\n        cost[i].push_back(w[a[i]]);\n        num_nbr[i]++;\n        if(j > MAX(i+1,initial) + 3) break;\n      }\n      nbr[i].push_back(nxt);\n      num_nbr[i]++;\n      cost[i].push_back(0);\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n}\n\nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n  \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n  \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n\n  int cnt = 0;\n  while(1){\n    fill(dist,dist+K+1,INT_MAX);\n    for(i = 0;i<K-M;i++){\n      if(prev[i] != -1) continue;\n      dist[i] = 0;\n      que.push(P(0,i));\n    }\n//    printf(\"\\n%d-th loop\",++cnt);\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n//      printf(\"node %d established.\\n\",u);\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    if(dist[t] == INT_MAX) return res;\n    for(i = 0;i < K-M;i++) h[i] += dist[i];\n    h[t] += dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n}\n\nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n\nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M,V,K;\nconst int MAX_N = 10000,MAX_V = 20017;\nvector<int> A,W;\nvector<int> ball [MAX_N];\nstruct edge{\n\tint to,cap,rev;\n\tll cost;\n};\nvector<edge> G [MAX_V];\nll h [MAX_V],minCost [MAX_V];\nint prevv [MAX_V],preve [MAX_V];\nconst ll INF = 1e9,INFLL = 1e18;\n\ninline void add_edge(int from,int to,int cap,ll cost)\n{\n\tG [from].push_back(edge{to,cap,int(G [to].size()),cost});\n\tG [to].push_back(edge{from,0,int(G [from].size()) - 1,-cost});\n}\n\nll min_cost_flow(int s,int t,int f)\n{\n\tll res = 0;\n\tmemset(h,0,sizeof(h));\n\twhile(f > 0){\n\t\tfill(minCost,minCost + MAX_V,INFLL);\n\t\tpriority_queue< pair<ll,int>,vector< pair<ll,int> >,greater< pair<ll,int> > > pq;\n\t\tminCost [s] = 0;\n\t\tpq.push(make_pair(0ll,s));\n\t\twhile(pq.empty() == false){\n\t\t\tll cost = pq.top().first;\n\t\t\tint curr = pq.top().second;\n\t\t\tpq.pop();\n\n\t\t\tif(minCost [curr] < cost) continue;\n\t\t\tFOR(i,0,G [curr].size()){\n\t\t\t\tedge& e = G [curr] [i];\n\t\t\t\tif(e.cap > 0 && chmin(minCost [e.to],cost + e.cost + h [curr] - h [e.to])){\n\t\t\t\t\tprevv [e.to] = curr;\n\t\t\t\t\tpreve [e.to] = i;\n\t\t\t\t\tpq.push(make_pair(minCost [e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost [t] >= INFLL) return -1;\n\t\tFOR(i,0,V) h [i] += minCost [i];\n\t\tint d = f;\n\t\tfor(int v = t;v != s;v = prevv [v]){\n\t\t\tchmin(d,G [prevv [v]] [preve [v]].cap);\n\t\t}\n\t\tres += h [t] * d;\n\t\tf -= d;\n\t\tfor(int v = t;v != s;v = prevv [v]){\n\t\t\tedge& e = G [prevv [v]] [preve [v]];\n\t\t\te.cap -= d;\n\t\t\tG [e.to] [e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tW.assign(N,0);\n\tA.assign(K,0);\n\tFOR(i,0,N){\n\t\tscanf(\"%d\",&W [i]);\n\t}\n\tFOR(i,0,K){\n\t\tscanf(\"%d\",&A [i]);\n\t\tA [i]--;\n\t\tball [A [i]].push_back(i);\n\t}\n\n\tV = K * 2 + 2;\n\tint s = K * 2,t = K * 2 + 1;\n\tadd_edge(s,0,INF,0);\n\tadd_edge(K - 1,t,INF,INF);\n\tadd_edge(K * 2 - 1,t,1,0);\n\tFOR(i,0,K){\n\t\tadd_edge(i,i + K,1,W [A [i]]);\n\t\tif(i + 1 < K){\n\t\t\tadd_edge(i,i + 1,INF,INF);\n\t\t\tadd_edge(i + K,i + 1,1,0);\n\t\t}\n\t}\n\tFOR(i,0,N) FOR(j,1,ball [i].size()){\n\t\tint x = ball [i] [j - 1],y = ball [i] [j];\n\t\tadd_edge(x + K,y + K,1,(y - x - 1) * INF);\n\t}\n\n\tll ans = min_cost_flow(s,t,M) - INF * (M - 1) * K;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int INT_INF = 1 << 29;\nconst ll INF = 1LL<<55;\n\ntypedef pair<int, int> P;\nstruct edge {\n\tint to;\n\tint cap;\n\tll cost;\n\tint rev;\n};\n\nconst int MAX_V = 20010;\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, ll cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nll min_cost_flow(int s, int t, int f, bool bell = false) {\n\tll res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\tif (bell) {\n\t\t\tbell = false;\n\t\t\tbool update;\n\t\t\tdo {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 10010, MAX_K = 10010;\n\nint main(int argc, char *argv[]) {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tint w[MAX_N];\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tint a[MAX_K], r = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t\tr+= w[a[i]];\n\t}\n\tint b[MAX_N];\n\tfill_n(b, MAX_N, -1);\n\tfor (int i = 0; i < K; i++) {\n\t\tadd_edge(i, i+1, INT_INF, 0);\n\t\tif (b[a[i]] != -1) {\n\t\t\tadd_edge(b[a[i]], i, 1, -w[a[i]]);\n\t\t}\n\t\tb[a[i]] = i+1;\n\t}\n\tV = K+1;\n\tprintf(\"%lld\\n\", r + min_cost_flow(0, K, M-1, true));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10005\ntypedef pair<int,int> P; //firstは最短距離、secondは頂点の番号\n\n//辺を表す構造体{行先、容量、コスト、逆辺のインデックス}\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nint N,M,K;\nint weight[NUM],ball_array[NUM];\nint index_table[NUM];\nvector<int> LOC[NUM];\n\n\nint V; //頂点数\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint h[NUM]; //ポテンシャル\nint dist[NUM]; //最短距離\nint pre_node[NUM],pre_edge[NUM]; //直前の頂点と辺\n\n//fromからtoへ向かう容量capacity,コストcostの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\n//sourceからsinkへの、流量flowの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)h[i] = 0; //ポテンシャルを0にする\n\twhile(flow > 0){\n\t\t//ダイクストラ法を用いてhを更新する\n\t\tpriority_queue<P,vector<P>,greater<P>> Q;\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tQ.push(P(0,source));\n\n\t\twhile(!Q.empty()){\n\t\t\tP p = Q.top();\n\t\t\tQ.pop();\n\t\t\tint node_id = p.second;\n\t\t\tif(dist[node_id] < p.first)continue; //最短でなければSKIP\n\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost+h[node_id]-h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost+h[node_id]-h[e.to];\n\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\tQ.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\t//これ以上流せない\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor(int node_id = 0; node_id < V; node_id++)h[node_id] += dist[node_id];\n\n\t\t//source-sink間最短路に沿って目いっぱい流す\n\t\tint tmp_flow = flow;\n\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*h[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n\nint main(){\n\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&weight[i]);\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d\",&ball_array[i]);\n\t\tball_array[i]--;\n\n\t\tLOC[ball_array[i]].push_back(i); //ボールを投入する必要のある時刻の配列\n\t\tans += weight[ball_array[i]];\n\t}\n\n\tint source = 0,sink = 1,index = 2;\n\t//時刻0～K-1に、ノード番号を割り当てる\n\tfor(int i = 0; i < K; i++){\n\t\tindex_table[i] = index++;\n\t}\n\n\tadd_edge(source,index_table[0],M,0);\n\n\t//時刻ノード同士を、十分大きな容量かつコスト0の辺で結ぶ\n\tfor(int i = 0; i < K-1; i++){\n\t\tadd_edge(index_table[i],index_table[i+1],M,0);\n\t}\n\n\tadd_edge(index_table[K-1],sink,M,0);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(LOC[i].size() <= 1)continue; //入れない、または1回しか入れないボールは無視\n\n\t\tfor(int a = 0; a < LOC[i].size()-1; a++){\n\t\t\tif(LOC[i][a]+1 == LOC[i][a+1]){ //入れる時刻が連続している場合\n\t\t\t\tans -= weight[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tadd_edge(index_table[LOC[i][a]+1],index_table[LOC[i][a+1]],1,-weight[i]);\n\t\t}\n\t}\n\n\tV = index;\n\n\t//★★時刻→時刻に、必ず[今入れたばかりの球]が存在するので、区間の重なりはM-1まで★★\n\tans += min_cost_flow(source,sink,M-1);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long LL;\nconst LL INF = 1LL << 59;\n \ntemplate<class Flow, class Cost>\nstruct Edge\n{\n\tint from, to;\n\tFlow cap, flow;\n\tCost cost;\n\tEdge *back;\n \n\tEdge(int from, int to, Flow cap, Cost cost, Edge *back)\n\t\t: from(from), to(to), cap(cap), flow(0), cost(cost), back(back)\n\t{}\n};\n \ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost> *>> &g, int src, int dst, Flow c, Cost d)\n{\n\tEdge<Flow, Cost> *ea = new Edge<Flow, Cost>(src, dst, c, d, nullptr);\n\tEdge<Flow, Cost> *eb = new Edge<Flow, Cost>(dst, src, 0, -d, ea);\n\tea->back = eb;\n\tg[src].push_back(ea);\n\tg[dst].push_back(eb);\n}\n \ntemplate<class Flow, class Cost>\npair<Flow, Cost> primal_dual(vector<vector<Edge<Flow, Cost> *>> &g, int src, int sink, Flow max_flow)\n{\n\tconst int N = g.size();\n\tpair<Flow, Cost> res;\n\tvector<Cost> dist(N);\n\tvector<Edge<Flow, Cost> *> prev(N);\n\tfor (Flow f = max_flow; f > 0;)\n\t{\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tfill(prev.begin(), prev.end(), nullptr);\n\t\tdist[src] = 0;\n \n\t\twhile (true)\n\t\t{\n\t\t\tbool updated = false;\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t{\n\t\t\t\tfor (auto *e : g[i])\n\t\t\t\t{\n\t\t\t\t\tif (e->cap - e->flow > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tCost nc = dist[e->from] + e->cost;\n\t\t\t\t\t\tif (nc < dist[e->to])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdist[e->to] = nc;\n\t\t\t\t\t\t\tprev[e->to] = e;\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!updated)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (prev[sink] == nullptr)\n\t\t\tbreak;\n \n\t\tFlow aug = f;\n\t\tfor (auto *e = prev[sink]; e; e = prev[e->from])\n\t\t{\n\t\t\taug = min(aug, e->cap - e->flow);\n\t\t}\n\t\tfor (auto *e = prev[sink]; e; e = prev[e->from])\n\t\t{\n\t\t\tres.second += aug * e->cost;\n\t\t\te->flow += aug;\n\t\t\te->back->flow -= aug;\n\t\t}\n\t\tf -= aug;\n\t\tres.first += aug;\n\t}\n \n\treturn res;\n}\n \nbool solve()\n{\n\tint M, N, K;\n\tif (!(cin >> M >> N >> K))\n\t\treturn false;\n \n\tvector<LL> ws(N);\n\tvector<int> as;\t// 数字序列\n\tvector<vector<Edge<int, LL> *>> graph(K + 2);\n\tconst int SRC = K;\n\tconst int SINK = K + 1;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tcin >> ws[i];\n\t}\n\tLL sum = 0;\t// 总权重\n\tfor (int i = 0; i < K; ++i)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\t--a;\n\t\tif (as.size() > 0 && as.back() == a)\n\t\t{\n\t\t\t// do nothing 排除连续相同的序号\n\t\t}\n\t\telse\n\t\t{\n\t\t\tas.push_back(a);\n\t\t\tsum += ws[a];\n\t\t}\n\t}\n\tconst int L = as.size();\n\tfor (int i = 0; i < L; ++i)\n\t{\n\t\t// Edge to neighbor\n\t\tif (i + 1 < L)\n\t\t{\n\t\t\tadd_edge(graph, i, i + 1, M, 0LL);\t// v[t] -(∞/0)-> v[t+1]\n\t\t}\n\t\t// Edge to next same number\n\t\tauto it = find(as.begin() + i + 1, as.end(), as[i]);\n\t\tif (it != as.end())\n\t\t{\n\t\t\tadd_edge(graph, i + 1, it - as.begin(), 1, -ws[as[i]]);\t// v[t+1] -(1/-w[v[t]])-> v[t']\n\t\t}\n\t}\n\tadd_edge(graph, SRC, 0, M, 0LL);\n\tadd_edge(graph, L - 1, SINK, M, 0LL);\n\tauto res = primal_dual(graph, SRC, SINK, M - 1);\n\tcout << sum + res.second << endl;\n\treturn true;\n}\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n \n\twhile (solve());\n#ifndef ONLINE_JUDGE\n\tfclose(stdin);\n\tfclose(stdout);\n\tsystem(\"out.txt\");\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef long long LL;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=10010;\nint V,dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update=1;\n        while(update){\n            update=0;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=1;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF)return -1;\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d; \n        }\n    }return res;\n}\nvoid clear(){for(int i=0;i<=V;i++)G[i].clear();}\nconst int MAX_N=10010;\nint M,N,K,w[MAX_N],lst[MAX_N],a[MAX_N];\nint solve(){\n    for(int i=1;i<=N;i++)scanf(\"%d\",&w[i]);\n    for(int i=1;i<=K;i++)scanf(\"%d\",&a[i]);\n    int cnt=unique(a+1,a+K+1)-(a+1);\n    int res=0;\n    memset(lst,0,sizeof(lst));\n    V=cnt+1; clear();\n    for(int i=1;i<=cnt;i++){\n        res+=w[a[i]];\n        if(lst[a[i]])add_edge(lst[a[i]],i-1,1,-w[a[i]]);\n        lst[a[i]]=i;\n    }for(int i=1;i<cnt;i++)add_edge(i,i+1,INF,0);\n    printf(\"%d\\n\",res+min_cost_flow(1,cnt,M-1));\n}\nint main(){\n    while(~scanf(\"%d%d%d\",&M,&N,&K))solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n \nusing namespace std;\ntypedef pair<int,int> P;\n \nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n \nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n \nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n \n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n \n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n \n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      if(M!=1){\n        for(j=MAX(i+1,initial);j<nxt;j++){        \n          nbr[i].push_back(j);\n          cost[i].push_back(w[a[i]]);\n          num_nbr[i]++;\n          if(j >= MAX(i+1,initial) + 10) break;\n        }\n        nbr[i].push_back(nxt);\n        num_nbr[i]++;\n        cost[i].push_back(0);\n      }\n      else{\n        nbr[i].push_back(i+1);\n        cost[i].push_back((nxt == i+1)? 0:w[a[i]]);\n        num_nbr[i]++;\n      }\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n  /*\n  for(i=0;i<K-M;i++)for(j=0;j<num_nbr[i];j++){\n    printf(\"cost[%d][%d]=%d\\n\",i,nbr[i][j],cost[i][j]);\n  }\n   */\n}\n \nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k+1];\n  static priority_queue<P, vector<P>, greater<P> > que;\n   \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n   \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,(K+1)*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n \n  int cnt = 0;\n  for(int s=0;s<K-M;s++){\n    fill(dist,dist+K+1,INT_MAX);\n      dist[s] = 0;\n      que.push(P(0,s));\n//    printf(\"\\n%d-th loop\",++cnt);\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n//      printf(\"node %d established.\\n\",u);\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    for(i = 0;i < K-M;i++) h[i] += (dist[i] == INT_MAX)? 0:dist[i];\n    h[t] += (dist[t] == INT_MAX)? 0:dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n  return res;\n}\n \nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n \nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n\nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n\nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n\n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n\n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n\n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      for(j=MAX(i+1,initial);j<nxt;j++){        \n        nbr[i].push_back(j);\n        cost[i].push_back(w[a[i]]);\n        num_nbr[i]++;\n      }\n      nbr[i].push_back(nxt);\n      num_nbr[i]++;\n      cost[i].push_back(0);\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n}\n\nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n  \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n  \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n  \n  while(1){\n    fill(dist,dist+K+1,INT_MAX);\n    for(i = 0;i<K-M;i++){\n      if(prev[i] != -1) continue;\n      dist[i] = 0;\n      que.push(P(0,i));\n    }\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    if(dist[t] == INT_MAX) return res;\n    for(i = 0;i < K-M;i++) h[i] += dist[i];\n    h[t] += dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n}\n\nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n\nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = long long;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\ntypedef long long ll;\nll w[10000];\nvector<ll> id[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tid[a - 1].push_back(i);\n\t\tsum += w[a - 1];\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, M, 0);\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < (int)id[i].size() - 1; j++) {\n\t\t\t//cout << id[i][j] + 1 + 1 << \" \" << id[i][j + 1] + 1 << \" \" << -w[i] << endl;\n\t\t\tpd.add_edge(id[i][j] + 1, id[i][j + 1], 1, -w[i]);\n\t\t}\n\t}\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n  \ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, to, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, to, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f){\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 200000000;\n  \n  while(f > 0){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    \n    bool update = true;\n    \n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n\tif(dist[v] == inf) continue;\n\tfor(int i = 0; i < (int)g[v].size(); i++){\n\t  E &e = g[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t    dist[e.to]  = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update      = true;\n\t  }\n\t}\n      }\n    }\n    \n      return -1;\n    }\n    \n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n    \n    f   -= d;\n    res += d * dist[t];\n    // printf(\"f:%d res:%d\\n\", f, res);\n    \n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap           -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m = getInt();\n  int n = getInt();\n  int k = getInt();\n\n  vector<int> w(n);\n  vector<int> a(k);\n\n  Graph<CostEdge> g(k);\n\n  REP(i,n) w[i] = getInt();\n  REP(i,k) a[i] = getInt() - 1;\n\n  int ans = 0;\n  REP(i,k) ans += w[a[i]];\n  // printf(\"%d\\n\", ans);\n\n  vector<int> prevs(n, -1);\n\n  REP(i,k){\n    if(i != k - 1) g.addEdge(i, i + 1, 10000, 0);\n    int aa = a[i];\n    if(prevs[aa] != -1){\n      int j = prevs[aa];\n      if(j + 1 == i){\n\tans -= w[a[i]];\n      }else{\n\tg.addEdge(j + 1, i, 1, - w[a[i]]);\n\t// printf(\"%d => %d : %d\\n\", j + 2, i + 1, - w[aa]);\n      }\n    }\n    prevs[aa] = i;\n  }\n\n  ans += minCostFlow(g, 0, k - 1, m - 1);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\n\nstruct edge { int to, cap, cost, rev;};\n\nconst int MAX_V = 1000000;\nconst int MAX_N = 1000000;\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].push_back((edge){to, cap, cost, G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h, h + V, 0);\n    while(f > 0){\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(pii(0, s));\n        while(!que.empty()){\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(int i = 0; i < G[v].size(); i++){\n                edge &e = G[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[t] == INF) return -1;\n        for(int v = 0; v < V; v++) h[v] += dist[v];\n        int d = f;\n        for(int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d * h[t];\n        for(int v = t; v != s; v = prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint N, K;\nint a[MAX_N], b[MAX_N], w[MAX_N];\nvi wb, ab;\n\nvoid solve(){\n    vi x;\n    rep(i, N){\n\tx.pb(a[i]);\n\tx.pb(b[i]);\n    }\n    sort(all(x));\n    UNIQUE(x);\n    \n    int m = x.size();\n    int s = m, t = s + 1;\n    V = t + 1;\n    int res = 0;\n    add_edge(s, 0, K, 0);\n    add_edge(m - 1, t, K, 0);\n    for(int i = 0; i + 1 < m; i++){\n\tadd_edge(i, i + 1, INF, 0);\n    }\n    rep(i,N){\n\tint u = find(all(x), a[i]) - x.begin();\n\tint v = find(all(x), b[i]) - x.begin();\n\tadd_edge(v, u, 1, w[i]);\n\tadd_edge(s, v, 1, 0);\n\tadd_edge(u, t, 1, 0);\n\tres -= w[i];\n    }\n\n    res += min_cost_flow(s, t, K + N);\n    rep(i,ab.size()) res += wb[ab[i]];\n    cout << res << endl;\n}\n\nvoid input(){\n    int m, n, k;\n    cin >> m >> n >> k;\n    rep(i,n){\n\tint t;\n\tcin >> t;\n\twb.pb(t);\n    }\n    rep(i,k){\n\tint t;\n\tcin >> t;\n\tt--;\n\tab.pb(t);\n    }\n    //UNIQUE(ab);\n    int tmp[MAX_N];\n    memset(tmp, -1, sizeof(tmp));\n    int cnt = 0;\n    rep(i,k){\n\tif(tmp[ab[i]] != -1){\n\t    a[cnt] = tmp[ab[i]] + 1;\n\t    b[cnt] = i;\n\t    w[cnt] = wb[ab[i]];\n\t    cnt++;\n\t}\n\ttmp[ab[i]] = i;\n    }\n    N = cnt;\n    K = m - 1;\n/*\n    rep(i,cnt){\n\tcout << a[i] << ' ' << b[i] << ' ' << w[i] << endl;\n    }\n*/\n}\n\nint main() {\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<ll,int>;\n\n// (?????????, ??????, ?????????, ??????)\nstruct edge{ int to,cap,cost,rev; };\n\nint V; // TODO:initialize\nconst int MAX_V = 30303; // TODO:initialize\nconst ll INF = LLONG_MAX/5; // TODO:initialize\nvector<edge> G[MAX_V];\nll h[MAX_V]; // ??????????????£???\nll dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,(int)G[to].size()});\n    G[to].pb({from,0,-cost,(int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???(???????????????-1)\nll min_cost_flow(int s, int t, int f){\n    ll res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        // dijkstra??§h?????´??°\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        pq.push(pi(0,s));\n        while(!pq.empty()){\n            pi p = pq.top();\n            pq.pop();\n            int v = p.se;\n            if(p.fi>dist[v]) continue;\n            rep(i,G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    pq.push(pi(dist[e.to],e.to));\n                }\n            }\n        }\n\n        // ????????\\???????????????\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t???????????????????????£??????????????????\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nconst ll M=19191919;\n\nvector<int> num[10000];\n\nint main()\n{\n    int F,n,k;\n    scanf(\" %d %d %d\", &F, &n, &k);\n    vector<int> w(n),a(k);\n    rep(i,n) scanf(\" %d\", &w[i]);\n    rep(i,k)\n    {\n        scanf(\" %d\", &a[i]);\n        --a[i];\n        num[a[i]].pb(i);\n    }\n\n    V = 3*k+2;\n    int S=3*k, T=S+1;\n    add_edge(S,0,F,0);\n\n    rep(i,k)\n    {\n        add_edge(3*i,3*i+1,1,w[a[i]]);\n        add_edge(3*i+1,3*i+2,1,-M);\n        if(i<k-1)\n        {\n            add_edge(3*i+2,3*(i+1),1,0);\n            add_edge(3*i,3*(i+1),F,0);\n        }\n    }\n\n    rep(i,n)\n    {\n        int SZ = num[i].size();\n        if(SZ<2) continue;\n        rep(j,SZ-1)\n        {\n            int u=num[i][j], v=num[i][j+1];\n            add_edge(3*u+2,3*v+1,1,0);\n        }\n    }\n\n    add_edge(3*k-3,T,F,0);\n    add_edge(3*k-1,T,F,0);\n\n    printf(\"%lld\\n\", min_cost_flow(S,T,F)+M*k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<string>\n#include<assert.h>\n#include<math.h>\n#include<stdio.h>\n#include<ctype.h>\n#endif\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define DEBUG if(0)\n#endif\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r) { bool a = l>r; if (a)l = r; return a; }\ntemplate <typename T>inline bool chmax(T &l, T r) { bool a = l<r; if (a)l = r; return a; }\n\nstruct input {\n\tbool success;\n\tinput(){success = true;}\n#ifdef BTK\n\ttemplate<typename T>inline input& operator>>(T& x) {success = !!(cin >> x);return *this;}\n#else\n\tinline input& operator>>(LL& x) {success = (scanf(\"%lld\", &x) != EOF);return *this;}\n\tinline input& operator>>(int& x) {success = (scanf(\"%d\", &x) != EOF);return *this;}\n\tinline input& operator>>(char* x) {success = (scanf(\"%s\", x) != EOF);return *this;}\n\tinline input& operator>>(double& x) {success = (scanf(\"%llf\", &x) != EOF);return *this;}\n#endif\n}in;\n\nconst char space = ' ';\nconst char ln = '\\n';\nstruct output {\n#ifdef BTK\n\ttemplate<typename T>inline output& operator<<(T x) {cout << x; return (*this);}\n\tinline void fp(const double x, const char* s) { char buf[20];sprintf(buf, s, x); cout << buf;}\n#else\n\tinline output& operator<<(const string& x) { printf(\"%s\", x.c_str()); return *this; }\n\tinline output& operator<<(const int x) { printf(\"%d\", x); return *this;}\n\tinline output& operator<<(const char x) { putchar(x); return *this;}\n\tinline output& operator<<(const LL x) { printf(\"%lld\", x); return *this;}\n\tinline output& operator<<(const double x) { printf(\"%lf\", x); return *this;}\n\tinline void fp(const double x, const char* s) {printf(s, x);}\n#endif\n}out;\ntypedef int FLOW;\ntypedef LL COST;\nnamespace MinCostFlow {\n\tconst FLOW FLOW_INF = 1e7;\n\tconst COST COST_INF = 1e15;\n\tstruct edge {\n\t\tFLOW flow; COST cost;\n\t\tint to, rev;\n\t};\n\ttypedef vector<edge> E;\n\ttypedef vector<E> Graph;\n\tvoid addedge(Graph&g, int from, int to, FLOW f, COST c) {\n\t\tint x = g[from].size();\n\t\tint y = g[to].size();\n\t\tedge a = { f,c,to,y };\n\t\tedge b = { (FLOW)0,-c,from,x };\n\t\tg[from].push_back(a);\n\t\tg[to].push_back(b);\n\t}\n\n\tconst int BUF = 11234;\n\tCOST h[BUF];\n\tCOST d[BUF];\n\tint pV[BUF];\n\tint pE[BUF];\n\tvoid init(int size = BUF) {\n\t\tREP(i, size)h[i] = 0;\n\t}\n\ttypedef pair<COST, int> P;\n\tpriority_queue<P> que;\n}\n\n\n\npair<FLOW, COST> maxflow(MinCostFlow::Graph &g, int s, int t, bool init = true) {\n\tconst int V = g.size();\n\tif (init)MinCostFlow::init();\n\tusing namespace MinCostFlow;\n\tCOST c = 0;\n\tFLOW f = 0;\n\twhile (true) {\n\t\tfill(d, d + V, COST_INF);\n\t\td[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (que.size()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tCOST cost = -p.first;\n\t\t\tint v = p.second;\n\t\t\tif (d[v]<cost)continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tedge &e = g[v][i];\n\t\t\t\tif (e.flow>0 && d[e.to]>d[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\td[e.to] = d[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tpV[e.to] = v;\n\t\t\t\t\tpE[e.to] = i;\n\t\t\t\t\tque.push(P(-d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t] == COST_INF)break;\n\n\t\tREP(v, V)h[v] += d[v];\n\t\tFLOW ff = FLOW_INF;\n\t\tfor (int v = t; v != s; v = pV[v]) {\n\t\t\tedge& e = g[pV[v]][pE[v]];\n\t\t\tchmin(ff, e.flow);\n\t\t}\n\t\tf += ff;\n\t\tc += ff*h[t];\n\t\tfor (int v = t; v != s; v = pV[v]) {\n\t\t\tedge &e = g[pV[v]][pE[v]];\n\t\t\te.flow -= ff;\n\t\t\tg[v][e.rev].flow += ff;\n\t\t}\n\t}\n\treturn pair<FLOW, COST>(f, c);\n}\n\nint w[112345];\nint pos[112345];\nint main() {\n\tint M, N, K;\n\tin >> M >> N >> K;\n\tM--;\n\tREP(i, N)in >> w[i];\n\tREP(i, N)pos[i] = -1;\n\tint V = K + 1;\n\tint S = V++;\n\tint T = V++;\n\tint s = 0;\n\tint t = K;\n\tMinCostFlow::Graph g(V);\n\tREP(i, K)MinCostFlow::addedge(g, i, i + 1, M, 0);\n\tMinCostFlow::addedge(g, S, s, M, 0);\n\tMinCostFlow::addedge(g, t, T, M, 0);\n\tLL tot = 0;\n\tLL cost = 0;\n\tREP(i, K) {\n\t\tint a;\n\t\tin >> a;\n\t\ta--;\n\t\ttot += w[a];\n\t\tif (pos[a] != -1&&pos[a]!=i) {\n\t\t\tMinCostFlow::addedge(g, S, i, 1, 0);\n\t\t\tMinCostFlow::addedge(g, i, pos[a], 1, w[a]);\n\t\t\tMinCostFlow::addedge(g, pos[a], T, 1, 0);\n\t\t\tcost += w[a];\n\t\t}\n\t\tif (pos[a] != i)tot -= w[a];\n\t\tpos[a] = i + 1;\n\t}\n\tpair<FLOW, COST> fc = maxflow(g, S, T);\n\tcost += fc.second;\n\tout << tot + cost<<ln;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <set>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#define INF 0x3f3f3f3f\n#define EPS 10e-5\n#define MAX_N 10010\n#define MAX_K 10010\n\nint lrsheet[MAX_N],lra[MAX_N],ks[MAX_N],wi[MAX_N];\n\n//1 ≤ M ≤ 10\n//1 ≤ N ≤ 104\n//1 ≤ K ≤ 104\n//1 ≤ wi ≤ 104\n//1 ≤ aj ≤ N\n\nconst int dx[]={-1,0,0,1,0},dy[]={0,1,-1,0,0};\nusing namespace std;\n\nint m,n,k;\nint vCnt;\n\n#define pb push_back\n#define PB pop_back\n#define bk back()\n#define fs first\n#define se second\n#define sq(x) (x)*(x)\n#define eps (1e-10)\n#define INF (1000000300)\n#define clr(x) memset((x),0,sizeof (x))\n#define cp(a,b) memcpy((a),(b),sizeof (b))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<ll,int> D;\n\n\nconst int MAXV=1e4+300;\nint V;\nconst int s=MAXV-1,t=MAXV-2;\nstruct EDGE{\n    int to,cap,cost,next;\n}ES[MAXV*10];\nint eh;\nint h[MAXV];\nint dis[MAXV];\nint prevv[MAXV],preve[MAXV];\nint head[MAXV];\nvoid addedge(int from,int to,int cap,int cost){\n    ES[eh].to=to;ES[eh].cap=cap;ES[eh].cost=cost;\n    ES[eh].next=head[from];head[from]=eh++;\n    ES[eh].to=from;ES[eh].cap=0;ES[eh].cost=-cost;\n    ES[eh].next=head[to];head[to]=eh++;\n}\nbool inq[MAXV];\nll min_cost_flow(int s,int t,int f){\n    V=MAXV;//default V size maxed\n    ll res=0;\n    memset(h,0,sizeof h);\n    queue<P> Q;////spfa计算势h\n    fill(dis,dis+V,INF);\n    dis[s]=0;\n    Q.push(P(0,s));\n    inq[s]=1;\n    while(!Q.empty()){\n        P p=Q.front();Q.pop();\n        int v=p.se;\n        inq[v]=0;\n        for(int i=head[v];i!=-1;i=ES[i].next){\n            EDGE &e=ES[i];\n            if(e.cap>0&&dis[e.to]>dis[v]+e.cost+h[v]-h[e.to]){\n                dis[e.to]=dis[v]+e.cost +h[v]-h[e.to];\n                prevv[e.to]=v;\n                preve[e.to]=i;\n                if(!inq[e.to]) Q.push(P(dis[e.to],e.to)),inq[e.to]=1;\n            }\n        }\n    }\n    for(int v=0;v<V;v++)\n        h[v]+=dis[v];\n    while(f>0){\n        priority_queue<P,vector<P> ,greater<P> >Q;////Dijkstra计算势h\n        fill(dis,dis+V,INF);\n        dis[s]=0;\n        Q.push(P(0,s));\n        while(!Q.empty()){\n            P p=Q.top();Q.pop();\n            int v=p.se;\n            if(dis[v]<p.fs) continue;\n            for(int i=head[v];i!=-1;i=ES[i].next){\n                EDGE &e=ES[i];\n                if(e.cap>0&&dis[e.to]>dis[v]+e.cost+h[v]-h[e.to]){\n                    dis[e.to]=dis[v]+e.cost +h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    Q.push(P(dis[e.to],e.to));\n                }\n            }\n        }\n        if(dis[t]==INF) return -1;\n        for(int v=0;v<V;v++) h[v]+=dis[v];\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v])\n            d=min(d,ES[preve[v]].cap);\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            EDGE &e=ES[preve[v]];\n            e.cap-=d;\n            ES[preve[v]^1].cap+=d;\n        }\n    }\n    return res;\n}\nvoid clear_G(){\n    eh=0;\n    memset(head,-1,sizeof head);\n}\n\n\n\nint main()\n{\n//    ios::sync_with_stdio(false);\n//    cin.tie(0);cout.tie(0);\n    while(~scanf(\"%d%d%d\",&m,&n,&k)){\n      for(int i=0;i<n;++i)scanf(\"%d\",wi+i);\n\n      for(int i=0;i<k;++i){\n          scanf(\"%d\",ks+i);--ks[i];\n      }\n\n      k= unique(ks,ks+k) - ks;\n      int s = k,t = k+1,S= t+1,T=S+1;\n\n      clear_G();\n\n      memset(lrsheet,-1,sizeof(lrsheet));\n      int sums=0;\n      for(int i=k-1;i>=0;--i){\n            lra[i] = i;\n            swap(lrsheet[ks[i]],lra[i]);\n            sums += wi[ks[i]];\n      }\n\n\n      for(int i=0;i<k;++i){\n        if(i+1<k) addedge(i,i+1,INF,0);\n        if(lra[i]!=-1){\n          addedge(i,lra[i]-1,1,-wi[ks[i]]);\n        }\n      }\n\n      //add_edge(s,0,m-1,0);\n      //add_edge(k-1,t,m-1,0);\n\n      int res = min_cost_flow(0,k-1,m-1);\n\n      printf(\"%d\\n\",sums+res);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int MAX_N = 10000;\nconst int MAX_K = 10000;\nconst int MAX_V = MAX_K + 2;\nconst int INF = 1<<29;\n\nint M, N, K;\nint ws[MAX_N];\nvector<int> as;\nvector<int> ts[MAX_N];\n\ntypedef pair<int, int> P;\nstruct edge{ int to, cap, cost, rev; };\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\tfill(h, h+V, 0);\n\twhile(f > 0){\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v] < p.first) continue;\n\t\t\tfor(int i=0; i<G[v].size(); i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v = 0; v<V; v++) h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor(int v=t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor(int v=t; v!=s; v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint solve(){\n\tint tot = 0, cnt = 0, sub = 0;\n\n\tfor(int i=0; i<K; i++){\n\t\tts[as[i]].push_back(i);\n\t}\n\n\tconst int source = K, sink = K + 1;\n\tV = sink + 1;\n\n\tadd_edge(source, 0, M-1, 0);\n\tadd_edge(K-1, sink, M-1, 0);\n\tfor(int i=0; i+1<K; i++){\n\t\tadd_edge(i, i+1, INF, 0);\n\t}\n\n\tfor(int i=0; i<N; i++){\n\t\ttot += ws[i] * ts[i].size();\n\t\tfor(int j=0; j+1 < (int)ts[i].size(); j++){\n\t\t\tadd_edge(ts[i][j+1], ts[i][j]+1, 1, ws[i]);\n\t\t\tadd_edge(source, ts[i][j+1], 1, 0);\n\t\t\tadd_edge(ts[i][j]+1, sink, 1, 0);\n\t\t\tcnt++;\n\t\t\tsub -= ws[i];\n\t\t}\n\t}\n\n\treturn tot + (min_cost_flow(source, sink, M-1 + cnt) + sub);\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tfor(int i=0; i<N; i++){\n\t\tscanf(\"%d\", ws+i);\n\t}\n\tfor(int i=0; i<K; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tas.push_back(x - 1);\n\t}\n\n\tas.erase(unique(as.begin(), as.end()), as.end());\n\tK = as.size();\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n  \ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f){\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 200000000;\n  \n  while(f > 0){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    \n    bool update = true;\n    \n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n\tif(dist[v] == inf) continue;\n\tfor(int i = 0; i < (int)g[v].size(); i++){\n\t  E &e = g[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t    dist[e.to]  = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update      = true;\n\t  }\n\t}\n      }\n    }\n    \n    if(dist[t] == inf){\n      return -1;\n    }\n    \n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n    \n    f   -= d;\n    res += d * dist[t];\n    \n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap           -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m = getInt();\n  int n = getInt();\n  int k = getInt();\n\n  vector<int> w(n);\n  vector<int> a(k);\n\n  Graph<CostEdge> g(k);\n\n  REP(i,n) w[i] = getInt();\n  REP(i,k) a[i] = getInt() - 1;\n\n  int ans = 0;\n  REP(i,k) ans += w[a[i]];\n\n  vector<int> prevs(n, -1);\n\n  REP(i,k){\n    if(i != k - 1) g.addEdge(i, i + 1, 10000, 0);\n    int aa = a[i];\n    if(prevs[aa] != -1){\n      int j = prevs[aa];\n      if(j + 1 == i){\n\tans -= w[a[i]];\n      }else{\n\tg.addEdge(j + 1, i, 1, - w[a[i]]);\n      }\n    }\n    prevs[aa] = i;\n  }\n\n  ans += minCostFlow(g, 0, k - 1, m - 1);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\n\nstruct edge { int to, cap, cost, rev;};\n\nconst int MAX_V = 1000000;\nconst int MAX_N = 1000000;\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].push_back((edge){to, cap, cost, G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h, h + V, 0);\n    while(f > 0){\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(pii(0, s));\n        while(!que.empty()){\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(int i = 0; i < G[v].size(); i++){\n                edge &e = G[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[t] == INF) return -1;\n        for(int v = 0; v < V; v++) h[v] += dist[v];\n        int d = f;\n        for(int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d * h[t];\n        for(int v = t; v != s; v = prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint N, K;\nint a[MAX_N], b[MAX_N], w[MAX_N];\nvi wb, ab;\n\nvoid solve(){\n    vi x;\n    rep(i, N){\n\tx.pb(a[i]);\n\tx.pb(b[i]);\n    }\n    sort(all(x));\n    UNIQUE(x);\n    \n    int m = x.size();\n    int s = m, t = s + 1;\n    V = t + 1;\n    int res = 0;\n    add_edge(s, 0, K, 0);\n    add_edge(m - 1, t, K, 0);\n    for(int i = 0; i + 1 < m; i++){\n\tadd_edge(i, i + 1, INF, 0);\n    }\n    rep(i,N){\n\tint u = find(all(x), a[i]) - x.begin();\n\tint v = find(all(x), b[i]) - x.begin();\n\tadd_edge(v, u, 1, w[i]);\n\tadd_edge(s, v, 1, 0);\n\tadd_edge(u, t, 1, 0);\n\tres -= w[i];\n    }\n\n    res += min_cost_flow(s, t, K + N);\n    rep(i,ab.size()) res += wb[ab[i]];\n    cout << res << endl;\n}\n\nvoid input(){\n    int m, n, k;\n    cin >> m >> n >> k;\n    rep(i,n){\n\tint t;\n\tcin >> t;\n\twb.pb(t);\n    }\n    rep(i,k){\n\tint t;\n\tcin >> t;\n\tt--;\n\tab.pb(t);\n    }\n    UNIQUE(ab);\n    int tmp[MAX_N];\n    memset(tmp, -1, sizeof(tmp));\n    int cnt = 0;\n    rep(i,k){\n\tif(tmp[ab[i]] != -1){\n\t    a[cnt] = tmp[ab[i]];\n\t    b[cnt] = i - 1;\n\t    w[cnt] = wb[ab[i]];\n\t    cnt++;\n\t}\n\ttmp[ab[i]] = i;\n    }\n    N = cnt;\n    K = m - 1;\n/*\n    rep(i,cnt){\n\tcout << a[i] << ' ' << b[i] << ' ' << w[i] << endl;\n    }\n*/\n}\n\nint main() {\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<climits>\n#define mod 1000000000\n#define M 1000005\n#define INF 1000000000\n#define pi 3.14159265358979323846264338327950238\n#define eps 1e-9\n#define LL long long\n#define LD long double\nusing namespace std;\ntypedef pair<int,int> P;\nstruct edge{int to,cap,cost,rev;};\nint V;\nvector<edge>G[M];\nint h[M];\nint dist[M];\nint prevv[M],preve[M];\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back((edge){to,cap,cost,G[to].size()});\n    G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    fill(h,h+V,0);\n    while(f>0){\n        //printf(\"%d\\n\",f);\n        priority_queue<P, vector<P> , greater<P> > que;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        que.push(P(0,s));\n        while(!que.empty()){\n            P p=que.top();que.pop();\n            int v=p.second;\n            if(dist[v]<p.first) continue;\n            for(int j=0;j<G[v].size();j++){\n                edge &e=G[v][j];\n                if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=j;\n                    que.push(P(dist[e.to],e.to));\n                }\n            }\n        }\n        if(dist[t]==INF) return -1;\n        for(int v=0;v<V;v++) h[v]+=dist[v];\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]) d=min(d,G[prevv[v]][preve[v]].cap);\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\nint w[M];\nvector<int>A;\nint main(){\n    int n,m,K;\n    while(scanf(\"%d%d%d\",&m,&n,&K)!=EOF){\n        int j,k,s=K,t=s+1;\n        V=t+1;\n        for(j=0;j<n;j++) scanf(\"%d\",&w[j]);\n        int sum=0;\n        for(j=0;j<K;j++) G[j].clear();\n        A.clear();\n        for(j=0;j<K;j++){\n            int a;\n            scanf(\"%d\",&a);a--;\n            if(!(A.size()&&A.back()==a)) sum+=w[a],A.push_back(a);\n        }\n        K=A.size();\n        for(j=0;j<K;j++){\n            if(j+1<K) add_edge(j,j+1,m,0);\n            int t=find(A.begin()+j+1,A.end(),A[j])-A.begin();\n            if(t!=A.size()) add_edge(j+1,t,1,-w[A[j]]);\n        }\n        add_edge(s,0,m,0);\n        add_edge(K-1,t,m,0);\n        printf(\"%d\\n\",min_cost_flow(s,t,m-1)+sum);\n    }\n    //system(\"pause\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 31000\n\t#define MAXM 120000\n\t#define wint int\n\t#define cint long long \n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i]) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint p[11000];\nint q[11000];\nint last[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",q+i);\n\t\tq[i]--;\n\t}\n\tfor(int i=0;i<b;i++)last[i]=-1;\n\tMCF::init((c+1)*3+2);\n\tint s=(c+1)*3;\n\tint t=(c+1)*3+1;\n\tMCF::ae(s,0,a,0);\n\tMCF::ae(c,t,a,0);\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i,i+1,a,0);\n\t\tif(~last[q[i]]){\n\t\t\tMCF::ae(last[q[i]],i-1,1,-p[q[i]]);\n\t\t}\n\t\tlast[q[i]]=i;\n\t}\n\tMCF::solve(s,t,a-1);\n\tint ret=0;\n\tfor(int i=0;i<c;i++)ret+=p[q[i]];\n\tprintf(\"%lld\\n\",MCF::toc+ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tvector<int> top;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfill(h, h + n, 0);\n\t\tif(top.size()) {\n\t\t\tassert(top.size() == n);\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint v = top[i];\n\t\t\t\tfor(Edge& e : g[v]) {\n\t\t\t\t\tif(e.cap == 0) continue;\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\th[u] = min(h[u], h[v] + e.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tPrimalDual pd(K);\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 1000000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tpd.add_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\tfor(int i = 0; i < K; i++) {\n\t\t//pd.top.push_back(i);\n\t}\n\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define maxn 10005\n#define inf 0x3f3f3f3f\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint m,n,k,w[10005],lst[10005];\nvector <int> a;\nstruct edge{\n\tint to,cap,cst,rev;\n};\nvector <edge> adj[maxn];\nint dis[maxn],h[maxn];\nint V,prvv[maxn],prve[maxn],que[maxn],he,ta;\nbool inque[maxn];\nvoid addedge(int u,int v,int c,int d){\n\tadj[u].push_back((edge){v,c,d,(int)adj[v].size()});\n\tadj[v].push_back((edge){u,0,-d,(int)adj[u].size() - 1});\n}\nint min_cost_flow(int s,int t,int f){\n\tmemset(h,0,sizeof(h));\n\tint res = 0;\n\tbool fir = true;\n\twhile(f > 0){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[s] = 0;\n\t\tif(fir){\n\t\t\tmemset(inque,0,sizeof(inque));\n\t\t\the = ta = 0;\n\t\t\tinque[s] = true;\n\t\t\tque[ta++] = s;\n\t\t\twhile(he != ta){\n\t\t\t\tint u = que[he++];\n\t\t\t\tif(he == V+2) he = 0;\n\t\t\t\tinque[u] = false;\n\t\t\t\tfor(int i=0;i<adj[u].size();i++){\n\t\t\t\t\tedge &e = adj[u][i];\n\t\t\t\t\tif(e.cap && dis[u] + h[u] + e.cst - h[e.to] < dis[e.to]){\n\t\t\t\t\t\tdis[e.to] = dis[u] + h[u] + e.cst - h[e.to];\n\t\t\t\t\t\tprvv[e.to] = u;\n\t\t\t\t\t\tprve[e.to] = i;\n\t\t\t\t\t\tif(!inque[e.to]){\n\t\t\t\t\t\t\tinque[e.to] = true;\n\t\t\t\t\t\t\tque[ta++] = e.to;\n\t\t\t\t\t\t\tif(ta == V+2) ta = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfir = false;\n\t\t}else{\n\t\t\tpriority_queue <P,vector<P>,greater<P> > que;\n\t\t\tque.push(mp(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p = que.top();que.pop();\n\t\t\t\tint u = p.second;\n\t\t\t\tif(p.first != dis[u]) continue;\n\t\t\t\tfor(int i=0;i<adj[u].size();i++){\n\t\t\t\t\tedge &e = adj[u][i];\n\t\t\t\t\tif(e.cap && dis[u] + h[u] - h[e.to] + e.cst < dis[e.to]){\n\t\t\t\t\t\tdis[e.to] = dis[u] + h[u] - h[e.to] + e.cst;\n\t\t\t\t\t\tprvv[e.to] = u;\n\t\t\t\t\t\tprve[e.to] = i;\n\t\t\t\t\t\tque.push(mp(dis[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=V;i++) h[i] += dis[i];\n\t\tint flow = f;\n\t\tfor(int i=t;i!=s;i=prvv[i]){\n\t\t\tflow = min(flow,adj[prvv[i]][prve[i]].cap);\n\t\t}\n\t\tf -= flow;\n\t\tres += flow * h[t];\n\t\tfor(int i=t;i!=s;i=prvv[i]){\n\t\t\tedge &e = adj[prvv[i]][prve[i]];\n\t\t\te.cap -= flow;\n\t\t\tadj[e.to][e.rev].cap += flow;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tmemset(lst,-1,sizeof(lst));\n\tscanf(\"%d%d%d\",&m,&n,&k);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n\tfor(int i=1;i<=k;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ta.push_back(x);\n\t}\n\tint sum = 0;\n\ta.erase(unique(a.begin(),a.end()),a.end());\n\tk = a.size();\n\tfor(int i=0;i<k-1;i++){\n\t\taddedge(i,i+1,m,0);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tsum += w[a[i]];\n\t\tif(lst[a[i]] != -1) addedge(lst[a[i]],i-1,1,-w[a[i]]);\n\t\tlst[a[i]] = i;\n\t}\n\tV = k-1;\n\tprintf(\"%d\\n\",sum + min_cost_flow(0,k-1,m-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n#define MAX_V 10000\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init_edge(){\n    for(int i=0;i<V;i++)G[i].clear();\n}\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        priority_queue< pii, vector<pii>, greater<pii> >  que;\n        fill( dist, dist+V , INF );\n        dist[s]=0;\n        que.push(pii(0,s));\n        while(!que.empty()){\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v]<p.first)continue;\n            for(int i=0;i<(int)G[v].size();i++){\n                edge &e = G[v][i];\n                if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push(pii(dist[e.to],e.to));\n                }\n            }\n        }\n        if(dist[t]==INF){\n            return -1;\n        }\n        for(int v=0;v<V;v++)h[v]+=dist[v];\n        \n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int M,N,K; cin >> M >> N >> K;\n\n    V = K;\n    \n    int res = 0;\n    vector<int> A(N);\n    vector<vector<int> > B(N);\n    for(int i = 0; i < N;i++) cin >> A[i];\n    for(int i = 0; i < K;i++){\n        int a; cin >> a; a--;\n        B[a].push_back(i);\n        res += A[a];\n    }\n    \n    for(int i = 0; i < N;i++){\n        if((int)B[i].size() <= 1) continue;\n        for(int j = 0; j < (int)B[i].size()-1;j++){\n            int s = B[i][j], t = B[i][j+1];\n            if(s+1 != t){\n                add_edge(s+1, t, 1, -A[i]);\n            }else{\n                res -= A[i];\n            }\n        }\n    }\n    for(int i = 0; i < K-1;i++){\n        add_edge(i, i+1, M, 0);\n    }\n    cout << res + min_cost_flow(0, K-1, M-1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n  \ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f, bool negative = false){\n  typedef pair<int, int> P;\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> h(n, 0);\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 10000000;\n\n  if(negative){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    \n    bool update = true;\n    \n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n\tif(dist[v] == inf) continue;\n\tfor(int i = 0; i < (int)g[v].size(); i++){\n\t  E &e = g[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t    dist[e.to]  = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update      = true;\n\t  }\n\t}\n      }\n    }\n\n    for(int i = 0; i < n; i++)\n      h[i] = dist[i];\n  }\n\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n      P p   = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < (int)g[v].size(); i++){\n\tE &e = g[v][i];\n\n\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t  dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];\n\t  prevv[e.to] = v;\n\t  preve[e.to] = i;\n\t  que.push(P(dist[e.to], e.to));\n\t}\n      }\n    if(dist[t] == inf){\n      return -1;\n    }\n\n    for(int v = 0; v < n; v++) h[v] += dist[v];\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n\n    f   -= d;\n    res += d * h[t];\n\n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m = getInt();\n  int n = getInt();\n  int k = getInt();\n\n  vector<int> w(n);\n  vector<int> a(k);\n\n  Graph<CostEdge> g(k);\n\n  REP(i,n) w[i] = getInt();\n  REP(i,k) a[i] = getInt() - 1;\n\n  int ans = 0;\n  REP(i,k) ans += w[a[i]];\n\n  vector<int> prevs(n, -1);\n\n  REP(i,k){\n    if(i != k - 1) g.addEdge(i, i + 1, 10000, 0);\n    int aa = a[i];\n    if(prevs[aa] != -1){\n      int j = prevs[aa];\n      if(j + 1 == i){\n\tans -= w[a[i]];\n      }else{\n\tg.addEdge(j + 1, i, 1, - w[a[i]]);\n      }\n    }\n    prevs[aa] = i;\n  }\n\n  ans += minCostFlow(g, 0, k - 1, m - 1, true);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef long long LL;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=10010;\nint V,dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update=1;\n        while(update){\n            update=0;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=1;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF)return -1;\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }return res;\n}\nvoid clear(){for(int i=0;i<=V;i++)G[i].clear();}\nconst int MAX_N=10010;\nint M,N,K,w[MAX_N],lst[MAX_N],a[MAX_N];\nint solve(){\n    for(int i=1;i<=N;i++)scanf(\"%d\",&w[i]);\n    for(int i=1;i<=K;i++)scanf(\"%d\",&a[i]);\n    int cnt=unique(a+1,a+K+1)-(a+1);\n    int res=0;\n    memset(lst,0,sizeof(lst));\n    V=cnt+1; clear();\n    for(int i=1;i<=cnt;i++){\n        res+=w[a[i]];\n        if(lst[a[i]])add_edge(lst[a[i]],i-1,1,-w[a[i]]);\n        lst[a[i]]=i;\n    }for(int i=1;i<cnt;i++)add_edge(i,i+1,INF,0);\n    printf(\"%d\\n\",res+min_cost_flow(1,cnt,M-1));\n}\nint main(){\n    while(~scanf(\"%d%d%d\",&M,&N,&K))solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* 首先，只要在下一个相同数字到来之前没放这个球，下个数字来的时候直接将这个球放进去，和直接放是等效的。\n* 为了简单，只在取出球的时候计算花费（取出最后该取出的球之后求和）、任意时刻箱子的状态转移是\n* (1) 在时刻t将球放入，将原来的球取出，转移到t+1\n* (2) 在时刻t不放入球，保持空的，转移到t+1\n* (3) 在时刻t将球放入，保持该球，到下次相同编号到来的t'转移\n* 这三种情况\n* 另外，对于所有时刻，至少有一个箱子是“放入”的状态。\n*\n* 这种状态转移可以自然地用图描述：\n* (1) v[t] -(1/w[v[t]])-> v[t+1]\n* (2) v[t] -(∞/0)-> v[t+1]\n* (3) v[t] -(1/0)-> v[t']\n* 这里，由于(1)和(3)是一个连贯的动作，所以将(3)变形为\n* (3') v[t] -(1/w[v[t]])-> v[t+1] -(1/-w[v[t]])-> v[t']\n* 这样就合并了(1)和(3')，然后让所有(1)类型的边上面传输1单位流量即可。\n*\n* 变形后，最极端情况花费设为∑w[v[t]]的话\n* (2) v[t] -(∞/0)-> v[t+1]\n* (3'') v[t+1] -(1/-w[v[t]])-> v[t']\n* 在上图跑F=M-1的最小费用流即可。`\n* 另外，当t+1 == t'的时候会产生负圈，此时得预先排除这样的顶点。\n*\n* 复杂度是O(K^2 + MNK)。\n*/\n#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#define all(x) (x).begin(),(x).end()\n#define size(x) ((int)(x).size()) \n#define FIRST first \n#define SECOND second\n#define FRONT front\n#define PUSH_BACK push_back\n#define MAKE_PAIR make_pair \n#define EMPTY empty\n#define PRIORITY_QUEUE priority_queue\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned int uii;\ntypedef pair<int,int> pii;\ntypedef unsigned long long uLL;  \n//head\n\nconst int inf = 1e8;\nconst int maxn = 2e4;\n\nstruct edge\n{\n\tint v, r, w, c;\n};\nstd::vector<edge> G[maxn];\nint h[maxn], dist[maxn];\nint pv[maxn], pe[maxn];\nint V;\nint w[maxn], num[maxn], vis[maxn];\nvoid init(){\n\tfor(int i = 0; i < V; i++){\n\t\tG[i].clear();\n\t}\n}\n\nvoid add(int u, int v, int w, int cost){\n\tG[u].push_back((edge){v, size(G[v]), w, cost});\n\tG[v].push_back((edge){u, size(G[u])-1, 0, -cost});\n} \n\n\nint min_cost_flow(int s, int t, int flow){\n\tint res = 0;\n\tfill(h, h+V, 0);\n\twhile(flow > 0){\n\t\tfill(dist, dist+V, inf);\n\t\tdist[s] = 0;\n\t\tpriority_queue<pii, std::vector<pii>, greater<pii> > q;\n\t\tq.push(pii(0, s));\n\t\twhile(!q.empty()){\n\t\t\tpii x = q.top(); q.pop();\n\t\t\tint u = x.second;\n\t\t\tif(dist[u] < x.first) continue;\n\t\t\tfor(int i = 0; i < size(G[u]); i++){\n\t\t\t\tedge &e = G[u][i];\n\t\t\t\tint k = h[u] + dist[u] + e.c - h[e.v];\n\t\t\t\tif(k < dist[e.v] && e.w > 0){\n\t\t\t\t\tdist[e.v] = k;\n\t\t\t\t\tq.push(pii(k, e.v));\n\t\t\t\t\tpv[e.v] = u;\n\t\t\t\t\tpe[e.v] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == inf) {\n\t\t\treturn -1;\t//不能再增广\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\th[i] += dist[i];\n\t\t}   \n\t\tint tf = flow;\n\t\tfor(int v = t; v != s; v = pv[v]){\n\t\t\ttf = min(tf, G[pv[v]][pe[v]].w);\n\t\t}\t\n\t\tif(tf){\n\t\t\tfor(int v = t; v != s; v = pv[v]){\n\t\t\t\tedge &e = G[pv[v]][pe[v]];\n\t\t\t\te.w -= tf;\n\t\t\t\tG[v][e.r].w += tf;\n\t\t\t}\n\t\t\tres += tf * h[t];\n\t\t\tflow -= tf;\n\t\t}\n\t}\n\treturn res;\t\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint m, n, k;\n\tcin >> m >> n >> k;\n\tint res = 0, s = 0, t = k+1;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> w[i];\n\t}\n\tfor(int i = 1; i < k; i++){\n\t\tadd(i, i+1, inf, 0);\n\t}\n\tadd(s, 1, m-1, 0);\n\tadd(k, t, m-1, 0);\n\tint c = 0;\n\tV = k + 2;\n\tfor(int i = 1; i <= k; i++){\n\t\tcin >> num[i];\n\t\tres += w[num[i]];\n\t\tif(vis[num[i]]){\n\t\t\tint u = vis[num[i]]+1;\n\t\t\t// printf(\"%d\\n\", u);\n\t\t\tif(u < i){\n\t\t\t\tadd(i, u, 1, w[num[i]]);\n\t\t\t\t// printf(\"%d %d\\n\", i, u);\n\t\t\t\tadd(s, i, 1, 0);\n\t\t\t\tadd(u, t, 1, 0);\n\t\t\t\tc++;\n\t\t\t} \n\t\t\tres -= w[num[i]];\n\t\t}\n\t\tvis[num[i]] = i;\n\t}\n\t// printf(\"%d\\n\", res);\n\t// printf(\"%d\\n\", c);\n\tprintf(\"%d\\n\", res + min_cost_flow(s, t, m-1 + c));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef long long LL;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=10010;\nint V,dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update=1;\n        while(update){\n            update=0;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=1;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF)return -1;\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }return res;\n}\nvoid clear(){for(int i=0;i<=V;i++)G[i].clear();}\nconst int MAX_N=10010;\nint M,N,K,w[MAX_N],lst[MAX_N],a[MAX_N];\nint solve(){\n    for(int i=1;i<=N;i++)scanf(\"%d\",&w[i]);\n    for(int i=1;i<=K;i++)scanf(\"%d\",&a[i]);\nif(M == 1) {\n    int cnt=unique(a+1,a+K+1)-(a+1);\n    int res=0;\n    for(int i=1;i<=cnt;i++){\n        res+=w[a[i]];}\nprintf(\"%d\\n\", res);\n return;}\n   int cnt = K;\n    int res=0;\n    memset(lst,0,sizeof(lst));\n    V=cnt+1; clear();\n    for(int i=1;i<=cnt;i++){\n        res+=w[a[i]];\n        if(lst[a[i]])add_edge(lst[a[i]],i-1,1,-w[a[i]]);\n        lst[a[i]]=i;\n    }for(int i=1;i<cnt;i++)add_edge(i,i+1,INF,0);\n    printf(\"%d\\n\",res+min_cost_flow(1,cnt,M-1));\n}\nint main(){\n    while(~scanf(\"%d%d%d\",&M,&N,&K))solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n#define MAX_V 10010\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update = true;\n        while(update){\n            update = false;\n            for(int v=0; v<V ;v++){\n                if(dist[v]==INF) continue;\n                for(int i=0; i<G[v].size(); i++){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF) return -1;\n        \n        int d = f;\n        for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*dist[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int M,N,K; cin >> M >> N >> K;\n\n    V = K;\n    \n    int res = 0;\n    vector<int> A(N);\n    vector<vector<int> > B(N);\n    for(int i = 0; i < N;i++) cin >> A[i];\n    for(int i = 0; i < K;i++){\n        int a; cin >> a; a--;\n        B[a].push_back(i);\n        res += A[a];\n    }\n    \n    for(int i = 0; i < N;i++){\n        if((int)B[i].size() <= 1) continue;\n        for(int j = 0; j < (int)B[i].size()-1;j++){\n            int s = B[i][j], t = B[i][j+1];\n            if(s+1 != t){\n                add_edge(s+1, t, 1, -A[i]);\n            }else{\n                res -= A[i];\n            }\n        }\n    }\n    for(int i = 0; i < K-1;i++){\n        add_edge(i, i+1, M, 0);\n    }\n    cout << res + min_cost_flow(0, K-1, M-1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<ll, ll>\n#define pdd pair<double, double>\n#define f first\n#define s second\n#define MOD 1000000007\n#define mkp make_pair\n#define M_PI 3.14159265358979323846\n#define FOR(i,l,r) for (int i=l;i<=r;i++)\n#define FORD(i,r,l) for (int i=r;i>=l;i--)\n#define INF 2147483647\ntypedef long long ll;\n\n#define MAXV 15000\nstruct edge {int to, cap, cost, rev;};\nint V,E,S,T,F;\nvector<edge> G[MAXV];\nint dist[MAXV], prevv[MAXV], preve[MAXV];\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n    G[from].pb((edge){to, cap, cost, G[to].size()});\n    G[to].pb((edge){from, 0, -cost, G[from].size()-1});\n}\n\nint min_cost_flow(int S, int T, int F)\n{\n    int res = 0;\n    while(F > 0)\n    {\n        fill(dist, dist+V, INF);\n        dist[S] = 0;\n        bool update = true;\n        while(update)\n        {\n            update = false;\n            for(int v = 0; v < V; v++)\n            {\n                if(dist[v] == INF)continue;\n                for(int i = 0; i < G[v].size(); i++)\n                {\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost)\n                    {\n                        dist[e.to] = dist[v]+e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[T] == INF)return -1;\n        int d = F;\n        for(int v = T; v != S; v = prevv[v])\n        {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        F-=d;\n        res+=d*dist[T];\n        for(int v = T; v != S; v = prevv[v])\n        {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\n\n#define MAXN 10005\nint N,M,K;\nint w[MAXN],a[MAXN],last[MAXN];\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    \n    cin>>M>>N>>K;\n        V=K+2;\n        FOR(i,0,V-1)G[i].clear();\n        S=0;\n        T=K+1;\n        \n        FOR(i,1,N)cin>>w[i];\n        int tot=0;\n        FOR(i,1,K)\n        {\n            cin>>a[i];\n            if(i==1||a[i]!=a[i-1])tot+=w[a[i]];//changing count\n        }\n        \n        memset(last,-1,sizeof(last));\n        FOR(i,1,K)\n        {\n            int now=a[i];\n            if(last[now]!=-1&&last[now]!=i-1)\n            {\n                add_edge( last[now], i-1, 1, -w[now] );\n            }\n            last[now]=i;\n        }\n        FOR(i,0,V-2)add_edge( i, i+1, INF, 0 );\n        \n        cout<<tot+min_cost_flow(S,T,M-1)<<'\\n';\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\nconst int MAXN=1e4+5;\nstruct edge\n{\n    int from,to,c,cost;\n    edge(int _from,int _to,int _c,int _cost)\n    {\n        from=_from,to=_to,c=_c,cost=_cost;\n    }\n};\nvector<int> same[MAXN+5];\nvector<int> G[MAXN+5];\nvector<edge> p;\nint N,M,K,inf=1e9;\nint w[MAXN+5];\nvector <int> a;\nint input()\n{\n    int sum=0;\n    for(int i=0; i<M; i++) scanf(\"%d\",&w[i]);\n    int t;\n    for(int i=0; i<K; i++)\n    {\n        scanf(\"%d\",&t);\n        t--;\n        if(a.size()==0||t!=a[a.size()-1])\n        {\n            same[t].push_back(a.size());\n            a.push_back(t);\n            sum+=w[t];\n        }\n    }\n    K=a.size();\n    return sum;\n}\nvoid add(int from,int to,int c,int cost)\n{\n    G[from].push_back(p.size());\n    p.push_back(edge(from,to,c,cost));\n    G[to].push_back(p.size());\n    p.push_back(edge(to,from,0,-cost));\n}\nvoid get_map(int s,int d)\n{\n    for(int i=0; i<K-1; i++) add(i,i + 1, N, 0);\n    for(int i=0; i<M; i++) for(int j=0; j<same[i].size()-1; j++) add(same[i][j]+1,same[i][j+1],1,-w[a[same[i][j]]]);\n    add(s,0,N,0);\n    add(K-1,d,N,0);\n}\nint pre[MAXN+5],dist[MAXN+5];\nbool vis[MAXN+5];\nbool spfa(int s,int d)\n{\n    int u,v;\n    queue<int> q;\n    for(int i=0; i<=d+2; i++)\n    {\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=inf;\n    }\n    vis[s]=1;\n    dist[s]=0;\n    q.push(s);\n    while(!q.empty())\n    {\n        u=q.front();\n        /* cout<<u<<\":\"<<endl;\n         for(int i=0;i<=d;i++) printf(\"%4d\",p[pre[i]].from); cout<<endl;\n         for(int i=0;i<=d;i++) printf(\"%4d\",dist[i]); cout<<endl;*/\n        q.pop();\n        vis[u]=0;\n        for(int j=0; j<G[u].size(); j++)\n        {\n            int i=G[u][j];\n            if(p[i].c>0)\n            {\n                v=p[i].to;\n                if(dist[v]>dist[u]+p[i].cost)\n                {\n                    dist[v]=dist[u]+p[i].cost;\n                    pre[v]=i;\n                    if(!vis[v])\n                    {\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    return dist[d]<0;\n}\n\nint MCMF(int s,int d)\n{\n    int ans=0,flow;\n    int flow_sum=0;\n    while(spfa(s,d))\n    {\n        flow=1;\n        for(int i=pre[d];; i=pre[p[i].from])\n        {\n            if(p[i].c<flow) flow=p[i].c;\n            if(p[i].from==s) break;\n        }\n        for(int i=pre[d]; ; i=pre[p[i].from])\n        {\n            p[i].c-=flow;\n            p[i^1].c+=flow;\n            if(p[i].from==s) break;\n        }\n        ans+=dist[d];\n        //cout<<dist[d]<<\"*\"<<flow<<endl;\n        flow_sum += flow;\n        if(flow_sum>=N-1) break;\n    }\n    //cout << flow_sum << endl;\n    //cout<<ans<<endl;\n    return ans;\n}\nvoid init()\n{\n    for(int i=0; i<M; i++) same[i].clear();\n    for(int i=0;i<K+3;i++) G[i].clear();\n    p.clear();\n}\nint main()\n{\n    cin>>N>>M>>K;\n    init();\n    int sum=input();\n    int s=K,d=K+1;\n    get_map(s,d);\n    cout<<sum+MCMF(s,d)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_M = 10;\nconst int MAX_N = 10000;\nconst int MAX_K = 10000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Edge {\n  int i, cap, cost;\n  Edge() {}\n  Edge(int _i, int _cap, int _cost): i(_i), cap(_cap), cost(_cost) {}\n};\n\ntypedef vector<Edge> ve;\n\n/* global variables */\n\nint wis[MAX_N], ajs[MAX_K], last[MAX_N];\nint dists[MAX_K], prvs[MAX_K];\nve nbrs[MAX_K];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int m, n, k;\n  cin >> m >> n >> k;\n\n  for (int i = 0; i < n; i++) cin >> wis[i], last[i] = -1;\n\n  int wsum = 0;\n  \n  for (int j = 0; j < k; j++) {\n    int aj;\n    cin >> aj;\n    aj--;\n    ajs[j] = aj;\n\n    if (j > 0)\n      nbrs[j - 1].push_back(Edge(j, m - 1, 0));\n    if (last[aj] >= 0)\n      nbrs[last[aj] + 1].push_back(Edge(j, 1, -wis[aj]));\n    last[aj] = j;\n\n    wsum += wis[aj];\n  }\n\n  int csum = 0;\n\n  for (;;) {\n    for (int i = 0; i < k; i++) dists[i] = INF;\n    dists[0] = 0;\n    prvs[0] = -1;\n\n    for (int ui = 0; ui < k; ui++) {\n      if (dists[ui] >= INF) continue;\n\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->cap > 0 && dists[vit->i] > dists[ui] + vit->cost) {\n\t  dists[vit->i] = dists[ui] + vit->cost;\n\t  prvs[vit->i] = ui;\n\t}\n    }\n\n    if (dists[k - 1] >= INF) break;\n    \n    for (int vi = k - 1; vi != 0;) {\n      int ui = prvs[vi];\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->i == vi) {\n\t  vit->cap--;\n\t  csum += vit->cost;\n\t  break;\n\t}\n      vi = ui;\n    }\n  }\n  \n  cout << (wsum + csum) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nstruct EdgeC{\n  int to, cap, cost, rev;\n  EdgeC(int to_=0, int cap_ = 0, int cost_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), cost(cost_), rev(rev_){}\n};\nusing GraphC = vector<vector<EdgeC>>;\n\nvoid add_edge(GraphC& G, int from, int to, int cap, int cost){\n  G[from].emplace_back(to, cap, cost, G[to].size());\n  G[to].emplace_back(from, 0, -cost, G[from].size()-1);\n}\n\nint min_cost_flow(GraphC& G, int s, int t, int f){\n  int V = G.size();\n  vector<int> dist(V);\n  vector<int> prevv(V), preve(V);\n  int res = 0;\n  \n  while(f > 0){\n\tfill(begin(dist), end(dist), INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile(update){\n\t  update = false;\n\t  for(int v=0;v<V;++v){\n\t\tif(dist[v] == INF) continue;\n\t\tfor(unsigned int i=0;i<G[v].size();++i){\n\t\t  auto& e = G[v][i];\n\t\t  if(e.cap > 0 && dist[v] + e.cost < dist[e.to]){\n\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\tif(dist[t] == INF) return -INF;\n\n\tint d = f;\n\tfor(int v=t;v!=s;v=prevv[v])\n\t  d = min(d, G[prevv[v]][preve[v]].cap);\n\n\tf -= d;\n\tres += d * dist[t];\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t  auto& e = G[prevv[v]][preve[v]];\n\t  e.cap -= d;\n\t  G[v][e.rev].cap += d;\n\t}\n  }\n  \n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int BOX, BALL, K;\n  cin >> BOX >> BALL >> K;\n  VI xs(BALL);\n  cin >> xs;\n\n  VI qs_(K);\n  cin >> qs_;\n\n  VI qs;\n  REP(i,K)\n\tif(qs.empty() || qs.back() != qs_[i])\n\t  qs.PB(qs_[i]);\n  K = SZ(qs);\n\n  VI last(BALL+1,-1);\n  VI post(K,-1);\n  for(int i=K-1;i>=0;--i){\n\tpost[i] = last[qs[i]];\n\tlast[qs[i]] = i;\n  }\n\n  int ans = 0;\n  GraphC G(K+1);\n  REP(k,K){\n\tadd_edge(G, k, k+1, BOX, 0);\n\tans += xs[qs[k]-1];\n\tif(post[k] >= 0){\n\t  add_edge(G, k+1, post[k], 1, -xs[qs[k]-1]);\n\t}\n  }\n  cout << ans + min_cost_flow(G, 0, K, BOX-1) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long LL;\nconst LL INF = 1LL << 59;\n \ntemplate<class Flow, class Cost>\nstruct Edge\n{\n\tint from, to;\n\tFlow cap, flow;\n\tCost cost;\n\tEdge *back;\n \n\tEdge(int from, int to, Flow cap, Cost cost, Edge *back)\n\t\t: from(from), to(to), cap(cap), flow(0), cost(cost), back(back)\n\t{}\n};\n \ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost> *> > &g, int src, int dst, Flow c, Cost d)\n{\n\tEdge<Flow, Cost> *ea = new Edge<Flow, Cost>(src, dst, c, d, NULL);\n\tEdge<Flow, Cost> *eb = new Edge<Flow, Cost>(dst, src, 0, -d, ea);\n\tea->back = eb;\n\tg[src].push_back(ea);\n\tg[dst].push_back(eb);\n}\n \ntemplate<class Flow, class Cost>\npair<Flow, Cost> primal_dual(vector<vector<Edge<Flow, Cost> *> > &g, int src, int sink, Flow max_flow)\n{\n\tconst int N = g.size();\n\tpair<Flow, Cost> res;\n\tvector<Cost> dist(N);\n\tvector<Edge<Flow, Cost> *> prev(N);\n\tfor (Flow f = max_flow; f > 0;)\n\t{\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tfill(prev.begin(), prev.end(), nullptr);\n\t\tdist[src] = 0;\n \n\t\twhile (true)\n\t\t{\n\t\t\tbool updated = false;\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t{\n\t\t\t\tfor (auto *e : g[i])\n\t\t\t\t{\n\t\t\t\t\tif (e->cap - e->flow > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tCost nc = dist[e->from] + e->cost;\n\t\t\t\t\t\tif (nc < dist[e->to])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdist[e->to] = nc;\n\t\t\t\t\t\t\tprev[e->to] = e;\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!updated)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (prev[sink] == nullptr)\n\t\t\tbreak;\n \n\t\tFlow aug = f;\n\t\tfor (auto *e = prev[sink]; e; e = prev[e->from])\n\t\t{\n\t\t\taug = min(aug, e->cap - e->flow);\n\t\t}\n\t\tfor (auto *e = prev[sink]; e; e = prev[e->from])\n\t\t{\n\t\t\tres.second += aug * e->cost;\n\t\t\te->flow += aug;\n\t\t\te->back->flow -= aug;\n\t\t}\n\t\tf -= aug;\n\t\tres.first += aug;\n\t}\n \n\treturn res;\n}\n \nbool solve()\n{\n\tint M, N, K;\n\tif (!(cin >> M >> N >> K))\n\t\treturn false;\n \n\tvector<LL> ws(N);\n\tvector<int> as;\t// 数字序列\n\tvector<vector<Edge<int, LL> *> > graph(K + 2);\n\tconst int SRC = K;\n\tconst int SINK = K + 1;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tcin >> ws[i];\n\t}\n\tLL sum = 0;\t// 总权重\n\tfor (int i = 0; i < K; ++i)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\t--a;\n\t\tif (as.size() > 0 && as.back() == a)\n\t\t{\n\t\t\t// do nothing 排除连续相同的序号\n\t\t}\n\t\telse\n\t\t{\n\t\t\tas.push_back(a);\n\t\t\tsum += ws[a];\n\t\t}\n\t}\n\tconst int L = as.size();\n\tfor (int i = 0; i < L; ++i)\n\t{\n\t\t// Edge to neighbor\n\t\tif (i + 1 < L)\n\t\t{\n\t\t\tadd_edge(graph, i, i + 1, M, 0LL);\t// v[t] -(∞/0)-> v[t+1]\n\t\t}\n\t\t// Edge to next same number\n\t\tauto it = find(as.begin() + i + 1, as.end(), as[i]);\n\t\tif (it != as.end())\n\t\t{\n\t\t\tadd_edge(graph, i + 1, it - as.begin(), 1, -ws[as[i]]);\t// v[t+1] -(1/-w[v[t]])-> v[t']\n\t\t}\n\t}\n\tadd_edge(graph, SRC, 0, M, 0LL);\n\tadd_edge(graph, L - 1, SINK, M, 0LL);\n\tauto res = primal_dual(graph, SRC, SINK, M - 1);\n\tcout << sum + res.second << endl;\n\treturn true;\n}\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n \n\twhile (solve());\n#ifndef ONLINE_JUDGE\n\tfclose(stdin);\n\tfclose(stdout);\n\tsystem(\"out.txt\");\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing W = ll;\nusing edge = struct {int to, rev; W cap, flow, cost;};\nusing G = vector<vector<edge>>;\n\nvoid add_edge(G &graph, int from, int to, W cap, W cost) {\n    graph[from].push_back({to, int(graph[to].size()) , cap , 0 , cost});\n    graph[to].push_back({from, int(graph[from].size()) - 1, 0 , 0, -cost});\n}\n\nW primal_dual(G &graph, int s, int t, int f) {\n    const W inf = 1LL << 50;\n    W res = 0;\n    while (f) {\n        int n = graph.size(), update;\n        vector<W> dist(n, inf);\n        vector<int> pv(n, 0), pe(n, 0);\n        dist[s] = 0;\n\n        rep(loop, n) {\n            update = false;\n            rep(v, n)rep(i, graph[v].size()) {\n                edge &e = graph[v][i];\n                if (e.cap > e.flow and chmin(dist[e.to], dist[v] + e.cost)) {\n                    pv[e.to] = v, pe[e.to] = i;\n                    update = true;\n\n                }\n            }\n            if (!update) break;\n        }\n\n        if (dist[t] == inf) return -1;\n\n        W d = f;\n\n        for (int v = t; v != s; v = pv[v]){\n            chmin(d, graph[pv[v]][pe[v]].cap - graph[pv[v]][pe[v]].flow);\n        }\n\n        f -= d, res += d * dist[t];\n\n        for (int v = t; v != s; v = pv[v]) {\n            edge &e = graph[pv[v]][pe[v]];\n            e.flow += d;\n            graph[v][e.rev].flow -= d;\n        }\n    }\n    return res;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int m, n, K; cin >> m >> n >> K;\n    vll w(n); for(auto& e : w) cin >> e;\n    ll res = 0;\n    vi a(K);  for(auto& e : a) cin >> e, e--, res += w[e];\n\n    int s = 0, t = K - 1;\n    G graph(K + 2);\n    rep(i, K - 1){\n        add_edge(graph, i, i + 1, inf, 0);\n    }\n\n    vi pre_t(n, -1);\n    rep(t, K){\n        int e = a[t];\n        int& pt = pre_t[e];\n        if(pt >= 0){\n            if(t - 1 == pt){\n                res -= w[e];\n            }\n            else {\n                add_edge(graph, pt + 1, t, 1, -w[e]);\n            }\n        }\n        pt = t;\n    }\n\n    res += primal_dual(graph, s, t, m - 1);\n    \n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define maxn 30005\n#define inf 0x3f3f3f3f\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> P;\nint m,n,k,a[10005],w[10005],lst[10005];\nstruct edge{\n\tint to,cap,cst,rev;\n};\nvector <edge> adj[maxn];\nll dis[maxn],h[maxn];\nint V,prvv[maxn],prve[maxn],que[maxn],he,ta;\nbool inque[maxn];\nvoid addedge(int u,int v,int c,int d){\n\tadj[u].push_back((edge){v,c,d,(int)adj[v].size()});\n\tadj[v].push_back((edge){u,0,-d,(int)adj[u].size()});\n}\nll min_cost_flow(int s,int t,int f){\n\tmemset(h,0,sizeof(h));\n\tll res = 0;\n\tbool fir = true;\n\twhile(f > 0){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[s] = 0;\n\t\tif(fir){\n\t\t\tmemset(inque,0,sizeof(inque));\n\t\t\the = ta = 0;\n\t\t\tinque[s] = true;\n\t\t\tque[ta++] = s;\n\t\t\twhile(he != ta){\n\t\t\t\tint u = que[he++];\n\t\t\t\tif(he == V+1) he = 0;\n\t\t\t\tinque[u] = false;\n\t\t\t\tfor(int i=0;i<adj[u].size();i++){\n\t\t\t\t\tedge &e = adj[u][i];\n\t\t\t\t\tif(e.cap && dis[u] + h[u] + e.cst - h[e.to] < dis[e.to]){\n\t\t\t\t\t\tdis[e.to] = dis[u] + h[u] + e.cst - h[e.to];\n\t\t\t\t\t\tprvv[e.to] = u;\n\t\t\t\t\t\tprve[e.to] = i;\n\t\t\t\t\t\tif(!inque[e.to]){\n\t\t\t\t\t\t\tinque[e.to] = true;\n\t\t\t\t\t\t\tque[ta++] = e.to;\n\t\t\t\t\t\t\tif(ta == V+1) ta = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfir = false;\n\t\t}else{\n\t\t\tpriority_queue <P,vector<P>,greater<P> > que;\n\t\t\tque.push(mp(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p = que.top();que.pop();\n\t\t\t\tint u = p.second;\n\t\t\t\tif(p.first != dis[u]) continue;\n\t\t\t\tfor(int i=0;i<adj[u].size();i++){\n\t\t\t\t\tedge &e = adj[u][i];\n\t\t\t\t\tif(e.cap && dis[u] + h[u] - h[e.to] + e.cst < dis[e.to]){\n\t\t\t\t\t\tdis[e.to] = dis[u] + h[u] - h[e.to] + e.cst;\n\t\t\t\t\t\tprvv[e.to] = u;\n\t\t\t\t\t\tprve[e.to] = i;\n\t\t\t\t\t\tque.push(mp(dis[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=V;i++) h[i] += dis[i];\n\t\tint flow = f;\n\t\tfor(int i=t;i!=s;i=prvv[i]){\n\t\t\tflow = min(flow,adj[prvv[i]][prve[i]].cap);\n\t\t}\n\t\tf -= flow;\n\t\tres += flow * h[t];\n\t\tfor(int i=t;i!=s;i=prvv[i]){\n\t\t\tedge &e = adj[prvv[i]][prve[i]];\n\t\t\te.cap -= flow;\n\t\t\tadj[e.to][e.rev].cap += flow;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&m,&n,&k);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n\tfor(int i=1;i<=k;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t//node 0: S.\n\t//node 1 ... k: 1' ... k'\n\t//node k+1 ... 2k: in-type for 1...k\n\t//node 2k+1 ... 3k: out-type for 1 ... k\n\t//node 3k+1: T.\n\tint S = 0,T = 3 * k + 1;\n\tV = T;\n\tll ans = 0,sum = 0;\n\taddedge(S,1,m,0);\n\taddedge(S,k+1,m,0);\n\taddedge(k,T,m,0);\n\taddedge(3 * k,T,m,0);\n\tfor(int i=1;i<k;i++){\n\t\taddedge(i,i+1,m,0);\n\t\taddedge(i,i+1+k,m,0);\n\t}\n\tfor(int i=2*k+1;i<3*k;i++){\n\t\taddedge(i,i+1-k,m,0);\n\t\taddedge(i,i+1-2*k,m,0);\n\t}\n\tfor(int i=k+1;i<=2*k;i++){\n\t\taddedge(i,i+k,1,-inf);\n\t\tans += inf;\n\t}\n\tfor(int i=1;i<=k;i++){\n\t\tsum += w[a[i]];\n\t\tif(lst[a[i]] != 0){\n\t\t\taddedge(lst[a[i]] + 2*k,i+k,1,-w[a[i]]);\n\t\t}\n\t\tlst[a[i]] = i;\n\t}\n\tans += min_cost_flow(S,T,m);\n\tprintf(\"%lld\\n\",sum + ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\ntypedef int weight;\ntypedef pair<weight, int> P;\nconst weight INF = (1 << 29);\n\nstruct edge {\n\tint to;\n\tint cap;\n\tweight cost;\n\tint rev;\n\tedge(int to_, int cap_, weight cost_, int rev_) :to(to_), cap(cap_), cost(cost_), rev(rev_) {};\n};\n\nvector<vector<edge>> G;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n}\n\nvoid add_edge(int from, int to, int cap, weight cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\n\nweight min_cost_flow(int s, int t, weight f) {\n\tconst int n = G.size();\n\tweight res = 0;\n\tvector<int> prevv(n), preve(n);\n\twhile(f > 0) {\n\t\tvector<weight> dist(n, INF);\n\t\tdist[s] = 0;\n\n\t\twhile(true) {\n\t\t\tbool update = false;\n\t\t\tfor(int v = 0; v < n; ++v) {\n\t\t\t\tfor(unsigned i = 0; i < G[v].size(); ++i) {\n\t\t\t\t\tconst auto &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\n\t\tif(dist[t] == INF) return -1;\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tinit(K);\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tadd_edge(i, i + 1, 1000000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tadd_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\n\tll res = min_cost_flow(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef pair< int, int > P;\n\nstruct edge\n{\n  int to, cap, cost, rev;\n};\n\nconst int MAX_N = 1e4;\nconst int MAX_K = 1e4;\nconst int MAX_V = MAX_K;\nconst int INF = 1 << 29;\n\nint V;\nvector< edge > G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid init_G(int v)\n{\n  V = v;\n\n  for (int i = 0; i < V; i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n  G[from].push_back((edge){to, cap, cost, G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f)\n{\n  int res = 0;\n  memset(h, 0, sizeof h);\n\n  while (f > 0)\n  {\n    priority_queue< P, vector< P >, greater< P > > que;\n\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while (!que.empty())\n    {\n      P p = que.top();\n      que.pop();\n\n      int v = p.second;\n\n      if (dist[v] < p.first)\n        continue;\n\n      for (int i = 0; i < (int)G[v].size(); i++)\n      {\n        edge &e = G[v][i];\n\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to])\n        {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n\n    if (dist[t] == INF)\n      return -1;\n\n    for (int v = 0; v < V; v++)\n      h[v] += dist[v];\n\n    int d = f;\n    for (int v = t; v != s; v = prevv[v])\n      d = min(d, G[prevv[v]][preve[v]].cap);\n\n    f -= d;\n    res += d * h[t];\n\n    for (int v = t; v != s; v = prevv[v])\n    {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n\n  return res;\n}\n\nint M, N, K;\nint w[MAX_N];\nint a[MAX_K];\n\nvoid solve()\n{\n  int res = 0;\n  vector< int > B[N];\n\n  init_G(K);\n\n  for (int i = 0; i < K; i++)\n  {\n    B[a[i]].push_back(i);\n    res += w[a[i]];\n  }\n\n  for (int i = 0; i < N; i++)\n  {\n    for (int j = 0; j < (int)B[i].size() - 1; j++)\n    {\n      int n1 = B[i][j], n2 = B[i][j + 1];\n      if (n1 + 1 != n2)\n        add_edge(n1 + 1, n2, 1, -w[i]);\n      else\n        res -= w[i];\n    }\n  }\n\n  for (int i = 0; i < K - 1; i++)\n    add_edge(i, i + 1, M, 0);\n\n  printf(\"%d\\n\", res + min_cost_flow(0, K - 1, M - 1));\n\n  return;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &M, &N, &K);\n\n  for (int n = 0; n < N; n++)\n    scanf(\"%d\", w + n);\n\n  for (int k = 0; k < K; k++)\n  {\n    scanf(\"%d\", a + k);\n    a[k]--;\n  }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10005\ntypedef pair<int,int> P; //firstは最短距離、secondは頂点の番号\n\n//辺を表す構造体{行先、容量、コスト、逆辺のインデックス}\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nint N,M,K;\nint weight[NUM],ball_array[NUM];\nint index_table[NUM];\nvector<int> LOC[NUM];\n\nint V; //頂点数\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint dist[NUM]; //最短距離\nint pre_node[NUM],pre_edge[NUM]; //直前の頂点と辺\n\n\n//fromからtoへ向かう容量capacity,コストcostの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\n//sourceからsinkへの、流量flowの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\twhile(flow > 0){\n\t\t//ベルマンフォード方により、source-sink間最短経路を求める\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int node_id = 0; node_id < V; node_id++){\n\t\t\t\tif(dist[node_id] == BIG_NUM)continue;\n\t\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost; //node_idを経由した方が早い場合\n\t\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\t//これ以上流せない\n\t\t\treturn -1;\n\t\t}\n\n\t\t//source-sink間最短路に沿って目いっぱい流す\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*dist[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&weight[i]);\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d\",&ball_array[i]);\n\t\tball_array[i]--;\n\n\t\tLOC[ball_array[i]].push_back(i); //ボールを投入する必要のある時刻の配列\n\t\tans += weight[ball_array[i]];\n\t}\n\n\tint source = 0,sink = 1,index = 2;\n\t//時刻0～K-1に、ノード番号を割り当てる\n\tfor(int i = 0; i < K; i++){\n\t\tindex_table[i] = index++;\n\t}\n\n\tadd_edge(source,index_table[0],M,0);\n\n\t//時刻ノード同士を、十分大きな容量かつコスト0の辺で結ぶ\n\tfor(int i = 0; i < K-1; i++){\n\t\tadd_edge(index_table[i],index_table[i+1],M,0);\n\t}\n\n\tadd_edge(index_table[K-1],sink,M,0);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(LOC[i].size() <= 1)continue; //入れない、または1回しか入れないボールは無視\n\n\t\tfor(int a = 0; a < LOC[i].size()-1; a++){\n\t\t\tif(LOC[i][a]+1 == LOC[i][a+1]){ //入れる時刻が連続している場合\n\t\t\t\tans -= weight[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tadd_edge(index_table[LOC[i][a]+1],index_table[LOC[i][a+1]],1,-weight[i]);\n\t\t}\n\t}\n\n\tV = index;\n\n\t//★★時刻→時刻に、必ず[今入れたばかりの球]が存在するので、区間の重なりはM-1まで★★\n\tans += min_cost_flow(source,sink,M-1);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef long long LL;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=10010;\nint V,dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update=1;\n        while(update){\n            update=0;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=1;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF)return -1;\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d; \n        }\n    }return res;\n}\nvoid clear(){for(int i=0;i<V;i++)G[i].clear();}\nconst int MAX_N=10010;\nint M,N,K,w[MAX_N],lst[MAX_N],a[MAX_N];\nint solve(){\n    for(int i=1;i<=N;i++)scanf(\"%d\",&w[i]);\n    for(int i=1;i<=K;i++)scanf(\"%d\",&a[i]);\n    int cnt=unique(a+1,a+K+1)-(a+1);\n    int res=0;\n    memset(lst,0,sizeof(lst));\n    V=cnt; clear();\n    for(int i=1;i<=cnt;i++){\n        res+=w[a[i]];\n        if(lst[a[i]])add_edge(lst[a[i]],i-1,1,-w[a[i]]);\n        lst[a[i]]=i;\n    }for(int i=1;i<cnt-1;i++)add_edge(i,i+1,INF,0);\n    printf(\"%d\\n\",res+min_cost_flow(1,cnt-1,M-1));\n}\nint main(){\n    while(~scanf(\"%d%d%d\",&M,&N,&K))solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 100000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tpd.add_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nint cost[max_k][max_k];\nint back_cost[max_k][max_k];\nint nbr[max_k][max_k];\nint num_nbr[max_k];\n\nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n\nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n\n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n\n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n\n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      for(j=MAX(i+1,initial);j<nxt;j++){        \n        nbr[i][(num_nbr[i])++] = j;\n        cost[i][j] = w[a[i]];\n      }\n      nbr[i][(num_nbr[i])++] = nxt;\n      cost[i][nxt] = 0;\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i][(num_nbr[i])++] = j;\n        cost[i][j] = 0;\n      }\n    }\n  }\n}\n\nint min_cost(){\n  static int h[max_k+1];\n  static int dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n  \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n  \n  memset(h,0,(K+1)*sizeof(int));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n  \n  while(1){\n    fill(dist,dist+K+1,INT_MAX);\n    for(i = 0;i<K-M;i++){\n      if(prev[i] != -1) continue;\n      dist[i] = 0;\n      que.push(P(0,i));\n    }\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == v) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][v] + (-cost[w][v]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][v] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    if(dist[t] == INT_MAX) return res;\n    for(i = 0;i < K-M;i++) h[i] += dist[i];\n    h[t] += dist[t];\n    \n    for(v=prev_mid[t],u=prev[t];true;v=prev_mid[u],u=prev[u]){\n      flow[u] = v;\n      used[v] = u;\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n}\n\nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n\nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 51000\n\t#define MAXM 1000000\n\t#define wint int\n\t#define cint long long \n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint p[11000];\nint q[11000];\nint last[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",q+i);\n\t\tq[i]--;\n\t}\n\tfor(int i=0;i<b;i++)last[i]=-1;\n\tMCF::init((c+1)*3+2);\n\tint s=(c+1)*3;\n\tint t=(c+1)*3+1;\n\tMCF::ae(s,0,10,0);\n\tMCF::ae(c,t,10,0);\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i,i+1,10,0);\n\t\tMCF::ae(i,c+1+i,1,p[q[i]]);\n\t\tMCF::ae(2*c+2+i,i+1,1,0);\n\t\tMCF::ae(c+1+i,2*c+2+i,1,-1000000000);\n\t\tif(~last[q[i]]){\n\t\t\tMCF::ae(2*c+2+last[q[i]],c+1+i,1,0);\n\t\t}\n\t\tlast[q[i]]=i;\n\t}\n\tMCF::solve(s,t,a);\n\tprintf(\"%lld\\n\",MCF::toc+1000000000LL*c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n \nusing namespace std;\ntypedef pair<int,int> P;\n \nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n \nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n \nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n \n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n \n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n \n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      if(M==1){\n        for(j=MAX(i+1,initial);j<nxt;j++){        \n          nbr[i].push_back(j);\n          cost[i].push_back(w[a[i]]);\n          num_nbr[i]++;\n          //        if(j > MAX(i+1,initial) + 10) break;\n        }\n        nbr[i].push_back(nxt);\n        num_nbr[i]++;\n        cost[i].push_back(0);\n      }\n      else{\n        nbr[i].push_back(i+1);\n        cost[i].push_back(w[a[i]]);\n        num_nbr[i]++;\n      }\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n}\n \nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n   \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n   \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n \n  int cnt = 0;\n  for(int s=0;s<K-M;s++){\n    fill(dist,dist+K+1,INT_MAX);\n      dist[s] = 0;\n      que.push(P(0,s));\n//    printf(\"\\n%d-th loop\",++cnt);\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n//      printf(\"node %d established.\\n\",u);\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    for(i = 0;i < K-M;i++) h[i] += (dist[i] == INT_MAX)? 0:dist[i];\n    h[t] += (dist[t] == INT_MAX)? 0:dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n  return res;\n}\n \nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n \nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int CAPA_INF=1<<29;\nconst int COST_INF=1<<29;\n\ntemplate<class T,class U>\nstruct Edge{\n\tint v,rev;\n\tT capa;\n\tU cost;\n\tT flow;\n};\n\ntemplate<class T,class U>\nstruct AdjList:public vector< vector< Edge<T,U> > >{\n\tAdjList(int n):vector< vector< Edge<T,U> > >(n){}\n};\n\ntemplate<class T,class U>\nvoid add_edge(AdjList<T,U> &adj,int u,int v,T capa,U cost){\n\tadj[u].push_back((Edge<T,U>){v,adj[v].size()  ,capa, cost,0});\n\tadj[v].push_back((Edge<T,U>){u,adj[u].size()-1,   0,-cost,0});\n}\n\ntemplate<class T,class U>\npair<T,U> augment(AdjList<T,U> &adj,int s,int t,vector<U> &pot,bool first){\n\tint n=adj.size();\n\tvector<int> pre(n);\n\tvector<U> d(n,COST_INF); d[s]=0;\n\n\tif(first){\n\t\trep(u,n) rep(i,adj[u].size()) {\n\t\t\tEdge<T,U> &e=adj[u][i];\n\t\t\tif(e.capa-e.flow>0 && d[u]+e.cost<d[e.v]){\n\t\t\t\td[e.v]=d[u]+e.cost;\n\t\t\t\tpre[e.v]=e.rev;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t// Dijkstra\n\t\tbool ok=false;\n\t\tpriority_queue< pair<U,int> > pq; pq.push(make_pair(0,s));\n\t\twhile(!pq.empty()){\n\t\t\tint u=pq.top().second;\n\t\t\tU cost=-pq.top().first; pq.pop();\n\n\t\t\tif(cost<d[u]) continue;\n\t\t\tif(u==t) ok=true;\n\n\t\t\trep(i,adj[u].size()){\n\t\t\t\tEdge<T,U> &e=adj[u][i];\n\t\t\t\tU cost2=cost+e.cost+pot[u]-pot[e.v];\n\t\t\t\tif(e.capa-e.flow>0 && cost2<d[e.v]){\n\t\t\t\t\td[e.v]=cost2;\n\t\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\t\tpq.push(make_pair(-cost2,e.v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!ok) return make_pair(0,0);\n\t}\n\n\tT water=CAPA_INF;\n\tfor(int v=t;v!=s;){\n\t\tEdge<T,U> &e1=adj[v][pre[v]];\n\t\tEdge<T,U> &e2=adj[e1.v][e1.rev];\n\t\twater=min(water,e2.capa-e2.flow);\n\t\tv=e1.v;\n\t}\n\n\tU cost=0;\n\tfor(int v=t;v!=s;){\n\t\tEdge<T,U> &e1=adj[v][pre[v]];\n\t\tEdge<T,U> &e2=adj[e1.v][e1.rev];\n\t\te1.flow-=water;\n\t\te2.flow+=water;\n\t\tcost+=water*e2.cost;\n\t\tv=e1.v;\n\t}\n\n\trep(u,n) pot[u]+=d[u];\n\n\treturn make_pair(water,cost);\n}\n\ntemplate<class T,class U>\npair<T,U> primal_dual(AdjList<T,U> &adj,int s,int t){\n\tT ans1=0;\n\tU ans2=0;\n\tvector<U> pot(adj.size());\n\tfor(int i=0;;i++){\n\t\tpair<T,U> tmp=augment(adj,s,t,pot,i==0);\n\t\tif(tmp.first==0) break;\n\t\tans1+=tmp.first;\n\t\tans2+=tmp.second;\n\t}\n\treturn make_pair(ans1,ans2);\n}\n\nint main(){\n\tint m,n,k; scanf(\"%d%d%d\",&m,&n,&k);\n\tint w[10000];\n\trep(i,n) scanf(\"%d\",w+i);\n\n\tAdjList<int,int> adj(k+1);\n\n\tint wsum=0;\n\tint pre[10000];\n\trep(a,n) pre[a]=-1;\n\trep(i,k){\n\t\tint a; scanf(\"%d\",&a); a--;\n\t\tadd_edge(adj,i,i+1,i<k-1?CAPA_INF:m-1,0);\n\t\tif(~pre[a]){\n\t\t\tadd_edge(adj,pre[a]+1,i,1,-w[a]);\n\t\t}\n\t\tpre[a]=i;\n\t\twsum+=w[a];\n\t}\n\n\tprintf(\"%d\\n\",wsum+primal_dual(adj,0,k).second);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 10005;\nconst int M = N * 4;\n\nint n, m, k;\nint w[N];\nint a[N];\nint lst[N];\n\ntypedef int ftype;\nconst ftype INF = 0x3f3f3f3f;\nint head[N], to[M], nxt[M], tot, cur[N];\nftype cap[M], cost[M], flow[N], dis[N], mncost, mxflow;\nbool vis[N];\ninline void init() { tot = 0; memset(head, -1, sizeof(head)); }\ninline void addedge(int x, int y, ftype w, ftype c) {\n  to[tot] = y; cap[tot] = w; cost[tot] = c; nxt[tot] = head[x]; head[x] = tot++;\n  to[tot] = x; cap[tot] = 0; cost[tot] = -c; nxt[tot] = head[y]; head[y] = tot++;\n}\nbool SPFA(int src, int sink) {\n  memset(dis, 0x3f, sizeof(dis));\n  memset(vis, 0, sizeof(vis));\n  dis[src] = 0; cur[src] = -1; flow[src] = INF;\n  queue<int> que; que.push(src);\n  while (!que.empty()) {\n    int u = que.front(); que.pop();\n    vis[u] = false;\n    for (int i = head[u], v; ~i; i = nxt[i]) {\n      v = to[i];\n      if (cap[i] > 0 && dis[v] > dis[u] + cost[i]) {\n        dis[v] = dis[u] + cost[i]; flow[v] = min(flow[u], cap[i]); cur[v] = i;\n        if (!vis[v]) { vis[v] = true; que.push(v); }\n      }\n    }\n  }\n  if (dis[sink] == INF) { return false; }\n  mxflow += flow[sink]; mncost += flow[sink] * dis[sink];\n  for (int i = cur[sink]; ~i; i = cur[to[i ^ 1]]) {\n    cap[i] -= flow[sink]; cap[i ^ 1] += flow[sink];\n  }\n  return true;\n}\nftype MCMF(int src, int sink) {\n  mxflow = mncost = 0;\n  while (SPFA(src, sink));\n  return mncost;\n}\n\nint main() {\n  while (~scanf(\"%d%d%d\", &m, &n, &k)) {\n    init(); memset(lst, 0, sizeof(lst));\n    int sum = 0; m--;\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d\", &w[i]);\n    }\n    for (int i = 1; i <= k; i++) {\n      scanf(\"%d\", &a[i]);\n    }\n    k = unique(a + 1, a + k + 1) - a - 1;\n    for (int i = 1; i <= k; i++) {\n      if (lst[w[a[i]]]) { addedge(lst[w[a[i]]], i - 1, 1, -w[a[i]]); }\n      lst[w[a[i]]] = i;\n      sum += w[a[i]];\n    }\n    for (int i = 2; i <= k; i++) {\n      addedge(i - 1, i, m, 0);\n    }\n    int src = k + 1, sink = src + 1;\n    addedge(src, 1, m, 0);\n    addedge(k, sink, m, 0);\n    printf(\"%d\\n\", sum + MCMF(src, sink));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint w[10000];\nvector<int> id[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tid[a - 1].push_back(i);\n\t\tsum += w[a - 1];\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, M, 0);\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < (int)id[i].size() - 1; j++) {\n\t\t\t//cout << id[i][j] + 1 + 1 << \" \" << id[i][j + 1] + 1 << \" \" << -w[i] << endl;\n\t\t\tpd.add_edge(id[i][j] + 1, id[i][j + 1], 1, -w[i]);\n\t\t}\n\t}\n\n\tint res = pd.solve(0, K - 1, M - 1);\n\tassert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n  \ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f){\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 200000000;\n  \n  while(f > 0){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    \n    bool update = true;\n    \n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n\tif(dist[v] == inf) continue;\n\tfor(int i = 0; i < (int)g[v].size(); i++){\n\t  E &e = g[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t    dist[e.to]  = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update      = true;\n\t  }\n\t}\n    }\n    \n    if(dist[t] == inf){\n      return -1;\n    }\n    \n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n    \n    f   -= d;\n    res += d * dist[t];\n    \n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap           -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m = getInt();\n  int n = getInt();\n  int k = getInt();\n\n  vector<int> w(n);\n  vector<int> a(k);\n\n  Graph<CostEdge> g(k);\n\n  REP(i,n) w[i] = getInt();\n  REP(i,k) a[i] = getInt() - 1;\n\n  int ans = 0;\n  REP(i,k) ans += w[a[i]];\n\n  vector<int> prevs(n, -1);\n\n  REP(i,k){\n    if(i != k - 1) g.addEdge(i, i + 1, 10000, 0);\n    int aa = a[i];\n    if(prevs[aa] != -1){\n      int j = prevs[aa];\n      if(j + 1 == i){\n\tans -= w[a[i]];\n      }else{\n\tg.addEdge(j + 1, i, 1, - w[a[i]]);\n      }\n    }\n    prevs[aa] = i;\n  }\n\n  ans += minCostFlow(g, 0, k - 1, m - 1);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 10005;\nconst int M = N * 8;\n\nint n, m, k;\nint w[N];\nint a[N];\nint lst[N];\n\ntypedef int ftype;\nconst ftype INF = 0x3f3f3f3f;\nint head[N], to[M], nxt[M], tot, cur[N];\nftype cap[M], cost[M], flow[N], dis[N], mncost, mxflow;\nbool vis[N];\ninline void init() { tot = 0; memset(head, -1, sizeof(head)); }\ninline void addedge(int x, int y, ftype w, ftype c) {\n  to[tot] = y; cap[tot] = w; cost[tot] = c; nxt[tot] = head[x]; head[x] = tot++;\n  to[tot] = x; cap[tot] = 0; cost[tot] = -c; nxt[tot] = head[y]; head[y] = tot++;\n}\nbool SPFA(int src, int sink) {\n  memset(dis, 0x3f, sizeof(dis));\n  memset(vis, 0, sizeof(vis));\n  dis[src] = 0; cur[src] = -1; flow[src] = INF;\n  stack<int> que; que.push(src);\n  while (!que.empty()) {\n    int u = que.top(); que.pop();\n    vis[u] = false;\n    for (int i = head[u], v; ~i; i = nxt[i]) {\n      v = to[i];\n      if (cap[i] > 0 && dis[v] > dis[u] + cost[i]) {\n        dis[v] = dis[u] + cost[i]; flow[v] = min(flow[u], cap[i]); cur[v] = i;\n        if (!vis[v]) { vis[v] = true; que.push(v); }\n      }\n    }\n  }\n  if (dis[sink] == INF) { return false; }\n  mxflow += flow[sink]; mncost += flow[sink] * dis[sink];\n  for (int i = cur[sink]; ~i; i = cur[to[i ^ 1]]) {\n    cap[i] -= flow[sink]; cap[i ^ 1] += flow[sink];\n  }\n  return true;\n}\nftype MCMF(int src, int sink) {\n  mxflow = mncost = 0;\n  while (SPFA(src, sink));\n  return mncost;\n}\n\nint main() {\n  while (~scanf(\"%d%d%d\", &m, &n, &k)) {\n    init(); memset(lst, 0, sizeof(lst));\n    int sum = 0; m--;\n    for (int i = 1; i <= n; i++) {\n      scanf(\"%d\", &w[i]);\n    }\n    for (int i = 1; i <= k; i++) {\n      scanf(\"%d\", &a[i]);\n    }\n    k = unique(a + 1, a + k + 1) - a - 1;\n    for (int i = 1; i <= k; i++) {\n      if (lst[w[a[i]]]) { addedge(lst[w[a[i]]], i - 1, 1, -w[a[i]]); }\n      lst[w[a[i]]] = i;\n      sum += w[a[i]];\n    }\n    for (int i = 2; i <= k; i++) {\n      addedge(i - 1, i, m, 0);\n    }\n    int src = k + 1, sink = src + 1;\n    addedge(src, 1, m, 0);\n    addedge(k, sink, m, 0);\n    printf(\"%d\\n\", sum + MCMF(src, sink));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int INT_INF = 1 << 29;\nconst ll INF = 1LL<<55;\n\ntypedef pair<int, int> P;\nstruct edge {\n\tint to;\n\tint cap;\n\tll cost;\n\tint rev;\n};\n\nconst int MAX_V = 20010;\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, ll cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nll min_cost_flow(int s, int t, int f) {\n\tll res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 10010, MAX_K = 10010;\nconst ll OFFSET = 1LL<<30;\nint main(int argc, char *argv[]) {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tint w[MAX_N];\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tint a[MAX_K];\n\tfor (int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t}\n\tV = K*2+4;\n\tadd_edge(0, V-3, INT_INF, 0);\n\tadd_edge(V-2, 0, M, 0);\n\tadd_edge(V-3, V-1, M, 0);\n\tfor (int i = 0; i < K; i++) {\n\t\tadd_edge(0, i*2+1, 1, w[a[i]]);\n\t\tadd_edge(i*2+2, i*2+1, 1, OFFSET);\n\t\tadd_edge(V-2, i*2+2, 1, 0);\n\t\tadd_edge(i*2+1, V-1, 1, 0);\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (a[i] == a[j]) {\n\t\t\t\tadd_edge(j*2+2, i*2+1, 1, 0);\n\t\t\t} else {\n\t\t\t\tadd_edge(j*2+2, i*2+1, 1, w[a[i]]);\n\t\t\t}\n\t\t}\n\t\tadd_edge(i*2+2, V-3, 1, 0);\n\t}\n\tprintf(\"%lld\\n\", min_cost_flow(V-2, V-1, M+K));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;//shortest pass,vertex number\n\nconst int MAX=10010;\nconst int INF=1<<25;\n\nclass edge\n{\npublic:\n\tint to,cap,cost,rev;\n\tedge(){}\n\tedge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost)\n{\n\tG[from].push_back(edge(to,cap,cost,G[to].size()));\n\tG[to].push_back(edge(from,0,-cost,G[from].size()-1));\n\treturn;\n}\n\nint mincostflow(int s,int t,int f)\n{\n\tint res=0;\n\tmemset(h,0,sizeof(h));\n\twhile(f>0)\n\t{\n\t\tpriority_queue<P> Q;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tQ.push(P(0,s));\n\t\t\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tP p=Q.top();Q.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first*(-1))continue;\n\t\t\tfor(int i=0;i<G[v].size();i++)\n\t\t\t{\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to])\n\t\t\t\t{\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tQ.push(P(dist[e.to]*(-1),e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(dist[t]==INF)return -1;\n\t\t\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\t\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint m,n,k;\n\tcin>>m>>n>>k;\n\tV=k+1;\n\tint w[MAX];\n\tfor(int i=0;i<n;i++)cin>>w[i];\n\tint prev[MAX];\n\tmemset(prev,-1,sizeof(prev));\n\tint ans=0;\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tint a;\n\t\tcin>>a;\n\t\ta--;\n\t\t\n\t\tadd_edge(i,i+1,INF,0);\n\t\t\n\t\tans+=w[a];\n\t\t\n\t\tif(prev[a]!=-1)\n\t\t{\n\t\t\tif(prev[a]+1==i)\n\t\t\t{\n\t\t\t\tans-=w[a];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tadd_edge(prev[a]+1,i,1,-w[a]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprev[a]=i;\n\t}\n\t\n\tcout<<ans+mincostflow(0,k,m-1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\n\nstruct edge { int to, cap, cost, rev;};\n\nconst int MAX_V = 1000000;\nconst int MAX_N = 1000000;\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].push_back((edge){to, cap, cost, G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h, h + V, 0);\n    while(f > 0){\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(pii(0, s));\n        while(!que.empty()){\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(int i = 0; i < G[v].size(); i++){\n                edge &e = G[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[t] == INF) return -1;\n        for(int v = 0; v < V; v++) h[v] += dist[v];\n        int d = f;\n        for(int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d * h[t];\n        for(int v = t; v != s; v = prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint N, K;\nint a[MAX_N], b[MAX_N], w[MAX_N];\nvi wb, ab;\n\nvoid solve(){\n    vi x;\n    rep(i, N){\n\tx.pb(a[i]);\n\tx.pb(b[i]);\n    }\n    sort(all(x));\n    UNIQUE(x);\n    \n    int m = x.size();\n    int s = m, t = s + 1;\n    V = t + 1;\n    int res = 0;\n    add_edge(s, 0, K, 0);\n    add_edge(max(0, m - 1), t, K, 0);\n    for(int i = 0; i + 1 < m; i++){\n\tadd_edge(i, i + 1, INF, 0);\n    }\n    rep(i,N){\n\tint u = find(all(x), a[i]) - x.begin();\n\tint v = find(all(x), b[i]) - x.begin();\n\tadd_edge(v, u, 1, w[i]);\n\tadd_edge(s, v, 1, 0);\n\tadd_edge(u, t, 1, 0);\n\tres -= w[i];\n    }\n//    cerr << res << endl;\n    res += min_cost_flow(s, t, K + N);\n//    cerr << res << endl;\n    rep(i,ab.size()) res += wb[ab[i]];\n    cout << res << endl;\n}\n\nvoid input(){\n    int m, n, k;\n    cin >> m >> n >> k;\n    rep(i,n){\n\tint t;\n\tcin >> t;\n\twb.pb(t);\n    }\n    rep(i,k){\n\tint t;\n\tcin >> t;\n\tt--;\n\tab.pb(t);\n    }\n    //UNIQUE(ab);\n    int tmp[MAX_N];\n    memset(tmp, -1, sizeof(tmp));\n    int cnt = 0;\n    rep(i,k){\n\tif(tmp[ab[i]] != -1){\n\t    a[cnt] = tmp[ab[i]] + 1;\n\t    b[cnt] = i;\n\t    w[cnt] = wb[ab[i]];\n\t    cnt++;\n\t}\n\ttmp[ab[i]] = i;\n    }\n    N = cnt;\n    K = m - 1;\n/*\n    rep(i,cnt){\n\tcout << a[i] << ' ' << b[i] << ' ' << w[i] << endl;\n    }\n*/\n}\n\nint main() {\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\ntypedef int weight;\ntypedef pair<weight, int> P;\nconst weight INF = (1 << 29);\n\nstruct edge {\n\tint to;\n\tint cap;\n\tweight cost;\n\tint rev;\n\tedge(int to_, int cap_, weight cost_, int rev_) :to(to_), cap(cap_), cost(cost_), rev(rev_) {};\n};\n\nvector<vector<edge>> G;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n}\n\nvoid add_edge(int from, int to, int cap, weight cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\n\nweight min_cost_flow(int s, int t, weight f) {\n\tconst int n = G.size();\n\tweight res = 0;\n\tvector<int> prevv(n), preve(n);\n\twhile(f > 0) {\n\t\tvector<weight> dist(n, INF);\n\t\tdist[s] = 0;\n\n\t\twhile(true) {\n\t\t\tbool update = false;\n\t\t\tfor(int v = 0; v < n; ++v) {\n\t\t\t\tfor(unsigned i = 0; i < G[v].size(); ++i) {\n\t\t\t\t\tconst auto &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\n\t\tif(dist[t] == INF) return -1;\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tinit(K);\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tadd_edge(i, i + 1, 1000000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tadd_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\n\tll res = min_cost_flow(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2266: Cache Strategy\n * ?¢??????????n????????????????????????m????????????????????????????????????????????????????????§?????????????°????????????¨?????????????????\\?????\\???????????\\??????????????????????????±?´???°?????°??????????????\\?????¢????±?????°??????±?´????\n * ?±???????????°??´?\n * ??????????°??????\\???????????????????????±???????????????????¬?????????¢???????????±?´??????°???????????????????????¨???????????????????????????????????´??????????????????????????´???????????¨???????????????????????±?´????????????\\????????????????????¶????°??????°?????´???????????????????????????1??±?´??´?????????????????????¨?????????INF??±?´?0???????°???´??????????????\\????±?????°??´???¨??????????????\\??????????????§??????????????°??????????¢??????????????§?????????????????????????\n */\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\n\nint a[10010], w[10010];\nint pre[10010];\n\nstruct Edge {\n  Edge() {}\n\n  Edge(int _v, int _cap, int _cost, int _rev) : v(_v), cap(_cap), cost(_cost), rev(_rev) {}\n\n  int v, cap, cost, rev;\n};\n\nvector<Edge> e[10010];\nint n;\nint h[10010], d[10010];\nint pv[10010], pe[10010];\npriority_queue<pii, vector<pii>, greater<pii> > pq;\n\nvoid AddEdge(int u, int v, int cap, int cost) {\n  e[u].push_back(Edge(v, cap, cost, e[v].size()));\n  e[v].push_back(Edge(u, 0, -cost, e[u].size() - 1));\n}\n\nint MinCostFlow(int s, int t, int f) {\n  int ans = 0;\n  memset(h, 0, sizeof(h));\n  while (f > 0) {\n    memset(d, 0x3f, sizeof(d));\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n    while (!pq.empty()) {\n      int u = pq.top().second;\n      int pre = pq.top().first;\n      pq.pop();\n      if (d[u] < pre) continue;\n      for (int i = 0; i < e[u].size(); ++i) {\n        Edge &te = e[u][i];\n        int v = te.v;\n        if (te.cap > 0 && d[v] > d[u] + h[u] - h[v] + te.cost) {\n          d[v] = d[u] + h[u] - h[v] + te.cost;\n          pv[v] = u;\n          pe[v] = i;\n          pq.push(make_pair(d[v], v));\n        }\n      }\n    }\n\n    if (d[t] == INF) {\n      return -1;\n    }\n    for (int i = 0; i < n; ++i) {\n      h[i] += d[i];\n    }\n\n    int cur = f;\n    for (int i = t; i != s; i = pv[i]) {\n      cur = min(cur, e[pv[i]][pe[i]].cap);\n    }\n    ans += cur * h[t];\n    f -= cur;\n    for (int i = t; i != s; i = pv[i]) {\n      Edge &te = e[pv[i]][pe[i]];\n      te.cap -= cur;\n      e[i][te.rev].cap += cur;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  int M, N, K, ans = 0;\n  scanf(\"%d%d%d\", &M, &N, &K);\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; ++i) {\n    scanf(\"%d\", &a[i]);\n    --a[i];\n  }\n  K = unique(a, a + K) - a;\n\n  memset(pre, -1, sizeof(pre));\n  for (int i = 0; i < K; ++i) {\n    ans += w[a[i]];\n    if (pre[a[i]] != -1) {\n      AddEdge(pre[a[i]], i - 1, 1, -w[a[i]]);\n    }\n    pre[a[i]] = i;\n  }\n  for (int i = 1; i < K; ++i) {\n    AddEdge(i - 1, i, INF, 0);\n  }\n  n = K;\n  ans += MinCostFlow(0, n - 1, M - 1);\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\nconst int MAX=10100;\nconst int INF=1<<25;\n\nclass edge\n{\npublic:\n\tint to,cap,cost,rev;\n\tedge(){}\n\tedge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost)\n{\n\tG[from].push_back(edge(to,cap,cost,G[to].size()));\n\tG[to].push_back(edge(from,0,-cost,G[from].size()-1));\n\treturn;\n}\n\nint mincostflow(int s,int t,int f)\n{\n\tint res=0;\n\twhile(f>0)\n\t{\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tbool update=true;\n\t\twhile(update)\n\t\t{\n\t\t\tupdate=false;\n\t\t\tfor(int v=0;v<V;v++)\n\t\t\t{\n\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\tfor(int i=0;i<G[v].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost;\n\t\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(dist[t]==INF)return -1;\n\t\t\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n\t\tf-=d;\n\t\tres+=d*dist[t];\n\t\t\n\t\tfor(int v=t;v!=s;v=prevv[v])\n\t\t{\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint m,n,k;\n\tcin>>m>>n>>k;\n\tV=k+1;\n\tint w[MAX];\n\tfor(int i=0;i<n;i++)cin>>w[i];\n\tint prev[MAX];\n\tmemset(prev,-1,sizeof(prev));\n\tint ans=0;\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tint a;\n\t\tcin>>a;\n\t\ta--;\n\t\t\n\t\tadd_edge(i,i+1,INF,0);\n\t\t\n\t\tans+=w[a];\n\t\t\n\t\tif(prev[a]!=-1)\n\t\t{\n\t\t\tif(prev[a]+1==i)\n\t\t\t{\n\t\t\t\tans-=w[a];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tadd_edge(prev[a]+1,i,1,-w[a]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprev[a]=i;\n\t}\n\t\n\tcout<<ans+mincostflow(0,k,m-1)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n  \ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f){\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 200000000;\n  \n  while(f > 0){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    \n    bool update = true;\n    \n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n\tif(dist[v] == inf) continue;\n\tfor(int i = 0; i < (int)g[v].size(); i++){\n\t  E &e = g[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t    dist[e.to]  = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update      = true;\n\t  }\n\t}\n    }\n    \n    if(dist[t] == inf){\n      return -1;\n    }\n    \n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n    \n    f   -= d;\n    res += d * dist[t];\n    \n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap           -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m = getInt();\n  int n = getInt();\n  int k = getInt();\n\n  vector<int> w(n);\n  vector<int> a(k);\n\n  Graph<CostEdge> g(k);\n\n  REP(i,n) w[i] = getInt();\n  REP(i,k) a[i] = getInt() - 1;\n\n  int ans = 0;\n  REP(i,k) ans += w[a[i]];\n\n  vector<int> prevs(n, -1);\n\n  REP(i,k){\n    if(i != k - 1) g.addEdge(i, i + 1, 10000, 0);\n    int aa = a[i];\n    if(prevs[aa] != -1){\n      int j = prevs[aa];\n      if(j + 1 == i){\n\tans -= w[a[i]];\n      }else{\n\tg.addEdge(j + 1, i, 1, - w[a[i]]);\n      }\n    }\n    prevs[aa] = i;\n  }\n\n  ans += minCostFlow(g, 0, k - 1, m - 1);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<string>\n#include<assert.h>\n#include<math.h>\n#include<stdio.h>\n#include<ctype.h>\n#endif\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define DEBUG if(0)\n#endif\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r) { bool a = l>r; if (a)l = r; return a; }\ntemplate <typename T>inline bool chmax(T &l, T r) { bool a = l<r; if (a)l = r; return a; }\n\nstruct input {\n\tbool success;\n\tinput(){success = true;}\n#ifdef BTK\n\ttemplate<typename T>inline input& operator>>(T& x) {success = !!(cin >> x);return *this;}\n#else\n\tinline input& operator>>(LL& x) {success = (scanf(\"%lld\", &x) != EOF);return *this;}\n\tinline input& operator>>(int& x) {success = (scanf(\"%d\", &x) != EOF);return *this;}\n\tinline input& operator>>(char* x) {success = (scanf(\"%s\", x) != EOF);return *this;}\n\tinline input& operator>>(double& x) {success = (scanf(\"%llf\", &x) != EOF);return *this;}\n#endif\n}in;\n\nconst char space = ' ';\nconst char ln = '\\n';\nstruct output {\n#ifdef BTK\n\ttemplate<typename T>inline output& operator<<(T x) {cout << x; return (*this);}\n\tinline void fp(const double x, const char* s) { char buf[20];sprintf(buf, s, x); cout << buf;}\n#else\n\tinline output& operator<<(const string& x) { printf(\"%s\", x.c_str()); return *this; }\n\tinline output& operator<<(const int x) { printf(\"%d\", x); return *this;}\n\tinline output& operator<<(const char x) { putchar(x); return *this;}\n\tinline output& operator<<(const LL x) { printf(\"%lld\", x); return *this;}\n\tinline output& operator<<(const double x) { printf(\"%lf\", x); return *this;}\n\tinline void fp(const double x, const char* s) {printf(s, x);}\n#endif\n}out;\ntypedef int FLOW;\ntypedef LL COST;\nnamespace MinCostFlow {\n\tconst FLOW FLOW_INF = 1e7;\n\tconst COST COST_INF = 1e15;\n\tstruct edge {\n\t\tFLOW flow; COST cost;\n\t\tint to, rev;\n\t};\n\ttypedef vector<edge> E;\n\ttypedef vector<E> Graph;\n\tvoid addedge(Graph&g, int from, int to, FLOW f, COST c) {\n\t\tint x = g[from].size();\n\t\tint y = g[to].size();\n\t\tedge a = { f,c,to,y };\n\t\tedge b = { (FLOW)0,-c,from,x };\n\t\tg[from].push_back(a);\n\t\tg[to].push_back(b);\n\t}\n\n\tconst int BUF = 11234;\n\tCOST h[BUF];\n\tCOST d[BUF];\n\tint pV[BUF];\n\tint pE[BUF];\n\tvoid init(int size = BUF) {\n\t\tREP(i, size)h[i] = 0;\n\t}\n\ttypedef pair<COST, int> P;\n\tpriority_queue<P> que;\n}\n\n\n\npair<FLOW, COST> maxflow(MinCostFlow::Graph &g, int s, int t, bool init = true) {\n\tconst int V = g.size();\n\tif (init)MinCostFlow::init();\n\tusing namespace MinCostFlow;\n\tCOST c = 0;\n\tFLOW f = 0;\n\twhile (true) {\n\t\tfill(d, d + V, COST_INF);\n\t\td[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (que.size()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tCOST cost = -p.first;\n\t\t\tint v = p.second;\n\t\t\tif (d[v]<cost)continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tedge &e = g[v][i];\n\t\t\t\tif (e.flow>0 && d[e.to]>d[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\td[e.to] = d[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tpV[e.to] = v;\n\t\t\t\t\tpE[e.to] = i;\n\t\t\t\t\tque.push(P(-d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t] == COST_INF)break;\n\n\t\tREP(v, V)h[v] += d[v];\n\t\tFLOW ff = FLOW_INF;\n\t\tfor (int v = t; v != s; v = pV[v]) {\n\t\t\tedge& e = g[pV[v]][pE[v]];\n\t\t\tchmin(ff, e.flow);\n\t\t}\n\t\tf += ff;\n\t\tc += ff*h[t];\n\t\tfor (int v = t; v != s; v = pV[v]) {\n\t\t\tedge &e = g[pV[v]][pE[v]];\n\t\t\te.flow -= ff;\n\t\t\tg[v][e.rev].flow += ff;\n\t\t}\n\t}\n\treturn pair<FLOW, COST>(f, c);\n}\n\nLL w[112345];\nint pos[112345];\nint main() {\n\tint M, N, K;\n\tin >> M >> N >> K;\n\tM--;\n\tREP(i, N)in >> w[i];\n\tREP(i, N)pos[i] = -1;\n\tint V = K + 1;\n\tint S = V++;\n\tint T = V++;\n\tMinCostFlow::Graph g(V);\n\tMinCostFlow::addedge(g, S, 0, M, 0);\n\tMinCostFlow::addedge(g, K, T, M, 0);\n\tREP(i, K)MinCostFlow::addedge(g, i, i + 1, M, 10000);\n\tLL tot = 0;\n\tREP(i, K) {\n\t\tint a;\n\t\tin >> a;\n\t\ta--;\n\t\ttot += w[a];\n\t\tif (pos[a] != -1&&pos[a]!=i) {\n\t\t\tMinCostFlow::addedge(g, pos[a], i, 1, (10000)*(i-pos[a])-w[a]);\n\t\t}\n\t\tif (pos[a] == i)tot -= w[a];\n\t\tpos[a] = i + 1;\n\t}\n\tpair<FLOW, COST> fc = maxflow(g, S, T);\n\tout << tot + fc.second - M*10000*K<<ln;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\ntypedef ll PD_Type;\nconst PD_Type PD_INF = 1 << 30;\n\nstruct Primal_Dual\n{\n    typedef pair< PD_Type, int > pii;\n    \n    struct edge\n    {\n        int to, rev;\n        PD_Type    cap, cost;\n        edge() {}\n        edge(int to, PD_Type cap, PD_Type cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n        \n    };\n    vector< vector< edge > > graph;\n    vector< int > prevv, preve;\n    vector< PD_Type > potential, min_cost;\n    Primal_Dual(int V) : graph(V) {}\n    \n    void add_edge(int from, int to, PD_Type cap, PD_Type cost)\n    {\n        graph[from].push_back(edge(to, cap, cost, (int)graph[to].size()));\n        graph[to].push_back(edge(from, 0, -cost, (int)graph[from].size() - 1));\n    }\n    \n    PD_Type min_cost_flow(int s, int t, int f)\n    {\n        int V = (int)graph.size();\n        PD_Type ret = 0;\n        priority_queue< pii, vector< pii >, greater< pii > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n        \n        while (f > 0) {\n            min_cost.assign(V, PD_INF);\n            que.push(pii(0, s));\n            min_cost[s] = 0;\n            \n            while (!que.empty()) {\n                pii p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < (int)graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    PD_Type nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second; preve[e.to] = i;\n                        que.push(pii(min_cost[e.to], e.to));\n                    }\n                }\n            }\n            if (min_cost[t] == PD_INF) return -1;\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            PD_Type addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n};\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int M,N,K; cin >> M >> N >> K;\n    Primal_Dual F(K);\n    \n    int res = 0;\n    vector<int> A(N);\n    vector<vector<int> > B(N);\n    for(int i = 0; i < N;i++) cin >> A[i];\n    for(int i = 0; i < K;i++){\n        int a; cin >> a; a--;\n        B[a].push_back(i);\n        res += A[a];\n    }\n    \n    for(int i = 0; i < N;i++){\n        if((int)B[i].size() <= 1) continue;\n        for(int j = 0; j < (int)B[i].size()-1;j++){\n            int s = B[i][j], t = B[i][j+1];\n            if(s+1 != t){\n                F.add_edge(s+1, t, 1, -A[i]);\n            }else{\n                res -= A[i];\n            }\n        }\n    }\n    for(int i = 0; i < K-1;i++){\n        F.add_edge(i, i+1, M, 0);\n    }\n    cout << res + F.min_cost_flow(0, K-1, M-1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int INT_INF = 1 << 29;\nconst ll INF = 1LL<<55;\n\ntypedef pair<int, int> P;\nstruct edge {\n\tint to;\n\tint cap;\n\tll cost;\n\tint rev;\n};\n\nconst int MAX_V = 20010;\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, ll cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nll min_cost_flow(int s, int t, int f, bool bell = false) {\n\tll res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\tif (bell) {\n\t\t\tbell = false;\n\t\t\tbool update;\n\t\t\tdo {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\t\tfor (edge e: G[i]) {\n\t\t\t\t\t\tif (e.cap > 0 && dist[i] != INF && dist[e.to] > dist[i] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[i] + e.cost;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t} else {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 10010, MAX_K = 10010;\nconst ll OFFSET = 1LL<<30;\nint main(int argc, char *argv[]) {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tint w[MAX_N];\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tint a[MAX_K], r = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t\tr+= w[a[i]];\n\t}\n\tint b[MAX_N];\n\tfill_n(b, MAX_N, -1);\n\tadd_edge(K+1, 0, M-1, 0);\n\tadd_edge(K, K+2, M-1, 0);\n\tint cc = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tadd_edge(i, i+1, M-1, 0);\n\t\tif (b[a[i]] != -1) {\n\t\t\tadd_edge(i, b[a[i]], 1, w[a[i]]);\n\t\t\tadd_edge(K+1, i, 1, 0);\n\t\t\tadd_edge(b[a[i]], K+2, 1, 0);\n\t\t\tr -= w[a[i]];\n\t\t\tcc++;\n\t\t}\n\t\tb[a[i]] = i+1;\n\t}\n\tV = K+3;\n\tprintf(\"%lld\\n\", r + min_cost_flow(K+1, K+2, M+cc-1, false));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1<<28;\nstruct edge{int to,cap,cost,rev;};\nvector<edge> graph[vmax];\n\nint dist[vmax];\nint pv[vmax],pe[vmax];\ntypedef tuple<int,int> state;\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tgraph[from].push_back({to,cap,cost,(int)graph[to].size()});\n\tgraph[to].push_back({from,0,-cost,(int)graph[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f,int n){\n\tint res=0;\n\twhile(f>0){\n\t\tfill(dist,dist+n,inf);\n\t\tdist[s]=0;\n\t\tbool update=true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\trep(v,n){\n\t\t\t\tif(dist[v]==inf) continue;\n\t\t\t\trep(i,graph[v].size()){\n\t\t\t\t\tedge &e=graph[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost;\n\t\t\t\t\t\tpv[e.to]=v,pe[e.to]=i;\n\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t]==inf) return -1;\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=pv[v]) d=min(d,graph[pv[v]][pe[v]].cap);\n\t\tf-=d;\n\t\tres+=d*dist[t];\n\n\t\tfor(int v=t;v!=s;v=pv[v]){\n\t\t\tedge &e=graph[pv[v]][pe[v]];\n\t\t\te.cap-=d;\n\t\t\tgraph[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint w[10010];\nint a[10010];\n\nint main(void){\n\tint m,n,k;\n\tcin >> m >> n >> k;\n\trep(i,n) cin >> w[i];\n\trep(i,k) cin >> a[i],a[i]--;\n\n\tint sum=0;\n\trep(i,k){\n\t\tif(i-1>=0&&a[i]==a[i-1]) continue;\n\t\tsum+=w[a[i]];\n\t}\n\n\trep(i,k-1) add_edge(i,i+1,inf,0);\n\n\tint prev[10010];\n\trep(i,n) prev[i]=-1;\n\n\trep(i,k){\n\t\tint cur=a[i];\n\t\tif(prev[cur]!=-1&&prev[cur]+1!=i) add_edge(prev[cur]+1,i,1,-w[cur]);\n\t\tprev[cur]=i;\n\t}\n\tcout << sum+min_cost_flow(0,k-1,m-1,k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <iterator>\n\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int INF = 10000000;\n\ntypedef pair<int, int>P;\nstruct edge {int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()} );\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h+V, 0);\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (dist[v] < p.first) continue;\n      for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if (dist[t] == INF) {\n      return -1;\n    }\n    for (int v = 0; v < V; v++) h[v] += dist[v];\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nconst int MAX_N = 100000;\nint M, N, K;\nint w[MAX_N];\nvector<int> a[MAX_N];\n\nint main(){\n  int all_res = 0;\n  scanf(\"%d %d %d\", &M, &N, &K);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; i++) {\n    int j = 0;\n    scanf(\"%d\", &j);\n    a[j-1].push_back(i);\n    all_res += w[j-1];\n  }\n\n  int s = K, t = s + 1;\n  V = t + 1;\n  int res = 0;\n  add_edge(s, 0, M-1, 0);\n  add_edge(K - 1, t, M-1, 0);\n  for (int i =0; i + 1 < K; i++) {\n    add_edge(i, i + 1, INF, 0);\n  }\n  int NE = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < (int)a[i].size()-1; j++) {\n      if(a[i][j+1]- a[i][j]-1==0) {\n        res -= w[i];\n      } else {\n        add_edge(a[i][j+1], a[i][j]+1, 1, w[i]);\n        add_edge(s, a[i][j+1], 1, 0);\n        add_edge(a[i][j]+1, t, 1, 0);\n        res -= w[i];\n        NE++;\n      }\n    }\n  }\n\n  res += min_cost_flow(s, t, M+NE-1);\n  printf(\"%d\\n\", all_res+res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define maxn 30005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nint m,n,k,a[10005],w[10005],lst[10005];\nstruct edge{\n\tint to,cap,cst,rev;\n};\nvector <edge> adj[maxn];\nll dis[maxn],h[maxn];\nint V,prvv[maxn],prve[maxn];\nbool inque[maxn];\nvoid addedge(int u,int v,int c,int d){\n\tadj[u].push_back((edge){v,c,d,adj[v].size()});\n\tadj[v].push_back((edge){u,0,-d,adj[u].size()});\n}\nll min_cost_flow(int s,int t,int f){\n\tmemset(h,0,sizeof(h));\n\tll res = 0;\n\twhile(f > 0){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tmemset(inque,0,sizeof(inque));\n\t\tqueue <int> que;\n\t\tdis[s] = 0;\n\t\tinque[s] = true;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint u = que.front();que.pop();\n\t\t\tinque[u] = false;\n\t\t\tfor(int i=0;i<adj[u].size();i++){\n\t\t\t\tedge &e = adj[u][i];\n\t\t\t\tif(e.cap && dis[u] + h[u] + e.cst - h[e.to] < dis[e.to]){\n\t\t\t\t\tdis[e.to] = dis[u] + h[u] + e.cst - h[e.to];\n\t\t\t\t\tprvv[e.to] = u;\n\t\t\t\t\tprve[e.to] = i;\n\t\t\t\t\tif(!inque[e.to]){\n\t\t\t\t\t\tinque[e.to] = true;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=V;i++) h[i] += dis[i];\n\t\tint flow = f;\n\t\tfor(int i=t;i!=s;i=prvv[i]){\n\t\t\tflow = min(flow,adj[prvv[i]][prve[i]].cap);\n\t\t}\n\t\tf -= flow;\n\t\tres += flow * h[t];\n\t\tfor(int i=t;i!=s;i=prvv[i]){\n\t\t\tedge &e = adj[prvv[i]][prve[i]];\n\t\t\te.cap -= flow;\n\t\t\tadj[e.to][e.rev].cap += flow;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&m,&n,&k);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n\tfor(int i=1;i<=k;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\t//node 0: S.\n\t//node 1 ... k: 1' ... k'\n\t//node k+1 ... 2k: in-type for 1...k\n\t//node 2k+1 ... 3k: out-type for 1 ... k\n\t//node 3k+1: T.\n\tint S = 0,T = 3 * k + 1;\n\tV = T;\n\tll ans = 0,sum = 0;\n\taddedge(S,1,m,0);\n\taddedge(S,k+1,m,0);\n\taddedge(k,T,m,0);\n\taddedge(3 * k,T,m,0);\n\tfor(int i=1;i<k;i++){\n\t\taddedge(i,i+1,m,0);\n\t\taddedge(i,i+1+k,m,0);\n\t}\n\tfor(int i=2*k+1;i<3*k;i++){\n\t\taddedge(i,i+1-k,m,0);\n\t\taddedge(i,i+1-2*k,m,0);\n\t}\n\tfor(int i=k+1;i<=2*k;i++){\n\t\taddedge(i,i+k,1,-inf);\n\t\tans += inf;\n\t}\n\tfor(int i=1;i<=k;i++){\n\t\tsum += w[a[i]];\n\t\tif(lst[a[i]] != 0){\n\t\t\taddedge(lst[a[i]] + 2*k,i+k,1,-w[a[i]]);\n\t\t}\n\t\tlst[a[i]] = i;\n\t}\n\tans += min_cost_flow(S,T,m);\n\tprintf(\"%lld\\n\",sum + ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int MAX_N = 10000;\nconst int MAX_K = 10000;\nconst int MAX_V = MAX_K + 2;\nconst int INF = 1<<29;\n\nint M, N, K;\nint ws[MAX_N], as[MAX_K];\nvector<int> ts[MAX_N];\n\ntypedef pair<int, int> P;\nstruct edge{ int to, cap, cost, rev; };\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\tfill(h, h+V, 0);\n\twhile(f > 0){\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v] < p.first) continue;\n\t\t\tfor(int i=0; i<G[v].size(); i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v = 0; v<V; v++) h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor(int v=t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor(int v=t; v!=s; v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint solve(){\n\tint tot = 0, cnt = 0;\n\n\tfor(int i=0; i<K; i++){\n\t\tts[as[i]-1].push_back(i);\n\t}\n\n\tconst int source = K, sink = K + 1;\n\tV = sink + 1;\n\n\tadd_edge(source, 0, M-1, 0);\n\tadd_edge(K-1, sink, M-1, 0);\n\tfor(int i=0; i+1<K; i++){\n\t\tadd_edge(i, i+1, INF, 0);\n\t}\n\n\tfor(int i=0; i<N; i++)if(!ts[i].empty()){\n\t\tfor(int j=0; j+1 < (int)ts[i].size(); j++){\n\t\t\tadd_edge(ts[i][j+1], ts[i][j]+1, 1, ws[i]);\n\t\t\tadd_edge(source, ts[i][j+1], 1, 0);\n\t\t\tadd_edge(ts[i][j]+1, sink, 1, 0);\n\t\t\tcnt++;\n\t\t\ttot -= ws[i];\n\t\t}\n\t}\n\n\treturn min_cost_flow(source, sink, M-1 + cnt) - tot;\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tfor(int i=0; i<N; i++){\n\t\tscanf(\"%d\", ws+i);\n\t}\n\tfor(int i=0; i<K; i++){\n\t\tscanf(\"%d\", as+i);\n\t}\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* 首先，只要在下一个相同数字到来之前没放这个球，下个数字来的时候直接将这个球放进去，和直接放是等效的。\n* 为了简单，只在取出球的时候计算花费（取出最后该取出的球之后求和）、任意时刻箱子的状态转移是\n* (1) 在时刻t将球放入，将原来的球取出，转移到t+1\n* (2) 在时刻t不放入球，保持空的，转移到t+1\n* (3) 在时刻t将球放入，保持该球，到下次相同编号到来的t'转移\n* 这三种情况\n* 另外，对于所有时刻，至少有一个箱子是“放入”的状态。\n*\n* 这种状态转移可以自然地用图描述：\n* (1) v[t] -(1/w[v[t]])-> v[t+1]\n* (2) v[t] -(∞/0)-> v[t+1]\n* (3) v[t] -(1/0)-> v[t']\n* 这里，由于(1)和(3)是一个连贯的动作，所以将(3)变形为\n* (3') v[t] -(1/w[v[t]])-> v[t+1] -(1/-w[v[t]])-> v[t']\n* 这样就合并了(1)和(3')，然后让所有(1)类型的边上面传输1单位流量即可。\n*\n* 变形后，最极端情况花费设为∑w[v[t]]的话\n* (2) v[t] -(∞/0)-> v[t+1]\n* (3'') v[t+1] -(1/-w[v[t]])-> v[t']\n* 在上图跑F=M-1的最小费用流即可。`\n* 另外，当t+1 == t'的时候会产生负圈，此时得预先排除这样的顶点。\n*\n* 复杂度是O(K^2 + MNK)。\n*/\n#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#define all(x) (x).begin(),(x).end()\n#define size(x) ((int)(x).size()) \n#define FIRST first \n#define SECOND second\n#define FRONT front\n#define PUSH_BACK push_back\n#define MAKE_PAIR make_pair \n#define EMPTY empty\n#define PRIORITY_QUEUE priority_queue\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned int uii;\ntypedef pair<int,int> pii;\ntypedef unsigned long long uLL;  \n//head\n\nconst int inf = 1e8;\nconst int maxn = 2e4;\n\nstruct edge\n{\n\tint v, r, w, c;\n};\nstd::vector<edge> G[maxn];\nint h[maxn], dist[maxn];\nint pv[maxn], pe[maxn];\nint V;\nint w[maxn], num[maxn], vis[maxn];\nvoid init(){\n\tfor(int i = 0; i < V; i++){\n\t\tG[i].clear();\n\t}\n}\n\nvoid add(int u, int v, int w, int cost){\n\tG[u].push_back((edge){v, size(G[v]), w, cost});\n\tG[v].push_back((edge){u, size(G[u])-1, 0, -cost});\n} \n\n\nint min_cost_flow(int s, int t, int flow){\n\tint res = 0;\n\tfill(h, h+V, 0);\n\twhile(flow > 0){\n\t\tfill(dist, dist+V, inf);\n\t\tdist[s] = 0;\n\t\tpriority_queue<pii, std::vector<pii>, greater<pii> > q;\n\t\tq.push(pii(0, s));\n\t\twhile(!q.empty()){\n\t\t\tpii x = q.top(); q.pop();\n\t\t\tint u = x.second;\n\t\t\tif(dist[u] < x.first) continue;\n\t\t\tfor(int i = 0; i < size(G[u]); i++){\n\t\t\t\tedge &e = G[u][i];\n\t\t\t\tint k = h[u] + dist[u] + e.c - h[e.v];\n\t\t\t\tif(k < dist[e.v] && e.w > 0){\n\t\t\t\t\tdist[e.v] = k;\n\t\t\t\t\tq.push(pii(k, e.v));\n\t\t\t\t\tpv[e.v] = u;\n\t\t\t\t\tpe[e.v] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == inf) {\n\t\t\treturn -1;\t//不能再增广\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\th[i] += dist[i];\n\t\t}   \n\t\tint tf = flow;\n\t\tfor(int v = t; v != s; v = pv[v]){\n\t\t\ttf = min(tf, G[pv[v]][pe[v]].w);\n\t\t}\t\n\t\tif(tf){\n\t\t\tfor(int v = t; v != s; v = pv[v]){\n\t\t\t\tedge &e = G[pv[v]][pe[v]];\n\t\t\t\te.w -= tf;\n\t\t\t\tG[v][e.r].w += tf;\n\t\t\t}\n\t\t\tres += tf * h[t];\n\t\t\tflow -= tf;\n\t\t}\n\t}\n\treturn res;\t\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\t// freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint m, n, k;\n\tcin >> m >> n >> k;\n\tint res = 0, s = 0, t = k+1;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> w[i];\n\t}\n\tfor(int i = 1; i < k; i++){\n\t\tadd(i, i+1, inf, 0);\n\t}\n\tadd(s, 1, m-1, 0);\n\tadd(k, t, m-1, 0);\n\tint c = 0;\n\tV = k + 2;\n\tfor(int i = 1; i <= k; i++){\n\t\tcin >> num[i];\n\t\tres += w[num[i]];\n\t\tif(vis[num[i]]){\n\t\t\tint u = vis[num[i]]+1;\n\t\t\t// printf(\"%d\\n\", u);\n\t\t\tif(u < i){\n\t\t\t\tadd(i, u, 1, w[num[i]]);\n\t\t\t\t// printf(\"%d %d\\n\", i, u);\n\t\t\t\tadd(s, i, 1, 0);\n\t\t\t\tadd(u, t, 1, 0);\n\t\t\t\tc++;\n\t\t\t} \n\t\t\tres -= w[num[i]];\n\t\t}\n\t\tvis[num[i]] = i;\n\t}\n\t// printf(\"%d\\n\", res);\n\t// printf(\"%d\\n\", c);\n\tcout << res + min_cost_flow(s, t, m-1 + c) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\n#define all(x) (x).begin(),(x).end()\n#define size(x) ((int)(x).size()) \n#define FIRST first \n#define SECOND second\n#define FRONT front\n#define PUSH_BACK push_back\n#define MAKE_PAIR make_pair \n#define EMPTY empty\n#define PRIORITY_QUEUE priority_queue\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned int uii;\ntypedef pair<int,int> pii;\ntypedef unsigned long long uLL;  \n//head\n\nconst int inf = 1e8;\nconst int maxn = 2e4;\nstruct edge\n{\n\tint v, r, w, c;\n};\nstd::vector<edge> G[maxn];\nint h[maxn], dist[maxn];\nint pv[maxn], pe[maxn];\nint V;\nint n, m, k;\n\nvoid init(){\n\tfor(int i = 0; i < V; i++){\n\t\tG[i].clear();\n\t}\n}\n\nvoid add(int u, int v, int w, int cost){\n\tG[u].push_back((edge){v, size(G[v]), w, cost});\n\tG[v].push_back((edge){u, size(G[u])-1, 0, -cost});\n} \n\nvoid bellman(int s){\n\tint update = 1;\n\tfill(dist, dist+V, inf);\n\tdist[s] = 0;\n\twhile(update){\n\t\tupdate = 0;\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tfor(int j = 0; j < size(G[u]); j++){\n\t\t\t\tedge &e = G[u][j];\n\t\t\t\tif(e.w > 0 && dist[e.v] > dist[u] + e.c){\n\t\t\t\t\tdist[e.v] = dist[u] + e.c;\n\t\t\t\t\tupdate = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint min_cost_flow(int s, int t, int flow){\n\tint res = 0;\n\tfill(h, h+V, 0);\n\tbellman(s);\n\tfor(int i = 0; i < V; i++){\n\t\th[i] += dist[i];\n\t}\n\twhile(flow > 0){\n\t\tfill(dist, dist+V, inf);\n\t\tdist[s] = 0;\n\t\tpriority_queue<pii, std::vector<pii>, greater<pii> > q;\n\t\tq.push(pii(0, s));\n\t\twhile(!q.empty()){\n\t\t\tpii x = q.top(); q.pop();\n\t\t\tint u = x.second;\n\t\t\tif(dist[u] < x.first) continue;\n\t\t\tfor(int i = 0; i < size(G[u]); i++){\n\t\t\t\tedge &e = G[u][i];\n\t\t\t\tint k = h[u] + dist[u] + e.c - h[e.v];\n\t\t\t\tif(k < dist[e.v] && e.w > 0){\n\t\t\t\t\tdist[e.v] = k;\n\t\t\t\t\tq.push(pii(k, e.v));\n\t\t\t\t\tpv[e.v] = u;\n\t\t\t\t\tpe[e.v] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == inf) {\n\t\t\treturn -1;\t//不能再增广\n\t\t}\n\t\tfor(int i = 0; i < V; i++){\n\t\t\th[i] += dist[i];\n\t\t}   \n\t\tint tf = flow;\n\t\tfor(int v = t; v != s; v = pv[v]){\n\t\t\ttf = min(tf, G[pv[v]][pe[v]].w);\n\t\t}\t\n\t\tif(tf){\n\t\t\tfor(int v = t; v != s; v = pv[v]){\n\t\t\t\tedge &e = G[pv[v]][pe[v]];\n\t\t\t\te.w -= tf;\n\t\t\t\tG[v][e.r].w += tf;\n\t\t\t}\n\t\t\tres += tf * h[t];\n\t\t\tflow -= tf;\n\t\t}\n\t}\n\treturn res;\t\n}\n\nint a[maxn], w[maxn], vis[maxn];\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t// freopen(\"out.txt\", \"w\", stdout);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> m >> n >> k;\n\tint res = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> w[i];\n\t} \n\tfor(int i = 0; i < k; i++){\n\t\tcin >> a[i];\n\t}\n\tk = unique(a, a+k) - a;\n\tint s = 0, t = k - 1;\n\tfor(int i = 0; i < k-1; i++){\n\t\tadd(i, i+1, inf, 0);\n\t}\n\tV = k;\n\t// cout << k << endl;\n\tfor(int i = 0; i < k; i++){\n\t\tres += w[a[i]];\n\t\tif(vis[a[i]]){\n\t\t\tadd(vis[a[i]], i, 1, -w[a[i]]);\n\t\t\t// cout << vis[a[i]] << ' ' << -w[a[i]] << endl;\n\t\t}\n\t\tvis[a[i]] = i+1;\n\t}\n\tcout << res + min_cost_flow(s, t, m-1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 51000\n\t#define MAXM 1000000\n\t#define wint int\n\t#define cint long long \n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint p[11000];\nint q[11000];\nint last[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",q+i);\n\t\tq[i]--;\n\t}\n\tfor(int i=0;i<b;i++)last[i]=-1;\n\tMCF::init((c+1)*3+2);\n\tint s=(c+1)*3;\n\tint t=(c+1)*3+1;\n\tMCF::ae(s,0,10,0);\n\tMCF::ae(c,t,10,0);\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i,i+1,10,0);\n\t\tMCF::ae(i,c+1+i,1,p[q[i]]);\n\t\tMCF::ae(2*c+2+i,i+1,1,0);\n\t\tMCF::ae(c+1+i,2*c+2+i,1,-1000000000);\n\t\tif(~last[q[i]]){\n\t\t\tMCF::ae(2*c+2+last[q[i]],c+1+i,1,0);\n\t\t}\n\t\tlast[q[i]]=i;\n\t}\n\tMCF::solve(s,t,a);\n\tprintf(\"%lld\\n\",MCF::toc+1000000000LL*c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <iterator>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 10000000;\n\ntypedef pair<int, int>P;\nstruct edge {int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()} );\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h+V, 0);\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (dist[v] < p.first) continue;\n      for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if (dist[t] == INF) {\n      return -1;\n    }\n    for (int v = 0; v < V; v++) h[v] += dist[v];\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nconst int MAX_N = 10;\nint M, N, K;\nint w[MAX_N];\nvector<int> a[MAX_N];\n\nint main(){\n  int all_res = 0;\n  scanf(\"%d %d %d\", &M, &N, &K);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; i++) {\n    int j = 0;\n    scanf(\"%d\", &j);\n    a[j-1].push_back(i);\n    all_res += w[j-1];\n  }\n\n  int s = K, t = s + 1;\n  V = t + 1;\n  int res = 0;\n  add_edge(s, 0, M-1, 0);\n  add_edge(K - 1, t, M-1, 0);\n  for (int i =0; i + 1 < K; i++) {\n    add_edge(i, i + 1, INF, 0);\n  }\n  int NE = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < (int)a[i].size()-1; j++) {\n      if(a[i][j+1]- a[i][j]==0) {\n        res += w[i];\n      } else {\n        add_edge(a[i][j+1], a[i][j]+1, 1, w[i]);\n        add_edge(s, a[i][j+1], 1, 0);\n        add_edge(a[i][j]+1, t, 1, 0);\n        res -= w[i];\n        NE++;\n      }\n    }\n  }\n\n  res += min_cost_flow(s, t, M+NE-1);\n  printf(\"%d\\n\", all_res+res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\nstruct edge\n{\n    int from,to,c,cost;\n    edge(int _from,int _to,int _c,int _cost)\n    {\n        from=_from,to=_to,c=_c,cost=_cost;\n    }\n};\nvector<int> same[10005];\nvector<int> G[10005];\nvector<edge> p;\nint N,M,K,inf=1e9;\nint w[10005],a[10005];\nvoid input(int &sum)\n{\n    sum=0;\n    for(int i=0; i<M; i++) scanf(\"%d\",&w[i]);\n    int k=0,t;\n    for(int i=0; i<K; i++)\n    {\n        scanf(\"%d\",&t); t--;\n        if(k==0||t!=a[k-1])\n        {\n            same[t].push_back(k);\n            a[k]=t;\n            sum+=w[t];\n            k++;\n        }\n    }\n    K=k;\n}\nvoid add(int from,int to,int c,int cost)\n{\n    G[from].push_back(p.size());\n    p.push_back(edge(from,to,c,cost));\n    G[to].push_back(p.size());\n    p.push_back(edge(to,from,0,-cost));\n}\nvoid get_map(int s,int d)\n{\n    for(int i=0;i<K-1;i++) add(i,i + 1, M, 0);\n    for(int i=0;i<M;i++) for(int j=0;j<same[i].size()-1;j++) add(same[i][j]+1,same[i][j+1],1,-w[a[same[i][j]]]);\n    add(s,0,M,0);\n    add(K-1,d,M,0);\n}\nint pre[10005],dist[10005];\nbool vis[10005];\nbool spfa(int s,int d)\n{\n    int u,v;\n    queue<int> q;\n    for(int i=0;i<=d+2;i++){\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=inf;\n    }\n    vis[s]=1;\n    dist[s]=0;\n    q.push(s);\n    while(!q.empty()){\n        u=q.front();\n       /* cout<<u<<\":\"<<endl;\n        for(int i=0;i<=d;i++) printf(\"%4d\",p[pre[i]].from); cout<<endl;\n        for(int i=0;i<=d;i++) printf(\"%4d\",dist[i]); cout<<endl;*/\n        q.pop();\n        vis[u]=0;\n        for(int j=0;j<G[u].size();j++){\n            int i=G[u][j];\n            if(p[i].c>0){\n                v=p[i].to;\n                if(dist[v]>dist[u]+p[i].cost){\n                    dist[v]=dist[u]+p[i].cost;\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    return dist[d]!=inf;\n}\n\nint MCMF(int s,int d){\n    int ans=0,flow;\n    int flow_sum=0;\n    while(spfa(s,d)){\n        flow=inf;\n        for(int i=pre[d];i!=-1;i=pre[p[i].from])\n            if(p[i].c<flow)\n                flow=p[i].c;\n        for(int i=pre[d];i!=-1;i=pre[p[i].from]){\n            p[i].c-=flow;\n            p[i^1].c+=flow;\n        }\n        ans+=dist[d]*flow;\n        //cout<<dist[d]<<\"*\"<<flow<<endl;\n        flow_sum += flow;\n        if(flow_sum>=N-1) break;\n    }\n    //cout << flow_sum << endl;\n    //cout<<ans<<endl;\n    return ans;\n}\nvoid init()\n{\n    for(int i=0;i<10005;i++) G[i].clear(),same[i].clear();\n    p.clear();\n}\nint main()\n{\n    while(cin>>N>>M>>K)\n    {\n        init();\n        int sum;\n        input(sum);\n        int s=K,d=K+1;\n        get_map(s,d);\n        cout<<sum+MCMF(s,d)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ???M?????±????????????????£???????????????¨???????¬¬????????±??????\n * ???????????????????????????????????????????????????????¬¬????????±\n * ?????????????????????????????¶???????????±????????¶???????????????\n * ?????????????????°???????°±?????????????????????\n * ?°???????????????°???????????????(INF/0)????°???????????????????\n * ??????a???b?????¨a?????????????????????b?????????????¢????(w/1)\n * ???M-1????°??????¨??????\n */\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<utility>\n#include<cstring>\n#define INF 1000000000\n#define MAX_V 10000\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to, cap, cost, rev;\n};\nint N, M, K, V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to, cap, cost, G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\twhile(f > 0){\n\t\t//Bellman-Ford\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int v = 0; v < V; v++){\n\t\t\t\tif(dist[v] == INF) continue;\n\t\t\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += dist[t];\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint w[MAX_V], s[MAX_V], last[MAX_V];\nint main(){\n\tcin>>M>>N>>K;\n\tint sum = 0;\n\tfor(int i = 0; i < N; i++) scanf(\"%d\", &w[i]);\n\tint index = 0;\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d\", &s[index]);\n\t\tif(index == 0 || s[index] != s[index-1]){\n\t\t\tsum += w[s[index]-1];\n\t\t\tindex++;\n\t\t}\n\t}\n\tV = index;\n\tmemset(last, -1 ,sizeof(last));\n\tfor(int i = 0; i < V; i++){\n\t\tif(last[s[i]] >= 0) add_edge(last[s[i]] + 1, i, 1, -w[s[i]-1]);\n\t\tif(i < V-1) add_edge(i, i+1, INF, 0);\n\t\tlast[s[i]] = i;\n\t}\n\tprintf(\"%d\\n\",sum + min_cost_flow(0, V-1, M-1));\n\treturn 0;\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 51000\n\t#define MAXM 1000000\n\t#define wint int\n\t#define cint long long \n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t/*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint p[11000];\nint q[11000];\nint last[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",q+i);\n\t\tq[i]--;\n\t}\n\tfor(int i=0;i<b;i++)last[i]=-1;\n\tMCF::init((c+1)*3+2);\n\tint s=(c+1)*3;\n\tint t=(c+1)*3+1;\n\tMCF::ae(s,0,10,0);\n\tMCF::ae(c,t,10,0);\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i,i+1,10,0);\n\t\tMCF::ae(i,c+1+i,1,p[q[i]]);\n\t\tMCF::ae(2*c+2+i,i+1,1,0);\n\t\tMCF::ae(c+1+i,2*c+2+i,1,-1000000000);\n\t\tif(~last[q[i]]){\n\t\t\tMCF::ae(2*c+2+last[q[i]],c+1+i,1,0);\n\t\t}\n\t\tlast[q[i]]=i;\n\t}\n\tMCF::solve(s,t,a);\n\tprintf(\"%lld\\n\",MCF::toc+1000000000LL*c);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_M = 10;\nconst int MAX_N = 10000;\nconst int MAX_K = 10000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Edge {\n  int i, cap, cost;\n  Edge() {}\n  Edge(int _i, int _cap, int _cost): i(_i), cap(_cap), cost(_cost) {}\n};\n\ntypedef vector<Edge> ve;\n\n/* global variables */\n\nint wis[MAX_N], ajs[MAX_K], last[MAX_N];\nint dists[MAX_K], prvs[MAX_K];\nve nbrs[MAX_K];\nbool used[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int m, n, k;\n  cin >> m >> n >> k;\n\n  for (int i = 0; i < n; i++)\n    cin >> wis[i], last[i] = -1, used[i] = false;\n\n  int wsum = 0, nused = 0;\n  \n  for (int j = 0; j < k; j++) {\n    int aj;\n    cin >> aj;\n    aj--;\n    ajs[j] = aj;\n\n    if (j > 0)\n      nbrs[j - 1].push_back(Edge(j, m - 1, 0));\n    if (last[aj] >= 0)\n      nbrs[last[aj] + 1].push_back(Edge(j, 1, -wis[aj]));\n    last[aj] = j;\n\n    wsum += wis[aj];\n\n    if (! used[aj]) {\n      used[aj] = true;\n      nused++;\n    }\n  }\n\n  int csum = 0;\n\n  if (nused <= m) {\n    for (int i = 0; i < n; i++)\n      if (used[i]) csum += wis[i];\n    cout << csum << endl;\n    return 0;\n  }\n\n  for (;;) {\n    for (int i = 0; i < k; i++) dists[i] = INF;\n    dists[0] = 0;\n    prvs[0] = -1;\n\n    for (int ui = 0; ui < k; ui++) {\n      if (dists[ui] >= INF) continue;\n\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->cap > 0 && dists[vit->i] > dists[ui] + vit->cost) {\n\t  dists[vit->i] = dists[ui] + vit->cost;\n\t  prvs[vit->i] = ui;\n\t}\n    }\n\n    if (dists[k - 1] >= INF) break;\n    \n    for (int vi = k - 1; vi != 0;) {\n      int ui = prvs[vi];\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->i == vi) {\n\t  vit->cap--;\n\t  csum += vit->cost;\n\t  break;\n\t}\n      vi = ui;\n    }\n  }\n  \n  cout << (wsum + csum) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <iterator>\n\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int INF = 10000000;\n\ntypedef pair<int, int>P;\nstruct edge {int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()} );\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h+V, 0);\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (dist[v] < p.first) continue;\n      for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if (dist[t] == INF) {\n      return -1;\n    }\n    for (int v = 0; v < V; v++) h[v] += dist[v];\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nconst int MAX_N = 100000;\nint M, N, K;\nint w[MAX_N];\nvector<int> a[MAX_N];\n\nint main(){\n  int all_res = 0;\n  scanf(\"%d %d %d\", &M, &N, &K);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; i++) {\n    int j = 0;\n    scanf(\"%d\", &j);\n    a[j-1].push_back(i);\n    all_res += w[j-1];\n  }\n\n  int s = K, t = s + 1;\n  V = t + 1;\n  int res = 0;\n  add_edge(s, 0, M-1, 0);\n  add_edge(K - 1, t, M-1, 0);\n  for (int i =0; i + 1 < K; i++) {\n    add_edge(i, i + 1, INF, 0);\n  }\n  int NE = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < (int)a[i].size()-1; j++) {\n      if(a[i][j+1]- a[i][j]==0) {\n        res += w[i];\n      } else {\n        add_edge(a[i][j+1], a[i][j]+1, 1, w[i]);\n        add_edge(s, a[i][j+1], 1, 0);\n        add_edge(a[i][j]+1, t, 1, 0);\n        res -= w[i];\n        NE++;\n      }\n    }\n  }\n\n  res += min_cost_flow(s, t, M+NE-1);\n  printf(\"%d\\n\", all_res+res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tif (from < 0 || to < 0) return;\n\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\ntypedef pair<int, int> P;\n\nint dist[21000], h[21000] = {0}, prevV[21000], prevE[21000];\nint flow(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+21000, INF); dist[s] = 0;\n\t\twhile (1) {\n\t\t\tbool isUpdated = false;\n\t\t\tfor (int i = 0; i < G.size(); ++i) {\n\t\t\t\tif (dist[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\t\t\tEdge& e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && dist[i]+e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[i]+e.cost;\n\t\t\t\t\t\tprevV[e.to] = i;\n\t\t\t\t\t\tprevE[e.to] = j;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isUpdated) break;\n\t\t}\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\texit(1);\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n\n/*\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+21000, INF); dist[s] = 0;\n\t\tpriority_queue<P, vector<P>, greater<P> > Q; Q.push({0, s});\n\t\twhile ( !Q.empty() ) {\n\t\t\tP p = Q.top(); Q.pop();\n\t\t\tint v = p.second;\n\t\t\tif (p.first > dist[v]) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\t\tEdge& e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[v]+e.cost+h[v]-h[e.to] < dist[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevV[e.to] = v;\n\t\t\t\t\tprevE[e.to] = i;\n\t\t\t\t\tQ.push({dist[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < G.size(); ++i) h[i] += dist[i];\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\texit(1);\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n*/\n}\n\nint main() {\n\tint M, N, K; cin >> M >> N >> K;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> w[i];\n\t}\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; ++i) {\n\t\tcin >> a[i]; --a[i];\n\t}\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tK = a.size();\n\n\tint last = K;\n\tG.resize(2*K);\n\tvector<int> prev(N, -1);\n\tfor (int i = 0; i < K; ++i) {\n\t\taddEdge(i-1, i, INF, 0);\n\t\tif (prev[a[i]] > -1) {\n\t\t\taddEdge(prev[a[i]], last, 1, 0);\n\t\t\taddEdge(prev[a[i]]+1, last, 1, 0);\n\t\t\taddEdge(last, i, 1, -w[a[i]]);\n\t\t\t++last;\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\tG.resize(last);\n//\tfor (int i = 0; i < N; ++i) {\n//\t\taddEdge(prev[a[i]], t, 1, -w[a[i]]);\n//\t}\n//\taddEdge(K-1, t, INF, 0);\n\n\tint sum = 0;\n\tfor (int i = 0; i < K; ++i) {\n\t\tsum += w[a[i]];\n\t}\n\tcout << (sum + flow(0, K-1, M-1)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int INT_INF = 1 << 29;\nconst ll INF = 1LL<<55;\n\ntypedef pair<int, int> P;\nstruct edge {\n\tint to;\n\tint cap;\n\tll cost;\n\tint rev;\n};\n\nconst int MAX_V = 20010;\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, ll cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nll min_cost_flow(int s, int t, int f, bool bell = false) {\n\tll res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\tif (bell) {\n\t\t\tbell = false;\n\t\t\tbool update;\n\t\t\tdo {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 10010, MAX_K = 10010;\n\nint main(int argc, char *argv[]) {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tint w[MAX_N];\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tint a[MAX_K], r = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t\tr+= w[a[i]];\n\t}\n\tint b[MAX_N];\n\tfill_n(b, MAX_N, -1);\n\tfor (int i = 0; i < K; i++) {\n\t\tadd_edge(i, i+1, INT_INF, 0);\n\t\tint j = b[a[i]];\n\t\tif (j != -1) {\n\t\t\tif (j == i) {\n\t\t\t\tr -= w[a[i]];\n\t\t\t} else {\n\t\t\t\tadd_edge(b[a[i]], i, 1, -w[a[i]]);\n\t\t\t}\n\t\t}\n\t\tb[a[i]] = i+1;\n\t}\n\tV = K+1;\n\tprintf(\"%lld\\n\", r + min_cost_flow(0, K, M-1, true));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\ntypedef ll PD_Type;\nconst PD_Type PD_INF = 1 << 30;\n\nstruct Primal_Dual\n{\n    typedef pair< PD_Type, int > pii;\n    \n    struct edge\n    {\n        int to, rev;\n        PD_Type    cap, cost;\n        edge() {}\n        edge(int to, PD_Type cap, PD_Type cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n        \n    };\n    vector< vector< edge > > graph;\n    vector< int > prevv, preve;\n    vector< PD_Type > potential, min_cost;\n    Primal_Dual(int V) : graph(V) {}\n    \n    void add_edge(int from, int to, PD_Type cap, PD_Type cost)\n    {\n        graph[from].push_back(edge(to, cap, cost, (int)graph[to].size()));\n        graph[to].push_back(edge(from, 0, -cost, (int)graph[from].size() - 1));\n    }\n    \n    PD_Type min_cost_flow(int s, int t, int f)\n    {\n        int V = (int)graph.size();\n        PD_Type ret = 0;\n        priority_queue< pii, vector< pii >, greater< pii > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n        \n        //一回だけbellmanfordで最初のポテンシャルを求める\n        for(int k = 0; k < V; k++) {\n            for(int i = 0;i < V;i++) {\n                for(int j = 0; j < (int)graph[i].size(); j++) {\n                    edge &e = graph[i][j];\n                    if (e.cap == 0)continue; // 誤差注意\n                    potential[e.to] = min(potential[e.to], potential[i] + e.cost);\n                }\n            }\n        }\n        \n        while (f > 0) {\n            min_cost.assign(V, PD_INF);\n            que.push(pii(0, s));\n            min_cost[s] = 0;\n            \n            while (!que.empty()) {\n                pii p = que.top();\n                que.pop();\n                if (min_cost[p.second] < p.first) continue;\n                for (int i = 0; i < (int)graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    PD_Type nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if (e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second; preve[e.to] = i;\n                        que.push(pii(min_cost[e.to], e.to));\n                    }\n                }\n            }\n            if (min_cost[t] == PD_INF) return -1;\n            for (int v = 0; v < V; v++) potential[v] += min_cost[v];\n            PD_Type addflow = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n        }\n        return ret;\n    }\n};\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int M,N,K; cin >> M >> N >> K;\n    Primal_Dual F(K);\n    \n    int res = 0;\n    vector<int> A(N);\n    vector<vector<int> > B(N);\n    for(int i = 0; i < N;i++) cin >> A[i];\n    for(int i = 0; i < K;i++){\n        int a; cin >> a; a--;\n        B[a].push_back(i);\n        res += A[a];\n    }\n    \n    for(int i = 0; i < N;i++){\n        if((int)B[i].size() <= 1) continue;\n        for(int j = 0; j < (int)B[i].size()-1;j++){\n            int s = B[i][j], t = B[i][j+1];\n            if(s+1 != t){\n                F.add_edge(s+1, t, 1, -A[i]);\n            }else{\n                res -= A[i];\n            }\n        }\n    }\n    for(int i = 0; i < K-1;i++){\n        F.add_edge(i, i+1, M, 0);\n    }\n    cout << res + F.min_cost_flow(0, K-1, M-1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n#define MAX_V 1000\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init_edge(){\n    for(int i=0;i<V;i++)G[i].clear();\n}\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        priority_queue< pii, vector<pii>, greater<pii> >  que;\n        fill( dist, dist+V , INF );\n        dist[s]=0;\n        que.push(pii(0,s));\n        while(!que.empty()){\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v]<p.first)continue;\n            for(int i=0;i<(int)G[v].size();i++){\n                edge &e = G[v][i];\n                if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push(pii(dist[e.to],e.to));\n                }\n            }\n        }\n        if(dist[t]==INF){\n            return -1;\n        }\n        for(int v=0;v<V;v++)h[v]+=dist[v];\n        \n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int M,N,K; cin >> M >> N >> K;\n\n    V = K;\n    \n    int res = 0;\n    vector<int> A(N);\n    vector<vector<int> > B(N);\n    for(int i = 0; i < N;i++) cin >> A[i];\n    for(int i = 0; i < K;i++){\n        int a; cin >> a; a--;\n        B[a].push_back(i);\n        res += A[a];\n    }\n    \n    for(int i = 0; i < N;i++){\n        if((int)B[i].size() <= 1) continue;\n        for(int j = 0; j < (int)B[i].size()-1;j++){\n            int s = B[i][j], t = B[i][j+1];\n            if(s+1 != t){\n                add_edge(s+1, t, 1, -A[i]);\n            }else{\n                res -= A[i];\n            }\n        }\n    }\n    for(int i = 0; i < K-1;i++){\n        add_edge(i, i+1, M, 0);\n    }\n    cout << res + min_cost_flow(0, K-1, M-1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tvector<int> top;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfill(h, h + n, 0);\n\t\tassert(top.size() == n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint v = top[i];\n\t\t\tfor(Edge& e : g[v]) {\n\t\t\t\tif(e.cap == 0) continue;\n\t\t\t\tint u = e.dst;\n\t\t\t\th[u] = min(h[u], h[v] + e.cost);\n\t\t\t}\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tPrimalDual pd(K);\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 1000000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tpd.add_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\tfor(int i = 0; i < K; i++) {\n\t\tpd.top.push_back(i);\n\t}\n\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n#define MAX_V 10010\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update = true;\n        while(update){\n            update = false;\n            for(int v=0; v<V ;v++){\n                if(dist[v]==INF) continue;\n                for(int i=0; i<G[v].size(); i++){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF) return -1;\n        \n        int d = f;\n        for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*dist[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int M,N,K; cin >> M >> N >> K;\n    \n    V = K;\n    \n    int res = 0;\n    vector<int> A(N);\n    vector<vector<int> > B(N);\n    for(int i = 0; i < N;i++) cin >> A[i];\n    for(int i = 0; i < K;i++){\n        int a; cin >> a; a--;\n        B[a].push_back(i);\n        res += A[a];\n    }\n    \n    for(int i = 0; i < N;i++){\n        if((int)B[i].size() <= 1) continue;\n        for(int j = 0; j < (int)B[i].size()-1;j++){\n            int s = B[i][j], t = B[i][j+1];\n            if(s+1 != t){\n                add_edge(s+1, t, 1, -A[i]);\n            }else{\n                res -= A[i];\n            }\n        }\n    }\n    for(int i = 0; i < K-1;i++){\n        add_edge(i, i+1, M, 0);\n    }\n    cout << res + min_cost_flow(0, K-1, M-1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef complex<double> P;\n\nstruct edge { int to, cap, cost, rev;};\n\nconst int MAX_V = 1000000;\nconst int MAX_N = 1000000;\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].push_back((edge){to, cap, cost, G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h, h + V, 0);\n    while(f > 0){\n        priority_queue<pii, vector<pii>, greater<pii> > que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(pii(0, s));\n        while(!que.empty()){\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(int i = 0; i < G[v].size(); i++){\n                edge &e = G[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[t] == INF) return -1;\n        for(int v = 0; v < V; v++) h[v] += dist[v];\n        int d = f;\n        for(int v = t; v != s; v = prevv[v])\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d * h[t];\n        for(int v = t; v != s; v = prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint N, K;\nint a[MAX_N], b[MAX_N], w[MAX_N];\nvi wb, ab;\n\nvoid solve(){\n    vi x;\n    rep(i, N){\n\tx.pb(a[i]);\n\tx.pb(b[i]);\n    }\n    sort(all(x));\n    UNIQUE(x);\n    \n    int m = x.size();\n    int s = m, t = s + 1;\n    V = t + 1;\n    int res = 0;\n    add_edge(s, 0, K, 0);\n    add_edge(m - 1, t, K, 0);\n    for(int i = 0; i + 1 < m; i++){\n\tadd_edge(i, i + 1, INF, 0);\n    }\n    rep(i,N){\n\tint u = find(all(x), a[i]) - x.begin();\n\tint v = find(all(x), b[i]) - x.begin();\n\tadd_edge(v, u, 1, w[i]);\n\tadd_edge(s, v, 1, 0);\n\tadd_edge(u, t, 1, 0);\n\tres -= w[i];\n    }\n\n    res += min_cost_flow(s, t, K + N);\n    rep(i,ab.size()) res += wb[ab[i]];\n    cout << res << endl;\n}\n\nvoid input(){\n    int m, n, k;\n    cin >> m >> n >> k;\n    rep(i,n){\n\tint t;\n\tcin >> t;\n\twb.pb(t);\n    }\n    rep(i,k){\n\tint t;\n\tcin >> t;\n\tt--;\n\tab.pb(t);\n    }\n    UNIQUE(ab);\n    int tmp[MAX_N];\n    memset(tmp, -1, sizeof(tmp));\n    int cnt = 0;\n    rep(i,k){\n\tif(tmp[ab[i]] != -1){\n\t    a[cnt] = tmp[ab[i]] + 1;\n\t    b[cnt] = i;\n\t    w[cnt] = wb[ab[i]];\n\t    cnt++;\n\t}\n\ttmp[ab[i]] = i;\n    }\n    N = cnt;\n    K = m - 1;\n/*\n    rep(i,cnt){\n\tcout << a[i] << ' ' << b[i] << ' ' << w[i] << endl;\n    }\n*/\n}\n\nint main() {\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL BASE = 10000LL * 10000LL * 100;\nconst LL INF = 1LL << 60;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow cap, flow;\n    Cost cost;\n    Edge *back;\n\n    Edge(int from, int to, Flow cap, Cost cost, Edge *back) : from(from), to(to), cap(cap), cost(cost), back(back) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    Edge<Flow,Cost> *ea = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    Edge<Flow,Cost> *eb = new Edge<Flow,Cost>(dst, src, 0, -d, ea);\n    ea->back = eb;\n    g[src].push_back(ea);\n    g[dst].push_back(eb);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow,Cost>\nprimal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, int max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> dist(N);\n    vector<Edge<Flow,Cost>*> prev(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        fill(prev.begin(), prev.end(), nullptr);\n        dist[src] = 0;\n\n        for(int turn = 0; turn < N; ++turn) {\n            bool updated = false;\n            for(int i = 0; i < N; ++i) {\n                for(auto *e : g[i]) {\n                    if(e->cap - e->flow > 0) {\n                        Cost nc = dist[e->from] + e->cost;\n                        if(nc < dist[e->to]) {\n                            dist[e->to] = nc;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(!updated) break;\n        }\n        if(prev[sink] == nullptr) break;\n\n        Flow aug = f;\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            aug = min(aug, e->cap - e->flow);\n        }\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            res.second += aug * e->cost;\n            e->flow += aug;\n            e->back->flow -= aug;\n        }\n        f -= aug;\n        res.first += aug;\n    }\n\n    return res;\n}\n\nbool solve() {\n    int M, N, K;\n    if(!(cin >> M >> N >> K)) return false;\n\n    vector<LL> ws(N);\n    vector<int> as(K);\n    vector<vector<Edge<int,LL>*>> graph(K*2+2);\n    const int SRC = K*2;\n    const int SINK = K*2+1;\n    for(int i = 0; i < N; ++i) {\n        cin >> ws[i];\n    }\n    for(int i = 0; i < K; ++i) {\n        cin >> as[i];\n        --as[i];\n    }\n    for(int i = 0; i < K; ++i) {\n        add_edge(graph, 2*i, 2*i+1, 1, -BASE);\n        // Edge to neighbor\n        if(i+1 < K) {\n            add_edge(graph, 2*i, 2*(i+1), M, 0LL);\n            add_edge(graph, 2*i+1, 2*(i+1), 1, ws[as[i]]);\n        }\n        // Edge to next same number\n        auto it = find(as.begin()+i+1, as.end(), as[i]);\n        if(it != as.end()) {\n            add_edge(graph, 2*i+1, 2*(it-as.begin()), 1, 0LL);\n        }\n        // Edge to sink\n        add_edge(graph, 2*i+1, SINK, 1, ws[as[i]]);\n        // Edge from source\n        add_edge(graph, SRC, 2*i, 1, 0LL);\n    }\n    auto res = primal_dual(graph, SRC, SINK, M);\n    cout << res.second + BASE * K << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 31000\n\t#define MAXM 120000\n\t#define wint int\n\t#define cint long long \n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i]) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint p[11000];\nint q[11000];\nint last[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",q+i);\n\t\tq[i]--;\n\t}\n\tfor(int i=0;i<b;i++)last[i]=-1;\n\tMCF::init((c+1)*3+2);\n\tint s=(c+1)*3;\n\tint t=(c+1)*3+1;\n\tMCF::ae(s,0,a,0);\n\tMCF::ae(c,t,a,0);\n\tint ret=0;\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i,i+1,a,0);\n\t\tif(~last[q[i]]){\n\t\t\tif(last[q[i]]+1==i)ret-=p[q[i]];\n\t\t\telse MCF::ae(last[q[i]],i-1,1,-p[q[i]]);\n\t\t}\n\t\tlast[q[i]]=i;\n\t}\n\tMCF::solve(s,t,a-1);\n\tfor(int i=0;i<c;i++)ret+=p[q[i]];\n\tprintf(\"%lld\\n\",MCF::toc+ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntypedef int weight;\ntypedef pair<weight, int> P;\nconstexpr weight INF = (1 << 29);\n\nstruct edge {\n\tint to;\n\tint cap;\n\tweight cost;\n\tint rev;\n\tedge(int to_, int cap_, weight cost_, int rev_):to(to_), cap(cap_), cost(cost_), rev(rev_){};\n};\n\nvector<vector<edge>> G;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n}\n\nvoid add_edge(int from, int to, int cap, weight cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\n\nweight min_cost_flow(int s, int t, weight f) {\n\tconst int n = G.size();\n\tweight res = 0;\n\tvector<int> prevv(n), preve(n);\n\twhile(f > 0) {\n\t\tvector<weight> dist(n, INF);\n\t\tvector<bool> in_queue(n, false);\n\n\t\tqueue<int> que;\n\t\tque.push(s);\n\t\tdist[s] = 0;\n\t\tin_queue[s] = true;\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int v = que.front();\n\t\t\tque.pop();\n\t\t\tin_queue[v] = false;\n\n\t\t\tfor(unsigned i = 0; i < G[v].size(); ++i) {\n\t\t\t\tconst auto &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\n\t\t\t\t\tif(!in_queue[e.to]) {\n\t\t\t\t\t\tin_queue[e.to] = true;\n\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t] == INF) return -1;\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint m, n, k;\n\tcin >> m >> n >> k;\n\n\tvector<int> w(n);\n\tfor(auto &e : w) cin >> e;\n\n\tinit(k + 1);\n\n\tvector<int> prev(n, -1);\n\tint ans = 0;\n\n\trep(i, k) {\n\t\tint a;\n\t\tcin >> a;\n\t\t--a;\n\n\t\tans += w[a];\n\n\t\tadd_edge(i, i + 1, INF, 0);\n\t\tif(prev[a] != -1) {\n\t\t\tif(prev[a] + 1 == i) {\n\t\t\t\tans -= w[a];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(prev[a] + 1, i, 1, -w[a]);\n\t\t\t}\n\t\t}\n\t\tprev[a] = i;\n\t}\n\n\tcout << ans + min_cost_flow(0, k, m - 1) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int INT_INF = 1 << 29;\nconst ll INF = 1LL<<55;\n\ntypedef pair<int, int> P;\nstruct edge {\n\tint to;\n\tint cap;\n\tll cost;\n\tint rev;\n};\n\nconst int MAX_V = 20010;\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, ll cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nll min_cost_flow(int s, int t, int f, bool bell = false) {\n\tll res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\tif (bell) {\n\t\t\tbell = false;\n\t\t\tbool update;\n\t\t\tdo {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\t\tfor (int j = 0; j < G[i].size(); j++) {\n\t\t\t\t\t\tedge e = G[i][j];\n\t\t\t\t\t\tif (e.cap > 0 && dist[i] != INF && dist[e.to] > dist[i] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[i] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = i;\n\t\t\t\t\t\t\tpreve[e.to] = j;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t} else {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 10010, MAX_K = 10010;\nconst ll OFFSET = 1LL<<30;\nint main(int argc, char *argv[]) {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tint w[MAX_N];\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tint a[MAX_K], r = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t\tr+= w[a[i]];\n\t}\n\tint b[MAX_N];\n\tfill_n(b, MAX_N, -1);\n\tfor (int i = 0; i < K; i++) {\n\t\tadd_edge(i, i+1, M, 0);\n\t\tif (b[a[i]] != -1) {\n\t\t\tadd_edge(b[a[i]], i, 1, -w[a[i]]);\n\t\t}\n\t\tb[a[i]] = i+1;\n\t}\n\tV = K+1;\n\tprintf(\"%lld\\n\", r + min_cost_flow(0, K, M-1, true));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tif (from < 0 || to < 0) return;\n\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\ntypedef pair<int, int> P;\n\nint dist[21000], h[21000] = {0}, prevV[21000], prevE[21000];\nint flow(int s, int t, int f) {\n/*\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+21000, INF); dist[s] = 0;\n\t\twhile (1) {\n\t\t\tbool isUpdated = false;\n\t\t\tfor (int i = 0; i < G.size(); ++i) {\n\t\t\t\tif (dist[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\t\t\tEdge& e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && dist[i]+e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[i]+e.cost;\n\t\t\t\t\t\tprevV[e.to] = i;\n\t\t\t\t\t\tprevE[e.to] = j;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isUpdated) break;\n\t\t}\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\texit(1);\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n*/\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+21000, INF); dist[s] = 0;\n\t\tpriority_queue<P, vector<P>, greater<P> > Q; Q.push({0, s});\n\t\twhile ( !Q.empty() ) {\n\t\t\tP p = Q.top(); Q.pop();\n\t\t\tint v = p.second;\n\t\t\tif (p.first > dist[v]) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\t\tEdge& e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[v]+e.cost+h[v]-h[e.to] < dist[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevV[e.to] = v;\n\t\t\t\t\tprevE[e.to] = i;\n\t\t\t\t\tQ.push({dist[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < G.size(); ++i) h[i] += dist[i];\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\texit(1);\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\n#define MAX_W 10000\n\nint main() {\n\tint M, N, K; cin >> M >> N >> K;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> w[i];\n\t}\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; ++i) {\n\t\tcin >> a[i]; --a[i];\n\t}\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tK = a.size();\n\n\tint last = K;\n\tG.resize(2*K);\n\tvector<int> prev(N, -1);\n\tfor (int i = 0; i < K; ++i) {\n\t\taddEdge(i-1, i, INF, MAX_W);\n\t\tif (prev[a[i]] > -1) {\n\t\t\taddEdge(prev[a[i]], last, 1, MAX_W*(i-prev[a[i]])-w[a[i]]);\n\t\t\taddEdge(prev[a[i]]+1, last, 1, MAX_W*(i-prev[a[i]]-1)-w[a[i]]);\n\t\t\taddEdge(last, i, 1, 0);\n\t\t\t++last;\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\tG.resize(last);\n//\tfor (int i = 0; i < N; ++i) {\n//\t\taddEdge(prev[a[i]], t, 1, -w[a[i]]);\n//\t}\n//\taddEdge(K-1, t, INF, 0);\n\n\tint sum = 0;\n\tfor (int i = 0; i < K; ++i) {\n\t\tsum += w[a[i]];\n\t}\n\tcout << (sum - (MAX_W * (K-1) * (M-1) - flow(0, K-1, M-1))) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <vector>\n#include <queue>\n#include <array>\n#include <stdio.h>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 10000000;\nconst int Big_M = 100000;\n\ntypedef pair<int, int>P;\nstruct edge {int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()} );\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h+V, 0);\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (dist[v] < p.first) continue;\n      for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if (dist[t] == INF) {\n      return -1;\n    }\n    for (int v = 0; v < V; v++) h[v] += dist[v];\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nconst int MAX_N = 10;\nint M, N, K;\nint w[MAX_N];\nvector<int> a[MAX_N];\n\nint main(){\n  int all_res = 0;\n  scanf(\"%d %d %d\", &M, &N, &K);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; i++) {\n    int j = 0;\n    scanf(\"%d\", &j);\n    a[j-1].push_back(i);\n    all_res += w[j-1];\n  }\n\n  int s = 2*K, t = s + 1;\n  V = t + 1;\n  int res = 0;\n  add_edge(s, 0, M, 0);\n  add_edge(2*K - 1, t, M, 0);\n  for (int i =0; i + 1 < K; i++) {\n    add_edge(i+K, i + 1, INF, 0);\n  }\n  int NE = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < (int)a[i].size()-1; j++) {\n      add_edge(a[i][j+1], a[i][j]+K, 1, w[i]);\n      add_edge(s, a[i][j+1], 1, 0);\n      add_edge(a[i][j]+K, t, 1, 0);\n      res -= w[i];\n      NE++;\n    }\n  }\n\n  for (int i =0; i < K; i++) {\n    add_edge(i, i+K, INF, 0);\n    add_edge(i+K, i, 1, Big_M);\n    add_edge(s, i+K, 1, 0);\n    add_edge(i, t, 1, 0);\n  }\n\n  res += min_cost_flow(s, t, M+NE+K);\n  printf(\"%d\\n\", all_res+res);\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1<<29;\nstruct edge{int to,cap,cost,rev;};\nvector<edge> graph[vmax];\n\nint h[vmax],dist[vmax];\nint pv[vmax],pe[vmax];\ntypedef tuple<int,int> state;\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tgraph[from].push_back({to,cap,cost,(int)graph[to].size()});\n\tgraph[to].push_back({from,0,-cost,(int)graph[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f,int n){\n\tint res=0;\n\tfill(h,h+n,0);\n\twhile(f>0){\n\t\tpriority_queue <state,vector<state>,greater<state> > q;\n\t\tfill(dist,dist+n,inf);\n\t\tdist[s]=0;\n\t\tq.push(state(0,s));\n\t\twhile(!q.empty()){\n\t\t\tint cost,v;\n\t\t\ttie(cost,v)=q.top();q.pop();\n\t\t\tif(dist[v] < cost) continue;\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tedge &e=graph[v][i];\n\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tpv[e.to]=v,pe[e.to]=i;\n\t\t\t\t\tq.push(state(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==inf) return -1;\n\t\trep(v,n) h[v]+=dist[v];\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=pv[v]) d=min(d,graph[pv[v]][pe[v]].cap);\n\t\tf-=d;res+=d*h[t];\n\t\tfor(int v=t;v!=s;v=pv[v]){\n\t\t\tedge &e=graph[pv[v]][pe[v]];\n\t\t\te.cap-=d;\n\t\t\tgraph[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint w[10010];\nint a[10010];\n\nint main(void){\n\tint m,n,k;\n\tcin >> m >> n >> k;\n\trep(i,n) cin >> w[i];\n\trep(i,k) cin >> a[i],a[i]--;\n\n\tint sum=0;\n\trep(i,k){\n\t\tif(i-1>=0&&a[i]==a[i-1]) continue;\n\t\tsum+=w[a[i]];\n\t}\n\n\trep(i,k-1) add_edge(i,i+1,inf,0);\n\n\tint prev[10010];\n\trep(i,n) prev[i]=-1;\n\n\trep(i,k){\n\t\tint cur=a[i];\n\t\tif(prev[cur]!=-1) add_edge(prev[cur]+1,i,1,-w[cur]);\n\t\tprev[cur]=i;\n\t}\n\tcout << sum+min_cost_flow(0,k-1,m-1,k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = long long;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\ntypedef long long ll;\nll w[10000];\nvector<ll> id[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tif(id[a].size() == 0 || id[a].back() != i - 1) {\n\t\t\tid[a].push_back(i);\n\t\t\tsum += w[a];\n\t\t}\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 100000, 0);\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < (int)id[i].size() - 1; j++) {\n\t\t\t//cout << id[i][j] + 1 + 1 << \" \" << id[i][j + 1] + 1 << \" \" << -w[i] << endl;\n\t\t\tif(id[i][j] + 1 != id[i][j + 1]) {\n\t\t\t\tpd.add_edge(id[i][j] + 1, id[i][j + 1], 1, -w[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntypedef int weight;\ntypedef pair<weight, int> P;\nconstexpr weight INF = (1 << 29);\n\nstruct edge {\n\tint to;\n\tint cap;\n\tweight cost;\n\tint rev;\n\tedge(int to_, int cap_, weight cost_, int rev_):to(to_), cap(cap_), cost(cost_), rev(rev_){};\n};\n\nvector<vector<edge>> G;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n}\n\nvoid add_edge(int from, int to, int cap, weight cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\n\nweight min_cost_flow(int s, int t, weight f) {\n\tconst int n = G.size();\n\tweight res = 0;\n\tvector<int> prevv(n), preve(n);\n\twhile(f > 0) {\n\t\tvector<weight> dist(n, INF);\n\t\tdist[s] = 0;\n\n\t\twhile(true) {\n\t\t\tbool update = false;\n\t\t\tfor(int v = 0; v < n; ++v) {\n\t\t\t\tfor(unsigned i = 0; i < G[v].size(); ++i) {\n\t\t\t\t\tconst auto &e = G[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!update) break;\n\t\t}\n\n\t\tif(dist[t] == INF) return -1;\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint m, n, k;\n\tcin >> m >> n >> k;\n\n\tvector<int> w(n);\n\tfor(auto &e : w) cin >> e;\n\n\tinit(k + 1);\n\n\tvector<int> prev(n, -1);\n\tint ans = 0;\n\n\trep(i, k) {\n\t\tint a;\n\t\tcin >> a;\n\t\t--a;\n\n\t\tans += w[a];\n\n\t\tadd_edge(i, i + 1, INF, 0);\n\t\tif(prev[a] != -1) {\n\t\t\tif(prev[a] + 1 == i) {\n\t\t\t\tans -= w[a];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(prev[a] + 1, i, 1, -w[a]);\n\t\t\t}\n\t\t}\n\t\tprev[a] = i;\n\t}\n\n\tcout << ans + min_cost_flow(0, k, m - 1) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n \nusing namespace std;\ntypedef pair<int,int> P;\n \nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n \nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n \nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n \n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n \n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n \n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      if(M!=1){\n        for(j=MAX(i+1,initial);j<nxt;j++){        \n          nbr[i].push_back(j);\n          cost[i].push_back(w[a[i]]);\n          num_nbr[i]++;\n          //        if(j > MAX(i+1,initial) + 10) break;\n        }\n        nbr[i].push_back(nxt);\n        num_nbr[i]++;\n        cost[i].push_back(0);\n      }\n      else{\n        nbr[i].push_back(i+1);\n        cost[i].push_back((nxt == i+1)? 0:w[a[i]]);\n        num_nbr[i]++;\n      }\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n}\n \nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n   \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n   \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n \n  int cnt = 0;\n  for(int s=0;s<K-M;s++){\n    fill(dist,dist+K+1,INT_MAX);\n      dist[s] = 0;\n      que.push(P(0,s));\n//    printf(\"\\n%d-th loop\",++cnt);\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n//      printf(\"node %d established.\\n\",u);\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    for(i = 0;i < K-M;i++) h[i] += (dist[i] == INT_MAX)? 0:dist[i];\n    h[t] += (dist[t] == INT_MAX)? 0:dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n  return res;\n}\n \nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n \nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\n\t\twhile(f > 0) {\n\t\t\tfill(dist, dist + n, inf);\n\t\t\tdist[s] = 0;\n\n\t\t\twhile(true) {\n\t\t\t\tbool update = false;\n\t\t\t\tfor(int v = 0; v < n; ++v) {\n\t\t\t\t\tfor(unsigned i = 0; i < g[v].size(); ++i) {\n\t\t\t\t\t\tconst auto &e = g[v][i];\n\t\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!update) break;\n\t\t\t}\n\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tPrimalDual pd(K);\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 1000000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tpd.add_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n#define MAX_V 10000\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init_edge(){\n    for(int i=0;i<V;i++)G[i].clear();\n}\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res = 0;\n    fill(h,h+V,0);\n    \n    //一回だけbellmanfordで最初のポテンシャルを求める\n    for(int k = 0; k < V; k++) {\n        for(int i = 0;i < V;i++) {\n            for(int j = 0; j < (int)G[i].size(); j++) {\n                edge &e = G[i][j];\n                if (e.cap == 0)continue; // 誤差注意\n                h[e.to] = min(h[e.to], h[i] + e.cost);\n            }\n        }\n    }\n    \n    while(f>0){\n        priority_queue< pii, vector<pii>, greater<pii> >  que;\n        fill( dist, dist+V , INF );\n        dist[s]=0;\n        que.push(pii(0,s));\n        while(!que.empty()){\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v]<p.first)continue;\n            for(int i=0;i<(int)G[v].size();i++){\n                edge &e = G[v][i];\n                if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push(pii(dist[e.to],e.to));\n                }\n            }\n        }\n        \n        if(dist[t]==INF){\n            return -1;\n        }\n        for(int v=0;v<V;v++)h[v]+=dist[v];\n        \n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int M,N,K; cin >> M >> N >> K;\n    \n    V = K;\n    \n    int res = 0;\n    vector<int> A(N);\n    vector<vector<int>> B(N);\n    for(int i = 0; i < N;i++) cin >> A[i];\n    for(int i = 0; i < K;i++){\n        int a; cin >> a; a--;\n        B[a].push_back(i);\n        res += A[a];\n    }\n    \n    for(int i = 0; i < N;i++){\n        if((int)B[i].size() <= 1) continue;\n        for(int j = 0; j < (int)B[i].size()-1;j++){\n            int s = B[i][j], t = B[i][j+1];\n            if(s+1 != t){\n                add_edge(s+1, t, 1, -A[i]);\n            }else{\n                res -= A[i];\n            }\n        }\n    }\n    for(int i = 0; i < K-1;i++){\n        add_edge(i, i+1, M, 0);\n    }\n    cout << res + min_cost_flow(0, K-1, M-1) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <utility>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef long long LL;\nstruct edge{\n    int to,cap,cost,rev;\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=10010;\nint V,dist[MAX_V],prevv[MAX_V],preve[MAX_V];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update=1;\n        while(update){\n            update=0;\n            for(int v=0;v<V;v++){\n                if(dist[v]==INF)continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e=G[v][i];\n                    if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n                        dist[e.to]=dist[v]+e.cost;\n                        prevv[e.to]=v;\n                        preve[e.to]=i;\n                        update=1;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF)return -1;\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }f-=d;\n        res+=d*dist[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e=G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }return res;\n}\nvoid clear(){for(int i=0;i<=V;i++)G[i].clear();}\nconst int MAX_N=10010;\nint M,N,K,w[MAX_N],lst[MAX_N],a[MAX_N];\nint solve(){\n    for(int i=1;i<=N;i++)scanf(\"%d\",&w[i]);\n    for(int i=1;i<=K;i++)scanf(\"%d\",&a[i]);\nif(M == 1) {\n    int cnt=unique(a+1,a+K+1)-(a+1);\n    int res=0;\n    for(int i=1;i<=cnt;i++){\n        res+=w[a[i]];}\nprintf(\"%d\\n\", res);\n return 0;}\n   int cnt = K;\n    int res=0;\n    memset(lst,0,sizeof(lst));\n    V=cnt+1; clear();\n    for(int i=1;i<=cnt;i++){\n        res+=w[a[i]];\n        if(lst[a[i]])add_edge(lst[a[i]],i-1,1,-w[a[i]]);\n        lst[a[i]]=i;\n    }for(int i=1;i<cnt;i++)add_edge(i,i+1,INF,0);\n    printf(\"%d\\n\",res+min_cost_flow(1,cnt,M-1));\n}\nint main(){\n    while(~scanf(\"%d%d%d\",&M,&N,&K))solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int INT_INF = 1 << 29;\nconst ll INF = 1LL<<55;\n\ntypedef pair<int, int> P;\nstruct edge {\n\tint to;\n\tint cap;\n\tll cost;\n\tint rev;\n};\n\nconst int MAX_V = 20010;\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, ll cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nll min_cost_flow(int s, int t, int f, bool bell = false) {\n\tll res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\tif (bell) {\n\t\t\tbell = false;\n\t\t\tbool update;\n\t\t\tdo {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t} else {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 10010, MAX_K = 10010;\n\nint main(int argc, char *argv[]) {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tint w[MAX_N];\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tint a[MAX_K], r = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t\tr+= w[a[i]];\n\t}\n\tint b[MAX_N];\n\tfill_n(b, MAX_N, -1);\n\tfor (int i = 0; i < K; i++) {\n\t\tadd_edge(i, i+1, INT_INF, 0);\n\t\tint j = b[a[i]];\n\t\tif (j != -1) {\n\t\t\tif (j == i) {\n\t\t\t\tr -= w[a[i]];\n\t\t\t} else {\n\t\t\t\tadd_edge(b[a[i]], i, 1, -w[a[i]]);\n\t\t\t}\n\t\t}\n\t\tb[a[i]] = i+1;\n\t}\n\tV = K+1;\n\tprintf(\"%lld\\n\", r + min_cost_flow(0, K, M-1, true));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n  \ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, to, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, to, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f){\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 200000000;\n  \n  while(f > 0){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    \n    bool update = true;\n    \n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n\tif(dist[v] == inf) continue;\n\tfor(int i = 0; i < (int)g[v].size(); i++){\n\t  E &e = g[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t    dist[e.to]  = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update      = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t] == inf){\n      return -1;\n    }\n    \n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n    \n    f   -= d;\n    res += d * dist[t];\n    \n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap           -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m = getInt();\n  int n = getInt();\n  int k = getInt();\n\n  vector<int> w(n);\n  vector<int> a(k);\n\n  Graph<CostEdge> g(k);\n\n  REP(i,n) w[i] = getInt();\n  REP(i,k) a[i] = getInt() - 1;\n\n  int ans = 0;\n  REP(i,k) ans += w[a[i]];\n  // printf(\"%d\\n\", ans);\n\n  vector<int> prevs(n, -1);\n\n  REP(i,k){\n    if(i != k - 1) g.addEdge(i, i + 1, 10000, 0);\n    int aa = a[i];\n    if(prevs[aa] != -1){\n      int j = prevs[aa];\n      if(j + 1 == i){\n\tans -= w[a[i]];\n      }else{\n\tg.addEdge(j + 1, i, 1, - w[a[i]]);\n\t// printf(\"%d => %d : %d\\n\", j + 2, i + 1, - w[aa]);\n      }\n    }\n    prevs[aa] = i;\n  }\n\n  ans += minCostFlow(g, 0, k - 1, m - 1);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL BASE = 10000LL * 10000LL * 100;\nconst LL INF = 1LL << 59;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow cap, flow;\n    Cost cost;\n    Edge *back;\n\n    Edge(int from, int to, Flow cap, Cost cost, Edge *back) : from(from), to(to), cap(cap), cost(cost), back(back) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    Edge<Flow,Cost> *ea = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    Edge<Flow,Cost> *eb = new Edge<Flow,Cost>(dst, src, 0, -d, ea);\n    ea->back = eb;\n    g[src].push_back(ea);\n    g[dst].push_back(eb);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow,Cost>\nprimal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, Flow max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> dist(N);\n    vector<Edge<Flow,Cost>*> prev(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        fill(prev.begin(), prev.end(), nullptr);\n        dist[src] = 0;\n\n        while(true) {\n            bool updated = false;\n            for(int i = 0; i < N; ++i) {\n                for(auto *e : g[i]) {\n                    if(e->cap - e->flow > 0) {\n                        Cost nc = dist[e->from] + e->cost;\n                        if(nc < dist[e->to]) {\n                            dist[e->to] = nc;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(!updated) break;\n        }\n        if(prev[sink] == nullptr) break;\n\n        Flow aug = f;\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            aug = min(aug, e->cap - e->flow);\n        }\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            res.second += aug * e->cost;\n            e->flow += aug;\n            e->back->flow -= aug;\n        }\n        f -= aug;\n        res.first += aug;\n    }\n\n    return res;\n}\n\nbool solve() {\n    int M, N, K;\n    if(!(cin >> M >> N >> K)) return false;\n\n    vector<LL> ws(N);\n    vector<int> as(K);\n    vector<vector<Edge<int,LL>*>> graph(K+2);\n    const int SRC = K;\n    const int SINK = K+1;\n    for(int i = 0; i < N; ++i) {\n        cin >> ws[i];\n    }\n    LL sum = 0;\n    for(int i = 0; i < K; ++i) {\n        cin >> as[i];\n        --as[i];\n        sum += ws[as[i]];\n    }\n    for(int i = 0; i < K; ++i) {\n        // Edge to neighbor\n        if(i+1 < K) {\n            add_edge(graph, i, i+1, M, 0LL);\n        }\n        // Edge to next same number\n        auto it = find(as.begin()+i+1, as.end(), as[i]);\n        if(it != as.end()) {\n            add_edge(graph, i+1, it-as.begin(), 1, -ws[as[i]]);\n        }\n    }\n    add_edge(graph, SRC, 0, M, 0LL);\n    add_edge(graph, K-1, SINK, M, 0LL);\n    auto res = primal_dual(graph, SRC, SINK, M-1);\n    cout << sum + res.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <sstream>\n#include <typeinfo>\n#include <queue>\n#include <stack>\n#include <tuple>\n\nusing namespace std;\n\n\ntypedef long long ll;\nconst int INT_INF = 1 << 29;\nconst ll INF = 1LL<<55;\n\ntypedef pair<int, int> P;\nstruct edge {\n\tint to;\n\tint cap;\n\tll cost;\n\tint rev;\n};\n\nconst int MAX_V = 20010;\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, ll cost) {\n\tG[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n\tG[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nll min_cost_flow(int s, int t, int f, bool bell = false) {\n\tll res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tfill_n(dist, V, INF);\n\t\tdist[s] = 0;\n\t\tif (bell) {\n\t\t\tbell = false;\n\t\t\tbool update;\n\t\t\tdo {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t} else {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nconst int MAX_N = 10010, MAX_K = 10010;\n\nint main(int argc, char *argv[]) {\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\tint w[MAX_N];\n\tfor (int i = 0; i < N; i++) {\n\t\tscanf(\"%d\", &w[i]);\n\t}\n\tint a[MAX_K], r = 0;\n\tfor (int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\ta[i]--;\n\t\tr+= w[a[i]];\n\t}\n\tint b[MAX_N];\n\tfill_n(b, MAX_N, -1);\n\tfor (int i = 0; i < K; i++) {\n\t\tadd_edge(i, i+1, INT_INF, 0);\n\t\tint j = b[a[i]];\n\t\tif (j != -1) {\n\t\t\tif (j == i) {\n\t\t\t\tr -= w[a[i]];\n\t\t\t} else {\n\t\t\t\tadd_edge(b[a[i]], i, 1, -w[a[i]]);\n\t\t\t}\n\t\t}\n\t\tb[a[i]] = i+1;\n\t}\n\tV = K+1;\n\tprintf(\"%lld\\n\", r + min_cost_flow(0, K, M-1, true));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/01/14  Problem: AOJ 2266 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2266  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\nDPにも貪欲にもできないので最小費用流なのは何となく分かるんだけど\nそれ以上は全く何もわからないため答えを見た。\n\n\n\n----解説ここまで---- */\n\n\n/* 最小費用流 負辺もいける */\ntypedef long long PD_Type;\nconst PD_Type PD_INF = 1 << 30;\n\nstruct Primal_Dual\n{\n\ttypedef pair< PD_Type, int > pii;\n\n\tstruct edge\n\t{\n\t\tint to, rev;\n\t\tPD_Type\tcap, cost;\n\t\tedge() {}\n\t\tedge(int to, PD_Type cap, PD_Type cost, int rev) :to(to), cap(cap), cost(cost), rev(rev) {}\n\n\t};\n\tvector< vector< edge > > graph;\n\tvector< int > prevv, preve;\n\tvector< PD_Type > potential, min_cost;\n\tPrimal_Dual(int V) : graph(V) {}\n\n\tvoid add_edge(int from, int to, PD_Type cap, PD_Type cost)\n\t{\n\t\tgraph[from].push_back(edge(to, cap, cost, (int)graph[to].size()));\n\t\tgraph[to].push_back(edge(from, 0, -cost, (int)graph[from].size() - 1));\n\t}\n\n\tPD_Type min_cost_flow(int s, int t, int f)\n\t{\n\t\tint V = graph.size();\n\t\tPD_Type ret = 0;\n\t\tpriority_queue< pii, vector< pii >, greater< pii > > que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\t//一回だけbellmanfordで最初のポテンシャルを求める\n\t\tFOR(k, 0, V) {\n\t\t\tFOR(i, 0, V) {\n\t\t\t\tFOR(j, 0, (int)graph[i].size()) {\n\t\t\t\t\tedge &e = graph[i][j];\n\t\t\t\t\tif (e.cap == 0)continue; // 誤差注意\n\t\t\t\t\tpotential[e.to] = min(potential[e.to], potential[i] + e.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, PD_INF);\n\t\t\tque.push(pii(0, s));\n\t\t\tmin_cost[s] = 0;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < (int)graph[p.second].size(); i++) {\n\t\t\t\t\tedge &e = graph[p.second][i];\n\t\t\t\t\tPD_Type nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(min_cost[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == PD_INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tPD_Type addflow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tgraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n// Primal_Dual mnf(仕様頂点数), mnf.add_edge(a,b,cap,cost), mnf.min_cost_flow(s,t,f)\nLL N,M,K;\n\nLL ans = 0LL;\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tcin >> M>>N>>K;\n\tPrimal_Dual F(K);\n\tVL a(N);\n\tFOR(i, 0, N) {\n\t\tcin >> a[i];\n\t}\n\tVVI B(10004,VI());\n\tLL sum = 0;\n\tFOR(i, 0, K) {\n\t\tint aa; cin >> aa; aa--;\n\t\tB[aa].push_back(i);\n\t\tsum += a[aa];\n\t}\n\n\tFOR(i, 0, N) {\n\t\tif (SZ(B[i]) <= 1)continue;\n\t\tFOR(j, 0, SZ(B[i]) - 1) {\n\t\t\tint n1 = B[i][j], n2 = B[i][j + 1];\n\t\t\tif (n1 + 1 != n2)F.add_edge(n1 + 1, n2, 1, -a[i]);\n\t\t\telse sum -= a[i];\n\t\t}\n\t}\n\tFOR(i, 0, K - 1)F.add_edge(i,i+1,M,0);\n\tans = sum + F.min_cost_flow(0, K - 1, M - 1);\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1<<29;\nstruct edge{int to,cap,cost,rev;};\nvector<edge> graph[vmax];\n\nint h[vmax],dist[vmax];\nint pv[vmax],pe[vmax];\ntypedef tuple<int,int> state;\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tgraph[from].push_back({to,cap,cost,(int)graph[to].size()});\n\tgraph[to].push_back({from,0,-cost,(int)graph[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f,int n){\n\tint res=0;\n\tfill(h,h+n,0);\n\twhile(f>0){\n\t\tpriority_queue <state,vector<state>,greater<state> > q;\n\t\tfill(dist,dist+n,inf);\n\t\tdist[s]=0;\n\t\tq.push(state(0,s));\n\t\twhile(!q.empty()){\n\t\t\tint cost,v;\n\t\t\ttie(cost,v)=q.top();q.pop();\n\t\t\tif(dist[v] < cost) continue;\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tedge &e=graph[v][i];\n\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tpv[e.to]=v,pe[e.to]=i;\n\t\t\t\t\tq.push(state(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==inf) return -1;\n\t\trep(v,n) h[v]+=dist[v];\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=pv[v]) d=min(d,graph[pv[v]][pe[v]].cap);\n\t\tf-=d;res+=d*h[t];\n\t\tfor(int v=t;v!=s;v=pv[v]){\n\t\t\tedge &e=graph[pv[v]][pe[v]];\n\t\t\te.cap-=d;\n\t\t\tgraph[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint w[10010];\nint a[10010];\n\nint main(void){\n\tint m,n,k;\n\tcin >> m >> n >> k;\n\trep(i,n) cin >> w[i];\n\trep(i,k) cin >> a[i],a[i]--;\n\n\tint sum=0;\n\trep(i,k) sum+=w[a[i]];\n\n\trep(i,k-1) add_edge(i,i+1,inf,0);\n\n\tint prev[10010];\n\trep(i,n) prev[i]=-1;\n\n\trep(i,k){\n\t\tint cur=a[i];\n\t\tif(prev[cur]!=-1) add_edge(prev[cur]+1,i,1,-w[cur]);\n\t\tprev[cur]=i;\n\t}\n\tcout << sum+min_cost_flow(0,k-1,m-1,k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n  \ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, to, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, to, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f){\n  typedef pair<int, int> P;\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> h(n, 0);\n  vector<int> prevv(n);\n  vector<int> preve(n);\n\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    vector<int> dist(n, INT_MAX);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n      P p   = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < (int)g[v].size(); i++){\n\tE &e = g[v][i];\n\n\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t  dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];\n\t  prevv[e.to] = v;\n\t  preve[e.to] = i;\n\t  que.push(P(dist[e.to], e.to));\n\t}\n      }\n    }\n    if(dist[t] == INT_MAX){\n      return -1;\n    }\n\n    for(int v = 0; v < n; v++) h[v] += dist[v];\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n\n    f   -= d;\n    res += d * h[t];\n\n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n};\n\nint main(){\n  int m = getInt();\n  int n = getInt();\n  int k = getInt();\n\n  vector<int> w(n);\n  vector<int> a(k);\n\n  Graph<CostEdge> g(k);\n\n  REP(i,n) w[i] = getInt();\n  REP(i,k) a[i] = getInt() - 1;\n\n  int ans = 0;\n  REP(i,k) ans += w[a[i]];\n\n  REP(i,k){\n    if(i != k - 1) g.addEdge(i, i + 1, 100000, 0);\n    rep(j, i + 1, k){\n      if(a[i] == a[j]){\n\tg.addEdge(i + 1, j, 1, - w[a[i]]);\n\tbreak;\n      }\n    }\n  }\n\n  ans += minCostFlow(g, 0, k - 1, m - 1);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = long long;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 100000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tpd.add_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n  \ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f, bool negative = false){\n  typedef pair<int, int> P;\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> h(n, 0);\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 10000000;\n\n  if(negative){\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    \n    bool update = true;\n    \n    while(update){\n      update = false;\n      for(int v = 0; v < n; v++){\n\tif(dist[v] == inf) continue;\n\tfor(int i = 0; i < (int)g[v].size(); i++){\n\t  E &e = g[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v] + e.cost){\n\t    dist[e.to]  = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update      = true;\n\t  }\n\t}\n      }\n    }\n\n    for(int i = 0; i < n; i++)\n      h[i] = dist[i];\n  }\n\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n      P p   = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < (int)g[v].size(); i++){\n\tE &e = g[v][i];\n\n\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t  dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];\n\t  prevv[e.to] = v;\n\t  preve[e.to] = i;\n\t  que.push(P(dist[e.to], e.to));\n\t}\n      }\n    }\n    if(dist[t] == inf){\n      return -1;\n    }\n\n    for(int v = 0; v < n; v++) h[v] += dist[v];\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n\n    f   -= d;\n    res += d * h[t];\n\n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m = getInt();\n  int n = getInt();\n  int k = getInt();\n\n  vector<int> w(n);\n  vector<int> a(k);\n\n  Graph<CostEdge> g(k);\n\n  REP(i,n) w[i] = getInt();\n  REP(i,k) a[i] = getInt() - 1;\n\n  int ans = 0;\n  REP(i,k) ans += w[a[i]];\n\n  vector<int> prevs(n, -1);\n\n  REP(i,k){\n    if(i != k - 1) g.addEdge(i, i + 1, 10000, 0);\n    int aa = a[i];\n    if(prevs[aa] != -1){\n      int j = prevs[aa];\n      if(j + 1 == i){\n\tans -= w[a[i]];\n      }else{\n\tg.addEdge(j + 1, i, 1, - w[a[i]]);\n      }\n    }\n    prevs[aa] = i;\n  }\n\n  ans += minCostFlow(g, 0, k - 1, m - 1, true);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL BASE = 10000LL * 10000LL * 100;\nconst LL INF = 1LL << 59;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow cap, flow;\n    Cost cost;\n    Edge *back;\n\n    Edge(int from, int to, Flow cap, Cost cost, Edge *back) : from(from), to(to), cap(cap), flow(0), cost(cost), back(back) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    Edge<Flow,Cost> *ea = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    Edge<Flow,Cost> *eb = new Edge<Flow,Cost>(dst, src, 0, -d, ea);\n    ea->back = eb;\n    g[src].push_back(ea);\n    g[dst].push_back(eb);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow,Cost>\nprimal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, Flow max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> dist(N);\n    vector<Edge<Flow,Cost>*> prev(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        fill(prev.begin(), prev.end(), nullptr);\n        dist[src] = 0;\n\n        while(true) {\n            bool updated = false;\n            for(int i = 0; i < N; ++i) {\n                for(auto *e : g[i]) {\n                    if(e->cap - e->flow > 0) {\n                        Cost nc = dist[e->from] + e->cost;\n                        if(nc < dist[e->to]) {\n                            dist[e->to] = nc;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(!updated) break;\n        }\n        if(prev[sink] == nullptr) break;\n\n        Flow aug = f;\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            aug = min(aug, e->cap - e->flow);\n        }\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            res.second += aug * e->cost;\n            e->flow += aug;\n            e->back->flow -= aug;\n        }\n        f -= aug;\n        res.first += aug;\n    }\n\n    return res;\n}\n\nbool solve() {\n    int M, N, K;\n    if(!(cin >> M >> N >> K)) return false;\n\n    vector<LL> ws(N);\n    vector<int> as;\n    vector<vector<Edge<int,LL>*>> graph(K+2);\n    const int SRC = K;\n    const int SINK = K+1;\n    for(int i = 0; i < N; ++i) {\n        cin >> ws[i];\n    }\n    LL sum = 0;\n    for(int i = 0; i < K; ++i) {\n        int a;\n        cin >> a;\n        --a;\n        if(as.size() > 0 && as.back() == a) {\n            // do nothing\n        } else {\n            as.push_back(a);\n            sum += ws[a];\n        }\n    }\n    for(int i = 0; i < as.size(); ++i) {\n        // Edge to neighbor\n        if(i+1 < K) {\n            add_edge(graph, i, i+1, M, 0LL);\n        }\n        // Edge to next same number\n        auto it = find(as.begin()+i+1, as.end(), as[i]);\n        if(it != as.end()) {\n            add_edge(graph, i+1, it-as.begin(), 1, -ws[as[i]]);\n        }\n    }\n    add_edge(graph, SRC, 0, M, 0LL);\n    add_edge(graph, K-1, SINK, M, 0LL);\n    auto res = primal_dual(graph, SRC, SINK, M-1);\n    cout << sum + res.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nstruct EdgeC{\n  int to, cap, cost, rev;\n  EdgeC(int to_=0, int cap_ = 0, int cost_ = 0, int rev_ = 0)\n\t:to(to_), cap(cap_), cost(cost_), rev(rev_){}\n};\nusing GraphC = vector<vector<EdgeC>>;\n\nvoid add_edge(GraphC& G, int from, int to, int cap, int cost){\n  G[from].emplace_back(to, cap, cost, G[to].size());\n  G[to].emplace_back(from, 0, -cost, G[from].size()-1);\n}\n\nint min_cost_flow(GraphC& G, int s, int t, int f){\n  int V = G.size();\n  vector<int> dist(V);\n  vector<int> prevv(V), preve(V);\n  int res = 0;\n  \n  while(f > 0){\n\tfill(begin(dist), end(dist), INF);\n\tdist[s] = 0;\n\tbool update = true;\n\twhile(update){\n\t  update = false;\n\t  for(int v=0;v<V;++v){\n\t\tif(dist[v] == INF) continue;\n\t\tfor(unsigned int i=0;i<G[v].size();++i){\n\t\t  auto& e = G[v][i];\n\t\t  if(e.cap > 0 && dist[v] + e.cost < dist[e.to]){\n\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\tprevv[e.to] = v;\n\t\t\tpreve[e.to] = i;\n\t\t\tupdate = true;\n\t\t  }\n\t\t}\n\t  }\n\t}\n\tif(dist[t] == INF) return -INF;\n\n\tint d = f;\n\tfor(int v=t;v!=s;v=prevv[v])\n\t  d = min(d, G[prevv[v]][preve[v]].cap);\n\n\tf -= d;\n\tres += d * dist[t];\n\tfor(int v=t;v!=s;v=prevv[v]){\n\t  auto& e = G[prevv[v]][preve[v]];\n\t  e.cap -= d;\n\t  G[v][e.rev].cap += d;\n\t}\n  }\n  \n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int BOX, BALL, K;\n  cin >> BOX >> BALL >> K;\n  VI xs(BALL);\n  cin >> xs;\n\n  VI qs_(K);\n  cin >> qs_;\n\n  VI qs;\n  REP(i,K)\n\tif(qs.empty() || qs.back() != qs_[i])\n\t  qs.PB(qs_[i]);\n  K = SZ(qs);\n\n  VI last(BALL+1,-1);\n  VI post(K,-1);\n  for(int i=K-1;i>=0;--i){\n\tpost[i] = last[qs[i]];\n\tlast[qs[i]] = i;\n  }\n\n  int ans = 0;\n  GraphC G(K+1);\n  REP(k,K){\n\tadd_edge(G, k, k+1, BOX, 0);\n\tans += xs[qs[k]-1];\n\tif(post[k] >= 0){\n\t  add_edge(G, k+1, post[k], 1, -xs[qs[k]-1]);\n\t}\n  }\n  cout << ans + min_cost_flow(G, 0, K, BOX-1) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define ALL(x) begin(x), end(x)\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T> inline void chmin(T & a, T const & b) { a = min(a, b); }\n\ntemplate <class T>\nstruct edge { int to; T cap, cost; int rev; };\ntemplate <class T>\nvoid add_edge(vector<vector<edge<T> > > & graph, int from, int to, T cap, T cost) {\n    graph[from].push_back((edge<T>) {   to, cap,  cost, int(graph[  to].size())     });\n    graph[  to].push_back((edge<T>) { from,  0, - cost, int(graph[from].size()) - 1 });\n}\n/**\n * @brief minimum-cost flow with primal-dual method\n * @note mainly O(V^2UC) for U is the sum of capacities and C is the sum of costs. and additional O(VE) if negative edges exist\n */\ntemplate <class T>\nT min_cost_flow_destructive(int src, int dst, T flow, vector<vector<edge<T> > > & graph) {\n    T result = 0;\n    vector<T> potential(graph.size());\n    if (0 < flow) { // initialize potential when negative edges exist (slow). you can remove this if unnecessary\n        fill(ALL(potential), numeric_limits<T>::max());\n        potential[src] = 0;\n        while (true) { // Bellman-Ford algorithm\n            bool updated = false;\n            REP (e_from, graph.size()) for (auto & e : graph[e_from]) if (e.cap) {\n                if (potential[e_from] == numeric_limits<T>::max()) continue;\n                if (potential[e.to] > potential[e_from] + e.cost) {\n                    potential[e.to] = potential[e_from] + e.cost; // min\n                    updated = true;\n                }\n            }\n            if (not updated) break;\n        }\n    }\n    while (0 < flow) {\n        // update potential using dijkstra\n        vector<T> distance(graph.size(), numeric_limits<T>::max()); // minimum distance\n        vector<int> prev_v(graph.size()); // constitute a single-linked-list represents the flow-path\n        vector<int> prev_e(graph.size());\n        { // initialize distance and prev_{v,e}\n            reversed_priority_queue<pair<T, int> > que; // distance * vertex\n            distance[src] = 0;\n            que.emplace(0, src);\n            while (not que.empty()) { // Dijkstra's algorithm\n                T d; int v; tie(d, v) = que.top(); que.pop();\n                if (potential[v] == numeric_limits<T>::max()) continue; // for unreachable nodes\n                if (distance[v] < d) continue;\n                // look round the vertex\n                REP (e_index, graph[v].size()) {\n                    // consider updating\n                    edge<T> e = graph[v][e_index];\n                    int w = e.to;\n                    if (potential[w] == numeric_limits<T>::max()) continue;\n                    T d1 = distance[v] + e.cost + potential[v] - potential[w]; // updated distance\n                    if (0 < e.cap and d1 < distance[e.to]) {\n                        distance[w] = d1;\n                        prev_v[w] = v;\n                        prev_e[w] = e_index;\n                        que.emplace(d1, w);\n                    }\n                }\n            }\n        }\n        if (distance[dst] == numeric_limits<T>::max()) return -1; // no such flow\n        REP (v, graph.size()) {\n            if (potential[v] == numeric_limits<T>::max()) continue;\n            potential[v] += distance[v];\n        }\n        // finish updating the potential\n        // let flow on the src->dst minimum path\n        T delta = flow; // capacity of the path\n        for (int v = dst; v != src; v = prev_v[v]) {\n            chmin(delta, graph[prev_v[v]][prev_e[v]].cap);\n        }\n        flow -= delta;\n        result += delta * potential[dst];\n        for (int v = dst; v != src; v = prev_v[v]) {\n            edge<T> & e = graph[prev_v[v]][prev_e[v]]; // reference\n            e.cap -= delta;\n            graph[v][e.rev].cap += delta;\n        }\n    }\n    return result;\n}\n\nconstexpr int inf = 1e9 + 7;\nint main() {\n    // input\n    int m, n, k; scanf(\"%d%d%d\", &m, &n, &k);\n    vector<int> w(n); REP (i, n) scanf(\"%d\", &w[i]);\n    vector<int> a(k);\n    REP (i, k) {\n        scanf(\"%d\", &a[i]);\n        -- a[i];\n    }\n    // solve\n    a.erase(unique(ALL(a)), a.end());  // remove consecutive same elements\n    k = a.size();\n    int base = 0;\n    vector<vector<edge<int> > > g(k);\n    vector<int> last(n, -1);\n    REP_R (i, k) {\n        base += w[a[i]];\n        if (i < k - 1) {\n            add_edge(g, i, i + 1, inf, 0);\n            if (last[a[i]] != -1) {\n                add_edge(g, i + 1, last[a[i]], 1, - w[a[i]]);\n            }\n        }\n        last[a[i]] = i;\n    }\n    int result = base + min_cost_flow_destructive(0, k - 1, m - 1, g);\n    // output\n    printf(\"%d\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \nusing namespace std;\n \ntypedef long long LL;\nconst LL INF = 1LL << 59;\n \ntemplate<class Flow, class Cost>\nstruct Edge\n{\n\tint from, to;\n\tFlow cap, flow;\n\tCost cost;\n\tEdge *back;\n \n\tEdge(int from, int to, Flow cap, Cost cost, Edge *back)\n\t\t: from(from), to(to), cap(cap), flow(0), cost(cost), back(back)\n\t{}\n};\n \ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost> *> > &g, int src, int dst, Flow c, Cost d)\n{\n\tEdge<Flow, Cost> *ea = new Edge<Flow, Cost>(src, dst, c, d, nullptr);\n\tEdge<Flow, Cost> *eb = new Edge<Flow, Cost>(dst, src, 0, -d, ea);\n\tea->back = eb;\n\tg[src].push_back(ea);\n\tg[dst].push_back(eb);\n}\n \ntemplate<class Flow, class Cost>\npair<Flow, Cost> primal_dual(vector<vector<Edge<Flow, Cost> *> > &g, int src, int sink, Flow max_flow)\n{\n\tconst int N = g.size();\n\tpair<Flow, Cost> res;\n\tvector<Cost> dist(N);\n\tvector<Edge<Flow, Cost> *> prev(N);\n\tfor (Flow f = max_flow; f > 0;)\n\t{\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tfill(prev.begin(), prev.end(), nullptr);\n\t\tdist[src] = 0;\n \n\t\twhile (true)\n\t\t{\n\t\t\tbool updated = false;\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t{\n\t\t\t\tfor (auto *e : g[i])\n\t\t\t\t{\n\t\t\t\t\tif (e->cap - e->flow > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tCost nc = dist[e->from] + e->cost;\n\t\t\t\t\t\tif (nc < dist[e->to])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdist[e->to] = nc;\n\t\t\t\t\t\t\tprev[e->to] = e;\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!updated)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (prev[sink] == nullptr)\n\t\t\tbreak;\n \n\t\tFlow aug = f;\n\t\tfor (auto *e = prev[sink]; e; e = prev[e->from])\n\t\t{\n\t\t\taug = min(aug, e->cap - e->flow);\n\t\t}\n\t\tfor (auto *e = prev[sink]; e; e = prev[e->from])\n\t\t{\n\t\t\tres.second += aug * e->cost;\n\t\t\te->flow += aug;\n\t\t\te->back->flow -= aug;\n\t\t}\n\t\tf -= aug;\n\t\tres.first += aug;\n\t}\n \n\treturn res;\n}\n \nbool solve()\n{\n\tint M, N, K;\n\tif (!(cin >> M >> N >> K))\n\t\treturn false;\n \n\tvector<LL> ws(N);\n\tvector<int> as;\t// 数字序列\n\tvector<vector<Edge<int, LL> *> > graph(K + 2);\n\tconst int SRC = K;\n\tconst int SINK = K + 1;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tcin >> ws[i];\n\t}\n\tLL sum = 0;\t// 总权重\n\tfor (int i = 0; i < K; ++i)\n\t{\n\t\tint a;\n\t\tcin >> a;\n\t\t--a;\n\t\tif (as.size() > 0 && as.back() == a)\n\t\t{\n\t\t\t// do nothing 排除连续相同的序号\n\t\t}\n\t\telse\n\t\t{\n\t\t\tas.push_back(a);\n\t\t\tsum += ws[a];\n\t\t}\n\t}\n\tconst int L = as.size();\n\tfor (int i = 0; i < L; ++i)\n\t{\n\t\t// Edge to neighbor\n\t\tif (i + 1 < L)\n\t\t{\n\t\t\tadd_edge(graph, i, i + 1, M, 0LL);\t// v[t] -(∞/0)-> v[t+1]\n\t\t}\n\t\t// Edge to next same number\n\t\tauto it = find(as.begin() + i + 1, as.end(), as[i]);\n\t\tif (it != as.end())\n\t\t{\n\t\t\tadd_edge(graph, i + 1, it - as.begin(), 1, -ws[as[i]]);\t// v[t+1] -(1/-w[v[t]])-> v[t']\n\t\t}\n\t}\n\tadd_edge(graph, SRC, 0, M, 0LL);\n\tadd_edge(graph, L - 1, SINK, M, 0LL);\n\tauto res = primal_dual(graph, SRC, SINK, M - 1);\n\tcout << sum + res.second << endl;\n\treturn true;\n}\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n \n\twhile (solve());\n#ifndef ONLINE_JUDGE\n\tfclose(stdin);\n\tfclose(stdout);\n\tsystem(\"out.txt\");\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL BASE = 10000LL * 10000LL * 100;\nconst LL INF = 1LL << 59;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow cap, flow;\n    Cost cost;\n    Edge *back;\n\n    Edge(int from, int to, Flow cap, Cost cost, Edge *back) : from(from), to(to), cap(cap), flow(0), cost(cost), back(back) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    Edge<Flow,Cost> *ea = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    Edge<Flow,Cost> *eb = new Edge<Flow,Cost>(dst, src, 0, -d, ea);\n    ea->back = eb;\n    g[src].push_back(ea);\n    g[dst].push_back(eb);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow,Cost>\nprimal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, Flow max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> dist(N);\n    vector<Edge<Flow,Cost>*> prev(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        fill(prev.begin(), prev.end(), nullptr);\n        dist[src] = 0;\n\n        while(true) {\n            bool updated = false;\n            for(int i = 0; i < N; ++i) {\n                for(auto *e : g[i]) {\n                    if(e->cap - e->flow > 0) {\n                        Cost nc = dist[e->from] + e->cost;\n                        if(nc < dist[e->to]) {\n                            dist[e->to] = nc;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(!updated) break;\n        }\n        if(prev[sink] == nullptr) break;\n\n        Flow aug = f;\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            aug = min(aug, e->cap - e->flow);\n        }\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            res.second += aug * e->cost;\n            e->flow += aug;\n            e->back->flow -= aug;\n        }\n        f -= aug;\n        res.first += aug;\n    }\n\n    return res;\n}\n\nbool solve() {\n    int M, N, K;\n    if(!(cin >> M >> N >> K)) return false;\n\n    vector<LL> ws(N);\n    vector<int> as(K);\n    vector<vector<Edge<int,LL>*>> graph(K+2);\n    const int SRC = K;\n    const int SINK = K+1;\n    for(int i = 0; i < N; ++i) {\n        cin >> ws[i];\n    }\n    LL sum = 0;\n    for(int i = 0; i < K; ++i) {\n        cin >> as[i];\n        --as[i];\n        sum += ws[as[i]];\n    }\n    for(int i = 0; i < K; ++i) {\n        // Edge to neighbor\n        if(i+1 < K) {\n            add_edge(graph, i, i+1, M, 0LL);\n        }\n        // Edge to next same number\n        auto it = find(as.begin()+i+1, as.end(), as[i]);\n        if(it != as.end()) {\n            add_edge(graph, i+1, it-as.begin(), 1, -ws[as[i]]);\n        }\n    }\n    add_edge(graph, SRC, 0, M, 0LL);\n    add_edge(graph, K-1, SINK, M, 0LL);\n    auto res = primal_dual(graph, SRC, SINK, M-1);\n    cout << sum + res.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\ntypedef int Weight;\nconst Weight INF=1<<29;\nstruct Edge{\n\tint src,dst;\n\tWeight weight,cap; // weight が辺のコストを表す\n\tint rev; // 逆辺の番号\n\tEdge(int src,int dst,Weight weight=0,Weight cap=0,int rev=-1):\n\tsrc(src),dst(dst),weight(weight),cap(cap),rev(rev)\n\t{}\n};\nstruct Node:public vector<Edge>{};\nbool operator<(const Edge &a,const Edge &b){\n\treturn a.weight<b.weight;\n}\nbool operator>(const Edge &a,const Edge &b){return b<a;}\ntypedef vector<Node> Graph;\ntypedef vector<vector<Weight> > Matrix;\n\n//src から dst へ向かう容量 cap,コストcost の辺をグラフに追加する\nvoid add_edge(Graph &G,int src,int dst,Weight cap,Weight cost){\n\tG[src].push_back(Edge(src,dst,cost,cap,G[dst].size()));\n\tG[dst].push_back(Edge(dst,src,-cost,0,G[src].size()-1));\n}\n\nWeight min_cost_flow(Graph &G,int s,int t,Weight f){\n\ttypedef pair<Weight,int> P;\n\tWeight res=0;\n\tint V=G.size();\n\tvector<Weight> h(V,0);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\tif(s==t)return 0;\n\tbool start=true;\n\twhile(f>0){\n\t\tvector<Weight> dist(V,INF);\n\t\tif(start){\n\t\t\tbool update=true;\n\t\t\tdist[s]=0;\n\t\t\twhile(update){\n\t\t\t\tupdate=false;\n\t\t\t\tREP(v,V){\n\t\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\t\tREP(i,G[v].size()){\n\t\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight){\n\t\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight;\n\t\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstart=0;\n\t\t}else{\n\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\tdist[s]=0;\n\t\t\tque.push(P(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.top();que.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first)continue;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight+h[v]-h[e.dst]){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight+h[v]-h[e.dst];\n\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\tque.push(P(dist[e.dst],e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\t\tWeight d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tEdge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint M, N, K;\n\nmain(){\n\tios::sync_with_stdio(false);\n\tcin >> M >> N >> K;\n\tvi w(N), a(K);\n\tREP(i, N){\n\t\tcin >> w[i];\n\t}\n\tint res = 0;\n\tREP(i, K){\n\t\tcin >> a[i]; a[i]--;\n\t}\n\tUNIQUE(a);\n\tK = a.size();\n\tREP(i, K) res += w[a[i]];\n\tGraph g(K+2);\n\tREP(i, K-1) add_edge(g, i, i+1, INF, 0);\n\tadd_edge(g, K, 0, M-1, 0);\n\tadd_edge(g, K-1, K+1, M-1, 0);\n\tvi prev(N, -1);\n\tREP(i, K){\n\t\tif(prev[a[i]] != -1){\n\t\t\tconst int u = prev[a[i]]+1;\n\t\t\tconst int v = i;\n\t\t\tadd_edge(g, u, v, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\tres += min_cost_flow(g, K, K+1, M-1);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 51000\n\t#define MAXM 1000000\n\t#define wint int\n\t#define cint long long \n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint p[11000];\nint q[11000];\nint last[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",q+i);\n\t\tq[i]--;\n\t}\n\tfor(int i=0;i<b;i++)last[i]=-1;\n\tMCF::init((c+1)*3+2);\n\tint s=(c+1)*3;\n\tint t=(c+1)*3+1;\n\tMCF::ae(s,0,10,0);\n\tMCF::ae(c,t,10,0);\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i,i+1,10,0);\n\t\tMCF::ae(i,c+1+i,1,p[q[i]]);\n\t\tMCF::ae(2*c+2+i,i+1,1,0);\n\t\tMCF::ae(c+1+i,2*c+2+i,1,-1000000000);\n\t\tif(~last[q[i]]){\n\t\t\tMCF::ae(2*c+2+last[q[i]],c+1+i,1,0);\n\t\t}\n\t\tlast[q[i]]=i;\n\t}\n\tMCF::solve(s,t,a);\n\tprintf(\"%lld\\n\",MCF::toc+1000000000LL*c);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 51000\n\t#define MAXM 1000000\n\t#define wint int\n\t#define cint long long \n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i]) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint p[11000];\nint q[11000];\nint last[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",q+i);\n\t\tq[i]--;\n\t}\n\tfor(int i=0;i<b;i++)last[i]=-1;\n\tMCF::init((c+1)*3+2);\n\tint s=(c+1)*3;\n\tint t=(c+1)*3+1;\n\tMCF::ae(s,0,10,0);\n\tMCF::ae(c,t,10,0);\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i,i+1,10,0);\n\t\tMCF::ae(i,c+1+i,1,p[q[i]]);\n\t\tMCF::ae(2*c+2+i,i+1,1,0);\n\t\tMCF::ae(c+1+i,2*c+2+i,1,-1000000000);\n\t\tif(~last[q[i]]){\n\t\t\tMCF::ae(2*c+2+last[q[i]],c+1+i,1,0);\n\t\t}\n\t\tlast[q[i]]=i;\n\t}\n\tMCF::solve(s,t,a);\n\tprintf(\"%lld\\n\",MCF::toc+1000000000LL*c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int MAX_N = 10000;\nconst int MAX_K = 10000;\nconst int MAX_V = MAX_K + 2;\nconst int INF = 1<<29;\n\nint M, N, K;\nint ws[MAX_N];\nvector<int> as;\nvector<int> ts[MAX_N];\n\ntypedef pair<int, int> P;\nstruct edge{ int to, cap, cost, rev; };\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\tfill(h, h+V, 0);\n\twhile(f > 0){\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v] < p.first) continue;\n\t\t\tfor(int i=0; i<G[v].size(); i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v = 0; v<V; v++) h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor(int v=t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor(int v=t; v!=s; v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint solve(){\n\tint tot = 0, cnt = 0;\n\n\tfor(int i=0; i<K; i++){\n\t\tts[as[i]-1].push_back(i);\n\t}\n\n\tconst int source = K, sink = K + 1;\n\tV = sink + 1;\n\n\tadd_edge(source, 0, M-1, 0);\n\tadd_edge(K-1, sink, M-1, 0);\n\tfor(int i=0; i+1<K; i++){\n\t\tadd_edge(i, i+1, INF, 0);\n\t}\n\n\tfor(int i=0; i<N; i++)if(!ts[i].empty()){\n\t\tfor(int j=0; j+1 < (int)ts[i].size(); j++){\n\t\t\tadd_edge(ts[i][j+1], ts[i][j]+1, 1, ws[i]);\n\t\t\tadd_edge(source, ts[i][j+1], 1, 0);\n\t\t\tadd_edge(ts[i][j]+1, sink, 1, 0);\n\t\t\tcnt++;\n\t\t\ttot -= ws[i];\n\t\t}\n\t}\n\n\treturn min_cost_flow(source, sink, M-1 + cnt) - tot;\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tfor(int i=0; i<N; i++){\n\t\tscanf(\"%d\", ws+i);\n\t}\n\tfor(int i=0; i<K; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tas.push_back(x);\n\t}\n\n\tas.erase(unique(as.begin(), as.end()), as.end());\n\tK = as.size();\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\n// (?????????, ??????, ?????????, ??????)\nstruct edge{ int to,cap,cost,rev; };\n\nint V; // TODO:initialize\nconst int MAX_V = 30303; // TODO:initialize\nconst int INF = 123456789; // TODO:initialize\nvector<edge> G[MAX_V];\nint h[MAX_V]; // ??????????????£???\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,(int)G[to].size()});\n    G[to].pb({from,0,-cost,(int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???(???????????????-1)\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        // dijkstra??§h?????´??°\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        pq.push(pi(0,s));\n        while(!pq.empty()){\n            pi p = pq.top();\n            pq.pop();\n            int v = p.se;\n            if(p.fi>dist[v]) continue;\n            rep(i,G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    pq.push(pi(dist[e.to],e.to));\n                }\n            }\n        }\n\n        // ????????\\???????????????\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t???????????????????????£??????????????????\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nconst int M=10101;\n\nvector<int> num[10000];\n\nint main()\n{\n    int F,n,k;\n    scanf(\" %d %d %d\", &F, &n, &k);\n    vector<int> w(n),a(k);\n    rep(i,n) scanf(\" %d\", &w[i]);\n    rep(i,k)\n    {\n        scanf(\" %d\", &a[i]);\n        --a[i];\n        num[a[i]].pb(i);\n    }\n\n    V = 3*k+2;\n    int S=3*k, T=S+1;\n    add_edge(S,0,F,0);\n\n    rep(i,k)\n    {\n        add_edge(3*i,3*i+1,1,w[a[i]]);\n        add_edge(3*i+1,3*i+2,1,-M);\n        if(i<k-1)\n        {\n            add_edge(3*i+2,3*(i+1),1,0);\n            add_edge(3*i,3*(i+1),F,0);\n        }\n    }\n\n    rep(i,n)\n    {\n        int SZ = num[i].size();\n        if(SZ<2) continue;\n        rep(j,SZ-1)\n        {\n            int u=num[i][j], v=num[i][j+1];\n            add_edge(3*u+2,3*v+1,1,0);\n        }\n    }\n\n    add_edge(3*k-3,T,F,0);\n    add_edge(3*k-1,T,F,0);\n\n    printf(\"%d\\n\", min_cost_flow(S,T,F)+M*k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef int Weight;\nstruct Edge {\n  int index;\n  int src;\n  int dest;\n  Weight capacity;\n  Weight cost;\n  Edge(int index, int src, int dest, Weight capacity, Weight cost) : index(index), src(src), dest(dest), capacity(capacity), cost(cost) {;}\n  bool operator<(const Edge &rhs) const {\n    if (cost != rhs.cost) { return cost > rhs.cost; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid printMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\n// index^1 is reverse edge\npair<Weight, Weight> MinCostFlow(const Graph &g, int e, int s, int t) {\n  const int n = g.size();\n  Array capacity(e, 0);\n  for (int from = 0; from < n; from++) {\n    for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n      capacity[it->index] += it->capacity;\n    }\n  }\n  pair<Weight, Weight> ret = make_pair(0, 0);\n  vector<pair<int, int> > parent(n);\n  vector<Weight> prev_dist(n, 0);\n  vector<Weight> now_dist(n);\n\n  // calc potential\n  for (int iter = 0; iter < n; iter++) {\n    bool end = true;\n    for (int from = 0; from < n; from++) {\n      for (int i = 0; i < (int)g[from].size(); i++) {\n        if (g[from][i].capacity <= 0) { continue; }\n        int to = g[from][i].dest;\n        Weight ncost = prev_dist[from] + g[from][i].cost;\n        if (ncost < prev_dist[to]) {\n          end = false;\n          prev_dist[to] = ncost;\n        }\n      }\n    }\n    if (end) { break; }\n    if (iter == n - 1) {\n      assert(false); // exist negative cycle\n    }\n  }\n\n  while (true) {\n    fill(parent.begin(), parent.end(), make_pair(-1, -1));\n    fill(now_dist.begin(), now_dist.end(), 2000000000LL);\n    priority_queue<Edge> que;\n    que.push(Edge(e, s, s, 0, 0));\n    now_dist[s] = 0;\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (parent[node.dest].first != -1) { continue; }\n      parent[node.dest] = make_pair(node.src, node.index);\n      int from = node.dest;\n      for (int i = 0; i < (int)g[from].size(); i++) {\n        int to = g[from][i].dest;\n        int index = g[from][i].index;\n        Weight ncost = node.cost + g[from][i].cost + (prev_dist[from] - prev_dist[to]);\n        if (capacity[index] <= 0) { continue; }\n        if (ncost >= now_dist[to]) { continue; }\n        now_dist[to] = ncost;\n        que.push(Edge(i, from, to, 0, ncost));\n      }\n    }\n    if (parent[t].first == -1) { break; }\n    pair<int, int> index = parent[t];\n    Weight flow = 2000000000LL;\n    while (index.second != e) {\n      flow = min(flow, capacity[g[index.first][index.second].index]);\n      index = parent[index.first];\n    }\n    ret.first += flow;\n    index = parent[t];\n    while (index.second != e) {\n      Edge edge = g[index.first][index.second];\n      ret.second += flow * edge.cost;\n      capacity[edge.index] -= flow;\n      capacity[edge.index^1] += flow;\n      index = parent[index.first];\n    }\n    for (int i = 0; i < n; i++) {\n      prev_dist[i] += now_dist[i];\n    }\n  }\n  return ret;\n}\n\nvoid AddEdge(Graph &g, int &e, int from, int to, Weight capacity, Weight cost) {\n  g[from].push_back(Edge(e++, from, to, capacity, cost));\n  g[to].push_back(Edge(e++, to, from, 0, -cost));\n}\n\nint n, m, k;\nint w[10010];\nint seq[10010];\nint prev[10010];\n\nint main() {\n  while (scanf(\"%d %d %d\", &m, &n, &k) > 0) {\n    MEMSET(prev, -1);\n    REP(i, n) { scanf(\"%d\", &w[i]); }\n    REP(i, k) { scanf(\"%d\", &seq[i]); seq[i]--; }\n    int head = 0;\n    int p = -1;\n    REP(i, k) {\n      if (seq[i] != p) { seq[head++] = seq[i]; }\n      p = seq[i];\n    }\n    k = head;\n    Graph g(k + 1);\n    int e = 0;\n    int aint = 0;\n    REP(i, k) {\n      aint += w[seq[i]];\n      AddEdge(g, e, i, i + 1, m - 1, 0);\n      if (prev[seq[i]] != -1) {\n        AddEdge(g, e, prev[seq[i]] + 1, i, 1, -w[seq[i]]);\n      }\n      prev[seq[i]] = i;\n    }\n    int cost = MinCostFlow(g, e, 0, k).second;\n    printf(\"%d\\n\", aint + cost);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int CAPA_INF=1<<29;\nconst int COST_INF=1<<29;\n\ntemplate<class T,class U>\nstruct Edge{\n\tint v,rev;\n\tT capa;\n\tU cost;\n\tT flow;\n};\n\ntemplate<class T,class U>\nstruct AdjList:public vector< vector< Edge<T,U> > >{\n\tAdjList(int n):vector< vector< Edge<T,U> > >(n){}\n};\n\ntemplate<class T,class U>\nvoid add_edge(AdjList<T,U> &adj,int u,int v,T capa,U cost){\n\tadj[u].push_back((Edge<T,U>){v,adj[v].size()  ,capa, cost,0});\n\tadj[v].push_back((Edge<T,U>){u,adj[u].size()-1,   0,-cost,0});\n}\n\ntemplate<class T,class U>\npair<T,U> augment(AdjList<T,U> &adj,int s,int t,vector<U> &pot,bool first){\n\tint n=adj.size();\n\tvector<int> pre(n);\n\tvector<U> d(n,COST_INF); d[s]=0;\n\n\tif(first){\n\t\trep(u,n) rep(i,adj[u].size()) {\n\t\t\tEdge<T,U> &e=adj[u][i];\n\t\t\tif(e.capa-e.flow>0 && d[u]+e.cost<d[e.v]){\n\t\t\t\td[e.v]=d[u]+e.cost;\n\t\t\t\tpre[e.v]=e.rev;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\t// Dijkstra\n\t\tbool ok=false;\n\t\tpriority_queue< pair<U,int> > pq; pq.push(make_pair(0,s));\n\t\twhile(!pq.empty()){\n\t\t\tint u=pq.top().second;\n\t\t\tU cost=-pq.top().first; pq.pop();\n\n\t\t\tif(cost<d[u]) continue;\n\t\t\tif(u==t) ok=true;\n\n\t\t\trep(i,adj[u].size()){\n\t\t\t\tEdge<T,U> &e=adj[u][i];\n\t\t\t\tU cost2=cost+e.cost+pot[u]-pot[e.v];\n\t\t\t\tif(e.capa-e.flow>0 && cost2<d[e.v]){\n\t\t\t\t\td[e.v]=cost2;\n\t\t\t\t\tpre[e.v]=e.rev;\n\t\t\t\t\tpq.push(make_pair(-cost2,e.v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!ok) return make_pair(0,0);\n\t}\n\n\tT water=CAPA_INF;\n\tfor(int v=t;v!=s;){\n\t\tEdge<T,U> &e1=adj[v][pre[v]];\n\t\tEdge<T,U> &e2=adj[e1.v][e1.rev];\n\t\twater=min(water,e2.capa-e2.flow);\n\t\tv=e1.v;\n\t}\n\n\tU cost=0;\n\tfor(int v=t;v!=s;){\n\t\tEdge<T,U> &e1=adj[v][pre[v]];\n\t\tEdge<T,U> &e2=adj[e1.v][e1.rev];\n\t\te1.flow-=water;\n\t\te2.flow+=water;\n\t\tcost+=water*e2.cost;\n\t\tv=e1.v;\n\t}\n\n\trep(u,n) pot[u]+=d[u];\n\n\treturn make_pair(water,cost);\n}\n\ntemplate<class T,class U>\npair<T,U> primal_dual(AdjList<T,U> &adj,int s,int t){\n\tT ans1=0;\n\tU ans2=0;\n\tvector<U> pot(adj.size());\n\tfor(int i=0;;i++){\n\t\tpair<T,U> tmp=augment(adj,s,t,pot,i==0);\n\t\tif(tmp.first==0) break;\n\t\tans1+=tmp.first;\n\t\tans2+=tmp.second;\n\t}\n\treturn make_pair(ans1,ans2);\n}\n\nint main(){\n\tint m,n,k; scanf(\"%d%d%d\",&m,&n,&k);\n\tint w[10000];\n\trep(i,n) scanf(\"%d\",w+i);\n\n\tAdjList<int,int> adj(k+1);\n\n\tint wsum=0;\n\tint pre[10000];\n\trep(a,n) pre[a]=-1;\n\trep(i,k){\n\t\tint a; scanf(\"%d\",&a); a--;\n\t\tadd_edge(adj,i,i+1,i<k-1?CAPA_INF:m-1,0);\n\t\tif(~pre[a]){\n\t\t\tif(pre[a]+1<i) add_edge(adj,pre[a]+1,i,1,-w[a]);\n\t\t\telse           wsum-=w[a];\n\t\t}\n\t\tpre[a]=i;\n\t\twsum+=w[a];\n\t}\n\n\tprintf(\"%d\\n\",wsum+primal_dual(adj,0,k).second);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10000\ntypedef pair<int,int> P; //firstは最短距離、secondは頂点の番号\n\n//辺を表す構造体{行先、容量、コスト、逆辺のインデックス}\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nint N,M,K;\nint weight[NUM],ball_array[NUM];\nint index_table[NUM];\nvector<int> LOC[NUM];\n\n\nint V; //頂点数\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint h[NUM]; //ポテンシャル\nint dist[NUM]; //最短距離\nint pre_node[NUM],pre_edge[NUM]; //直前の頂点と辺\n\n//fromからtoへ向かう容量capacity,コストcostの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\n//sourceからsinkへの、流量flowの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)h[i] = 0; //ポテンシャルを0にする\n\twhile(flow > 0){\n\t\t//ダイクストラ法を用いてhを更新する\n\t\tpriority_queue<P,vector<P>,greater<P>> Q;\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tQ.push(P(0,source));\n\n\t\twhile(!Q.empty()){\n\t\t\tP p = Q.top();\n\t\t\tQ.pop();\n\t\t\tint node_id = p.second;\n\t\t\tif(dist[node_id] < p.first)continue; //最短でなければSKIP\n\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost+h[node_id]-h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost+h[node_id]-h[e.to];\n\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\tQ.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\t//これ以上流せない\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor(int node_id = 0; node_id < V; node_id++)h[node_id] += dist[node_id];\n\n\t\t//source-sink間最短路に沿って目いっぱい流す\n\t\tint tmp_flow = flow;\n\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*h[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\n\nint main(){\n\n\tscanf(\"%d %d %d\",&M,&N,&K);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d\",&weight[i]);\n\t}\n\n\tint ans = 0;\n\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d\",&ball_array[i]);\n\t\tball_array[i]--;\n\n\t\tLOC[ball_array[i]].push_back(i); //ボールを投入する必要のある時刻の配列\n\t\tans += weight[ball_array[i]];\n\t}\n\n\tint source = 0,sink = 1,index = 2;\n\t//時刻0～K-1に、ノード番号を割り当てる\n\tfor(int i = 0; i < K; i++){\n\t\tindex_table[i] = index++;\n\t}\n\n\tadd_edge(source,index_table[0],M,0);\n\n\t//時刻ノード同士を、十分大きな容量かつコスト0の辺で結ぶ\n\tfor(int i = 0; i < K-1; i++){\n\t\tadd_edge(index_table[i],index_table[i+1],M,0);\n\t}\n\n\tadd_edge(index_table[K-1],sink,M,0);\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tif(LOC[i].size() <= 1)continue; //入れない、または1回しか入れないボールは無視\n\n\t\tfor(int a = 0; a < LOC[i].size()-1; a++){\n\t\t\tif(LOC[i][a]+1 == LOC[i][a+1]){ //入れる時刻が連続している場合\n\t\t\t\tans -= weight[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tadd_edge(index_table[LOC[i][a]+1],index_table[LOC[i][a+1]],1,-weight[i]);\n\t\t}\n\t}\n\n\tV = index;\n\n\t//★★時刻→時刻に、必ず[今入れたばかりの球]が存在するので、区間の重なりはM-1まで★★\n\tans += min_cost_flow(source,sink,M-1);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef pair< int, int > P;\n\nstruct edge\n{\n  int to, cap, cost, rev;\n};\n\nconst int MAX_N = 1e4;\nconst int MAX_K = 1e4;\nconst int MAX_V = MAX_K;\nconst int INF = 1 << 29;\n\nint V;\nvector< edge > G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid init_G(int v)\n{\n  V = v;\n\n  for (int i = 0; i < V; i++)\n    G[i].clear();\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n  G[from].push_back((edge){to, cap, cost, G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, G[from].size() - 1});\n}\n\nint min_cost_flow(int s, int t, int f)\n{\n  int res = 0;\n  memset(h, 0, sizeof h);\n\n  while (f > 0)\n  {\n    priority_queue< P, vector< P >, greater< P > > que;\n\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while (!que.empty())\n    {\n      P p = que.top();\n      que.pop();\n\n      int v = p.second;\n\n      if (dist[v] < p.first)\n        continue;\n\n      for (int i = 0; i < (int)G[v].size(); i++)\n      {\n        edge &e = G[v][i];\n\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to])\n        {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n\n    if (dist[t] == INF)\n      return -1;\n\n    for (int v = 0; v < V; v++)\n      h[v] += dist[v];\n\n    int d = f;\n    for (int v = t; v != s; v = prevv[v])\n      d = min(d, G[prevv[v]][preve[v]].cap);\n\n    f -= d;\n    res += d * h[t];\n\n    for (int v = t; v != s; v = prevv[v])\n    {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n\n  return res;\n}\n\nint M, N, K;\nint w[MAX_N];\n// int a[MAX_K];\n\nvoid solve()\n{\n  int res = 0;\n  vector< int > B[N];\n\n  init_G(K);\n\n  for (int i = 0; i < K; i++)\n  {\n    int a;\n    scanf(\"%d\", &a);\n    a--;\n    B[a].push_back(i);\n    res += w[a];\n  }\n\n  for (int i = 0; i < N; i++)\n  {\n    for (int j = 0; j < (int)B[i].size() - 1; j++)\n    {\n      int n1 = B[i][j], n2 = B[i][j + 1];\n      if (n1 + 1 != n2)\n        add_edge(n1 + 1, n2, 1, -w[i]);\n      else\n        res -= w[i];\n    }\n  }\n\n  for (int i = 0; i < K - 1; i++)\n    add_edge(i, i + 1, M, 0);\n\n  printf(\"%d\\n\", res + min_cost_flow(0, K - 1, M - 1));\n\n  return;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &M, &N, &K);\n\n  for (int n = 0; n < N; n++)\n    scanf(\"%d\", w + n);\n\n  // for (int k = 0; k < K; k++)\n  // {\n  //   scanf(\"%d\", a + k);\n  //   a[k]--;\n  // }\n\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <vector>\n#include <queue>\n#include <stdio.h>\n#include <iterator>\n\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int INF = 10000000;\n\ntypedef pair<int, int>P;\nstruct edge {int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()} );\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h+V, 0);\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (dist[v] < p.first) continue;\n      for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if (dist[t] == INF) {\n      return -1;\n    }\n    for (int v = 0; v < V; v++) h[v] += dist[v];\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nconst int MAX_N = 100000;\nint M, N, K;\nint w[MAX_N];\nvector<int> a[MAX_N];\n\nint main(){\n  int all_res = 0;\n  scanf(\"%d %d %d\", &M, &N, &K);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; i++) {\n    int j = 0;\n    scanf(\"%d\", &j);\n    a[j-1].push_back(i);\n    all_res += w[j-1];\n  }\n\n  int s = K, t = s + 1;\n  V = t + 1;\n  int res = 0;\n  add_edge(s, 0, M-1, 0);\n  add_edge(K - 1, t, M-1, 0);\n  for (int i =0; i + 1 < K; i++) {\n    add_edge(i, i + 1, INF, 0);\n  }\n  int NE = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < (int)a[i].size()-1; j++) {\n      if(a[i][j+1]- a[i][j]-1==0) {\n        //res += w[i];\n      } else {\n        add_edge(a[i][j+1], a[i][j]+1, 1, w[i]);\n        add_edge(s, a[i][j+1], 1, 0);\n        add_edge(a[i][j]+1, t, 1, 0);\n        res -= w[i];\n        NE++;\n      }\n    }\n  }\n\n  res += min_cost_flow(s, t, M+NE-1);\n  printf(\"%d\\n\", all_res+res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tif (from < 0 || to < 0) return;\n\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\ntypedef pair<int, int> P;\n\nint dist[20000], h[20000] = {0}, prevV[20000], prevE[20000];\nint flow(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+20000, INF); dist[s] = 0;\n\t\tpriority_queue<P, vector<P>, greater<P> > Q; Q.push({0, s});\n\t\twhile ( !Q.empty() ) {\n\t\t\tP p = Q.top(); Q.pop();\n\t\t\tint v = p.second;\n\t\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\t\tEdge& e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[v]+e.cost+h[v]-h[e.to] < dist[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevV[e.to] = v;\n\t\t\t\t\tprevE[e.to] = i;\n\t\t\t\t\tQ.push({dist[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < G.size(); ++i) h[i] += dist[i];\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\texit(1);\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint M, N, K; cin >> M >> N >> K;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> w[i];\n\t}\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; ++i) {\n\t\tcin >> a[i]; --a[i];\n\t}\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tK = a.size();\n\n\tint t = 2*K, last = K;\n\tG.resize(t+1);\n\tvector<int> prev(N, -1);\n\tfor (int i = 0; i < K; ++i) {\n\t\taddEdge(i-1, i, INF, 0);\n\t\tif (prev[a[i]] > -1) {\n\t\t\taddEdge(prev[a[i]], last, 1, 0);\n\t\t\taddEdge(prev[a[i]]+1, last, 1, 0);\n\t\t\taddEdge(last, i, 1, -w[a[i]]);\n\t\t\t++last;\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n//\tfor (int i = 0; i < N; ++i) {\n//\t\taddEdge(prev[a[i]], t, 1, -w[a[i]]);\n//\t}\n//\taddEdge(K-1, t, INF, 0);\n\n\tint sum = 0;\n\tfor (int i = 0; i < K; ++i) {\n\t\tsum += w[a[i]];\n\t}\n\tcout << (sum + flow(0, K-1, M-1)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_M = 10;\nconst int MAX_N = 10000;\nconst int MAX_K = 10000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Edge {\n  int i, cap, cost;\n  Edge() {}\n  Edge(int _i, int _cap, int _cost): i(_i), cap(_cap), cost(_cost) {}\n};\n\ntypedef vector<Edge> ve;\n\n/* global variables */\n\nint wis[MAX_N], ajs[MAX_K], last[MAX_N];\nint dists[MAX_K], prvs[MAX_K];\nve nbrs[MAX_K];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int m, n, k;\n  cin >> m >> n >> k;\n\n  for (int i = 0; i < n; i++) cin >> wis[i], last[i] = -1;\n\n  int wsum = 0;\n  \n  for (int j = 0; j < k; j++) {\n    int aj;\n    cin >> aj;\n    aj--;\n    ajs[j] = aj;\n\n    if (j > 0)\n      nbrs[j - 1].push_back(Edge(j, m - 1, 0));\n    if (last[aj] >= 0)\n      nbrs[last[aj] + 1].push_back(Edge(j, 1, -wis[aj]));\n    last[aj] = j;\n\n    wsum += wis[aj];\n  }\n\n  int csum = 0;\n\n  for (; m > 1;) {\n    for (int i = 0; i < k; i++) dists[i] = INF;\n    dists[0] = 0;\n    prvs[0] = -1;\n\n    for (int ui = 0; ui < k; ui++) {\n      if (dists[ui] >= INF) continue;\n\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->cap > 0 && dists[vit->i] > dists[ui] + vit->cost) {\n\t  dists[vit->i] = dists[ui] + vit->cost;\n\t  prvs[vit->i] = ui;\n\t}\n    }\n\n    if (dists[k - 1] >= INF) break;\n    \n    for (int vi = k - 1; vi != 0;) {\n      int ui = prvs[vi];\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->i == vi) {\n\t  vit->cap--;\n\t  csum += vit->cost;\n\t  break;\n\t}\n      vi = ui;\n    }\n  }\n  \n  cout << (wsum + csum) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = long long;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // テヲツ慊嘉・ツ青妥ィツセツコ\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t テゥツ鳴禿ヲツ慊?ァツ淞ュティツキツッテ」ツ?ォテヲツイツソテ」ツ?」テ」ツ?ヲテァツ崢ョテ、ツクツ?ヲツ敖ッテヲツオツ?」ツ??\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// テヲツオツ?」ツつ古」ツ?淌」ツδ陛」ツδュテ」ツδシ=テ・ツ?ε」ツ??」ツ?ョテ・ツョツケテゥツ??テァツ渉セテ・ツ慊ィテ」ツ?ョテ・ツョツケテゥツ?湘」ツつ津ィツ。ツィテァツ、ツコ\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\ntypedef long long ll;\nll w[10000];\nvector<ll> id[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tid[a[i]].push_back(i);\n\t\tsum += w[a[i]];\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 100000, 0);\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < (int)id[i].size() - 1; j++) {\n\t\t\tif(id[i][j] + 1 != id[i][j + 1]) {\n\t\t\t\t//cout << id[i][j] + 1 + 1 << \" \" << id[i][j + 1] + 1 << \" \" << -w[i] << endl;\n\t\t\t\tpd.add_edge(id[i][j] + 1, id[i][j + 1], 1, -w[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define ALL(x) begin(x), end(x)\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntypedef int weight;\ntypedef pair<weight, int> P;\n\nstruct edge {\n\tint to;\n\tint cap;\n\tweight cost;\n\tint rev;\n\tedge(int to_, int cap_, weight cost_, int rev_):to(to_), cap(cap_), cost(cost_), rev(rev_){};\n};\n\nvector<vector<edge>> G;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n}\n\nvoid add_edge(int from, int to, int cap, weight cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\n\nweight min_cost_flow(int s, int t, weight f) {\n\tconst int n = G.size();\n\tweight res = 0;\n\tvector<int> prevv(n), preve(n);\n\tvector<weight> h(n, 0);\n\twhile(f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tvector<weight> dist(n, INT_MAX);\n\t\tdist[s] = 0;\n\t\tque.push({0, s});\n\t\twhile(!que.empty()) {\n\t\t\tconst auto d = que.top().first;\n\t\t\tconst auto v = que.top().second;\n\t\t\tque.pop();\n\n\t\t\tif(dist[v] < d) continue;\n\n\t\t\tfor(unsigned i = 0; i < G[v].size(); ++i) {\n\t\t\t\tconst edge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > d + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = d + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push({dist[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t] == INT_MAX) return -1;\n\n\t\tfor(int v = 0; v < n; ++v) {\n\t\t\th[v] += dist[v];\n\t\t}\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint m, n, k;\n\tcin >> m >> n >> k;\n\n\tvector<int> w(n);\n\tfor(auto &e : w) cin >> e;\n\n\tinit(k + 1);\n\n\tvector<int> prev(n, -1);\n\tint ans = 0;\n\n\trep(i, k) {\n\t\tint a;\n\t\tcin >> a;\n\t\t--a;\n\n\t\tans += w[a];\n\n\t\tadd_edge(i, i + 1, INT_MAX, 0);\n\t\tif(prev[a] != -1) {\n\t\t\tif(prev[a] + 1 == i) {\n\t\t\t\tans -= w[a];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tadd_edge(prev[a] + 1, i, 1, -w[a]);\n\t\t\t}\n\t\t}\n\t\tprev[a] = i;\n\t}\n\n\tcout << ans + min_cost_flow(0, k, m - 1) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n\nusing namespace std;\n\nstruct Edge{\n  int cap; // capacity\n  int to;\n  int rev; // reverse edge id\n\n  Edge(){}\n  Edge(int c, int t, int r) :\n    cap(c), to(t), rev(r){}\n};\n\nstruct CostEdge : public Edge{\n  int cost;\n  CostEdge() : Edge() {}\n  CostEdge(int c, int t, int cs, int r) :\n    Edge(c, t, r), cost(cs){}\n};\n  \ntemplate<class E> // Edge type\nclass Graph{\npublic:\n  typedef std::vector<std::vector<E> > G;\n\nprivate:\n  G g;\n\npublic:\n  Graph(int n) : g(G(n)) {}\n\n  void addEdge(int from, int to, int cap){\n    g[from].push_back(E(cap, to, g[to].size()));\n    g[to].push_back(E(0, from, g[from].size() - 1));\n  }\n\n  void addEdge(int from, int to, int cap, int cost){\n    g[from].push_back(E(cap, to, cost, g[to].size()));\n    g[to].push_back(E(0, from, -cost, g[from].size() - 1));\n  }\n\n  G &getRowGraph(){\n    return g;\n  }\n};\n\ntemplate<class E>\nint minCostFlow(Graph<E> &graph, int s, int t, int f){\n  typedef pair<int, int> P;\n  typename Graph<E>::G &g = graph.getRowGraph();\n  int n = g.size();\n  int res = 0;\n  vector<int> h(n, 0);\n  vector<int> prevv(n);\n  vector<int> preve(n);\n  const int inf = 10000000;\n\n  while(f > 0){\n    priority_queue<P, vector<P>, greater<P> > que;\n    vector<int> dist(n, inf);\n    dist[s] = 0;\n    que.push(P(0, s));\n\n    while(!que.empty()){\n      P p   = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < (int)g[v].size(); i++){\n\tE &e = g[v][i];\n\n\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t  dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];\n\t  prevv[e.to] = v;\n\t  preve[e.to] = i;\n\t  que.push(P(dist[e.to], e.to));\n\t}\n      }\n    }\n    if(dist[t] == inf){\n      return -1;\n    }\n\n    for(int v = 0; v < n; v++) h[v] += dist[v];\n\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, g[prevv[v]][preve[v]].cap);\n    }\n\n    f   -= d;\n    res += d * h[t];\n\n    for(int v = t; v != s; v = prevv[v]){\n      E &e = g[prevv[v]][preve[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m = getInt();\n  int n = getInt();\n  int k = getInt();\n\n  vector<int> w(n);\n  vector<int> a(k);\n\n  Graph<CostEdge> g(k);\n\n  REP(i,n) w[i] = getInt();\n  REP(i,k) a[i] = getInt() - 1;\n\n  int ans = 0;\n  REP(i,k) ans += w[a[i]];\n\n  vector<int> prevs(n, -1);\n\n  REP(i,k){\n    if(i != k - 1) g.addEdge(i, i + 1, 10000, 0);\n    int aa = a[i];\n    if(prevs[aa] != -1){\n      int j = prevs[aa];\n      if(j + 1 == i){\n\tans -= w[a[i]];\n      }else{\n\tg.addEdge(j + 1, i, 1, - w[a[i]]);\n      }\n    }\n    prevs[aa] = i;\n  }\n\n  ans += minCostFlow(g, 0, k - 1, m - 1);\n\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <utility>\n#define maxn 10005\n#define inf 0x3f3f3f3f\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint m,n,k,w[10005],lst[10005];\nvector <int> a;\nstruct edge{\n\tint to,cap,cst,rev;\n};\nvector <edge> adj[maxn];\nint dis[maxn],h[maxn];\nint V,prvv[maxn],prve[maxn];\nbool inque[maxn];\nvoid addedge(int u,int v,int c,int d){\n\tadj[u].push_back((edge){v,c,d,(int)adj[v].size()});\n\tadj[v].push_back((edge){u,0,-d,(int)adj[u].size() - 1});\n}\nint min_cost_flow(int s,int t,int f){\n\tmemset(h,0,sizeof(h));\n\tint res = 0;\n\tbool fir = true;\n\twhile(f > 0){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[s] = 0;\n\t\tif(fir){\n\t\t\tmemset(inque,0,sizeof(inque));\n\t\t\tqueue <int> que;\n\t\t\tque.push(s);\n\t\t\tinque[s] = true;\n\t\t\twhile(!que.empty()){\n\t\t\t\tint u = que.front();que.pop();\n\t\t\t\tinque[u] = false;\n\t\t\t\tfor(int i=0;i<adj[u].size();i++){\n\t\t\t\t\tedge &e = adj[u][i];\n\t\t\t\t\tif(e.cap && dis[u] + h[u] + e.cst - h[e.to] < dis[e.to]){\n\t\t\t\t\t\tdis[e.to] = dis[u] + h[u] + e.cst - h[e.to];\n\t\t\t\t\t\tprvv[e.to] = u;\n\t\t\t\t\t\tprve[e.to] = i;\n\t\t\t\t\t\tif(!inque[e.to]){\n\t\t\t\t\t\t\tque.push(e.to);\n\t\t\t\t\t\t\tinque[e.to] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfir = false;\n\t\t}else{\n\t\t\tpriority_queue <P,vector<P>,greater<P> > que;\n\t\t\tque.push(mp(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p = que.top();que.pop();\n\t\t\t\tint u = p.second;\n\t\t\t\tif(p.first != dis[u]) continue;\n\t\t\t\tfor(int i=0;i<adj[u].size();i++){\n\t\t\t\t\tedge &e = adj[u][i];\n\t\t\t\t\tif(e.cap && dis[u] + h[u] - h[e.to] + e.cst < dis[e.to]){\n\t\t\t\t\t\tdis[e.to] = dis[u] + h[u] - h[e.to] + e.cst;\n\t\t\t\t\t\tprvv[e.to] = u;\n\t\t\t\t\t\tprve[e.to] = i;\n\t\t\t\t\t\tque.push(mp(dis[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=V;i++) h[i] += dis[i];\n\t  if(h[t] >= inf) return -1;\n\t\tint flow = f;\n\t\tfor(int i=t;i!=s;i=prvv[i]){\n\t\t\tflow = min(flow,adj[prvv[i]][prve[i]].cap);\n\t\t}\n\t\tf -= flow;\n\t\tres += flow * h[t];\n\t\tfor(int i=t;i!=s;i=prvv[i]){\n\t\t\tedge &e = adj[prvv[i]][prve[i]];\n\t\t\te.cap -= flow;\n\t\t\tadj[e.to][e.rev].cap += flow;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tmemset(lst,-1,sizeof(lst));\n\tscanf(\"%d%d%d\",&m,&n,&k);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n\tfor(int i=1;i<=k;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\ta.push_back(x);\n\t}\n\tint sum = 0;\n\ta.erase(unique(a.begin(),a.end()),a.end());\n\tk = a.size();\n\tfor(int i=0;i<k-1;i++){\n\t\taddedge(i,i+1,m,0);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tsum += w[a[i]];\n\t\tif(lst[a[i]] != -1) addedge(lst[a[i]],i-1,1,-w[a[i]]);\n\t\tlst[a[i]] = i;\n\t}\n\tV = k-1;\n\tprintf(\"%d\\n\",sum + min_cost_flow(0,k-1,m-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2266: Cache Strategy\n * ?¢??????????n????????????????????????m????????????????????????????????????????????????????????§?????????????°????????????¨?????????????????\\?????\\???????????\\??????????????????????????±?´???°?????°??????????????\\?????¢????±?????°??????±?´????\n * ?±???????????°??´?\n * ??????????°??????\\???????????????????????±???????????????????¬?????????¢???????????±?´??????°???????????????????????¨???????????????????????????????????´??????????????????????????´???????????¨???????????????????????±?´????????????\\????????????????????¶????°??????°?????´???????????????????????????1??±?´??´?????????????????????¨?????????INF??±?´?0???????°???´??????????????\\????±?????°??´???¨??????????????\\??????????????§??????????????°??????????¢??????????????§?????????????????????????\n */\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\n\nint a[10010], w[10010];\nint pre[10010];\n\nstruct Edge {\n  Edge() {}\n\n  Edge(int _v, int _cap, int _cost, int _rev) : v(_v), cap(_cap), cost(_cost), rev(_rev) {}\n\n  int v, cap, cost, rev;\n};\n\nvector<Edge> e[10010];\nint n;\nint h[10010], d[10010];\nint pv[10010], pe[10010];\npriority_queue<pii, vector<pii>, greater<pii> > pq;\n\nvoid AddEdge(int u, int v, int cap, int cost) {\n  e[u].push_back(Edge(v, cap, cost, e[v].size()));\n  e[v].push_back(Edge(u, 0, -cost, e[u].size() - 1));\n}\n\nint MinCostFlow(int s, int t, int f) {\n  int ans = 0;\n  memset(h, 0, sizeof(h));\n  while (f > 0) {\n    memset(d, 0x3f, sizeof(d));\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n    while (!pq.empty()) {\n      int u = pq.top().second;\n      int pre = pq.top().first;\n      pq.pop();\n      if (d[u] < pre) continue;\n      for (int i = 0; i < e[u].size(); ++i) {\n        Edge &te = e[u][i];\n        int v = te.v;\n        if (te.cap > 0 && d[v] > d[u] + h[u] - h[v] + te.cost) {\n          d[v] = d[u] + h[u] - h[v] + te.cost;\n          pv[v] = u;\n          pe[v] = i;\n          pq.push(make_pair(d[v], v));\n        }\n      }\n    }\n\n    if (d[t] == INF) {\n      return -1;\n    }\n    for (int i = 0; i < n; ++i) {\n      h[i] += d[i];\n    }\n\n    int cur = f;\n    for (int i = t; i != s; i = pv[i]) {\n      cur = min(cur, e[pv[i]][pe[i]].cap);\n    }\n    ans += cur * h[t];\n    f -= cur;\n    for (int i = t; i != s; i = pv[i]) {\n      Edge &te = e[pv[i]][pe[i]];\n      te.cap -= cur;\n      e[i][te.rev].cap += cur;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  int M, N, K, ans = 0;\n  scanf(\"%d%d%d\", &M, &N, &K);\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; ++i) {\n    scanf(\"%d\", &a[i]);\n    --a[i];\n  }\n  K = unique(a, a + K) - a;\n\n  memset(pre, -1, sizeof(pre));\n  for (int i = 0; i < K; ++i) {\n    ans += w[a[i]];\n    if (pre[a[i]] != -1) {\n      AddEdge(pre[a[i]], i - 1, 1, -w[a[i]]);\n    }\n    pre[a[i]] = i;\n  }\n  for (int i = 1; i < K; ++i) {\n    AddEdge(i - 1, i, M - 1, 0);\n  }\n  n = K;\n  ans += MinCostFlow(0, n - 1, M - 1);\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\nconst int MAX_V = 10010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nvector<Edge> g[MAX_V];\n\nstruct PrimalDual {\n\tint n;\n\tPrimalDual(int n_) : n(n_) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 100000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tpd.add_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\ntypedef int weight;\ntypedef pair<weight, int> P;\nconst weight INF = (1 << 27);\n\nstruct edge {\n\tint to;\n\tint cap;\n\tweight cost;\n\tint rev;\n\tedge(int to_, int cap_, weight cost_, int rev_) :to(to_), cap(cap_), cost(cost_), rev(rev_) {};\n};\n\nvector<vector<edge>> G;\n\nvoid init(int V) {\n\tG.assign(V, vector<edge>());\n}\n\nvoid add_edge(int from, int to, int cap, weight cost) {\n\tG[from].emplace_back(to, cap, cost, G[to].size());\n\tG[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\n\nweight min_cost_flow(int s, int t, weight f) {\n\tconst int n = G.size();\n\tweight res = 0;\n\tvector<int> prevv(n), preve(n);\n\tvector<weight> h(n);\n\tvector<weight> dist(n);\n\twhile(f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tdist[s] = 0;\n\t\tq.push(P(0, s));\n\t\twhile(q.size()) {\n\t\t\tP p = q.top();\n\t\t\tq.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v] < p.first) continue;\n\t\t\tfor(int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge& e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tq.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tif(dist[t] == INF) return -1;\n\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tinit(K);\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tadd_edge(i, i + 1, 1000000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tadd_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\n\tll res = min_cost_flow(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M,V,K;\nconst int MAX_N = 10000,MAX_V = 30017;\nvector<int> A,W;\nvector<int> ball [MAX_N];\nstruct edge{\n\tint to,cap,rev;\n\tll cost;\n};\nvector<edge> G [MAX_V];\nll h [MAX_V],minCost [MAX_V];\nint prevv [MAX_V],preve [MAX_V];\nconst ll INF = 1e9,INFLL = 1e18;\n\ninline void add_edge(int from,int to,int cap,ll cost)\n{\n\tG [from].push_back(edge{to,cap,int(G [to].size()),cost});\n\tG [to].push_back(edge{from,0,int(G [from].size()) - 1,-cost});\n}\n\nll min_cost_flow(int s,int t,int f)\n{\n\tll res = 0;\n\tmemset(h,0,sizeof(h));\n\twhile(f > 0){\n\t\tfill(minCost,minCost + MAX_V,INFLL);\n\t\tpriority_queue< pair<ll,int>,vector< pair<ll,int> >,greater< pair<ll,int> > > pq;\n\t\tminCost [s] = 0;\n\t\tpq.push(make_pair(0ll,s));\n\t\twhile(pq.empty() == false){\n\t\t\tll cost = pq.top().first;\n\t\t\tint curr = pq.top().second;\n\t\t\tpq.pop();\n\n\t\t\tif(minCost [curr] < cost) continue;\n\t\t\tFOR(i,0,G [curr].size()){\n\t\t\t\tedge& e = G [curr] [i];\n\t\t\t\tif(e.cap > 0 && chmin(minCost [e.to],cost + e.cost + h [curr] - h [e.to])){\n\t\t\t\t\tprevv [e.to] = curr;\n\t\t\t\t\tpreve [e.to] = i;\n\t\t\t\t\tpq.push(make_pair(minCost [e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost [t] >= INFLL) return -1;\n\t\tFOR(i,0,V) h [i] += minCost [i];\n\t\tint d = f;\n\t\tfor(int v = t;v != s;v = prevv [v]){\n\t\t\tchmin(d,G [prevv [v]] [preve [v]].cap);\n\t\t}\n\t\tres += h [t] * d;\n\t\tf -= d;\n\t\tfor(int v = t;v != s;v = prevv [v]){\n\t\t\tedge& e = G [prevv [v]] [preve [v]];\n\t\t\te.cap -= d;\n\t\t\tG [e.to] [e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tW.assign(N,0);\n\tA.assign(K,0);\n\tFOR(i,0,N){\n\t\tscanf(\"%d\",&W [i]);\n\t}\n\tFOR(i,0,K){\n\t\tscanf(\"%d\",&A [i]);\n\t\tA [i]--;\n\t\tball [A [i]].push_back(i);\n\t}\n\n\tV = K * 3 + 2;\n\tint s = K * 3,t = K * 3 + 1;\n\tadd_edge(s,0,INF,0);\n\tadd_edge(K - 1,t,INF,INF);\n\tadd_edge(K * 3 - 1,t,1,0);\n\tFOR(i,0,K){\n\t\tadd_edge(i,i + K,1,W [A [i]]);\n\t\tadd_edge(i + K,i + K * 2,1,0);\n\t\tif(i + 1 < K){\n\t\t\tadd_edge(i,i + 1,INF,INF);\n\t\t\tadd_edge(i + K * 2,i + 1,1,0);\n\t\t}\n\t}\n\tFOR(i,0,N) FOR(j,1,ball [i].size()){\n\t\tint x = ball [i] [j - 1],y = ball [i] [j];\n\t\tadd_edge(x + K * 2,y + K,1,(y - x - 1) * INF);\n\t}\n\n\tll ans = min_cost_flow(s,t,M) - INF * (M - 1) * K;\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define min(a,b)    (((a) < (b)) ? (a) : (b))\n#define max(a,b)    (((a) > (b)) ? (a) : (b))\n#define abs(x)    ((x) < 0 ? -(x) : (x))\n#define INF 0x3f3f3f3f\n#define delta 0.85\n#define eps 1e-10\n#define PI 3.14159265358979323846\nusing namespace std;\n\n#define MAX_V 10005\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(int to, int cap, int cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\nbool inq[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\tmemset(h, 0, sizeof(h));\n\t// Spfa\n\tmemset(inq, 0, sizeof(inq));\n\tmemset(dist, 0x3f, sizeof(dist));\n\tqueue<int> q;\n\tdist[s] = 0;\n\tq.push(s);\n\tinq[s] = 1;\n\twhile(!q.empty()){\n\t\tint v = q.front(); q.pop();\n\t\tinq[v] = 0;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tint d2 = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\tif(e.cap > 0 && dist[e.to] > d2){\n\t\t\t\tdist[e.to] = d2;\n\t\t\t\tif(!inq[e.to]){\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t\tinq[e.to] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int v = 0; v < V; v++) h[v] += dist[v];\n\t\n\twhile(f > 0){\n\t\t// Dijkstra\n\t\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n\t\tmemset(dist, 0x3f, sizeof(dist));\n\t\tdist[s] = 0;\n\t\tque.push(pair<int, int>(0, s));\n\t\twhile(!que.empty()){\n\t\t\tpair<int, int> p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v] < p.first) continue;\n\t\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tint d2 = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\tif(e.cap > 0 && d2 < dist[e.to]){\n\t\t\t\t\tdist[e.to] = d2;\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(pair<int, int>(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v = 0; v < V; v++) h[v] += dist[v];\n\t\tint d = f;\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor(int v = t; v != s; v = prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid clear_graph(){\n\tfor(int v = 0; v < V; v++) G[v].clear();\n}\n\n#define MAX_K 10000\n#define MAX_N 10000\nint M, N, K;\nint w[MAX_N];\nint a[MAX_K], pre[MAX_K];\n\nvoid solve(){\n\tint res = 0;\n\tmemset(pre, -1, sizeof(pre));\n\tint na = unique(a, a + K) - a;\n\t\n\tint s = na, t = s + 1;\n\tV = t + 1;\n\tclear_graph();\n\t\n\tadd_edge(s, 0, M - 1, 0);\n\tadd_edge(na - 1, t, M - 1, 0);\n\tfor(int i = 0; i < na - 1; i++){\n\t\tadd_edge(i, i + 1, INF, 0);\n\t}\n\tint cnt = 0;\n\tfor(int i = 0; i < na; i++){\n\t\tif(pre[a[i]] != -1){\n\t\t\tadd_edge(pre[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tpre[a[i]] = i;\n\t}\n\t\n\tfor(int i = 0; i < na; i++) res += w[a[i]];\n\tres += min_cost_flow(s, t, M - 1);\n\tprintf(\"%d\\n\", res);\n}\n\nint main(){\n\twhile(~scanf(\"%d%d%d\", &M, &N, &K)){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tscanf(\"%d\", w + i);\n\t\t}\n\t\tfor(int i = 0; i < K; i++){\n\t\t\tscanf(\"%d\", a + i);\n\t\t\t--a[i];\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tvector<int> top;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfill(h, h + n, 0);\n\t\tassert(top.size() == n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint v = top[i];\n\t\t\tfor(Edge& e : g[v]) {\n\t\t\t\tif(e.cap == 0) continue;\n\t\t\t\tint u = e.dst;\n\t\t\t\th[u] = min(h[u], h[v] + e.cost);\n\t\t\t}\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tPrimalDual pd(K);\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 1000000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tpd.add_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\tfor(int i = 0; i < K; i++) {\n\t\t//pd.top.push_back(i);\n\t}\n\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef long long int64;\n\nconst int MAX_N = 10000;\nconst int MAX_K = 10000;\nconst int MAX_V = MAX_K + 2;\nconst int INF = 1<<29;\nconst int INF2 = 10000;\n\nint M, N, K;\nint ws[MAX_N];\nvector<int> as;\nvector<int> ts[MAX_N];\n\ntypedef pair<int, int> P;\nstruct edge{ int to, cap, cost, rev; };\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n\tG[from].push_back((edge){to,cap,cost,G[to].size()});\n\tG[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n\tint res = 0;\n\tfill(h, h+V, 0);\n\twhile(f > 0){\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist+V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v] < p.first) continue;\n\t\t\tfor(int i=0; i<G[v].size(); i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v = 0; v<V; v++) h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor(int v=t; v != s; v = prevv[v]){\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor(int v=t; v!=s; v=prevv[v]){\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint solve(){\n\tint tot = 0, cnt = 0, sub = 0;\n\n\tfor(int i=0; i<K; i++){\n\t\tts[as[i]].push_back(i);\n\t}\n\n\tV = K;\n\n\tfor(int i=0; i+1<K; i++){\n\t\tadd_edge(i, i+1, INF, INF2);\n\t}\n\n\tfor(int i=0; i<N; i++){\n\t\ttot += ws[i] * ts[i].size();\n\t\tfor(int j=0; j+1 < (int)ts[i].size(); j++){\n\t\t\tadd_edge(ts[i][j]+1, ts[i][j+1], 1, INF2 * (ts[i][j+1] - (ts[i][j] + 1)) - ws[i]);\n\t\t}\n\t}\n\n\treturn tot + ( min_cost_flow(0, K-1, M-1) -  (M - 1) * (K - 1) * INF2 );\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&M,&N,&K);\n\tfor(int i=0; i<N; i++){\n\t\tscanf(\"%d\", ws+i);\n\t}\n\tfor(int i=0; i<K; i++){\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tas.push_back(x - 1);\n\t}\n\n\tas.erase(unique(as.begin(), as.end()), as.end());\n\tK = as.size();\n\n\tprintf(\"%d\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pii pair<int, int>\n\nconst int maxn = 1e4 + 5;\nconst int inf = 0x3f3f3f3f;\n\nstruct edge {\n    int to, cap, cost, rev;\n};\nint n, m, res, f, N, k;\nvector<edge> g[maxn];\nint h[maxn], dis[maxn], prevv[maxn], preve[maxn], vis[maxn];\n\ninline void add_edge(int from, int to, int cap, int cost) {\n    // printf(\"%d %d %d %d\\n\", from, to, cap, cost);\n    g[from].emplace_back(edge{to, cap, cost, (int)g[to].size()});\n    g[to].emplace_back(edge{from, 0, -cost, (int)g[from].size() - 1});\n}\n\nvoid min_cost_flow(int s, int t, int F) {\n    fill(h, h + N, 0);\n    while (f < F) {\n        queue<int> que;\n        fill(dis, dis + N, inf);\n        memset(vis, 0, sizeof(vis));\n        dis[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            vis[v] = 0;\n            for (int i = 0; i < (int)g[v].size(); i++) {\n                edge &e = g[v][i];\n                if (e.cap > 0 && dis[e.to] > dis[v] + e.cost + h[v] - h[e.to]) {\n                    dis[e.to] = dis[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    if (!vis[e.to]) {\n                        que.push(e.to);\n                        vis[e.to] = 1;\n                    }\n                }\n            }\n        }\n        if (dis[t] == inf) break;\n        for (int i = 0; i < N; i++) h[i] += dis[i];\n        int d = F - f;\n        for (int v = t; v != s; v = prevv[v])\n            d = min(d, g[prevv[v]][preve[v]].cap);\n        f += d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n}\n\nint val[maxn], a[maxn], pos[maxn];\n\ninline int read() {\n    int x = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n    return f * x;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &m, &n, &k);\n    for (int i = 1; i <= n; i++) val[i] = read();\n    for (int i = 1; i <= k; i++) a[i] = read();\n    if (m == 1) {\n        for (int i = 1; i <= k; i++) {\n            if (a[i] != a[i - 1]) res += val[a[i]];\n        }\n        printf(\"%d\\n\", res);\n        return 0;\n    }\n    N = k + 2;\n    add_edge(0, 1, m - 1, 0);\n    add_edge(k, N - 1, m - 1, 0);\n    for (int i = 1; i <= k; i++) {\n        if (i < k) add_edge(i, i + 1, inf, 0);\n        if (pos[a[i]]) {\n            if(pos[a[i]] < i - 1) add_edge(pos[a[i]], i - 1, 1, -val[a[i]]);\n            else res -= val[a[i]];\n        }\n        pos[a[i]] = i;\n        res += val[a[i]];\n    }\n    min_cost_flow(0, N - 1, m - 1);\n    printf(\"%d\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\nconst int MAX_V = 10010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nvector<Edge> g[MAX_V];\n\nstruct PrimalDual {\n\tint n;\n\tPrimalDual(int n_) : n(n_) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\ntypedef long long ll;\nll w[10000];\nint a[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tcin >> a[i];\n\t\ta[i]--;\n\t\tif(i > 0 && a[i - 1] == a[i]) continue;\n\t\tsum += w[a[i]];\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 100000, 0);\n\t}\n\tvector<int> prev(N, -1);\n\tfor(int i = 0; i < K; i++) {\n\t\tif(prev[a[i]] != -1 && prev[a[i]] + 1 != i) {\n\t\t\tpd.add_edge(prev[a[i]] + 1, i, 1, -w[a[i]]);\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nint cost[max_k][max_k];\nint back_cost[max_k][max_k];\nint nbr[max_k][max_k];\nint num_nbr[max_k];\n\nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n\nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n\n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(appear[i]).size()-1;j++){\n      next[i] = appear[i][j+1];\n    }\n  }\n\n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n\n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      for(j=MAX(i+1,initial);j<nxt;j++){        \n        nbr[i][(num_nbr[i])++] = j;\n        cost[i][j] = w[i];\n      }\n      nbr[i][(num_nbr[i])++] = nxt;\n      cost[i][nxt] = 0;\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i][(num_nbr[i])++] = j;\n        cost[i][j] = 0;\n      }\n    }\n  }\n}\n\nint min_cost(){\n  static int h[max_k+1];\n  static int dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n  \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n  \n  memset(h,0,(K+1)*sizeof(int));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n  \n  while(1){\n    fill(dist,dist+K+1,INT_MAX);\n    for(i = 0;i<K-M;i++){\n      if(prev[i] != -1) continue;\n      dist[i] = 0;\n      que.push(P(0,i));\n    }\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == v) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][v] + (-cost[w][v]) + (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][v] + (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    if(dist[t] == INT_MAX) return res;\n    for(i = 0;i < K-M;i++) h[i] += dist[i];\n    h[t] += dist[t];\n    \n    for(v=prev_mid[t],u=prev[t];true;v=prev_mid[u],u=prev[u]){\n      flow[u] = v;\n      used[v] = u;\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n}\n\nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_M = 10;\nconst int MAX_N = 10000;\nconst int MAX_K = 10000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Edge {\n  int i, cap, cost;\n  Edge() {}\n  Edge(int _i, int _cap, int _cost): i(_i), cap(_cap), cost(_cost) {}\n};\n\ntypedef vector<Edge> ve;\n\n/* global variables */\n\nint wis[MAX_N], ajs[MAX_K], last[MAX_N];\nint dists[MAX_K], prvs[MAX_K];\nve nbrs[MAX_K];\nbool used[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int m, n, k;\n  cin >> m >> n >> k;\n\n  for (int i = 0; i < n; i++)\n    cin >> wis[i], last[i] = -1, used[i] = false;\n\n  int wsum = 0, nused = 0;\n  \n  for (int j = 0; j < k; j++) {\n    int aj;\n    cin >> aj;\n    aj--;\n    ajs[j] = aj;\n\n    if (j > 0)\n      nbrs[j - 1].push_back(Edge(j, m - 1, 0));\n    if (last[aj] >= 0)\n      nbrs[last[aj] + 1].push_back(Edge(j, 1, -wis[aj]));\n    last[aj] = j;\n\n    wsum += wis[aj];\n\n    if (! used[aj]) {\n      used[aj] = true;\n      nused++;\n    }\n  }\n\n  int csum = 0;\n\n  if (nused <= m) {\n    for (int i = 0; i < n; i++)\n      if (used[i]) csum += wis[i];\n    cout << csum << endl;\n    return 0;\n  }\n\n  if (m == 1) {\n    int p = -1;\n    for (int j = 0; j < k; j++) {\n      if (p != ajs[j]) csum += wis[ajs[j]];\n      p = ajs[j];\n    }\n    cout << csum << endl;\n    return 0;\n  }\n  \n  for (;;) {\n    for (int i = 0; i < k; i++) dists[i] = INF;\n    dists[0] = 0;\n    prvs[0] = -1;\n\n    for (int ui = 0; ui < k; ui++) {\n      if (dists[ui] >= INF) continue;\n\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->cap > 0 && dists[vit->i] > dists[ui] + vit->cost) {\n\t  dists[vit->i] = dists[ui] + vit->cost;\n\t  prvs[vit->i] = ui;\n\t}\n    }\n\n    if (dists[k - 1] >= INF) break;\n    \n    for (int vi = k - 1; vi != 0;) {\n      int ui = prvs[vi];\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->i == vi) {\n\t  vit->cap--;\n\t  csum += vit->cost;\n\t  break;\n\t}\n      vi = ui;\n    }\n  }\n  \n  cout << (wsum + csum) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_M = 10;\nconst int MAX_N = 10000;\nconst int MAX_K = 10000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\nstruct Edge {\n  int i, cap, cost;\n  Edge() {}\n  Edge(int _i, int _cap, int _cost): i(_i), cap(_cap), cost(_cost) {}\n};\n\ntypedef vector<Edge> ve;\n\n/* global variables */\n\nint wis[MAX_N], ajs[MAX_K], last[MAX_N];\nint dists[MAX_K], prvs[MAX_K];\nve nbrs[MAX_K];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int m, n, k;\n  cin >> m >> n >> k;\n\n  for (int i = 0; i < n; i++) cin >> wis[i], last[i] = -1;\n\n  int wsum = 0;\n  \n  for (int j = 0; j < k; j++) {\n    int aj;\n    cin >> aj;\n    aj--;\n    ajs[j] = aj;\n\n    if (j > 0)\n      nbrs[j - 1].push_back(Edge(j, m - 1, 0));\n    if (last[aj] >= 0)\n      nbrs[last[aj] + 1].push_back(Edge(j, 1, -wis[aj]));\n    last[aj] = j;\n\n    wsum += wis[aj];\n  }\n\n  int csum = 0;\n\n  for (; k > 1;) {\n    for (int i = 0; i < k; i++) dists[i] = INF;\n    dists[0] = 0;\n    prvs[0] = -1;\n\n    for (int ui = 0; ui < k; ui++) {\n      if (dists[ui] >= INF) continue;\n\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->cap > 0 && dists[vit->i] > dists[ui] + vit->cost) {\n\t  dists[vit->i] = dists[ui] + vit->cost;\n\t  prvs[vit->i] = ui;\n\t}\n    }\n\n    if (dists[k - 1] >= INF) break;\n    \n    for (int vi = k - 1; vi != 0;) {\n      int ui = prvs[vi];\n      ve& nbru = nbrs[ui];\n      for (ve::iterator vit = nbru.begin(); vit != nbru.end(); vit++)\n\tif (vit->i == vi) {\n\t  vit->cap--;\n\t  csum += vit->cost;\n\t  break;\n\t}\n      vi = ui;\n    }\n  }\n  \n  cout << (wsum + csum) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <vector>\n#include <queue>\n#include <array>\n#include <stdio.h>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 10000000;\nconst int Big_M = 100000;\n\ntypedef pair<int, int>P;\nstruct edge {int to, cap, cost, rev;};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost) {\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()} );\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1 });\n}\n\nint min_cost_flow(int s, int t, int f) {\n  int res = 0;\n  fill(h, h+V, 0);\n  while (f > 0) {\n    priority_queue<P, vector<P>, greater<P> > que;\n    fill(dist, dist + V, INF);\n    dist[s] = 0;\n    que.push(P(0, s));\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (dist[v] < p.first) continue;\n      for (int i = 0; i < (int)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to], e.to));\n        }\n      }\n    }\n    if (dist[t] == INF) {\n      return -1;\n    }\n    for (int v = 0; v < V; v++) h[v] += dist[v];\n    int d = f;\n    for (int v = t; v != s; v = prevv[v]) {\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d * h[t];\n    for (int v = t; v != s; v = prevv[v]) {\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nconst int MAX_N = 10;\nint M, N, K;\nint w[MAX_N];\nvector<int> a[MAX_N];\n\nint main(){\n  int all_res = 0;\n  scanf(\"%d %d %d\", &M, &N, &K);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; i++) {\n    int j = 0;\n    scanf(\"%d\", &j);\n    a[j-1].push_back(i);\n    all_res += w[j-1];\n  }\n\n  int s = 2*K, t = s + 1;\n  V = t + 1;\n  int res = 0;\n  add_edge(s, 0, M, 0);\n  add_edge(2*K - 1, t, M, 0);\n  for (int i =0; i + 1 < K; i++) {\n    add_edge(i+K, i + 1, INF, 0);\n  }\n  int NE = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < (int)a[i].size()-1; j++) {\n      add_edge(a[i][j+1], a[i][j]+K, 1, w[i]);\n      add_edge(s, a[i][j+1], 1, 0);\n      add_edge(a[i][j]+K, t, 1, 0);\n      res -= w[i];\n      NE++;\n    }\n  }\n\n  for (int i =0; i < K; i++) {\n    add_edge(i, i+K, INF, 0);\n    add_edge(i+K, i, 1, Big_M);\n    add_edge(s, i+K, 1, 0);\n    add_edge(i, t, 1, 0);\n  }\n\n  res += min_cost_flow(s, t, M+NE+K);\n  printf(\"%d\\n\", all_res+res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF=1e9;\nconst ll MAX=10001;\nstruct edge{\n    int to, cap, rev; ll cost;\n};\n \nint V;\nvector<edge> g[20002];\nll h[20002];\nll dist[20002];\nint prevv[20002], preve[20002];\n \nvoid add_edge(int from, int to, int cap, ll cost){\n    edge e;\n    e.to=to, e.cap=cap, e.cost=cost, e.rev=g[to].size();\n    g[from].push_back(e);\n    e.to=from, e.cap=0, e.cost=-cost, e.rev=g[from].size()-1;\n    g[to].push_back(e);\n}\n   \nll min_cost_flow(int s, int t, int f){\n    ll res=0;\n    fill(h, h+V, 0);\n    while(f>0){\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(dist, dist+V, INF);\n        dist[s]=0;\n        que.push(P(0, s));\n        while(!que.empty()){\n            P p=que.top(); que.pop();\n            int v=p.second;\n            if(dist[v]<p.first) continue;\n            for(int i=0; i<g[v].size(); i++){\n                edge &e=g[v][i];\n                if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        for(int v=0; v<V; v++) h[v]+=dist[v];\n        if(dist[t]==INF) return -1;\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]){\n            d=min(d, g[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*h[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e=g[prevv[v]][preve[v]];\n            e.cap-=d;\n            g[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n \nint main()\n{\n    int m, n, k; cin>>m>>n>>k;\n    vector<int> t[10001];\n    int w[10001];\n    for(int i=0; i<n; i++) cin>>w[i];\n    int ans=0;\n    for(int i=0; i<k; i++){\n        int a; cin>>a;\n        ans+=w[a-1];\n        t[a-1].push_back(i);\n    }\n    V=k;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<(int)t[i].size()-1; j++){\n            if(t[i][j]+1==t[i][j+1]){\n                ans-=w[i];\n            }else{\n                add_edge(t[i][j]+1, t[i][j+1], 1, MAX*(t[i][j+1]-t[i][j]-1)-w[i]);\n            }\n        }\n    }\n    for(int i=0; i<k-1; i++) add_edge(i, i+1, INF, MAX);\n    ans+=(min_cost_flow(0, k-1, m-1)-(m-1)*MAX*(k-1));\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\ntypedef int Weight;\nconst Weight INF=1<<29;\nstruct Edge{\n\tint src,dst;\n\tWeight weight,cap; // weight が辺のコストを表す\n\tint rev; // 逆辺の番号\n\tEdge(int src,int dst,Weight weight=0,Weight cap=0,int rev=-1):\n\tsrc(src),dst(dst),weight(weight),cap(cap),rev(rev)\n\t{}\n};\nstruct Node:public vector<Edge>{};\nbool operator<(const Edge &a,const Edge &b){\n\treturn a.weight<b.weight;\n}\nbool operator>(const Edge &a,const Edge &b){return b<a;}\ntypedef vector<Node> Graph;\ntypedef vector<vector<Weight> > Matrix;\n\n//src から dst へ向かう容量 cap,コストcost の辺をグラフに追加する\nvoid add_edge(Graph &G,int src,int dst,Weight cap,Weight cost){\n\tG[src].push_back(Edge(src,dst,cost,cap,G[dst].size()));\n\tG[dst].push_back(Edge(dst,src,-cost,0,G[src].size()-1));\n}\n\nWeight min_cost_flow(Graph &G,int s,int t,Weight f){\n\ttypedef pair<Weight,int> P;\n\tWeight res=0;\n\tint V=G.size();\n\tvector<Weight> h(V,0);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\tif(s==t)return 0;\n\tbool start=true;\n\twhile(f>0){\n\t\tvector<Weight> dist(V,INF);\n\t\tif(start){\n\t\t\tbool update=true;\n\t\t\tdist[s]=0;\n\t\t\twhile(update){\n\t\t\t\tupdate=false;\n\t\t\t\tREP(v,V){\n\t\t\t\t\tif(dist[v]==INF)continue;\n\t\t\t\t\tREP(i,G[v].size()){\n\t\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight){\n\t\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight;\n\t\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\t\tupdate=true;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstart=0;\n\t\t}else{\n\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\tdist[s]=0;\n\t\t\tque.push(P(0,s));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.top();que.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<p.first)continue;\n\t\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\t\tEdge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.dst]>dist[v]+e.weight+h[v]-h[e.dst]){\n\t\t\t\t\t\tdist[e.dst]=dist[v]+e.weight+h[v]-h[e.dst];\n\t\t\t\t\t\tprevv[e.dst]=v;\n\t\t\t\t\t\tpreve[e.dst]=i;\n\t\t\t\t\t\tque.push(P(dist[e.dst],e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF){\n\t\t\treturn -1;\n\t\t}\n\t\tfor(int v=0;v<V;v++)h[v]+=dist[v];\n\t\tWeight d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tEdge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint M, N, K;\n\nmain(){\n\tios::sync_with_stdio(false);\n\tcin >> M >> N >> K;\n\tvi w(N), a(K);\n\tREP(i, N){\n\t\tcin >> w[i];\n\t}\n\tint res = 0;\n\tREP(i, K){\n\t\tcin >> a[i]; a[i]--;\n\t}\n\tUNIQUE(a);\n\tK = a.size();\n\tREP(i, K) res += w[a[i]];\n\tGraph g(K+2);\n\tREP(i, K-1) add_edge(g, i, i+1, INF, 0);\n\tadd_edge(g, K, 0, M-1, 0);\n\tadd_edge(g, K-1, K+1, M-1, 0);\n\tvi prev(N, -1);\n\tint minus = 0;\n\tREP(i, K){\n\t\tif(prev[a[i]] != -1){\n\t\t\tconst int u = prev[a[i]]+1;\n\t\t\tconst int v = i;\n\t\t\tadd_edge(g, v, u, 1, w[a[i]]);\n\t\t\tadd_edge(g, K, v, 1, 0);\n\t\t\tadd_edge(g, u, K+1, 1, 0);\n\t\t\tres -= w[a[i]];\n\t\t\tminus ++;\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n\tres += min_cost_flow(g, K, K+1, M-1 + minus);\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<string>\n#include<assert.h>\n#include<math.h>\n#include<stdio.h>\n#include<ctype.h>\n#endif\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define DEBUG if(0)\n#endif\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r) { bool a = l>r; if (a)l = r; return a; }\ntemplate <typename T>inline bool chmax(T &l, T r) { bool a = l<r; if (a)l = r; return a; }\n\nstruct input {\n\tbool success;\n\tinput(){success = true;}\n#ifdef BTK\n\ttemplate<typename T>inline input& operator>>(T& x) {success = !!(cin >> x);return *this;}\n#else\n\tinline input& operator>>(LL& x) {success = (scanf(\"%lld\", &x) != EOF);return *this;}\n\tinline input& operator>>(int& x) {success = (scanf(\"%d\", &x) != EOF);return *this;}\n\tinline input& operator>>(char* x) {success = (scanf(\"%s\", x) != EOF);return *this;}\n\tinline input& operator>>(double& x) {success = (scanf(\"%llf\", &x) != EOF);return *this;}\n#endif\n}in;\n\nconst char space = ' ';\nconst char ln = '\\n';\nstruct output {\n#ifdef BTK\n\ttemplate<typename T>inline output& operator<<(T x) {cout << x; return (*this);}\n\tinline void fp(const double x, const char* s) { char buf[20];sprintf(buf, s, x); cout << buf;}\n#else\n\tinline output& operator<<(const string& x) { printf(\"%s\", x.c_str()); return *this; }\n\tinline output& operator<<(const int x) { printf(\"%d\", x); return *this;}\n\tinline output& operator<<(const char x) { putchar(x); return *this;}\n\tinline output& operator<<(const LL x) { printf(\"%lld\", x); return *this;}\n\tinline output& operator<<(const double x) { printf(\"%lf\", x); return *this;}\n\tinline void fp(const double x, const char* s) {printf(s, x);}\n#endif\n}out;\ntypedef int FLOW;\ntypedef LL COST;\nnamespace MinCostFlow {\n\tconst FLOW FLOW_INF = 1e7;\n\tconst COST COST_INF = 1e15;\n\tstruct edge {\n\t\tFLOW flow; COST cost;\n\t\tint to, rev;\n\t};\n\ttypedef vector<edge> E;\n\ttypedef vector<E> Graph;\n\tvoid addedge(Graph&g, int from, int to, FLOW f, COST c) {\n\t\tint x = g[from].size();\n\t\tint y = g[to].size();\n\t\tedge a = { f,c,to,y };\n\t\tedge b = { (FLOW)0,-c,from,x };\n\t\tg[from].push_back(a);\n\t\tg[to].push_back(b);\n\t}\n\n\tconst int BUF = 11234;\n\tCOST h[BUF];\n\tCOST d[BUF];\n\tint pV[BUF];\n\tint pE[BUF];\n\tvoid init(int size = BUF) {\n\t\tREP(i, size)h[i] = 0;\n\t}\n\ttypedef pair<COST, int> P;\n\tpriority_queue<P> que;\n}\n\n\n\npair<FLOW, COST> maxflow(MinCostFlow::Graph &g, int s, int t, bool init = true) {\n\tconst int V = g.size();\n\tif (init)MinCostFlow::init();\n\tusing namespace MinCostFlow;\n\tCOST c = 0;\n\tFLOW f = 0;\n\twhile (true) {\n\t\tfill(d, d + V, COST_INF);\n\t\td[s] = 0;\n\t\tque.push(P(0, s));\n\t\twhile (que.size()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tCOST cost = -p.first;\n\t\t\tint v = p.second;\n\t\t\tif (d[v]<cost)continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tedge &e = g[v][i];\n\t\t\t\tif (e.flow>0 && d[e.to]>d[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\td[e.to] = d[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tpV[e.to] = v;\n\t\t\t\t\tpE[e.to] = i;\n\t\t\t\t\tque.push(P(-d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[t] == COST_INF)break;\n\n\t\tREP(v, V)h[v] += d[v];\n\t\tFLOW ff = FLOW_INF;\n\t\tfor (int v = t; v != s; v = pV[v]) {\n\t\t\tedge& e = g[pV[v]][pE[v]];\n\t\t\tchmin(ff, e.flow);\n\t\t}\n\t\tf += ff;\n\t\tc += ff*h[t];\n\t\tfor (int v = t; v != s; v = pV[v]) {\n\t\t\tedge &e = g[pV[v]][pE[v]];\n\t\t\te.flow -= ff;\n\t\t\tg[v][e.rev].flow += ff;\n\t\t}\n\t}\n\treturn pair<FLOW, COST>(f, c);\n}\n\nint w[112345];\nint pos[112345];\nint main() {\n\tint M, N, K;\n\tin >> M >> N >> K;\n\tM--;\n\tREP(i, N)in >> w[i];\n\tREP(i, N)pos[i] = -1;\n\tint V = K + 1;\n\tint S = V++;\n\tint T = V++;\n\tint s = 0;\n\tint t = K;\n\tMinCostFlow::Graph g(V);\n\tREP(i, K)MinCostFlow::addedge(g, i, i + 1, M, 0);\n\tMinCostFlow::addedge(g, S, s, M, 0);\n\tMinCostFlow::addedge(g, t, T, M, 0);\n\tLL tot = 0;\n\tREP(i, K) {\n\t\tint a;\n\t\tin >> a;\n\t\ta--;\n\t\ttot += w[a];\n\t\tif (pos[a] != -1&&pos[a]!=i) {\n\t\t\tMinCostFlow::addedge(g, S, i, 1, 0);\n\t\t\tMinCostFlow::addedge(g, i, pos[a], 1, w[a]);\n\t\t\tMinCostFlow::addedge(g, pos[a], T, 1, 0);\n\t\t\ttot -= w[a];\n\t\t}\n\t\tif (pos[a] != i)tot -= w[a];\n\t\tpos[a] = i + 1;\n\t}\n\tpair<FLOW, COST> fc = maxflow(g, S, T);\n\tout << -(tot - fc.second)<<ln;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n#define MAX_V 10010\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvoid init_edge(){\n    for(int i=0;i<V;i++)G[i].clear();\n}\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\nint min_cost_flow(int s,int t,int f){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        priority_queue< pii, vector<pii>, greater<pii> >  que;\n        fill( dist, dist+V , INF );\n        dist[s]=0;\n        que.push(pii(0,s));\n        while(!que.empty()){\n            pii p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v]<p.first)continue;\n            for(int i=0;i<(int)G[v].size();i++){\n                edge &e = G[v][i];\n                if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n                    dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n                    prevv[e.to]=v;\n                    preve[e.to]=i;\n                    que.push(pii(dist[e.to],e.to));\n                }\n            }\n        }\n        \n        if(dist[t]==INF){\n            return -1;\n        }\n        for(int v=0;v<V;v++)h[v]+=dist[v];\n        \n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int M,N,K; cin >> M >> N >> K;\n\n    V = K;\n    \n    int res = 0;\n    vector<int> A(N);\n    vector<vector<int> > B(N);\n    for(int i = 0; i < N;i++) cin >> A[i];\n    for(int i = 0; i < K;i++){\n        int a; cin >> a; a--;\n        B[a].push_back(i);\n        res += A[a];\n    }\n    \n    for(int i = 0; i < N;i++){\n        if((int)B[i].size() <= 1) continue;\n        for(int j = 0; j < (int)B[i].size()-1;j++){\n            int s = B[i][j], t = B[i][j+1];\n            if(s+1 != t){\n                add_edge(s+1, t, 1, -A[i]);\n            }else{\n                res -= A[i];\n            }\n        }\n    }\n    for(int i = 0; i < K-1;i++){\n        add_edge(i, i+1, M, 0);\n    }\n    cout << res + min_cost_flow(0, K-1, M-1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = int;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // テヲツ慊嘉・ツ青妥ィツセツコ\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t テゥツ鳴禿ヲツ慊?ァツ淞ュティツキツッテ」ツ?ォテヲツイツソテ」ツ?」テ」ツ?ヲテァツ崢ョテ、ツクツ?ヲツ敖ッテヲツオツ?」ツ??\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// テヲツオツ?」ツつ古」ツ?淌」ツδ陛」ツδュテ」ツδシ=テ・ツ?ε」ツ??」ツ?ョテ・ツョツケテゥツ??テァツ渉セテ・ツ慊ィテ」ツ?ョテ・ツョツケテゥツ?湘」ツつ津ィツ。ツィテァツ、ツコ\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint w[10000];\nvector<int> id[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tid[a - 1].push_back(i);\n\t\tsum += w[a - 1];\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, M, 0);\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < (int)id[i].size() - 1; j++) {\n\t\t\t//cout << id[i][j] + 1 + 1 << \" \" << id[i][j + 1] + 1 << \" \" << -w[i] << endl;\n\t\t\tpd.add_edge(id[i][j] + 1, id[i][j + 1], 1, -w[i]);\n\t\t}\n\t}\n\n\tint res = pd.solve(0, K - 1, M - 1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\n/*\n<url:>\n問題文============================================================\n\n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n#define MAX_V 10010\nstruct edge{\n    int to;\n    int cap;\n    int cost;\n    int rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,(int)G[to].size()));\n    G[to].push_back(edge(from,0,-cost,(int)G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n    int res=0;\n    while(f>0){\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        bool update = true;\n        while(update){\n            update = false;\n            for(int v=0; v<V ;v++){\n                if(dist[v]==INF) continue;\n                for(int i=0; i<G[v].size(); i++){\n                    edge &e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if(dist[t]==INF) return -1;\n        \n        int d = f;\n        for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*dist[t];\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    int M,N,K; cin >> M >> N >> K;\n\n    V = K;\n    \n    int res = 0;\n    vector<int> A(N);\n    vector<vector<int> > B(N);\n    for(int i = 0; i < N;i++) cin >> A[i];\n    for(int i = 0; i < K;i++){\n        int a; cin >> a; a--;\n        B[a].push_back(i);\n        res += A[a];\n    }\n    \n    for(int i = 0; i < N;i++){\n        if((int)B[i].size() <= 1) continue;\n        for(int j = 0; j < (int)B[i].size()-1;j++){\n            int s = B[i][j], t = B[i][j+1];\n            if(s+1 != t){\n                add_edge(s+1, t, 1, -A[i]);\n            }else{\n                res -= A[i];\n            }\n        }\n    }\n    for(int i = 0; i < K-1;i++){\n        add_edge(i, i+1, M, 0);\n    }\n    cout << res + min_cost_flow(0, K-1, M-1) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2266: Cache Strategy\n * ?¢??????????n????????????????????????m????????????????????????????????????????????????????????§?????????????°????????????¨?????????????????\\?????\\???????????\\??????????????????????????±?´???°?????°??????????????\\?????¢????±?????°??????±?´????\n * ?±???????????°??´?\n * ??????????°??????\\???????????????????????±???????????????????¬?????????¢???????????±?´??????°???????????????????????¨???????????????????????????????????´??????????????????????????´???????????¨???????????????????????±?´????????????\\????????????????????¶????°??????°?????´???????????????????????????1??±?´??´?????????????????????¨?????????INF??±?´?0???????°???´??????????????\\????±?????°??´???¨??????????????\\??????????????§??????????????°??????????¢??????????????§?????????????????????????\n */\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\n\nint a[10010], w[10010];\nint pre[10010];\n\nstruct Edge {\n  Edge() {}\n\n  Edge(int _v, int _cap, int _cost, int _rev) : v(_v), cap(_cap), cost(_cost), rev(_rev) {}\n\n  int v, cap, cost, rev;\n};\n\nvector<Edge> e[10010];\nint n;\nint h[10010], d[10010];\nint pv[10010], pe[10010];\npriority_queue<pii, vector<pii>, greater<pii> > pq;\n\nvoid AddEdge(int u, int v, int cap, int cost) {\n  e[u].push_back(Edge(v, cap, cost, e[v].size()));\n  e[v].push_back(Edge(u, 0, -cost, e[u].size() - 1));\n}\n\nint MinCostFlow(int s, int t, int f) {\n  int ans = 0;\n  memset(h, 0, sizeof(h));\n  while (f > 0) {\n    memset(d, 0x3f, sizeof(d));\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n    while (!pq.empty()) {\n      int u = pq.top().second;\n      int pre = pq.top().first;\n      pq.pop();\n      if (d[u] < pre) continue;\n      for (int i = 0; i < e[u].size(); ++i) {\n        Edge &te = e[u][i];\n        int v = te.v;\n        if (te.cap > 0 && d[v] > d[u] + h[u] - h[v] + te.cost) {\n          d[v] = d[u] + h[u] - h[v] + te.cost;\n          pv[v] = u;\n          pe[v] = i;\n          pq.push(make_pair(d[v], v));\n        }\n      }\n    }\n\n    if (d[t] == INF) {\n      return -1;\n    }\n    for (int i = 0; i < n; ++i) {\n      h[i] += d[i];\n    }\n\n    int cur = f;\n    for (int i = t; i != s; i = pv[i]) {\n      cur = min(cur, e[pv[i]][pe[i]].cap);\n    }\n    ans += cur * h[t];\n    f -= cur;\n    for (int i = t; i != s; i = pv[i]) {\n      Edge &te = e[pv[i]][pe[i]];\n      te.cap -= cur;\n      e[i][te.rev].cap += cur;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  int M, N, K, ans = 0;\n  scanf(\"%d%d%d\", &M, &N, &K);\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; ++i) {\n    scanf(\"%d\", &a[i]);\n    --a[i];\n  }\n  K = unique(a, a + K) - a;\n\n  memset(pre, -1, sizeof(pre));\n  for (int i = 0; i < K; ++i) {\n    ans += w[a[i]];\n    if (pre[a[i]] != -1) {\n      AddEdge(pre[a[i]], i - 1, 1, -w[a[i]]);\n    }\n    pre[a[i]] = i;\n  }\n  for (int i = 1; i < K; ++i) {\n    AddEdge(i - 1, i, M - 1, 0);\n  }\n  n = K;\n  ans += MinCostFlow(0, n - 1, M - 1);\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 31000\n\t#define MAXM 120000\n\t#define wint int\n\t#define cint long long \n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i]) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint p[11000];\nint q[11000];\nint last[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",q+i);\n\t\tq[i]--;\n\t}\n\tfor(int i=0;i<b;i++)last[i]=-1;\n\tMCF::init((c+1)*3+2);\n\tint s=(c+1)*3;\n\tint t=(c+1)*3+1;\n\tMCF::ae(s,0,a,0);\n\tMCF::ae(c,t,a,0);\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i,i+1,a,0);\n\t\tMCF::ae(i,c+1+i,1,p[q[i]]);\n\t\tMCF::ae(2*c+2+i,i+1,1,0);\n\t\tMCF::ae(c+1+i,2*c+2+i,1,-1000000000);\n\t\tif(~last[q[i]]){\n\t\t\tMCF::ae(2*c+2+last[q[i]],c+1+i,1,0);\n\t\t}\n\t\tlast[q[i]]=i;\n\t}\n\tMCF::solve(s,t,a);\n\tprintf(\"%lld\\n\",MCF::toc+1000000000LL*c);\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1<<29;\nstruct edge{int to,cap,cost,rev;};\nvector<edge> graph[vmax];\n\nint h[vmax],dist[vmax];\nint pv[vmax],pe[vmax];\ntypedef tuple<int,int> state;\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tgraph[from].push_back({to,cap,cost,(int)graph[to].size()});\n\tgraph[to].push_back({from,0,-cost,(int)graph[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f,int n){\n\tint res=0;\n\tfill(h,h+n,0);\n\twhile(f>0){\n\t\tpriority_queue <state,vector<state>,greater<state> > q;\n\t\tfill(dist,dist+n,inf);\n\t\tdist[s]=0;\n\t\tq.push(state(0,s));\n\t\twhile(!q.empty()){\n\t\t\tint cost,v;\n\t\t\ttie(cost,v)=q.top();q.pop();\n\t\t\tif(dist[v] < cost) continue;\n\t\t\trep(i,graph[v].size()){\n\t\t\t\tedge &e=graph[v][i];\n\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tpv[e.to]=v,pe[e.to]=i;\n\t\t\t\t\tq.push(state(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[t]==inf) return -1;\n\t\trep(v,n) h[v]+=dist[v];\n\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=pv[v]) d=min(d,graph[pv[v]][pe[v]].cap);\n\t\tf-=d;res+=d*h[t];\n\t\tfor(int v=t;v!=s;v=pv[v]){\n\t\t\tedge &e=graph[pv[v]][pe[v]];\n\t\t\te.cap-=d;\n\t\t\tgraph[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint w[10010];\nint a[10010];\n\nint main(void){\n\tint m,n,k;\n\tcin >> m >> n >> k;\n\trep(i,n) cin >> w[i];\n\trep(i,k) cin >> a[i],a[i]--;\n\n\tint sum=0;\n\trep(i,k){\n\t\tif(i-1>=0&&a[i]==a[i-1]) continue;\n\t\tsum+=w[a[i]];\n\t}\n\n\trep(i,k-1) add_edge(i,i+1,inf,0);\n\n\tint prev[10010];\n\trep(i,n) prev[i]=-1;\n\n\trep(i,k){\n\t\tint cur=a[i];\n\t\tif(prev[cur]!=-1&&prev[cur]+1!=i) add_edge(prev[cur]+1,i,1,-w[cur]);\n\t\tprev[cur]=i;\n\t}\n\tcout << sum+min_cost_flow(0,k-1,m-1,k) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <queue>\nusing namespace std;\n\n\nconst int MAX_V = 100010;\nusing Capacity = int;\nusing Cost = long long;\nconst auto inf = numeric_limits<Capacity>::max() / 8;\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].emplace_back(dst, cap, cost, g[dst].size(), false);\n\t\tg[dst].emplace_back(src, 0, -cost, g[src].size() - 1, true);\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res = 0;\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\th[i] = 0;\n\t\t}\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(pcv(0, s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.emplace(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] += dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\tvoid view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\t\t\tif(!g[i][j].isRev) {\n\t\t\t\t\tEdge& e = g[i][j];\n\t\t\t\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\ntypedef long long ll;\nll w[10000];\nvector<ll> id[10000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N, K;\n\tcin >> M >> N >> K;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tll sum = 0;\n\tfor(int i = 0; i < K; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tif(id[a].size() == 0 || id[a].back() != i - 1) {\n\t\t\tid[a].push_back(i);\n\t\t\tsum += w[a];\n\t\t}\n\t}\n\n\tPrimalDual pd(K);\n\tfor(int i = 0; i < K - 1; i++) {\n\t\tpd.add_edge(i, i + 1, 100000, 0);\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < (int)id[i].size() - 1; j++) {\n\t\t\t//cout << id[i][j] + 1 + 1 << \" \" << id[i][j + 1] + 1 << \" \" << -w[i] << endl;\n\t\t\tpd.add_edge(id[i][j] + 1, id[i][j + 1], 1, -w[i]);\n\t\t}\n\t}\n\n\tll res = pd.solve(0, K - 1, M - 1);\n\t//assert(res != -1);\n\tcout << sum + res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n \nusing namespace std;\ntypedef pair<int,int> P;\n \nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n \nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n \nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n \n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n \n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n \n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      if(M!=1){\n        for(j=MAX(i+1,initial);j<nxt;j++){        \n          nbr[i].push_back(j);\n          cost[i].push_back(w[a[i]]);\n          num_nbr[i]++;\n          if(j >= MAX(i+1,initial) + 10) break;\n        }\n        nbr[i].push_back(nxt);\n        num_nbr[i]++;\n        cost[i].push_back(0);\n      }\n      else{\n        nbr[i].push_back(i+1);\n        cost[i].push_back((nxt == i+1)? 0:w[a[i]]);\n        num_nbr[i]++;\n      }\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n  /*\n  for(i=0;i<K-M;i++)for(j=0;j<num_nbr[i];j++){\n    printf(\"cost[%d][%d]=%d\\n\",i,nbr[i][j],cost[i][j]);\n  }\n   */\n}\n \nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k+1];\n  static priority_queue<P, vector<P>, greater<P> > que;\n   \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n   \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,(K+1)*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n \n  int cnt = 0;\n  for(int s=0;s<K-M;s++){\n    fill(dist,dist+K+1,INT_MAX);\n      dist[s] = 0;\n      que.push(P(0,s));\n//    printf(\"\\n%d-th loop\",++cnt);\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n//      printf(\"node %d established.\\n\",u);\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    for(i = 0;i < K-M;i++) h[i] += (dist[i] == INT_MAX)? 0:dist[i];\n    h[t] += (dist[t] == INT_MAX)? 0:dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n  return res;\n}\n \nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n \nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2266: Cache Strategy\n * ?¢??????????n????????????????????????m????????????????????????????????????????????????????????§?????????????°????????????¨?????????????????\\?????\\???????????\\??????????????????????????±?´???°?????°??????????????\\?????¢????±?????°??????±?´????\n * ?±???????????°??´?\n * ??????????°??????\\???????????????????????±???????????????????¬?????????¢???????????±?´??????°???????????????????????¨???????????????????????????????????´??????????????????????????´???????????¨???????????????????????±?´????????????\\????????????????????¶????°??????°?????´???????????????????????????1??±?´??´?????????????????????¨?????????INF??±?´?0???????°???´??????????????\\????±?????°??´???¨??????????????\\??????????????§??????????????°??????????¢??????????????§??????????????????????????????????????´????????????\\?±????????¢???????????????¨Dijkstra????????¨Bellman-Ford???\n */\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int INF = 0x3f3f3f3f;\n\nint a[10010], w[10010];\nint pre[10010];\n\nstruct Edge {\n  Edge() {}\n\n  Edge(int _v, int _cap, int _cost, int _rev) : v(_v), cap(_cap), cost(_cost), rev(_rev) {}\n\n  int v, cap, cost, rev;\n};\n\nvector<Edge> e[10010];\nint n;\nint d[10010];\nint pv[10010], pe[10010];\n\nvoid AddEdge(int u, int v, int cap, int cost) {\n  e[u].push_back(Edge(v, cap, cost, e[v].size()));\n  e[v].push_back(Edge(u, 0, -cost, e[u].size() - 1));\n}\n\nint MinCostFlow(int s, int t, int f) {\n  int ans = 0;\n  while (f > 0) {\n    memset(d, 0x3f, sizeof(d));\n    d[s] = 0;\n    bool update = true;\n    while (update) {\n      update = false;\n      for (int i = 0; i < n; ++i) {\n        if (d[i] == INF) continue;\n        for (int j = 0; j < e[i].size(); ++j) {\n          Edge &te = e[i][j];\n          if (te.cap > 0 && d[te.v] > d[i] + te.cost) {\n            d[te.v] = d[i] + te.cost;\n            pv[te.v] = i;\n            pe[te.v] = j;\n            update = true;\n          }\n        }\n      }\n    }\n\n    if (d[t] == INF) {\n      return -1;\n    }\n\n    int cur = f;\n    for (int i = t; i != s; i = pv[i]) {\n      cur = min(cur, e[pv[i]][pe[i]].cap);\n    }\n    ans += cur * d[t];\n    f -= cur;\n    for (int i = t; i != s; i = pv[i]) {\n      Edge &te = e[pv[i]][pe[i]];\n      te.cap -= cur;\n      e[i][te.rev].cap += cur;\n    }\n  }\n  return ans;\n}\n\nint main() {\n  int M, N, K, ans = 0;\n  scanf(\"%d%d%d\", &M, &N, &K);\n  for (int i = 0; i < N; ++i) {\n    scanf(\"%d\", &w[i]);\n  }\n  for (int i = 0; i < K; ++i) {\n    scanf(\"%d\", &a[i]);\n    --a[i];\n  }\n  K = unique(a, a + K) - a;\n\n  memset(pre, -1, sizeof(pre));\n  for (int i = 0; i < K; ++i) {\n    ans += w[a[i]];\n    if (pre[a[i]] != -1) {\n      AddEdge(pre[a[i]], i - 1, 1, -w[a[i]]);\n    }\n    pre[a[i]] = i;\n  }\n  for (int i = 1; i < K; ++i) {\n    AddEdge(i - 1, i, M - 1, 0);\n  }\n  n = K;\n  ans += MinCostFlow(0, n - 1, M - 1);\n  printf(\"%d\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\nusing namespace std;\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 51000\n\t#define MAXM 1000000\n\t#define wint int\n\t#define cint long long \n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 1001001001001001001LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i]) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i]) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint p[11000];\nint q[11000];\nint last[11000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d\",q+i);\n\t\tq[i]--;\n\t}\n\tfor(int i=0;i<b;i++)last[i]=-1;\n\tMCF::init((c+1)*3+2);\n\tint s=(c+1)*3;\n\tint t=(c+1)*3+1;\n\tMCF::ae(s,0,a,0);\n\tMCF::ae(c,t,a,0);\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i,i+1,a,0);\n\t\tMCF::ae(i,c+1+i,1,p[q[i]]);\n\t\tMCF::ae(2*c+2+i,i+1,1,0);\n\t\tMCF::ae(c+1+i,2*c+2+i,1,-1000000000);\n\t\tif(~last[q[i]]){\n\t\t\tMCF::ae(2*c+2+last[q[i]],c+1+i,1,0);\n\t\t}\n\t\tlast[q[i]]=i;\n\t}\n\tMCF::solve(s,t,a);\n\tprintf(\"%lld\\n\",MCF::toc+1000000000LL*c);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL BASE = 10000LL * 10000LL * 10000;\nconst LL INF = 1LL << 60;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow cap, flow;\n    Cost cost;\n    Edge *back;\n\n    Edge(int from, int to, Flow cap, Cost cost, Edge *back) : from(from), to(to), cap(cap), cost(cost), back(back) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    Edge<Flow,Cost> *ea = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    Edge<Flow,Cost> *eb = new Edge<Flow,Cost>(dst, src, 0, -d, ea);\n    ea->back = eb;\n    g[src].push_back(ea);\n    g[dst].push_back(eb);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow,Cost>\nprimal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, int max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> dist(N);\n    vector<Edge<Flow,Cost>*> prev(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        fill(prev.begin(), prev.end(), nullptr);\n        dist[src] = 0;\n\n        for(int turn = 0; turn < N; ++turn) {\n            bool updated = false;\n            for(int i = 0; i < N; ++i) {\n                for(auto *e : g[i]) {\n                    if(e->cap - e->flow > 0) {\n                        Cost nc = dist[e->from] + e->cost;\n                        if(nc < dist[e->to]) {\n                            dist[e->to] = nc;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(!updated) break;\n        }\n        if(prev[sink] == nullptr) break;\n\n        Flow aug = f;\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            aug = min(aug, e->cap - e->flow);\n        }\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            res.second += aug * e->cost;\n            e->flow += aug;\n            e->back->flow -= aug;\n        }\n        f -= aug;\n        res.first += aug;\n    }\n\n    return res;\n}\n\nbool solve() {\n    int M, N, K;\n    if(!(cin >> M >> N >> K)) return false;\n\n    vector<LL> ws(N);\n    vector<int> as(K);\n    vector<vector<Edge<int,LL>*>> graph(K*2+2);\n    const int SRC = K*2;\n    const int SINK = K*2+1;\n    for(int i = 0; i < N; ++i) {\n        cin >> ws[i];\n    }\n    for(int i = 0; i < K; ++i) {\n        cin >> as[i];\n        --as[i];\n    }\n    for(int i = 0; i < K; ++i) {\n        add_edge(graph, 2*i, 2*i+1, 1, -BASE);\n        // Edge to neighbor\n        if(i+1 < K) add_edge(graph, 2*i+1, 2*(i+1), 1, ws[as[i]]);\n        // Edge to next same number\n        auto it = find(as.begin()+i+1, as.end(), as[i]);\n        if(it != as.end()) {\n            add_edge(graph, 2*i+1, 2*(it-as.begin()), 1, 0LL);\n        }\n        // Edge to sink\n        add_edge(graph, 2*i+1, SINK, 1, ws[as[i]]);\n        // Edge from source\n        add_edge(graph, SRC, 2*i, 1, 0LL);\n    }\n    auto res = primal_dual(graph, SRC, SINK, M);\n    cout << res.second + BASE * K << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#define max_m 10\n#define max_n 10000\n#define max_k 10000\n#define MIN(a,b)  ( ((a)<(b) ) ? (a) : (b) )\n#define MAX(a,b)  ( ((a)>(b) ) ? (a) : (b) )\n#define START K+1\n\nusing namespace std;\ntypedef pair<int,int> P;\n\nint M,N,K;\nint i,j;\nint w[max_n];\nchar a[max_k];\nvector<int> cost[max_k];\nvector<int> nbr[max_k];\nint num_nbr[max_k];\n\nvoid read_inputs(){\n  scanf(\"%d%d%d\",&M,&N,&K);\n  for(i=0;i<N;i++){\n    scanf(\"%d\",w+i);    \n  }\n  for(i=0;i<K;i++){\n    scanf(\"%d\",a+i);\n    a[i]--;\n  }\n}\n\nvoid make_biparate(){\n  int initial=0;\n  static vector<int> appear[max_n];\n  static int next[max_k];\n\n  memset(next,-1,K*sizeof(int));  \n  for(i=0;i<K;i++){\n    (appear[a[i]]).push_back(i);   \n  }\n  for(i=0;i<N;i++){\n    for(j=0;j<(int) (appear[i]).size()-1;j++){\n      next[appear[i][j]] = appear[i][j+1];\n    }\n  }\n\n  static bool expt[max_k];\n  memset(expt,0,K*sizeof(int));\n  for(i=0;i<K;i++){\n    if(next[i] >= 0) expt[next[i]] = true;\n  }\n  for(i=0;i<K;i++){\n    if(!expt[i]) initial++;\n    if(initial == M) break;\n  }\n\n  memset(num_nbr,0,K*sizeof(int));\n  for(i=0;i<K-M;i++){\n    int nxt = next[i];\n    if(nxt >= 0){\n      for(j=MAX(i+1,initial);j<nxt;j++){        \n        nbr[i].push_back(j);\n        cost[i].push_back(w[a[i]]);\n        num_nbr[i]++;\n        if(j > MAX(i+1,initial) + 10) break;\n      }\n      nbr[i].push_back(nxt);\n      num_nbr[i]++;\n      cost[i].push_back(0);\n    }\n    else{\n      for(j=MAX(i+1,initial);j<K;j++){\n        nbr[i].push_back(j);\n        cost[i].push_back(0);\n        num_nbr[i]++;\n      }\n    }\n  }\n}\n\nint min_cost(){\n  static long h[max_k+1];\n  static long dist[max_k+1];\n  static int flow[max_k];\n  static int prev[max_k+1];\n  static int prev_mid[max_k+1];\n  static int used[max_k];\n  static int use_edge[max_k+1];\n  static int use_cost[max_k];\n  static priority_queue<P, vector<P>, greater<P> > que;\n  \n  int res=0;\n  int t = K;\n  int new_dist;\n  int u,v,w;\n  \n  memset(h,0,(K+1)*sizeof(long));\n  memset(prev,-1,K*sizeof(int));\n  memset(used,-1,K*sizeof(int));\n  memset(flow,-1,K*sizeof(int));\n\n  int cnt = 0;\n  while(1){\n    fill(dist,dist+K+1,INT_MAX);\n    for(i = 0;i<K-M;i++){\n      if(prev[i] != -1) continue;\n      dist[i] = 0;\n      que.push(P(0,i));\n    }\n//    printf(\"\\n%d-th loop\",++cnt);\n    while(!que.empty()){\n      P p=que.top(); que.pop();\n      u = p.second;\n      if(dist[u] < p.first) continue;\n//      printf(\"node %d established.\\n\",u);\n      for(i=0;i<num_nbr[u];i++){\n        v = nbr[u][i];\n        if(flow[u] == i) continue;\n        if((w = used[v]) >= 0){\n          new_dist = dist[u] + cost[u][i] + (-use_cost[w]) - (h[w] - h[u]);\n          if(new_dist < dist[w]){\n            dist[w] = new_dist;\n            prev[w] = u;\n            use_edge[w] = i;\n            prev_mid[w] = v;\n            que.push(P(new_dist,w));\n          }\n        }else{\n          new_dist = dist[u] + cost[u][i] - (h[t] - h[u]);\n          if(new_dist < dist[t]){\n            dist[t] = new_dist;\n            prev[t] = u;\n            use_edge[t] = i;\n            prev_mid[t] = v;\n          }\n        }        \n      }\n    }\n    if(dist[t] == INT_MAX) return res;\n    for(i = 0;i < K-M;i++) h[i] += dist[i];\n    h[t] += dist[t];\n    for(w=t,v=prev_mid[t],u=prev[t];true;w=u,v=prev_mid[u],u=prev[u]){\n      flow[u] = use_edge[w];\n      used[v] = u;\n      use_cost[u] = cost[u][use_edge[w]];\n      if(prev[u] == -1) {\n        prev[u] = START;\n        break;\n      }\n    }    \n    res += h[t];\n  }\n}\n\nint necessary(){  \n  static bool appear[max_n];\n  int res=0;\n  memset(appear,0,N*sizeof(int));\n  for(i=0;i<K;i++){\n    if(appear[a[i]]) continue;\n    appear[a[i]] = true;\n    res += w[a[i]];\n  }\n  return res;\n}\n\nmain(){\n  read_inputs(); //入力読み込み\n  make_biparate(); //二部グラフ作成\n  printf(\"%d\\n\",min_cost()+necessary()); //二部グラフの最小コストマッチング算出\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, cost, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid addEdge(int from, int to, int cap, int cost) {\n\tif (from < 0 || to < 0) return;\n\n\tG[from].push_back({to, cap, cost, (int)G[to].size()});\n\tG[to].push_back({from, 0, -cost, (int)G[from].size()-1});\n}\n\n#define INF 1000000000\n\ntypedef pair<int, int> P;\n\nint dist[21000], h[21000] = {0}, prevV[21000], prevE[21000];\nint flow(int s, int t, int f) {\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+21000, INF); dist[s] = 0;\n\t\twhile (1) {\n\t\t\tbool isUpdated = false;\n\t\t\tfor (int i = 0; i < G.size(); ++i) {\n\t\t\t\tif (dist[i] == INF) continue;\n\t\t\t\tfor (int j = 0; j < G[i].size(); ++j) {\n\t\t\t\t\tEdge& e = G[i][j];\n\t\t\t\t\tif (e.cap > 0 && dist[i]+e.cost < dist[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[i]+e.cost;\n\t\t\t\t\t\tprevV[e.to] = i;\n\t\t\t\t\t\tprevE[e.to] = j;\n\t\t\t\t\t\tisUpdated = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isUpdated) break;\n\t\t}\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\texit(1);\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n/*\n\tint res = 0;\n\twhile (f > 0) {\n\t\tfill(&dist[0], &dist[0]+21000, INF); dist[s] = 0;\n\t\tpriority_queue<P, vector<P>, greater<P> > Q; Q.push({0, s});\n\t\twhile ( !Q.empty() ) {\n\t\t\tP p = Q.top(); Q.pop();\n\t\t\tint v = p.second;\n\t\t\tif (p.first > dist[v]) continue;\n\t\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\t\tEdge& e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[v]+e.cost+h[v]-h[e.to] < dist[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevV[e.to] = v;\n\t\t\t\t\tprevE[e.to] = i;\n\t\t\t\t\tQ.push({dist[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < G.size(); ++i) h[i] += dist[i];\n\n\t\tif (dist[t] == INF) {\n\t\t\tcout << \"ERROR\" << endl;\n\t\t\texit(1);\n\t\t}\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\td = min(d, G[prevV[v]][prevE[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevV[v]) {\n\t\t\tEdge& e = G[prevV[v]][prevE[v]];\n\t\t\te.cap -= d;\n\t\t\tG[e.to][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n*/\n}\n\nint main() {\n\tint M, N, K; cin >> M >> N >> K;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> w[i];\n\t}\n\tvector<int> a(K);\n\tfor (int i = 0; i < K; ++i) {\n\t\tcin >> a[i]; --a[i];\n\t}\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tK = a.size();\n\n\tint last = K;\n\tG.resize(2*K);\n\tvector<int> prev(N, -1);\n\tfor (int i = 0; i < K; ++i) {\n\t\taddEdge(i-1, i, INF, 0);\n\t\tif (prev[a[i]] > -1) {\n\t\t\taddEdge(prev[a[i]], last, 1, 0);\n\t\t\taddEdge(prev[a[i]]+1, last, 1, 0);\n\t\t\taddEdge(last, i, 1, -w[a[i]]);\n\t\t\t++last;\n\t\t}\n\t\tprev[a[i]] = i;\n\t}\n//\tfor (int i = 0; i < N; ++i) {\n//\t\taddEdge(prev[a[i]], t, 1, -w[a[i]]);\n//\t}\n//\taddEdge(K-1, t, INF, 0);\n\n\tint sum = 0;\n\tfor (int i = 0; i < K; ++i) {\n\t\tsum += w[a[i]];\n\t}\n\tcout << (sum + flow(0, K-1, M-1)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\nconst int MAXN=1e5+5;\nstruct edge\n{\n    int from,to,c,cost;\n    edge(int _from,int _to,int _c,int _cost)\n    {\n        from=_from,to=_to,c=_c,cost=_cost;\n    }\n};\nvector<int> same[MAXN+5];\nvector<int> G[MAXN+5];\nvector<edge> p;\nint N,M,K,inf=1e9;\nint w[MAXN+5];\nvector <int> a;\nvoid input(int &sum)\n{\n    sum=0;\n    for(int i=0; i<M; i++) scanf(\"%d\",&w[i]);\n    int t;\n    for(int i=0; i<K; i++)\n    {\n        scanf(\"%d\",&t); t--;\n        if(a.size()==0||t!=a[a.size()-1])\n        {\n            same[t].push_back(a.size());\n            a.push_back(t);\n            sum+=w[t];\n        }\n    }\n    K=a.size();\n}\nvoid add(int from,int to,int c,int cost)\n{\n    G[from].push_back(p.size());\n    p.push_back(edge(from,to,c,cost));\n    G[to].push_back(p.size());\n    p.push_back(edge(to,from,0,-cost));\n}\nvoid get_map(int s,int d)\n{\n    for(int i=0;i<K-1;i++) add(i,i + 1, N, 0);\n    for(int i=0;i<M;i++) for(int j=0;j<same[i].size()-1;j++) add(same[i][j]+1,same[i][j+1],1,-w[a[same[i][j]]]);\n    add(s,0,N,0);\n    add(K-1,d,N,0);\n}\nint pre[MAXN+5],dist[MAXN+5];\nbool vis[MAXN+5];\nbool spfa(int s,int d)\n{\n    int u,v;\n    queue<int> q;\n    for(int i=0;i<=d+2;i++){\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=inf;\n    }\n    vis[s]=1;\n    dist[s]=0;\n    q.push(s);\n    while(!q.empty()){\n        u=q.front();\n       /* cout<<u<<\":\"<<endl;\n        for(int i=0;i<=d;i++) printf(\"%4d\",p[pre[i]].from); cout<<endl;\n        for(int i=0;i<=d;i++) printf(\"%4d\",dist[i]); cout<<endl;*/\n        q.pop();\n        vis[u]=0;\n        for(int j=0;j<G[u].size();j++){\n            int i=G[u][j];\n            if(p[i].c>0){\n                v=p[i].to;\n                if(dist[v]>dist[u]+p[i].cost){\n                    dist[v]=dist[u]+p[i].cost;\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    return dist[d]!=inf;\n}\n\nint MCMF(int s,int d){\n    int ans=0,flow;\n    int flow_sum=0;\n    while(spfa(s,d)){\n        flow=inf;\n        for(int i=pre[d];i!=-1;i=pre[p[i].from])\n            if(p[i].c<flow)\n                flow=p[i].c;\n        for(int i=pre[d];i!=-1;i=pre[p[i].from]){\n            p[i].c-=flow;\n            p[i^1].c+=flow;\n        }\n        ans+=dist[d]*flow;\n        //cout<<dist[d]<<\"*\"<<flow<<endl;\n        flow_sum += flow;\n        if(flow_sum>=N-1) break;\n    }\n    //cout << flow_sum << endl;\n    //cout<<ans<<endl;\n    return ans;\n}\nvoid init()\n{\n    for(int i=0;i<MAXN;i++) G[i].clear(),same[i].clear();\n    p.clear();\n}\nint main()\n{\n    while(cin>>N>>M>>K)\n    {\n        init();\n        int sum;\n        input(sum);\n        int s=K,d=K+1;\n        get_map(s,d);\n        cout<<sum+MCMF(s,d)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\nconst LL BASE = 10000LL * 10000LL * 100;\nconst LL INF = 1LL << 59;\n\ntemplate<class Flow, class Cost>\nstruct Edge {\n    int from, to;\n    Flow cap, flow;\n    Cost cost;\n    Edge *back;\n\n    Edge(int from, int to, Flow cap, Cost cost, Edge *back) : from(from), to(to), cap(cap), flow(0), cost(cost), back(back) {}\n};\n\ntemplate<class Flow, class Cost>\nvoid add_edge(vector<vector<Edge<Flow, Cost>*>> &g, int src, int dst, Flow c, Cost d) {\n    Edge<Flow,Cost> *ea = new Edge<Flow,Cost>(src, dst, c, d, nullptr);\n    Edge<Flow,Cost> *eb = new Edge<Flow,Cost>(dst, src, 0, -d, ea);\n    ea->back = eb;\n    g[src].push_back(ea);\n    g[dst].push_back(eb);\n}\n\ntemplate<class Flow, class Cost>\npair<Flow,Cost>\nprimal_dual(vector<vector<Edge<Flow,Cost>*>> &g, int src, int sink, Flow max_flow) {\n    const int N = g.size();\n    pair<Flow, Cost> res;\n    vector<Cost> dist(N);\n    vector<Edge<Flow,Cost>*> prev(N);\n    for(Flow f = max_flow; f > 0; ) {\n        fill(dist.begin(), dist.end(), INF);\n        fill(prev.begin(), prev.end(), nullptr);\n        dist[src] = 0;\n\n        while(true) {\n            bool updated = false;\n            for(int i = 0; i < N; ++i) {\n                for(auto *e : g[i]) {\n                    if(e->cap - e->flow > 0) {\n                        Cost nc = dist[e->from] + e->cost;\n                        if(nc < dist[e->to]) {\n                            dist[e->to] = nc;\n                            prev[e->to] = e;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            if(!updated) break;\n        }\n        if(prev[sink] == nullptr) break;\n\n        Flow aug = f;\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            aug = min(aug, e->cap - e->flow);\n        }\n        for(auto *e = prev[sink]; e; e = prev[e->from]) {\n            res.second += aug * e->cost;\n            e->flow += aug;\n            e->back->flow -= aug;\n        }\n        f -= aug;\n        res.first += aug;\n    }\n\n    return res;\n}\n\nbool solve() {\n    int M, N, K;\n    if(!(cin >> M >> N >> K)) return false;\n\n    vector<LL> ws(N);\n    vector<int> as;\n    vector<vector<Edge<int,LL>*>> graph(K+2);\n    const int SRC = K;\n    const int SINK = K+1;\n    for(int i = 0; i < N; ++i) {\n        cin >> ws[i];\n    }\n    LL sum = 0;\n    for(int i = 0; i < K; ++i) {\n        int a;\n        cin >> a;\n        --a;\n        if(as.size() > 0 && as.back() == a) {\n            // do nothing\n        } else {\n            as.push_back(a);\n            sum += ws[a];\n        }\n    }\n    const int L = as.size();\n    for(int i = 0; i < L; ++i) {\n        // Edge to neighbor\n        if(i+1 < L) {\n            add_edge(graph, i, i+1, M, 0LL);\n        }\n        // Edge to next same number\n        auto it = find(as.begin()+i+1, as.end(), as[i]);\n        if(it != as.end()) {\n            add_edge(graph, i+1, it-as.begin(), 1, -ws[as[i]]);\n        }\n    }\n    add_edge(graph, SRC, 0, M, 0LL);\n    add_edge(graph, L-1, SINK, M, 0LL);\n    auto res = primal_dual(graph, SRC, SINK, M-1);\n    cout << sum + res.second << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2266 Cache Strategy\n// 2018.3.8 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 10005\ntypedef struct { int to, rev; int cap, cost; } EDGE;\nEDGE *edge[MAX]; int hi[MAX], lim[MAX];\nint V;\t\t\t\t// 頂点数\nint potential[MAX], dist[MAX], prevv[MAX], preve[MAX];\n\nvoid check_lim(int a)\n{\n\tif (hi[a] < lim[a]) return;\n\tif (lim[a] == 0) {\n\t\tlim[a] = 16, hi[a] = 0;\n\t\tedge[a] = malloc(sizeof(EDGE) *lim[a]);\n\t} else if (hi[a] == lim[a]) {\n\t\tint k = lim[a];\n\t\tif (k > 512) k = 512;\n\t\tlim[a] += k;\n\t\tedge[a] = realloc(edge[a], sizeof(EDGE) *lim[a]);\n\t}\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tint f, t;\n\tEDGE *ep;\n\n\tcheck_lim(from), check_lim(to);\n\tf = hi[from]++, t = hi[to]++;\n\tep = &edge[from][f], ep->to = to, ep->cap = cap, ep->cost = cost, ep->rev = t; \n\tep = &edge[to][t], ep->to = from, ep->cap = 0, ep->cost = -cost, ep->rev = f;\n}\n\nint minCostFlow(int S, int T, int F, int neg)\n{\n\tint i, v, nv, t, nt, update, ret;\n\tEDGE *ep;\n\n\tret = 0;\n//\tmemset(potential, 0, V << 2);\n  \n\twhile (F > 0) {\n\t\tmemset(dist, INF, V << 2);\n\t\tqsize = 0;\n\t\tdist[S] = 0;\n\t\tif (neg) {\n\t\t\tneg = 0;\n\t\t\tupdate = 1;\n\t\t\tdo {\n\t\t\t\tupdate = 0;\n\t\t\t\tfor (v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\t\t\tep = &edge[v][i];\n\t\t\t\t\t\tif (ep->cap <= 0) continue;\n\t\t\t\t\t\tnv = ep->to;\n\t\t\t\t\t\tnt = dist[v] + ep->cost;\n\t\t\t\t\t\tif (dist[nv] > nt) {\n\t\t\t\t\t\t\tdist[nv] = nt, prevv[nv] = v, preve[ep->to] = i;\n\t\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t} else {\n\t\t\tenq(S, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tv = que[0].s, t = que[0].t, deq();\n\t\t\t\tif (dist[v] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\t\tep = &edge[v][i];\n\t\t\t\t\tif (ep->cap <= 0) continue;\n\t\t\t\t\tnv = ep->to;\n\t\t\t\t\tnt = t + ep->cost - potential[nv] + potential[v];\n\t\t\t\t\tif(dist[nv] > nt) {\n\t\t\t\t\t\tdist[nv] = nt;\n\t\t\t\t\t\tprevv[nv] = v, preve[nv] = i;\n\t\t\t\t\t\tenq(nv, nt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[T] == INF) return -1;\n\t\tfor (v = 0; v < V; v++) potential[v] += dist[v];\n\n\t\tt = F;\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tif (t > ep->cap) t = ep->cap;\n\t\t}\n\t\tF -= t;\n\n\t\tret += t * potential[T];\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tep->cap -= t;\n\t\t\tedge[v][ep->rev].cap += t;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint w[MAX], a[MAX], b[MAX], c[MAX], f[MAX];\n\nint main()\n{\n\tint M, N, K, i, cnt, ans;\n\tint as, cs;\n\n\tM = in(), N = in(), K = in();\n\tfor (i = 1; i <= N; i++) w[i] = in();\n\tfor (i = 1; i <= K; i++) b[i] = in();\n\tcnt = 0, as = 1, cs = 0; for (i = 1; i <= K; i++) {\n\t\tif (b[i] == b[i-1]) c[cs++] = b[i];\n\t\telse                a[as++] = b[i], cnt++;\n\t}\n\tfor (i = 0; i < cs; i++) a[as++] = c[i];\n\n\tV = cnt+1;\n\tans = 0; for (i = 1; i <= cnt; i++) {\n\t\tans += w[a[i]];\n\t\tif (f[a[i]]) add_edge(f[a[i]], i-1, 1, -w[a[i]]);\n\t\tf[a[i]] = i;\n\t}\n\tfor (i = 1; i < cnt; i++) add_edge(i, i+1, INF, 0);\n\tprintf(\"%d\\n\", ans + minCostFlow(1, cnt, M-1, 1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2266 Cache Strategy\n// 2018.3.8 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define INF 0x10101010\n#define MAX 10005\ntypedef struct { int to, rev; int cap, cost; } EDGE;\nEDGE *edge[MAX]; int hi[MAX], lim[MAX];\nint V;\t\t\t\t// 頂点数\nint dist[MAX], prevv[MAX], preve[MAX];\n\nvoid check_lim(int a)\n{\n\tif (hi[a] < lim[a]) return;\n\tif (lim[a] == 0) {\n\t\tlim[a] = 32, hi[a] = 0;\n\t\tedge[a] = malloc(sizeof(EDGE) *lim[a]);\n\t} else if (hi[a] == lim[a]) {\n\t\tint k = lim[a];\n\t\tif (k > 512) k = 512;\n\t\tlim[a] += k;\n\t\tedge[a] = realloc(edge[a], sizeof(EDGE) *lim[a]);\n\t}\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tint f, t;\n\tEDGE *ep;\n\n\tcheck_lim(from), check_lim(to);\n\tf = hi[from]++, t = hi[to]++;\n\tep = &edge[from][f], ep->to = to, ep->cap = cap, ep->cost = cost, ep->rev = t; \n\tep = &edge[to][t], ep->to = from, ep->cap = 0, ep->cost = -cost, ep->rev = f;\n}\n\nint minCostFlow(int s, int t, int f)\n{\n\tint i, v, d, update, ans;\n\tEDGE *ep;\n\n\tans = 0;\n\twhile (f > 0) {\n\t\tfor (i = 0; i < V; i++) dist[i] = INF;\n\t\tdist[s] = 0;\n\t\tupdate = 1;\n\t\twhile (update) {\n\t\t\tupdate = 0;\n\t\t\tfor (v = 0; v < V; v++) {\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\t\tep = &edge[v][i];\n\t\t\t\t\tif (ep->cap > 0 && dist[ep->to] > dist[v] + ep->cost) {\n\t\t\t\t\t\tdist[ep->to] = dist[v] + ep->cost;\n\t\t\t\t\t\tprevv[ep->to] = v;\n\t\t\t\t\t\tpreve[ep->to] = i;\n\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\n\t\td = f;\n        for (v = t; v != s; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tif (d > ep->cap) d = ep->cap;\n\t\t}\n\t\tf -= d;\n\n\t\tans += d * dist[t];\n        for (v = t; v != s; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tep->cap -= d;\n\t\t\tedge[v][ep->rev].cap += d;\n\t\t}\n\t}\n\treturn ans;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint w[MAX], a[MAX], b[MAX], c[MAX], f[MAX];\n\nint main()\n{\n\tint M, N, K, i, cnt, ans;\n\tint as, cs;\n\n\tM = in(), N = in(), K = in();\n\tfor (i = 1; i <= N; i++) w[i] = in();\n\tfor (i = 1; i <= K; i++) b[i] = in();\n\tcnt = 0, as = 1, cs = 0; for (i = 1; i <= K; i++) {\n\t\tif (b[i] == b[i-1]) c[cs++] = b[i];\n\t\telse                a[as++] = b[i], cnt++;\n\t}\n\tfor (i = 0; i < cs; i++) a[as++] = c[i];\n\n\tV = cnt+1;\n\tans = 0; for (i = 1; i <= cnt; i++) {\n\t\tans += w[a[i]];\n\t\tif (f[a[i]]) add_edge(f[a[i]], i-1, 1, -w[a[i]]);\n\t\tf[a[i]] = i;\n\t}\n\tfor (i = 1; i < cnt; i++) add_edge(i, i+1, INF, 0);\n    printf(\"%d\\n\", ans + minCostFlow(1, cnt, M-1));\n\treturn 0;\n}\n \n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define NMAX 10000\n#define INF 1000000000\n#define ELMAX 512\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int rev;\n  int cap;\n  int cost;\n};\nstruct node *list[NMAX];\nint elen[NMAX], elim[NMAX], dist[NMAX], prev[NMAX], preve[NMAX], h[NMAX];\nint heap[NMAX], heap_index[NMAX], heapsize;\nvoid Insert(int, int, int, int);\nvoid ext_lim(int);\nvoid downheap(int);\nvoid upheap(int);\nvoid PQ_init(int);\nint PQ_remove(void);\nvoid PQ_update(int);\nint Bellman(int, int, int);\nint Maxflow(int, int, int);\nint Mincostflow(int, int, int, int);\nint main(void)\n{\n  int i, j, m, n, k, s, t, f, delta, pv = 0, v = 0, mincost = 0;\n  int weight[NMAX], vertex[NMAX], interval[NMAX] = {0};\n  scanf(\"%d %d %d%*c\", &m, &n, &k);\n  for (i = 0; i < n; i++) scanf(\"%d%*c\", &weight[i]);\n  for (i = 0; i < k; i++) {\n    int temp;\n    scanf(\"%d\", &temp);\n    if (pv != temp) {\n      vertex[v++] = temp;\n      pv = temp;\n    }\n  }\n  s = 0;\n  t = v - 1;\n  f = m - 1;\n  for (i = 0; i < v - 1; i++) Insert(i, i + 1, INF, 0);\n  for (i = 0; i < v; i++) {\n    if (interval[vertex[i]-1]) Insert(interval[vertex[i]-1], i, 1, -weight[vertex[i]-1]);\n    mincost += weight[vertex[i]-1];\n    interval[vertex[i]-1] = i + 1;\n  }\n  Bellman(s, t, v);\n  delta = f;\n  for (i = t; i != s; i = prev[i]) {\n    delta = MIN(delta, list[prev[i]][preve[i]].cap);\n  }\n  f -= delta;\n  for (i = t; i != s; i = prev[i]) {\n    list[prev[i]][preve[i]].cap -= delta;\n    list[i][list[prev[i]][preve[i]].rev].cap += delta;\n  }\n  for (i = 0; i < v; i++) h[i] += dist[i];\n  mincost += delta * h[t];\n  printf(\"%d\\n\", mincost + Mincostflow(s, t, v, f));\n  for (i = 0; i < v; i++) free(list[i]);\n}\nvoid Insert(int a, int b, int cap, int cost)\n{\n  int from, to;\n  ext_lim(a);\n  ext_lim(b);\n  from = elen[a]++;\n  to = elen[b]++;\n  list[a][from].id = b;\n  list[a][from].rev = to;\n  list[a][from].cap = cap;\n  list[a][from].cost = cost;\n  list[b][to].id = a;\n  list[b][to].rev = from;\n  list[b][to].cap = 0;\n  list[b][to].cost = -cost;\n}\nvoid ext_lim(int v)\n{\n  if (elen[v] < elim[v]) return;\n  else {\n    int elnum = MIN(elim[v] + 1, ELMAX);\n    elim[v] += elnum;\n    list[v] = (struct node*)realloc(list[v], sizeof(struct node) * elim[v]);\n  }\n}\nvoid downheap(int k)\n{\n  int j, v = heap[k];\n  while (k < heapsize / 2) {\n    j = 2 * k + 1;\n    if (j < heapsize - 1 && dist[heap[j]] > dist[heap[j+1]]) j++;\n    if (dist[v] <= dist[heap[j]]) break;\n    heap[k] = heap[j];\n    heap_index[heap[j]] = k;\n    k = j;\n  }\n  heap[k] = v;\n  heap_index[v] = k;\n}\nvoid upheap(int j)\n{\n  int k, v = heap[j];\n  while (j > 0) {\n    k = (j + 1) / 2 -1;\n    if (dist[v] >= dist[heap[k]]) break;\n    heap[j] = heap[k];\n    heap_index[heap[k]] = j;\n    j = k;\n  }\n  heap[j] = v;\n  heap_index[v] = j;\n}\nvoid PQ_init(int size)\n{\n  int i;\n  heapsize = size;\n  for (i = 0; i < size; i++) {\n    heap[i] = i;\n    heap_index[i] = i;\n  }\n  for (i = heapsize / 2 - 1; i >= 0; i--) downheap(i);\n}\nint PQ_remove(void)\n{\n  int v = heap[0];\n  heap[0] = heap[heapsize-1];\n  heap_index[heap[heapsize-1]] = 0;\n  heapsize--;\n  downheap(0);\n  return v;\n}\nvoid PQ_update(int v)\n{\n  upheap(heap_index[v]);\n}\nint Bellman(int s, int t, int size)\n{\n  int i, n, update = 1;\n  for (i = 0; i < size; i++) {\n    dist[i] = INF;\n    prev[i] = -1;\n    preve[i] = -1;\n  }\n  dist[s] = 0;\n  while (update) {\n    update = 0;\n    for (i = 0; i < size; i++) {\n      if (dist[i] == INF) continue;\n      for (n = 0; n < elen[i]; n++) {\n        int v = list[i][n].id;\n        if (list[i][n].cap> 0) {\n          int newlen = dist[i] + list[i][n].cost;\n          if (newlen < dist[v]) {\n            dist[v] = newlen;\n            prev[v] = i;\n            preve[v] = n;\n            update = 1;\n          }\n        }\n      }\n    }\n  }\n  return dist[t] != INF;\n}\nint Maxflow(int s, int t, int size)\n{\n  int i, n;\n  for (i = 0; i < size; i++) {\n    dist[i] = INF;\n    prev[i] = -1;\n    preve[i] = -1;\n  }\n  dist[s] = 0;\n  PQ_init(size);\n  while(heapsize) {\n    i = PQ_remove();\n    if (dist[i] == INF) break;\n    for (n = 0; n < elen[i]; n++) {\n      int v = list[i][n].id;\n      if (list[i][n].cap> 0) {\n        int newlen = dist[i] + list[i][n].cost + h[i] - h[v];\n        if (newlen < dist[v]) {\n          dist[v] = newlen;\n          prev[v] = i;\n          preve[v] = n;\n          PQ_update(v);\n        }\n      }\n    }\n  }\n  return dist[t] != INF;\n}\nint Mincostflow(int s, int t, int size, int f)\n{\n  int mincost = 0;\n  while (f > 0 && Maxflow(s, t, size)) {\n    int i, delta = f;\n    for (i = t; i != s; i = prev[i]) {\n      delta = MIN(delta, list[prev[i]][preve[i]].cap);\n    }\n    f -= delta;\n    for (i = t; i != s; i = prev[i]) {\n      list[prev[i]][preve[i]].cap -= delta;\n      list[i][list[prev[i]][preve[i]].rev].cap += delta;\n    }\n    for (i = 0; i < size; i++) h[i] += dist[i];\n    mincost += delta * h[t];\n  }\n  return mincost;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2266 Cache Strategy\n// 2018.3.8 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 20005\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 10005\ntypedef struct { int to, rev; int cap, cost; } EDGE;\nEDGE *edge[MAX]; int hi[MAX], lim[MAX];\nint V;\t\t\t\t// 頂点数\nint potential[MAX], dist[MAX], prevv[MAX], preve[MAX];\n\nvoid check_lim(int a)\n{\n\tif (hi[a] < lim[a]) return;\n\tif (lim[a] == 0) {\n\t\tlim[a] = 32, hi[a] = 0;\n\t\tedge[a] = malloc(sizeof(EDGE) *lim[a]);\n\t} else if (hi[a] == lim[a]) {\n\t\tint k = lim[a];\n\t\tif (k > 512) k = 512;\n\t\tlim[a] += k;\n\t\tedge[a] = realloc(edge[a], sizeof(EDGE) *lim[a]);\n\t}\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tint f, t;\n\tEDGE *ep;\n\n\tcheck_lim(from), check_lim(to);\n\tf = hi[from]++, t = hi[to]++;\n\tep = &edge[from][f], ep->to = to, ep->cap = cap, ep->cost = cost, ep->rev = t; \n\tep = &edge[to][t], ep->to = from, ep->cap = 0, ep->cost = -cost, ep->rev = f;\n}\n\nint minCostFlow(int S, int T, int F, int neg)\n{\n\tint i, v, nv, t, nt, update, ret;\n\tEDGE *ep;\n\n\tret = 0;\n//\tmemset(potential, 0, V << 2);\n  \n\twhile (F > 0) {\n\t\tfor (v = 0; v < V; v++) dist[v] = INF;\n\t\tqsize = 0;\n\t\tdist[S] = 0;\n\t\tif (neg) {\n\t\t\tneg = 0;\n\t\t\tupdate = 1;\n\t\t\twhile (update) {\n\t\t\t\tupdate = 0;\n\t\t\t\tfor (v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\t\t\tep = &edge[v][i];\n\t\t\t\t\t\tif (ep->cap > 0 && dist[ep->to] > dist[v] + ep->cost) {\n\t\t\t\t\t\t\tdist[ep->to] = dist[v] + ep->cost;\n\t\t\t\t\t\t\tprevv[ep->to] = v;\n\t\t\t\t\t\t\tpreve[ep->to] = i;\n\t\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tenq(S, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tv = que[0].s, t = que[0].t, deq();\n\t\t\t\tif (dist[v] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\t\tep = &edge[v][i], nv = ep->to;\n\t\t\t\t\tnt = t + ep->cost - potential[nv] + potential[v];\n\t\t\t\t\tif(ep->cap > 0 && dist[nv] > nt) {\n\t\t\t\t\t\tdist[nv] = nt;\n\t\t\t\t\t\tprevv[nv] = v, preve[nv] = i;\n\t\t\t\t\t\tenq(nv, nt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[T] == INF) return -1;\n\t\tfor (v = 0; v < V; v++) potential[v] += dist[v];\n\n\t\tt = F;\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tif (t > ep->cap) t = ep->cap;\n\t\t}\n\t\tF -= t;\n\n\t\tret += t * potential[T];\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tep->cap -= t;\n\t\t\tedge[v][ep->rev].cap += t;\n\t\t}\n    }\n\treturn ret;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint w[MAX], a[MAX], b[MAX], c[MAX], f[MAX];\n\nint main()\n{\n\tint M, N, K, i, cnt, ans;\n\tint as, cs;\n\n\tM = in(), N = in(), K = in();\n\tfor (i = 1; i <= N; i++) w[i] = in();\n\tfor (i = 1; i <= K; i++) b[i] = in();\n\tcnt = 0, as = 1, cs = 0; for (i = 1; i <= K; i++) {\n\t\tif (b[i] == b[i-1]) c[cs++] = b[i];\n\t\telse                a[as++] = b[i], cnt++;\n\t}\n\tfor (i = 0; i < cs; i++) a[as++] = c[i];\n\n\tV = cnt+1;\n\tans = 0; for (i = 1; i <= cnt; i++) {\n\t\tans += w[a[i]];\n\t\tif (f[a[i]]) add_edge(f[a[i]], i-1, 1, -w[a[i]]);\n\t\tf[a[i]] = i;\n\t}\n\tfor (i = 1; i < cnt; i++) add_edge(i, i+1, INF, 0);\n    printf(\"%d\\n\", ans + minCostFlow(1, cnt, M-1, 1));\n\treturn 0;\n}\n \n"
  },
  {
    "language": "C",
    "code": "// AOJ 2266 Cache Strategy\n// 2018.3.8 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 2000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 10005\ntypedef struct { int to, rev; int cap, cost; } EDGE;\nEDGE *edge[MAX]; int hi[MAX], lim[MAX];\nint V;\t\t\t\t// 頂点数\nint potential[MAX], dist[MAX], prevv[MAX], preve[MAX];\n\nvoid check_lim(int a)\n{\n\tif (hi[a] < lim[a]) return;\n\tif (lim[a] == 0) {\n\t\tlim[a] = 16, hi[a] = 0;\n\t\tedge[a] = malloc(sizeof(EDGE) *lim[a]);\n\t} else if (hi[a] == lim[a]) {\n\t\tint k = lim[a];\n\t\tif (k > 512) k = 512;\n\t\tlim[a] += k;\n\t\tedge[a] = realloc(edge[a], sizeof(EDGE) *lim[a]);\n\t}\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tint f, t;\n\tEDGE *ep;\n\n\tcheck_lim(from), check_lim(to);\n\tf = hi[from]++, t = hi[to]++;\n\tep = &edge[from][f], ep->to = to, ep->cap = cap, ep->cost = cost, ep->rev = t; \n\tep = &edge[to][t], ep->to = from, ep->cap = 0, ep->cost = -cost, ep->rev = f;\n}\n\nint minCostFlow(int S, int T, int F, int neg)\n{\n\tint i, v, nv, t, nt, update, ret;\n\tEDGE *ep;\n\n\tret = 0;\n//\tmemset(potential, 0, V << 2);\n  \n\twhile (F > 0) {\n\t\tmemset(dist, INF, V << 2);\n\t\tqsize = 0;\n\t\tdist[S] = 0;\n\t\tif (neg) {\n\t\t\tneg = 0;\n\t\t\tupdate = 1;\n\t\t\tdo {\n\t\t\t\tupdate = 0;\n\t\t\t\tfor (v = 0; v < V; v++) {\n\t\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\t\t\tep = &edge[v][i];\n\t\t\t\t\t\tif (ep->cap <= 0) continue;\n\t\t\t\t\t\tnv = ep->to;\n\t\t\t\t\t\tnt = dist[v] + ep->cost;\n\t\t\t\t\t\tif (dist[nv] > nt) {\n\t\t\t\t\t\t\tdist[nv] = nt, prevv[nv] = v, preve[ep->to] = i;\n\t\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (update);\n\t\t} else {\n\t\t\tenq(S, 0);\n\t\t\twhile (qsize) {\n\t\t\t\tv = que[0].s, t = que[0].t, deq();\n\t\t\t\tif (dist[v] < t) continue;\n\t\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\t\tep = &edge[v][i];\n\t\t\t\t\tif (ep->cap <= 0) continue;\n\t\t\t\t\tnv = ep->to;\n\t\t\t\t\tnt = t + ep->cost - potential[nv] + potential[v];\n\t\t\t\t\tif(dist[nv] > nt) {\n\t\t\t\t\t\tdist[nv] = nt;\n\t\t\t\t\t\tprevv[nv] = v, preve[nv] = i;\n\t\t\t\t\t\tenq(nv, nt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[T] == INF) return -1;\n\t\tfor (v = 0; v < V; v++) potential[v] += dist[v];\n\n\t\tt = F;\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tif (t > ep->cap) t = ep->cap;\n\t\t}\n\t\tF -= t;\n\n\t\tret += t * potential[T];\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tep->cap -= t;\n\t\t\tedge[v][ep->rev].cap += t;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint w[MAX], a[MAX], b[MAX], c[MAX], f[MAX];\n\nint main()\n{\n\tint M, N, K, i, cnt, ans;\n\tint as, cs;\n\n\tM = in(), N = in(), K = in();\n\tfor (i = 1; i <= N; i++) w[i] = in();\n\tfor (i = 1; i <= K; i++) b[i] = in();\n\tcnt = 0, as = 1, cs = 0; for (i = 1; i <= K; i++) {\n\t\tif (b[i] == b[i-1]) c[cs++] = b[i];\n\t\telse                a[as++] = b[i], cnt++;\n\t}\n\tfor (i = 0; i < cs; i++) a[as++] = c[i];\n\n\tV = cnt+1;\n\tans = 0; for (i = 1; i <= cnt; i++) {\n\t\tans += w[a[i]];\n\t\tif (f[a[i]]) add_edge(f[a[i]], i-1, 1, -w[a[i]]);\n\t\tf[a[i]] = i;\n\t}\n\tfor (i = 1; i < cnt; i++) add_edge(i, i+1, INF, 0);\n\tprintf(\"%d\\n\", ans + minCostFlow(1, cnt, M-1, 1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System.Numerics;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        public void Solve() {\n            var m = ri;\n            var n = ri;\n            var k = ri;\n            var w = Enumerate(n, x => ri);\n            var a = Enumerate(k, x => ri - 1);\n            var G = new MCF.MinCostFlow(k + 5);\n            var src = k + 3;\n            var sink = src + 1;\n            var s = new HashSet<int>();\n            var sum = 0;\n            var prev = Enumerate(n, x => -1);\n            G.AddDirectedEdge(src, 0, 1000000, 0);\n            G.AddDirectedEdge(k, sink, 1000000, 0);\n            for (int i = 0; i < k; i++) {\n                var id = a[i];\n                sum += w[id];\n                if (i + 1 < k) G.AddDirectedEdge(i, i + 1, 10000, 0);\n                if (prev[id] != -1) {\n                    if (prev[id] != i - 1)\n                        G.AddDirectedEdge(prev[id] + 1, i, 1, -w[id]);\n                    else sum -= w[id];\n                }\n                prev[id] = i;\n            }\n            s.Clear();\n            for (int i = k - 1; i >= 0; i--) {\n                var id = a[i];\n                if (s.Add(id) && s.Count <= m) G.AddDirectedEdge(i + 1, sink, 1, 0);\n            }\n            /*\n            for (int i = 0; i < G.G.Length; i++)\n                foreach (var e in G.G[i])\n                    if (e.Cap != 0) Console.WriteLine($\"{i} {e.To}\");\n            */\n            var ans = G.Execute(src, sink, m - 1);\n            Debug.WriteLine(ans);\n            Console.WriteLine(sum + ans.Value);\n        }\n\n        const long INF = 1L << 60;\n        //int[] dx = { -1, 0, 1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\nnamespace MCF {\n    using C = System.Int32;\n    using V = System.Int32;\n    #region MinCostFlow\n    public class MinCostFlow {\n        bool hasng;\n        public readonly List<Edge>[] G;\n        public MinCostFlow(int V) {\n            G = new List<Edge>[V];\n            for (int i = 0; i < V; i++)\n                G[i] = new List<Edge>();\n\n        }\n        public void AddDirectedEdge(int from, int to, C cap, V cost) {\n            addEdge(from, to, cap, 0, cost);\n        }\n\n        public KeyValuePair<C, V> Execute(int src, int sink, C f = C.MaxValue, V inf = V.MaxValue / 2) {\n            var n = G.Length;\n            var dist = new V[n];\n            var prev = new int[n];\n            var prevEdge = new Edge[n];\n            var potential = new V[n];\n\n\n            C flow = 0;\n            V cost = 0;\n            var first = hasng;\n            while (f > 0) {\n                for (int i = 0; i < G.Length; i++)\n                    dist[i] = inf;\n\n                //shortest path\n                if (first)//spfa\n                {\n                    var q = new Queue<int>();\n                    q.Enqueue(src); dist[src] = 0;\n                    var inQ = new bool[n];\n                    while (q.Count > 0) {\n                        var p = q.Dequeue();\n                        inQ[p] = false;\n                        foreach (var e in G[p]) {\n                            var t = e.To;\n                            var d = dist[p] + e.Cost;\n                            if (e.Cap > 0 && d < dist[t]) {\n                                if (!inQ[t]) {\n                                    inQ[t] = true;\n                                    q.Enqueue(t);\n                                }\n                                dist[t] = d; prev[t] = p; prevEdge[t] = e;\n                            }\n                        }\n                    }\n                    first = false;\n                }\n                else//dijkstra\n                {\n                    var vis = new bool[n];\n                    var pq = new PriorityQueue<KeyValuePair<int, V>>((l, r) => l.Value.CompareTo(r.Value));\n                    pq.Enqueue(new KeyValuePair<int, V>(src, 0));\n                    dist[src] = 0;\n                    while (pq.Count > 0) {\n                        var p = pq.Dequeue().Key;\n                        if (vis[p]) continue;\n                        Debug.WriteLine(p);\n                        vis[p] = true;\n                        foreach (var e in G[p]) {\n                            if (e.Cap <= 0) continue;\n                            var t = e.To;\n                            if (vis[t]) continue;\n                            var d = dist[p] + e.Cost + potential[p] - potential[t];\n                            if (dist[t] > d) {\n                                dist[t] = d; prev[t] = p; prevEdge[t] = e;\n                                pq.Enqueue(new KeyValuePair<int, V>(t, d));\n                            }\n                        }\n                    }\n\n\n                }\n\n\n                //update\n                {\n                    if (dist[sink] == inf) break;\n                    for (int i = 0; i < n; i++)\n                        potential[i] = Math.Min(inf, potential[i] + dist[i]);\n                    C df = f;\n                    V d = 0;\n                    for (var v = sink; v != src; v = prev[v]) {\n                        var e = prevEdge[v];\n                        df = Math.Min(df, e.Cap); d += e.Cost;\n                    }\n                    f -= df; cost += df * d; flow += df;\n                    for (var v = sink; v != src; v = prev[v]) {\n                        var e = prevEdge[v];\n                        e.Cap -= df; e.Rev.Cap += df;\n                    }\n                }\n\n            }\n            return new KeyValuePair<C, V>(flow, cost);\n        }\n        void addEdge(int f, int t, C c1, C c2, V e) {\n            if (e < 0) hasng = true;\n            var a = new Edge(t, c1, e);\n            var b = new Edge(f, c2, -e);\n            Edge.Link(a, b);\n            G[f].Add(a);\n            G[t].Add(b);\n        }\n        public class Edge {\n            public static void Link(Edge e1, Edge e2) {\n                e1.Rev = e2; e2.Rev = e1;\n            }\n            public int To { get; private set; }\n            public Edge Rev { get; private set; }\n            public V Cost { get; private set; }\n            public C Cap { get; set; }\n            public Edge(int t, C c, V e) {\n                To = t;\n                Cap = c;\n                Cost = e;\n            }\n            public override string ToString() {\n                return string.Format(\"to: {0}, cap: {1}\", To, Cap);\n            }\n        }\n    }\n    #endregion\n}\n#region BinaryHeap\npublic class PriorityQueue<T> {\n    readonly List<T> heap = new List<T>();\n    readonly Comparison<T> compare;\n    public PriorityQueue() { compare = Comparer<T>.Default.Compare; }\n\n    public PriorityQueue(Comparison<T> comparison) { compare = comparison; }\n    public PriorityQueue(IComparer<T> comparer) { compare = comparer.Compare; }\n\n    public void Enqueue(T item) {\n        var pos = heap.Count;\n        heap.Add(item);\n        while (pos > 0) {\n            var par = (pos - 1) / 2;\n            if (compare(heap[par], item) <= 0)\n                break;\n            heap[pos] = heap[par];\n            pos = par;\n        }\n        heap[pos] = item;\n\n    }\n\n    public T Dequeue() {\n        var ret = heap[0];\n        var pos = 0;\n        var x = heap[heap.Count - 1];\n\n        while (pos * 2 + 1 < heap.Count - 1) {\n            var lch = pos * 2 + 1;\n            var rch = pos * 2 + 2;\n            if (rch < heap.Count - 1 && compare(heap[rch], heap[lch]) < 0) lch = rch;\n            if (compare(heap[lch], x) >= 0)\n                break;\n            heap[pos] = heap[lch];\n            pos = lch;\n        }\n        heap[pos] = x;\n        heap.RemoveAt(heap.Count - 1);\n        return ret;\n\n    }\n    public T Peek() { return heap[0]; }\n    public int Count { get { return heap.Count; } }\n    public bool Any() { return heap.Count > 0; }\n\n    public T[] Items {\n        get {\n            var ret = heap.ToArray();\n            Array.Sort(ret, compare);\n            return ret;\n        }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import defaultdict\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass MinCostFlow:\n    \"\"\" 最小費用流(ダイクストラ版)：O(F*E*logV) \"\"\"\n\n    INF = 10 ** 18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        G = self.G\n        G[fr].append([to, cap, cost, len(G[to])])\n        G[to].append([fr, 0, -cost, len(G[fr])-1])\n\n    def flow(self, s, t, f):\n        from heapq import heappush, heappop\n\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0] * N\n        prv_v = [0] * N\n        prv_e = [0] * N\n\n        while f:\n            dist = [INF] * N\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                for i, (to, cap, cost, _) in enumerate(G[v]):\n                    if cap > 0 and dist[to] > dist[v] + cost + H[v] - H[to]:\n                        dist[to] = r = dist[v] + cost + H[v] - H[to]\n                        prv_v[to] = v; prv_e[to] = i\n                        heappush(que, (r, to))\n            if dist[t] == INF:\n                return INF\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prv_v[v]][prv_e[v]][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = G[prv_v[v]][prv_e[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prv_v[v]\n        return res\n\nM, N, K = MAP()\nA = LIST(N)\nB = [b-1 for b in LIST(K)]\n\n# 隣り合う同値を取り除いておく\nB2 = [B[0]]\nfor i in range(1, K):\n    if B[i-1] != B[i]:\n        B2.append(B[i])\nK2 = len(B2)\n\n# 同じ値が次に出現する位置を調べておく\nnxt = [INF] * K2\nD = defaultdict(lambda: INF)\ntotal = 0\nfor i in range(K2-1, -1, -1):\n    b = B2[i]\n    nxt[i] = D[b]\n    D[b] = i\n    total += A[b]\n\nmcf = MinCostFlow(K2)\n# 負コストを避けるための調整用\nMAX = 10 ** 4\nfor i in range(K2-1):\n    b = B2[i]\n    # 残さない場合は利得0とする\n    mcf.add_edge(i, i+1, M-1, MAX)\n    j = nxt[i]\n    if j != INF:\n        # 残しておくと、残さない場合にかかるコスト分の利得があるとみなす\n        mcf.add_edge(i+1, j, 1, MAX*(j-i-1) - A[b])\n\nres = MAX*(K2-1)*(M-1) - mcf.flow(0, K2-1, M-1)\nprint(total - res)\n\n"
  }
]