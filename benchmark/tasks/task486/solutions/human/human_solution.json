[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\nstruct w {\n\tvector<int>vs;\n\tw operator-()const {\n\t\tvector<int>a(53);\n\t\tfor (int i = 0; i < 53; ++i) {\n\t\t\ta[i] = -vs[i];\n\t\t}\n\t\treturn w{ a };\n\t}\n\tw() :vs(53){\n\t\t\n\t}\n\tw(const vector<int>&v_) :vs(v_) {\n\n\t}\n};\nw operator +(const w&l, const w&r) {\n\tvector<int>pluss(53);\n\tfor (int i = 0; i < 53; ++i) {\n\t\tpluss[i] = l.vs[i] + r.vs[i];\n\t}\n\treturn w{ pluss };\n}\nw operator-(const w&l, const w&r) {\n\tvector<int>pluss(53);\n\tfor (int i = 0; i < 53; ++i) {\n\t\tpluss[i] = l.vs[i] - r.vs[i];\n\t}\n\treturn w{ pluss };\n}\nw operator*(const int&l, const w&r) {\n\tvector<int>ks(53);\n\t{\n\t\tfor (int i = 0; i < 53; ++i) {\n\t\t\tks[i] = l*r.vs[i];\n\t\t}\n\t}\n\treturn ks;\n}\nbool operator==(const w&l, const w&r) {\n\treturn l.vs == r.vs;\n}\nbool operator<(const w&l, const w&r) {\n\tfor (int i = 52; i >=0; --i) {\n\t\tif (l.vs[i] != r.vs[i])return l.vs[i] < r.vs[i];\n\t}\n\treturn false;\n}\nbool operator>(const w&l, const w&r) {\n\tfor (int i = 52; i >= 0; --i) {\n\t\tif (l.vs[i] != r.vs[i])return l.vs[i] > r.vs[i];\n\t}\n\treturn false;\n}\n\ntypedef w  Weight;\nstruct Edge {\n\tint src, dest;\n\tint cap, rev;\n\tWeight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\nconst int V = 4000;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nWeight h[V];                //??????????????£???\nWeight dist[V];             //???????????¢\nint prevv[V], preve[V];  //??´???????????¨??????\n\nvoid add_edge(Graph &g, int src, int dest, int cap, Weight weight_) {\n\tg[src].push_back(Edge{ src, dest, cap, (int)g[dest].size(), weight_ });\n\tg[dest].push_back(Edge{ dest, src, 0, (int)g[src].size() - 1, -weight_ });\n}\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nw INF;\nWeight min_cost_flow(Graph &g, int s, int t, int f) {\n\tWeight res;\n\tfill(dist, dist + V, vector<int>(53,0));\n\ttypedef pair<Weight, int> P;\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s]=vector<int>(53,0);\n\t\tque.push(P(vector<int>(53,0), s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.weight + h[v] - h[e.dest]) {\n\t\t\t\t\tdist[e.dest] = dist[v] + e.weight + h[v] - h[e.dest];\n\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\tque.push(P(dist[e.dest], e.dest));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] > INF||dist[t]==INF) return vector<int>();\n\t\tREP(v, V) h[v] =h[v]+dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) d = min(d, g[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres =res+ d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tvector<int>inf(53);\n\tinf[52] = 1;\n\tINF = inf;\n\tint N; cin >> N;\n\tvector<vector<int>>field(N, vector<int>(N));\n\tfor (int i = 0; i < N; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (st[j] >= 'A'&&st[j] <= 'Z') {\n\t\t\t\tfield[i][j] = st[j] - 'A';\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = st[j] - 'a'+26;\n\t\t\t}\n\t\t}\n\t}\n\tconst int start = 0;\n\tconst int row = 1;\n\tconst int col = row + N;\n\tconst int goal = col + N;\n\tGraph g(goal+1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tadd_edge(g, start, row + i, 1, w{});\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tvector<int>v(53);\n\t\t\tv[field[i][j]]++;\n\t\t\tadd_edge(g, row + i, col + j, 1, w{ v });\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tadd_edge(g, col + i, goal, 1, w{});\n\t}\n\tauto ans = min_cost_flow(g, start, goal, N);\n\tstring st;\n\tfor (int i = 0; i < 52; ++i) {\n\t\tfor (int j = 0; j < ans.vs[i]; ++j) {\n\t\t\tif (i < 26)st.push_back('A' + i);\n\t\t\telse st.push_back('a' + i - 26);\n\t\t}\n\t}\n\tcout << st << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define MAX_N 1000\nusing namespace std;\n\nstruct edge{int to, cap,cost,rev;};\nint V;\nvector<edge> G[MAX_V];\nvector<int> dist[MAX_V];\nconst vector<int> INF(1<<8,1000);\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  while(f>0){\n    for(int i=0;i<V;i++) dist[i]=INF;\n    dist[s]=vector<int>(1<<8,0);\n\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  vector<int> ncost=dist[v];\n\t  if(e.cost!=0)ncost[abs(e.cost)]+=e.cost/abs(e.cost);\n\t  \n\t  if(e.cap > 0 && dist[e.to] > ncost){\n\t    dist[e.to] = ncost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1;    \n\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return 1;\n}\n\n\nint can[MAX_N][MAX_N];\nint Biparite_Matching(int N,int K){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)add_edge(i, N+j,1,can[i][j]);\n  V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\n\n\nint main(){\n  int n;\n  cin>>n;\n  string mp[51];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)can[i][j] = -mp[i][j];\n\n  Biparite_Matching(n,n);\n  string ans;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++)\n      if(G[i][j].cap==0) ans+=mp[i][G[i][j].to-n];\n  sort(ans.begin(),ans.end());\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  string s[n],ans,tmp;\n  for(int i=0;i<n;i++) cin>>s[i];\n  for(int i=0;i<n;i++) ans+=s[i][i];\n  sort(ans.begin(),ans.end());\n  bool f=1;\n  time_t ti=clock();\n  srand((unsigned)time(NULL));\n  while((double)(clock()-ti)/CLOCKS_PER_SEC<1.7){\n    if(f==0){\n      for(int k=0;k<50;k++){\n\tint i=rand()%n,j=rand()%n,a=rand()%n,b=rand()%n;\n\tfor(int l=0;l<n;l++) swap(s[i][l],s[a][l]);\n\tfor(int l=0;l<n;l++) swap(s[l][j],s[l][b]);\n      }\n    }\n    f=0;\n    for(int i=0;!f&&i<n;i++){\n      for(int j=0;!f&&j<n;j++){\n\tfor(int a=0;!f&&a<n;a++){\n\t  for(int b=0;!f&&b<n;b++){\n\t    char p[4]={s[i][i],s[a][a],s[j][j],s[b][b]};\n\t    char q[4]={s[a][i],s[i][a],s[j][b],s[b][j]};\n\t    sort(p,p+4);sort(q,q+4);\n\t    for(int l=0;l<4;l++){\n\t      f|=p[l]>q[l];\n\t      if(p[l]<q[l]) break;\n\t    }\n\t    if(f){\n\t      for(int l=0;l<n;l++) swap(s[i][l],s[a][l]);\n\t      for(int l=0;l<n;l++) swap(s[l][j],s[l][b]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    tmp=\"\";\n    for(int i=0;i<n;i++) tmp+=s[i][i];\n    sort(tmp.begin(),tmp.end());\n    if(tmp.compare(ans)<0) ans=tmp;\n  }\n  //for(int i=0;i<n;i++) cout<<s[i]<<endl;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\n#include <time.h>\nusing namespace std;\nlong double esp=1e-11;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define cle(a) while(!a.empty())a.pop()\n#define mem(p) memset(p,0,sizeof(p))\n#define memf(p) memset(p,0x3f,sizeof(p))\n#define memn(p) memset(p,-1,sizeof(p))\n#define mp(A, B) make_pair(A, B)\n#define pb push_back\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\ntypedef long long int LL;\nconst long double PI = acos((long double)-1);\nconst LL INF=0x3f3f3f3fll;\nconst int MOD = 1000000007;\nconst int maxn=110000;\n#define V 110\n#define E 45100\nint vis[V];\nint dist[V];\nint pre[V];\n\nstruct Edge{\n    int u,v,c,cost,next;\n}edge[E];\nint head[V],cnt;\n\nvoid init(){\n    cnt=0;\n    memset(head,-1,sizeof(head));\n}\nvoid addedge(int u,int v,int c,int cost)\n{\n    edge[cnt].u=u;edge[cnt].v=v;edge[cnt].cost=cost;\n    edge[cnt].c=c;edge[cnt].next=head[u];head[u]=cnt++;\n\n    edge[cnt].u=v;edge[cnt].v=u;edge[cnt].cost=-cost;\n    edge[cnt].c=0;edge[cnt].next=head[v];head[v]=cnt++;\n}\n\nbool spfa(int begin,int end){\n    int u,v;\n    queue<int> q;\n    for(int i=0;i<=end+2;i++){\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=INF;\n    }\n    vis[begin]=1;\n    dist[begin]=0;\n    q.push(begin);\n    while(!q.empty()){\n        u=q.front();\n        q.pop();\n        vis[u]=0;\n        for(int i=head[u];i!=-1;i=edge[i].next){\n            if(edge[i].c>0){\n                v=edge[i].v;\n                if(dist[v]>dist[u]+edge[i].cost){\n                    dist[v]=dist[u]+edge[i].cost;\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    return dist[end]!=INF;\n}\n\nint MCMF(int begin,int end){\n    int ans=0,flow;\n    int flow_sum=0;\n    while(spfa(begin,end)){\n        flow=INF;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u])\n            if(edge[i].c<flow)\n                flow=edge[i].c;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u]){\n            edge[i].c-=flow;\n            edge[i^1].c+=flow;\n        }\n        ans+=dist[end];\n        flow_sum += flow;\n    }\n    //cout << flow_sum << endl;\n    return ans;\n}\nchar s[66];\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"inlay.in\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    //map<long long int,int>ma;                 %I64d\n    //vector<int>::iterator iter;\n    //memset(m,0,sizeof(int));\n    //for(int x=1;x<=n;x++)\n    //for(int y=1;y<=n;y++)\n    //scanf(\"%d%d\",&a,&b);\n    //scanf(\"%d\",&a);\n    //printf(\"%d\\n\",ans);\n    int n;\n    scanf(\"%d\",&n);\n    init();\n    int st=105,ed=106;\n    for(int x=0;x<n;x++)\n        addedge(st,x,1,0),addedge(n+x,ed,1,0);\n\n    for(int x=0;x<n;x++)\n    {\n        scanf(\"%s\",s);\n        for(int y=0;y<n;y++)\n            addedge(x,n+y,1,s[y]);\n    }\n    MCMF(st,ed);\n    vector<char>ans;\n    ans.clear();\n    for(int x=0;x<cnt;x++)\n        if(edge[x].u>=n&&edge[x].u<2*n&&edge[x].v<n&&edge[x].c>0)\n            ans.pb(-edge[x].cost);\n    sort(all(ans));\n    for(int x=0;x<n;x++)putchar(ans[x]);putchar('\\n');\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\n#include <time.h>\nusing namespace std;\nlong double esp=1e-11;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define cle(a) while(!a.empty())a.pop()\n#define mem(p) memset(p,0,sizeof(p))\n#define memf(p) memset(p,0x3f,sizeof(p))\n#define memn(p) memset(p,-1,sizeof(p))\n#define mp(A, B) make_pair(A, B)\n#define pb push_back\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\ntypedef long long int LL;\nconst long double PI = acos((long double)-1);\nconst LL INF=0x3f3f3f3fll;\nconst int MOD = 1000000007;\nconst int maxn=110000;\ntypedef  struct {int v,next,val;} edge;\nconst int MAXN=110;\nconst int MAXM=30010;\n\nedge e[MAXM];\nint p[MAXN],eid;\n\ninline void init(){memset(p,-1,sizeof(p));eid=0;}\n\n//??????\ninline void insert1(int from,int to,int val)\n{\n    e[eid].v=to;\n    e[eid].val=val;\n    e[eid].next=p[from];\n    p[from]=eid++;\n\n    swap(from,to);\n\n    e[eid].v=to;\n    e[eid].val=0;\n    e[eid].next=p[from];\n    p[from]=eid++;\n}\n\nint N=MAXN;//n????????° m????????°\nint h[MAXN];\nint gap[MAXN];\n\nint source,sink;\ninline int dfs(int pos,int cost)\n{\n    if (pos==sink)\n    {\n        return cost;\n    }\n\n    int j,minh=N-1,lv=cost,d;\n\n    for (j=p[pos];j!=-1;j=e[j].next)\n    {\n        int v=e[j].v,val=e[j].val;\n        if(val>0)\n        {\n            if (h[v]+1==h[pos])\n            {\n                if (lv<e[j].val) d=lv;\n                else d=e[j].val;\n\n                d=dfs(v,d);\n                e[j].val-=d;\n                e[j^1].val+=d;\n                lv-=d;\n                if (h[source]>=N) return cost-lv;\n                if (lv==0) break;\n            }\n\n            if (h[v]<minh)    minh=h[v];\n        }\n    }\n\n    if (lv==cost)\n    {\n        --gap[h[pos]];\n        if (gap[h[pos]]==0) h[source]=N;\n        h[pos]=minh+1;\n        ++gap[h[pos]];\n    }\n\n    return cost-lv;\n\n}\n\nint sap(int st,int ed)\n{\n\n    source=st;\n    sink=ed;\n    int ret=0;\n    memset(gap,0,sizeof(gap));\n    memset(h,0,sizeof(h));\n\n    gap[st]=N;\n\n    while (h[st]<N)\n    {\n        ret+=dfs(st,INT_MAX);\n    }\n\n    return ret;\n}\nchar s[55][55];\nint dx[55],dy[55];\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"inlay.in\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    //map<long long int,int>ma;                 %I64d\n    //vector<int>::iterator iter;\n    //memset(m,0,sizeof(int));\n    //for(int x=1;x<=n;x++)\n    //for(int y=1;y<=n;y++)\n    //scanf(\"%d%d\",&a,&b);\n    //scanf(\"%d\",&a);\n    //printf(\"%d\\n\",ans);\n    mem(dx);\n    mem(dy);\n    int n;\n    scanf(\"%d\",&n);\n    int st=105,ed=106;\n    for(int x=0;x<n;x++)\n        scanf(\"%s\",s[x]);\n    vector<int>ans;\n    ans.clear();\n    for(int z='A';z<='z';(z=='Z')?z='a':z++)\n    {\n        init();\n        for(int x=0;x<n;x++)\n        if(!dx[x])\n        insert1(st,x+1,1);\n        for(int y=0;y<n;y++)\n        if(!dy[y])\n        insert1(n+y+1,ed,1);\n        for(int x=0;x<n;x++)\n            for(int y=0;y<n;y++)\n            if(s[x][y]==z&&!dx[x]&&!dy[y])\n            {\n                insert1(x+1,n+y+1,1);\n            }\n        sap(st,ed);\n        for(int x=n+1;x<=2*n;x++)\n        {\n            for (int j=p[x];j!=-1;j=e[j].next)\n            if(e[j].v<=n&&e[j].val>0)\n            {\n                ans.pb(z);\n                dx[e[j].v-1]=1;\n                dy[x-n-1]=1;\n            }\n        }\n    }\n    sort(all(ans));\n    for(int x=0;x<n;x++)\n        printf(\"%c\",ans[x]);\n    putchar(10);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tSMALL,\n\tBIG,\n\tEQUAL,\n};\n\n#define NUM 150\n#define DIGIT 53\n\n//辺を表す構造体{行先、容量、コスト、逆辺のインデックス}\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_num,int arg_rev_index,bool is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tnum = arg_num;\n\t\tfor(int i = 0; i < DIGIT; i++)cost[i] = 0;\n\t\tif(num != -1){\n\t\t\tif(is_rev == false){\n\t\t\t\tcost[num] = 1;\n\t\t\t}else{\n\t\t\t\tcost[num] = -1;\n\t\t\t}\n\t\t}\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,num,cost[DIGIT],rev_index;\n};\n\nint V; //頂点数\nint H,W;\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint dist[NUM][DIGIT]; //最短距離\nint pre_node[NUM],pre_edge[NUM]; //直前の頂点と辺\nchar base_map[50][51];\n\n\n//桁0～51を、'A'～'z'に対応させる。桁52はBIG_NUMの重み\nint getNUM(char ch){\n\n\tif(ch >= 'A' && ch <= 'Z'){\n\t\treturn ch - 'A';\n\t}else{\n\t\treturn ch - 'a'+26;\n\t}\n}\n\nint getCHAR(int num){\n\n\tif(num <= 25){\n\t\treturn 'A'+num;\n\t}else{\n\t\treturn 'a'+num-26;\n\t}\n}\n\n\n//fromからtoへ向かう容量capacity,コストcostの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity,int arg_num){\n\tG[from].push_back(Edge(to,capacity,arg_num,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,arg_num,G[from].size()-1,true));\n}\n\n//SMALL:Aの方が小さい BIG:Aの方が大きい EQUAL:同じ\nType compare_cost(int cost_A[DIGIT],int cost_B[DIGIT]){\n\n\tfor(int i = DIGIT-1; i >= 0; i--){\n\t\tif(cost_A[i] != cost_B[i]){\n\t\t\tif(cost_A[i] < cost_B[i]){\n\t\t\t\treturn SMALL;\n\t\t\t}else{\n\t\t\t\treturn BIG;\n\t\t\t}\n\t\t}\n\t}\n\treturn EQUAL;\n}\n\nbool is_big_num(int array[DIGIT]){\n\n\treturn array[DIGIT-1] == 1;\n}\n\n//sourceからsinkへの、流量flowの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\n\tint work[DIGIT];\n\n\twhile(flow > 0){\n\t\t//ベルマンフォード方により、source-sink間最短経路を求める\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int k = 0; k < DIGIT-1; k++)dist[i][k] = 0;\n\t\t\tdist[i][DIGIT-1] = 1; //BIG_NUM扱い\n\t\t}\n\n\t\tdist[source][DIGIT-1] = 0; //全桁0→コスト0扱い\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int node_id = 0; node_id < V; node_id++){\n\t\t\t\tif(is_big_num(dist[node_id]))continue; //辿り着けない\n\t\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\t\tEdge &e = G[node_id][i];\n\n\t\t\t\t\tfor(int i = 0; i < DIGIT; i++)work[i] = dist[node_id][i]+e.cost[i]; //★配列形式のコスト★\n\n\t\t\t\t\tif(e.capacity > 0 && compare_cost(work,dist[e.to]) == SMALL){\n\n\t\t\t\t\t\tfor(int i = 0; i < DIGIT; i++)dist[e.to][i] = work[i]; //node_idを経由した方が早い場合\n\t\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(is_big_num(dist[sink])){\n\t\t\t//これ以上流せない\n\t\t\treturn -1;\n\t\t}\n\n\t\t//source-sink間最短路に沿って目いっぱい流す\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\t//printf(\"flow:%d\\n\",flow);\n\t\tret += 0; //戻り値不要\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint size;\n\n\tscanf(\"%d\",&size);\n\tH = size;\n\tW = H;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tint source = 0,sink = 1,index = 2;\n\tint index_row[H],index_col[W];\n\n\tfor(int row = 0; row < H; row++)index_row[row] = index++;\n\tfor(int col = 0; col < W; col++)index_col[col] = index++;\n\n\tfor(int i = 0; i < size; i++){\n\t\tadd_edge(source,index_row[i],1,-1); //sourceから行ノードにcap1,cost0の辺を張る\n\t}\n\n\tfor(int i = 0; i < size; i++){\n\t\tadd_edge(index_col[i],sink,1,-1); //列ノードから行ノードにcap1,cost0の辺を張る\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tadd_edge(index_row[row],index_col[col],1,getNUM(base_map[row][col])); //行と列を、文字のコストで結ぶ\n\t\t}\n\t}\n\n\n\tV = index;\n\tmin_cost_flow(source,sink,size);\n\n\tvector<int> ANS;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int i = 0; i < G[index_row[row]].size(); i++){\n\t\t\tif(G[index_row[row]][i].capacity == 0){ //フローが流れた辺の値を取得する\n\t\t\t\tANS.push_back(G[index_row[row]][i].num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(ANS.begin(),ANS.end());\n\n\tfor(int i = 0; i < size; i++)printf(\"%c\",getCHAR(ANS[i]));\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\tvector<vector<char>> c(N, vector<char>(N));\n\tvector<char> ch;\n\trep(i, 0, N) rep(j, 0, N) { cin >> c[i][j]; ch.emplace_back(c[i][j]); }\n\tsort(all(ch));\n\tch.erase(unique(ch.begin(), ch.end()), ch.end());\n\tvector<int> r;\n\tsrand(time(NULL));\n\twhile (r.size() < ch.size()) {\n\t\tint a = rand();\n\t\tif (find(r.begin(), r.end(), a) == r.end())\n\t\t\tr.emplace_back(a);\n\t}\n\tsort(all(r));\n\tint w[128];\n\trep(i, 0, ch.size())w[ch[i]] = r[i];\n\tMinimumCostFlow mcf(N + N + 2);\n\tint s = mcf.n - 2, t = s + 1;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tmcf.addArc(i, N + j, 1, w[c[i][j]]);\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tmcf.addArc(s, i, 1, 0);\n\t\tmcf.addArc(N + i, t, 1, 0);\n\t}\n\tmcf.minimumCostFlow(s, t, N);\n\tvector<char> ans;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif (mcf.g[i][j].cap == 0)\n\t\t\t\tans.emplace_back(c[i][j]);\n\t\t}\n\t}\n\tsort(all(ans));\n\trep(i, 0, ans.size())\n\t\tcout << ans[i];\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  string s[n],ans,tmp;\n  for(int i=0;i<n;i++) cin>>s[i];\n  /*\n  for(int k=0;k<n-1;k++){\n    int ti=k,tj=k;\n    for(int i=k;i<n;i++){\n      for(int j=k;j<n;j++){\n\tif(s[ti][tj]==s[i][j]){\n\t  char p='z',q='z';\n\t  for(int a=k;a<n;a++){\n\t    for(int b=k;b<n;b++){\n\t      if(a==i||b==j) p=min(p,s[a][b]);\n\t      if(a==ti||b==tj) q=min(q,s[a][b]);\n\t    }\n\t  }\n\t  if(p>q) ti=i,tj=j;\n\t}\n\tif(s[ti][tj]>s[i][j]) ti=i,tj=j;\n      }\n    }\n    swap(s[ti],s[k]);\n    for(int l=0;l<n;l++) swap(s[l][tj],s[l][k]);\n  }\n  */\n  bool f=1;\n  while(f){\n    tmp=ans=\"\";\n    for(int i=0;i<n;i++) tmp+=s[i][i];\n    sort(tmp.begin(),tmp.end());\n    f=0;\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  if(i==j) continue;\n\t  if(s[i][j]<s[k][k]){\n\t    if((s[j][j]>=s[j][k]&&s[k][k]>s[j][k])||\n\t       (s[i][i]>=s[k][i]&&s[k][k]>s[k][i])) {\n\t      swap(s[i],s[k]);\n\t      for(int l=0;l<n;l++) swap(s[l][j],s[l][k]);\n\t      f=1;\n\t    }\n\t  }\n\t}\n      }\n    }\n    //cout<<endl;for(int i=0;i<n;i++) cout<<s[i]<<endl;\n    for(int i=0;i<n;i++) ans+=s[i][i];\n    sort(ans.begin(),ans.end());\n    if(ans==tmp) break;\n  }\n  //for(int i=0;i<n;i++) cout<<s[i]<<endl;\n  //for(int i=0;i<n;i++) ans+=s[i][i];\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = 1000;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing W = vi;\nusing edge = struct {int to, rev, cap, flow; W cost;};\nusing G = vector<vector<edge>>;\n\nconst int N = 52;\n\nW operator+(const W& lhs, const W& rhs){\n    vi ret = lhs;\n    rep(i, lhs.size()){\n        ret[i] += rhs[i];\n    }\n    return ret;\n}\nW operator+=(W& lhs, const W& rhs){\n    rep(i, lhs.size()){\n        lhs[i] += rhs[i];\n    }\n    return lhs;\n}\nW operator-=(W& lhs, const W& rhs){\n    rep(i, lhs.size()){\n        lhs[i] -= rhs[i];\n    }\n    return lhs;\n}\nW operator*(const int& lhs, const W& rhs){\n    W ret = rhs;\n    rep(i, ret.size()){\n        ret[i] *= lhs;\n    }\n    return ret;\n}\nW operator-(W x){\n    rep(i, x.size()){\n        x[i] *= -1;\n    }\n    return x;\n}\n\nvoid add_edge(G &graph, int from, int to, int cap, W cost) {\n    graph[from].push_back({to, int(graph[to].size()) , cap , 0 , cost});\n    graph[to].push_back({from, int(graph[from].size()) - 1, 0 , 0, -cost});\n}\n\nW primal_dual(G &graph, int s, int t, int f) {\n    const W inf = W(N, INF);\n    W res = W(N, 0);\n    while (f) {\n        int n = graph.size(), update;\n        vector<W> dist(n, inf);\n        vector<int> pv(n, 0), pe(n, 0);\n        dist[s] = vi(N);\n\n        rep(loop, n) {\n            update = false;\n            rep(v, n)rep(i, graph[v].size()) {\n                edge &e = graph[v][i];\n                if (e.cap > e.flow and chmin(dist[e.to], dist[v] + e.cost)) {\n                    pv[e.to] = v, pe[e.to] = i;\n                    update = true;\n\n                }\n            }\n            if (!update) break;\n        }\n\n        if (dist[t] == inf) return inf;\n\n        int d = f;\n\n        for (int v = t; v != s; v = pv[v]){\n            chmin(d, graph[pv[v]][pe[v]].cap - graph[pv[v]][pe[v]].flow);\n        }\n\n        f -= d, res += d * dist[t];\n\n        for (int v = t; v != s; v = pv[v]) {\n            edge &e = graph[pv[v]][pe[v]];\n            e.flow += d;\n            graph[v][e.rev].flow -= d;\n        }\n    }\n    return res;\n}\n\nW i2v(int i){\n    W ret(N);\n    if(i >= 0) ret[i] = -1;\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n; cin >> n;\n    vector<string> plates(n); for(auto& e : plates) cin >> e;\n\n    G graph(2 * n + 2);\n    int s = 2 * n, t = s + 1;\n    map<char, int> c2i;\n    map<int, char> i2c;\n    int cnt = 0;\n    for(auto c = 'A'; c <= 'Z'; c++) { c2i[c] = cnt; i2c[cnt] = c; cnt++; }\n    for(auto c = 'a'; c <= 'z'; c++) { c2i[c] = cnt; i2c[cnt] = c; cnt++; }\n\n    rep(i, n){\n        rep(j, n){\n            int cur = c2i[plates[i][j]];\n            add_edge(graph, i, n + j, 1, i2v(cur));\n        }\n    }\n    rep(i, n){\n        add_edge(graph, s, i, 1, i2v(-1));\n        add_edge(graph, n + i, t, 1, i2v(-1));\n    }\n\n    W tbl = primal_dual(graph, s, t, n);\n    string res;\n    rep(i, N){\n        if(tbl[i] < 0) res += string(-tbl[i], i2c[i]);\n    }\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 500\n#define INF (1e9)\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint MAXC;\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  \n  int n;\n  cin>>n;\n\n  V=n*2+2;\n\n  string str;\n  \n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<n;j++)\n      add_edge(i,j+n,1,(int)str[j]);\n  }\n\n  int s=n*2,t=s+1;\n\n  for(int i=0;i<n;i++)\n    add_edge(s,i,1,0);\n  \n  for(int i=0;i<n;i++)\n    add_edge(i+n,t,1,0);\n  \n  MAXC='A';\n  while(1){\n    int r=min_cost_flow(s,t,n);\n    if(r!=-1)break;\n    else min_cost_flow(t,s,n);\n    MAXC++;\n  }\n  string ans;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++)\n      if(!G[i][j].cap)ans+=(char)G[i][j].cost;\n  \n  sort(ans.begin(),ans.end());\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\tvector<vector<char>> c(N, vector<char>(N));\n\tvector<char> ch;\n\trep(i, 0, N) rep(j, 0, N) { cin >> c[i][j]; ch.emplace_back(c[i][j]); }\n\tsort(all(ch));\n\tch.erase(unique(ch.begin(), ch.end()), ch.end());\n\tvector<int> r;\n\tsrand(time(NULL));\n\twhile (r.size() < ch.size()) {\n\t\tint a = rand();\n\t\tif (find(r.begin(), r.end(), a) == r.end())\n\t\t\tr.emplace_back(a);\n\t}\n\tsort(all(r));\n\tint w[128];\n\trep(i, 0, ch.size())w[ch[i]] = r[i];\n\tMinimumCostFlow mcf(N + N + 2);\n\tint s = mcf.n - 2, t = s + 1;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tmcf.addArc(i, N + j, 1, w[c[i][j]]);\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tmcf.addArc(s, i, 1, 0);\n\t\tmcf.addArc(N + i, t, 1, 0);\n\t}\n\tmcf.minimumCostFlow(s, t, N);\n\tvector<char> ans;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif (mcf.g[i][j].cap == 0)\n\t\t\t\tans.emplace_back(c[i][j]);\n\t\t}\n\t}\n\tsort(all(ans));\n\trep(i, 0, ans.size())\n\t\tcout << ans[i];\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) begin(a),end(a)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct BigInt {\n\tstatic const int kBase = 1000000000;\n\tstatic const int kBaseDigits = 9;\n\tvector<int> d;\n\tint sign;\n\tBigInt() :sign(1) {}\n\tBigInt(long long v) {\n\t\tsign = 1;\n\t\tif (v < 0)\n\t\t\tsign = -1, v = -v;\n\t\tfor (; v > 0; v = v / kBase)\n\t\t\td.emplace_back(v % kBase);\n\t}\n\tBigInt(const string &s) { read(s); }\n\n\tbool operator<(const BigInt &v)const {\n\t\tif (sign != v.sign)\n\t\t\treturn sign < v.sign;\n\t\tif (d.size() != v.d.size())\n\t\t\treturn d.size() * sign < v.d.size() * v.sign;\n\t\tfor (int i = d.size() - 1; i >= 0; i--)\n\t\t\tif (d[i] != v.d[i])\n\t\t\t\treturn d[i] * sign < v.d[i] * sign;\n\t\treturn false;\n\t}\n\tbool operator>(const BigInt &v)const { return v < *this; }\n\tbool operator<=(const BigInt &v)const { return !(v < *this); }\n\tbool operator>=(const BigInt &v)const { return !(*this < v); }\n\tbool operator==(const BigInt &v)const { return !(*this < v) && !(v < *this); }\n\tbool operator!=(const BigInt &v)const { return !(*this == v); }\n\n\tBigInt &operator+=(const BigInt &v) {\n\t\tif (sign == v.sign) {\n\t\t\tBigInt res = v;\n\t\t\tfor (int i = 0, carry = 0; i < (int)max(d.size(), v.d.size()) || carry; ++i) {\n\t\t\t\tif (i == (int)res.d.size())\n\t\t\t\t\tres.d.emplace_back(0);\n\t\t\t\tres.d[i] += carry + (i < (int)d.size() ? d[i] : 0);\n\t\t\t\tcarry = res.d[i] >= kBase;\n\t\t\t\tif (carry)\n\t\t\t\t\tres.d[i] -= kBase;\n\t\t\t}\n\t\t\treturn *this = res;\n\t\t}\n\t\telse\n\t\t\treturn *this -= (-v);\n\t}\n\tBigInt &operator-=(const BigInt &v) {\n\t\tif (sign == v.sign) {\n\t\t\tBigInt tmp = abs();\n\t\t\tif (abs() >= v.abs()) {\n\t\t\t\tBigInt res = *this;\n\t\t\t\tfor (int i = 0, carry = 0; i < (int)v.d.size() || carry; ++i) {\n\t\t\t\t\tres.d[i] -= carry + (i < (int)v.d.size() ? v.d[i] : 0);\n\t\t\t\t\tcarry = res.d[i] < 0;\n\t\t\t\t\tif (carry)\n\t\t\t\t\t\tres.d[i] += kBase;\n\t\t\t\t}\n\t\t\t\tres.trim();\n\t\t\t\treturn *this = res;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn *this = -(v - *this);\n\t\t}\n\t\telse\n\t\t\treturn *this += -v;\n\t}\n\tBigInt &operator*=(const BigInt &v) {\n\t\treturn *this = *this * v;\n\t}\n\tBigInt &operator/=(const BigInt &v) {\n\t\treturn *this = *this / v;\n\t}\n\tBigInt operator-()const {\n\t\tBigInt res = *this;\n\t\tres.sign = -sign;\n\t\treturn res;\n\t}\n\n\tBigInt operator+(const BigInt &v)const { return BigInt(*this) += v; }\n\tBigInt operator-(const BigInt &v)const { return BigInt(*this) -= v; }\n\tBigInt operator*(int v)const {\n\t\tBigInt res = *this;\n\t\tres *= v;\n\t\treturn res;\n\t}\n\tBigInt operator*(const BigInt &v)const {\n\t\tvector<int> a6 = convert_base(this->d, kBaseDigits, 6);\n\t\tvector<int> b6 = convert_base(v.d, kBaseDigits, 6);\n\t\tvll a(a6.begin(), a6.end());\n\t\tvll b(b6.begin(), b6.end());\n\t\twhile (a.size() < b.size())\n\t\t\ta.emplace_back(0);\n\t\twhile (b.size() < a.size())\n\t\t\tb.emplace_back(0);\n\t\twhile (a.size() & (a.size() - 1))\n\t\t\ta.emplace_back(0), b.emplace_back(0);\n\t\tvll c = karatsubaMultiply(a, b);\n\t\tBigInt res;\n\t\tres.sign = sign * v.sign;\n\t\tfor (int i = 0, carry = 0; i < (int)c.size(); i++) {\n\t\t\tlong long cur = c[i] + carry;\n\t\t\tres.d.emplace_back((int)(cur % 1000000));\n\t\t\tcarry = (int)(cur / 1000000);\n\t\t}\n\t\tres.d = convert_base(res.d, 6, kBaseDigits);\n\t\tres.trim();\n\t\treturn res;\n\t}\n\n\tBigInt operator/(const BigInt &v)const { return divmod(*this, v).first; }\n\tBigInt operator/(int v)const {\n\t\tBigInt res = *this;\n\t\tres /= v;\n\t\treturn res;\n\t}\n\tBigInt operator%(const BigInt &v)const {\n\t\treturn divmod(*this, v).second;\n\t}\n\tint operator%(int v)const {\n\t\tif (v < 0)\n\t\t\tv = -v;\n\t\tint m = 0;\n\t\tfor (int i = d.size() - 1; i >= 0; --i)\n\t\t\tm = (d[i] + m * (long long)kBase) % v;\n\t\treturn m * sign;\n\t}\n\n\tBigInt &operator*=(int v) {\n\t\tif (v < 0)\n\t\t\tsign = -sign, v = -v;\n\t\tfor (int i = 0, carry = 0; i < (int)d.size() || carry; ++i) {\n\t\t\tif (i == (int)d.size())\n\t\t\t\td.emplace_back(0);\n\t\t\tlong long cur = d[i] * (long long)v + carry;\n\t\t\tcarry = (int)(cur / kBase);\n\t\t\td[i] = (int)(cur % kBase);\n\t\t}\n\t\ttrim();\n\t\treturn *this;\n\t}\n\tBigInt &operator/=(int v) {\n\t\tif (v < 0)\n\t\t\tsign = -sign, v = -v;\n\t\tfor (int i = (int)d.size() - 1, rem = 0; i >= 0; --i) {\n\t\t\tlong long cur = d[i] + rem * (long long)kBase;\n\t\t\td[i] = (int)(cur / v);\n\t\t\trem = (int)(cur % v);\n\t\t}\n\t\ttrim();\n\t\treturn *this;\n\t}\n\tstatic pair<BigInt, BigInt> divmod(const BigInt &a1, const BigInt &b1) {\n\t\tint norm = kBase / (b1.d.back() + 1);\n\t\tBigInt a = a1.abs() * norm;\n\t\tBigInt b = b1.abs() * norm;\n\t\tBigInt q, r;\n\t\tq.d.resize(a.d.size());\n\n\t\tfor (int i = a.d.size() - 1; i >= 0; i--) {\n\t\t\tr *= kBase;\n\t\t\tr += a.d[i];\n\t\t\tint s1 = r.d.size() <= b.d.size() ? 0 : r.d[b.d.size()];\n\t\t\tint s2 = r.d.size() <= b.d.size() - 1 ? 0 : r.d[b.d.size() - 1];\n\t\t\tint d = ((long long)kBase * s1 + s2) / b.d.back();\n\t\t\tr -= b * d;\n\t\t\twhile (r < 0)\n\t\t\t\tr += b, --d;\n\t\t\tq.d[i] = d;\n\t\t}\n\n\t\tq.sign = a1.sign * b1.sign;\n\t\tr.sign = a1.sign;\n\t\tq.trim();\n\t\tr.trim();\n\t\treturn make_pair(q, r / norm);\n\t}\n\tvoid trim() {\n\t\twhile (!d.empty() && !d.back())\n\t\t\td.pop_back();\n\t\tif (d.empty())\n\t\t\tsign = 1;\n\t}\n\tbool isZero()const {\n\t\treturn d.empty() || (d.size() == 1 && !d[0]);\n\t}\n\n\tBigInt abs()const {\n\t\tBigInt res = *this;\n\t\tres.sign *= res.sign;\n\t\treturn res;\n\t}\n\n\tlong long longValue()const {\n\t\tlong long res = 0;\n\t\tfor (int i = d.size() - 1; i >= 0; i--)\n\t\t\tres = res * kBase + d[i];\n\t\treturn res * sign;\n\t}\n\n\tvoid read(const string &s) {\n\t\tsign = 1;\n\t\td.clear();\n\t\tint pos = 0;\n\t\twhile (pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')) {\n\t\t\tif (s[pos] == '-')\n\t\t\t\tsign = -sign;\n\t\t\t++pos;\n\t\t}\n\t\tfor (int i = s.size() - 1; i >= pos; i -= kBaseDigits) {\n\t\t\tint x = 0;\n\t\t\tfor (int j = max(pos, i - kBaseDigits + 1); j <= i; j++)\n\t\t\t\tx = x * 10 + s[j] - '0';\n\t\t\td.emplace_back(x);\n\t\t}\n\t\ttrim();\n\t}\n\n\tfriend istream& operator >> (istream &stream, BigInt &v) {\n\t\tstring s;\n\t\tstream >> s;\n\t\tv.read(s);\n\t\treturn stream;\n\t}\n\n\tfriend ostream& operator << (ostream &stream, const BigInt &v) {\n\t\tif (v.sign == -1)\n\t\t\tstream << '-';\n\t\tstream << (v.d.empty() ? 0 : v.d.back());\n\t\tfor (int i = (int)v.d.size() - 2; i >= 0; --i)\n\t\t\tstream << setw(kBaseDigits) << setfill('0') << v.d[i];\n\t\treturn stream;\n\t}\n\n\tstatic vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\n\t\tvector<long long> p(max(old_digits, new_digits) + 1);\n\t\tp[0] = 1;\n\t\tfor (int i = 1; i < (int)p.size(); i++)\n\t\t\tp[i] = p[i - 1] * 10;\n\t\tvector<int> res;\n\t\tlong long cur = 0;\n\t\tint cur_digits = 0;\n\t\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\t\tcur += a[i] * p[cur_digits];\n\t\t\tcur_digits += old_digits;\n\t\t\twhile (cur_digits >= new_digits) {\n\t\t\t\tres.emplace_back(int(cur % p[new_digits]));\n\t\t\t\tcur /= p[new_digits];\n\t\t\t\tcur_digits -= new_digits;\n\t\t\t}\n\t\t}\n\t\tres.emplace_back((int)cur);\n\t\twhile (!res.empty() && !res.back())\n\t\t\tres.pop_back();\n\t\treturn res;\n\t}\n\n\tusing vll = vector<long long>;\n\tstatic vll karatsubaMultiply(const vll &a, const vll &b) {\n\t\tint n = a.size();\n\t\tvll res(n + n);\n\t\tif (n <= 32) {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tres[i + j] += a[i] * b[j];\n\t\t\treturn res;\n\t\t}\n\n\t\tint k = n >> 1;\n\t\tvll a1(a.begin(), a.begin() + k);\n\t\tvll a2(a.begin() + k, a.end());\n\t\tvll b1(b.begin(), b.begin() + k);\n\t\tvll b2(b.begin() + k, b.end());\n\n\t\tvll a1b1 = karatsubaMultiply(a1, b1);\n\t\tvll a2b2 = karatsubaMultiply(a2, b2);\n\n\t\tfor (int i = 0; i < k; i++)\n\t\t\ta2[i] += a1[i];\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tb2[i] += b1[i];\n\n\t\tvll r = karatsubaMultiply(a2, b2);\n\t\tfor (int i = 0; i < (int)a1b1.size(); i++)\n\t\t\tr[i] -= a1b1[i];\n\t\tfor (int i = 0; i < (int)a2b2.size(); i++)\n\t\t\tr[i] -= a2b2[i];\n\n\t\tfor (int i = 0; i < (int)r.size(); i++)\n\t\t\tres[i + k] += r[i];\n\t\tfor (int i = 0; i < (int)a1b1.size(); i++)\n\t\t\tres[i] += a1b1[i];\n\t\tfor (int i = 0; i < (int)a2b2.size(); i++)\n\t\t\tres[i + n] += a2b2[i];\n\t\treturn res;\n\t}\n\n};\n\nBigInt gcd(const BigInt &x, const BigInt &y) { return y.isZero() ? x : gcd(y, x % y); }\nBigInt lcm(const BigInt &x, const BigInt &y) { return x / gcd(x, y) * y; }\n\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = BigInt;\n\tconst Cost kInfCost = BigInt(string(log10(pow(2500, 55)), '9'));\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<Cost> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), kInfCost);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == kInfCost)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tFlow d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += dist[t] * d;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tBigInt w[52];\n\tw[0] = 1;\n\trep(i, 0, 51) {\n\t\tw[i + 1] = w[i] * 2500;\n\t}\n\n\tint N; cin >> N;\n\tvector<vector<BigInt>> a(N, vector<BigInt>(N));\n\tvector<vector<char>> c(N, vector<char>(N));\n\trep(i, 0, N) rep(j, 0, N) {\n\t\tcin >> c[i][j];\n\t\tif (c[i][j] <= 'Z')\n\t\t\ta[i][j] = w[c[i][j] - 'A'];\n\t\telse\n\t\t\ta[i][j] = w[26 + c[i][j] - 'z'];\n\t}\n\tdump(a);\n\n\tMinimumCostFlow mcf(N + N + 2);\n\tint s = mcf.n - 2, t = s + 1;\n\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tmcf.addArc(i, N + j, 1, a[i][j]);\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tmcf.addArc(s, i, 1, 0);\n\t\tmcf.addArc(N + i, t, 1, 0);\n\t}\n\tauto cost = mcf.minimumCostFlow(s, t, N);\n\tdump(cost);\n\n\tvector<char> ans;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tdump(mcf.g[i][j].cap);\n\t\t\tif (mcf.g[i][j].cap == 0) {\n\t\t\t\tans.emplace_back(c[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tsort(all(ans));\n\trep(i, 0, ans.size())\n\t\tcout << ans[i];\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\n// (?????????, ??????, ?????????, ??????)\nstruct edge{ int to,cap,cost,rev; };\n\nint V; // TODO:initialize\nconst int MAX_V = 111; // TODO:initialize\nconst int INF = 12345678; // TODO:initialize\nvector<edge> G[MAX_V];\nint h[MAX_V]; // ??????????????£???\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,(int)G[to].size()});\n    G[to].pb({from,0,-cost,(int)G[from].size()-1});\n}\n\n// s??????t????????????f???????°??????¨???(???????????????-1)\nint min_cost_flow(int s, int t, int f, bool neg = false){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        if(neg)\n        {\n            // bellman-ford??§h?????´??°\n            neg = false;\n            bool update;\n            do{\n                update = false;\n                rep(v,V){\n                    if(dist[v] == INF) continue;\n                    rep(i,G[v].size()){\n                        edge &e = G[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }while(update);\n        }\n        else\n        {\n            // dijkstra??§h?????´??°\n            pq.push(pi(0,s));\n            while(!pq.empty()){\n                pi p = pq.top();\n                pq.pop();\n                int v = p.se;\n                if(p.fi>dist[v]) continue;\n                rep(i,G[v].size()){\n                    edge &e = G[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        pq.push(pi(dist[e.to],e.to));\n                    }\n                }\n            }\n        }\n\n        // ????????\\???????????????\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t???????????????????????£??????????????????\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n;\n    cin >>n;\n    vector<string> s(n);\n    rep(i,n) cin >>s[i];\n\n    V = 2*n+2;\n    int S = 2*n, T = S+1;\n\n    rep(i,n)\n    {\n        add_edge(S,i,1,0);\n        add_edge(n+i,T,1,0);\n\n        rep(j,n)\n        {\n            int c = s[i][j]-'A';\n            if('a'<=s[i][j] && s[i][j]<='z') c = 26+s[i][j]-'a';\n            add_edge(i,n+j,1,c);\n        }\n    }\n\n    int f = min_cost_flow(S,T,n);\n\n    string ans = \"\";\n    rep(i,n)\n    {\n        for(const auto &e:G[n+i])\n        {\n            if(e.cap==1)\n            {\n                int x = -e.cost;\n                char c = 'A'+x;\n                if(x>=26) c = 'a'+x-26;\n                ans += c;\n                break;\n            }\n        }\n    }\n    sort(all(ans));\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\n#define UNIQUE(xs) sort(xs.begin(), xs.end()); xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\nint main() {\n\n  int N; cin >> N;\n  vector<vector<pair<char, int>>> V;\n  rep(i, N) {\n    string s; cin >> s;\n    vector<pair<char, int>> vs;\n    rep(j, N) {\n      vs.emplace_back(s[j], j);\n    }\n    sort(all(vs));\n    V.push_back(vs);\n  }\n\n  sort(all(V));\n\n  set<int> st;\n\n  rep(i, N) {\n    map<char, vector<int>> pos;\n    rep(j, N) pos[V[i][j].first].push_back(V[i][j].second);\n    for(auto& e: pos) {\n      sort(all(e.second));\n    }\n\n    for(auto& e: pos) {\n      char target = e.first;\n      auto& indexes = e.second;\n      bool ok = 0;\n      for(int i=indexes.size() - 1; i>=0; i--) {\n        if(!st.count(indexes[i])) {\n          st.insert(indexes[i]);\n          ok = 1;\n//          cout << indexes[i] << \" \";\n          break;\n        }\n      }\n      if(ok) {\n        cout << target;\n        break;\n      }\n    }\n\n  }\n\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\n#include <time.h>\nusing namespace std;\nlong double esp=1e-11;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define cle(a) while(!a.empty())a.pop()\n#define mem(p) memset(p,0,sizeof(p))\n#define memf(p) memset(p,0x3f,sizeof(p))\n#define memn(p) memset(p,-1,sizeof(p))\n#define mp(A, B) make_pair(A, B)\n#define pb push_back\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\ntypedef long long int LL;\nconst long double PI = acos((long double)-1);\nconst LL INF=0x3f3f3f3fll;\nconst int MOD = 1000000007;\nconst int maxn=110000;\ntypedef  struct {int v,next,val;} edge;\nconst int MAXN=110;\nconst int MAXM=30010;\n\nedge e[MAXM];\nint p[MAXN],eid;\n\ninline void init(){memset(p,-1,sizeof(p));eid=0;}\n\n//有向\ninline void insert1(int from,int to,int val)\n{\n    e[eid].v=to;\n    e[eid].val=val;\n    e[eid].next=p[from];\n    p[from]=eid++;\n\n    swap(from,to);\n\n    e[eid].v=to;\n    e[eid].val=0;\n    e[eid].next=p[from];\n    p[from]=eid++;\n}\n\nint N=MAXN;//n?点数 m??数\nint h[MAXN];\nint gap[MAXN];\n\nint source,sink;\ninline int dfs(int pos,int cost)\n{\n    if (pos==sink)\n    {\n        return cost;\n    }\n\n    int j,minh=N-1,lv=cost,d;\n\n    for (j=p[pos];j!=-1;j=e[j].next)\n    {\n        int v=e[j].v,val=e[j].val;\n        if(val>0)\n        {\n            if (h[v]+1==h[pos])\n            {\n                if (lv<e[j].val) d=lv;\n                else d=e[j].val;\n\n                d=dfs(v,d);\n                e[j].val-=d;\n                e[j^1].val+=d;\n                lv-=d;\n                if (h[source]>=N) return cost-lv;\n                if (lv==0) break;\n            }\n\n            if (h[v]<minh)    minh=h[v];\n        }\n    }\n\n    if (lv==cost)\n    {\n        --gap[h[pos]];\n        if (gap[h[pos]]==0) h[source]=N;\n        h[pos]=minh+1;\n        ++gap[h[pos]];\n    }\n\n    return cost-lv;\n\n}\n\nint sap(int st,int ed)\n{\n\n    source=st;\n    sink=ed;\n    int ret=0;\n    memset(gap,0,sizeof(gap));\n    memset(h,0,sizeof(h));\n\n    gap[st]=N;\n\n    while (h[st]<N)\n    {\n        ret+=dfs(st,INT_MAX);\n    }\n\n    return ret;\n}\nchar s[55][55];\nint dx[55],dy[55];\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"inlay.in\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    //map<long long int,int>ma;                 %I64d\n    //vector<int>::iterator iter;\n    //memset(m,0,sizeof(int));\n    //for(int x=1;x<=n;x++)\n    //for(int y=1;y<=n;y++)\n    //scanf(\"%d%d\",&a,&b);\n    //scanf(\"%d\",&a);\n    //printf(\"%d\\n\",ans);\n    mem(dx);\n    mem(dy);\n    int n;\n    scanf(\"%d\",&n);\n    int st=105,ed=106;\n    for(int x=0;x<n;x++)\n        scanf(\"%s\",s[x]);\n    vector<int>ans;\n    ans.clear();\n    for(int z='A';z<='z';(z=='Z')?z='a':z++)\n    {\n        init();\n        for(int x=0;x<n;x++)\n        if(!dx[x])\n        insert1(st,x+1,1);\n        for(int y=0;y<n;y++)\n        if(!dy[y])\n        insert1(n+y+1,ed,1);\n        for(int x=0;x<n;x++)\n            if(!dx[x])\n            for(int y=0;y<n;y++)\n            if(s[x][y]==z&&!dy[y])\n            {\n                insert1(x+1,n+y+1,1);\n            }\n        sap(st,ed);\n        for(int x=n+1;x<=2*n;x++)\n        {\n            for (int j=p[x];j!=-1;j=e[j].next)\n            if(e[j].v<=n&&e[j].val>0)\n            {\n                ans.pb(z);\n                dx[e[j].v-1]=1;\n                dy[x-n-1]=1;\n            }\n        }\n    }\n    sort(all(ans));\n    for(int x=0;x<n;x++)\n        printf(\"%c\",ans[x]);\n    putchar(10);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1<<21);\nconst int MAX_V = 200;\n\nconst int S=52;\n\nstruct state{\n  vector<int> v;\n  state(vector<int> v): v(v) {}\n  state( char c ){\n    v = vector<int>(S);\n    if( c <= 'Z' ) v[c-'A']=-1;\n    else v[26+c-'a']=-1;\n  }\n  state(int x){\n    v=vector<int>(S,x);\n  }\n  state(){}\n  state operator+(const state& x) const{\n    vector<int> res(v.size());\n    for(int i=0;i<(int)res.size();i++)\n      res[i] = v[i]+x.v[i];\n    return state(res);\n  }\n  state operator-(const state& x){\n    vector<int> res(v.size());\n    for(int i=0;i<(int)res.size();i++)\n      res[i] = v[i]-x.v[i];\n    return state(res);\n  }\n  state operator*(int x){\n    vector<int> res=v;\n    for(int i=0;i<(int)res.size();i++) res[i]*=x;\n    return res;\n  }\n  bool operator<(const state& x) const{\n    for(int i=0;i<(int)v.size();i++){\n      if( v[i] == x.v[i] ) continue;\n      return v[i] < x.v[i];\n    }\n    return false;\n  }\n  bool operator==(const state& x) const{\n    for(int i=0;i<x.v.size();i++)\n      if( v[i] != x.v[i] ) return false;\n    return true;\n  }\n  void view(){\n    for(int i=0;i<v.size();i++){\n      cout << v[i] << \" \";\n    }\n    cout << endl;\n  }\n};\n\nstruct edge{\n  int to, cap,rev;\n  state cost;\n  edge( int to, int cap, state cost, int rev) : to(to),cap(cap),cost(cost),rev(rev) {}\n  edge(){}\n};\n\n\ntypedef pair<state,int> P;\n\nint V;\nvector<edge> G[MAX_V];\nstate h[MAX_V];\nstate dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n \nvoid add_edge(int from,int to,int cap,state cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, cost*-1 , (int)G[from].size() - 1});\n}\n\nstate min_cost_flow(int s,int t,int f){\n  state res = state(0);\n  fill( h, h+V, state(0));\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,state(INF) );\n    dist[s] = state(0);\n    que.push(P(dist[s],s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < (int)G[v].size() ; i++){\n        edge &e = G[v][i];\n         \n        if(e.cap > 0 && dist[v] + e.cost + h[v] - h[e.to] < dist[e.to] ){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if( dist[t] == state(INF) ){\n      return -1;\n    }\n \n    for(int v = 0 ; v < V ; v++) h[v] = h[v]+dist[v];\n       \n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res = res + (h[t] * d);\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint N;\nchar c[55][55];\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin >> c[i][j];\n\n  V = 2*N+2;\n  int s = 2*N, t = 2*N+1;\n\n  for(int i=0;i<N;i++){\n    add_edge(s,i,1,state(0));\n    add_edge(N+i,t, 1,state(0));\n    for(int j=0;j<N;j++){\n      add_edge(i,N+j,1, state(c[i][j]) );\n    }\n  }\n  string alp=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  state res = min_cost_flow(s,t,N);\n  for(int i=0;i<S;i++){\n    for(int j=0;j<-res.v[i];j++ ){\n      cout << alp[i];\n    }\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\ntypedef vi Weight;\ntypedef int Flow;\nWeight ZERO;\nWeight INF;\n\nWeight operator-(const Weight& v)\n{\n\tWeight res = v;\n\tREP(i, res.size()) res[i] *= -1;\n\treturn res;\n}\n\nWeight operator+(const Weight& a, const Weight b)\n{\n\tWeight res = a;\n\tREP(i, res.size()) res[i] += b[i];\n\treturn res;\n}\n\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid add_edge(Graph &g, int from, int to, Flow cap, Weight cost)\n{\n\tg[from].push_back(Edge(from, to, (int)g[to].size(), cap, cost));\n\tg[to].push_back(Edge(to, from, (int)g[from].size() - 1, 0, -cost));\n}\n\nWeight mincost_flow(Graph &g, int s, int t, Flow f)\n{\n\tconst int n = g.size();\n\tvi emp(52);\n\tWeight res = emp;\n\tArray dist(n);\n\tvi prevv(n), preve(n);\n\twhile (f > 0)\n\t{\n\t\tREP(i, n) dist[i] = (i == s) ? ZERO : INF;\n\t\tbool update = true;\n\t\twhile (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\tfor (int v = 0; v < n; v++)\n\t\t\t{\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\tREP(i, g[v].size())\n\t\t\t\t{\n\t\t\t\t\tEdge& e = g[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.cost)\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[e.dest] = dist[v] + e.cost;\n\t\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFlow d = f;\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t{\n\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tassert(d == 1);\n\t\t//res += d * dist[t];\n\t\tres = res + dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t{\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nmap<char, vi> mp;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tZERO.resize(52);\n\tINF.resize(52, 1000000);\n\tint n; cin >> n;\n\tvs fld(n);\n\tREP(i, n) cin >> fld[i];\n\tGraph g(n * 2 + 2);\n\tint src = n * 2, sink = n * 2 + 1;\n\tREP(i, 26)\n\t{\n\t\tvi v(52);\n\t\tv[i] = -1;\n\t\tmp['A' + i] = v;\n\t}\n\tREP(i, 26)\n\t{\n\t\tvi v(52);\n\t\tv[i+26] = -1;\n\t\tmp['a' + i] = v;\n\t}\n\tvi emp(52);\n\tREP(i, n)\n\t{\n\t\tadd_edge(g, src, i, 1, emp);\n\t\tadd_edge(g, n + i, sink, 1, emp);\n\t}\n\tREP(i, n)REP(j, n)\n\t{\n\t\tadd_edge(g, i, n + j, 1, mp[fld[i][j]]);\n\t}\n\tvi res = mincost_flow(g, src, sink, n);\n\tstring ans;\n\tREP(i, 26)\n\t{\n\t\tREP(j, -res[i]) ans += char('A' + i);\n\t}\n\tREP(i, 26)\n\t{\n\t\tREP(j, -res[i+26]) ans += char('a' + i);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nstring ans;\nmap<int,char> itos;\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    ans+=itos[dist[t]];\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint ctoi[300];\n\nint main(){\n  \n  int n;\n  cin>>n;\n  \n  int S=n*2,T=S+1;\n  \n  int cost=-300;\n  int idx='A';\n\n  while(idx<300){\n    ctoi[idx]=cost;\n    itos[cost]=(char)idx;\n    cost++;\n    idx++;\n  }\n  \n  for(int i=0;i<n;i++){\n    string s;\n    cin>>s;\n    for(int j=0;j<n;j++){\n      add_edge(i,j+n,1,ctoi[(int)s[j]]);\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    add_edge(S,i,1,0);\n    add_edge(i+n,T,1,0);\n  }\n  \n  V=n*2+2;\n  min_cost_flow(S,T,n);\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N; cin >> N;\n  vector<string> vs(N);\n  rep(i, N) {\n    cin >> vs[i];\n  }\n\n  sort(all(vs));\n\n  set<int> st;\n\n  rep(i, N) {\n    vector<pair<char, int>> V;\n    rep(j, N) V.emplace_back(vs[i][j], j);\n    sort(all(V));\n    rep(j, N) {\n      if(!st.count(V[j].second)) {\n        st.insert(V[j].second);\n        cout << V[j].first;\n        break;\n      }\n    }\n  }\n\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) begin(a),end(a)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct BigInt {\n\tstatic const int kBase = 1000000000;\n\tstatic const int kBaseDigits = 9;\n\tvector<int> d;\n\tint sign;\n\tBigInt() :sign(1) {}\n\tBigInt(long long v) {\n\t\tsign = 1;\n\t\tif (v < 0)\n\t\t\tsign = -1, v = -v;\n\t\tfor (; v > 0; v = v / kBase)\n\t\t\td.emplace_back(v % kBase);\n\t}\n\tBigInt(const string &s) { read(s); }\n\n\tbool operator<(const BigInt &v)const {\n\t\tif (sign != v.sign)\n\t\t\treturn sign < v.sign;\n\t\tif (d.size() != v.d.size())\n\t\t\treturn d.size() * sign < v.d.size() * v.sign;\n\t\tfor (int i = d.size() - 1; i >= 0; i--)\n\t\t\tif (d[i] != v.d[i])\n\t\t\t\treturn d[i] * sign < v.d[i] * sign;\n\t\treturn false;\n\t}\n\tbool operator>(const BigInt &v)const { return v < *this; }\n\tbool operator<=(const BigInt &v)const { return !(v < *this); }\n\tbool operator>=(const BigInt &v)const { return !(*this < v); }\n\tbool operator==(const BigInt &v)const { return !(*this < v) && !(v < *this); }\n\tbool operator!=(const BigInt &v)const { return !(*this == v); }\n\n\tBigInt &operator+=(const BigInt &v) {\n\t\tif (sign == v.sign) {\n\t\t\tBigInt res = v;\n\t\t\tfor (int i = 0, carry = 0; i < (int)max(d.size(), v.d.size()) || carry; ++i) {\n\t\t\t\tif (i == (int)res.d.size())\n\t\t\t\t\tres.d.emplace_back(0);\n\t\t\t\tres.d[i] += carry + (i < (int)d.size() ? d[i] : 0);\n\t\t\t\tcarry = res.d[i] >= kBase;\n\t\t\t\tif (carry)\n\t\t\t\t\tres.d[i] -= kBase;\n\t\t\t}\n\t\t\treturn *this = res;\n\t\t}\n\t\telse\n\t\t\treturn *this -= (-v);\n\t}\n\tBigInt &operator-=(const BigInt &v) {\n\t\tif (sign == v.sign) {\n\t\t\tBigInt tmp = abs();\n\t\t\tif (abs() >= v.abs()) {\n\t\t\t\tBigInt res = *this;\n\t\t\t\tfor (int i = 0, carry = 0; i < (int)v.d.size() || carry; ++i) {\n\t\t\t\t\tres.d[i] -= carry + (i < (int)v.d.size() ? v.d[i] : 0);\n\t\t\t\t\tcarry = res.d[i] < 0;\n\t\t\t\t\tif (carry)\n\t\t\t\t\t\tres.d[i] += kBase;\n\t\t\t\t}\n\t\t\t\tres.trim();\n\t\t\t\treturn *this = res;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn *this = -(v - *this);\n\t\t}\n\t\telse\n\t\t\treturn *this += -v;\n\t}\n\tBigInt &operator*=(const BigInt &v) {\n\t\treturn *this = *this * v;\n\t}\n\tBigInt &operator/=(const BigInt &v) {\n\t\treturn *this = *this / v;\n\t}\n\tBigInt operator-()const {\n\t\tBigInt res = *this;\n\t\tres.sign = -sign;\n\t\treturn res;\n\t}\n\n\tBigInt operator+(const BigInt &v)const { return BigInt(*this) += v; }\n\tBigInt operator-(const BigInt &v)const { return BigInt(*this) -= v; }\n\tBigInt operator*(int v)const {\n\t\tBigInt res = *this;\n\t\tres *= v;\n\t\treturn res;\n\t}\n\tBigInt operator*(const BigInt &v)const {\n\t\tvector<int> a6 = convert_base(this->d, kBaseDigits, 6);\n\t\tvector<int> b6 = convert_base(v.d, kBaseDigits, 6);\n\t\tvll a(a6.begin(), a6.end());\n\t\tvll b(b6.begin(), b6.end());\n\t\twhile (a.size() < b.size())\n\t\t\ta.emplace_back(0);\n\t\twhile (b.size() < a.size())\n\t\t\tb.emplace_back(0);\n\t\twhile (a.size() & (a.size() - 1))\n\t\t\ta.emplace_back(0), b.emplace_back(0);\n\t\tvll c = karatsubaMultiply(a, b);\n\t\tBigInt res;\n\t\tres.sign = sign * v.sign;\n\t\tfor (int i = 0, carry = 0; i < (int)c.size(); i++) {\n\t\t\tlong long cur = c[i] + carry;\n\t\t\tres.d.emplace_back((int)(cur % 1000000));\n\t\t\tcarry = (int)(cur / 1000000);\n\t\t}\n\t\tres.d = convert_base(res.d, 6, kBaseDigits);\n\t\tres.trim();\n\t\treturn res;\n\t}\n\n\tBigInt operator/(const BigInt &v)const { return divmod(*this, v).first; }\n\tBigInt operator/(int v)const {\n\t\tBigInt res = *this;\n\t\tres /= v;\n\t\treturn res;\n\t}\n\tBigInt operator%(const BigInt &v)const {\n\t\treturn divmod(*this, v).second;\n\t}\n\tint operator%(int v)const {\n\t\tif (v < 0)\n\t\t\tv = -v;\n\t\tint m = 0;\n\t\tfor (int i = d.size() - 1; i >= 0; --i)\n\t\t\tm = (d[i] + m * (long long)kBase) % v;\n\t\treturn m * sign;\n\t}\n\n\tBigInt &operator*=(int v) {\n\t\tif (v < 0)\n\t\t\tsign = -sign, v = -v;\n\t\tfor (int i = 0, carry = 0; i < (int)d.size() || carry; ++i) {\n\t\t\tif (i == (int)d.size())\n\t\t\t\td.emplace_back(0);\n\t\t\tlong long cur = d[i] * (long long)v + carry;\n\t\t\tcarry = (int)(cur / kBase);\n\t\t\td[i] = (int)(cur % kBase);\n\t\t}\n\t\ttrim();\n\t\treturn *this;\n\t}\n\tBigInt &operator/=(int v) {\n\t\tif (v < 0)\n\t\t\tsign = -sign, v = -v;\n\t\tfor (int i = (int)d.size() - 1, rem = 0; i >= 0; --i) {\n\t\t\tlong long cur = d[i] + rem * (long long)kBase;\n\t\t\td[i] = (int)(cur / v);\n\t\t\trem = (int)(cur % v);\n\t\t}\n\t\ttrim();\n\t\treturn *this;\n\t}\n\tstatic pair<BigInt, BigInt> divmod(const BigInt &a1, const BigInt &b1) {\n\t\tint norm = kBase / (b1.d.back() + 1);\n\t\tBigInt a = a1.abs() * norm;\n\t\tBigInt b = b1.abs() * norm;\n\t\tBigInt q, r;\n\t\tq.d.resize(a.d.size());\n\n\t\tfor (int i = a.d.size() - 1; i >= 0; i--) {\n\t\t\tr *= kBase;\n\t\t\tr += a.d[i];\n\t\t\tint s1 = r.d.size() <= b.d.size() ? 0 : r.d[b.d.size()];\n\t\t\tint s2 = r.d.size() <= b.d.size() - 1 ? 0 : r.d[b.d.size() - 1];\n\t\t\tint d = ((long long)kBase * s1 + s2) / b.d.back();\n\t\t\tr -= b * d;\n\t\t\twhile (r < 0)\n\t\t\t\tr += b, --d;\n\t\t\tq.d[i] = d;\n\t\t}\n\n\t\tq.sign = a1.sign * b1.sign;\n\t\tr.sign = a1.sign;\n\t\tq.trim();\n\t\tr.trim();\n\t\treturn make_pair(q, r / norm);\n\t}\n\tvoid trim() {\n\t\twhile (!d.empty() && !d.back())\n\t\t\td.pop_back();\n\t\tif (d.empty())\n\t\t\tsign = 1;\n\t}\n\tbool isZero()const {\n\t\treturn d.empty() || (d.size() == 1 && !d[0]);\n\t}\n\n\tBigInt abs()const {\n\t\tBigInt res = *this;\n\t\tres.sign *= res.sign;\n\t\treturn res;\n\t}\n\n\tlong long longValue()const {\n\t\tlong long res = 0;\n\t\tfor (int i = d.size() - 1; i >= 0; i--)\n\t\t\tres = res * kBase + d[i];\n\t\treturn res * sign;\n\t}\n\n\tvoid read(const string &s) {\n\t\tsign = 1;\n\t\td.clear();\n\t\tint pos = 0;\n\t\twhile (pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')) {\n\t\t\tif (s[pos] == '-')\n\t\t\t\tsign = -sign;\n\t\t\t++pos;\n\t\t}\n\t\tfor (int i = s.size() - 1; i >= pos; i -= kBaseDigits) {\n\t\t\tint x = 0;\n\t\t\tfor (int j = max(pos, i - kBaseDigits + 1); j <= i; j++)\n\t\t\t\tx = x * 10 + s[j] - '0';\n\t\t\td.emplace_back(x);\n\t\t}\n\t\ttrim();\n\t}\n\n\tfriend istream& operator >> (istream &stream, BigInt &v) {\n\t\tstring s;\n\t\tstream >> s;\n\t\tv.read(s);\n\t\treturn stream;\n\t}\n\n\tfriend ostream& operator << (ostream &stream, const BigInt &v) {\n\t\tif (v.sign == -1)\n\t\t\tstream << '-';\n\t\tstream << (v.d.empty() ? 0 : v.d.back());\n\t\tfor (int i = (int)v.d.size() - 2; i >= 0; --i)\n\t\t\tstream << setw(kBaseDigits) << setfill('0') << v.d[i];\n\t\treturn stream;\n\t}\n\n\tstatic vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\n\t\tvector<long long> p(max(old_digits, new_digits) + 1);\n\t\tp[0] = 1;\n\t\tfor (int i = 1; i < (int)p.size(); i++)\n\t\t\tp[i] = p[i - 1] * 10;\n\t\tvector<int> res;\n\t\tlong long cur = 0;\n\t\tint cur_digits = 0;\n\t\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\t\tcur += a[i] * p[cur_digits];\n\t\t\tcur_digits += old_digits;\n\t\t\twhile (cur_digits >= new_digits) {\n\t\t\t\tres.emplace_back(int(cur % p[new_digits]));\n\t\t\t\tcur /= p[new_digits];\n\t\t\t\tcur_digits -= new_digits;\n\t\t\t}\n\t\t}\n\t\tres.emplace_back((int)cur);\n\t\twhile (!res.empty() && !res.back())\n\t\t\tres.pop_back();\n\t\treturn res;\n\t}\n\n\tusing vll = vector<long long>;\n\tstatic vll karatsubaMultiply(const vll &a, const vll &b) {\n\t\tint n = a.size();\n\t\tvll res(n + n);\n\t\tif (n <= 32) {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tres[i + j] += a[i] * b[j];\n\t\t\treturn res;\n\t\t}\n\n\t\tint k = n >> 1;\n\t\tvll a1(a.begin(), a.begin() + k);\n\t\tvll a2(a.begin() + k, a.end());\n\t\tvll b1(b.begin(), b.begin() + k);\n\t\tvll b2(b.begin() + k, b.end());\n\n\t\tvll a1b1 = karatsubaMultiply(a1, b1);\n\t\tvll a2b2 = karatsubaMultiply(a2, b2);\n\n\t\tfor (int i = 0; i < k; i++)\n\t\t\ta2[i] += a1[i];\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tb2[i] += b1[i];\n\n\t\tvll r = karatsubaMultiply(a2, b2);\n\t\tfor (int i = 0; i < (int)a1b1.size(); i++)\n\t\t\tr[i] -= a1b1[i];\n\t\tfor (int i = 0; i < (int)a2b2.size(); i++)\n\t\t\tr[i] -= a2b2[i];\n\n\t\tfor (int i = 0; i < (int)r.size(); i++)\n\t\t\tres[i + k] += r[i];\n\t\tfor (int i = 0; i < (int)a1b1.size(); i++)\n\t\t\tres[i] += a1b1[i];\n\t\tfor (int i = 0; i < (int)a2b2.size(); i++)\n\t\t\tres[i + n] += a2b2[i];\n\t\treturn res;\n\t}\n\n};\n\nBigInt gcd(const BigInt &x, const BigInt &y) { return y.isZero() ? x : gcd(y, x % y); }\nBigInt lcm(const BigInt &x, const BigInt &y) { return x / gcd(x, y) * y; }\n\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = BigInt;\n\tconst Cost kInfCost = BigInt(string(log10(pow(2500, 70)), '9'));\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<Cost> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), kInfCost);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == kInfCost)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == kInfCost)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tFlow d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += dist[t] * d;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tBigInt w[52];\n\tw[0] = -1;\n\trep(i, 0, 51) {\n\t\tw[i + 1] = w[i] * 2500;\n\t}\n\treverse(w, w + 52);\n\n\tint N; cin >> N;\n\tvector<vector<BigInt>> a(N, vector<BigInt>(N));\n\tvector<vector<char>> c(N, vector<char>(N));\n\trep(i, 0, N) rep(j, 0, N) {\n\t\tcin >> c[i][j];\n\t\tif (c[i][j] <= 'Z')\n\t\t\ta[i][j] = w[c[i][j] - 'A'];\n\t\telse\n\t\t\ta[i][j] = w[26 + c[i][j] - 'a'];\n\t}\n\n\tdump(a);\n\n\tMinimumCostFlow mcf(N + N + 2);\n\tint s = mcf.n - 2, t = s + 1;\n\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tmcf.addArc(i, N + j, 1, a[i][j]);\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tmcf.addArc(s, i, 1, 0);\n\t\tmcf.addArc(N + i, t, 1, 0);\n\t}\n\n\n\n\tauto cost = mcf.minimumCostFlow(s, t, N);\n\tdump(cost);\n\n\tvector<char> ans;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif (mcf.g[i][j].cap == 0) {\n\t\t\t\tans.emplace_back(c[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tsort(all(ans));\n\trep(i, 0, ans.size())\n\t\tcout << ans[i];\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\n#include <time.h>\nusing namespace std;\nlong double esp=1e-11;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define cle(a) while(!a.empty())a.pop()\n#define mem(p) memset(p,0,sizeof(p))\n#define memf(p) memset(p,0x3f,sizeof(p))\n#define memn(p) memset(p,-1,sizeof(p))\n#define mp(A, B) make_pair(A, B)\n#define pb push_back\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\ntypedef long long int LL;\nconst long double PI = acos((long double)-1);\nconst LL INF=0x3f3f3f3fll;\nconst int MOD = 1000000007;\nconst int maxn=110000;\n#define V 110\n#define E 15100\nstruct bigint{\n    int k[55];\n}ept;\nbigint binf;\nbigint operator+(bigint const &a,bigint const &b){\n        bigint tem;\n        for(int x=0;x<55;x++)\n            tem.k[x]=a.k[x]+b.k[x];\n        return tem;}\nbool operator>(bigint const &a,bigint const &b){\n        for(int x=0;x<55;x++)\n            if(a.k[x]>b.k[x])return 1;\n            else if(a.k[x]==b.k[x])continue;\n            else return 0;\n            return 0;}\nbool operator!=(bigint const &a,bigint const &b){\n        for(int x=0;x<55;x++)\n            if(a.k[x]!=b.k[x])return 1;\n        return 0;}\nint vis[V];\nbigint dist[V];\nint pre[V];\n\nstruct Edge{\n    int u,v,c,next;\n    bigint cost;\n}edge[E];\nint head[V],cnt;\n\nvoid init(){\n    cnt=0;\n    memset(head,-1,sizeof(head));\n}\nvoid addedge(int u,int v,int c,bigint cost)\n{\n    edge[cnt].u=u;edge[cnt].v=v;edge[cnt].cost=cost;\n    edge[cnt].c=c;edge[cnt].next=head[u];head[u]=cnt++;\n\n    for(int x=0;x<55;x++)cost.k[x]*=-1;\n    edge[cnt].u=v;edge[cnt].v=u;edge[cnt].cost=cost;\n    edge[cnt].c=0;edge[cnt].next=head[v];head[v]=cnt++;\n}\n\nbool spfa(int begin,int end){\n    int u,v;\n    queue<int> q;\n    for(int i=0;i<=end+2;i++){\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=binf;\n    }\n    vis[begin]=1;\n    dist[begin]=ept;\n    q.push(begin);\n    while(!q.empty()){\n        u=q.front();\n        q.pop();\n        vis[u]=0;\n        for(int i=head[u];i!=-1;i=edge[i].next){\n            if(edge[i].c>0){\n                v=edge[i].v;\n                if(dist[v]>dist[u]+edge[i].cost){\n                    dist[v]=dist[u]+edge[i].cost;\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }                   //cout << \"spfa\" << endl;\n    return dist[end]!=binf;\n}\n\nbigint MCMF(int begin,int end){\n    bigint ans=ept;\n    int flow;\n    int flow_sum=0;\n    while(spfa(begin,end)){\n        flow=INF;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u])\n            if(edge[i].c<flow)\n                flow=edge[i].c;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u]){\n            edge[i].c-=flow;\n            edge[i^1].c+=flow;\n        }\n        ans=ans+dist[end];\n        flow_sum += flow;\n    }\n    //cout << flow_sum << endl;\n    return ans;\n}\nchar s[110];\nchar h[66][66];\nint cal(char c)\n{\n    if(c<='Z')return c-'A';\n    return 26+c-'a';\n}\nchar fcal(int x)\n{\n    if(x<=25)return 'A'+x;\n    return x-26+'a';\n}\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"inlay.in\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    //map<long long int,int>ma;                 %I64d\n    //vector<int>::iterator iter;\n    //memset(m,0,sizeof(int));\n    //for(int x=1;x<=n;x++)\n    //for(int y=1;y<=n;y++)\n    //scanf(\"%d%d\",&a,&b);\n    //scanf(\"%d\",&a);\n    //printf(\"%d\\n\",ans);\n    mem(ept.k);\n    memf(binf.k);\n    int n;\n    scanf(\"%d\",&n);\n    init();\n    int st=105,ed=106;\n    for(int x=0;x<n;x++)\n        addedge(st,x,1,ept),addedge(n+x,ed,1,ept);\n    bigint tem;\n    for(int x=0;x<n;x++)\n    {\n        scanf(\"%s\",s);\n        for(int y=0;y<n;y++)\n        {\n            h[x][y]=s[y];\n            mem(tem.k);\n            tem.k[cal(s[y])]=-1;\n            addedge(x,n+y,1,tem);\n        }\n    }           //printf(\"%d\\n\",1111);\n    bigint ans=MCMF(st,ed);\n    for(int x=0;x<55;x++)\n        while(ans.k[x]++)\n        putchar(fcal(x));\n    puts(\"\");\n    //printf(\"%d\\n\",spfa(st,ed));\n    /*for(int x=0;x<cnt;x++)\n    {\n        printf(\"%d %d %d\\n\",edge[x].u,edge[x].v,edge[x].c);\n        for(int y=0;y<55;y++)\n            if(edge[x].cost.k[y])\n                printf(\"%d \",edge[x].cost.k[y]);\n            //printf(\"%d \",edge[x].cost.k[y]);\n        putchar('\\n');\n    }*/\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <tuple>\n#include <queue>\n#include <valarray>\nusing namespace std;\nusing ll = long long int;\n\nconst int B = 52;\nint get_ord(char c) {\n    if('A' <= c and c <= 'Z') return c - 'A';\n    return 26 + (c - 'a');\n}\n\nchar get_chr(int t) {\n    char chr;\n    if(t < 26) chr = (char)('A' + t);\n    else chr = (char)('a' + t - 26);\n    return chr;\n}\n\n// Ford-Fulkerson 法による 最大流 O( F |E| )\n// Bellman-Ford 法による 最小費用流 O( F |V| |E| )\n// [条件に注意] Dijkstra 法による 最小費用流 O( F |E| log |V| )\n\ntemplate <typename CapTp=int, typename CostTp=int>\nstruct Edge {\n    int to, rev;\n    CapTp cap; CostTp cost;\n    bool is_rev;\n    Edge(int t, bool f, int r, CapTp ca, CostTp co=0)\n        : to(t), rev(r), cap(ca), cost(co), is_rev(f) {}\n};\n\ntemplate <typename CapTp=int, typename CostTp=int>\nstruct Flow {\n    using Graph = vector< vector< Edge<CapTp, CostTp> > >;\n    Graph G; const CapTp IA; const CostTp IO;\n    vector< pair<int, int> > r_edges;\n    Flow(int N_, CapTp IA_=1<<29, CostTp IO_=1<<29)\n        : G(N_), IA(IA_), IO(IO_), r_edges() {}\n    // 辺を追加 (from -> to に流量 ca, コスト co)\n    void add_edge(int from, int to, CapTp ca, CostTp co=0) {\n        G[from].emplace_back(to, false, G[to].size(), ca, co);\n        G[to].emplace_back(from, true, G[from].size() - 1, 0, -co);\n        r_edges.emplace_back(to, G[to].size() - 1);\n    }\n    // k 番目の辺にいくつ流れたか\n    CapTp get_flowed_cap(size_t k) {\n        if(r_edges.size() <= k) return -1;\n        int v, i; tie(v, i) = r_edges[k];\n        return G[v][i].cap;\n    }\n    // s -> t 最大流\n    CapTp max_flow(int s, int t) {\n        vector<bool> used(G.size());\n        auto dfs = [&](auto &&func, int v, int t, CapTp f) -> CapTp {\n            if(v == t) return f;\n            used[v] = true;\n            for(auto &e : G[v]) {\n                if(used[e.to] or e.cap == 0) continue;\n                CapTp d = func(func, e.to, t, min(f, e.cap));\n                if(d == 0) continue;\n                e.cap -= d; G[e.to][e.rev].cap += d;\n                return d;\n            }\n            return 0;\n        };\n\n        CapTp res(0);\n        while(true) {\n            fill(used.begin(), used.end(), false);\n            CapTp delta = dfs(dfs, s, t, IA);\n            if(delta == 0) return res;\n            res += delta;\n        }\n    }\n\n    bool is_equal(CostTp a, CostTp b) {\n        valarray<bool> x = (a == b);\n        for(auto e : x) if(!e) return false;\n        return true;\n    }\n\n    bool is_greateq(CostTp a, CostTp b) {\n        for(size_t i=0; i<a.size(); i++) {\n            if(a[i] < b[i]) return true;\n            if(a[i] > b[i]) return false;\n        }\n        return is_equal(a, b);\n    }\n\n    // ベルマンフォードをつかって最小費用流\n    CostTp mincost_flow(int s, int t, CapTp f) {\n        vector<CostTp> dist(G.size()); CostTp res = valarray<int>(B);\n        vector<int> prevv(G.size()), preve(G.size());\n        while(f > 0) {\n            fill(dist.begin(), dist.end(), IO);\n            dist[s] = valarray<int>(B);\n            while(1) {\n                bool upd = false;\n                for(int v=0; v<(int)G.size(); v++) {\n                    if(is_equal(dist[v], IO)) continue;\n                    for(size_t i=0; i<G[v].size(); i++) {\n                        auto &e = G[v][i];\n                        if(e.cap == 0 or is_greateq(dist[e.to], dist[v] + e.cost)) continue;\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v, preve[e.to] = i;\n                        upd = true;\n                    }\n                }\n                if(!upd) break;\n            }\n\n            if(is_equal(dist[t], IO)) return IO;\n            \n            CapTp d = f;\n            for(int v=t; v!=s; v=prevv[v]) d = min(d, G[prevv[v]][preve[v]].cap);\n            f -= d; res += d * dist[t];\n            for(int v=t; v!=s; v=prevv[v]) {\n                auto &e = G[prevv[v]][preve[v]];\n                e.cap -= d, G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n    // ポテンシャルの導入により、ダイクストラ法で最小費用流を解く\n    // [仮定している条件]\n    //     1. グラフに負の閉路が存在しない (流量の 0 初期化のため)\n    //        もし存在するならベルマンフォードで負の閉路を見つけ\n    //        そこに流せるだけ流してスタート\n    //     2. グラフに負の辺が存在しない (pot_0 の計算可能性)\n    //        もし存在する場合は最初のみベルマンフォードを使う必要あり\n    CostTp fast_mincost_flow(int s, int t, CapTp f) {\n        CostTp res = valarray<int>(B);\n        vector<CostTp> dist(G.size()), pot(G.size());\n        vector<int> prevv(G.size()), preve(G.size());\n        while(f > 0) {\n            using PT = pair<CostTp, int>;\n            priority_queue< PT, vector<PT>, greater<PT> > que;\n            fill(dist.begin(), dist.end(), IO);\n\n            dist[s] = 0;\n            que.push(make_pair(0, s));\n            while(!que.empty()) {\n                PT cur = que.top(); que.pop();\n                int v = cur.second;\n                if(dist[v] < cur.first) continue;\n                for(size_t i=0; i<G[v].size(); i++) {\n                    auto& e = G[v][i];\n                    if(e.cap > 0 and dist[e.to] > dist[v] + e.cost + pot[v] - pot[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + pot[v] - pot[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t] == IO) {\n                return -1;\n            }\n            for(int v=0; v<(int)G.size(); v++) pot[v] += dist[v];\n\n            CapTp d = f;\n            for(int v=t; v!=s; v=prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * pot[t];\n            for(int v=t; v!=s; v=prevv[v]) {\n                auto& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }    \n};\n\nint main() {\n    int N; cin >> N;\n\n    vector< vector< pair<int, int> > > groups(B);\n    vector< vector<int> > indices(B);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n            char c; cin >> c;\n            groups[get_ord(c)].emplace_back(i, j);\n        }\n    }\n\n    string ans = \"\";\n    valarray<int> MAXARRAY(60, B);\n    Flow< int, valarray<int> > fl(2*N + 2, 1 << 29, MAXARRAY);\n    int source = 2*N, sink = source + 1;\n\n    int k = 0;\n    for(int t=0; t<B; t++) {\n        for(size_t i=0; i<groups[t].size(); i++) {\n            int r, c; tie(r, c) = groups[t][i];\n            indices[t].emplace_back(k++);\n            valarray<int> vec(B); vec[t] = -1;\n            fl.add_edge(r, N+c, 1, vec);\n        }\n    }\n\n    for(int i=0; i<N; i++) {\n        valarray<int> vec(B);\n        fl.add_edge(source, i, 1, vec);\n        fl.add_edge(N+i, sink, 1, vec);\n    }\n\n    auto mincost = fl.mincost_flow(source, sink, N);\n    if(mincost[0] == 60) return 1;\n\n    for(int t=0; t<B; t++) {\n        char chr = get_chr(t);\n        ans += string(-mincost[t], chr);\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 50\nusing namespace std;\ntypedef pair<char,string> P;\ntypedef pair<int,int> P1;\n\nint n;\nstring s[N];\nint dy[2]={-1,1};\nint dx[2]={0,0};\n\nvoid solve(){\n  string ans;\n  \n  while(n){\n    \n    map<P,vector<P1> > memo;\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\t\n\tstring str;\n\t\n\tfor(int k=0;k<2;k++){\n\t  \n\t  int ny=i+dy[k],nx=j+dx[k];\n\t  \n\t  while(1){\n\t    \n\t    if(ny<0||nx<0||n<=ny||n<=nx)break;\n\t    \n\t    str+=s[ny][nx];\n\t    \n\t    ny+=dy[k],nx+=dx[k];\n\t  }\n\t  \n\t}\n\t\n\tsort(str.begin(),str.end());\n\t\n\tmemo[P(s[i][j],str)].push_back(P1(i,j));\n      }\n    }\n    \n    map<P,vector<P1> >::iterator ite=memo.begin();\n    \n    int y,x;\n    char minc=(*ite).first.first;\n    \n    ans+=minc;\n    \n    while(ite!=memo.end()){\n      \n      if(minc<(*ite).first.first)break;\n      else y=(*ite).second[0].first,x=(*ite).second[0].second;\n      ite++;\n    }\n    \n    string t[N];\n    int idx=0;\n    \n    for(int i=0;i<n;i++){\n      if(y==i)continue;\n      for(int j=0;j<n;j++){\n\t\n\tif(x==j)continue;\n\t\n\tt[idx]+=s[i][j];\n      }\n      idx++;\n    }\n    \n    n--;\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)s[i][j]=t[i][j];\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>s[i];\n  \n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 50\nusing namespace std;\ntypedef pair<char,string> P;\ntypedef pair<int,int> P1;\n\nint n;\nstring s[N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nvoid solve(){\n  string ans;\n  \n  while(n){\n    \n    map<P,vector<P1> > memo;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\n\tstring str;\n\t\n\tfor(int k=0;k<4;k++){\n\t  \n\t  int ny=i+dy[k],nx=j+dx[k];\n\t  \n\t  while(1){\n\t    \n\t    if(ny<0||nx<0||n<=ny||n<=nx)break;\n\t    \n\t    str+=s[ny][nx];\n\n\t    ny+=dy[k],nx+=dx[k];\n\t  }\n\t  \n\t}\n\t\n\tsort(str.begin(),str.end());\n\t\n\tmemo[P(s[i][j],str)].push_back(P1(i,j));\n      }\n    }\n    \n        \n    map<P,vector<P1> >::iterator ite=memo.begin();\n    \n    int y,x;\n    char minc=(*ite).first.first;\n    \n    ans+=minc;\n    \n    while(ite!=memo.end()){\n      \n      if(minc<(*ite).first.first)break;\n      else y=(*ite).second[0].first,x=(*ite).second[0].second;\n      ite++;\n    }\n    \n    string t[N];\n    int idx=0;\n    \n    for(int i=0;i<n;i++){\n      if(y==i)continue;\n      for(int j=0;j<n;j++){\n\t\n\tif(x==j)continue;\n\t\n\tt[idx]+=s[i][j];\n      }\n      idx++;\n    }\n    \n    n--;\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)s[i][j]=t[i][j];\n\n  }\n\n  cout<<ans<<endl;\n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>s[i];\n\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include<queue>\nusing namespace std;\nconst int N = 1e5+10, M = 1e5, mod = 1e9, inf = 1e9+9;\ntypedef long long ll;\n\nint n,v[N],c[N];\nchar mp[500][500];\nstruct ss{\n    char a;\n    int x,y;\n    friend bool operator < (ss a, ss b){return a.a > b.a;}\n};\npriority_queue<ss> q;\nchar ans[N];\nint main() {\n    while(scanf(\"%d\",&n)!=EOF) {\n            memset(v,0,sizeof(v));\n    memset(c,0,sizeof(c));\n            while(!q.empty()) q.pop();\n        for(int i=1;i<=n;i++) scanf(\"%s\",mp[i]+1);\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=n;j++) {\n                q.push((ss){mp[i][j],i,j});\n            }\n        }\n        int cnt = 0;\n        while(!q.empty()) {\n            ss k = q.top();\n            q.pop();\n            if(!v[k.x]&&!c[k.y]) {\n                ans[++cnt] = k.a;\n                v[k.x]=c[k.y]=1;\n            }\n        }\n        for(int i=1;i<cnt;i++) cout<<ans[i];\n            cout<<ans[cnt]<<endl;\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 200\n#define INF (1e9)\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  \n  int n;\n  cin>>n;\n\n  V=n*2+2;\n\n  string str;\n  \n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<n;j++)\n      add_edge(i,j+n,1,str[j]);\n  }\n\n  int s=n*2,t=s+1;  \n\n  for(int i=0;i<n;i++)\n    add_edge(s,i,1,0);\n  \n  for(int i=0;i<n;i++)\n    add_edge(i+n,t,1,0);\n\n  min_cost_flow(s,t,INF);\n  \n  string ans;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++)\n      if(!G[i][j].cap)ans+=G[i][j].cost;\n  \n  sort(ans.begin(),ans.end());\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  string s[n],ans;\n  for(int i=0;i<n;i++) cin>>s[i];\n  \n  for(int k=0;k<n-1;k++){\n    int ti=k,tj=k;\n    for(int i=k;i<n;i++){\n      for(int j=k;j<n;j++){\n\tif(s[ti][tj]==s[i][j]){\n\t  char p='z',q='z';\n\t  for(int a=k;a<n;a++){\n\t    for(int b=k;b<n;b++){\n\t      if(a==i||b==j) p=min(p,s[a][b]);\n\t      if(a==ti||b==tj) q=min(q,s[a][b]);\n\t    }\n\t  }\n\t  if(p>q) ti=i,tj=j;\n\t}\n\tif(s[ti][tj]>s[i][j]) ti=i,tj=j;\n      }\n    }\n    swap(s[ti],s[k]);\n    for(int l=0;l<n;l++) swap(s[l][tj],s[l][k]);\n  }\n  bool f=1;\n  while(f){\n    f=0;\n    for(int k=0;k<n;k++){\n      for(int i=0;i<k;i++){\n\tfor(int j=0;j<k;j++){\n\t  if(i==j) continue;\n\t  if(s[i][j]<s[k][k]&&s[j][j]==s[j][k]&&s[i][i]==s[k][i]) {\n\t    swap(s[i],s[k]);\n\t    for(int l=0;l<n;l++) swap(s[l][j],s[l][k]);\n\t    f=1;\n\t  }\n\t}\n      }\n    }\n    //cout<<endl;for(int i=0;i<n;i++) cout<<s[i]<<endl;\n  }\n  for(int i=0;i<n;i++) ans+=s[i][i];\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  string s[n],ans;\n  for(int i=0;i<n;i++) cin>>s[i];\n  \n  for(int k=0;k<n-1;k++){\n    int ti=k,tj=k;\n    for(int i=k;i<n;i++){\n      for(int j=k;j<n;j++){\n\tif(s[ti][tj]==s[i][j]){\n\t  char p='z',q='z';\n\t  for(int a=k;a<n;a++){\n\t    for(int b=k;b<n;b++){\n\t      if(a==i||b==j) p=min(p,s[a][b]);\n\t      if(a==ti||b==tj) q=min(q,s[a][b]);\n\t    }\n\t  }\n\t  if(p>q) ti=i,tj=j;\n\t}\n\tif(s[ti][tj]>s[i][j]) ti=i,tj=j;\n      }\n    }\n    swap(s[ti],s[k]);\n    for(int l=0;l<n;l++) swap(s[l][tj],s[l][k]);\n  }\n  \n  for(int k=0;k<n-1;k++){\n    for(int i=0;i<k;i++){\n      if(s[i][k]<=s[k][k]&&s[i][i]==s[k][i]) {\n\tswap(s[i],s[k]);\n\tfor(int j=0;j<k;j++){\n\t  if(s[k][j]<=s[k][k]&&s[j][j]==s[j][k]){\n\t    for(int l=0;l<n;l++) swap(s[l][j],s[l][k]);\n\t    \n\t    int tti=k,ttj=k;\n\t    for(int ii=k;ii<n;ii++){\n\t      for(int jj=k;jj<n;jj++){\n\t\tif(s[tti][ttj]>s[ii][jj]) tti=ii,ttj=jj;\n\t      }\n\t    }\n\t    swap(s[tti],s[k]);\n\t    for(int l=0;l<n;l++) swap(s[l][ttj],s[l][k]);\n\t    \n\t  }\n\t}\n      }\n    }\n    //cout<<endl;for(int i=0;i<n;i++) cout<<s[i]<<endl;\n  }\n  for(int i=0;i<n;i++) ans+=s[i][i];\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1<<28\ntypedef pair<int,int> P;\nstruct edge{\n  int to,cap,cost,rev;\n  edge(){}\n  edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back(edge(to,cap,cost,G[to].size()));\n  G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+V,0);\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;v<V;v++) h[v]+=dist[v];\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  string str[n],ans;\n  for(int i=0;i<n;i++) cin>>str[i];\n  V=n*2+2;\n  int s=n*2,t=n*2+1;\n  for(int i=0;i<n;i++){\n    add_edge(s,i,1,0);\n    add_edge(n+i,t,1,0);\n  }\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      add_edge(i,n+j,1,str[i][j]);\n  \n  min_cost_flow(s,t,n);\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      if(G[i][j].cap) continue;\n      ans+=str[i][G[i][j].to-n];\n    }\n  }\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint V;\nvector<int> G[102];\nint match[102];\nbool used[102];\n\nvoid init(int v){\n  V=v;\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0; i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_match(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0; v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nint N;\nstring s[55];\nmap<char,vector<P> > query;\n\nint main(){\n  cin>>N;\n  rep(i,N)cin>>s[i];\n  rep(i,N){\n    rep(j,N){\n      query[s[i][j]].push_back(P(i,j));\n    }\n  }\n\n  string res;\n  int mx=0,pre=0;\n  init(2*N);\n  for(auto it : query){\n    for(P p : it.se){\n      add_edge(p.fi,p.se+N);\n    }\n    mx=bipartite_match();\n    rep(i,mx-pre)res+=it.fi;\n    pre=mx;\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\n#include <time.h>\nusing namespace std;\nlong double esp=1e-11;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define cle(a) while(!a.empty())a.pop()\n#define mem(p) memset(p,0,sizeof(p))\n#define memf(p) memset(p,0x3f,sizeof(p))\n#define memn(p) memset(p,-1,sizeof(p))\n#define mp(A, B) make_pair(A, B)\n#define pb push_back\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\ntypedef long long int LL;\nconst long double PI = acos((long double)-1);\nconst LL INF=0x3f3f3f3fll;\nconst int MOD = 1000000007;\nconst int maxn=110000;\n#define V 110\n#define E 45100\nint vis[V];\nint dist[V];\nint pre[V];\n\nstruct Edge{\n    int u,v,c,cost,next;\n}edge[E];\nint head[V],cnt;\n\nvoid init(){\n    cnt=0;\n    memset(head,-1,sizeof(head));\n}\nvoid addedge(int u,int v,int c,int cost)\n{\n    edge[cnt].u=u;edge[cnt].v=v;edge[cnt].cost=cost;\n    edge[cnt].c=c;edge[cnt].next=head[u];head[u]=cnt++;\n\n    edge[cnt].u=v;edge[cnt].v=u;edge[cnt].cost=-cost;\n    edge[cnt].c=0;edge[cnt].next=head[v];head[v]=cnt++;\n}\n\nbool spfa(int begin,int end){\n    int u,v;\n    queue<int> q;\n    for(int i=0;i<=end+2;i++){\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=INF;\n    }\n    vis[begin]=1;\n    dist[begin]=0;\n    q.push(begin);\n    while(!q.empty()){\n        u=q.front();\n        q.pop();\n        vis[u]=0;\n        for(int i=head[u];i!=-1;i=edge[i].next){\n            if(edge[i].c>0){\n                v=edge[i].v;\n                if(dist[v]>dist[u]+edge[i].cost){\n                    dist[v]=dist[u]+edge[i].cost;\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    return dist[end]!=INF;\n}\n\nint MCMF(int begin,int end){\n    int ans=0,flow;\n    int flow_sum=0;\n    while(spfa(begin,end)){\n        flow=INF;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u])\n            if(edge[i].c<flow)\n                flow=edge[i].c;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u]){\n            edge[i].c-=flow;\n            edge[i^1].c+=flow;\n        }\n        ans+=dist[end];\n        flow_sum += flow;\n    }\n    //cout << flow_sum << endl;\n    return ans;\n}\nchar s[110];\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"inlay.in\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    //map<long long int,int>ma;                 %I64d\n    //vector<int>::iterator iter;\n    //memset(m,0,sizeof(int));\n    //for(int x=1;x<=n;x++)\n    //for(int y=1;y<=n;y++)\n    //scanf(\"%d%d\",&a,&b);\n    //scanf(\"%d\",&a);\n    //printf(\"%d\\n\",ans);\n    int n;\n    scanf(\"%d\",&n);\n    init();\n    int st=105,ed=106;\n    for(int x=0;x<n;x++)\n        addedge(st,x,1,0),addedge(n+x,ed,1,0);\n\n    for(int x=0;x<n;x++)\n    {\n        scanf(\"%s\",s);\n        for(int y=0;y<n;y++)\n            addedge(x,n+y,1,s[y]);\n    }\n    MCMF(st,ed);\n    vector<char>ans;\n    ans.clear();\n    for(int x=0;x<cnt;x++)\n        if(edge[x].u>=n&&edge[x].u<2*n&&edge[x].v<n&&edge[x].c>0)\n            ans.pb(-edge[x].cost);\n    sort(all(ans));\n    for(int x=0;x<n;x++)\n        printf(\"%c\",ans[x]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> add(vector<int> a,vector<int> b){\n  vector<int> res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]+b[i];\n  return res;\n}\n\nvector<int> sub(vector<int> a){\n  vector<int> res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=-a[i];\n  return res;\n}\n\n\nint change(char ch){\n  int res;\n  if('A'<=ch&&ch<='Z'){\n    res= ch-'A';\n  }else{\n    res= 26+ch-'a';\n  }\n  return 59-res;\n}\n\nint N;\nchar mp[50][50];\nint t[50][50];\n\nstruct edge{\n  int to;\n  int cap;\n  vector<int> cost;\n  int rev;\n\n  edge( int a,int b, vector<int> c,int d){\n    to=a;\n    cap=b;\n    cost=c;\n    rev=d;\n  }\n};\n\n#define MAX_V (105)\n\nvector<edge> G[MAX_V];\nvector<int> h[MAX_V];\nvector<int> dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,vector<int> cost){\n  G[from].push_back( edge(to,cap,cost,G[to].size() ) );\n  G[to].push_back(   edge(from,0, sub(cost) ,G[from].size()-1 ) );\n}\n\ntypedef pair< vector<int> , int > P;\n\nvector<int> min_cost_flow(int s,int t,int f){\n  vector<int> res(60,0);\n  \n  fill( h, h+MAX_V, vector<int>(60,0) );\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > Q;\n    fill(dist,dist+MAX_V, vector<int>(60,1e8) );\n    dist[s]= vector<int>(60,0);\n    Q.push(P( dist[s] ,s));\n    while(!Q.empty()){\n      P p=Q.top();Q.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      \n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0){\n\n          vector<int> tmp = add(dist[v],e.cost);\n          tmp=add(tmp,h[v]);\n          vector<int> tmp2 = sub(h[e.to]);\n          tmp = add(tmp, tmp2);\n\n          \n          if(dist[e.to]>tmp){\n            dist[e.to]=tmp;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            Q.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n    }\n\n    \n    for(int v=0;v<MAX_V;v++)h[v]=add(h[v],dist[v]);\n    \n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    f-=d;\n    \n    res=add(res,h[t]);\n    \n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  \n  cin>>N;\n  int si=N+N;\n  int ti=N+N+1;\n\n  map< int , char > dm;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      char ch;\n      cin>>ch;\n      dm[ change(ch) ] = ch;\n      mp[i][j]=ch;\n    }\n  }\n\n    \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      t[i][j]=G[i].size();\n      vector<int> tmp(60,0);\n      tmp[ change(mp[i][j]) ] =  1;\n      add_edge(i,N+j,1,tmp);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    vector<int> tmp(60,0);\n    add_edge(si,i,1,tmp);\n    add_edge(N+i,ti,1,tmp);\n  }\n\n  vector<int> vec = min_cost_flow(si,ti,N);\n\n  string ans=\"\";\n\n\n  for(int i=0;i<60;i++){\n    for(int j=0;j<vec[i];j++){\n      ans+= dm[i];\n    }\n  }\n  assert((int)ans.size()==N);\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  /*\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      edge e=G[i][ t[i][j] ];\n      if(e.cap==0)ans+=mp[i][j];\n    }\n  }\n\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint change(char ch){\n  if('A'<=ch&&ch<='Z'){\n    return ch-'A';\n  }else{\n    return 26+ch-'a';\n  }\n}\n\nint N;\ndouble po[60];\nchar mp[50][50];\nint t[50][50];\n\nstruct edge{\n  int to;\n  int cap;\n  double cost;\n  int rev;\n};\n\n#define MAX_V (105)\n\nvector<edge> G[MAX_V];\nlong double h[MAX_V];\nlong double dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\ndouble eps=0.00000001;\n\nvoid add_edge(int from,int to,int cap,double cost){\n  G[from].push_back( (edge){to,cap,cost,(int)G[to].size() } );\n  G[to].push_back(   (edge){from,0,-cost,(int)G[from].size()-1 } );\n}\n\ntypedef pair< double , int > P;\n\ndouble min_cost_flow(int s,int t,int f){\n  double res=0;\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > Q;\n    fill(dist,dist+MAX_V, po[59]);\n    dist[s]=0;\n    Q.push(P(0,s));\n    while(!Q.empty()){\n      P p=Q.top();Q.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      \n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&dist[e.to]-eps>dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          Q.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==po[59])return -1;\n    for(int v=0;v<MAX_V;v++)h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=(double)d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  po[0]=1;\n  for(int i=1;i<60;i++)po[i]=po[i-1]*100;\n\n  cin>>N;\n  int si=N+N;\n  int ti=N+N+1;\n\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      char ch;\n      cin>>ch;\n      mp[i][j]=ch;  \n      t[i][j]=G[i].size();\n      add_edge(i,N+j,1,po[ change(ch) ]);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    add_edge(si,i,1,0);\n    add_edge(N+i,ti,1,0);\n  }\n\n  double ansf=min_cost_flow(si,ti,N);\n\n  string ans=\"\";\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      edge e=G[i][ t[i][j] ];\n      if(e.cap==0)ans+=mp[i][j];\n    }\n  }\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint change(char ch){\n  if('A'<=ch&&ch<='Z'){\n    return ch-'A';\n  }else{\n    return 26+ch-'a';\n  }\n}\n\nint N;\nlong double po[60];\nchar mp[50][50];\nint t[50][50];\n\nstruct edge{\n  int to;\n  int cap;\n  long double cost;\n  int rev;\n};\n\n#define MAX_V (105)\n\nvector<edge> G[MAX_V];\nlong double h[MAX_V];\nlong double dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nlong double eps=0.00000001;\n\nvoid add_edge(int from,int to,int cap,long double cost){\n  G[from].push_back( (edge){to,cap,cost,(int)G[to].size() } );\n  G[to].push_back(   (edge){from,0,-cost,(int)G[from].size()-1 } );\n}\n\ntypedef pair< long double , int > P;\n\nlong double min_cost_flow(int s,int t,int f){\n  long double res=0;\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > Q;\n    fill(dist,dist+MAX_V, po[59]);\n    dist[s]=0;\n    Q.push(P(0,s));\n    while(!Q.empty()){\n      P p=Q.top();Q.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      \n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&dist[e.to]-eps>dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          Q.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==po[59])return -1;\n    for(int v=0;v<MAX_V;v++)h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=(long double)d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  po[0]=1;\n\n  cin>>N;\n  int si=N+N;\n  int ti=N+N+1;\n\n  map< char , int > cnt;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      char ch;\n      cin>>ch;\n      cnt[ change(ch) ]++;\n      mp[i][j]=ch;\n    }\n  }\n\n  po[0]=1;\n  for(int i=1;i<60;i++){\n    po[i]=po[i-1]*( long double)( cnt[i-1]+2 );\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      t[i][j]=G[i].size();\n      add_edge(i,N+j,1,po[ change(mp[i][j]) ]);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    add_edge(si,i,1,0);\n    add_edge(N+i,ti,1,0);\n  }\n\n  long double ansf=min_cost_flow(si,ti,N);\n\n  string ans=\"\";\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      edge e=G[i][ t[i][j] ];\n      if(e.cap==0)ans+=mp[i][j];\n    }\n  }\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nconst int M=52;\n\nvector<int> operator+(const vector<int>& a,const vector<int>& b){\n  vector<int> res(M);\n  rep(i,M)res[i]=a[i]+b[i];\n  return res;\n}\nbool operator<(const vector<int>& a,const vector<int>& b){\n  rep(i,M){\n    if(a[i]!=b[i])return a[i]<b[i];\n  }\n  return true;\n}\n\nstruct edge{\n  int to,cap;\n  vector<int> cost;\n  int rev;\n};\n\nint V;\nint N;\nvector<edge> g[202];\nint h[202];\nvector<int> dist[202];\nint prevv[202],preve[202];\nvector<int> vinf;\n\nvoid init(int v){\n  V=v;\n  vinf=vector<int>(M,INF);\n  for(int i=0;i<V;i++){\n    g[i].clear();\n  }\n}\n\nvoid add_edge(int from,int to,int cap,vector<int> cost){\n  g[from].push_back((edge){to,cap,cost,(int)g[to].size()});\n  vector<int> rev=cost;\n  rep(i,cost.size())rev[i]=-rev[i];\n  g[to].push_back((edge){from,0,rev,(int)g[from].size()-1});\n}\n\nvector<int> min_cost_flow(int s,int t,int f){\n  vector<int> res=vector<int>(M,0);\n  memset(h,0,sizeof(h));\n  while(f>0){\n    rep(i,V)dist[i]=vinf;\n    dist[s]=vector<int>(M,0);\n    bool update=true;\n    while(update){\n      update=false;\n      for(int v=0;v<V;v++){\n        if(dist[v]==vinf)continue;\n        for(int i=0;i<g[v].size();i++){\n          edge &e=g[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost){\n            dist[e.to]=dist[v]+e.cost;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            update=true;\n          }\n        }\n      }\n    }\n    if(dist[t]==vinf) return vinf;\n\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,g[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    rep(i,M)res[i]=res[i]+d*dist[t][i];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=g[prevv[v]][preve[v]];\n      e.cap-=d;\n      g[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nstring s[55];\nvector<int> costs[55];\n\nint main(){\n  cin>>N;\n  rep(i,N)cin>>s[i];\n  int source=N*2,sink=N*2+1;\n  init(2*N+2);\n  rep(i,M){\n    vector<int> tmp(M,1000);\n    tmp[i]=999;\n    costs[i]=tmp;\n  }\n  rep(i,N){\n    add_edge(source,i,1,vector<int>(M,0));\n    add_edge(i+N,sink,1,vector<int>(M,0));\n  }\n  rep(i,N){\n    rep(j,N){\n      if('A'<=s[i][j]&&s[i][j]<='Z'){\n        add_edge(i,j+N,1,costs[s[i][j]-'A']);\n      }else{\n        add_edge(i,j+N,1,costs[s[i][j]-'a'+26]);\n      }\n    }\n  }\n  vector<int> res=min_cost_flow(source,sink,N);\n  string ans;\n  rep(i,M){\n    rep(j,N*1000-res[i]){\n      if(i>=0&&i<26){\n        ans+=(char)('A'+i);\n      }else{\n        ans+=(char)('a'+i-26);\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1<<28);\nconst int MAX_V = 200;\n\nconst int S=52;\n\nstruct state{\n  vector<int> v;\n  state(vector<int> v): v(v) {}\n  state( char c ){\n    v = vector<int>(S);\n    if( c <= 'Z' ) v[c-'A']=-1;\n    else v[26+c-'a']=-1;\n  }\n  state(int x){\n    v=vector<int>(S,x);\n  }\n  state(){}\n  state operator+(const state& x) const{\n    vector<int> res(v.size());\n    for(int i=0;i<(int)res.size();i++)\n      res[i] = v[i]+x.v[i];\n    return state(res);\n  }\n  state operator-(const state& x){\n    vector<int> res(v.size());\n    for(int i=0;i<(int)res.size();i++)\n      res[i] = v[i]-x.v[i];\n    return state(res);\n  }\n  state operator*(int x){\n    vector<int> res=v;\n    for(int i=0;i<(int)res.size();i++) res[i]*=x;\n    return res;\n  }\n  state operator*=(int x){\n    for(int i=0;i<(int)v.size();i++) v[i]*=x;\n    return *this;\n  }\n  bool operator<(const state& x) const{\n    for(int i=0;i<(int)v.size();i++){\n      if( v[i] == x.v[i] ) continue;\n      return v[i] < x.v[i];\n    }\n    return false;\n  }\n  bool operator==(const state& x) const{\n    for(int i=0;i<x.v.size();i++)\n      if( v[i] != x.v[i] ) return false;\n    return true;\n  }\n  void view(){\n    for(int i=0;i<v.size();i++){\n      cout << v[i] << \" \";\n    }\n    cout << endl;\n  }\n};\n\nstruct edge{\n  int to, cap,rev;\n  state cost;\n  edge( int to, int cap, state cost, int rev){\n    this->to = to;\n    this->cap = cap;\n    this->cost = cost;\n    this->rev = rev;\n  }\n  edge(){}\n};\n\n\ntypedef pair<state,int> P;\n\nint V;\nvector<edge> G[MAX_V];\nstate h[MAX_V];\nstate dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n \nvoid add_edge(int from,int to,int cap,state cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, cost*-1 , (int)G[from].size() - 1});\n}\n\nstate min_cost_flow(int s,int t,int f){\n  state res = state(0);\n  fill( h, h+V, state(0));\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,state(INF) );\n    dist[s] = state(0);\n    que.push(P(dist[s],s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < (int)G[v].size() ; i++){\n        edge &e = G[v][i];\n         \n        if(e.cap > 0 && dist[v] + e.cost + h[v] - h[e.to] < dist[e.to] ){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if( dist[t] == state(INF) ){\n      return -1;\n    }\n \n    for(int v = 0 ; v < V ; v++) h[v] = h[v]+dist[v];\n       \n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res = res + (h[t] * d);\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint N;\nchar c[55][55];\nbool flx[55],fly[55];\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin >> c[i][j];\n\n  V = 2*N+2;\n  int s = 2*N, t = 2*N+1;\n\n  for(int i=0;i<N;i++){\n    add_edge(s,i,1,state(0));\n    add_edge(N+i,t, 1,state(0));\n    for(int j=0;j<N;j++){\n      add_edge(i,N+j,1, state(c[i][j]) );\n    }\n  }\n  string alp=\"ABCDEFGHIJKLMNOPQRTSUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  state res = min_cost_flow(s,t,N);\n  for(int i=0;i<S;i++){\n    for(int j=0;j<-res.v[i];j++ ){\n      cout << alp[i];\n    }\n  }\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  string s[n],ans,tmp;\n  for(int i=0;i<n;i++) cin>>s[i];\n  bool f=1;\n  while(f){\n    tmp=ans=\"\";\n    for(int i=0;i<n;i++) tmp+=s[i][i];\n    sort(tmp.begin(),tmp.end());\n    f=0;\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  if(s[i][j]<s[k][k]){\n\t    if((s[j][j]>=s[j][k]&&s[k][k]>s[j][k])||\n\t       (s[j][j]>s[j][k])||\n\t       (s[i][i]>=s[k][i]&&s[k][k]>s[k][i])||\n\t       (s[i][i]>s[k][i])) {\n\t      swap(s[i],s[k]);\n\t      for(int l=0;l<n;l++) swap(s[l][j],s[l][k]);\n\t      f=1;\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<n;i++) ans+=s[i][i];\n    sort(ans.begin(),ans.end());\n    if(ans==tmp) break;\n    //cout<<ans<<endl;\n  }\n  f=1;\n  while(f){\n    f=0;\n    for(int i=0;!f&&i<n;i++){\n      for(int j=0;!f&&j<n;j++){\n\tfor(int a=0;!f&&a<n;a++){\n\t  for(int b=0;!f&&b<n;b++){\n\t    char p[4]={s[i][i],s[a][a],s[j][j],s[b][b]};\n\t    char q[4]={s[a][i],s[i][a],s[j][b],s[b][j]};\n\t    sort(p,p+4);sort(q,q+4);\n\t    /*\n\t    for(int l=0;l<n;l++) ans+=s[l][l];\n\t    sort(ans.begin(),ans.end());\n\t    cout<<ans<<endl;ans=\"\";\n\t    cout<<p[0]<<p[1]<<p[2]<<p[3]<<\":\"<<q[0]<<q[1]<<q[2]<<q[3]<<endl;\n\t    \n\t    */\n\t    for(int l=0;l<4;l++){\n\t      f|=p[l]>q[l];\n\t      if(p[l]<q[l]) break;\n\t    }\n\t    \n\t    if(f){\n\t      swap(s[i],s[a]);\n\t      for(int l=0;l<n;l++) swap(s[l][j],s[l][b]);\n\t      /*\n\t\tcout<<p[0]<<p[1]<<p[2]<<p[3]<<endl;\n\t\tcout<<q[0]<<q[1]<<q[2]<<q[3]<<endl;\n\t\tans=\"\";\n\t\tfor(int l=0;l<n;l++) cout<<s[l]<<endl;\n\t\tfor(int l=0;l<n;l++) ans+=s[l][l];\n\t\tsort(ans.begin(),ans.end());\n\t\tcout<<ans<<endl;ans=\"\";\n\t      */\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  //for(int i=0;i<n;i++) cout<<s[i]<<endl;\n  ans=\"\";\n  for(int i=0;i<n;i++) ans+=s[i][i];\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) begin(a),end(a)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct BigInt {\n\tstatic const int kBase = 1000000000;\n\tstatic const int kBaseDigits = 9;\n\tvector<int> d;\n\tint sign;\n\tBigInt() :sign(1) {}\n\tBigInt(long long v) {\n\t\tsign = 1;\n\t\tif (v < 0)\n\t\t\tsign = -1, v = -v;\n\t\tfor (; v > 0; v = v / kBase)\n\t\t\td.emplace_back(v % kBase);\n\t}\n\tBigInt(const string &s) { read(s); }\n\n\tbool operator<(const BigInt &v)const {\n\t\tif (sign != v.sign)\n\t\t\treturn sign < v.sign;\n\t\tif (d.size() != v.d.size())\n\t\t\treturn d.size() * sign < v.d.size() * v.sign;\n\t\tfor (int i = d.size() - 1; i >= 0; i--)\n\t\t\tif (d[i] != v.d[i])\n\t\t\t\treturn d[i] * sign < v.d[i] * sign;\n\t\treturn false;\n\t}\n\tbool operator>(const BigInt &v)const { return v < *this; }\n\tbool operator<=(const BigInt &v)const { return !(v < *this); }\n\tbool operator>=(const BigInt &v)const { return !(*this < v); }\n\tbool operator==(const BigInt &v)const { return !(*this < v) && !(v < *this); }\n\tbool operator!=(const BigInt &v)const { return !(*this == v); }\n\n\tBigInt &operator+=(const BigInt &v) {\n\t\tif (sign == v.sign) {\n\t\t\tBigInt res = v;\n\t\t\tfor (int i = 0, carry = 0; i < (int)max(d.size(), v.d.size()) || carry; ++i) {\n\t\t\t\tif (i == (int)res.d.size())\n\t\t\t\t\tres.d.emplace_back(0);\n\t\t\t\tres.d[i] += carry + (i < (int)d.size() ? d[i] : 0);\n\t\t\t\tcarry = res.d[i] >= kBase;\n\t\t\t\tif (carry)\n\t\t\t\t\tres.d[i] -= kBase;\n\t\t\t}\n\t\t\treturn *this = res;\n\t\t}\n\t\telse\n\t\t\treturn *this -= (-v);\n\t}\n\tBigInt &operator-=(const BigInt &v) {\n\t\tif (sign == v.sign) {\n\t\t\tBigInt tmp = abs();\n\t\t\tif (abs() >= v.abs()) {\n\t\t\t\tBigInt res = *this;\n\t\t\t\tfor (int i = 0, carry = 0; i < (int)v.d.size() || carry; ++i) {\n\t\t\t\t\tres.d[i] -= carry + (i < (int)v.d.size() ? v.d[i] : 0);\n\t\t\t\t\tcarry = res.d[i] < 0;\n\t\t\t\t\tif (carry)\n\t\t\t\t\t\tres.d[i] += kBase;\n\t\t\t\t}\n\t\t\t\tres.trim();\n\t\t\t\treturn *this = res;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn *this = -(v - *this);\n\t\t}\n\t\telse\n\t\t\treturn *this += -v;\n\t}\n\tBigInt &operator*=(const BigInt &v) {\n\t\treturn *this = *this * v;\n\t}\n\tBigInt &operator/=(const BigInt &v) {\n\t\treturn *this = *this / v;\n\t}\n\tBigInt operator-()const {\n\t\tBigInt res = *this;\n\t\tres.sign = -sign;\n\t\treturn res;\n\t}\n\n\tBigInt operator+(const BigInt &v)const { return BigInt(*this) += v; }\n\tBigInt operator-(const BigInt &v)const { return BigInt(*this) -= v; }\n\tBigInt operator*(int v)const {\n\t\tBigInt res = *this;\n\t\tres *= v;\n\t\treturn res;\n\t}\n\tBigInt operator*(const BigInt &v)const {\n\t\tvector<int> a6 = convert_base(this->d, kBaseDigits, 6);\n\t\tvector<int> b6 = convert_base(v.d, kBaseDigits, 6);\n\t\tvll a(a6.begin(), a6.end());\n\t\tvll b(b6.begin(), b6.end());\n\t\twhile (a.size() < b.size())\n\t\t\ta.emplace_back(0);\n\t\twhile (b.size() < a.size())\n\t\t\tb.emplace_back(0);\n\t\twhile (a.size() & (a.size() - 1))\n\t\t\ta.emplace_back(0), b.emplace_back(0);\n\t\tvll c = karatsubaMultiply(a, b);\n\t\tBigInt res;\n\t\tres.sign = sign * v.sign;\n\t\tfor (int i = 0, carry = 0; i < (int)c.size(); i++) {\n\t\t\tlong long cur = c[i] + carry;\n\t\t\tres.d.emplace_back((int)(cur % 1000000));\n\t\t\tcarry = (int)(cur / 1000000);\n\t\t}\n\t\tres.d = convert_base(res.d, 6, kBaseDigits);\n\t\tres.trim();\n\t\treturn res;\n\t}\n\n\tBigInt operator/(const BigInt &v)const { return divmod(*this, v).first; }\n\tBigInt operator/(int v)const {\n\t\tBigInt res = *this;\n\t\tres /= v;\n\t\treturn res;\n\t}\n\tBigInt operator%(const BigInt &v)const {\n\t\treturn divmod(*this, v).second;\n\t}\n\tint operator%(int v)const {\n\t\tif (v < 0)\n\t\t\tv = -v;\n\t\tint m = 0;\n\t\tfor (int i = d.size() - 1; i >= 0; --i)\n\t\t\tm = (d[i] + m * (long long)kBase) % v;\n\t\treturn m * sign;\n\t}\n\n\tBigInt &operator*=(int v) {\n\t\tif (v < 0)\n\t\t\tsign = -sign, v = -v;\n\t\tfor (int i = 0, carry = 0; i < (int)d.size() || carry; ++i) {\n\t\t\tif (i == (int)d.size())\n\t\t\t\td.emplace_back(0);\n\t\t\tlong long cur = d[i] * (long long)v + carry;\n\t\t\tcarry = (int)(cur / kBase);\n\t\t\td[i] = (int)(cur % kBase);\n\t\t}\n\t\ttrim();\n\t\treturn *this;\n\t}\n\tBigInt &operator/=(int v) {\n\t\tif (v < 0)\n\t\t\tsign = -sign, v = -v;\n\t\tfor (int i = (int)d.size() - 1, rem = 0; i >= 0; --i) {\n\t\t\tlong long cur = d[i] + rem * (long long)kBase;\n\t\t\td[i] = (int)(cur / v);\n\t\t\trem = (int)(cur % v);\n\t\t}\n\t\ttrim();\n\t\treturn *this;\n\t}\n\tstatic pair<BigInt, BigInt> divmod(const BigInt &a1, const BigInt &b1) {\n\t\tint norm = kBase / (b1.d.back() + 1);\n\t\tBigInt a = a1.abs() * norm;\n\t\tBigInt b = b1.abs() * norm;\n\t\tBigInt q, r;\n\t\tq.d.resize(a.d.size());\n\n\t\tfor (int i = a.d.size() - 1; i >= 0; i--) {\n\t\t\tr *= kBase;\n\t\t\tr += a.d[i];\n\t\t\tint s1 = r.d.size() <= b.d.size() ? 0 : r.d[b.d.size()];\n\t\t\tint s2 = r.d.size() <= b.d.size() - 1 ? 0 : r.d[b.d.size() - 1];\n\t\t\tint d = ((long long)kBase * s1 + s2) / b.d.back();\n\t\t\tr -= b * d;\n\t\t\twhile (r < 0)\n\t\t\t\tr += b, --d;\n\t\t\tq.d[i] = d;\n\t\t}\n\n\t\tq.sign = a1.sign * b1.sign;\n\t\tr.sign = a1.sign;\n\t\tq.trim();\n\t\tr.trim();\n\t\treturn make_pair(q, r / norm);\n\t}\n\tvoid trim() {\n\t\twhile (!d.empty() && !d.back())\n\t\t\td.pop_back();\n\t\tif (d.empty())\n\t\t\tsign = 1;\n\t}\n\tbool isZero()const {\n\t\treturn d.empty() || (d.size() == 1 && !d[0]);\n\t}\n\n\tBigInt abs()const {\n\t\tBigInt res = *this;\n\t\tres.sign *= res.sign;\n\t\treturn res;\n\t}\n\n\tlong long longValue()const {\n\t\tlong long res = 0;\n\t\tfor (int i = d.size() - 1; i >= 0; i--)\n\t\t\tres = res * kBase + d[i];\n\t\treturn res * sign;\n\t}\n\n\tvoid read(const string &s) {\n\t\tsign = 1;\n\t\td.clear();\n\t\tint pos = 0;\n\t\twhile (pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')) {\n\t\t\tif (s[pos] == '-')\n\t\t\t\tsign = -sign;\n\t\t\t++pos;\n\t\t}\n\t\tfor (int i = s.size() - 1; i >= pos; i -= kBaseDigits) {\n\t\t\tint x = 0;\n\t\t\tfor (int j = max(pos, i - kBaseDigits + 1); j <= i; j++)\n\t\t\t\tx = x * 10 + s[j] - '0';\n\t\t\td.emplace_back(x);\n\t\t}\n\t\ttrim();\n\t}\n\n\tfriend istream& operator >> (istream &stream, BigInt &v) {\n\t\tstring s;\n\t\tstream >> s;\n\t\tv.read(s);\n\t\treturn stream;\n\t}\n\n\tfriend ostream& operator << (ostream &stream, const BigInt &v) {\n\t\tif (v.sign == -1)\n\t\t\tstream << '-';\n\t\tstream << (v.d.empty() ? 0 : v.d.back());\n\t\tfor (int i = (int)v.d.size() - 2; i >= 0; --i)\n\t\t\tstream << setw(kBaseDigits) << setfill('0') << v.d[i];\n\t\treturn stream;\n\t}\n\n\tstatic vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\n\t\tvector<long long> p(max(old_digits, new_digits) + 1);\n\t\tp[0] = 1;\n\t\tfor (int i = 1; i < (int)p.size(); i++)\n\t\t\tp[i] = p[i - 1] * 10;\n\t\tvector<int> res;\n\t\tlong long cur = 0;\n\t\tint cur_digits = 0;\n\t\tfor (int i = 0; i < (int)a.size(); i++) {\n\t\t\tcur += a[i] * p[cur_digits];\n\t\t\tcur_digits += old_digits;\n\t\t\twhile (cur_digits >= new_digits) {\n\t\t\t\tres.emplace_back(int(cur % p[new_digits]));\n\t\t\t\tcur /= p[new_digits];\n\t\t\t\tcur_digits -= new_digits;\n\t\t\t}\n\t\t}\n\t\tres.emplace_back((int)cur);\n\t\twhile (!res.empty() && !res.back())\n\t\t\tres.pop_back();\n\t\treturn res;\n\t}\n\n\tusing vll = vector<long long>;\n\tstatic vll karatsubaMultiply(const vll &a, const vll &b) {\n\t\tint n = a.size();\n\t\tvll res(n + n);\n\t\tif (n <= 32) {\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tres[i + j] += a[i] * b[j];\n\t\t\treturn res;\n\t\t}\n\n\t\tint k = n >> 1;\n\t\tvll a1(a.begin(), a.begin() + k);\n\t\tvll a2(a.begin() + k, a.end());\n\t\tvll b1(b.begin(), b.begin() + k);\n\t\tvll b2(b.begin() + k, b.end());\n\n\t\tvll a1b1 = karatsubaMultiply(a1, b1);\n\t\tvll a2b2 = karatsubaMultiply(a2, b2);\n\n\t\tfor (int i = 0; i < k; i++)\n\t\t\ta2[i] += a1[i];\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tb2[i] += b1[i];\n\n\t\tvll r = karatsubaMultiply(a2, b2);\n\t\tfor (int i = 0; i < (int)a1b1.size(); i++)\n\t\t\tr[i] -= a1b1[i];\n\t\tfor (int i = 0; i < (int)a2b2.size(); i++)\n\t\t\tr[i] -= a2b2[i];\n\n\t\tfor (int i = 0; i < (int)r.size(); i++)\n\t\t\tres[i + k] += r[i];\n\t\tfor (int i = 0; i < (int)a1b1.size(); i++)\n\t\t\tres[i] += a1b1[i];\n\t\tfor (int i = 0; i < (int)a2b2.size(); i++)\n\t\t\tres[i + n] += a2b2[i];\n\t\treturn res;\n\t}\n\n};\n\nBigInt gcd(const BigInt &x, const BigInt &y) { return y.isZero() ? x : gcd(y, x % y); }\nBigInt lcm(const BigInt &x, const BigInt &y) { return x / gcd(x, y) * y; }\n\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = BigInt;\n\tconst Cost kInfCost = BigInt(string(log10(pow(2500, 55)), '9'));\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<Cost> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), kInfCost);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == kInfCost)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tFlow d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += dist[t] * d;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tBigInt w[52];\n\tw[0] = 1;\n\trep(i, 0, 51) {\n\t\tw[i + 1] = w[i] * 2500;\n\t}\n\n\tint N; cin >> N;\n\tvector<vector<BigInt>> a(N, vector<BigInt>(N));\n\tvector<vector<char>> c(N, vector<char>(N));\n\trep(i, 0, N) rep(j, 0, N) {\n\t\tcin >> c[i][j];\n\t\tif (c[i][j] <= 'Z')\n\t\t\ta[i][j] = w[c[i][j] - 'A'];\n\t\telse\n\t\t\ta[i][j] = w[26 + c[i][j] - 'a'];\n\t}\n\n\tMinimumCostFlow mcf(N + N + 2);\n\tint s = mcf.n - 2, t = s + 1;\n\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tmcf.addArc(i, N + j, 1, a[i][j]);\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tmcf.addArc(s, i, 1, 0);\n\t\tmcf.addArc(N + i, t, 1, 0);\n\t}\n\tauto cost = mcf.minimumCostFlow(s, t, N);\n\tdump(cost);\n\n\tvector<char> ans;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif (mcf.g[i][j].cap == 0) {\n\t\t\t\tans.emplace_back(c[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tsort(all(ans));\n\trep(i, 0, ans.size())\n\t\tcout << ans[i];\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint change(char ch){\n  if('A'<=ch&&ch<='Z'){\n    return ch-'A';\n  }else{\n    return 26+ch-'a';\n  }\n}\n\nint N;\nlong double po[60];\nchar mp[50][50];\nint t[50][50];\n\nstruct edge{\n  int to;\n  int cap;\n  long double cost;\n  int rev;\n};\n\n#define MAX_V (105)\n\nvector<edge> G[MAX_V];\nlong double h[MAX_V];\nlong double dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nlong double eps=0.0000000001;\n\nvoid add_edge(int from,int to,int cap,long double cost){\n  G[from].push_back( (edge){to,cap,cost,(int)G[to].size() } );\n  G[to].push_back(   (edge){from,0,-cost,(int)G[from].size()-1 } );\n}\n\ntypedef pair< long double , int > P;\n\nlong double min_cost_flow(int s,int t,int f){\n  long double res=0;\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > Q;\n    fill(dist,dist+MAX_V, po[59]*100);\n\n    dist[s]=0;\n    Q.push(P(0,s));\n    while(!Q.empty()){\n      P p=Q.top();Q.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      \n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&dist[e.to]-eps>dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          Q.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==po[59])return -1;\n    \n    for(int v=0;v<MAX_V;v++)h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=(long double)d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  po[0]=1;\n\n  cin>>N;\n  int si=N+N;\n  int ti=N+N+1;\n\n  map< char , int > cnt;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      char ch;\n      cin>>ch;\n      cnt[ change(ch) ]++;\n      mp[i][j]=ch;\n    }\n  }\n\n  po[0]=1;\n  for(int i=1;i<60;i++){\n    po[i]=po[i-1]*50*50;\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      t[i][j]=G[i].size();\n      add_edge(i,N+j,1,po[ change(mp[i][j]) ]);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    add_edge(si,i,1,0);\n    add_edge(N+i,ti,1,0);\n  }\n\n  long double ansf=min_cost_flow(si,ti,N);\n\n  string ans=\"\";\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      edge e=G[i][ t[i][j] ];\n      if(e.cap==0)ans+=mp[i][j];\n    }\n  }\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = (1<<21);\nconst int MAX_V = 200;\n\nconst int S=52;\n\nstruct state{\n  vector<int> v;\n  state(vector<int> v): v(v) {}\n  state( char c ){\n    v = vector<int>(S);\n    if( c <= 'Z' ) v[c-'A']=-1;\n    else v[26+c-'a']=-1;\n  }\n  state(int x){\n    v=vector<int>(S,x);\n  }\n  state(){}\n  state operator+(const state& x) const{\n    vector<int> res(v.size());\n    for(int i=0;i<(int)res.size();i++)\n      res[i] = v[i]+x.v[i];\n    return state(res);\n  }\n  state operator-(const state& x){\n    vector<int> res(v.size());\n    for(int i=0;i<(int)res.size();i++)\n      res[i] = v[i]-x.v[i];\n    return state(res);\n  }\n  state operator*(int x){\n    vector<int> res=v;\n    for(int i=0;i<(int)res.size();i++) res[i]*=x;\n    return res;\n  }\n  state operator*=(int x){\n    for(int i=0;i<(int)v.size();i++) v[i]*=x;\n    return *this;\n  }\n  bool operator<(const state& x) const{\n    for(int i=0;i<(int)v.size();i++){\n      if( v[i] == x.v[i] ) continue;\n      return v[i] < x.v[i];\n    }\n    return false;\n  }\n  bool operator==(const state& x) const{\n    for(int i=0;i<x.v.size();i++)\n      if( v[i] != x.v[i] ) return false;\n    return true;\n  }\n  void view(){\n    for(int i=0;i<v.size();i++){\n      cout << v[i] << \" \";\n    }\n    cout << endl;\n  }\n};\n\nstruct edge{\n  int to, cap,rev;\n  state cost;\n  edge( int to, int cap, state cost, int rev){\n    this->to = to;\n    this->cap = cap;\n    this->cost = cost;\n    this->rev = rev;\n  }\n  edge(){}\n};\n\n\ntypedef pair<state,int> P;\n\nint V;\nvector<edge> G[MAX_V];\nstate h[MAX_V];\nstate dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n \nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    G[i].clear();\n  }\n}\n \nvoid add_edge(int from,int to,int cap,state cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, cost*-1 , (int)G[from].size() - 1});\n}\n\nstate min_cost_flow(int s,int t,int f){\n  state res = state(0);\n  fill( h, h+V, state(0));\n  while(f > 0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    fill(dist,dist + V,state(INF) );\n    dist[s] = state(0);\n    que.push(P(dist[s],s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v] < p.first)continue;\n      for(int i = 0 ; i < (int)G[v].size() ; i++){\n        edge &e = G[v][i];\n         \n        if(e.cap > 0 && dist[v] + e.cost + h[v] - h[e.to] < dist[e.to] ){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n    if( dist[t] == state(INF) ){\n      return -1;\n    }\n    //cout << \"t \" << t << endl;\n    //dist[t].view();\n \n    for(int v = 0 ; v < V ; v++) h[v] = h[v]+dist[v];\n       \n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    //cout << \"d \"<<d << endl;\n    //    h[t].view();\n    res = res + (h[t] * d);\n    //res.view();\n    for(int v = t ; v != s ; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint N;\nchar c[55][55];\nint main(){\n  cin >> N;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      cin >> c[i][j];\n\n  V = 2*N+2;\n  int s = 2*N, t = 2*N+1;\n\n  for(int i=0;i<N;i++){\n    add_edge(s,i,1,state(0));\n    add_edge(N+i,t, 1,state(0));\n    for(int j=0;j<N;j++){\n      add_edge(i,N+j,1, state(c[i][j]) );\n    }\n  }\n  string alp=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  state res = min_cost_flow(s,t,N);\n  for(int i=0;i<S;i++){\n    for(int j=0;j<-res.v[i];j++ ){\n      cout << alp[i];\n    }\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n\n// weight vector of each character\n// A-Z(26) and a-z(26)\nstruct weight\n{\n  vector<int> val;\n\n  // constructors\n  weight():val(52, 0){}\n  weight(int ini):val(52, ini){}\n  weight(vector<int> ini):val(ini){}\n\n  // arithmetic\n  // binary\n  weight operator + (weight r) {\n    vector<int> ret(52);\n    for(int i = 0; i < 52; i++) ret[i] = val[i] + r.val[i];\n    return weight(ret);\n  }\n  weight operator - (weight r) {\n    vector<int> ret(52);\n    for(int i = 0; i < 52; i++) ret[i] = val[i] - r.val[i];\n    return weight(ret);\n  }\n  weight operator * (int k) {\n    vector<int> ret(52);\n    for(int i = 0; i < 52; i++) ret[i] = val[i] * k;\n    return weight(ret);\n  }\n  // unary\n  weight& operator - () {\n    for(int i = 0; i < 52; i++) val[i] = -val[i];\n    return *this;\n  }\n\n  \n  // comparison\n  bool operator == (const weight& r) const {\n    return val == r.val;\n  }\n  bool operator < (const weight& r) const {\n    return val < r.val;\n  }\n\n  // assignment\n  weight& operator += (const weight& r) {\n    for(int i = 0; i < 52; i++) val[i] += r.val[i];\n    return *this;\n  }\n};\nusing P = pair<weight, int>;\n\nconst weight inf = weight(1LL << 55);\nconst weight zero = weight(0);\n\n// Sccessive Shortest Path(Primal Dual): minimum cost maximum flow\nstruct PrimalDual\n{\n  struct edge\n  {\n    int to, cap, rev;\n    weight cost;\n    edge(){}\n    edge(int to, int cap, weight cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}\n  };\n\n  vector< vector<edge> > graph;\n  vector<weight> mincost;\n  \n  PrimalDual(int V):graph(V), mincost(V){}\n  void add_edge(int s, int t, int cap, weight cost)\n  {\n    graph[s].emplace_back(t, cap, cost, graph[t].size());\n    graph[t].emplace_back(s, 0, -cost, graph[s].size()-1);\n  }\n  weight min_cost_flow(int s, int t, int f)\n  {\n    weight ret = zero;\n    vector<weight> h(graph.size(), zero);\n    vector<int> pv(graph.size(), -1);\n    vector<int> pe(graph.size(), -1);\n\n    while(f > 0) {\n     priority_queue< P, vector<P>, greater<P> > que;\n      fill(all(mincost), inf);\n      mincost[s] = zero;\n      que.push(P(zero, s));\n      \n      while(!que.empty()) {\n\tP p = que.top(); que.pop();\n\tint v = p.second;\n\tif(mincost[v] < p.first) continue;\n\tfor(int i = 0; i < graph[v].size(); i++) {\n\t  edge &e = graph[v][i];\n\t  weight cost = mincost[v] + e.cost + h[v] - h[e.to];\n\t  if(e.cap > 0 && cost < mincost[e.to]) {\n\t    mincost[e.to] = cost;\n\t    pv[e.to] = v, pe[e.to] = i;\n\t    que.push(P(mincost[e.to], e.to));\n\t  }\n\t}\n      }\n\n      if(mincost[t] == inf) return weight(-1);\n\n      for(int i = 0; i < graph.size(); i++) h[i] += mincost[i];\n      int d = f;\n      for(int v = t; v != s; v = pv[v]) d = min(d, graph[pv[v]][pe[v]].cap);\n      f -= d;\n      ret += h[t] * d;\n      for(int v = t; v != s; v = pv[v]) {\n\tedge& e = graph[pv[v]][pe[v]];\n\te.cap -= d;\n\tgraph[v][e.rev].cap += d;\n      }\n    }\n\n    return ret;\n  }\n};\n\nconst string a = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N; cin >> N;\n  int s = 2*N, t = s + 1;\n\n  PrimalDual graph(t + 1);\n\n  for(int i = 0; i < N; i++) {\n    graph.add_edge(s, i, 1, zero);\n    graph.add_edge(N + i, t, 1, zero);\n  }\n  \n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      char c; cin >> c;\n      weight w; w.val[a.find(c)] = -1;\n      graph.add_edge(i, N + j, 1, w);\n    }\n  }\n\n  weight mcf = graph.min_cost_flow(s, t, N);\n  for(int i = 0; i < 52; i++) {\n    for(int j = 0; j < -mcf.val[i]; j++) cout << a[i];\n  }\n  cout << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tSMALL,\n\tBIG,\n\tEQUAL,\n};\n\n#define NUM 150\n#define DIGIT 53\n\n//辺を表す構造体{行先、容量、コスト、逆辺のインデックス}\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_num,int arg_rev_index,bool is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tnum = arg_num;\n\t\tfor(int i = 0; i < DIGIT; i++)cost[i] = 0;\n\t\tif(num != -1){\n\t\t\tif(is_rev == false){\n\t\t\t\tcost[num] = -1;\n\t\t\t}else{\n\t\t\t\tcost[num] = 1;\n\t\t\t}\n\t\t}\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,num,cost[DIGIT],rev_index;\n};\n\nint V; //頂点数\nint H,W;\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint dist[NUM][DIGIT]; //最短距離\nint pre_node[NUM],pre_edge[NUM]; //直前の頂点と辺\nchar base_map[50][51];\n\n\n//桁1～52を、'A'～'z'に対応させる。桁0はBIG_NUMの重み。桁が小さいほど重みが大きい\nint getNUM(char ch){\n\n\tif(ch >= 'A' && ch <= 'Z'){\n\t\treturn ch - 'A'+1;\n\t}else{\n\t\treturn ch - 'a'+26+1;\n\t}\n}\n\nint getCHAR(int num){\n\n\tnum--;\n\n\tif(num <= 25){\n\t\treturn 'A'+num;\n\t}else{\n\t\treturn 'a'+num-26;\n\t}\n}\n\n\n//fromからtoへ向かう容量capacity,コストcostの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity,int arg_num){\n\tG[from].push_back(Edge(to,capacity,arg_num,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,arg_num,G[from].size()-1,true));\n}\n\n//SMALL:Aの方が小さい BIG:Aの方が大きい EQUAL:同じ\nType compare_cost(int cost_A[DIGIT],int cost_B[DIGIT]){\n\n\tfor(int i = 0; i < DIGIT; i++){\n\t\tif(cost_A[i] != cost_B[i]){\n\t\t\tif(cost_A[i] < cost_B[i]){\n\t\t\t\treturn SMALL;\n\t\t\t}else{\n\t\t\t\treturn BIG;\n\t\t\t}\n\t\t}\n\t}\n\treturn EQUAL;\n}\n\nbool is_big_num(int array[DIGIT]){\n\n\treturn array[0] == 1;\n}\n\n//sourceからsinkへの、流量flowの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\n\tint work[DIGIT];\n\n\t//int debug = 0;\n\n\twhile(flow > 0){\n\t\t//ベルマンフォード方により、source-sink間最短経路を求める\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tdist[i][0] = 1; //BIG_NUM扱い\n\t\t\tfor(int k = 1; k < DIGIT; k++)dist[i][k] = 0;\n\t\t}\n\n\t\tdist[source][0] = 0; //全桁0→コスト0扱い\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int node_id = 0; node_id < V; node_id++){\n\t\t\t\tif(is_big_num(dist[node_id]))continue; //辿り着けない\n\t\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\t\tEdge &e = G[node_id][i];\n\n\t\t\t\t\tfor(int i = 0; i < DIGIT; i++)work[i] = dist[node_id][i]+e.cost[i]; //★配列形式のコスト★\n\n\t\t\t\t\tif(e.capacity > 0 && compare_cost(work,dist[e.to]) == SMALL){\n\n\t\t\t\t\t\tfor(int i = 0; i < DIGIT; i++)dist[e.to][i] = work[i]; //node_idを経由した方が早い場合\n\t\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(is_big_num(dist[sink])){\n\t\t\t//これ以上流せない\n\t\t\treturn -1;\n\t\t}\n\n\t\t//source-sink間最短路に沿って目いっぱい流す\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += 0; //戻り値不要\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint size;\n\n\tscanf(\"%d\",&size);\n\tH = size;\n\tW = H;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tint source = 0,sink = 1,index = 2;\n\tint index_row[H],index_col[W];\n\n\tfor(int row = 0; row < H; row++)index_row[row] = index++;\n\tfor(int col = 0; col < W; col++)index_col[col] = index++;\n\n\tfor(int i = 0; i < size; i++){\n\t\tadd_edge(source,index_row[i],1,-1); //sourceから行ノードにcap1,cost0の辺を張る\n\t}\n\n\tfor(int i = 0; i < size; i++){\n\t\tadd_edge(index_col[i],sink,1,-1); //列ノードから行ノードにcap1,cost0の辺を張る\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tadd_edge(index_row[row],index_col[col],1,getNUM(base_map[row][col])); //行と列を、文字のコストで結ぶ\n\t\t}\n\t}\n\n\n\tV = index;\n\tmin_cost_flow(source,sink,size);\n\n\tvector<int> ANS;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int i = 0; i < G[index_row[row]].size(); i++){\n\t\t\tif(G[index_row[row]][i].capacity == 0){ //フローが流れた辺の値を取得する\n\t\t\t\tANS.push_back(G[index_row[row]][i].num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(ANS.begin(),ANS.end());\n\n\tfor(int i = 0; i < size; i++)printf(\"%c\",getCHAR(ANS[i]));\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nconst int INF = 1 << 30;\n\ntypedef vector< int > vi;\n\nvi operator+(const vi &t, const vi &s)\n{\n  vi ret(52);\n  for(int i = 0; i < 52; i++) ret[i] = t[i] + s[i];\n  return (ret);\n}\n\nvi operator-(const vi &t)\n{\n  vi ret(52);\n  for(int i = 0; i < 52; i++) ret[i] = t[i] * -1;\n  return (ret);\n}\n\nvi operator*(const vi &t, int k)\n{\n  vi ret(52);\n  for(int i = 0; i < 52; i++) ret[i] = t[i] * k;\n  return (ret);\n}\n\nstruct Primal_Dual\n{\n  typedef pair< vi, int > Pi;\n\n  struct edge\n  {\n    int to, cap;\n    vi cost;\n    int rev;\n  };\n\n  vector< vector< edge > > graph;\n  vector< vi > potential, min_cost;\n  vector< int > prevv, preve;\n\n  Primal_Dual(int V) : graph(V) {}\n\n  void add_edge(int from, int to, int cap, vi cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  vi min_cost_flow(int s, int t, int f)\n  {\n    int V = graph.size();\n    vi ret(52, 0);\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, vi(52, 0));\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, vi(52, INF));\n      que.push(Pi(vi(52, 0), s));\n      min_cost[s] = vi(52, 0);\n\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          vi nextCost = min_cost[p.second] + e.cost + potential[p.second] + -potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t][0] == INF) return (vi(52, -1));\n      for(int v = 0; v < V; v++) potential[v] = potential[v] + min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret = ret + potential[t] * addflow;\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nconst string temp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\nint main()\n{\n  int N;\n  string S[50];\n\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> S[i];\n  }\n\n  Primal_Dual flow(N + N + 2);\n  const int s = N + N, t = N + N + 1;\n  vi vc(52, 0);\n  for(int i = 0; i < N; i++) flow.add_edge(s, i, 1, vc);\n  for(int i = 0; i < N; i++) flow.add_edge(i + N, t, 1, vc);\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      vc[temp.find(S[i][j])]--;\n      flow.add_edge(i, j + N, 1, vc);\n      vc[temp.find(S[i][j])]++;\n    }\n  }\n\n  auto cost = flow.min_cost_flow(s, t, N);\n  for(int i = 0; i < 52; i++) cout << string(-cost[i], temp[i]);\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <utility>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef vector<int> vi;\ntypedef pair<vi,int> P;\nstruct edge {\n\tint to,cap;\n\tvi cost;\n\tint rev;\n\tedge(int to,int cap,vi cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\nconst int MAX_V=102;\nint V;\nvector<edge> G[MAX_V];\nvi h[MAX_V];\nvi dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvi zero(52,0),mx(52,53),vinf(52,200);\nvi operator +(const vi &l,const vi &r){\n\tvi ret=l;\n\trep(i,52) ret[i]+=r[i];\n\treturn ret;\n}\nvi operator -(const vi &l,const vi &r){\n\tvi ret=l;\n\trep(i,52) ret[i]-=r[i];\n\treturn ret;\n}\nvi operator*(const int &l,const vi &r){\n\tvi ret=r;\n\trep(i,52) ret[i]+=l;\n\treturn ret;\n}\nvi operator -(const vi &l){\n\tvi ret=l;\n\trep(i,52) ret[i]=-ret[i];\n\treturn ret;\n}\nvoid add_edge(int from, int to, int cap, vi cost){\n\tedge e1=edge(to,cap,cost,G[to].size()),e2(from,0,-cost,G[from].size());\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid min_cost_flow(int s, int t, int f){\n\tvi res=zero;\n\tfill(h,h+V,zero);\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,vinf);\n\t\tdist[s]=zero;\n\t\tque.push(P(zero,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tif(dist[t]==vinf) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]=h[v]+dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres=res+d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n}\nvi tovi(int x){\n\tvi ret(52,0);\n\tret[x]++;\n\treturn ret;\n}\nint toint(vi vv){\n\trep(i,52) if(vv[i]==52) return i;\n\tassert(false);\n}\nint num(char c){\n\tif('A'<=c&&c<='Z') return c-'A';\n\treturn c-'a'+26;\n}\nchar denum(int num){\n\tif(num<26) return 'A'+num;\n\treturn 'a'+(num-26);\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tstring st[50];\n\trep(i,N) cin>>st[i];\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tadd_edge(i,j+N,1,mx-tovi(num(st[i][j])));\n\t\t}\n\t}\n\tint s=2*N,t=2*N+1;\n\tV=2*N+2;\n\trep(i,N) add_edge(s,i,1,zero);\n\trep(i,N) add_edge(N+i,t,1,zero);\n\tstring ans;\n\tmin_cost_flow(s,t,N);\n\trep(i,N){\n\t\tfor(edge e:G[i]){\n\t\t\tif(e.cap==0) ans.pb(denum(toint(e.cost)));\n\t\t}\n\t}\n\tsort(all(ans));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Weight {\n    vector<int> c;\n\n    Weight () { c = vector<int>(52); }\n    Weight (int v) : c{52, v} {}\n    Weight (const vector<int>& c) : c{c} {}\n\n    void init(int v) {\n        for (int i = 0; i < 52; i++) {\n            c[i] = v;\n        }\n    }\n    \n    bool operator < (const Weight& w) const {\n        return c > w.c;\n    }\n\n    bool operator > (const Weight& w) const {\n        return c > w.c;\n    }\n\n    bool operator == (const Weight& w) const {\n        return c == w.c;\n    }\n    \n    Weight& operator += (const Weight& w) {        \n        for (int i = 0; i < 52; i++) {\n            c[i] += w.c[i];\n        }\n        return *this;\n    }\n\n    Weight& operator * (int k) {\n        for (int i = 0; i < 52; i++) {\n            c[i] *= k;            \n        }\n        return *this;\n    }\n\n    Weight& operator - () {\n        for (int i = 0; i < 52; i++) {\n            c[i] = -c[i];\n        }        \n        return *this;\n    }\n};\n\nWeight operator + (const Weight& a, const Weight& b)\n{\n    Weight w;\n    for (int i = 0; i < 52; i++) {\n        w.c[i] = a.c[i] + b.c[i];\n    }\n    return w;\n}\n\nWeight operator - (const Weight& a, const Weight& b)\n{\n    Weight w;\n    for (int i = 0; i < 52; i++) {\n        w.c[i] = a.c[i] - b.c[i];\n    }\n    return w;\n}\n\n#define MAX_V 1010\n#define INF 1e9\nusing pwi = pair<Weight, int>;\n\nstruct edge {\n    int to;\n    int cap;\n    Weight cost;\n    int rev;    \n    \n    edge(int to, int cap, Weight cost, int rev) :\n        to{to}, cap{cap}, cost{cost}, rev{rev} {}\n};\n\nint V;\nWeight h[MAX_V], dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\nvector<edge> G[MAX_V];\n\nvoid add_edge(int from, int to, int cap, Weight cost)\n{\n    G[from].push_back(edge(to, cap, cost, G[to].size()));\n    G[to].push_back(edge(from, 0, -cost, G[from].size()-1));\n}\n\nvoid init(Weight* w, int v)\n{\n    for (int i = 0; i < V; i++) {\n        w[i].init(v);\n    }\n}\n\nWeight min_cost_flow(int s, int t, int f)\n{\n    Weight res;\n    init(h, 0);\n    while (f > 0) {\n        priority_queue<pwi> pq;\n        init(dist, INF);\n        dist[s].init(0);\n        pq.push(pwi(Weight(), s));\n        while (!pq.empty()) {\n            pwi p = pq.top(); pq.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                edge &e = G[v][i];\n                \n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) { \n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v; preve[e.to] = i;\n                    pq.push({dist[e.to], e.to});\n                }\n            }\n        }\n        \n        Weight inf(INF);\n        if (dist[t] == inf) return -1;\n        for (int v = 0; v < V; v++) {\n            h[v] += dist[v];\n        }\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += h[t] * d;        \n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint get_num(char x)\n{\n    if (isupper(x)) {\n        return (x - 'A');\n    }\n    return 26 + (x - 'a');\n}\n\nchar get_char(int x)\n{\n    if (x < 26) {\n        return (x + 'A');\n    }\n    return (x - 26 + 'a');\n}\n\nint main()\n{\n    int N;\n    cin >> N;\n    \n    int S = 2 * N, T = S + 1;\n    V = T + 1;\n    for (int i = 0; i < N; i++) {\n        add_edge(S, i, 1, Weight());\n        add_edge(i + N, T, 1, Weight());\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            char c;\n            cin >> c;\n            Weight w;\n            w.c[get_num(c)] = -1;\n            add_edge(i, j + N, 1, w);\n        }\n    }\n\n    auto res = min_cost_flow(S, T, N);\n    for (int i = 0; i < 52; i++) {\n        if (res.c[i] < 0) {\n            for (int j = 0; j < -res.c[i]; j++) {\n                cout << get_char(i);\n            }\n        }\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<array>\nusing namespace std;\nvoid dump(const array<int,52>&A)\n{\n\tfor(int i=0;i<52;i++)\n\t{\n\t\tcout<<A[i];\n\t\tif(i==51)cout<<endl;\n\t\telse cout<<\",\";\n\t}\n}\narray<int,52>MAX,ZERO;\narray<int,52>operator-(const array<int,52>&A)\n{\n\tarray<int,52>ret=A;\n\tfor(int i=0;i<52;i++)ret[i]=-ret[i];\n\treturn ret;\n}\narray<int,52>operator+(const array<int,52>&A,const array<int,52>&B)\n{\n\tarray<int,52>ret=ZERO;\n\tfor(int i=0;i<52;i++)ret[i]=A[i]+B[i];\n\treturn ret;\n}\narray<int,52>operator-(const array<int,52>&A,const array<int,52>&B)\n{\n\tarray<int,52>ret=ZERO;\n\tfor(int i=0;i<52;i++)ret[i]=A[i]-B[i];\n\treturn ret;\n}\narray<int,52>operator*(const array<int,52>&A,const int&x)\n{\n\tarray<int,52>ret=ZERO;\n\tfor(int i=0;i<52;i++)ret[i]=A[i]*x;\n\treturn ret;\n}\nbool operator<(const array<int,52>&A,const array<int,52>&B)\n{\n\tfor(int i=0;i<52;i++)if(A[i]!=B[i])return A[i]>B[i];\n\treturn false;\n}\n//Minimum Cost Flow O(FE log V)\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<limits>\ntemplate<typename T>\nstruct MCF{\n\tstruct edge{\n\t\tint to,rev,cap;\n\t\tT cost;\n\t};\n\tvector<vector<edge> >G;\n\tvector<T>h,d;\n\tvector<int>pv,pe;\n\tMCF(int n_=0):G(n_),h(n_,ZERO),d(n_),pv(n_),pe(n_){}\n\tvoid add_edge(int from,int to,int cap,T cost)\n\t{\n\t\tG[from].push_back({to,(int)G[to].size(),cap,cost});\n\t\tG[to].push_back({from,(int)G[from].size()-1,0,-cost});\n\t}\n\tT min_cost_flow(int s,int t,int f)//ans or -1\n\t{\n\t\tT ret=ZERO;\n\t\twhile(f>0)\n\t\t{\n\t\t\tpriority_queue<pair<T,int>,vector<pair<T,int> >,greater<pair<T,int> > >P;\n\t\t\tfill(d.begin(),d.end(),MAX);\n\t\t\td[s]=ZERO;\n\t\t\tP.push(make_pair(ZERO,s));\n\t\t\twhile(!P.empty())\n\t\t\t{\n\t\t\t\tpair<T,int>p=P.top();P.pop();\n\t\t\t\tif(d[p.second]<p.first)continue;\n\t\t\t\tfor(int i=0;i<G[p.second].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge&e=G[p.second][i];\n\t\t\t\t\tif(e.cap>0&&d[p.second]+e.cost+h[p.second]-h[e.to]<d[e.to])\n\t\t\t\t\t{\n\t\t\t\t\t\td[e.to]=d[p.second]+e.cost+h[p.second]-h[e.to];\n\t\t\t\t\t\tpv[e.to]=p.second;\n\t\t\t\t\t\tpe[e.to]=i;\n\t\t\t\t\t\tP.push(make_pair(d[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(d[t]==MAX)return MAX;\n\t\t\tfor(int u=0;u<G.size();u++)h[u]=h[u]+d[u];\n\t\t\tint d=f;\n\t\t\tfor(int u=t;u!=s;u=pv[u])d=min(d,G[pv[u]][pe[u]].cap);\n\t\t\tf-=d;\n\t\t\tret=ret+h[t]*d;\n\t\t\tfor(int u=t;u!=s;u=pv[u])\n\t\t\t{\n\t\t\t\tG[pv[u]][pe[u]].cap-=d;\n\t\t\t\tG[u][G[pv[u]][pe[u]].rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\nmain()\n{\n\tfor(int i=0;i<52;i++)MAX[i]=-114514;\n\tint N;\n\tcin>>N;\n\tvector<string>A(N);\n\tfor(int i=0;i<N;i++)cin>>A[i];\n\tMCF<array<int,52> >P(2*N+2);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tP.add_edge(2*N,i,1,ZERO);\n\t\tP.add_edge(N+i,2*N+1,1,ZERO);\n\t}\n\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t{\n\t\tarray<int,52>cost=ZERO;\n\t\tif(A[i][j]<='Z')\n\t\t{\n\t\t\tcost[A[i][j]-'A']=1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcost[A[i][j]-'a'+26]=1;\n\t\t}\n\t\tP.add_edge(i,N+j,1,cost);\n\t}\n\tarray<int,52>ans=P.min_cost_flow(2*N,2*N+1,N);\n\tfor(int i=0;i<52;i++)for(int j=0;j<ans[i];j++)\n\t{\n\t\tchar c=i<26?i+'A':i-26+'a';\n\t\tcout<<c;\n\t}\n\tcout<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//BEGIN CUT HERE\ntemplate<typename TF,typename TC>\nstruct PrimalDual{\n  struct edge{\n    int to;\n    TF cap;\n    TC cost;\n    int rev;\n    edge(){}\n    edge(int to,TF cap,TC cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  static const TC INF;\n  vector<vector<edge>> G;\n  vector<TC> h,dist;\n  vector<int> prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int n):G(n),h(n),dist(n),prevv(n),preve(n){}\n\n  void add_edge(int u,int v,TF cap,TC cost){\n    G[u].emplace_back(v,cap,cost,G[v].size());\n    G[v].emplace_back(u,0,-cost,G[u].size()-1);\n  }\n\n  void dijkstra(int s){\n    struct P{\n      TC first;\n      int second;\n      P(TC first,int second):first(first),second(second){}\n      bool operator<(const P&a) const{return a.first<first;}\n    };\n    priority_queue<P> que;\n    fill(dist.begin(),dist.end(),INF);\n\n    dist[s]=0;\n    que.emplace(dist[s],s);\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap==0) continue;\n        if(dist[v]+e.cost+h[v]-h[e.to]<dist[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.emplace(dist[e.to],e.to);\n        }\n      }\n    }\n  }\n\n  TC flow(int s,int t,TF f,int &ok){\n    TC res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      dijkstra(s);\n      if(dist[t]==INF){\n        ok=0;\n        return res;\n      }\n\n      for(int v=0;v<(int)h.size();v++)\n        if(dist[v]<INF) h[v]=h[v]+dist[v];\n\n      TF d=f;\n      for(int v=t;v!=s;v=prevv[v])\n        d=min(d,G[prevv[v]][preve[v]].cap);\n\n      f-=d;\n      res=res+h[t]*d;\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    ok=1;\n    return res;\n  }\n};\ntemplate<typename TF, typename TC> const TC PrimalDual<TF, TC>::INF = numeric_limits<TC>::max()/2;\n//END CUT HERE\n//INSERT ABOVE HERE\nint GRL_6_B(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int v,e,f;\n  cin>>v>>e>>f;\n\n  PrimalDual<int, int> pd(v);\n  for(int i=0;i<e;i++){\n    int u,v,c,d;\n    cin>>u>>v>>c>>d;\n    pd.add_edge(u,v,c,d);\n  }\n  int ok=0;\n  int res=pd.flow(0,v-1,f,ok);\n  cout<<(ok?res:-1)<<endl;\n  return 0;\n}\n/*\n  verified on 2019/07/05\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n*/\n\nsigned SPOJ_GREED(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  auto solve=\n    [](){\n      int n;\n      cin>>n;\n      vector<int> cnt(n,0);\n      for(int i=0;i<n;i++){\n        int x;\n        cin>>x;\n        cnt[x-1]++;\n      }\n      using ll = long long;\n      const ll INF = 1<<28;\n      int S=n,T=n+1;\n      PrimalDual<ll, ll> G(n+2);\n\n      int m;\n      cin>>m;\n      for(int i=0;i<m;i++){\n        int x,y;\n        cin>>x>>y;\n        x--;y--;\n        G.add_edge(x,y,INF,1);\n        G.add_edge(y,x,INF,1);\n      }\n\n      for(int i=0;i<n;i++){\n        G.add_edge(S,i,cnt[i],0);\n        G.add_edge(i,T,1,0);\n      }\n\n      int ok=0;\n      ll res=G.flow(S,T,n,ok);\n      assert(ok);\n      cout<<res<<endl;\n      return 0;\n\n    };\n  int t;\n  cin>>t;\n  while(t--) solve();\n  return 0;\n}\n/*\n  verified on 2019/07/05\n  https://www.spoj.com/problems/GREED/\n*/\n\nsigned geocon2013_B(){\n  using D = double;\n\n  int n;\n  cin>>n;\n  vector<D> xs(n),ys(n);\n  for(int i=0;i<n;i++) cin>>xs[i]>>ys[i];\n\n  vector<int> pos,neg;\n  for(int i=0;i<n;i++){\n    if(xs[i]>0) pos.emplace_back(i);\n    if(xs[i]<0) neg.emplace_back(i);\n  }\n\n  int f=max(pos.size(),neg.size());\n  if(f==0){\n    cout<<0<<endl;\n    return 0;\n  }\n\n  PrimalDual<int, D> G(n+3);\n  int S=n,T=n+1,U=n+2;\n  for(int z:pos) G.add_edge(S,z,1,0);\n  for(int z:neg) G.add_edge(z,T,1,0);\n\n  int dif=pos.size()-neg.size();\n  if(dif>0){\n    G.add_edge(U,T,dif,0);\n    for(int p:pos)\n      G.add_edge(p,U,1,abs(xs[p]));\n  }\n  if(dif<0){\n    G.add_edge(S,U,-dif,0);\n    for(int q:neg)\n      G.add_edge(U,q,1,abs(xs[q]));\n  }\n\n  for(int p:pos)\n    for(int q:neg)\n      G.add_edge(p,q,1,\n                 min(hypot(xs[p]+xs[q],ys[p]-ys[q]),abs(xs[p])+abs(xs[q])));\n\n  int ok=0;\n  D ans=G.flow(S,T,f,ok);\n  assert(ok);\n  cout<<fixed<<setprecision(12)<<ans<<endl;\n  return 0;\n}\n/*\n  verified on 2019/07/05\n  https://atcoder.jp/contests/geocon2013/tasks/geocon2013_b\n*/\n\nconst int MAX = 52;\nstruct ARR{\n  array<int, MAX> val;\n  ARR(){fill(val.begin(),val.end(),0);}\n  ARR(int x){fill(val.begin(),val.end(),x);}\n  int& operator[](int k){return val[k];};\n  int operator[](int k)const{return val[k];};\n  ARR operator+(const ARR &oth) const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=val[i]+oth[i];\n    return res;\n  }\n  ARR operator-(const ARR &oth) const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=val[i]-oth[i];\n    return res;\n  }\n  ARR operator-() const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=-val[i];\n    return res;\n  }\n  ARR operator*(const int &k) const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=val[i]*k;\n    return res;\n  }\n  ARR operator/(const int &k) const{\n    ARR res;\n    for(int i=0;i<MAX;i++)\n      res[i]=val[i]/k;\n    return res;\n  }\n  bool operator< (const ARR &oth) const{\n    return val< oth.val;\n  }\n  bool operator==(const ARR &oth) const{\n    return val==oth.val;\n  }\n};\n\nnamespace std {\n  template<> class numeric_limits<ARR> {\n  public:\n    static ARR max() {return ARR(numeric_limits<int>::max());};\n  };\n}\n\nsigned AOJ_2679(){\n  int n;\n  cin>>n;\n  vector<string> vs(n);\n  for(int i=0;i<n;i++) cin>>vs[i];\n\n  auto enc=\n    [&](char c){\n      if(isupper(c)) return c-'A';\n      return 26+c-'a';\n    };\n  auto dec=\n    [&](int d){\n      if(d<26) return 'A'+d;\n      return 'a'+d-26;\n    };\n\n  int S=n*2,T=n*2+1;\n  PrimalDual<int, ARR> G(n*2+2);\n  for(int i=0;i<n;i++){\n    G.add_edge(S,i,1,ARR());\n    G.add_edge(n+i,T,1,ARR());\n  }\n\n  const int INF = 1e5;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      ARR cost(INF);\n      cost[enc(vs[i][j])]=INF-1;\n      G.add_edge(i,n+j,1,cost);\n    }\n  }\n\n  int ok;\n  auto res=G.flow(S,T,n,ok);\n  assert(ok);\n\n  string ans;\n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<n*INF-res[i];j++)\n      ans+=dec(i);\n  cout<<ans<<endl;\n\n  return 0;\n}\n/*\n  verified on 2019/07/05\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2679\n*/\n\nsigned main(){\n  //GRL_6_B();\n  //SPOJ_GREED();\n  //geocon2013_B();\n  AOJ_2679();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nmap<int,char> itoc;\nstring ans;\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n\n    ans+=itoc[dist[t]];\n    \n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\n\n\nint main(){\n  \n  int n;\n  cin>>n;\n\n  int cost=-300,idx='A';\n  int ctoi[300];\n  \n  while(idx!='Z'+1){\n    ctoi[idx]=cost;\n    itoc[cost]=(char)idx;\n    idx++;\n    cost++;\n  }\n\n  idx='a';\n  while(idx!='z'+1){\n    ctoi[idx]=cost;\n    itoc[cost]=(char)idx;\n    idx++;\n    cost++;\n  }\n\n  int S=n*2,T=S+1;\n\n  for(int i=0;i<n;i++){\n    \n    string s;\n    cin>>s;\n    \n    for(int j=0;j<n;j++)\n      add_edge(i,j+n,1,ctoi[s[j]]);\n    \n  }\n\n  for(int i=0;i<n;i++){\n    add_edge(S,i,1,0);\n    add_edge(i+n,T,1,0);\n  }\n\n  V=n*2+2;\n  \n  min_cost_flow(S,T,n);\n  \n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  string s[n],ans;\n  for(int i=0;i<n;i++) cin>>s[i];\n  \n  for(int k=0;k<n-1;k++){\n    int ti=k,tj=k;\n    for(int i=k;i<n;i++){\n      for(int j=k;j<n;j++){\n\tif(s[ti][tj]==s[i][j]){\n\t  char p='z',q='z';\n\t  for(int a=k;a<n;a++){\n\t    for(int b=k;b<n;b++){\n\t      if(a==i||b==j) p=min(p,s[a][b]);\n\t      if(a==ti||b==tj) q=min(q,s[a][b]);\n\t    }\n\t  }\n\t  if(p>q) ti=i,tj=j;\n\t}\n\tif(s[ti][tj]>s[i][j]) ti=i,tj=j;\n      }\n    }\n    swap(s[ti],s[k]);\n    for(int l=0;l<n;l++) swap(s[l][tj],s[l][k]);\n  }\n  bool f=1;\n  while(f){\n    f=0;\n    for(int k=0;k<n;k++){\n      for(int i=0;i<k;i++){\n\tfor(int j=0;j<k;j++){\n\t  if(i==j) continue;\n\t  if(s[i][j]<s[k][k]&&s[j][j]==s[j][k]&&s[i][i]==s[k][i]) {\n\t    swap(s[i],s[k]);\n\t    for(int l=0;l<n;l++) swap(s[l][j],s[l][k]);\n\t    f=1;\n\t  }\n\t}\n      }\n    }\n    cout<<endl;for(int i=0;i<n;i++) cout<<s[i]<<endl;\n  }\n  for(int i=0;i<n;i++) ans+=s[i][i];\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\n#include <time.h>\nusing namespace std;\nlong double esp=1e-11;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define cle(a) while(!a.empty())a.pop()\n#define mem(p) memset(p,0,sizeof(p))\n#define memf(p) memset(p,0x3f,sizeof(p))\n#define memn(p) memset(p,-1,sizeof(p))\n#define mp(A, B) make_pair(A, B)\n#define pb push_back\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\ntypedef long long int LL;\nconst long double PI = acos((long double)-1);\nconst LL INF=0x3f3f3f3fll;\nconst int MOD = 1000000007;\nconst int maxn=110000;\n#define V 510\n#define E 45100\nint vis[V];\nint dist[V];\nint pre[V];\n\nstruct Edge{\n    int u,v,c,cost,next;\n}edge[E];\nint head[V],cnt;\n\nvoid init(){\n    cnt=0;\n    memset(head,-1,sizeof(head));\n}\nvoid addedge(int u,int v,int c,int cost)\n{\n    edge[cnt].u=u;edge[cnt].v=v;edge[cnt].cost=cost;\n    edge[cnt].c=c;edge[cnt].next=head[u];head[u]=cnt++;\n\n    edge[cnt].u=v;edge[cnt].v=u;edge[cnt].cost=-cost;\n    edge[cnt].c=0;edge[cnt].next=head[v];head[v]=cnt++;\n}\n\nbool spfa(int begin,int end){\n    int u,v;\n    queue<int> q;\n    for(int i=0;i<=end+2;i++){\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=INF;\n    }\n    vis[begin]=1;\n    dist[begin]=0;\n    q.push(begin);\n    while(!q.empty()){\n        u=q.front();\n        q.pop();\n        vis[u]=0;\n        for(int i=head[u];i!=-1;i=edge[i].next){\n            if(edge[i].c>0){\n                v=edge[i].v;\n                if(dist[v]>dist[u]+edge[i].cost){\n                    dist[v]=dist[u]+edge[i].cost;\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    return dist[end]!=INF;\n}\n\nint MCMF(int begin,int end){\n    int ans=0,flow;\n    int flow_sum=0;\n    while(spfa(begin,end)){\n        flow=INF;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u])\n            if(edge[i].c<flow)\n                flow=edge[i].c;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u]){\n            edge[i].c-=flow;\n            edge[i^1].c+=flow;\n        }\n        ans+=dist[end];\n        flow_sum += flow;\n    }\n    //cout << flow_sum << endl;\n    return ans;\n}\nchar s[110];\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"inlay.in\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    //map<long long int,int>ma;                 %I64d\n    //vector<int>::iterator iter;\n    //memset(m,0,sizeof(int));\n    //for(int x=1;x<=n;x++)\n    //for(int y=1;y<=n;y++)\n    //scanf(\"%d%d\",&a,&b);\n    //scanf(\"%d\",&a);\n    //printf(\"%d\\n\",ans);\n    int n;\n    scanf(\"%d\",&n);\n    init();\n    int st=105,ed=106;\n    for(int x=0;x<n;x++)\n        addedge(st,x,1,0),addedge(n+x,ed,1,0);\n\n    for(int x=0;x<n;x++)\n    {\n        scanf(\"%s\",s);\n        for(int y=0;y<n;y++)\n            addedge(x,n+y,1,s[y]);\n    }\n    MCMF(st,ed);\n    vector<int>ans;\n    ans.clear();\n    for(int x=0;x<cnt;x++)\n        if(edge[x].u>=n&&edge[x].u<2*n&&edge[x].v<n&&edge[x].c>0&&edge[x].cost<0)\n            ans.pb(-edge[x].cost);\n    sort(all(ans));\n    for(int x=0;x<n;x++)\n        printf(\"%c\",ans[x]);\n    putchar(10);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\n//const int max_n = 1 << 22;\n//modint fact[max_n], factinv[max_n];\n//void init_f() {\n//\tfact[0] = modint(1);\n//\tfor (int i = 0; i < max_n - 1; i++) {\n//\t\tfact[i + 1] = fact[i] * modint(i + 1);\n//\t}\n//\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n//\tfor (int i = max_n - 2; i >= 0; i--) {\n//\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n//\t}\n//}\n//modint comb(int a, int b) {\n//\tif (a < 0 || b < 0 || a < b)return 0;\n//\treturn fact[a] * factinv[b] * factinv[a - b];\n//}\n\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\nusing poly = vector<int>;\n\npoly operator+(const poly &a, const poly &b) {\n\tpoly res(a.size());\n\trep(i, a.size())res[i] = a[i] + b[i];\n\treturn res;\n}\npoly operator-(const poly &a) {\n\tpoly res(a.size());\n\trep(i, a.size())res[i] = -a[i];\n\treturn res;\n}\n\nconst poly inf(52, mod);\nconst poly zerop(52,0);\n\nusing speP = pair<poly, int>;\n\nint max_n;\nconst int mn = 100000;\nstruct edge {\n\tint to, cap; poly cost; int rev;\n};\nvector<edge> G[mn];\nP par[mn];\npoly dist[mn];\nvoid add_edge(int from, int to, int cap, poly cost) {\n\tG[from].push_back({ to,cap,cost,(int)G[to].size() });\n\tG[to].push_back({ from,0,-cost,(int)G[from].size() - 1 });\n\tmax_n = max({ max_n, from + 1, to + 1 });\n}\npoly minimum_road(int s, int t) {\n\tfill(par, par + max_n, LDP{ -1,-1 });\n\tfill(dist, dist + max_n, inf);\n\tdist[s] = zerop;\n\tpriority_queue<speP, vector<speP>, greater<speP>> q; q.push({ zerop,s });\n\twhile (!q.empty()) {\n\t\tspeP p = q.top(); q.pop();\n\t\tint id = p.second;\n\t\tif (id == t)continue;\n\t\tif (p.first > dist[id])continue;\n\t\trep(j, G[id].size()) {\n\t\t\tif (G[id][j].cap > 0) {\n\t\t\t\tint to = G[id][j].to;\n\t\t\t\tpoly nd = p.first + G[id][j].cost;\n\t\t\t\tif (nd < dist[to]) {\n\t\t\t\t\tdist[to] = nd;\n\t\t\t\t\tpar[to] = { id,j };\n\t\t\t\t\tq.push({ dist[to],to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cur = t;\n\tint f = 1;\n\twhile (cur != s) {\n\t\tint p = par[cur].first, j = par[cur].second;\n\t\tif (p < 0)return { -1,-1 };\n\t\tG[p][j].cap -= f;\n\t\tif (G[p][j].rev >= 0) {\n\t\t\tG[cur][G[p][j].rev].cap += f;\n\t\t}\n\t\tcur = p;\n\t}\n\treturn dist[t];\n}\npoly minimum_cost_flow(int s, int t, int k) {\n\tpoly ret = zerop;\n\trep(i, k) {\n\t\tpoly z = minimum_road(s, t);\n\t\tret = ret + z;\n\t}\n\treturn ret;\n}\n\nint trans(char &t) {\n\tif (t <= 'Z')return t - 'A';\n\telse return 26 + t - 'a';\n}\nchar trans(int &i) {\n\tif (i < 26)return 'A' + i;\n\telse return 'a' + i - 26;\n}\nchar mp[50][50];\nvoid solve() {\n\tint n; cin >> n;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\tint sta = 2 * n; int goa = sta + 1;\n\trep(i, n)add_edge(sta, i, 1, zerop);\n\trep(i, n)add_edge(i + n, goa, 1, zerop);\n\trep(i, n)rep(j, n) {\n\t\tpoly c(52, 52); c[trans(mp[i][j])]--;\n\t\tadd_edge(i, j + n, 1, c);\n\t}\n\tstring ans;\n\tpoly p=minimum_cost_flow(sta, goa, n);\n\trep(i, 52)rep(j, 52*n-p[i])ans.push_back(trans(i));\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint change(char ch){\n  if('A'<=ch&&ch<='Z'){\n    return ch-'A';\n  }else{\n    return 26+ch-'a';\n  }\n}\n\nint N;\nlong double po[60];\nchar mp[50][50];\nint t[50][50];\n\nstruct edge{\n  int to;\n  int cap;\n  long double cost;\n  int rev;\n};\n\n#define MAX_V (105)\n\nvector<edge> G[MAX_V];\nlong double h[MAX_V];\nlong double dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nlong double eps=0.00000001;\n\nvoid add_edge(int from,int to,int cap,long double cost){\n  G[from].push_back( (edge){to,cap,cost,(int)G[to].size() } );\n  G[to].push_back(   (edge){from,0,-cost,(int)G[from].size()-1 } );\n}\n\ntypedef pair< long double , int > P;\n\nlong double min_cost_flow(int s,int t,int f){\n  long double res=0;\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > Q;\n    fill(dist,dist+MAX_V, po[59]);\n    dist[s]=0;\n    Q.push(P(0,s));\n    while(!Q.empty()){\n      P p=Q.top();Q.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      \n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0&&dist[e.to]-eps>dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          Q.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==po[59])return -1;\n    for(int v=0;v<MAX_V;v++)h[v]+=dist[v];\n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    f-=d;\n    res+=(long double)d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  po[0]=1;\n\n  cin>>N;\n  int si=N+N;\n  int ti=N+N+1;\n\n  map< char , int > cnt;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      char ch;\n      cin>>ch;\n      cnt[ change(ch) ]++;\n      mp[i][j]=ch;\n    }\n  }\n\n  po[0]=1;\n  for(int i=1;i<60;i++){\n    po[i]=po[i-1]*( long double)( cnt[i-1]+1 );\n  }\n  \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      t[i][j]=G[i].size();\n      add_edge(i,N+j,1,po[ change(mp[i][j]) ]);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    add_edge(si,i,1,0);\n    add_edge(N+i,ti,1,0);\n  }\n\n  long double ansf=min_cost_flow(si,ti,N);\n\n  string ans=\"\";\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      edge e=G[i][ t[i][j] ];\n      if(e.cap==0)ans+=mp[i][j];\n    }\n  }\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 500\n#define INF 1<<28\n\nclass bigint {\nprivate:\n  static const int BASE = 100000000, LEN = 40;\n  bool negative;\n  std::vector<int> a;\n  bigint& normalize();\npublic:\n  bigint(int x = 0);\n  bigint(const std::string& s);\n  bigint& operator = (const bigint& x);\n  bigint& operator = (int x);\n  bigint& operator = (const std::string& s);\n  const bool operator < (const bigint& x) const;\n  const bool operator > (const bigint& x) const;\n  const bool operator <= (const bigint& x) const;\n  const bool operator >= (const bigint& x) const;\n  const bool operator != (const bigint& x) const;\n  const bool operator == (const bigint& x) const;\n  bigint operator -() const;\n  bigint& operator += (const bigint& x);\n  bigint& operator -= (const bigint& x);\n  bigint& operator *= (const bigint& x);\n  bigint& operator /= (const bigint& x);\n  bigint& operator %= (const bigint& x);\n  const bigint operator + (const bigint& x) const;\n  const bigint operator - (const bigint& x) const;\n  const bigint operator * (const bigint& x) const;\n  const bigint operator / (const bigint& x) const;\n  const bigint operator % (const bigint& x) const;\n  friend std::pair<bigint,bigint> divmod(const bigint& lhs, const bigint& rhs);\n  friend std::istream& operator >> (std::ostream& is, bigint& x); //??????????£?\n  friend std::ostream& operator << (std::ostream& os, const bigint& x);\n  friend const bigint abs(bigint x);\n};\nbigint& bigint::normalize() {\n  int i = a.size()-1;\n  while (i >= 0 && a[i] == 0) --i;\n  a.resize(i+1);\n  if (a.size() == 0) negative = false;\n  return *this;\n}\nbigint::bigint(int x) : negative(x<0) {\n  x = abs(x);\n  for (; x > 0; x /= BASE) a.push_back(x % BASE);\n}\nbigint::bigint(const std::string& s): negative(false) {\n  int p = 0;\n  if (s[p] == '-') { ++p; negative = true; }\n  else if (s[p] == '+') { ++p; }\n  for (int i = s.size()-1, v = BASE; i >= p; --i, v*=10) {\n    int x = s[i]-'0';\n    if (x < 0 || 9 < x) {\n      std::cerr<<\"error: parse error:\"<<s<<std::endl;\n      exit(1);\n    } \n    if (v == BASE) {\n      v = 1;\n      a.push_back(x);\n    } else a.back() += (x)*v;\n  }\n  normalize();\n}\nbigint& bigint::operator = (const bigint& x) {\n  negative = x.negative;\n  a = x.a;\n  return *this;\n}\nbigint& bigint::operator = (int x) { return *this = bigint(x); }\nbigint& bigint::operator = (const std::string& s) { return *this = bigint(s); }\nconst bool bigint::operator < (const bigint& x) const {\n  if (negative != x.negative) return negative < x.negative;\n  if (a.size() != x.a.size()) return (a.size() < x.a.size())^negative;\n  for(int i = a.size()-1; i >= 0; --i)\n    if (a[i] != x.a[i]) return (a[i] < x.a[i])^negative;\n  return false;\n}\nconst bool bigint::operator > (const bigint& x) const { return x<(*this); }\nconst bool bigint::operator <= (const bigint& x) const { return !(x<(*this)); }\nconst bool bigint::operator >= (const bigint& x) const { return !((*this)<x); }\nconst bool bigint::operator != (const bigint& x) const { return (*this)<x || x<(*this); }\nconst bool bigint::operator == (const bigint& x) const { return !((*this)<x || x<(*this)); }\nbigint bigint::operator -() const {\n  bigint ret(*this);\n  if (a.size()) ret.negative = !ret.negative;\n  return ret;\n}\nbigint& bigint::operator += (const bigint& x) {\n  if (negative != x.negative) return *this -= -x;\n  if (a.size() < x.a.size()) a.resize(x.a.size());\n  int tmp = 0;\n  for (int i = 0; i < a.size(); ++i) {\n    a[i] += (i<x.a.size()?x.a[i]:0) + tmp;\n    tmp = a[i] / BASE;\n    a[i] %= BASE;\n  }\n  if (tmp) a.push_back(1);\n  return *this;\n}\nbigint& bigint::operator -= (const bigint& x) {\n  if (negative != x.negative) return *this += -x;\n  std::vector<int> b(x.a);\n  if ((*this < x) ^ negative) {\n    a.swap(b);\n    negative = !negative;\n  }\n  for (int i = 0, tmp = 0; i < a.size(); ++i) {\n    a[i] += BASE - (i<b.size()?b[i]:0) + tmp;\n    tmp = a[i] / BASE - 1;\n    a[i] %= BASE;\n  }\n  return this->normalize();\n}\nbigint& bigint::operator *= (const bigint& x) {\n  negative ^= x.negative;\n  std::vector<int> c(a.size()*x.a.size()+1);\n  for (int i = 0; i < a.size(); ++i) {\n    long long tmp = 0;\n    for (int j = 0; j < x.a.size(); ++j) {\n      long long v = (long long)a[i] * x.a[j] + c[i+j] + tmp;\n      tmp = v / BASE;\n      c[i+j] = (int)(v % BASE);\n    }\n    if (tmp) c[i+x.a.size()] += (int)tmp;\n  }\n  a.swap(c);\n  return this->normalize();\n}\nbigint& bigint::operator /= (const bigint& x) {\n  return *this = divmod(*this,x).first;\n}\nbigint& bigint::operator %= (const bigint& x) {\n  return *this = divmod(*this,x).second;\n}\nconst bigint bigint::operator + (const bigint& x) const {\n  bigint res(*this); return res += x;\n}\nconst bigint bigint::operator - (const bigint& x) const {\n  bigint res(*this); return res -= x;\n}\nconst bigint bigint::operator * (const bigint& x) const {\n  bigint res(*this); return res *= x;\n}\nconst bigint bigint::operator / (const bigint& x) const {\n  bigint res(*this); return res /= x;\n}\nconst bigint bigint::operator % (const bigint& x) const {\n  bigint res(*this); return res %= x;\n}\nstd::pair<bigint,bigint> divmod(const bigint& lhs, const bigint& rhs) {\n  if (!rhs.a.size()) {\n    std::cerr<<\"error: division by zero\"<<std::endl;\n    exit(1);\n  }\n  bigint x(abs(rhs)), q, r;\n  for (int i = lhs.a.size()-1; i >= 0; --i) {\n    r = r * bigint::BASE + lhs.a[i];\n    int head = 0, tail = bigint::BASE;\n    if (r >= x) {\n      while (head + 1 < tail) {\n        int mid = (head + tail) / 2;\n        if (x * bigint(mid) > r) tail = mid;\n        else head = mid;\n      }\n      r -= x * head;\n    }\n    q.a.push_back(head);\n  }\n  reverse(q.a.begin(), q.a.end());\n  bool neg = lhs.negative ^ lhs.negative;\n  q.negative = neg; r.negative = neg;\n  return std::make_pair(q.normalize(), r.normalize());\n}\nstd::istream& operator >> (std::istream& is, bigint& x) {\n  std::string tmp; is >> tmp;\n  x = bigint(tmp);\n  return is;\n}\nstd::ostream& operator << (std::ostream& os, const bigint& x) {\n  if (x.negative) os << '-';\n  if (!x.a.size()) os << 0;\n  else os << x.a.back();\n  for (int i = x.a.size()-2; i >= 0; --i) {\n    os.width(bigint::LEN);\n    os.fill('0');\n    os << x.a[i];\n  }\n  return os;\n}\nconst bigint abs(bigint x) {\n  x.negative = false;\n  return x;\n}\n\nbigint base=bigint(\"100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\");\nbigint inf=bigint(\"10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\");\n\ntypedef pair<bigint,int> P;\n\nstruct edge{\n  int to,rev;\n  bigint cap,cost;\n  edge(){}\n  edge(int to,bigint cap,int rev,bigint cost):to(to),cap(cap),rev(rev),cost(cost){}\n};\n\nint V;\nvector<edge> G[MAX_V];\nbigint h[MAX_V];\nbigint dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,bigint cap,bigint cost){\n  G[from].push_back(edge(to,cap,G[to].size(),cost));\n  G[to].push_back(edge(from,0,G[from].size()-1,-cost));\n}\n\nbigint min_cost_flow(int s,int t,bigint f){\n  bigint res=0;\n  for(int i=0;i<V;i++) h[i]=0;\n  while(f>0){\n    priority_queue<P,vector<P>,greater<P> > que;\n    for(int i=0;bigint(i)<V;i++) dist[i]=inf;\n    dist[s]=bigint(0);\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p=que.top();que.pop();\n      int v=p.second;\n      if(dist[v]<p.first) continue;\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e=G[v][i];\n\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t  dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t  prevv[e.to]=v;\n\t  preve[e.to]=i;\n\t  que.push(P(dist[e.to],e.to));\n\t}\n      }\n    }\n    if(dist[t]==INF){\n      return -1;\n    }\n    for(int v=0;bigint(v)<V;v++) h[v]+=dist[v];\n\n    bigint d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  cin>>n;\n  string str[n],ans;\n  for(int i=0;i<n;i++) cin>>str[i];\n  V=n*2+2;\n  int s=n*2,t=n*2+1;\n  \n  for(int i=0;i<n;i++){\n    add_edge(s,i,1,0);\n    add_edge(n+i,t,1,0);\n  }\n  bigint cost[52];\n  for(int i=0;i<52;i++){\n    cost[i]=1;\n    for(int j=0;j<52-i;j++){\n      cost[i]*=52;\n    }\n  }\n  map<char,int> c;\n  for(char i='A';i<='Z';i++) c[i]=i-'A';\n  for(char i='a';i<='z';i++) c[i]=i-'a'+26;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      add_edge(i,n+j,1,base-cost[c[str[i][j]]]);\n\n  min_cost_flow(s,t,bigint(n));\n  \n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<(int)G[i].size();j++){\n      if(G[i][j].cap>bigint(0)) continue;\n      ans+=str[i][G[i][j].to-n];\n    }\n  }\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> add(vector<int> a,vector<int> b){\n  vector<int> res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]+b[i];\n  return res;\n}\n\nvector<int> sub(vector<int> a){\n  vector<int> res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=-a[i];\n  return res;\n}\n\n\nint change(char ch){\n  int res;\n  if('A'<=ch&&ch<='Z'){\n    res= ch-'A';\n  }else{\n    res= 26+ch-'a';\n  }\n  return res;\n}\n\nint N;\nchar mp[55][55];\nint t[55][55];\n\nstruct edge{\n  int to;\n  int cap;\n  vector<int> cost;\n  int rev;\n\n  edge( int a,int b, vector<int> c,int d){\n    to=a;\n    cap=b;\n    cost=c;\n    rev=d;\n  }\n};\n\n#define MAX_V 205\n\nvector<edge> G[MAX_V];\nvector<int> h[MAX_V];\nvector<int> dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,vector<int> cost){\n  G[from].push_back( edge(to,cap,cost,G[to].size() ) );\n  G[to].push_back(   edge(from,0, sub(cost) ,G[from].size()-1 ) );\n}\n\ntypedef pair< vector<int> , int > P;\n\nvector<int> min_cost_flow(int s,int t,int f){\n  vector<int> res(60,0);\n  \n  fill( h, h+MAX_V, vector<int>(60,0) );\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > Q;\n    fill(dist,dist+MAX_V, vector<int>(60,9999) );\n    dist[s]= vector<int>(60,0);\n    Q.push(P( dist[s] ,s));\n    while(!Q.empty()){\n      P p=Q.top();Q.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      \n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0){\n\n          vector<int> tmp = add(dist[v],e.cost);\n          tmp=add(tmp,h[v]);\n          vector<int> tmp2 = sub(h[e.to]);\n          tmp = add(tmp, tmp2);\n\n          \n          if(dist[e.to]>tmp){\n            dist[e.to]=tmp;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            Q.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n    }\n\n    \n    for(int v=0;v<MAX_V;v++)h[v]=add(h[v],dist[v]);\n    \n    f--;\n    res=add(res,h[t]);\n    \n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap--;\n      G[v][e.rev].cap++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  \n  cin>>N;\n  int si=N+N;\n  int ti=N+N+1;\n\n  map< int , char > dm;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      char ch;\n      cin>>ch;\n      dm[ change(ch) ] = ch;\n      mp[i][j]=ch;\n    }\n  }\n\n    \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      t[i][j]=G[i].size();\n      vector<int> tmp(60,1000);\n      tmp[ change(mp[i][j]) ]--;\n      add_edge(i,N+j,1,tmp);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    vector<int> tmp(60,0);\n    add_edge(si,i,1,tmp);\n    add_edge(N+i,ti,1,tmp);\n  }\n\n  vector<int> vec = min_cost_flow(si,ti,N);\n\n  string ans=\"\";\n\n\n  \n  for(int i=0;i<60;i++){\n    vec[i]=1000*N-vec[i];\n    for(int j=0;j<vec[i];j++){\n      ans+= dm[i];\n    }\n  }\n  assert((int)ans.size()==N);\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  /*\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      edge e=G[i][ t[i][j] ];\n      if(e.cap==0)ans+=mp[i][j];\n    }\n  }\n\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX = 52;\nconst int MAX_V = 100010;\ntypedef int Capacity;\ntypedef vector<int> Cost;\nconst Cost inf = Cost(MAX, 1000000);\nconst Cost zero = Cost(MAX, 0);\n\nCost operator -(Cost c) {\n\tfor(auto& a : c) a *= -1;\n\treturn c;\n}\n\nCost operator +(Cost c1, Cost c2) {\n\tfor(int i = 0; i < c1.size(); i++) c1[i] += c2[i];\n\treturn c1;\n}\n\nCost operator -(Cost c1, Cost c2) {\n\tfor(int i = 0; i < c1.size(); i++) c1[i] -= c2[i];\n\treturn c1;\n}\n\nbool operator ==(Cost c1, Cost c2) {\n\tfor(int i = 0; i < c1.size(); i++) {\n\t\tif(c1[i] != c2[i]) return false;\n\t}\n\treturn true;\n}\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tvector<int> top;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].push_back(Edge{ dst, cap, cost, (int)g[dst].size(), false });\n\t\tg[dst].push_back(Edge{ src, 0, -cost, (int)g[src].size() - 1, true });\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res(52, 0);\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\n\t\tfill(h, h + n, zero);\n\t\tif(top.size()) {\n\t\t\tassert(top.size() == n);\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint v = top[i];\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge& e = g[v][i];\n\t\t\t\t\tif(e.cap == 0) continue;\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\th[u] = min(h[u], h[v] + e.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = Cost(MAX, 0);\n\t\t\tq.push(pcv(Cost(MAX, 0), s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.push(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn inf;// !!!!!\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] = h[v] + dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\t\tres[i] += d * h[t][i];\n\t\t\t}\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\t/*void view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\tif(!g[i][j].isRev) {\n\t\tEdge& e = g[i][j];\n\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t}\n\t\t}\n\t\t}\n\t\t}*/\n};\n\nstring b[50];\n\nint conv(char c) {\n\tif('A' <= c && c <= 'Z') return c - 'A';\n\treturn c - 'a' + 26;\n}\n\nchar deconv(int id) {\n\tif(id <= 25) return 'A' + id;\n\treturn 'a' + (id - 26);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tPrimalDual pd(2 * N + 2);\n\tint S = 2 * N, T = S + 1;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tint c = conv(b[i][j]);\n\t\t\tCost cost(MAX, 0);\n\t\t\tcost[c] = -1;\n\t\t\tpd.add_edge(i, N + j, 1, cost);\n\t\t}\n\t\tpd.add_edge(S, i, 1, zero);\n\t\tpd.add_edge(i + N, T, 1, zero);\n\t}\n\n\tCost res = pd.solve(S, T, N);\n\tassert(res != inf);\n\tfor(int i = 0; i < MAX; i++) {\n\t\tfor(int j = 0; j < -res[i]; j++) {\n\t\t\tcout << deconv(i);\n\t\t}\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <array>\nusing namespace std;\ntypedef array<int, 52> rexico;\n\nrexico operator -(const rexico &a){\n    auto res = a;\n    for(auto &e: res){\n        e = -e;\n    }\n    return res;\n}\nrexico& operator +=(rexico &a, const rexico &b){\n    for(int i=0; i<52; i++){\n        a[i] += b[i];\n    }\n    return a;\n}\nrexico operator +(const rexico &a, const rexico &b){\n    auto res = a;\n    return res += b;\n}\nrexico operator *(const int &c, const rexico &a){\n    auto res = a;\n    for(auto &e: res){\n        e *= c;\n    }\n    return res;\n}\n\n\ntemplate<typename T>\nstruct MincostFlow{\n    struct edge{\n        int to, rev;\n        int cap;\n        T cost;\n        edge(int to, int rev, int cap, T cost)\n            :to(to),rev(rev),cap(cap),cost(cost){}\n        edge(){}\n    };\n    \n    int n;\n    T zero;\n    T inf;\n    vector<vector<edge>> graph;\n\n    MincostFlow(int n, T zero, T inf):n(n),zero(zero),inf(inf){\n        graph.resize(n);\n    }\n    void add_edge(int from, int to, int cap, T cost){\n        graph[from].emplace_back(to, graph[to].size(), cap, cost);\n        graph[to].emplace_back(from, (int)graph[from].size()-1, 0, -cost);\n    }\n    T exec(int s, int g, int f){\n        T res = zero;\n        while(f > 0){\n            vector<int> prevv(n), preve(n);\n            vector<T> mincost(n, inf);\n            mincost[s] = zero;\n            while(1){\n                bool update = false;\n                for(int i=0; i<n; i++){\n                    if(mincost[i] == inf) continue;\n                    for(int j=0; j<(int)graph[i].size(); j++){\n                        edge &e = graph[i][j];\n                        if(e.cap>0 && mincost[i] +e.cost < mincost[e.to]){\n                            mincost[e.to] = mincost[i] +e.cost;\n                            prevv[e.to] = i;\n                            preve[e.to] = j;\n                            update = true;\n                        }\n                    }\n                }\n                if(!update) break;\n            }\n            if(mincost[g] == inf){\n                return inf;\n            }\n         \n            int d = f;\n            for(int v=g; v!=s; v=prevv[v]){\n                d = min(d, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*mincost[g];\n            for(int v=g; v!=s; v=prevv[v]){\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= d;\n                graph[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nchar int2char(int n){\n    if(n<26) return 'A'+n;\n    return 'a'+n-26;\n}\nint char2int(char c){\n    if('A'<=c and c<='Z'){\n        return c-'A';\n    }\n    return c-'a'+26;\n}\nrexico conv(char c){\n    rexico res{};\n    res[char2int(c)] = -1;\n    return res;\n}\n\nint main(){\n    rexico zero{}, inf;\n    for(int i=0; i<52; i++){\n        inf[i] = 1e9;\n    }\n    int n;\n    cin >> n;\n    vector<string> s(n);\n    for(int i=0; i<n; i++){\n        cin >> s[i];\n    }\n    MincostFlow<rexico> mcf(2*n+2, zero, inf);\n    for(int i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            mcf.add_edge(i, n+j, 1, conv(s[i][j]));\n        }\n        mcf.add_edge(2*n, i, 1, zero);\n        mcf.add_edge(n+i, 2*n+1, 1, zero);\n    }\n    rexico ret = mcf.exec(2*n, 2*n+1, n);\n    string ans = \"\";\n    for(int i=0; i<52; i++){\n        ans += string(-ret[i], int2char(i));\n    }\n    sort(ans.begin(), ans.end());\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tSMALL,\n\tBIG,\n\tEQUAL,\n};\n\n#define NUM 150\n#define DIGIT 53\n\n//辺を表す構造体{行先、容量、コスト、逆辺のインデックス}\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_num,int arg_rev_index,bool is_rev){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tnum = arg_num;\n\t\tfor(int i = 0; i < DIGIT; i++)cost[i] = 0;\n\t\tif(num != -1){\n\t\t\tif(is_rev == false){\n\t\t\t\tcost[num] = -1;\n\t\t\t}else{\n\t\t\t\tcost[num] = 1;\n\t\t\t}\n\t\t}\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,num,cost[DIGIT],rev_index;\n};\n\nint V; //頂点数\nint H,W;\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nint dist[NUM][DIGIT]; //最短距離\nint pre_node[NUM],pre_edge[NUM]; //直前の頂点と辺\nchar base_map[50][51];\n\n\n//桁1～52を、'A'～'z'に対応させる。桁0はBIG_NUMの重み。桁が小さいほど重みが大きい\nint getNUM(char ch){\n\n\tif(ch >= 'A' && ch <= 'Z'){\n\t\treturn ch - 'A'+1;\n\t}else{\n\t\treturn ch - 'a'+26+1;\n\t}\n}\n\nint getCHAR(int num){\n\n\tnum--;\n\n\tif(num <= 25){\n\t\treturn 'A'+num;\n\t}else{\n\t\treturn 'a'+num-26;\n\t}\n}\n\n\n//fromからtoへ向かう容量capacity,コストcostの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity,int arg_num){\n\tG[from].push_back(Edge(to,capacity,arg_num,G[to].size(),false));\n\tG[to].push_back(Edge(from,0,arg_num,G[from].size()-1,true));\n}\n\n//SMALL:Aの方が小さい BIG:Aの方が大きい EQUAL:同じ\nType compare_cost(int cost_A[DIGIT],int cost_B[DIGIT]){\n\n\tfor(int i = 0; i < DIGIT; i++){\n\t\tif(cost_A[i] != cost_B[i]){\n\t\t\tif(cost_A[i] < cost_B[i]){\n\t\t\t\treturn SMALL;\n\t\t\t}else{\n\t\t\t\treturn BIG;\n\t\t\t}\n\t\t}\n\t}\n\treturn EQUAL;\n}\n\nbool is_big_num(int array[DIGIT]){\n\n\treturn array[0] == 1;\n}\n\n//sourceからsinkへの、流量flowの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\n\tint work[DIGIT];\n\n\t//int debug = 0;\n\n\twhile(flow > 0){\n\t\t//ベルマンフォード方により、source-sink間最短経路を求める\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tdist[i][0] = 1; //BIG_NUM扱い\n\t\t\tfor(int k = 1; k < DIGIT; k++)dist[i][k] = 0;\n\t\t}\n\n\t\tdist[source][0] = 0; //全桁0→コスト0扱い\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int node_id = 0; node_id < V; node_id++){\n\t\t\t\tif(is_big_num(dist[node_id]))continue; //辿り着けない\n\t\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\t\tEdge &e = G[node_id][i];\n\n\t\t\t\t\tfor(int i = 0; i < DIGIT; i++)work[i] = dist[node_id][i]+e.cost[i]; //★配列形式のコスト★\n\n\t\t\t\t\tif(e.capacity > 0 && compare_cost(work,dist[e.to]) == SMALL){\n\n\t\t\t\t\t\tfor(int i = 0; i < DIGIT; i++)dist[e.to][i] = work[i]; //node_idを経由した方が早い場合\n\t\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t//printf(\"%d-%dを経由したら早くなる\\n\",node_id,e.to);\n\t\t\t\t\t\t//printf(\"UPDATE!!\\n\");\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(is_big_num(dist[sink])){\n\t\t\t//これ以上流せない\n\t\t\treturn -1;\n\t\t}\n\n\t\t//printf(\"flow:%d\\n\",flow);\n\t\t//source-sink間最短路に沿って目いっぱい流す\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\t//printf(\"node_id:%d\\n\",node_id);\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\t//printf(\"flow:%d\\n\",flow);\n\t\tret += 0; //戻り値不要\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tint size;\n\n\tscanf(\"%d\",&size);\n\tH = size;\n\tW = H;\n\n\tfor(int row = 0; row < H; row++){\n\t\tscanf(\"%s\",base_map[row]);\n\t}\n\n\tint source = 0,sink = 1,index = 2;\n\tint index_row[H],index_col[W];\n\n\tfor(int row = 0; row < H; row++)index_row[row] = index++;\n\tfor(int col = 0; col < W; col++)index_col[col] = index++;\n\n\tfor(int i = 0; i < size; i++){\n\t\tadd_edge(source,index_row[i],1,-1); //sourceから行ノードにcap1,cost0の辺を張る\n\t}\n\n\tfor(int i = 0; i < size; i++){\n\t\tadd_edge(index_col[i],sink,1,-1); //列ノードから行ノードにcap1,cost0の辺を張る\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tadd_edge(index_row[row],index_col[col],1,getNUM(base_map[row][col])); //行と列を、文字のコストで結ぶ\n\t\t}\n\t}\n\n\n\tV = index;\n\tmin_cost_flow(source,sink,size);\n\n\tvector<int> ANS;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int i = 0; i < G[index_row[row]].size(); i++){\n\t\t\tif(G[index_row[row]][i].capacity == 0){ //フローが流れた辺の値を取得する\n\t\t\t\tANS.push_back(G[index_row[row]][i].num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(ANS.begin(),ANS.end());\n\n\tfor(int i = 0; i < size; i++)printf(\"%c\",getCHAR(ANS[i]));\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\n#include <time.h>\nusing namespace std;\nlong double esp=1e-11;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define cle(a) while(!a.empty())a.pop()\n#define mem(p) memset(p,0,sizeof(p))\n#define memf(p) memset(p,0x3f,sizeof(p))\n#define memn(p) memset(p,-1,sizeof(p))\n#define mp(A, B) make_pair(A, B)\n#define pb push_back\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\ntypedef long long int LL;\nconst long double PI = acos((long double)-1);\nconst LL INF=0x3f3f3f3fll;\nconst int MOD = 1000000007;\nconst int maxn=110000;\ntypedef  struct {int v,next,val;} edge;\nconst int MAXN=110;\nconst int MAXM=30010;\n\nedge e[MAXM];\nint p[MAXN],eid;\n\ninline void init(){memset(p,-1,sizeof(p));eid=0;}\n\n//??????\ninline void insert1(int from,int to,int val)\n{\n    e[eid].v=to;\n    e[eid].val=val;\n    e[eid].next=p[from];\n    p[from]=eid++;\n\n    swap(from,to);\n\n    e[eid].v=to;\n    e[eid].val=0;\n    e[eid].next=p[from];\n    p[from]=eid++;\n}\n\nint N=MAXN;//n????????° m????????°\nint h[MAXN];\nint gap[MAXN];\n\nint source,sink;\ninline int dfs(int pos,int cost)\n{\n    if (pos==sink)\n    {\n        return cost;\n    }\n\n    int j,minh=N-1,lv=cost,d;\n\n    for (j=p[pos];j!=-1;j=e[j].next)\n    {\n        int v=e[j].v,val=e[j].val;\n        if(val>0)\n        {\n            if (h[v]+1==h[pos])\n            {\n                if (lv<e[j].val) d=lv;\n                else d=e[j].val;\n\n                d=dfs(v,d);\n                e[j].val-=d;\n                e[j^1].val+=d;\n                lv-=d;\n                if (h[source]>=N) return cost-lv;\n                if (lv==0) break;\n            }\n\n            if (h[v]<minh)    minh=h[v];\n        }\n    }\n\n    if (lv==cost)\n    {\n        --gap[h[pos]];\n        if (gap[h[pos]]==0) h[source]=N;\n        h[pos]=minh+1;\n        ++gap[h[pos]];\n    }\n\n    return cost-lv;\n\n}\n\nint sap(int st,int ed)\n{\n\n    source=st;\n    sink=ed;\n    int ret=0;\n    memset(gap,0,sizeof(gap));\n    memset(h,0,sizeof(h));\n\n    gap[st]=N;\n\n    while (h[st]<N)\n    {\n        ret+=dfs(st,INT_MAX);\n    }\n\n    return ret;\n}\nchar s[55][55];\nint dx[55],dy[55];\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"inlay.in\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    //map<long long int,int>ma;                 %I64d\n    //vector<int>::iterator iter;\n    //memset(m,0,sizeof(int));\n    //for(int x=1;x<=n;x++)\n    //for(int y=1;y<=n;y++)\n    //scanf(\"%d%d\",&a,&b);\n    //scanf(\"%d\",&a);\n    //printf(\"%d\\n\",ans);\n    mem(dx);\n    mem(dy);\n    int n;\n    scanf(\"%d\",&n);\n    int st=105,ed=106;\n    for(int x=0;x<n;x++)\n        scanf(\"%s\",s[x]);\n    vector<int>ans;\n    ans.clear();\n    for(int z='A';z<='z';(z=='Z')?z='a':z++)\n    {\n        init();\n        for(int x=0;x<n;x++)\n        if(!dx[x])\n        insert1(st,x+1,1);\n        for(int y=0;y<n;y++)\n        if(!dy[y])\n        insert1(n+y+1,ed,1);\n        for(int x=0;x<n;x++)\n            if(!dx[x])\n            for(int y=0;y<n;y++)\n            if(s[x][y]==z&&!dy[y])\n            {\n                insert1(x+1,n+y+1,1);\n            }\n        sap(st,ed);\n        for(int x=n+1;x<=2*n;x++)\n        {\n            for (int j=p[x];j!=-1;j=e[j].next)\n            if(e[j].v<=n&&e[j].val>0)\n            {\n                ans.pb(z);\n                dx[e[j].v-1]=1;\n                dy[x-n-1]=1;\n            }\n        }\n    }\n    sort(all(ans));\n    for(int x=0;x<n;x++)\n        printf(\"%c\",ans[x]);\n    putchar(10);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 50\nusing namespace std;\ntypedef pair<char,string> P;\ntypedef pair<int,int> P1;\n\nint n;\nstring s[N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nvoid solve(){\n  string ans;\n  \n  while(n){\n    \n    map<P,vector<P1> > memo;\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\t\n\tstring str;\n\t\n\tfor(int k=0;k<4;k++){\n\t  \n\t  int ny=i+dy[k],nx=j+dx[k];\n\t  \n\t  while(1){\n\t    \n\t    if(ny<0||nx<0||n<=ny||n<=nx)break;\n\t    \n\t    str+=s[ny][nx];\n\t    \n\t    ny+=dy[k],nx+=dx[k];\n\t  }\n\t  \n\t}\n\t\n\tsort(str.begin(),str.end());\n\t\n\tmemo[P(s[i][j],str)].push_back(P1(i,j));\n      }\n    }\n    \n    map<P,vector<P1> >::iterator ite=memo.begin();\n    \n    int y,x;\n    char minc=(*ite).first.first;\n    \n    ans+=minc;\n    \n    while(ite!=memo.end()){\n      \n      if(minc<(*ite).first.first)break;\n      else y=(*ite).second[0].first,x=(*ite).second[0].second;\n      ite++;\n    }\n    \n    string t[N];\n    int idx=0;\n    \n    for(int i=0;i<n;i++){\n      if(y==i)continue;\n      for(int j=0;j<n;j++){\n\t\n\tif(x==j)continue;\n\t\n\tt[idx]+=s[i][j];\n      }\n      idx++;\n    }\n    \n    n--;\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)s[i][j]=t[i][j];\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>s[i];\n  \n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX = 52;\nconst int MAX_V = 100010;\ntypedef int Capacity;\ntypedef vector<int> Cost;\nconst Cost inf = Cost(MAX, 1000000);\nconst Cost zero = Cost(MAX, 0);\n\nCost operator -(Cost c) {\n\tfor(auto& a : c) a *= -1;\n\treturn c;\n}\n\nCost operator +(Cost c1, Cost c2) {\n\tfor(int i = 0; i < c1.size(); i++) c1[i] += c2[i];\n\treturn c1;\n}\n\nCost operator -(Cost c1, Cost c2) {\n\tfor(int i = 0; i < c1.size(); i++) c1[i] -= c2[i];\n\treturn c1;\n}\n\nstruct Edge {\n\tint dst;\n\tCapacity cap, cap_orig;\n\tCost cost;\n\tint revEdge; bool isRev;\n\tEdge(int dst, Capacity cap, Cost cost, int revEdge, bool isRev)\n\t\t:dst(dst), cap(cap), cap_orig(cap), cost(cost), revEdge(revEdge), isRev(isRev) {\n\t}\n};\n\n\nstruct PrimalDual {\n\tint n;\n\tvector<vector<Edge> > g;\n\tvector<int> top;\n\tPrimalDual(int n_) : n(n_), g(vector<vector<Edge> >(n_)) {}\n\tvoid add_edge(int src, int dst, Capacity cap, Cost cost) { // ?????????\n\t\tg[src].push_back(Edge{ dst, cap, cost, (int)g[dst].size(), false });\n\t\tg[dst].push_back(Edge{ src, 0, -cost, (int)g[src].size() - 1, true });\n\t}\n\tCost solve(int s, int t, int f) {\n\t\tCost res(52, 0);\n\t\tstatic Cost h[MAX_V], dist[MAX_V];\n\t\tstatic int prevv[MAX_V], preve[MAX_V];\n\n\t\tfill(h, h + n, zero);\n\t\tif(top.size()) {\n\t\t\tassert(top.size() == n);\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint v = top[i];\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge& e = g[v][i];\n\t\t\t\t\tif(e.cap == 0) continue;\n\t\t\t\t\tint u = e.dst;\n\t\t\t\t\th[u] = min(h[u], h[v] + e.cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile(f > 0) {\n\t\t\ttypedef pair<Cost, int> pcv;\n\t\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdist[i] = inf;\n\t\t\t}\n\t\t\tdist[s] = Cost(MAX, 0);\n\t\t\tq.push(pcv(Cost(MAX, 0), s));\n\t\t\twhile(q.size()) {\n\t\t\t\tpcv p = q.top(); q.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif(dist[v] < p.first) continue;\n\t\t\t\tfor(int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif(e.cap > 0 && dist[e.dst] > dist[v] + e.cost + h[v] - h[e.dst]) {\n\t\t\t\t\t\tdist[e.dst] = dist[v] + e.cost + h[v] - h[e.dst];\n\t\t\t\t\t\tprevv[e.dst] = v;\n\t\t\t\t\t\tpreve[e.dst] = i;\n\t\t\t\t\t\tq.push(pcv(dist[e.dst], e.dst));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t] == inf) {\n\t\t\t\treturn inf;// !!!!!\n\t\t\t}\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\th[v] = h[v] + dist[v];\n\t\t\t}\n\t\t\t// s-t ????????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tfor(int i = 0; i < MAX; i++) {\n\t\t\t\tres[i] += d * h[t][i];\n\t\t\t}\n\t\t\tfor(int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.revEdge].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t// ??????????????????=???????????????-?????¨??????????????¨???\n\t/*void view() {\n\t\tfor(int i = 0; i < g.size(); i++) {\n\t\tfor(int j = 0; j < g[i].size(); j++) {\n\t\tif(!g[i][j].isRev) {\n\t\tEdge& e = g[i][j];\n\t\tprintf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n\t\t}\n\t\t}\n\t\t}\n\t\t}*/\n};\n\nstring b[50];\n\nint conv(char c) {\n\tif('A' <= c && c <= 'Z') return c - 'A';\n\treturn c - 'a' + 26;\n}\n\nchar deconv(int id) {\n\tif(id <= 25) return 'A' + id;\n\treturn 'a' + (id - 26);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> b[i];\n\t}\n\n\tPrimalDual pd(2 * N + 2);\n\tint S = 2 * N, T = S + 1;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tint c = conv(b[i][j]);\n\t\t\tCost cost(MAX, 0);\n\t\t\tcost[c] = -1;\n\t\t\tpd.add_edge(i, N + j, 1, cost);\n\t\t}\n\t\tpd.add_edge(S, i, 1, zero);\n\t\tpd.add_edge(i + N, T, 1, zero);\n\t}\n\n\tCost res = pd.solve(S, T, N);\n\tassert(res != inf);\n\tfor(int i = 0; i < MAX; i++) {\n\t\tfor(int j = 0; j < -res[i]; j++) {\n\t\t\tcout << deconv(i);\n\t\t}\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nconst int INF = 1 << 30;\n\ntypedef vector< int > vi;\n\nvi operator+(const vi &t, const vi &s)\n{\n  vi ret(52);\n  for(int i = 0; i < 52; i++) ret[i] = t[i] + s[i];\n  return (ret);\n}\n\nvi operator-(const vi &t)\n{\n  vi ret(52);\n  for(int i = 0; i < 52; i++) ret[i] = t[i] * -1;\n  return (ret);\n}\n\nvi operator*(const vi &t, int k)\n{\n  vi ret(52);\n  for(int i = 0; i < 52; i++) ret[i] = t[i] * k;\n  return (ret);\n}\n\nstruct Primal_Dual\n{\n  typedef pair< vi, int > Pi;\n\n  struct edge\n  {\n    int to, cap;\n    vi cost;\n    int rev;\n  };\n\n  vector< vector< edge > > graph;\n  vector< vi > potential, min_cost;\n  vector< int > prevv, preve;\n\n  Primal_Dual(int V) : graph(V) {}\n\n  void add_edge(int from, int to, int cap, vi cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n\n  vi min_cost_flow(int s, int t, int f)\n  {\n    int V = graph.size();\n    vi ret(52, 0);\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, vi(52, 0));\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, vi(52, INF));\n      que.push(Pi(vi(52, 0), s));\n      min_cost[s] = vi(52, 0);\n\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          vi nextCost = min_cost[p.second] + e.cost + potential[p.second] + -potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t][0] == INF) return (vi(52, -1));\n      for(int v = 0; v < V; v++) potential[v] = potential[v] + min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret = ret + potential[t] * addflow;\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nconst string temp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nint main()\n{\n  int N;\n  string S[50];\n\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> S[i];\n  }\n\n  Primal_Dual flow(N + N + 2);\n  const int s = N + N, t = N + N + 1;\n  vi vc(52, 0);\n  for(int i = 0; i < N; i++) flow.add_edge(s, i, 1, vc);\n  for(int i = 0; i < N; i++) flow.add_edge(i + N, t, 1, vc);\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      vc[temp.find(S[i][j])]--;\n      flow.add_edge(i, j + N, 1, vc);\n      vc[temp.find(S[i][j])]++;\n    }\n  }\n\n  auto cost = flow.min_cost_flow(s, t, N);\n  for(int i = 0; i < 52; i++) cout << string(-cost[i], temp[i]);\n  cout << endl;"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  string s[n],ans,tmp;\n  for(int i=0;i<n;i++) cin>>s[i];\n  bool f=1;\n  \n  f=1;\n  while(f){\n    f=0;\n    for(int i=0;!f&&i<n;i++){\n      for(int j=0;!f&&j<n;j++){\n\tfor(int a=0;!f&&a<n;a++){\n\t  for(int b=0;!f&&b<n;b++){\n\t    char p[4]={s[i][i],s[a][a],s[j][j],s[b][b]};\n\t    char q[4]={s[a][i],s[i][a],s[j][b],s[b][j]};\n\t    sort(p,p+4);sort(q,q+4);\n\t    for(int l=0;l<4;l++){\n\t      f|=p[l]>q[l];\n\t      if(p[l]<q[l]) break;\n\t    }\n\t    \n\t    if(f){\n\t      swap(s[i],s[a]);\n\t      for(int l=0;l<n;l++) swap(s[l][j],s[l][b]);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  f=1;\n  while(f){\n    tmp=ans=\"\";\n    for(int i=0;i<n;i++) tmp+=s[i][i];\n    sort(tmp.begin(),tmp.end());\n    f=0;\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  if(s[i][j]<s[k][k]){\n\t    if((s[j][j]>=s[j][k]&&s[k][k]>s[j][k])||\n\t       (s[j][j]>s[j][k])||\n\t       (s[i][i]>=s[k][i]&&s[k][k]>s[k][i])||\n\t       (s[i][i]>s[k][i])) {\n\t      swap(s[i],s[k]);\n\t      for(int l=0;l<n;l++) swap(s[l][j],s[l][k]);\n\t      f=1;\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(int i=0;i<n;i++) ans+=s[i][i];\n    sort(ans.begin(),ans.end());\n    if(ans==tmp) break;\n    //cout<<ans<<endl;\n  }\n  f=1;\n  while(f){\n    f=0;\n    for(int i=0;!f&&i<n;i++){\n      for(int j=0;!f&&j<n;j++){\n\tfor(int a=0;!f&&a<n;a++){\n\t  for(int b=0;!f&&b<n;b++){\n\t    char p[4]={s[i][i],s[a][a],s[j][j],s[b][b]};\n\t    char q[4]={s[a][i],s[i][a],s[j][b],s[b][j]};\n\t    sort(p,p+4);sort(q,q+4);\n\t    for(int l=0;l<4;l++){\n\t      f|=p[l]>q[l];\n\t      if(p[l]<q[l]) break;\n\t    }\n\t    \n\t    if(f){\n\t      swap(s[i],s[a]);\n\t      for(int l=0;l<n;l++) swap(s[l][j],s[l][b]);\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  //for(int i=0;i<n;i++) cout<<s[i]<<endl;\n  ans=\"\";\n  for(int i=0;i<n;i++) ans+=s[i][i];\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <stdio.h>\n#include <iostream>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <bitset>\n#include <string>\n#include <time.h>\nusing namespace std;\nlong double esp=1e-11;\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define cle(a) while(!a.empty())a.pop()\n#define mem(p) memset(p,0,sizeof(p))\n#define memf(p) memset(p,0x3f,sizeof(p))\n#define memn(p) memset(p,-1,sizeof(p))\n#define mp(A, B) make_pair(A, B)\n#define pb push_back\n#define lson l , m , rt << 1\n#define rson m + 1 , r , rt << 1 | 1\ntypedef long long int LL;\nconst long double PI = acos((long double)-1);\nconst LL INF=0x3f3f3f3fll;\nconst int MOD = 1000000007;\nconst int maxn=110000;\n#define V 110\n#define E 45100\nint vis[V];\nint dist[V];\nint pre[V];\n\nstruct Edge{\n    int u,v,c,cost,next;\n}edge[E];\nint head[V],cnt;\n\nvoid init(){\n    cnt=0;\n    memset(head,-1,sizeof(head));\n}\nvoid addedge(int u,int v,int c,int cost)\n{\n    edge[cnt].u=u;edge[cnt].v=v;edge[cnt].cost=cost;\n    edge[cnt].c=c;edge[cnt].next=head[u];head[u]=cnt++;\n\n    edge[cnt].u=v;edge[cnt].v=u;edge[cnt].cost=-cost;\n    edge[cnt].c=0;edge[cnt].next=head[v];head[v]=cnt++;\n}\n\nbool spfa(int begin,int end){\n    int u,v;\n    queue<int> q;\n    for(int i=0;i<=end+2;i++){\n        pre[i]=-1;\n        vis[i]=0;\n        dist[i]=INF;\n    }\n    vis[begin]=1;\n    dist[begin]=0;\n    q.push(begin);\n    while(!q.empty()){\n        u=q.front();\n        q.pop();\n        vis[u]=0;\n        for(int i=head[u];i!=-1;i=edge[i].next){\n            if(edge[i].c>0){\n                v=edge[i].v;\n                if(dist[v]>dist[u]+edge[i].cost){\n                    dist[v]=dist[u]+edge[i].cost;\n                    pre[v]=i;\n                    if(!vis[v]){\n                        vis[v]=true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n    }\n    return dist[end]!=INF;\n}\n\nint MCMF(int begin,int end){\n    int ans=0,flow;\n    int flow_sum=0;\n    while(spfa(begin,end)){\n        flow=INF;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u])\n            if(edge[i].c<flow)\n                flow=edge[i].c;\n        for(int i=pre[end];i!=-1;i=pre[edge[i].u]){\n            edge[i].c-=flow;\n            edge[i^1].c+=flow;\n        }\n        ans+=dist[end];\n        flow_sum += flow;\n    }\n    //cout << flow_sum << endl;\n    return ans;\n}\nchar s[110];\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"inlay.in\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    //map<long long int,int>ma;                 %I64d\n    //vector<int>::iterator iter;\n    //memset(m,0,sizeof(int));\n    //for(int x=1;x<=n;x++)\n    //for(int y=1;y<=n;y++)\n    //scanf(\"%d%d\",&a,&b);\n    //scanf(\"%d\",&a);\n    //printf(\"%d\\n\",ans);\n    int n;\n    while(scanf(\"%d\",&n)!=EOF){\n    init();\n    int st=105,ed=106;\n    for(int x=0;x<n;x++)\n        addedge(st,x,1,0),addedge(n+x,ed,1,0);\n\n    for(int x=0;x<n;x++)\n    {\n        scanf(\"%s\",s);\n        for(int y=0;y<n;y++)\n            addedge(x,n+y,1,s[y]);\n    }\n    MCMF(st,ed);\n    vector<int>ans;\n    ans.clear();\n    for(int x=0;x<cnt;x++)\n        if(edge[x].u>=n&&edge[x].u<2*n&&edge[x].v<n&&edge[x].c>0&&edge[x].cost<0)\n            ans.pb(-edge[x].cost);\n    sort(all(ans));\n    for(int x=0;x<n;x++)\n        printf(\"%c\",ans[x]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{\n  int to, cap,rev;\n  string cost;\n  edge(){};\n  edge(int a,int b,string c,int d){\n    to=a, cap=b, cost=c, rev=d;\n  };\n};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nstring dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,string cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  string C=cost;\n  if(cost.size())C+=\"{\";\n  G[to].push_back((edge){from,0,C,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nstring min_cost_flow(int s,int t,int f){\n  \n  string res;\n  \n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    for(int i=0;i<V;i++) dist[i]=\"{\";\n    dist[s]=res;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==\"{\") continue;\n\t\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  \n\t  string str;\n\t  \n\t  if(e.cost.size()==2){\n\t    \n\t    string tmp;\n\t    int F=0;\n\t    \n\t    for(int j=0;j<dist[v].size();j++){\n\t      if(!F&&dist[v][j]==e.cost[0]){\n\t\tF=1;\n\t\tcontinue;\n\t      }\n\t      tmp+=dist[v][j];\n\t    }\n\t    \n\t    str=tmp;\n\t    \n\t  }else str=dist[v]+e.cost;\n\t  \n\t  sort(str.begin(),str.end());\n\t  \n\t  if(e.cap > 0 && dist[e.to] > str){\n\t    dist[e.to] = str;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res=dist[t];\n    \n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  \n  return res;\n}\n\nint main(){\n  \n  int n;\n  cin>>n;\n  \n  int S=n*2,T=S+1;\n\n  for(int i=0;i<n;i++){\n    \n    string s;\n    cin>>s;\n    \n    for(int j=0;j<n;j++){\n      string t;\n      t+=s[j];\n      add_edge(i,j+n,1,t);\n    }\n    \n  }\n\n  for(int i=0;i<n;i++){\n    add_edge(S,i,1,\"\");\n    add_edge(i+n,T,1,\"\");\n  }\n  \n  V=n*2+2;\n  \n  cout<<min_cost_flow(S,T,n)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> add(vector<int> a,vector<int> b){\n  vector<int> res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]+b[i];\n  return res;\n}\n\nvector<int> sub(vector<int> a){\n  vector<int> res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=-a[i];\n  return res;\n}\n\n\nint change(char ch){\n  int res;\n  if('A'<=ch&&ch<='Z'){\n    res= ch-'A';\n  }else{\n    res= 26+ch-'a';\n  }\n  return 59-res;\n}\n\nint N;\nchar mp[55][55];\nint t[55][55];\n\nstruct edge{\n  int to;\n  int cap;\n  vector<int> cost;\n  int rev;\n\n  edge( int a,int b, vector<int> c,int d){\n    to=a;\n    cap=b;\n    cost=c;\n    rev=d;\n  }\n};\n\n#define MAX_V 205\n\nvector<edge> G[MAX_V];\nvector<int> h[MAX_V];\nvector<int> dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,vector<int> cost){\n  G[from].push_back( edge(to,cap,cost,G[to].size() ) );\n  G[to].push_back(   edge(from,0, sub(cost) ,G[from].size()-1 ) );\n}\n\ntypedef pair< vector<int> , int > P;\n\nvector<int> min_cost_flow(int s,int t,int f){\n  vector<int> res(60,0);\n  \n  fill( h, h+MAX_V, vector<int>(60,0) );\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > Q;\n    fill(dist,dist+MAX_V, vector<int>(60,1e5) );\n    dist[s]= vector<int>(60,0);\n    Q.push(P( dist[s] ,s));\n    while(!Q.empty()){\n      P p=Q.top();Q.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      \n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0){\n\n          vector<int> tmp = add(dist[v],e.cost);\n          tmp=add(tmp,h[v]);\n          vector<int> tmp2 = sub(h[e.to]);\n          tmp = add(tmp, tmp2);\n\n          \n          if(dist[e.to]>tmp){\n            dist[e.to]=tmp;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            Q.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n    }\n\n    \n    for(int v=0;v<MAX_V;v++)h[v]=add(h[v],dist[v]);\n    \n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    f-=d;\n    \n    res=add(res,h[t]);\n    \n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  \n  cin>>N;\n  int si=N+N;\n  int ti=N+N+1;\n\n  map< int , char > dm;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      char ch;\n      cin>>ch;\n      dm[ change(ch) ] = ch;\n      mp[i][j]=ch;\n    }\n  }\n\n    \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      t[i][j]=G[i].size();\n      vector<int> tmp(60,0);\n      tmp[ change(mp[i][j]) ] =  1;\n      add_edge(i,N+j,1,tmp);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    vector<int> tmp(60,0);\n    add_edge(si,i,1,tmp);\n    add_edge(N+i,ti,1,tmp);\n  }\n\n  vector<int> vec = min_cost_flow(si,ti,N);\n\n  string ans=\"\";\n\n\n  for(int i=0;i<60;i++){\n    for(int j=0;j<vec[i];j++){\n      ans+= dm[i];\n    }\n  }\n  assert((int)ans.size()==N);\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  /*\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      edge e=G[i][ t[i][j] ];\n      if(e.cap==0)ans+=mp[i][j];\n    }\n  }\n\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define MAX_N 1000\nusing namespace std;\n\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nvector<int> dist[MAX_V];               //???????????¢\nconst vector<int> INF(1<<8,1000);\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  while(f>0){\n    for(int i=0;i<V;i++) dist[i]=INF;\n    dist[s]=vector<int>(1<<8,0);\n\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  vector<int> ncost=dist[v];\n\t  if(e.cost!=0)ncost[abs(e.cost)]+=e.cost/abs(e.cost);\n\t  \n\t  if(e.cap > 0 && dist[e.to] > ncost){\n\t    dist[e.to] = ncost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    //res[ += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return 10;\n}\n\n\nint can[MAX_N][MAX_N];\nint Biparite_Matching(int N,int K){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)add_edge(i, N+j,1,can[i][j]);\n  V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\n\n\nint main(){\n  int n;\n  cin>>n;\n  \n  string mp[51];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)can[i][j] = -mp[i][j];\n\n  Biparite_Matching(n,n);\n  string ans;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++)\n      if(G[i][j].cap==0) ans+=mp[i][G[i][j].to-n];\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  string s[n],ans,tmp;\n  for(int i=0;i<n;i++) cin>>s[i];\n  bool f=1;\n  while(f){\n    f=0;\n    for(int k=0;!f&&k<n;k++){\n      for(int i=0;!f&&i<n;i++){\n\tfor(int j=0;!f&&j<n;j++){\n\t  char p[3]={s[k][k],s[i][i],s[j][j]},q[3]={s[i][j],s[k][i],s[j][k]};\n\t  sort(p,p+3);sort(q,q+3);\n\t  for(int l=0;l<3;l++){\n\t    f|=p[l]>q[l];\n\t    if(p[l]<q[l]) break;\n\t  }\n\t  \n\t  if(f){\n\t    swap(s[i],s[k]);\n\t    for(int l=0;l<n;l++) swap(s[l][j],s[l][k]);\n\t  }\n\t}\n      }\n    }\n  }\n  //for(int i=0;i<n;i++) cout<<s[i]<<endl;\n  for(int i=0;i<n;i++) ans+=s[i][i];\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (?????????,??????,??????)\nstruct edge{ int to,cap,rev; };\n\nconst int MAX_V = 111; // TODO:initialize\nconst int F_INF = 123456; // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,0,(int)G[from].size()-1});\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// ?¢?????????????dfs??§??¢???\nint dinic_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d = dinic_dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dinic_dfs(s,t,F_INF))>0) flow+=f;\n    }\n}\n\nint main()\n{\n    int n;\n    cin >>n;\n    vector<string> s(n);\n    rep(i,n) cin >>s[i];\n\n    int S = 2*n, T = S+1;\n\n    rep(i,n)\n    {\n        add_edge(S,i,1);\n        add_edge(n+i,T,1);\n    }\n\n    string ans = \"\";\n    string Aa=\"Aa\";\n    rep(i,2)rep(j,26)\n    {\n        char c = Aa[i]+j;\n        rep(row,n)rep(col,n)\n        {\n            if(s[row][col]==c) add_edge(row,n+col,1);\n        }\n\n        int f = max_flow(S,T);\n        while(f--) ans += c;\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  int n;cin>>n;\n  string s[n],ans,tmp;\n  for(int i=0;i<n;i++) cin>>s[i];\n  for(int i=0;i<n;i++) ans+=s[i][i];\n  sort(ans.begin(),ans.end());\n  bool f=1;\n  time_t ti=clock();\n  while((double)(clock()-ti)/CLOCKS_PER_SEC<1.7){\n    f=0;\n    for(int i=0;!f&&i<n;i++){\n      for(int j=0;!f&&j<n;j++){\n\tfor(int a=0;!f&&a<n;a++){\n\t  for(int b=0;!f&&b<n;b++){\n\t    char p[4]={s[i][i],s[a][a],s[j][j],s[b][b]};\n\t    char q[4]={s[a][i],s[i][a],s[j][b],s[b][j]};\n\t    sort(p,p+4);sort(q,q+4);\n\t    for(int l=0;l<4;l++){\n\t      f|=p[l]>q[l];\n\t      if(p[l]<q[l]) break;\n\t    }\n\t    if(f){\n\t      for(int l=0;l<n;l++) swap(s[i][l],s[a][l]);\n\t      for(int l=0;l<n;l++) swap(s[l][j],s[l][b]);\n\t    }\n\t  }\n\t}\n      }\n    }\n    if(!f){\n      int i=rand()%n,j=rand()%n,a=rand()%n,b=rand()%n;\n      for(int l=0;l<n;l++) swap(s[i][l],s[a][l]);\n      for(int l=0;l<n;l++) swap(s[l][j],s[l][b]);\n    }else{\n      tmp=\"\";\n      for(int i=0;i<n;i++) tmp+=s[i][i];\n      sort(tmp.begin(),tmp.end());\n      if(tmp.compare(ans)<0) ans=tmp;\n    }\n  }\n  //for(int i=0;i<n;i++) cout<<s[i]<<endl;\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct bigint : public array<int, 52> {\n  bigint() { this->fill(0); }\n};\n\nbigint operator + (bigint const& l, bigint const& r) {\n  bigint ret;\n  rep(i, l.size()) ret[i] = l[i] + r[i];\n  return ret;\n}\n\nbigint& operator += (bigint& l, bigint const& r) {\n  rep(i, l.size()) l[i] += r[i];\n  return l;\n}\n\nbigint& operator -= (bigint& l, bigint const& r) {\n  rep(i, l.size()) l[i] -= r[i];\n  return l;\n}\n\nbigint operator - (bigint const& l, bigint const& r) {\n  bigint ret;\n  rep(i, ret.size()) ret[i] = l[i] - r[i];\n  return ret;\n}\n\nbigint operator * (int k, bigint const& x) {\n  auto ret = x;\n  rep(i, ret.size()) ret[i] *= k;\n  return ret;\n}\n\nbigint operator - (bigint const& x) {\n  auto ret = x;\n  rep(i, ret.size()) ret[i] *= -1;\n  return ret;\n}\n\nostream& operator << (ostream& ost, bigint const& xs) {\n  ost << \"[\";\n  rep(i, xs.size()) ost << xs[i] << \", \";\n  return ost << \"]\";\n}\n\nnamespace flow {\n\ntemplate<typename Flow, typename Cost>\nstruct edge_ {\n  int to; Flow cap; Cost cost; int rev;\n  edge_(int t, Flow ca, Cost co, int r) : to{t}, cap{ca}, cost{co}, rev{r} {}\n};\n\ntypedef edge_<int, bigint> edge;\n\ntemplate<typename Flow, typename Cost>\nstruct primal_dual {\n\n  vector<vector<edge>> G;\n  vector<Cost> h, dist;\n  vector<int> prevv, preve;\n\n  Cost zero_cost = bigint();\n  Cost infinity_cost;\n  Cost none_cost;\n\n  bool cannot_reach_sink(int sink) {\n    return dist[sink] == infinity_cost;\n  }\n\n  primal_dual(int V) : G(V), h(V), dist(V), prevv(V), preve(V) {\n    rep(i, infinity_cost.size()) {\n      infinity_cost[i] = none_cost[i] = inf;\n    }\n  }\n\n  void add_edge(int from, int to, Flow cap, Cost cost) {\n    G[from].emplace_back(to, cap, cost, G[to].size());\n    G[to].emplace_back(from, 0, -cost, G[from].size()-1);\n  }\n\n  Cost min_cost_flow(int s, int t, Flow f) {\n    Cost ret = zero_cost;\n    fill(h.begin(), h.end(), zero_cost);\n    while(f > 0) {\n      typedef pair<Cost, int> P;\n      priority_queue<P, vector<P>, greater<P>> pq;\n      fill(dist.begin(), dist.end(), infinity_cost);\n      dist[s] = zero_cost;\n      pq.emplace(zero_cost, s);\n      while(!pq.empty()) {\n        P p = pq.top(); pq.pop();\n        int v = p.second;\n        if(dist[v] < p.first) continue;\n        for(int i=0; i<G[v].size(); i++) {\n          auto& e = G[v][i];\n          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            pq.emplace(dist[e.to], e.to);\n          }\n        }\n      }\n\n      if(cannot_reach_sink(t)) return none_cost;\n      for(int i=0; i<h.size(); i++)\n        h[i] += dist[i];\n\n      Flow d = f;\n      for(int i=t; i!=s; i=prevv[i])\n        d = min(d, G[prevv[i]][preve[i]].cap);\n\n      f -= d;\n      ret += d * h[t];\n      for(int i=t; i!=s; i=prevv[i]) {\n        auto& e = G[prevv[i]][preve[i]];\n        e.cap -= d;\n        G[i][e.rev].cap += d;\n      }\n    }\n    return ret;\n  }\n\n};\n\n}\n\ntypedef flow::primal_dual<int, bigint> PrimalDual;\n\nint main() {\n\n  int N; cin >> N;\n  vector<string> G(N);\n  rep(i, N) cin >> G[i];\n\n  string coef; rep(k, 2) rep(i, 26) coef += char(\"Aa\"[k] + i);\n\n  PrimalDual pd(N * 2 + 2);\n  rep(i, N) rep(j, N) {\n    bigint cost;\n    cost[coef.find(G[i][j])]++;\n    pd.add_edge(i, N+j, 1, -cost);\n  }\n\n  const int SRC = N * 2, SINK = N * 2 + 1;\n  rep(i, N) {\n    pd.add_edge(SRC, i, 1, bigint());\n    pd.add_edge(N+i, SINK, 1, bigint());\n  }\n\n  auto r = -pd.min_cost_flow(SRC, SINK, N);\n\n  rep(i, coef.size()) {\n    rep(k, r[i]) cout << coef[i];\n  }\n\n  cout << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (?????????,??????,??????)\nstruct edge{ int to,cap,rev; };\n\nconst int MAX_V = 111; // TODO:initialize\nconst int F_INF = 123456; // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,0,(int)G[from].size()-1});\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// ?¢?????????????dfs??§??¢???\nint dinic_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d = dinic_dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// s??????t???????????§???\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dinic_dfs(s,t,F_INF))>0) flow+=f;\n    }\n}\n\nint main()\n{\n    int n;\n    cin >>n;\n    vector<string> s(n);\n    rep(i,n) cin >>s[i];\n\n    int S = 2*n, T = S+1;\n\n    vector<bool> ur(n), uc(n);\n    string ans = \"\";\n    string Aa=\"Aa\";\n    rep(i,2)rep(j,26)\n    {\n        rep(x,MAX_V) G[x].clear();\n\n        rep(x,n)if(!ur[x]) add_edge(S,x,1);\n        rep(x,n)if(!uc[x]) add_edge(n+x,T,1);\n\n        char c = Aa[i]+j;\n        rep(row,n)rep(col,n)\n        {\n            if(s[row][col]==c) add_edge(row,n+col,1);\n        }\n\n        int f = max_flow(S,T);\n        rep(k,G[T].size())\n        {\n            edge &e = G[T][k];\n            if(e.cap>0) uc[e.to-n] = true;\n        }\n        rep(k,G[S].size())\n        {\n            edge &e = G[S][k];\n            if(e.cap==0) ur[e.to] = true;\n        }\n\n        while(f--) ans += c;\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N; cin >> N;\n\tvector<vector<char>> c(N, vector<char>(N));\n\tvector<char> ch;\n\trep(i, 0, N) rep(j, 0, N) { cin >> c[i][j]; ch.emplace_back(c[i][j]); }\n\tsort(all(ch));\n\tch.erase(unique(ch.begin(), ch.end()), ch.end());\n\tvector<int> r;\n\trep(i, 0, ch.size()) {\n\t\tint a = rand();\n\t\tif (find(r.begin(), r.end(), a) == r.end())\n\t\t\tr.emplace_back(a);\n\t}\n\tsort(all(r));\n\tdump(r);\n\tint w[128];\n\trep(i, 0, ch.size())w[ch[i]] = r[i];\n\tMinimumCostFlow mcf(N + N + 2);\n\tint s = mcf.n - 2, t = s + 1;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tmcf.addArc(i, N + j, 1, w[c[i][j]]);\n\t\t}\n\t}\n\trep(i, 0, N) {\n\t\tmcf.addArc(s, i, 1, 0);\n\t\tmcf.addArc(N + i, t, 1, 0);\n\t}\n\tmcf.minimumCostFlow(s, t, N);\n\tvector<char> ans;\n\trep(i, 0, N) {\n\t\trep(j, 0, N) {\n\t\t\tif (mcf.g[i][j].cap == 0)\n\t\t\t\tans.emplace_back(c[i][j]);\n\t\t}\n\t}\n\tsort(all(ans));\n\trep(i, 0, ans.size())\n\t\tcout << ans[i];\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <utility>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef vector<int> vi;\ntypedef pair<vi,int> P;\nstruct edge {\n\tint to,cap;\n\tvi cost;\n\tint rev;\n};\nconst int MAX_V=102;\nint V;\nvector<edge> G[MAX_V];\nvi h[MAX_V];\nvi dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\nvi zero(52,0),mx(52,53),vinf(52,200);\nvi operator +(const vi &l,const vi &r){\n\tvi ret=l;\n\trep(i,52) ret[i]+=r[i];\n\treturn ret;\n}\nvi operator -(const vi &l,const vi &r){\n\tvi ret=l;\n\trep(i,52) ret[i]-=r[i];\n\treturn ret;\n}\nvi operator*(const int &l,const vi &r){\n\tvi ret=r;\n\trep(i,52) ret[i]+=l;\n\treturn ret;\n}\nvi operator -(const vi &l){\n\tvi ret=l;\n\trep(i,52) ret[i]=-ret[i];\n\treturn ret;\n}\nvoid add_edge(int from, int to, int cap, vi cost){\n\tedge e1={to,cap,cost,G[to].size()},e2={from,0,-cost,G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid min_cost_flow(int s, int t, int f){\n\tvi res=zero;\n\tfill(h,h+V,zero);\n\twhile(f>0){\n\t\tpriority_queue< P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,vinf);\n\t\tdist[s]=zero;\n\t\tque.push(P(zero,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first) continue;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tif(dist[t]==vinf) return -1;\n\t\tfor(int v=0;v<V;v++) h[v]=h[v]+dist[v];\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres=res+d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n}\nvi tovi(int x){\n\tvi ret(52,0);\n\tret[x]++;\n\treturn ret;\n}\nint toint(vi vv){\n\trep(i,52) if(vv[i]==52) return i;\n\tassert(false);\n}\nint num(char c){\n\tif('A'<=c&&c<='Z') return c-'A';\n\treturn c-'a'+26;\n}\nchar denum(int num){\n\tif(num<26) return 'A'+num;\n\treturn 'a'+(num-26);\n}\nint main(){\n\tint N;\n\tcin>>N;\n\tstring st[50];\n\trep(i,N) cin>>st[i];\n\trep(i,N){\n\t\trep(j,N){\n\t\t\tadd_edge(i,j+N,1,mx-tovi(num(st[i][j])));\n\t\t}\n\t}\n\tint s=2*N,t=2*N+1;\n\tV=2*N+2;\n\trep(i,N) add_edge(s,i,1,zero);\n\trep(i,N) add_edge(N+i,t,1,zero);\n\tstring ans;\n\tmin_cost_flow(s,t,N);\n\trep(i,N){\n\t\tfor(edge e:G[i]){\n\t\t\tif(e.cap==0) ans.pb(denum(toint(e.cost)));\n\t\t}\n\t}\n\tsort(all(ans));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> add(vector<int> a,vector<int> b){\n  vector<int> res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=a[i]+b[i];\n  return res;\n}\n\nvector<int> sub(vector<int> a){\n  vector<int> res(a.size());\n  for(int i=0;i<(int)a.size();i++)\n    res[i]=-a[i];\n  return res;\n}\n\n\nint change(char ch){\n  int res;\n  if('A'<=ch&&ch<='Z'){\n    res= ch-'A';\n  }else{\n    res= 26+ch-'a';\n  }\n  return 59-res;\n}\n\nint N;\nlong double po[60];\nchar mp[50][50];\nint t[50][50];\n\nstruct edge{\n  int to;\n  int cap;\n  vector<int> cost;\n  int rev;\n\n  edge( int a,int b, vector<int> c,int d){\n    to=a;\n    cap=b;\n    cost=c;\n    rev=d;\n  }\n};\n\n#define MAX_V (105)\n\nvector<edge> G[MAX_V];\nvector<int> h[MAX_V];\nvector<int> dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,vector<int> cost){\n  G[from].push_back( edge(to,cap,cost,G[to].size() ) );\n  G[to].push_back(   edge(from,0, sub(cost) ,G[from].size()-1 ) );\n}\n\ntypedef pair< vector<int> , int > P;\n\nvoid min_cost_flow(int s,int t,int f){\n  fill( h, h+MAX_V, vector<int>(60,0) );\n  while(f>0){\n    priority_queue< P , vector<P> , greater<P> > Q;\n    fill(dist,dist+MAX_V, vector<int>(60,1e8) );\n    dist[s]= vector<int>(60,0);\n    Q.push(P( dist[s] ,s));\n    while(!Q.empty()){\n      P p=Q.top();Q.pop();\n      int v=p.second;\n      if(dist[v]<p.first)continue;\n      \n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap>0){\n\n          vector<int> tmp = add(dist[v],e.cost);\n          tmp=add(tmp,h[v]);\n          vector<int> tmp2 = sub(h[e.to]);\n          tmp = add(tmp, tmp2);\n          \n          if(dist[e.to]>tmp){\n            dist[e.to]=tmp;\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            Q.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n    }\n\n    \n    for(int v=0;v<MAX_V;v++)h[v]=add(h[v],dist[v]);\n    \n    \n    int d=f;\n    for(int v=t;v!=s;v=prevv[v])\n      d=min(d,(int)G[prevv[v]][preve[v]].cap);\n    f-=d;\n        \n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e=G[prevv[v]][preve[v]];\n      e.cap-=d;\n      G[v][e.rev].cap+=d;\n    }\n  }\n\n}\n\nint main(){\n  \n  cin>>N;\n  int si=N+N;\n  int ti=N+N+1;\n\n  map< char , int > cnt;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      char ch;\n      cin>>ch;\n      cnt[ change(ch) ]++;\n      mp[i][j]=ch;\n    }\n  }\n\n    \n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      t[i][j]=G[i].size();\n      vector<int> tmp(60,0);\n      tmp[ change(mp[i][j]) ] =  1;\n      add_edge(i,N+j,1,tmp);\n    }\n  }\n\n  for(int i=0;i<N;i++){\n    vector<int> tmp(60,0);\n    add_edge(si,i,1,tmp);\n    add_edge(N+i,ti,1,tmp);\n  }\n\n  min_cost_flow(si,ti,N);\n\n  string ans=\"\";\n  for(int i=0;i<N;i++){\n    for(int j=0;j<N;j++){\n      edge e=G[i][ t[i][j] ];\n      if(e.cap==0)ans+=mp[i][j];\n    }\n  }\n  sort(ans.begin(),ans.end());\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 500\n#define INF (1e9)\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint MAXC;\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  \n  int n;\n  cin>>n;\n\n  V=n*2+2;\n\n  string str;\n  \n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<n;j++)\n      add_edge(i,j+n,1,(int)str[j]);\n  }\n\n  int s=n*2,t=s+1;\n\n  for(int i=0;i<n;i++)\n    add_edge(s,i,1,0);\n  \n  for(int i=0;i<n;i++)\n    add_edge(i+n,t,1,0);\n  \n  MAXC='A';\n  while(1){\n    int r=min_cost_flow(s,t,n);\n    if(r!=-1)break;\n    else min_cost_flow(t,s,n);\n    MAXC++;\n  }\n  \n  string ans;\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++)\n      if(!G[i][j].cap)ans+=(char)G[i][j].cost;\n  \n  sort(ans.begin(),ans.end());\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint V;\nvector<int> G[102];\nint match[102];\nbool used[102];\n\nvoid init(int v){\n  V=v;\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0; i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_match(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0; v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n\nint N;\nstring s[55];\nmap<char,vector<P> > query;\nbool dame[102];\n\nint main(){\n  cin>>N;\n  rep(i,N)cin>>s[i];\n  rep(i,N){\n    rep(j,N){\n      query[s[i][j]].push_back(P(i,j));\n    }\n  }\n\n  string res;\n  int mx=0,pre=0;\n  init(2*N);\n  for(auto it : query){\n    for(P p : it.se){\n      if(!dame[p.fi]&&!dame[p.se+N])add_edge(p.fi,p.se+N);\n    }\n    mx=bipartite_match();\n    rep(i,mx-pre)res+=it.fi;\n    pre=mx;\n    rep(i,N*2){\n      if(match[i]!=-1)dame[i]=true;\n    }\n  }\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n\n// weight vector of each character\n// A-Z(26) and a-z(26)\nstruct weight\n{\n  vector<int> val;\n\n  // constructors\n  weight():val(52, 0){}\n  weight(int ini):val(52, ini){}\n  weight(vector<int> ini):val(ini){}\n\n  // arithmetic\n  // binary\n  weight operator + (weight r) {\n    vector<int> ret(52);\n    for(int i = 0; i < 52; i++) ret[i] = val[i] + r.val[i];\n    return weight(ret);\n  }\n  weight operator - (weight r) {\n    vector<int> ret(52);\n    for(int i = 0; i < 52; i++) ret[i] = val[i] - r.val[i];\n    return weight(ret);\n  }\n  weight operator * (int k) {\n    vector<int> ret(52);\n    for(int i = 0; i < 52; i++) ret[i] = val[i] * k;\n    return weight(ret);\n  }\n  // unary\n  weight& operator - () {\n    for(int i = 0; i < 52; i++) val[i] = -val[i];\n    return *this;\n  }\n\n  \n  // comparison\n  bool operator == (const weight& r) const {\n    return val == r.val;\n  }\n  bool operator < (const weight& r) const {\n    return val < r.val;\n  }\n\n  // assignment\n  weight& operator += (const weight& r) {\n    for(int i = 0; i < 52; i++) val[i] += r.val[i];\n    return *this;\n  }\n};\nusing P = pair<weight, int>;\n\nconst weight inf = weight(1LL << 55);\nconst weight zero = weight(0);\n\n// Sccessive Shortest Path(Primal Dual): minimum cost maximum flow\nstruct PrimalDual\n{\n  struct edge\n  {\n    int to, cap, rev;\n    weight cost;\n    edge(){}\n    edge(int to, int cap, weight cost, int rev):to(to), cap(cap), cost(cost), rev(rev){}\n  };\n\n  vector< vector<edge> > graph;\n  vector<weight> mincost;\n  \n  PrimalDual(int V):graph(V), mincost(V){}\n  void add_edge(int s, int t, int cap, weight cost)\n  {\n    graph[s].emplace_back(t, cap, cost, graph[t].size());\n    graph[t].emplace_back(s, 0, -cost, graph[s].size()-1);\n  }\n  weight min_cost_flow(int s, int t, int f)\n  {\n    weight ret = zero;\n    vector<weight> h(graph.size(), zero);\n    vector<int> pv(graph.size(), -1);\n    vector<int> pe(graph.size(), -1);\n\n    while(f > 0) {\n     priority_queue< P, vector<P>, greater<P> > que;\n      fill(all(mincost), inf);\n      mincost[s] = zero;\n      que.push(P(zero, s));\n      \n      while(!que.empty()) {\n\tP p = que.top(); que.pop();\n\tint v = p.second;\n\tif(mincost[v] < p.first) continue;\n\tfor(int i = 0; i < graph[v].size(); i++) {\n\t  edge &e = graph[v][i];\n\t  weight cost = mincost[v] + e.cost + h[v] - h[e.to];\n\t  if(e.cap > 0 && cost < mincost[e.to]) {\n\t    mincost[e.to] = cost;\n\t    pv[e.to] = v, pe[e.to] = i;\n\t    que.push(P(mincost[e.to], e.to));\n\t  }\n\t}\n      }\n\n      if(mincost[t] == inf) return weight(-1);\n\n      for(int i = 0; i < graph.size(); i++) h[i] += mincost[i];\n      int d = f;\n      for(int v = t; v != s; v = pv[v]) d = min(d, graph[pv[v]][pe[v]].cap);\n      f -= d;\n      ret += h[t] * d;\n      for(int v = t; v != s; v = pv[v]) {\n\tedge& e = graph[pv[v]][pe[v]];\n\te.cap -= d;\n\tgraph[v][e.rev].cap += d;\n      }\n    }\n\n    return ret;\n  }\n};\n\nconst string a = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyxz\";\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N; cin >> N;\n  int s = 2*N, t = s + 1;\n\n  PrimalDual graph(t + 1);\n\n  for(int i = 0; i < N; i++) {\n    graph.add_edge(s, i, 1, zero);\n    graph.add_edge(N + i, t, 1, zero);\n  }\n  \n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      char c; cin >> c;\n      weight w; w.val[a.find(c)] = -1;\n      graph.add_edge(i, N + j, 1, w);\n    }\n  }\n\n  weight mcf = graph.min_cost_flow(s, t, N);\n  for(int i = 0; i < 52; i++) {\n    for(int j = 0; j < -mcf.val[i]; j++) cout << a[i];\n  }\n  cout << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<vector>\n#include<map>\n#include<stack>\n#include<string>\n#include<bitset>\n#define LL long long\n\nconst int MAXN=107;\nconst int MAXM=0;\nconst long long LLINF=9000000000000000000;\nconst long double INF=1e233;//careful because of floyed and so on\nconst int MOD=1000000007;\ndouble eps=0.00000001;\n\nusing namespace std;\n\nint n;\nchar s[MAXN][MAXN];\nlong double v[MAXN];\n\nlong double w[MAXN][MAXN];\nlong double lx[MAXN],ly[MAXN]; //??\nint linky[MAXN];\nbool visx[MAXN],visy[MAXN];\nlong double slack[MAXN];\nbool find(int x)\n{\n    visx[x] = true;\n    for(int y = 1; y <=n; y++)\n    {\n        if(visy[y])   continue;\n        int t = lx[x] + ly[y] - w[x][y];\n        if(t==0)\n        {\n            visy[y] = true;\n            if(linky[y] == -1 || find(linky[y]))\n            {\n                linky[y] = x;\n                return true;\n            }\n        }\n        else if(slack[y] > t)      slack[y] = t;\n    }\n    return false;\n}\n\nint KM()\n{\n    int i,j;\n\n    memset(linky,-1,sizeof(linky));\n    memset(ly,0,sizeof(ly));\n\n    for(i = 1; i <=n; i++)           //初始化??\n    {\n         lx[i] = -INF;\n         for(j = 1; j <=n; j++)\n         {\n            if(w[i][j] > lx[i])   lx[i] = w[i][j];\n         }\n    }\n\n    for(int x = 1; x <=n; x++)\n    {\n        for(i = 1; i <=n; i++)   slack[i] = INF;\n        while(true)\n        {\n            memset(visx,0,sizeof(visx));\n            memset(visy,0,sizeof(visy));\n            if(find(x))  break;\n            double d = INF;\n\n            for(i = 1; i <=n; i++)\n            {\n                if(!visy[i] && d > slack[i])    d = slack[i];\n            }\n            for(i = 1; i <=n; i++)\n            {\n                if(visx[i])    lx[i] -= d;\n            }\n            for(i = 1; i <=n; i++)\n            {\n                if(visy[i])    ly[i] += d;\n                else           slack[i] -= d;\n            }\n        }\n    }\n\n    int result = 0;\n    for(i = 1; i <=n; i++)\n    {\n        if(linky[i]>-1)\n        {\n            result += w[linky[i]][i];\n        }\n    }\n\n    return result;\n}\n\nint main(){\n    v[51]=1;\n    for (int i=50;i>=0;i--){\n        v[i]=v[i+1]*50;\n    }\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++){\n        scanf(\"%s\",s[i]+1);\n        for (int j=1;j<=n;j++){\n            if (s[i][j]>='A' && s[i][j]<='Z') w[i][j]=v[s[i][j]-'A'];\n            if (s[i][j]>='a' && s[i][j]<='z') w[i][j]=v[s[i][j]-'a'+26];\n        }\n    }\n    KM();\n    vector<char>ans;\n    for (int i=1;i<=n;i++){\n        ans.push_back(s[linky[i]][i]);\n    }\n    sort(ans.begin(),ans.end());\n    for (int i=0;i<(int)ans.size();i++){\n        printf(\"%c\",ans[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 500\n#define INF (1e9)\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{int to, cap,cost,rev;};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nint dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    fill(dist,dist+V,INF);\n    dist[s]=0;\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  if(e.cap > 0 && dist[e.to] > dist[v]+e.cost) {\n\t    dist[e.to] = dist[v] + e.cost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1; //????????\\??????????????????\n    \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res += d*dist[t];\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  \n  int n;\n  cin>>n;\n\n  V=n*2+2;\n\n  string str;\n  \n  for(int i=0;i<n;i++){\n    cin>>str;\n    for(int j=0;j<n;j++)\n      add_edge(i,j+n,1,(int)str[j]);\n  }\n\n  int s=n*2,t=s+1;\n\n  for(int i=0;i<n;i++)\n    add_edge(s,i,1,0);\n  \n  for(int i=0;i<n;i++)\n    add_edge(i+n,t,1,0);\n\n  min_cost_flow(s,t,INF);\n  \n  string ans;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++)\n      if(!G[i][j].cap)ans+=(char)G[i][j].cost;\n  \n  sort(ans.begin(),ans.end());\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define MAX_N 1000\nusing namespace std;\n\nstruct edge{int to, cap,cost,rev;};\nint V;\nvector<edge> G[MAX_V];\nvector<int> dist[MAX_V];\nconst vector<int> INF(1<<8,1000);\nint prevv[MAX_V],preve[MAX_V];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  G[to].push_back((edge){from,0,-cost,G[from].size()-1});\n}\n\nint min_cost_flow(int s,int t,int f){\n  while(f>0){\n    for(int i=0;i<V;i++) dist[i]=INF;\n    dist[s]=vector<int>(1<<8,0);\n\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==INF) continue;\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  vector<int> ncost=dist[v];\n\t  if(e.cost!=0)ncost[abs(e.cost)]+=e.cost/abs(e.cost);\n\t  \n\t  if(e.cap > 0 && dist[e.to] > ncost){\n\t    dist[e.to] = ncost;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n    if(dist[t]==INF) return -1;    \n\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return 1;\n}\n\n\nint can[MAX_N][MAX_N];\nint Biparite_Matching(int N,int K){\n  int s = N+K, t = s+1;\n  for(int i=0; i<N; i++) add_edge(s,i,1,0);\n  for(int i=0; i<K; i++) add_edge(N+i,t,1,0);\n\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)add_edge(i, N+j,1,can[i][j]);\n  V=N+K+2;\n  return min_cost_flow(s,t,N);\n}\n\n\n\nint main(){\n  int n;\n  cin>>n;\n  string mp[51];\n  for(int i=0;i<n;i++)cin>>mp[i];\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)can[i][j] = -mp[i][j];\n\n  Biparite_Matching(n,n);\n  string ans;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<G[i].size();j++)\n      if(G[i][j].cap==0) ans+=mp[i][G[i][j].to-n];\n  sort(ans.begin(),ans.end());\n\n  cout<<ans<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 100000\n#define INF 1e9\nusing namespace std;\n\n/*????°??????¨???(???????????£????????????????????¨) O(F|V||E|)*/\n\n//????????¨????§???????(???????????????????????????????????????)\nstruct edge{\n  int to, cap,rev;\n  string cost;\n  edge(){};\n  edge(int a,int b,string c,int d){\n    to=a, cap=b, cost=c, rev=d;\n  };\n};\nint V;                         //????????°\nvector<edge> G[MAX_V];         //??°???????????£??\\???????????¨???\nstring dist[MAX_V];               //???????????¢\nint prevv[MAX_V],preve[MAX_V]; //??´??????????????¨???\n\n// from??????to??????????????????cap????????????cost???????????°????????????????????????\nvoid add_edge(int from,int to,int cap,string cost){\n  G[from].push_back((edge){to,cap,cost,G[to].size()});\n  string C=cost;\n  if(cost.size())C+=\"{\";\n  G[to].push_back((edge){from,0,C,G[from].size()-1});\n}\n\n//s??????t????????????f???????°??????¨???????±???????\n//??????????????´???-1?????????\nstring min_cost_flow(int s,int t,int f){\n  \n  string res;\n  \n  while(f>0){\n    //????????????????????????????????????,s-t????????????????±???????\n    for(int i=0;i<V;i++) dist[i]=\"{\";\n    dist[s]=\"\";\n    bool update = true;\n    while(update){\n      update = false;\n      for(int v=0; v<V ;v++){\n\tif(dist[v]==\"{\") continue;\n\n\tfor(int i=0; i<G[v].size(); i++){\n\t  edge &e = G[v][i];\n\t  \n\t  string str;\n\t  \n\t  if(e.cost.size()==2){\n\t    \n\t    string tmp;\n\t    int f=0;\n\t    for(int j=0;j<dist[v].size();j++){\n\t      if(!f&&dist[v][j]==e.cost[0]){\n\t\tf=1;\n\t\tcontinue;\n\t      }\n\t      tmp+=dist[v][j];\n\t    }\n\t    if(!f)continue;\n\t    str=tmp;\n\t    \n\t  }else str=dist[v]+e.cost;\n\t  \n\t  sort(str.begin(),str.end());\n\t  \n\t  if(e.cap > 0 && dist[e.to] > str){\n\t    dist[e.to] = str;\n\t    prevv[e.to] = v;\n\t    preve[e.to] = i;\n\t    update = true;\n\t  }\n\t}\n      }\n    }\n        \n    //s???t?????????????????£??????????????????\n    int d = f;\n    for(int v=t; v!=s; v=prevv[v])d=min(d,G[prevv[v]][preve[v]].cap);\n    f -= d;\n    res+=dist[t];\n\n    for(int v=t; v!=s; v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  \n  return res;\n}\n\nint main(){\n  \n  int n;\n  cin>>n;\n  \n  int S=n*2,T=S+1;\n\n  for(int i=0;i<n;i++){\n    \n    string s;\n    cin>>s;\n    \n    for(int j=0;j<n;j++){\n      string t;\n      t+=s[j];\n      add_edge(i,j+n,1,t);\n    }\n  }\n\n  for(int i=0;i<n;i++){\n    add_edge(S,i,1,\"\");\n    add_edge(i+n,T,1,\"\");\n  }\n  \n  V=n*2+2;\n  \n  cout<<min_cost_flow(S,T,n)<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\nconst int MAXN = 300;\nconst int MAXM = 20000;\nclass BigNum {\n  public:\n    int a[52] = {0};\n    BigNum operator-() {\n        BigNum res;\n        for (int i = 0; i < 52; ++i) {\n            res.a[i] = -a[i];\n        }\n        return res;\n    }\n    BigNum operator+(const BigNum &X) const {\n        BigNum res;\n        for (int i = 0; i < 52; ++i) {\n            res.a[i] = a[i] + X.a[i];\n        }\n        return res;\n    }\n    bool operator>(const BigNum &X) const {\n        for (int i = 0; i < 52; ++i) {\n            if (a[i] == X.a[i])\n                continue;\n            return a[i] > X.a[i];\n        }\n        return 0;\n    }\n};\nBigNum Get(char c) {\n    BigNum res;\n    if (c == '#')\n        return res;\n    if (c <= 'Z') {\n        res.a['Z' - c + 26] = 1;\n        return res;\n    }\n    res.a['z' - c] = 1;\n    return res;\n}\nstruct Edge {\n    int to, next, cap, flow;\n    BigNum cost;\n    int x, y;\n} edge[MAXM];\nint head[MAXN], tol;\nint pre[MAXN];\nBigNum dis[MAXN];\nbool vis[MAXN];\nint N, M;\nvoid init() {\n    N = MAXN;\n    tol = 0;\n    memset(head, -1, sizeof(head));\n}\nvoid addedge(int u, int v, int cap, char cost) //左端点，右端点，容量，花?\n{\n    edge[tol].to = v;\n    edge[tol].cap = cap;\n    edge[tol].cost = Get(cost);\n    edge[tol].flow = 0;\n    edge[tol].next = head[u];\n    head[u] = tol++;\n    edge[tol].to = u;\n    edge[tol].cap = 0;\n    edge[tol].cost = -Get(cost);\n    edge[tol].flow = 0;\n    edge[tol].next = head[v];\n    head[v] = tol++;\n}\nbool spfa(int s, int t) {\n    queue<int> q;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 52; ++j) {\n            dis[i].a[j] = 100;\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        vis[i] = false;\n        pre[i] = -1;\n    }\n    for (int i = 0; i < 52; ++i) {\n        dis[s].a[i] = 0;\n    }\n    vis[s] = true;\n    q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        vis[u] = false;\n        for (int i = head[u]; i != -1; i = edge[i].next) {\n            int v = edge[i].to;\n            if (edge[i].cap > edge[i].flow && dis[v] > dis[u] + edge[i].cost) {\n                dis[v] = dis[u] + edge[i].cost;\n                pre[v] = i;\n                if (!vis[v]) {\n                    vis[v] = true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    if (pre[t] == -1)\n        return false;\n    else\n        return true;\n}\n//返回的是最大流， cost存的是最小?用\nvoid minCostMaxflow(int s, int t, BigNum &cost) {\n    while (spfa(s, t)) {\n        for (int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to]) {\n            edge[i].flow++;\n            edge[i ^ 1].flow--;\n            cost = cost + edge[i].cost;\n        }\n    }\n}\nvoid solve() {\n    init();\n    int n;\n    char s[100];\n    scanf(\"%d\", &n);\n    int S = n + n;\n    int T = S + 1;\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%s\", s);\n        for (int j = 0; j < n; ++j) {\n            addedge(i, j + n, 1, s[j]);\n        }\n        addedge(S, i, 1, '#');\n        addedge(i + n, T, 1, '#');\n    }\n    BigNum res;\n    minCostMaxflow(S, T, res);\n    for (int i = 51; i >= 0; --i) {\n        for (int j = 0; j < res.a[i]; ++j) {\n            if (i < 26) {\n                cout << (char)('z' - i);\n            } else {\n                cout << (char)('Z' - i + 26);\n            }\n        }\n    }\n    cout << endl;\n}\nint main() {\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 50\nusing namespace std;\ntypedef pair<char,string> P;\ntypedef pair<int,int> P1;\n\nint n;\nstring s[N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\n\nvoid solve(){\n  string ans;\n  \n  while(n){\n    \n    map<P,vector<P1> > memo;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\n\tstring str;\n\t\n\tfor(int k=0;k<4;k++){\n\t  \n\t  int ny=i+dy[k],nx=j+dx[k];\n\t  \n\t  while(1){\n\t    \n\t    if(ny<0||nx<0||ny<=n||nx<=n)break;\n\t    \n\t    str+=s[i][j];\n\t    \n\t    ny+=dy[k],nx+=dx[k];\n\t  }\n\t  \n\t}\n\n\tsort(str.begin(),str.end());\n\t\n\tmemo[P(s[i][j],str)].push_back(P1(i,j));\n      }\n    }\n    \n        \n    map<P,vector<P1> >::iterator ite=memo.begin();\n    \n    int y,x;\n    char minc=(*ite).first.first;\n    \n    ans+=minc;\n    \n    while(ite!=memo.end()){\n      \n      if(minc<(*ite).first.first)break;\n      else y=(*ite).second[0].first,x=(*ite).second[0].second;\n      \n      ite++;\n    }\n    \n    string t[N];\n    int idx=0;\n    \n    for(int i=0;i<n;i++){\n      if(y==i)continue;\n      for(int j=0;j<n;j++){\n\t\n\tif(x==j)continue;\n\t\n\tt[idx]+=s[i][j];\n      }\n      idx++;\n    }\n    \n    n--;\n\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)s[i][j]=t[i][j];\n\n  }\n\n  cout<<ans<<endl;\n}\n\nint main(){\n  \n  cin>>n;\n  \n  for(int i=0;i<n;i++)cin>>s[i];\n\n  solve();\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int wint;\nstruct cint{\n\tint num[55];\n\tcint(){for(int i=0;i<55;i++)num[i]=0;}\n\tcint operator+(const cint &a){\n\t\tcint ret;\n\t\tfor(int i=0;i<55;i++)ret.num[i]=num[i]+a.num[i];\n\t\treturn ret;\n\t}\n\tcint operator-(const cint &a){\n\t\tcint ret;\n\t\tfor(int i=0;i<55;i++)ret.num[i]=num[i]-a.num[i];\n\t\treturn ret;\n\t}\n\tcint operator-(){\n\t\tcint ret;\n\t\tfor(int i=0;i<55;i++)ret.num[i]=-num[i];\n\t\treturn ret;\n\t}\n\tcint operator*(const int &k){\n\t\tcint ret;\n\t\tfor(int i=0;i<55;i++)ret.num[i]=num[i]*k;\n\t\treturn ret;\n\t}\n};\ninline bool operator<(const cint &a,const cint &b){\n\tfor(int i=0;i<55;i++){\n\t\tif(a.num[i]!=b.num[i])return a.num[i]<b.num[i];\n\t}\n\treturn false;\n}\nnamespace MCF{\n\t#define MAXN 1000\n\t#define MAXM 100000\n\tconst wint wEPS=0;\n\tconst wint wINF=1001001001;\n\tconst cint cEPS;\n\tcint cINF;\n\tint n,m,ptr[MAXN],next[MAXM],zu[MAXM];\n\twint capa[MAXM],tof;\n\tcint cost[MAXM],toc,d[MAXN],pot[MAXN];\n\tint vis[MAXN],pree[MAXN];\n\tvoid init(int _n){\n\t\tcINF.num[0]=100000;\n\t\tn=_n;m=0;memset(ptr,~0,n*4);\n\t}\n\tvoid ae(int u,int v,wint w,cint c){\n\t\tnext[m]=ptr[u];ptr[u]=m;zu[m]=v;capa[m]=w;cost[m]=c;++m;\n\t\tnext[m]=ptr[v];ptr[v]=m;zu[m]=u;capa[m]=0;cost[m]=-c;++m;\n\t}\n\tbool solve(int src,int ink,wint flo=wINF){\n\t\tint i,u,v;\n\t\twint f;\n\t\tcint c,cc;\n\t\tmemset(pot,0,n*sizeof(cint));\n\t\tfor(bool cont=1;cont;){\n\t\t\tcont=0;\n\t\t\tfor(u=0;u<n;++u)for(i=ptr[u];~i;i=next[i])if(capa[i]>wEPS){\n\t\t\t\tif(pot[u]+cost[i]+cEPS<pot[zu[i]]){\n\t\t\t\t\tpot[zu[i]]=pot[u]+cost[i];cont=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(toc=cint(),tof=0;tof+wEPS<flo;){\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue<node,vector<node>,greater<node> >q;\n\t\t\tfor(u=0;u<n;++u){d[u]=cINF;vis[u]=0;}\n\t\t\tfor(q.push(make_pair(d[src]=cint(),src));!q.empty();){\n\t\t\t\tc=q.top().first;u=q.top().second;q.pop();\n\t\t\t\tif(vis[u]++)continue;\n\t\t\t\tfor(i=ptr[u];~i;i=next[i])if(capa[i]>wEPS){\n\t\t\t\t\tcc=c+cost[i]+pot[u]-pot[v=zu[i]];\n\t\t\t\t\tif(cc<d[v]){q.push(make_pair(d[v]=cc,v));pree[v]=i;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!vis[ink])return 0;\n\t\t\tf=flo-tof;\n\t\t\tfor(v=ink;v!=src;v=zu[i^1]){i=pree[v];f=min(f,capa[i]);}\n\t\t\tfor(v=ink;v!=src;v=zu[i^1]){i=pree[v];capa[i]-=f;capa[i^1]+=f;}\n\t\t\ttof+=f;\n\t\t\ttoc=toc+(d[ink]-pot[src]+pot[ink])*f;\n\t\t\tfor(u=0;u<n;++u)pot[u]=pot[u]+d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nchar str[100][100];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tMCF::init(a*2+2);\n\tint s=a*2;\n\tint t=a*2+1;\n\tfor(int i=0;i<a;i++){\n\t\tMCF::ae(s,i,1,cint());\n\t\tMCF::ae(a+i,t,1,cint());\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tcint val;\n\t\t\tif('A'<=str[i][j]&&str[i][j]<='Z')val.num[str[i][j]-'A']--;\n\t\t\telse val.num[str[i][j]-'a'+26]--;\n\t\t\tMCF::ae(i,a+j,1,val);\n\t\t}\n\t}\n\tMCF::solve(s,t,a);\n\tfor(int i=0;i<52;i++){\n\t\tfor(int j=0;j<-(MCF::toc.num[i]);j++){\n\t\t\tif(i<26)printf(\"%c\",'A'+i);\n\t\t\telse printf(\"%c\",'a'+i-26);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nvector<int> operator+(vector<int> l, vector<int> const& r) {\n    for(int i = 0; i < (int)l.size(); ++i) {\n        l[i] += r[i];\n    }\n    return l;\n}\nvector<int> operator-(vector<int> v) {\n    for(int i = 0; i < (int)v.size(); ++i) {\n        v[i] = -v[i];\n    }\n    return v;\n}\nvector<int> operator-(vector<int> l, vector<int> const& r) {\n    for(int i = 0; i < (int)l.size(); ++i) {\n        l[i] -= r[i];\n    }\n    return l;\n}\nvector<int> operator*(vector<int> v, int x) {\n    for(int i = 0; i < (int)v.size(); ++i) {\n        v[i] *= x;\n    }\n    return v;\n}\n\n\nusing weight = vector<int>;\n\nstruct edge {\n    int to, cap;\n    weight cost;\n    int rev;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, int cap, weight cost) {\n    g[from].push_back(edge{to, cap, cost, (int)g[to].size()});\n    g[to].push_back(edge{from, 0, -cost, (int)g[from].size()-1});\n}\n\nweight min_cost_flow(graph& g, int s, int t, int f) {\n    using P = pair<vector<int>, int>;\n\n    weight res(52);\n    std::vector<weight> h(g.size(), vector<int>(52));\n    std::vector<weight> dist(g.size());\n    std::vector<int> prevv(g.size()), preve(g.size());\n    while(f > 0) {\n        std::priority_queue<P, std::vector<P>, std::greater<P>> que;\n        std::fill(dist.begin(), dist.end(), vector<int>(52, INF));\n        dist[s] = vector<int>(52, 0);\n        que.push(P{dist[s], s});\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) {\n                continue;\n            }\n            for(int i = 0; i < (int)g[v].size(); ++i) {\n                edge& e = g[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P{dist[e.to], e.to});\n                }\n            }\n        }\n        if(dist[t][0] == INF) {\n            return vector<int>(52, -1);\n        }\n        for(int v=0; v<g.size(); ++v) {\n            h[v] = h[v] + dist[v];\n        }\n\n        int d = f;\n        for(int v = t; v != s; v = prevv[v]) {\n            d = min(d, g[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res = res + h[t] * d;\n        for(int v = t; v != s; v = prevv[v]) {\n            edge& e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\n\nint main() {\n    string const alphabets = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n    int N;\n    cin >> N;\n    vector<string> s(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> s[i];\n    }\n\n    graph g(N + N + 2);\n    int const source = N + N, sink = N + N + 1;\n    for(int i = 0; i < N; ++i) {\n        add_edge(g, source, i, 1, vector<int>(52, 0));\n        add_edge(g, i + N, sink, 1, vector<int>(52, 0));\n    }\n    for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n            vector<int> vec(52);\n            vec[alphabets.find(s[i][j])] = -1;\n            add_edge(g, i, j + N, 1, vec);\n        }\n    }\n\n    auto res = min_cost_flow(g, source, sink, N);\n    for(int i = 0; i < 52; ++i) {\n        cout << string(-res[i], alphabets[i]);\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2679 Decoding Ancient Messages\n// 2018.3.15 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { signed char a[52]; } T;\nT mx[10000]; int sz;\n#define mx_zero   0\n#define mx_inf    1\n\nint  mx_new() { return sz++; }\nvoid mx_clear(int a) { memset(mx+a, 0, sizeof(T)); }\nvoid mx_add1(int a, int b) { int i; for (i = 0; i < 52; i++) mx[a].a[i] += mx[b].a[i]; }\nvoid mx_add2(int s, int a, int b) { int i; for (i = 0; i < 52; i++) mx[s].a[i] = mx[a].a[i]+mx[b].a[i]; }\nvoid mx_sub1(int a, int b) { int i; for (i = 0; i < 52; i++) mx[a].a[i] -= mx[b].a[i]; }\nvoid mx_sub2(int d, int a, int b) { int i; for (i = 0; i < 52; i++) mx[d].a[i] = mx[a].a[i]-mx[b].a[i]; }\nvoid mx_mul2(int m, int a, int k) { int i; for (i = 0; i < 52; i++) mx[m].a[i] = mx[a].a[i] * k; }\nvoid mx_cpy(int a, int b) { memcpy(mx+a, mx+b, sizeof(T)); }\nint  mx_cmp(int a, int b) {\n\tint k, i; for (i = 0; i < 52; i++) if (k = mx[a].a[i] - mx[b].a[i]) return k; return 0; }\n\n#define MAX 105\ntypedef struct { int to, rev; int cap; int cost; } EDGE;\nEDGE edge[MAX][MAX]; int hi[MAX];\nint  V;\t\t\t\t// 頂点数\nint  dist[MAX], prevv[MAX], preve[MAX];\n\nvoid add_edge(int from, int to, int cap, int cost, int rcost)\n{\n\tint f, t;\n\tEDGE *e;\n\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = cap, e->cost = cost, e->rev = t;\n\te = &edge[to][t], e->to = from, e->cap = 0, e->cost = rcost, e->rev = f;\n}\n\nint minCostFlow(int S, int T, int F)\n{\n\tint i, v, nv, d, update;\n\tint t = mx_new(), ret;\n\tEDGE *e;\n\n\tfor (i = 0; i < V; i++) dist[i] = mx_new(); \n\tret = mx_new();\n\twhile (F > 0) {\n\t\tfor (v = 0; v < V; v++) mx_cpy(dist[v], mx_inf);\n\t\tmx_clear(dist[S]);\n\t\tdo {\n\t\t\tupdate = 0;\n\t\t\tfor (v = 0; v < V; v++) {\n\t\t\t\tif (mx_cmp(dist[v], mx_inf) == 0) continue;\n\t\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\t\te = &edge[v][i];\n\t\t\t\t\tif (e->cap <= 0) continue;\n\t\t\t\t\tnv = e->to;\n\t\t\t\t\tmx_add2(t, dist[v], e->cost);\n\t\t\t\t\tif (mx_cmp(dist[nv], t) > 0) {\n\t\t\t\t\t\tmx_cpy(dist[nv], t), prevv[nv] = v, preve[e->to] = i;\n\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (update);\n\n\t\td = F;\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\te = &edge[prevv[v]][preve[v]];\n\t\t\tif (d > e->cap) d = e->cap;\n\t\t}\n\t\tF -= d;\n\n\t\tmx_mul2(t, dist[T], d);\n\t\tmx_add1(ret, t);\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\te = &edge[prevv[v]][preve[v]];\n\t\t\te->cap -= d;\n\t\t\tedge[v][e->rev].cap += d;\n\t\t}\n\t}\n\treturn ret;\n}\n\nchar map[53][53];\n\nint main()\n{\n\tint N, i, j, a, b;\n\tint source, sink;\n\tchar buf[10], c;\n\n\tfgets(buf, 10, stdin), N = atoi(buf);\n\tfor (i = 0; i < N; i++) fgets(map[i], 53, stdin);\n\n\tfor (i = 0; i < 52; i++) mx[mx_inf].a[i] = 60;\n\tsz = 2,\tsource = N << 1, sink = source + 1, V = sink + 1;\n\n\tfor (i = 0; i < N; i++) {\n\t\tadd_edge(source, i, 1, mx_new(), mx_new());\n\t\tfor (j = 0; j < N; j++) {\n\t\t\tc = map[i][j], a = mx_new(), b = mx_new();\n\t\t\tif (c < 'a') mx[a].a[   c-'A'] = -1, mx[b].a[   c-'A'] = 1;\n\t\t\telse         mx[a].a[26+c-'a'] = -1, mx[b].a[26+c-'a'] = 1;\n\t\t\tadd_edge(i, N+j, 1, a, b);\n\t\t}\n\t\tadd_edge(N+i, sink, 1, mx_new(), mx_new());\n\t}\n\n\ta = minCostFlow(source, sink, N);\n\n\tfor (i = 0; i < 26; i++) {\n\t\tb = -mx[a].a[i];\n\t\twhile (b) putchar('A'+i), b--;\n\t}\n\tfor (i = 0; i < 26; i++) {\n\t\tb = -mx[a].a[i+26];\n\t\twhile (b) putchar('a'+i), b--;\n\t}\n\tputchar('\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "Ruby",
    "code": "P = 10000000\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** (a[i-1][j-1].ord - ?A.ord)\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do #min-cost flow by successive bellman-ford    \n    dist = [Float::INFINITY] * (2*n+2)\n    dist[0] = 0\n    prev_node = [nil] * (2*n+2)\n    (2*n+2).times do\n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2*n+1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2*n+1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Ruby",
    "code": "P = 1000000\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** (a[i-1][j-1].ord - ?A.ord)\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do #min-cost flow by successive bellman-ford    \n    dist = [Float::INFINITY] * (2*n+2)\n    dist[0] = 0\n    prev_node = [nil] * (2*n+2)\n    (2*n+1).times do\n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2*n+1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2*n+1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Ruby",
    "code": "P = 1000000\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** (a[i-1][j-1].ord - ?A.ord)\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do #min-cost flow by successive bellman-ford    \n    dist = [Float::INFINITY] * (2*n+2)\n    dist[0] = 0\n    prev_node = [nil] * (2*n+2)\n    (n-1).times do\n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2*n+1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2*n+1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Ruby",
    "code": "P = 1000\nalph = (?A..?Z).to_a + (?a..?z).to_a\ncode = Hash[*alph.zip((0..alph.size-1).to_a).flatten]\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** code[a[i-1][j-1]]\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do\n    dist = [Float::INFINITY] * (2*n+2)\n    dist[0] = 0\n    prev_node = [nil] * (2*n+2)\n    (2*n+1).times do\n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2*n+1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2*n+1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Ruby",
    "code": "P = 52\nalph = (?A..?Z).to_a + (?a..?z).to_a\ncode = Hash[*alph.zip((0..alph.size-1).to_a.reverse).flatten]\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** 52 - P ** code[a[i-1][j-1]]\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do\n    dist = [Float::INFINITY] * (2*n+2)\n    dist[0] = 0\n    prev_node = [nil] * (2*n+2)\n    (2*n+1).times do\n        change = false\n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                change = true\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n        break unless change\n    end\n    path = [2*n+1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2*n+1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Ruby",
    "code": "P = 100\nalph = (?A..?Z).to_a + (?a..?z).to_a\ncode = Hash[*alph.zip((0..alph.size-1).to_a.reverse).flatten]\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** 52 - P ** code[a[i-1][j-1]]\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do\n    dist = [Float::INFINITY] * (2*n+2)\n    dist[0] = 0\n    prev_node = [nil] * (2*n+2)\n    (2*n+2).times do\n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2*n+1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2*n+1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** (a[i-1][j-1].ord - ?A.ord)\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do #min-cost flow by successive bellman-ford    \n    dist = [Float::INFINITY] * (2*n+2)\n    dist[0] = 0\n    prev_node = [nil] * (2*n+2)\n    (n-1).times do\n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2*n+1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2*n+1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Ruby",
    "code": "P = 1000\nalph = (?A..?Z).to_a + (?a..?z).to_a\ncode = Hash[*alph.zip((0..alph.size-1).to_a).flatten]\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** code[a[i-1][j-1]]\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do\n    dist = [Float::INFINITY] * (2*n+2)\n    dist[0] = 0\n    prev_node = [nil] * (2*n+2)\n    (2*n+1).times do\n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2*n+1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2*n+1}.map {|j, i| a[i-1][j-n-1]}.sort_by(&:ord).join"
  },
  {
    "language": "Ruby",
    "code": "P = 10000\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** (a[i-1][j-1].ord - ?A.ord)\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do #min-cost flow by successive bellman-ford    \n    dist = [Float::INFINITY] * (2 * n + 2)\n    dist[0] = 0 \n    prev_node = [nil] * (2 * n + 2)\n    (n-1).times do \n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2 * n + 1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2 * n + 1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Ruby",
    "code": "P = 10000000\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** (a[i-1][j-1].ord - ?A.ord)\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do #min-cost flow by successive bellman-ford    \n    dist = [Float::INFINITY] * (2*n+2)\n    dist[0] = 0\n    prev_node = [nil] * (2*n+2)\n    (2*n+1).times do\n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2*n+1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2*n+1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Ruby",
    "code": "P = 100\n\nn = gets.to_i\na = $<.map {|l| l.chomp.split(\"\")}\nedges = {}\n(1..n).each do |i|\n    edges[[0, i]] = 0\n    (1..n).each do |j|\n        edges[[i, n+j]] = P ** (a[i-1][j-1].ord - ?A.ord)\n    end\n    edges[[n+i, 2*n+1]] = 0\nend\n\nn.times do #min-cost flow by successive bellman-ford    \n    dist = [Float::INFINITY] * (2 * n + 2)\n    dist[0] = 0 \n    prev_node = [nil] * (2 * n + 2)\n    (n-1).times do \n        edges.each do |(i, j), len|\n            d = dist[i] + len\n            if d < dist[j]\n                dist[j] = d\n                prev_node[j] = i\n            end\n        end\n    end\n    path = [2 * n + 1]\n    path << prev_node[path[-1]] while prev_node[path[-1]]\n    path.each_cons(2) do |i, j|\n        c = edges[[j, i]]\n        edges.delete([j, i])\n        edges[[i, j]] = -c\n    end\nend\n\nputs edges.keys.select {|i, j| i > j && j != 0 && i != 2 * n + 1}.map {|j, i| a[i-1][j-n-1]}.sort.join"
  },
  {
    "language": "Python",
    "code": "import heapq\n\nclass edge:\n    def __init__(self,to,cap,cost,rev):\n        self.to = to\n        self.cap = cap\n        self.cost = cost\n        self.rev = rev\n\nclass min_cost_flow:\n    INF = 52**60\n    def __init__(self, n):\n        self.V = n\n        self.G = [[] for _ in range(n)]\n        self.h = [0 for _ in range(n)]\n        self.dist = [0 for _ in range(n)]\n\n    def add_edge(self, f, t, cap, cost):\n        self.G[f].append(edge(t,cap,cost,len(self.G[t])))\n        self.G[t].append(edge(f,0,-cost,len(self.G[f])-1))\n\n    def min_cost_flow(self, s, t, f):\n        prevv = [0 for _ in range(self.V)]\n        preve = [0 for _ in range(self.V)]\n\n        res = 0\n        self.h = [0 for _ in range(self.V)]\n        while f > 0:\n            pq = []\n            self.dist = [min_cost_flow.INF for _ in range(self.V)]\n            self.dist[s] = 0\n            # dijkstra\n            heapq.heappush(pq,(0,s))\n            while len(pq) != 0:\n                p = heapq.heappop(pq)\n                v = p[1]\n                if p[0] > self.dist[v]:\n                    continue\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    if e.cap>0 and self.dist[e.to]>self.dist[v]+e.cost+self.h[v]-self.h[e.to]:\n                        self.dist[e.to] =  self.dist[v]+e.cost+self.h[v]-self.h[e.to]\n                        prevv[e.to] = v\n                        preve[e.to] = i\n                        heapq.heappush(pq,(self.dist[e.to],e.to))\n\n            if self.dist[t] == min_cost_flow.INF:\n                return -1\n\n            for i in range(self.V):\n                self.h[i] += self.dist[i]\n\n            d = f\n            v = t\n            while v != s:\n                d = min(d,self.G[prevv[v]][preve[v]].cap)\n                v = prevv[v]\n            f -= d\n            res += d*self.h[t]\n\n            v = t\n            while v != s:\n                self.G[prevv[v]][preve[v]].cap -= d\n                self.G[v][self.G[prevv[v]][preve[v]].rev].cap += d\n                v = prevv[v]\n\n        return res\n\n    def solve(self,s,t,n,d):\n        f = self.min_cost_flow(s,t,n)\n        ans = []\n        for i in range(n):\n            for j in range(len(self.G[n+i])):\n                if self.G[n+i][j].cap>0:\n                    cost = -self.G[n+i][j].cost\n                    ans.append(d[cost])\n                    break\n        ans.sort()\n        return ''.join(ans)\n\ndef main():\n    n = int(input())\n    s = []\n    for _ in range(n):\n        s.append(input())\n\n    flow = min_cost_flow(2*n+2)\n    S,T = 2*n,2*n+1\n    X = 52**52\n\n    for i in range(n):\n        flow.add_edge(S,i,1,0)\n        flow.add_edge(n+i,T,1,0)\n\n    d = {}\n    for i in range(n):\n        for j in range(n):\n            cost = X\n            if 'A'<=s[i][j]<='Z':\n                cost -= 52**(51-(ord(s[i][j])-ord(('A'))))\n            else:\n                cost -= 52**(25-(ord(s[i][j])-ord(('a'))))\n            flow.add_edge(i,n+j,1,cost)\n            d[cost] = s[i][j]\n\n    print(flow.solve(S,T,n,d))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import heapq\n\nclass edge:\n    def __init__(self,to,cap,cost,rev):\n        self.to = to\n        self.cap = cap\n        self.cost = cost\n        self.rev = rev\n\nclass min_cost_flow:\n    INF = 52**60\n    def __init__(self, n):\n        self.V = n\n        self.G = [[] for _ in range(n)]\n        self.h = [0 for _ in range(n)]\n        self.dist = [0 for _ in range(n)]\n\n    def add_edge(self, f, t, cap, cost):\n        self.G[f].append(edge(t,cap,cost,len(self.G[t])))\n        self.G[t].append(edge(f,0,-cost,len(self.G[f])-1))\n\n    def min_cost_flow(self, s, t, f):\n        prevv = [0 for _ in range(self.V)]\n        preve = [0 for _ in range(self.V)]\n\n        res = 0\n        self.h = [0 for _ in range(self.V)]\n        while f > 0:\n            pq = []\n            self.dist = [min_cost_flow.INF for _ in range(self.V)]\n            self.dist[s] = 0\n            # dijkstra\n            heapq.heappush(pq,(0,s))\n            while len(pq) != 0:\n                p = heapq.heappop(pq)\n                v = p[1]\n                if p[0] > self.dist[v]:\n                    continue\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i]\n                    if e.cap>0 and self.dist[e.to]>self.dist[v]+e.cost+self.h[v]-self.h[e.to]:\n                        self.dist[e.to] =  self.dist[v]+e.cost+self.h[v]-self.h[e.to]\n                        prevv[e.to] = v\n                        preve[e.to] = i\n                        heapq.heappush(pq,(self.dist[e.to],e.to))\n\n            if self.dist[t] == min_cost_flow.INF:\n                return -1\n\n            for i in range(self.V):\n                self.h[i] += self.dist[i]\n\n            d = f\n            v = t\n            while v != s:\n                d = min(d,self.G[prevv[v]][preve[v]].cap)\n                v = prevv[v]\n            f -= d\n            res += d*self.h[t]\n\n            v = t\n            while v != s:\n                self.G[prevv[v]][preve[v]].cap -= d\n                self.G[v][self.G[prevv[v]][preve[v]].rev].cap += d\n                v = prevv[v]\n\n        return res\n\n    def solve(self,s,t,n,d):\n        f = self.min_cost_flow(s,t,n)\n        ans = []\n        for i in range(n):\n            for j in range(len(self.G[n+i])):\n                if self.G[n+i][j].cap>0:\n                    cost = -self.G[n+i][j].cost\n                    ans.append(d[cost])\n                    break\n        ans.sort()\n        return ''.join(ans)\n\ndef main():\n    n = int(input())\n    s = []\n    for _ in range(n):\n        s.append(input())\n\n    flow = min_cost_flow(2*n+2)\n    S,T = 2*n,2*n+1\n    X = 52**52\n\n    for i in range(n):\n        flow.add_edge(S,i,1,0)\n        flow.add_edge(n+i,T,1,0)\n\n    d = {}\n    for i in range(n):\n        for j in range(n):\n            cost = X\n            if 'A'<=s[i][j]<='Z':\n                cost -= 52**(51-(ord(s[i][j])-ord(('A'))))\n            else:\n                cost -= 52**(26-(ord(s[i][j])-ord(('a'))))\n            flow.add_edge(i,n+j,1,cost)\n            d[cost] = s[i][j]\n\n    print(flow.solve(S,T,n,d))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from string import ascii_lowercase, ascii_uppercase\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nfrom heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**100\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n        self.D = {}\n\n    def add_edge(self, fr, to, cap, cost):\n        G = self.G\n        G[fr].append([to, cap, cost, len(G[to])])\n        G[to].append([fr, 0, -cost, len(G[fr])-1])\n        self.D[fr, to] = G[fr][-1]\n        self.D[to, fr] = G[to][-1]\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [0]*N\n\n        while f:\n            dist = [INF]*N\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                for i, (w, cap, cost, _) in enumerate(G[v]):\n                    if cap > 0 and dist[w] > dist[v] + cost + H[v] - H[w]:\n                        dist[w] = r = dist[v] + cost + H[v] - H[w]\n                        prv_v[w] = v; prv_e[w] = i\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return -1\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prv_v[v]][prv_e[v]][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = G[prv_v[v]][prv_e[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prv_v[v]\n        return res\n\ncs = ascii_uppercase + ascii_lowercase\nL = len(cs)\ndef solve():\n    N = int(readline())\n\n    g = N*2\n    mcf = MinCostFlow(N*2+2)\n    for i in range(N):\n        mcf.add_edge(g, i, 1, 0)\n        mcf.add_edge(N+i, g+1, 1, 0)\n\n    S = []\n    for i in range(N):\n        *Si, = map(cs.index, readline().strip())\n        for j in range(N):\n            mcf.add_edge(i, j+N, 1, -L**(L-Si[j]))\n        S.append(Si)\n\n    mcf.flow(g, g+1, N)\n    ans = []\n    for i in range(N):\n        Si = S[i]\n        for j in range(N):\n            if mcf.D[i, j+N][1] == 0:\n                ans.append(Si[j])\n    ans.sort()\n\n    write(\"\".join(map(cs.__getitem__, ans)))\n    write(\"\\n\")\nsolve()\n"
  }
]