[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\nint grid[MAX_SIZE][MAX_SIZE];\nint rows, cols, distance;\n\nbool isAllLightsOff() {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] != 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid toggle(int x, int y) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (abs(i - x) + abs(j - y) <= distance) {\n                grid[i][j] ^= 1;\n            }\n        }\n    }\n}\n\nbool canTurnOffAllLights() {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n                toggle(i, j);\n                if (isAllLightsOff()) {\n                    return true;\n                }\n            }\n        }\n    }\n    return isAllLightsOff();\n}\n\nint main() {\n    scanf(\"%d %d %d\", &rows, &cols, &distance);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    if (canTurnOffAllLights()) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nbool canTurnOffAllLights(const vector<vector<int>>& lights, int d) {\n    int m = lights.size();\n    if (m == 0) return true;\n    int n = lights[0].size();\n    \n    vector<vector<bool>> visited(m, vector<bool>(n, false));\n    queue<pair<int, int>> q;\n    \n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (lights[i][j] == 1) {\n                q.push({i, j});\n                visited[i][j] = true;\n                break;\n            }\n        }\n        if (!q.empty()) break;\n    }\n    \n    if (q.empty()) return true;\n    \n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        \n        for (int i = max(0, x - d); i <= min(m - 1, x + d); ++i) {\n            for (int j = max(0, y - d); j <= min(n - 1, y + d); ++j) {\n                if (abs(i - x) + abs(j - y) <= d && !visited[i][j]) {\n                    visited[i][j] = true;\n                    if (lights[i][j] == 1) {\n                        q.push({i, j});\n                    }\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (lights[i][j] == 1 && !visited[i][j]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}",
    "timestamp": "2025-08-05 20:50:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LightToggle {\n    public static boolean canTurnOffAllLights(int[][] grid, int distance) {\n        int m = grid.length;\n        if (m == 0) return true;\n        int n = grid[0].length;\n        \n        int[][] toggle = new int[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    for (int x = Math.max(0, i - distance); x <= Math.min(m - 1, i + distance); x++) {\n                        for (int y = Math.max(0, j - distance); y <= Math.min(n - 1, j + distance); y++) {\n                            if (Math.abs(x - i) + Math.abs(y - j) <= distance) {\n                                toggle[x][y] ^= 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (toggle[i][j] != 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 20:50:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public boolean canTurnOffLights(int[][] grid, int manhattanDistance) {\n        int m = grid.length;\n        int n = grid[0].length;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    boolean canToggle = false;\n                    \n                    for (int r = 0; r < m; r++) {\n                        for (int c = 0; c < n; c++) {\n                            if (getManhattanDistance(i, j, r, c) <= manhattanDistance) {\n                                grid[r][c] = 1 - grid[r][c];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return allLightsOff(grid);\n    }\n    \n    private int getManhattanDistance(int x1, int y1, int x2, int y2) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n    \n    private boolean allLightsOff(int[][] grid) {\n        for (int[] row : grid) {\n            for (int light : row) {\n                if (light == 1) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 20:50:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_ROWS 20\n#define MAX_COLS 20\n\nint rows, cols, manhattan_dist;\nbool lights[MAX_ROWS][MAX_COLS];\nbool original_lights[MAX_ROWS][MAX_COLS];\n\nvoid toggle_lights(int r, int c) {\n    lights[r][c] = !lights[r][c];\n    \n    for (int dr = -manhattan_dist; dr <= manhattan_dist; dr++) {\n        for (int dc = -(manhattan_dist - abs(dr)); dc <= manhattan_dist - abs(dr); dc++) {\n            int nr = r + dr;\n            int nc = c + dc;\n            \n            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {\n                lights[nr][nc] = !lights[nr][nc];\n            }\n        }\n    }\n}\n\nbool solve() {\n    for (int mask = 0; mask < (1 << (rows * cols)); mask++) {\n        memcpy(lights, original_lights, sizeof(original_lights));\n        \n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (mask & (1 << (r * cols + c))) {\n                    toggle_lights(r, c);\n                }\n            }\n        }\n        \n        bool all_off = true;\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (lights[r][c]) {\n                    all_off = false;\n                    break;\n                }\n            }\n            if (!all_off) break;\n        }\n        \n        if (all_off) return true;\n    }\n    \n    return false;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &rows, &cols, &manhattan_dist);\n    \n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            scanf(\"%d\", &original_lights[r][c]);\n        }\n    }\n    \n    printf(\"%s\\n\", solve() ? \"Possible\" : \"Impossible\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n\nclass LightController {\nprivate:\n    std::vector<std::vector<bool>> lights;\n    int rows, cols, distance;\n\n    bool isValidMove(int r, int c) {\n        return r >= 0 && r < rows && c >= 0 && c < cols;\n    }\n\n    void toggleLights(int r, int c) {\n        for (int dr = -distance; dr <= distance; ++dr) {\n            for (int dc = -distance; dc <= distance; ++dc) {\n                if (std::abs(dr) + std::abs(dc) <= distance) {\n                    int nr = r + dr, nc = c + dc;\n                    if (isValidMove(nr, nc)) {\n                        lights[nr][nc] = !lights[nr][nc];\n                    }\n                }\n            }\n        }\n    }\n\npublic:\n    bool canTurnOffLights(std::vector<std::vector<bool>>& initialState, int toggleDistance) {\n        lights = initialState;\n        rows = lights.size();\n        cols = lights[0].size();\n        distance = toggleDistance;\n\n        // Try all possible toggle combinations\n        for (int mask = 0; mask < (1 << (rows * cols)); ++mask) {\n            auto tempLights = lights;\n            \n            for (int r = 0; r < rows; ++r) {\n                for (int c = 0; c < cols; ++c) {\n                    if (mask & (1 << (r * cols + c))) {\n                        toggleLights(r, c);\n                    }\n                }\n            }\n\n            // Check if all lights are off\n            bool allOff = true;\n            for (const auto& row : lights) {\n                for (bool light : row) {\n                    if (light) {\n                        allOff = false;\n                        break;\n                    }\n                }\n                if (!allOff) break;\n            }\n\n            if (allOff) return true;\n            lights = tempLights;\n        }\n\n        return false;\n    }\n};",
    "timestamp": "2025-08-05 20:50:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_possible_to_turn_off_lights(grid, distance):\n    from collections import deque\n\n    def within_bounds(x, y):\n        return 0 <= x < rows and 0 <= y < cols\n\n    def toggle_lights(x, y):\n        for i in range(rows):\n            for j in range(cols):\n                if abs(i - x) + abs(j - y) <= distance:\n                    grid[i][j] = 1 - grid[i][j]\n\n    rows = len(grid)\n    cols = len(grid[0])\n    \n    # Let's check if initial configuration can be toggled off\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                toggle_lights(i, j)\n\n    # Check if all lights are off\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                return False\n    return True\n\n# Example usage:\nfloor_grid = [\n    [1, 0, 1],\n    [0, 1, 0],\n    [1, 1, 0]\n]\nmanhattan_distance = 1\nprint(is_possible_to_turn_off_lights(floor_grid, manhattan_distance))  # Output: False or True",
    "timestamp": "2025-08-13 03:41:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class NightWatchman {\n\n    static int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n\n    public static boolean canTurnOffAllLights(int[][] grid, int distance) {\n        Map<String, Boolean> memo = new HashMap<>();\n        return canTurnOffAllLightsHelper(grid, 0, 0, distance, memo);\n    }\n\n    private static boolean canTurnOffAllLightsHelper(int[][] grid, int row, int col, int distance, Map<String, Boolean> memo) {\n        if (row == grid.length) {\n            return allLightsOff(grid);\n        }\n        \n        int nextRow = col == grid[row].length - 1 ? row + 1 : row;\n        int nextCol = col == grid[row].length - 1 ? 0 : col + 1;\n        \n        String stateKey = generateStateKey(grid);\n        if (memo.containsKey(stateKey)) {\n            return memo.get(stateKey);\n        }\n        \n        // Try not toggling the current switch\n        if (canTurnOffAllLightsHelper(grid, nextRow, nextCol, distance, memo)) {\n            memo.put(stateKey, true);\n            return true;\n        }\n\n        // Try toggling the current switch\n        toggle(grid, row, col, distance);\n\n        if (canTurnOffAllLightsHelper(grid, nextRow, nextCol, distance, memo)) {\n            memo.put(stateKey, true);\n            toggle(grid, row, col, distance);  // revert the toggle\n            return true;\n        }\n\n        toggle(grid, row, col, distance);  // revert the toggle\n        memo.put(stateKey, false);\n        return false;\n    }\n\n    private static void toggle(int[][] grid, int row, int col, int distance) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (manhattanDistance(row, col, i, j) <= distance) {\n                    grid[i][j] = 1 - grid[i][j];\n                }\n            }\n        }\n    }\n\n    private static int manhattanDistance(int i, int j, int x, int y) {\n        return Math.abs(i - x) + Math.abs(j - y);\n    }\n\n    private static boolean allLightsOff(int[][] grid) {\n        for (int[] row : grid) {\n            for (int light : row) {\n                if (light != 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private static String generateStateKey(int[][] grid) {\n        StringBuilder sb = new StringBuilder();\n        for (int[] row : grid) {\n            for (int light : row) {\n                sb.append(light);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {\n            {1, 1, 1},\n            {0, 1, 0},\n            {1, 0, 1}\n        };\n        int distance = 1;\n\n        System.out.println(canTurnOffAllLights(grid, distance)); // Output should be true/false based on the possibility\n    }\n}",
    "timestamp": "2025-08-13 03:41:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX 10\n\nint n, m, d;\nint lights[MAX][MAX];\nbool toggled[MAX][MAX];\n\nbool canTurnOffAllLights(int x, int y) {\n    if (y == m) {\n        x++;\n        y = 0;\n    }\n    if (x == n) {\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (lights[i][j] % 2 != 0)\n                    return false;\n        return true;\n    }\n    \n    // Try without toggling\n    if (canTurnOffAllLights(x, y + 1))\n        return true;\n\n    // Toggle at (x, y)\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (abs(i - x) + abs(j - y) <= d) {\n                lights[i][j]++;\n            }\n        }\n    }\n    if (canTurnOffAllLights(x, y + 1))\n        return true;\n\n    // Revert toggle at (x, y)\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (abs(i - x) + abs(j - y) <= d) {\n                lights[i][j]--;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    printf(\"Enter grid size n m and distance d (<= 10): \");\n    scanf(\"%d %d %d\", &n, &m, &d);\n\n    printf(\"Enter the grid state:\\n\");\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            scanf(\"%d\", &lights[i][j]);\n\n    if (canTurnOffAllLights(0, 0)) {\n        printf(\"It's possible to turn off all lights.\\n\");\n    } else {\n        printf(\"It's not possible to turn off all lights.\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:41:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_turn_off_all_lights(grid, manhattan_dist):\n    rows, cols = len(grid), len(grid[0])\n    \n    # Try all possible initial toggle combinations\n    for toggle_state in range(1 << (rows * cols)):\n        # Create a copy of the grid to manipulate\n        test_grid = [row[:] for row in grid]\n        \n        # Simulate toggling switches based on current state\n        for r in range(rows):\n            for c in range(cols):\n                if toggle_state & (1 << (r * cols + c)):\n                    toggle_lights(test_grid, r, c, manhattan_dist)\n        \n        # Check if all lights are off after toggling\n        if all(all(light == 0 for light in row) for row in test_grid):\n            return True\n    \n    return False\n\ndef toggle_lights(grid, row, col, manhattan_dist):\n    rows, cols = len(grid), len(grid[0])\n    \n    # Toggle the current room's light\n    grid[row][col] = 1 - grid[row][col]\n    \n    # Check and toggle lights within Manhattan distance\n    for r in range(rows):\n        for c in range(cols):\n            if abs(r - row) + abs(c - col) <= manhattan_dist:\n                grid[r][c] = 1 - grid[r][c]",
    "timestamp": "2025-08-13 03:42:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef is_possible_to_turn_off(lights, distance):\n    rows = len(lights)\n    if rows == 0:\n        return True\n    cols = len(lights[0])\n    \n    # Create a copy of the lights to manipulate\n    grid = [row[:] for row in lights]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == 1:\n                # Toggle this switch and all within Manhattan distance\n                q = deque()\n                q.append((i, j))\n                grid[i][j] ^= 1\n                \n                while q:\n                    x, y = q.popleft()\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < rows and 0 <= ny < cols:\n                            if abs(nx - i) + abs(ny - j) <= distance:\n                                if grid[nx][ny] == 1:\n                                    grid[nx][ny] ^= 1\n                                    q.append((nx, ny))\n    \n    # Check if all lights are off\n    for row in grid:\n        if any(row):\n            return False\n    return True",
    "timestamp": "2025-08-13 03:42:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Room {\n    int x, y;\n};\n\n// Function to toggle the lights in the affected area\nvoid toggleLights(vector<vector<int>>& lights, int x, int y, int d) {\n    int n = lights.size();\n    int m = lights[0].size();\n    for (int i = max(0, x - d); i <= min(n - 1, x + d); ++i) {\n        for (int j = max(0, y - d); j <= min(m - 1, y + d); ++j) {\n            if (abs(i - x) + abs(j - y) <= d) {\n                lights[i][j] ^= 1;  // Toggle the light\n            }\n        }\n    }\n}\n\n// Function to check if all lights are off\nbool allOff(const vector<vector<int>>& lights) {\n    for (const auto& row : lights) {\n        for (int light : row) {\n            if (light == 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// Recursive function to determine if it's possible to turn off all lights\nbool canTurnOffLights(vector<vector<int>>& lights, int d) {\n    int n = lights.size();\n    int m = lights[0].size();\n\n    // Queue for breadth-first approach\n    queue<vector<vector<int>>> q;\n    q.push(lights);\n\n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n\n        if (allOff(current)) {\n            return true;\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (current[i][j] == 1) {\n                    vector<vector<int>> nextState = current;\n                    toggleLights(nextState, i, j, d);\n                    q.push(nextState);\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int n, m, d;\n    cin >> n >> m >> d;\n    vector<vector<int>> lights(n, vector<int>(m));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> lights[i][j];\n        }\n    }\n\n    if (canTurnOffLights(lights, d)) {\n        cout << \"Possible\" << endl;\n    } else {\n        cout << \"Impossible\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:14:30"
  }
]