[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\nusing BS = bitset<700>;\n\n// return (x, y) (a * x + b * y = gcd(a, b))\npair<long long, long long> exeuclid(long long a, long long b) {\n  if (b == 0)\n    return make_pair(1, 0);\n  pair<long long, long long> ret = exeuclid(b, a % b);\n  ret.first -= a / b * ret.second;\n  return make_pair(ret.second, ret.first);\n}\n\nll mod_inv(ll a, ll b) {\n  return (exeuclid(a, b).first % b + b) % b;\n}\n\nint bit_gauss(vector<BS> &a, int m) {\n  int rank = 0;\n  int n = a.size();\n  for (int j = 0; j < min(n, m); j++) {\n    for (int i = rank; i < n; i++) {\n      if (a[i][j]) {\n        for (int k = 0; k < n; k++) {\n          if (i == k || !a[k][j]) continue;\n          a[k] ^= a[i];\n        }\n        if (rank != i) {\n          swap(a[rank], a[i]);\n        }\n        rank++;\n        break;\n      }\n    }\n  }\n  return rank;\n}\n\nint mod_gauss(vvl &a, ll mod) {\n  int rank = 0;\n  for (auto &v : a)\n    for (auto &i : v) {\n      i %= mod;\n      i += mod;\n      i %= mod;\n    }\n  int n = a.size();\n  int m = a[0].size();\n  for (int j = 0; j < min(n, m); j++) {\n    for (int i = rank; i < n; i++) {\n      if (a[i][j]) {\n        ll inv = mod_inv(a[i][j], mod);\n        for (int k = 0; k < m; k++) a[i][k] = (a[i][k] * inv) % mod;\n        for (int k = 0; k < n; k++) {\n          if (i == k || a[k][j] == 0) continue;\n          ll mul = (mod - a[k][j]) % mod;\n          for (int l = 0; l < m; l++) a[k][l] = (a[k][l] + a[i][l] * mul) % mod;\n        }\n        if (rank != i) {\n          swap(a[rank], a[i]);\n        }\n        rank++;\n        break;\n      }\n    }\n  }\n  return rank;\n}\n\nint mod_solve(vvl &a, vll &b, vll &ret, ll mod) {\n  int n = a.size();\n  vvl c = a;\n  for (int i = 0; i < n; i++) {\n    c[i].push_back(b[i]);\n  }\n  int rank = mod_gauss(c, mod);\n  for (int i = rank; i < n; i++) if (c[i][n]) return -1;\n  ret.resize(n);\n  for (int i = 0; i < n; i++) ret[i] = c[i][n];\n  return rank;\n}\n\nint bit_solve(vector<BS> &a, vector<bool> &b, vector<bool> &ret) {\n  int n = a.size();\n  auto c = a;\n  for (int i = 0; i < n; i++) {\n    c[i][n] = b[i];\n  }\n  int rank = bit_gauss(c, n + 1);\n\n  for (int i = rank; i < n; i++) if (c[i][n]) return -1;\n  ret.resize(n);\n  for (int i = 0; i < n; i++) ret[i] = c[i][n];\n  return rank;\n}\n\nint cnt = 0;\n\nbool solve() {\n  cnt++;\n  int m, n, d;\n  cin >> m >> n >> d;\n  if (n == 0) return false;\n  vvl mp(n, vector<ll>(m));\n  for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) cin >> mp[i][j];\n  vector<BS> a(n * m);\n  vector<bool> b(n * m);\n  auto to_index = [&](int i, int j) {\n    return i + j * n;\n  };\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      b[to_index(i, j)] = mp[i][j];\n      a[to_index(i, j)][to_index(i, j)] = true;\n      for (int k = 0; k < n; k++)\n        for (int l = 0; l < m; l++) {\n          if ((abs(i - k) + abs(j - l)) == d) a[to_index(i, j)][to_index(k, l)] = true;\n        }\n    }\n  }\n  vector<bool> c;\n  int rank = bit_solve(a, b, c);\n  cout << (rank >= 0) << endl;\n  return true;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  while (solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\n// KEXÌÁ@ÅA§®ðÆ­\nvec gauss_jordan(const mat&A,const vec &b){\n\tint n=A.size();\n\tmat B(n,vec(n+1));\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)B[i][j]=A[i][j];\n\tfor(int i = 0; i < n; i++)B[i][n]=b[i];\n\t// eÏÉÚ\n\tfor(int i = 0; i < n; i++){\n\t\t// evfð2ÅÁ½]èÉu«·¦é\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(abs(B[j][k])%2==1)B[j][k]=B[j][k]%2;\n\t\t\t\telse if(B[j][k]==0)B[j][k]=0;\n\t\t\t\telse if(B[j][k]>0)B[j][k]=2;\n\t\t\t\telse B[j][k]=-2;\n\t\t\t}\n\t\t\tB[j][n]=B[j][n]%2;\n\t\t}\n\t\t// ÅåÌWÌâÎlðàÂàÌðiÔÚÉÁÄ­é\n\t\tint piv=-1;\n\t\tint val=-1;\n\t\tfor(int j=i;j<n;j++){\n//\t\t\tif(val<abs(B[j][i])){\n\t\t\tif(abs(B[j][i])==1){\n\t\t\t\tpiv=j;\n\t\t\t\tval=abs(B[j][i]);\n\t\t\t}\n\t\t}\n\t\t// ðª¡Ü½Íðª³¢\n\t\tif(piv==-1||val<EPS){\n\t\t\tif(B[i][n]!=0)\n\t\t\t\treturn vec();\n\t\t\telse{\n\t\t\t\tB[i][n]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswap(B[piv],B[i]);\n\t\t// isÚð»ê¼êB[piv][i]ÌlÅé\n\t\tint divNum=B[i][i];\n\t\tfor(int j = i; j <= n; j++)B[i][j]/=divNum;\n\t\t// »ê¼êÌs©çAisÚÌlðø­©ñ¶\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i==j)continue;\n\t\t\tint mulnum=B[j][i];\n\t\t\tfor(int k = i; k <= n; k++)B[j][k]-=mulnum*B[i][k];\n\t\t}\n\t}\n\tvec res(n);\n\tfor(int i = 0; i < n; i++)res[i]=B[i][n];\n\treturn res;\n}\n\nint main(){\n\tint m,n,d;\n\tint field[30][30];\n\twhile(cin>>m>>n>>d&&(m|n|d)){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\tcin>>field[i][j];\n\t\tint mtSize=m*n;\n\t\tmat mt(mtSize,vec(mtSize));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t// (m*i+j)sÚÌsñÌeñÉÂ¢Äè\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tfor(int l=0;l<m;l++){\n\t\t\t\t\t\tint mhd=abs(k-i)+abs(l-j);\n\t\t\t\t\t\tmt[m*i+j][m*k+l]=(mhd==d||mhd==0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> r;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)r.push_back(field[i][j]);\n\t\tvec res=gauss_jordan(mt,r);\n\t\tif(res.size()==0)cout<<0<<endl;\n\t\telse{\n//\t\t\tfor(int i=0;i<(int)res.size();i++)\n//\t\t\t\tcout<<res[i]<<\" \";\n//\t\t\tcout<<endl;\n\t\t\tcout<<1<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[]={-1,0,1,0},dx[]={0,-1,0,1},dy2[]={1,-1,-1,1},dx2[]={1,1,-1,-1};\nint m,n,d,s[25][25];\nint main()\n{\n\twhile(cin>>m>>n>>d,m){\n\t\tint N=m*n;\n\t\tvector<vi> a(N,vi(N+1,0));\n\t\trep(i,m)rep(j,n)cin>>s[i][j], a[i*n+j][N]=s[i][j];\n\t\t\n\t\trep(i,N)(a[i][i]+=1)%=2;\n\t\trep(i,m)rep(j,n)rep(dir,4)rep(k,d){\n\t\t\tint y=i+dy[dir]*d+dy2[dir]*k, x=j+dx[dir]*d+dx2[dir]*k;\n\t\t\tif(0<=y&&y<m&&0<=x&&x<n){\n\t\t\t\t(a[y*n+x][i*n+j]+=1)%=2;\n\t\t\t}\n\t\t}\n\t\trep(i,N){\n\t\t\tswap(a[i],*max_element(a.begin()+i,a.end()));\n\t\t\tif(a[i][i]){\n\t\t\t\trep(j,N)if(i<j&&a[j][i])rep(k,N+1)(a[j][k]+=a[i][k])%=2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool ok=1; int j=0;\n\t\trep(i,N)if(ok&&a[i][N]){\n\t\t\tfor(;j<N&&a[i][j]==0;j++);\n\t\t\tif(j>=N)ok=0;\n\t\t}\n\t\tcout<<(int)ok<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ninline int countPopulation(unsigned int x) {\n\tx -= ((x >> 1) & 0x55555555);\n\tx = ((x >> 2) & 0x33333333) + (x & 0x33333333);\n\tx = ((x >> 4) + x) & 0x0f0f0f0f;\n\tx += (x >> 8);\n\tx += (x >> 16);\n\treturn (x & 0x0000003f);\n}\n\ninline int countPopulation64(unsigned long long x) {\n\treturn countPopulation(x & 0xffffffff) + countPopulation(x >> 32);\n}\n\n\nstruct BitSet {\n\ttypedef unsigned long long uint64;\n\tstatic const int MAX_BIT_LENGTH = int(25*25+1);\n\tuint64 bits[(MAX_BIT_LENGTH + 0x3f)>>6];\n\tint size, last;\n\tuint64 lastMask;\n\n\tBitSet(){}\n\n\tvoid init(const int size_) {\n\t\tsize = size_;\n\t\tlast = (size+0x3f)>>6;\n\t\tlastMask = (1ULL<<(size&0x3f)) - 1;\n\t\tmemset(bits, 0, sizeof(uint64)*last);\n\t}\n\n\tinline int getIthBit(const int i) const {\n\t\treturn (bits[i>>6]>>(i&0x3f))&1;\n\t}\n\n\tinline int operator [](const int i) const {\n\t\treturn getIthBit(i);\n\t}\n\n\tinline void flip(const int i) {\n\t\tbits[i>>6] ^= (1ULL<<(i&0x3f));\n\t}\n\n\tinline void turnOn(const int i) {\n\t\tbits[i>>6] |= (1ULL<<(i&0x3f));\n\t}\n\n\tinline void turnOff(const int i) {\n\t\tbits[i>>6] &= ~(1ULL<<(i&0x3f));\n\t}\n\n\tinline void allFlip() {\n\t\tfor (int i = 0; i < last - 1; ++i) {\n\t\t\tbits[i] ^= ~0ULL;\n\t\t}\n\t\tbits[last - 1] ^= lastMask;\n\t}\n\n\tinline void allTurnOn() {\n\t\tmemset(bits, ~0, sizeof(uint64)*(last - 1));\n\t\tbits[last-1] = lastMask;\n\t}\n\n\tinline void allTurnOff() {\n\t\tmemset(bits, 0, sizeof(uint64)*last);\n\t}\n\n\tinline void rangeFlip(const int from, const int to) {\n\t\tconst int beg = from >> 6, ed = to >> 6;\n\t\tconst uint64 begMask = ~((1ULL<<(from&0x3f)) - 1), edMask = (1ULL<<(to&0x3f)) - 1;\n\t\tfor (int i = from + 1; i < ed; ++i) {\n\t\t\tbits[i] ^= ~0ULL;\n\t\t}\n\t\tif (beg == ed) {\n\t\t\tbits[beg] ^= begMask & edMask;\n\t\t}\n\t\telse {\n\t\t\tbits[beg] ^= begMask;\n\t\t\tbits[ed]  ^= edMask;\n\t\t}\n\t}\n\n\tinline void rangeTurnOn(const int from, const int to) {\n\t\tconst int beg = from >> 6, ed = to >> 6;\n\t\tconst uint64 begMask = ~((1ULL<<(from&0x3f)) - 1), edMask = (1ULL<<(to&0x3f)) - 1;\n\t\tfor (int i = from + 1; i < ed; ++i) {\n\t\t\tbits[i] = ~0ULL;\n\t\t}\n\t\tif (beg == ed) {\n\t\t\tbits[beg] |= begMask & edMask;\n\t\t}\n\t\telse {\n\t\t\tbits[beg] |= begMask;\n\t\t\tbits[ed]  |= edMask;\n\t\t}\n\t}\n\n\tinline void rangeTurnOff(const int from, const int to) {\n\t\tconst int beg = from >> 6, ed = to >> 6;\n\t\tconst uint64 begMask = ~((1ULL<<(from&0x3f)) - 1), edMask = (1ULL<<(to&0x3f)) - 1;\n\t\tfor (int i = from + 1; i < ed; ++i) {\n\t\t\tbits[i] = 0;\n\t\t}\n\t\tif (beg == ed) {\n\t\t\tbits[beg] &= ~(begMask & edMask);\n\t\t}\n\t\telse {\n\t\t\tbits[beg] &= ~begMask;\n\t\t\tbits[ed]  &= ~edMask;\n\t\t}\n\t}\n\n\tinline int countPopulation() const {\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tans += countPopulation64(bits[i]);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline int countRangePopulation(const int from, const int to) const {\n\t\tconst int beg = from >> 6, ed = to >> 6;\n\t\tconst uint64 begMask = ~((1ULL<<(from&0x3f)) - 1), edMask = (1ULL<<(to&0x3f)) - 1;\n\t\tint ans = 0;\n\t\tfor (int i = from + 1; i < ed; ++i) {\n\t\t\tans += countPopulation64(bits[i]);\n\t\t}\n\t\tif (beg == ed) {\n\t\t\tans += countPopulation64(bits[beg] &~ (begMask & edMask));\n\t\t}\n\t\telse {\n\t\t\tans += countPopulation64(bits[beg] &~ begMask);\n\t\t\tans += countPopulation64(bits[ed]  &~ edMask);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tBitSet operator& (const BitSet &x) const {\n\t\tBitSet ret = *this;\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tret.bits[i] &= x.bits[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBitSet operator| (const BitSet &x) const {\n\t\tBitSet ret = *this;\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tret.bits[i] |= x.bits[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBitSet operator^ (const BitSet &x) const {\n\t\tBitSet ret = *this;\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tret.bits[i] ^= x.bits[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBitSet operator~ () const {\n\t\tBitSet ret = *this;\n\t\tret.allFlip();\n\t\treturn ret;\n\t}\n\n\tBitSet &operator^= (const BitSet &x) {\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tbits[i] ^= x.bits[i];\n\t\t}\n\t\treturn *this;\n\t}\n\n\tBitSet &operator&= (const BitSet &x) {\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tbits[i] &= x.bits[i];\n\t\t}\n\t\treturn *this;\n\t}\n\n\tBitSet &operator|= (const BitSet &x) {\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tbits[i] |= x.bits[i];\n\t\t}\n\t\treturn *this;\n\t}\n};\n\n\nint calcEquationSystemMod2(vector<BitSet> &Ab, BitSet& x) {\n\tconst int n = Ab.size(), m = Ab[0].size - 1;\n\tx.init(m);\n\tbool uniq = true;\n\tint val = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (val == m) {\n\t\t\tfor (int j = i; j < n; ++j) {\n\t\t\t\tif (Ab[j][val]) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tint foundOne = -1;\n\t\tfor (int j = i; j < n; ++j) {\n\t\t\tif (Ab[j][val]) {\n\t\t\t\tfoundOne = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (foundOne >= 0) {\n\t\t\tswap(Ab[i], Ab[foundOne]);\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (Ab[j][val]) {\n\t\t\t\t\tAb[j] ^= Ab[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tuniq = false;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tAb[j].turnOff(val);\n\t\t\t}\n\t\t\t--i;\n\t\t}\n\t\t++val;\n\t}\n\n\tval = m - 1;\n\tint i = n - 1;\n\tfor (;i >= 0 && val >= 0; --val) {\n\t\tif (Ab[i][val]) {\n\t\t\tif (Ab[i][m]) {\n\t\t\t\tx.turnOn(val);\n\t\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\t\tAb[j].turnOff(val);\n\t\t\t\t\tAb[j].flip(m);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\t\tAb[j].turnOff(val);\n\t\t\t\t}\n\t\t\t}\n\t\t\t--i;\n\t\t}\n\t}\n\n\treturn uniq ? 1 : -1;\n}\n\nconst int MAX_N = 25;\nint W, H, D;\nint board[MAX_N][MAX_N];\n\ninline int toIndex(int y, int x) {\n\treturn y * W + x;\n}\n\nbool init() {\n\tscanf(\"%d%d%d\", &W, &H, &D);\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", board[i] + j);\n\t\t}\n\t}\n\treturn H > 0;\n}\n\ninline int getDist(int y1, int x1, int y2, int x2) {\n\treturn abs(y1 - y2) + abs(x1 - x2);\n}\n\nbool solve() {\n\tvector<BitSet> matrix(W*H);\n\tfor (int i = 0; i < W*H; ++i) {\n\t\tmatrix[i].init(W*H+1);\n\t}\n\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tmatrix[toIndex(i,j)].turnOn(toIndex(i,j));\n\t\t\tif (board[i][j]) {\n\t\t\t\tmatrix[toIndex(i,j)].turnOn(W*H);\n\t\t\t}\n\t\t\tfor (int ii = 0; ii < H; ++ii) {\n\t\t\t\tfor (int jj = 0; jj < W; ++jj) {\n\t\t\t\t\tif (getDist(i,j,ii,jj) == D) {\n\t\t\t\t\t\tmatrix[toIndex(i,j)].turnOn(toIndex(ii,jj));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tBitSet x;\n\treturn calcEquationSystemMod2(matrix, x) != 0;\n}\n\nint main() {\n\tfor (;init();) {\n\t\tputs(solve() ? \"1\" : \"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int w, h, d;\n        cin >> w >> h >> d;\n        if(w == 0)\n            return 0;\n\n        vector<vector<bool> > light(h, vector<bool>(w));\n        for(int i=0; i<h; ++i){\n            for(int j=0; j<w; ++j){\n                int a;\n                cin >> a;\n                light[i][j] = (a == 1);\n            }\n        }\n\n        vector<bitset<626> > bs(h*w);\n        for(int y0=0; y0<h; ++y0){\n            for(int x0=0; x0<w; ++x0){\n                int i = y0 * w + x0;\n                bs[i][i] = true;\n                bs[i][h*w] = light[y0][x0];\n\n                int sy[] = {0, 1, 0, -1};\n                int sx[] = {1, 0, -1, 0};\n                int dy[] = {1, -1, -1, 1};\n                int dx[] = {-1, -1, 1, 1};\n                for(int j=0; j<4; ++j){\n                    int y = y0 + sy[j] * d;\n                    int x = x0 + sx[j] * d;\n                    for(int k=0; k<d; ++k){\n                        if(0 <= y && y < h && 0 <= x && x < w)\n                            bs[i][y*w+x] = true;\n                        y += dy[j];\n                        x += dx[j];\n                    }\n                }\n            }\n        }\n\n        int i = 0;\n        int j = 0;\n        for(;;){\n            while(j < h*w){\n                int k = i;\n                while(k < h*w && !bs[k][j])\n                    ++ k;\n                if(k < h*w){\n                    swap(bs[i], bs[k]);\n                    break;\n                }\n                ++ j;\n            }\n            if(j == h*w)\n                break;\n\n            for(int k=i+1; k<h*w; ++k){\n                if(bs[k][j])\n                    bs[k] ^= bs[i];\n            }\n            ++ i;\n            ++ j;\n        }\n\n        bool ok = true;\n        for(int k=i; k<h*w; ++k){\n            if(bs[k][h*w])\n                ok = false;\n        }\n\n        if(ok)\n            cout << 1 << endl;\n        else\n            cout << 0 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\n\nint standard_mat(mat &A){\n    int m = sz(A), n = sz(A[0]);\n    int now = 0;\n    rep(j, n){\n        int pivot = now;\n        rep2(i, now, m-1){\n            if(A[i][j] > A[pivot][j]) pivot = i;\n        }\n        swap(A[now], A[pivot]);\n        if(A[now][j] == 0) continue;\n        rep(i, m){\n            if(i == now) continue;\n            rep2(k, j+1, n-1) A[i][k] ^= A[i][j]*A[now][k];\n            A[i][j] = 0;\n        }\n        now++;\n        if(now == m) break;\n    }\n    rep(i, m){\n        bool flag = true;\n        rep(j, n-1) if(A[i][j] == 1) flag = false;\n        if(A[i][n-1] == 0) flag = false;\n        if(flag) return 0;\n    }\n    return 1;\n}\n\nint main(){\n    vector<int> ans;\n    while(true){\n        int H, W, D;\n        cin >> W >> H >> D;\n        if(H == 0 && W == 0 && D == 0) break;\n        int s[H][W];\n        rep(i, H){\n            rep(j, W) cin >> s[i][j];\n        }\n        mat A(H*W, vec(H*W+1, 0));\n        rep(i, H){\n            rep(j, W){\n                rep(k, H){\n                    rep(l, W){\n                        if(abs(k-i)+abs(l-j) == D) A[i*W+j][k*W+l] = 1;\n                    }\n                }\n                A[i*W+j][i*W+j] = 1;\n                A[i*W+j][H*W] = s[i][j];\n            }\n        }\n        ans.pb(standard_mat(A));\n    }\n    for(auto &e: ans) cout << e << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 625+2;\nconst int mod = 2;\nint mat[N][N];\n//if mod is prime\nint mypow(int n,int p){\n  if (p == 0)return 1;\n  int tmp=mypow(n,p/2);\n  tmp=(tmp*tmp)%mod;\n  if (tmp%2==1)tmp=(tmp*n)%mod;\n  return tmp%mod;\n}\n\ninline int inverse(int now){\n  if (now == 0)return -1;// now answer\n  return 1;\n  return mypow(now,mod-2);\n}\n\n//if mod is not prime\n//extended euqlid?\n\n//partial pivot\nbool select_pivot(int r,int c,int k,int mat[N][N]){\n  int s=k;\n  int val=abs(mat[k][k]);\n  REP(i,k+1,r){\n    if (abs(mat[i][k])>val)val=abs(mat[i][k]),s=i;\n  }\n  if (val ==0)return false;\n  REP(i,k,c+1)swap(mat[k][i],mat[s][i]);\n  return true;\n}\n \nbool select_pivot(int r,int c,int k,int mat[N][N],int num[N]){\n int s=k,t=k;//selected pivot\n double val=fabs(mat[k][k]);\n REP(i,k+1,r){\n   REP(j,k+1,c){\n     if (fabs(mat[i][j]) >val){\n       val=fabs(mat[i][j]);\n       s=i;\n       t=j;\n     }\n   }\n }\n \n if ( val<1)return false;//cannot solve this linear equations.\n \n rep(i,r)swap(mat[i][k],mat[i][t]);\n \n swap(num[k],num[t]);\n \n REP(i,k,c+1){\n   swap(mat[k][i],mat[s][i]);\n }\n return true;//no problem for this pivot;\n}\n\nbool gauss(int r,int c,int mat[N][N],int num[N]){\n  rep(k,c){\n    if (!select_pivot(r,c,k,mat,num)){\n      //if (!select_pivot(r,c,k,mat)){\n      REP(i,k,r)if (mat[i][c] == 1)return false;\n      return true;\n    }\n    assert(inverse(mat[k][k]) != -1);\n    int inv=inverse(mat[k][k]);\n    REP(i,k+1,c+1)mat[k][i]=(mat[k][i]*inv)%mod;\n    mat[k][k]=1;\n    REP(i,k+1,r){\n      REP(j,k+1,c+1)mat[i][j]=(mat[i][j]+(-mat[i][k]*mat[k][j]+mod))%mod;\n      mat[i][k]=0;\n    }\n  }\n  return true;\n  for(int i=r-1;i>=0;i--){\n    REP(j,i+1,c){\n      mat[i][c]=(mat[i][c]-(mat[i][j]*mat[j][c])+mod)%mod;\n    }\n  }\n  return true;\n}\n\n#define GETPOS(c,i,j) ((i)*(c)+(j))\n\nmain(){\n  int r,c,d;\n  int num[N];\n  while(cin>>c>>r>>d && r){\n    int n=r*c;\n    rep(i,n)rep(j,n+1)mat[i][j]=0;\n    rep(i,n)num[i]=i;\n    rep(i,r)rep(j,c){\n      int tmp;cin>>tmp;\n      mat[GETPOS(c,i,j)][n]=1-tmp;\n    }\n    rep(i,r){\n      rep(j,c){\n\tmat[GETPOS(c,i,j)][GETPOS(c,i,j)]=1;\n\trep(ii,r){\n\t  rep(jj,c){\n\t    if (abs(ii-i)+abs(jj-j) == d){\n\t      mat[GETPOS(c,i,j)][GETPOS(c,ii,jj)]=1;\n\t      //cout << \"(\" <<i<<\",\"<<j<<\"),(\"\n\t      //<< ii<<\",\"<<jj<<\")\"<<endl;\n\t      //cout << GETPOS(c,i,j)+1 <<\" \" << GETPOS(c,ii,jj)+1 << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    /*    rep(i,n){\n      rep(j,n+1)cout << mat[i][j] <<\" \";\n      cout << endl;\n    }      \n    */\n\n    cout << gauss(n,n,mat,num) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, m, d;\nbool mat[650][650];\nbool a[25][25];\n\nbool valid(int x, int y)\n{\n    if(x < n && x >= 0 && y < m && y >= 0) return true;\n    return false;\n}\n\nint main()\n{\n    int cnt = 0;\n    while(~scanf(\"%d%d%d\", &m, &n, &d), n + m + d)\n    {\n\n        cnt++;\n        memset(mat, 0, sizeof mat);\n\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++)\n                scanf(\"%d\", &a[i][j]);\n\n        int row = n * m, col = n * m + 1;\n\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < m; j++)\n            {\n                for(int k = 0; k <= d; k++)\n                {\n                    int t1x = i + k, t1y = j + d - k;\n                    int t2x = i - k, t2y = j + d - k;\n                    int t3x = i + k, t3y = j - d + k;\n                    int t4x = i - k, t4y = j - d + k;\n                    if(valid(t1x, t1y)) mat[t1x * m + t1y][i * m + j] = 1;\n                    if(valid(t2x, t2y)) mat[t2x * m + t2y][i * m + j] = 1;\n                    if(valid(t3x, t3y)) mat[t3x * m + t3y][i * m + j] = 1;\n                    if(valid(t4x, t4y)) mat[t4x * m + t4y][i * m + j] = 1;\n                }\n                mat[i * m + j][i * m + j] = 1;\n            }\n        }\n\n        int flag = 0, pivot = 0;\n\n        for(int i = 0; i < n * m; i++)\n            mat[i][n * m] = a[i / m][i % m];\n\n        int ansl = 0, matl = 0;\n\n        for(int i = 0; i < col - 1; i++)\n        {\n            int pt = pivot;\n            while(mat[pt][i] == 0 && pt < row) pt++;\n            if(pt >= row) continue;\n            for(int j = 0; j < col; j++) swap(mat[pivot][j], mat[pt][j]);\n            for(int j = pivot + 1; j < row; j++)\n                if(mat[j][i] == 1)\n                    for(int k = i; k < col; k++)\n                        mat[j][k] ^= mat[pivot][k];\n            pivot++;\n        }\n\n        for(int u = row - 1; u >= 0; u--)\n        {\n            int fla = 0;\n            for(int v = 0; v < col - 1; v++)\n                if(mat[u][v] == 1) fla = 1;\n            if(fla == 0 && mat[u][col - 1] == 1)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        printf(\"%d\\n\", flag ^ 1);\n    }\n    return 0;\n}\n\n/*\n\n2 3 1\n0 0 1\n0 0 0\n2 3 1\n1 0 1\n0 0 0\n2 3 1\n0 1 1\n0 0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define REP(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n#define INF (1e10)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\ntemplate<class T> void print(const T& x){cout << setprecision(12) << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);}} premain;\n\n\nconst int MAX_ROW = 25*25+10; // to be set appropriately\nconst int MAX_COL = 25*25+10; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n}\n\n\nint main() {\n\tint M, N, D;\n\t\n\twhile(true) {\n\t\tcin >> M >> N >> D;\n\t\tif ((0 == M) && (0 == N) && (0 == D)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tBitMatrix A(M*N, M*N);\n\t\tvector<int> b(M*N);\n\n\t\tREP(i, M) REP(j, N) {\n\t\t\tREP(x, M) REP(y, N) {\n\t\t\t\tint d = abs(x-i) + abs(y-j);\n\t\t\t\tif (d == D) {\n\t\t\t\t\tA[i+M*j][x+M*y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tA[i+M*j][i+M*j] = 1;\n\t\t}\n\n\t\tREP(j, N) REP(i, M) {\n\t\t\tint s;\n\t\t\tcin >> s;\n\t\t\tb[i+M*j] = s;\n\t\t}\n\n\t\tvector<int> res(M*N);\n\t\tint rank = linear_equation(A, b, res);\n\t\tif (-1 == rank) {\n\t\t\tprint(0);\n\t\t} else {\n\t\t\tprint(1);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\n\n// 行列の階数を求める\n// 係数行列と拡大係数行列の階数が異なるときは不能\n// 係数行列と拡大係数行列の階数が等しく、係数行列の階数と変数の個数が異なるときは不定\n// 係数行列と拡大係数行列の階数と変数の個数がすべて等しいときは一意解が存在\nint mat_rank(mat A){\n    const int R = A.size(), C = A[0].size();\n    int ret = 0;\n    for(int i=0; ret<R&&i<C; ++i){\n        int pivot = ret;\n        for(int j=ret+1; j<R; ++j){\n            if(abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n        }\n        swap(A[pivot], A[ret]);\n\n        if(A[ret][i] == 0) continue;\n\n        // for(int k=C-1; k>=i; --k) A[ret][k] /= A[ret][i];\n        for(int j=ret+1; j<R; ++j){\n            for(int k=C-1; k>=i; --k) A[j][k] ^= A[ret][k]&A[j][i];\n        }\n        ++ret;\n    }\n    return ret;\n}\n\nusing pi = pair<int,int>;\n\nint main(){\n    int m,n,d;\n    while(scanf(\" %d %d %d\", &m, &n, &d),m){\n        auto ID = [&](int y, int x){\n            return y*m + x;\n        };\n\n        auto get = [&](int idx){\n            return pi(idx/m, idx%m);\n        };\n\n        auto dist = [&](pi p, pi q){\n            return abs(p.fi-q.fi) + abs(p.se-q.se);\n        };\n\n        int sz = n*m;\n\n        mat s(n,vec(m));\n        mat a(sz, vec(sz));\n        vec b(sz);\n        rep(i,n)rep(j,m){\n            scanf(\" %d\", &s[i][j]);\n            b[ID(i,j)] = s[i][j];\n        }\n\n        rep(i,sz)rep(j,sz){\n            if(i==j || dist(get(i), get(j)) == d) a[i][j] = 1;\n        }\n\n        mat ab(sz, vec(sz+1));\n        rep(i,sz){\n            rep(j,sz) ab[i][j] = a[i][j];\n            ab[i][sz] = b[i];\n        }\n\n        printf(\"%d\\n\", mat_rank(a) == mat_rank(ab));\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint fie[28][28];\nint dx[4]={1,1,-1,-1};\nint dy[4]={1,-1,1,-1};\nint lane[1000];\nint m,n,d;\n\nbool check(const vec& x){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(x[lane[i*m+j]]==1){\n\t\t\t\tfie[i][j]^=1;\n\t\t\t\tfor(int k=-d;k<=d;k++){\n\t\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\t\tif(abs(k)==d && l==1)continue;\n\t\t\t\t\t\tint nx=j+k,ny=i+(d-abs(k))*dy[l];\n\t\t\t\t\t\tif(nx>=0 && nx<m && ny>=0 && ny<n){\n\t\t\t\t\t\t\tfie[ny][nx]^=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(fie[i][j]==1)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool solve(){\n\tmat A(m*n,vec(m*n));\n\tint N=A.size();\n\tmat B(N,vec(N+1));\n\tvec b(N);\n\tfor(int i=0;i<N;i++){\n\t\tlane[i]=i;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tA[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(fie[i][j]==0){\n\t\t\t\tb[i*m+j]=0;\n\t\t\t}else{\n\t\t\t\tb[i*m+j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tA[i*m+j][i*m+j]=1;\n\t\t\tfor(int k=-d;k<=d;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tif(abs(k)==d && l==1)continue;\n\t\t\t\t\tint nx=j+k,ny=i+(d-abs(k))*dy[l];\n\t\t\t\t\tif(nx>=0 && nx<m && ny>=0 && ny<n){\n\t\t\t\t\t\tA[i*m+j][ny*m+nx]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tB[i][j]=A[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tB[i][N]=b[i];\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tint pivot=i;\n\t\tfor(int j=i;j<N;j++){\n\t\t\tif(B[j][i]>B[pivot][i])pivot=j;\n\t\t}\n\t\tswap(B[i],B[pivot]);\n\t\tif(B[i][i]==0)B[i][i]=1;\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i!=j){\n\t\t\t\tfor(int k=i+1;k<=N;k++){\n\t\t\t\t\tB[j][k]^=B[j][i]*B[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvec x(N);\n\tfor(int i=0;i<N;i++){\n\t\tx[i]=B[i][N];\n\t}\n\treturn check(x);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d\",&m,&n,&d);\n\t\tif(m+n+d==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tscanf(\"%d\",&fie[i][j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",solve()?1:0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst int debug=0;\nconst Int MAX = (debug?30:30*30);\nusing BS = bitset<MAX*2>;\nvoid det(vector<BS> &v){\n  int n=v.size();\n  for(Int i=0;i<n;i++){\n    for(Int k=i;k<n;k++){\n      if(v[k][i]){\n\tswap(v[i],v[k]);\n\tbreak;\n      }\n    }\n    for(Int k=0;k<n;k++)\n      if(i!=k&&v[k][i]) v[k]^=v[i];\n  }\n}\n\nsigned main(){\n  int m,n,d;\n  while(cin>>m>>n>>d,m){\n    vector<vector<int> > s(n,vector<int>(m));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tcin>>s[i][j];\n    \n\n    vector<BS> v(n*m,BS(0));\n    auto idx=[&](int y,int x){return y*m+x;};\n    auto in=[&](int y,int x){return 0<=y&&y<n&&0<=x&&x<m;};\n    auto bfs=[&](int y,int x){\n      int z=idx(y,x);\n      v[z][z]=1;\n      v[z][n*m]=s[y][x];\n      \n      vector<vector<int> > dp(n,vector<int>(m,-1));\n      using P = pair<int, int>;\n      queue<P> q;\n      dp[y][x]=0;\n      q.emplace(y,x);\n      int dy[]={0,0,1,-1};\n      int dx[]={1,-1,0,0};\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(dp[y][x]==d) v[z][idx(y,x)]=1;\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=dp[y][x]+1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    auto u=v;\n    det(v);\n    int ans=1;\n    for(int i=0;i<n*m;i++){\n      int tmp=s[i/m][i%m];\n      for(int j=0;j<n*m;j++) tmp+=u[i][j]&v[j][n*m];\n      if(debug) cout<<i<<\" \"<<tmp<<endl;\n      ans&=!(tmp&1);\n    }\n    cout<<ans<<endl;\n    if(debug && m==4) return 0;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <algorithm>\n#define coor(i,j) ((i)+(j)*m)\n#define in(i,j) (0<=(i)&&(i)<m&&0<=(j)&&(j)<n)\nusing namespace std;\nvector<bitset<626> > M(625);\n\nint main(){\n\tint m,n,d;\n\tint i,j,k;\n\tint success,ans;\n\tfor(;cin>>m>>n>>d,d;cout<<ans<<endl){\n\t\t//create M\n\t\tfor(j=0;j<n;j++)\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tM[coor(i,j)].reset();\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<n;j++)\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tM[coor(i,j)][coor(i,j)]=1;\n\t\t\t\tcin>>k;M[coor(i,j)][m*n]=k;\n\n\t\t\t\tfor(k=0;k<=d;k++){\n\t\t\t\t\tif(in(i-k,j-(d-k)))M[coor(i,j)][coor(i-k,j-(d-k))]=1;\n\t\t\t\t\tif(in(i+k,j-(d-k)))M[coor(i,j)][coor(i+k,j-(d-k))]=1;\n\t\t\t\t\tif(in(i-k,j+(d-k)))M[coor(i,j)][coor(i-k,j+(d-k))]=1;\n\t\t\t\t\tif(in(i+k,j+(d-k)))M[coor(i,j)][coor(i+k,j+(d-k))]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t//solve\n\t\tk=0;\n\t\tfor(i=0;i<m*n;i++){\n\t\t\tfor(j=k;j<m*n&&!M[j][i];j++);\n\t\t\tif(j==m*n)continue;\n\t\t\tswap(M[k],M[j]);\n\t\t\tfor(j=k+1;j<m*n;j++)if(M[j][i])M[j]^=M[k];\n\t\t\tk++;\n\t\t}\n\n\t\t//finalize\n\t\tans=1;\n\t\tfor(j=k;j<m*n;j++)if(M[j][m*n])ans=0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\n\nusing namespace std;\n\nint main(){\n\tint m, n, d;\n\twhile(cin >> m >> n >> d, m){\n\t\tvector< vector<int> > v(n*m, vector<int>(n*m+1,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tcin >> v[i*m+j][n*m];\n\t\t\t\tfor(int ii=0;ii<n;ii++){\n\t\t\t\t\tfor(int jj=0;jj<m;jj++){\n\t\t\t\t\t\tint dist = abs(i-ii)+abs(j-jj);\n\t\t\t\t\t\tif(dist==0||dist==d) v[ii*m+jj][i*m+j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cur = 0;\n\t\tfor(int i=0;i<n*m;i++){\n\t\t\tint chg = cur;\n\t\t\twhile(chg<n*m && v[chg][i]==0) chg++;\n\t\t\tif(chg == n*m) continue;\n\t\t\tswap(v[cur], v[chg]);\n\t\t\tfor(int j=cur+1;j<n*m;j++){\n\t\t\t\tif(v[j][i]){\n\t\t\t\t\tfor(int k=i;k<n*m+1;k++)\n\t\t\t\t\t\tv[j][k] = (v[j][k]+v[cur][k])%2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\tint res = 1;\n\t\tfor(int i=cur;i<n*m;i++)\n\t\t\tif(v[i][n*m] == 1) res = 0;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nusing matrix = std::vector<std::vector<T>>;\n\nbool gauss_jordan(matrix<int>& A, vector<int> const& b) {\n    const int n = A.size();\n    matrix<int> B(n, vector<int>(n + 1));\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            B[i][j] = A[i][j];\n        }\n        B[i][n] = b[i];\n    }\n\n    int rank = 0;\n    for(int i = 0; i < n; ++i) {\n        int pivot = rank;\n        for(int j = rank + 1; j < n; ++j) {\n            if(B[j][i] == 1) {\n                pivot = j;\n                break;\n            }\n        }\n        if(B[pivot][i] == 0) {\n            continue;\n        }\n        swap(B[rank], B[pivot]);\n        for(int j = rank + 1; j < n; ++j) {\n            if(B[j][i] == 0) {\n                continue;\n            }\n            for(int k = 0; k <= n; ++k) {\n                B[j][k] ^= B[rank][k];\n            }\n        }\n        rank++;\n    }\n    for(int i = rank; i < n; ++i) {\n        if(B[i][n] == 1) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int m, n, d;\n    while(cin >> m >> n >> d, m) {\n        const int D = m * n;\n        matrix<int> A(D, vector<int>(D));\n        vector<int> b(D);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < m; ++j) {\n                cin >> b[i * m + j];\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < m; ++j) {\n                for(int i2 = 0; i2 < n; ++i2) {\n                    for(int j2 = 0; j2 < m; ++j2) {\n                        A[i * m + j][i2 * m + j2] = abs(i - i2) + abs(j - j2) == d;\n                    }\n                }\n                A[i * m + j][i * m + j] = 1;\n            }\n        }\n\n        cout << gauss_jordan(A, b) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main(){\n\tint m, n, d;\n\twhile(cin >> m >> n >> d, m){\n\t\tvector< vector<int> > v(n*m, vector<int>(n*m+1,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tcin >> v[i*m+j][n*m];\n\t\t\t\tfor(int ii=0;ii<n;ii++){\n\t\t\t\t\tfor(int jj=0;jj<m;jj++){\n\t\t\t\t\t\tint dist = abs(i-ii)+abs(j-jj);\n\t\t\t\t\t\tif(dist==0||dist==d) v[ii*m+jj][i*m+j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cur = 0;\n\t\tfor(int i=0;i<n*m;i++){\n\t\t\tint chg = cur;\n\t\t\twhile(chg<n*m && v[chg][i]==0) chg++;\n\t\t\tif(chg == n*m) continue;\n\t\t\tswap(v[cur], v[chg]);\n\t\t\tfor(int j=cur+1;j<n*m;j++){\n\t\t\t\tif(v[j][i]){\n\t\t\t\t\tfor(int k=i;k<n*m+1;k++)\n\t\t\t\t\t\tv[j][k] = (v[j][k]+v[cur][k])%2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\tint res = 1;\n\t\tfor(int i=cur;i<n*m;i++)\n\t\t\tif(v[i][n*m] == 1) res = 0;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N, D;\n  while (cin>>M>>N>>D && M) {\n    int S[25][25];\n    REP(i, M)REP(j, N) cin>>S[i][j];\n    int G[25 * 25][26] = {};\n    REP(i, M)REP(j, N){\n      REP(k, M)REP(l, N){\n        if(abs(i - k) + abs(j - l) == D || (i == k && j == l)){\n          G[i + M * j][k] |= 1<<l;\n        }\n      }\n      G[i + M * j][25] = S[i][j];\n    }\n    bool ans = true;\n    for(int i = 0; i < M * N; i++){\n      int pivot = -1;\n      for(int j = i; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))) pivot = j;\n      }\n      if(pivot == -1) continue;\n      int tmp[26];\n      //swap(G[i], G[pivot]);\n      memcpy(tmp, G[i], sizeof(tmp));\n      memcpy(G[i], G[pivot], sizeof(tmp));\n      memcpy(G[pivot], tmp, sizeof(tmp));\n      for(int j = 0; j < M * N; j++){\n        if(i != j && G[j][i / N] & (1 << (i % N))){\n          for(int k = 0; k < M; k++){\n            G[j][k] ^= G[i][k];\n          }\n          G[j][25] ^= G[i][25];\n        }\n      }\n    }\n    for(int i = M * N - 1; i >= 0; i--){\n      if(!(G[i][i / N] & (1 << (i % N))) && G[i][25]){\n        ans = false;\n      }\n    }\n    if(ans) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint W,H,D,s[25][25],a[625][625],b[625];\nint id(int i,int j){\n\treturn i*W+j;\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H>>D;\n\t\tif(W==0) break;\n\t\trep(i,H) rep(j,W) cin>>b[id(i,j)];\n\t\trep(i,H) rep(j,W) rep(k,H) rep(h,W){\n\t\t\ta[id(k,h)][id(i,j)]=0;\n\t\t\tint d=abs(i-k)+abs(j-h);\n\t\t\tif(d==D||d==0) a[id(k,h)][id(i,j)]=1;\n\t\t}\n\t\tbool used[625]={};\n\t\tint eq=H*W;\n\t\tint r=0;\n\t\trep(j,625){\n\t\t\tint i=0;\n\t\t\twhile(i<eq && (used[i]||a[i][j]==0)) i++;\n\t\t\tif(i==eq) continue;\n\t\t\tr++;\n\t\t\tused[i]=true;\n\t\t\trep(k,eq){\n\t\t\t\tif(i==k) continue;\n\t\t\t\tif(a[k][j]==0) continue;\n\t\t\t\trep(l,eq) a[k][l]^=a[i][l];\n\t\t\t\tb[k]^=b[i];\n\t\t\t}\n\t\t}\n\t\tbool can=true;\n\t\trep(i,eq) if(!used[i]&&b[i]!=0) can=false;\n\t\tcout<<can<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define INF 1000000007\n#define EPS 1e-10\n#define ll long long\n\nusing namespace std;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n                    X[i][j] += (*this)[i][k]*another[k][j];\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    int rank(){\n\t\tint n = this->r;\n\t    int m = this->c;\n\t    int res = 0;\n\t    mat B(n,m);\n\t    for(int i=0;i<n;i++){\n\t        for(int j=0;j<m;j++){\n\t\t\t\tB[i][j] = (*this)[i][j];\n\t\t\t}\n\t    }\n\t    for(int i=0;i<m;i++){\n\t        if(res == n) return res;\n\t        int pivot = res;\n\t        for(int j=res+1;j<n;j++){\n\t            if(abs(B[j][i]) > abs(B[pivot][i])){\n\t                pivot = j;\n\t            }\n\t        }\n\t        if(abs(B[pivot][i]) < EPS) continue;\n\t        swap(B[pivot],B[res]);\n\t        for(int j=i+1;j<m;j++){\n\t            B[res][j] /= B[res][i];\n\t        }\n\t        for(int j=res+1;j<n;j++){\n\t            for(int k=i+1;k<m;k++){\n\t                B[j][k] -= B[res][k]*B[j][i];\n\t            }\n\t        }\n\t        res++;\n\t    }\n\t    return res;\n\t}\n    T det(){\n        if(this->r != this->c){\n            cout << \"正方行列でない(行列式定義不可)\" << endl;\n            exit(1);\n        }\n        T ans = 1;\n        int n = this->r;\n        mat B(n,n);\n        rep(i,n){\n            rep(j,n){\n                B[i][j] = (*this)[i][j];\n            }\n        }\n        rep(i,n) {\n            for(int j=i+1;j<n;j++){\n                for (; B[j][i] != 0; ans = -ans) {\n                    T r = B[i][i] / B[j][i];\n                    for(int k=i;k<n;k++) {\n                        T t = B[i][k] - r * B[j][k];\n                        B[i][k] = B[j][k];\n                        B[j][k] = t;\n                    }\n                }\n           }\n           ans *= B[i][i];\n       }\n       return ans;\n    }\n    mat inverse(){\n        if(this->r != this->c){\n            cout << \"正方行列でない(逆行列定義不可)\" << endl;\n            exit(1);\n        }\n        int n = this->r;\n        mat B(n,2*n);\n        rep(i,n){\n            rep(j,n){\n                B[i][j] = (*this)[i][j];\n            }\n        }\n        rep(i,n){\n            B[i][n+i] = 1;\n        }\n        rep(i,n){\n            int pivot = i;\n            for(int j=i;j<n;j++){\n                if(abs(B[j][i]) > abs(B[pivot][i])){\n                    pivot = j;\n                }\n            }\n            if(abs(B[pivot][i]) < EPS){\n                cout << \"解なしor不定\" << endl;\n                exit(1);\n            }\n            swap(B[i],B[pivot]);\n            for(int j=i+1;j<=2*n;j++){\n                B[i][j] /= B[i][i];\n            }\n            rep(j,n){\n                if(i != j){\n                    for(int k=i+1;k<=2*n;k++){\n                        B[j][k] -= B[j][i] * B[i][k];\n                    }\n                }\n            }\n        }\n        mat res(n,n);\n        rep(i,n){\n            rep(j,n){\n                res[i][j] = B[i][n+j];\n            }\n        }\n        return res;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> bool eq_solve(const mat<T>& A,const vector<T>& b){\n    if(A.row() != A.column()){\n        cout << \"正方行列でない(解なしor不定)\" << endl;\n        exit(1);\n    }\n    int n = A.row();\n    mat<T> B(n,n+1);\n    rep(i,n){\n        rep(j,n){\n            B[i][j] = A[i][j];\n        }\n    }\n    rep(i,n){\n        B[i][n] = b[i];\n    }\n    rep(i,n){\n        int pivot = i;\n        for(int j=i;j<n;j++){\n            if(abs(B[j][i]) > abs(B[pivot][i])){\n                pivot = j;\n            }\n        }\n        if(abs(B[pivot][i]) < EPS){\n            bool ok = true;\n            for(int j=i;j<n;j++){\n                if(B[j][n] > EPS){\n                    ok = false;\n                    break;\n                }\n            }\n            return ok;\n        }\n        swap(B[i],B[pivot]);\n        for(int j=i+1;j<=n;j++){\n            B[i][j] /= B[i][i];\n        }\n        rep(j,n){\n            if(i != j){\n                for(int k=i+1;k<=n;k++){\n                    B[j][k] ^= B[j][i] * B[i][k];\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int m,n,d;\n        cin >> m >> n >> d;\n        if(m == 0) break;\n        vector<vector<int> > vec(n,vector<int>(m));\n        rep(i,n){\n            rep(j,m){\n                cin >> vec[i][j];\n            }\n        }\n        mat<int> A(n*m,n*m);\n        vector<int> b(n*m);\n        rep(i,n){\n            rep(j,m){\n                A[i*m+j][i*m+j] = 1;\n                rep(k,d){\n                    int x = i-d+k, y = j+k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                rep(k,d){\n                    int x = i+k, y = j+d-k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                rep(k,d){\n                    int x = i+d-k, y = j-k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                rep(k,d){\n                    int x = i-k, y = j-d+k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                b[i*m+j] = vec[i][j];\n            }\n        }\n        cout << eq_solve(A,b) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define eps 1e-9\n\nusing namespace std;\n\nint m, n, d, N;\nint mat[650][650];\n\nvoid swapRow(int x, int y)\n{\n\tint t;\n\tfor(int i = 0; i < N+1; i++){\n\t\tt = mat[x][i];\n\t\tmat[x][i] = mat[y][i];\n\t\tmat[y][i] = t;\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> m >> n >> d;\n\t\tif(m == 0 && n == 0 & d == 0) break;\n\t\t\n\t\tN = m*n;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tfor(int ii = 0; ii < n; ii++){\n\t\t\t\t\tfor(int jj = 0; jj < m; jj++){\n\t\t\t\t\t\tif( abs(i - ii) + abs(j - jj) == d){\n\t\t\t\t\t\t\tmat[i*m+j][ii*m+jj] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i == ii && j == jj) mat[i*m+j][ii*m+jj] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s;\n\t\t\tmat[i][N] = s;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint piv, val = 0;\n\t\t\tfor(int j = i; j < N; j++){\n\t\t\t\tif(val < mat[j][i]){\n\t\t\t\t\tval = mat[j][i];\n\t\t\t\t\tpiv = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(val == 0) continue;\n\t\t\tswapRow(i, piv);\n\t\t\t\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(mat[j][i] == 0) continue;\n\t\t\t\tfor(int k = 0; k < N+1; k++){\n\t\t\t\t\tmat[j][k] += mat[i][k];\n\t\t\t\t\tmat[j][k] %= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tbool ans = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(mat[i][i] == 0 && mat[i][N] == 1){\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\n\n// binary行列の掃き出し法と行列累乗\n// bitset高速化により、定数倍速い\n\nconst int MAX_ROW = 1000;\nconst int MAX_COL = 1000;\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m, int n) : H(m), W(n) {}\n    inline bitset<MAX_COL> & operator [] (int i) { return val[i]; }\n};\ninline BitMatrix operator * (BitMatrix A, BitMatrix B) {\n    BitMatrix R(A.H, B.W);\n    BitMatrix tB(B.W, B.H);\n    for (int i = 0; i < tB.H; i++) for (int j = 0; j < tB.W; j++) tB[i][j] = B[j][i];\n    for (int i = 0; i < R.H; i++) for (int j = 0; j < R.W; j++) R[i][j] = ((A[i] & tB[j]).count() & 1);\n    return R;\n}\ninline BitMatrix pow(BitMatrix A, ll  n) {\n    BitMatrix R(A.H, A.H);\n    for (int i = 0; i < A.H; ++i) R[i][i] = 1;\n    while (n > 0) { if (n & 1) R = R * A; A = A * A; n >>= 1; }\n    return R;\n}\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; col++) {\n        if (is_extended && col == A.W - 1) break; // 拡大係数行列。この場合、最後の列は掃き出さない\n        int pivot = -1;\n        for (int row = rank; row < A.H; row++) if (A[row][col]) { pivot = row; break; }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; row++) if (row != rank && A[row][col]) A[row] ^= A[rank];\n        rank++;\n    }\n    return rank;\n}\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n    for (int row = rank; row < m; row++) if (M[row][n]) return -1; // check if it has no solution\n    res.assign(n, 0);\n    for (int i = 0; i < rank; i++) res[i] = M[i][n];\n    return rank;\n}\n\n\n// verified\n//  https://atcoder.jp/contests/code-thanks-festival-2017/tasks/code_thanks_festival_2017_f\n\n// verified\n//  https://atcoder.jp/contests/abc141/tasks/abc141_f\n\n// verified\n//  https://yukicoder.me/problems/no/184\n\n// verified\n//  https://yukicoder.me/problems/no/803\n\n// verified\n//  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1308&lang=en\nvoid AOJ_Awkward_Lights() {\n    int m, n, d;\n    while (true) {\n        cin >> m >> n >> d;\n        if (m == 0) break;\n        vector <vector<int>> s(n, vector<int>(m));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> s[i][j];\n            }\n        }\n        BitMatrix A(n * m, n * m);\n        vector<int> b(n * m), res;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                A[i * m + j][i * m + j] = 1;\n                b[i * m + j] = 1 - s[i][j];\n                for (int k = 0; k < n; k++) {\n                    for (int l = 0; l < m; l++) {\n                        if (abs(i - k) + abs(j - l) == d) A[i * m + j][k * m + l] = 1;\n                    }\n                }\n            }\n        }\n        cout << (linear_equation(A, b, res) == -1 ? 0 : 1) << '\\n';\n    }\n}\n\nint main() {\n    AOJ_Awkward_Lights();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n\nint modNorm(int a, int m) {\n  return (a%m+m)%m;\n}\n\n// ax+by=gcd(a,b)\nint extgcd(int a, int b, int &x, int &y) {\n  int g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nint invMod(int a, int p) {\n  int x, y;\n  if (extgcd(a,p,x,y) == 1) return (x+p)%p;\n  return 0;\n}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nostream &operator<<(ostream &os, const vec &a) {\n  FOR(it, a) os << *it << \" \";\n  return os;\n}\nostream &operator<<(ostream &os, const mat &a) {\n  FOR(it, a) os << *it << endl;\n  return os;\n}\n\nbool modGaussElimination(const mat &A, const vec &b, int m, vec &res) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  REP(i,n) REP(j,n)\n    B[i][j] = A[i][j];\n  REP(i, n) B[i][n] = b[i];\n  \n  //cout << B << endl;\n  int nowy = 0;\n  REP(x, n) {\n    int pivot = -1;\n    for (int j=nowy; j<n; ++j)\n      if (B[j][x]) {\n        pivot = j;break;\n      }\n    if (pivot == -1) continue;\n    swap(B[nowy], B[pivot]);\n\n    for (int j=nowy+1; j<n; ++j) {\n      int t = B[j][x] * invMod(B[nowy][x], m) % m;\n      if (t)\n        for (int k=x; k<=n; ++k)\n          B[j][k] = modNorm(B[j][k] - B[nowy][k] * t, m);\n    }\n    nowy++;\n  }\n  res.clear();\n  for (int y=nowy; y<n; ++y)\n    if (B[y][n])                // rank(A) != rank(A|b)\n      return 0;\n  if (nowy != n) {              // rank(A) == rank(A|b) != n\n    // 解が一意でない。ひとつ求める\n    res = vec(n,INF);           // INFは任意を表す\n    for (int y=n-1; y>=0; --y) {\n      int x;\n      for (x=y; x<n; ++x) {\n        if (B[y][x])\n          break;\n      }\n      if (x==n) continue;\n      int sum = B[y][n];\n      \n      for (int i=x+1; i<n; ++i) {\n        if (res[i] == INF) res[i] = 0; // この時点でres[i]が決まってなかったら0とする\n        sum = modNorm(sum - res[i] * B[y][i], m);\n      }\n      res[x] = sum * invMod(B[y][x], m) % m;\n    }\n    REP(i, n) if (res[i]==INF) res[i] = 0;\n    return 0;\n  }\n  // 解が一意に決まる。普通に後退代入\n  res.resize(n);\n  for (int x=n-1; x>=0; --x) {\n    int sum = B[x][n];\n    for (int i=n-1; i>x; --i) {\n      sum = modNorm(sum - res[i] * B[x][i], m); \n    }\n    res[x] = sum * invMod(B[x][x], m) % m;\n  }\n  \n  return 1;\n}\n\nint main() {\n  int m, n, d;\n  int c = 0;\n  while(cin>>m>>n>>d, m||n||d) {\n    bool ba[n][m];\n    mat A(n*m, vec(n*m));\n    vec b(n*m);\n    REP(i,n) {\n      REP(j,m) {\n        cin >> ba[i][j];\n        A[i*m+j][i*m+j] = 1;\n        REP(k,n) {\n          REP(l,m) {\n            int dis = abs(i-k)+abs(j-l);\n            if (dis == d) {\n              A[i*m+j][k*m+l] = 1;\n            }\n          }\n        }\n        b[i*m+j] = ba[i][j];\n      }\n    }\n    vec x;\n    modGaussElimination(A,b,2,x);\n    cout << (x.size() != 0) << endl;\n    \n    // if (x.size()) {             // 解法表示\n    //   REP(i, n) {\n    //     REP(j, m) {\n    //       cout << x[i*m+j] << \" \";\n    //     }\n    //     cout << endl;\n    //   }\n    // } else\n    //   cout << \"no solution\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nint M, N, D, S[32][32];\nbitset<640> bits[640];\n\nbool solve(int n) {\n    int h = 0;\n    rep(k, n) {\n        int ix = -1;\n        for(int i=h; i<n; i++) if(bits[i][k]) { ix=i; break; }\n        if(ix==-1) continue;\n        if(h!=ix) swap(bits[h], bits[ix]);\n        rep(i, n) if(i!=h) if(bits[i][k]) bits[i] ^= bits[h];\n        h++;\n    }\n    for(int i=h; i<n; i++) if(bits[i][n]) return false;\n    return true;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d%d%d\", &M, &N, &D);\n        if(M==0 && N==0 && D==0) return 0;\n        rep(i, N) rep(j, M) scanf(\"%d\", S[i]+j);\n        const int n = N*M;\n        rep(i, N) rep(j, M) {\n            const int ix = i*M+j;\n            bits[ix].reset();\n            bits[ix].set(ix);\n            if(S[i][j]) bits[ix].set(n);\n            rep(x, N) rep(y, M) if(abs(i-x)+abs(j-y)==D) bits[ix].set(x*M+y);\n        }\n        printf(\"%d\\n\", (int)solve(n));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef unsigned long long wolf;\nvector<wolf>v[700];\nint d[30][30];\nint ABS(int a){return max(a,-a);}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&b,&a,&c),a){\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&d[i][j]);\n\t\tint sz=a*b/64+1;\n\t\tint n=a*b;\n\t\tfor(int i=0;i<n;i++)v[i]=vector<wolf>(sz,0);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tint dis=ABS(i-k)+ABS(j-l);\n\t\t\t\tif(dis==0||dis==c){\n\t\t\t\t\tv[i*b+j][(k*b+l)/64]^=(1LL<<((k*b+l)%64));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint last=a*b%64;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(d[i][j])v[i*b+j][sz-1]+=(1LL<<last);\n\t\t\t}\n\t\t}\n\t/*\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<sz;j++)printf(\"%llu \",v[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t*/\tfor(int i=0;i<n;i++){\n\t\t\tint at=-1;\n\t\t\tfor(int j=i;j<n;j++){\n\t\t\t\tif(v[j][i/64]&(1LL<<(i%64))){at=j;break;}\n\t\t\t}\n\t\t\tif(!~at)continue;\n\t\t\tif(i!=at)swap(v[i],v[at]);\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(j==i)continue;\n\t\t\t\tif(v[j][i/64]&(1LL<<(i%64))){\n\t\t\t\t\tfor(int k=0;k<sz;k++)v[j][k]^=v[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(v[i][sz-1]&(1LL<<last)){\n\t\t\t\tbool OK=false;\n\t\t\t\tfor(int j=0;j<n;j++)if(v[i][j/64]&(1LL<<(j%64)))OK=true;\n\t\t\t\tif(!OK)ok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok)printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nbool gauss_jordan(const mat& A,const vec& b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  \n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  \n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++)if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    swap(B[i],B[pivot]);\n    for(int j=0;j<n;j++)\n      if(i!=j&&B[j][i])\n\tfor(int k=i;k<=n;k++)B[j][k]=(B[j][k]+B[i][k])%2;\n  }\n  for(int i=0;i<n;i++)if(B[i][i]==0&&B[i][n]==1) return 0;\n  return 1;\n}\n\nint h,w,d,mp[25][25];\nint main(){\n  while(1){\n    cin>>w>>h>>d;\n    if(!w&&!h&&!d)break;\n    mat A(h*w,vec(h*w));\n    vec B(h*w);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>mp[i][j];\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tint idx=w*i+j;\n\tB[idx] = mp[i][j];\n\tfor(int y=0;y<h;y++)\n\t  for(int x=0;x<w;x++){\n\t    int t = abs(i-y)+abs(j-x);\n\t    if(t==d||t==0)A[idx][w*y+x]=1;\t\t\t\t\n\t  }\n      }\n    cout<<gauss_jordan(A,B)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <algorithm>\n\n#define coor(i,j) ((i)+(j)*m)\n#define in(i,j) (0<=(i)&&(i)<m&&0<=(j)&&(j)<n)\nusing namespace std;\nvector<bitset<626> > M(625);\n\nmain(){\n\tint m,n,d;\n\tint i,j,k;\n\tint success,ans;\n\tfor(;cin>>m>>n>>d,d;cout<<ans<<endl){\n\t\t//create M\n\t\tfor(j=0;j<n;j++)\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tM[coor(i,j)].reset();\n\t\t\t\tM[coor(i,j)][coor(i,j)]=1;\n\t\t\t\tcin>>k;M[coor(i,j)][m*n]=k;\n\n\t\t\t\tfor(k=0;k<=d;k++){\n\t\t\t\t\tif(in(i-k,j-(d-k)))M[coor(i-k,j-(d-k))][coor(i,j)]=1;\n\t\t\t\t\tif(in(i+k,j-(d-k)))M[coor(i+k,j-(d-k))][coor(i,j)]=1;\n\t\t\t\t\tif(in(i-k,j+(d-k)))M[coor(i-k,j+(d-k))][coor(i,j)]=1;\n\t\t\t\t\tif(in(i+k,j+(d-k)))M[coor(i+k,j+(d-k))][coor(i,j)]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t//solve\n\t\tk=0;\n\t\tfor(i=0;i<m*n;i++){\n\t\t\tfor(j=k;j<m*n&&!M[j][i];j++);\n\t\t\tif(j==m*n)continue;\n\t\t\tswap(M[k],M[j]);\n\t\t\tfor(j=k+1;j<m*n;j++)if(M[j][i])M[j]^=M[k];\n\t\t\tk++;\n\t\t}\n\n\t\t//finalize\n\t\tans=1;\n\t\tfor(j=k;j<m*n;j++)if(M[j][m*n])ans=0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\n\nconst int mod = 2;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n/* verified AOJ1327 One-Dimensional Cellular Automaton\n~Matrix~\n??????????°????????¨?????????§??????\nvector iostream cmath cassert ??????\nMatrix a(VV), b(VV);\n?????????:a*b\n????????????:l*a\n???:a+b\n???:a-b\n??¢???:a.transport()\n?????????:a.cofactor()\n?????????:a.det()\na???i???j??????:a.get(i,j)???\na???i??????j?????????k?????£??\\:set(i,j,k)\n????????????a[i][j] (a[i][j]=k)\na???x???:a.pow(x)\nn*n?????¬??????E:Matrix(n)\nm*n 0??????:Matrix(m,n)\nm*n ??¨????´????p?????????:Matrix(m,n,p)\nRow???row??§????????????(m*1??????):Matrix(row)\n**(??´??°??????)**\n????§????:a.triangulate()\n?????????:a.rank()\n?????????:a.inverse()\n//(????????????a.det()?????????a.pre_inverse()??§?±??????? ??´??°???)\n??¬??????????¶???????:a.rowReduction()\n//??£???????¬?????¨????????§£??????\n***\n*/\n\n#include <vector>\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ntypedef Mod Elem;\ntypedef vector<Elem> Row;\ntypedef vector<Row> VV;\n\ntypedef long double ld;\nconst ld EPS = 1e-11;\n\nconst bool isZero(const Elem e) {\n\treturn e.num==0;\n}\n\nstruct Matrix {\n\tVV matrix;\n\tint n, m;\n\n\tMatrix(const VV &matrix_);\n\texplicit Matrix(int n_);\n\texplicit Matrix(const Row &row);\n\tMatrix(int m_, int n_);\n\tMatrix(int m_, int n_, Elem e);\n\n\tconst Elem get(const int i, const int j) const;\n\tvoid set(const int x, const int y, const Elem k);\n\n\tconst Matrix operator + (const Matrix &rhs) const;\n\tconst Matrix operator * (const Matrix &rhs) const;\n\tconst Matrix operator - (const Matrix &rhs) const;\n\tMatrix &operator += (const Matrix &rhs);\n\tMatrix &operator *= (const Matrix &rhs);\n\tMatrix &operator -= (const Matrix &rhs);\n\n\tRow &operator[](const int x);\n\n\tconst Matrix transport() const;\n\tconst Matrix pow(int x) const;\n\tconst Matrix cofactor(int x, int y) const;\n\tconst Elem det() const;\n\n\tconst Matrix triangulate() const;\n\tconst int rank() const;\n\n\t//?????????????????¨????????°???(?????????)*(?????????)?????????\n\t//A:matrix,return det A * A^-1\n\tconst Matrix pre_inverse() const;\n\tconst Matrix inverse() const;\n\tconst Matrix rowReduction() const;\n};\n\nconst Matrix operator * (const Elem lambda, const Matrix &rhs) {\n\tMatrix tmp(rhs);\n\tfor (int i = 0; i < rhs.m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++)\n\t\t\ttmp.set(i, j, tmp.get(i, j) * lambda);\n\treturn tmp;\n}\n\nMatrix::Matrix(const VV &matrix_) : matrix(matrix_) {\n\tm = matrix_.size();\n\tif (m == 0) n = 0;\n\telse n = matrix_[0].size();\n}\nMatrix::Matrix(int n_) : m(n_), n(n_) {\n\tmatrix = VV(n, Row(n, 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tset(i, i, 1);\n}\nMatrix::Matrix(const Row &row) : m(1), n(row.size()), matrix(VV(1, row)) {\n\t//size???m???vector<Elem>??????mx1???????????????\n\t(*this) = transport();\n}\nMatrix::Matrix(int m_, int n_) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, 0));\n}\nMatrix::Matrix(int m_, int n_, Elem e) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, e));\n}\n\nconst Elem Matrix::get(const int i, const int j) const {\n\tif (0 <= i && i < m && 0 <= j && j < n)\n\t\treturn matrix[i][j];\n\n\tcerr << \"get(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\nvoid Matrix::set(const int i, const int j, const Elem k) {\n\tif (0 <= i && i < m && 0 <= j && j < n) {\n\t\t*(matrix[i].begin() + j) = k;\n\t\treturn;\n\t}\n\tcerr << \"set(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\n\nconst Matrix Matrix::operator + (const Matrix &rhs) const {\n\tassert(m == rhs.m && n == rhs.n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ttmp.set(i, j, get(i, j) + rhs.get(i, j));\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator * (const Matrix &rhs) const {\n\tassert(n == rhs.m);\n\n\tMatrix tmp(m, rhs.n, 0);\n\tElem sum;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tsum += get(i, k) * rhs.get(k, j);\n\t\t\t}\n\t\t\ttmp.set(i, j, sum);\n\t\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator - (const Matrix &rhs) const {\n\treturn *this + ((Elem)-1 * rhs);\n}\n\nMatrix &Matrix::operator += (const Matrix &rhs) {\n\treturn *this = *this + rhs;\n}\n\nMatrix &Matrix::operator *= (const Matrix &rhs) {\n\treturn *this = *this * rhs;;\n}\n\nMatrix &Matrix::operator -= (const Matrix &rhs) {\n\treturn *this = *this - rhs;\n}\n\nRow &Matrix::operator[](const int x) {\n\treturn matrix[x];\n}\n\nconst Matrix Matrix::transport() const {\n\tVV tmp;\n\tfor (int i = 0; i < n; i++) {\n\t\tRow row;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\trow.push_back(get(j, i));\n\t\ttmp.push_back(row);\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::pow(int x) const {\n\tMatrix tmp(*this), e(m);\n\tfor (int i = 1; i <= x; i <<= 1) {\n\t\tif ((x & i) > 0)\n\t\t\te = e * tmp;\n\t\ttmp = tmp * tmp;\n\t}\n\treturn e;\n}\n\nconst Matrix Matrix::cofactor(int x, int y) const {\n\tVV tmp;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (x == i) continue;\n\t\tRow row;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (y == j) continue;\n\t\t\trow.push_back(get(i, j));\n\t\t}\n\t\ttmp.push_back(row);\n\t}\n\treturn Matrix(tmp);\n}\n\nconst Elem Matrix::det() const {\n\tassert(n == m);\n\n\tif (m == 1)\n\t\treturn get(0, 0);\n\tElem sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum += ((i % 2 == 0 ? 1 : -1) * get(i, 0)) * Matrix(cofactor(i, 0)).det();\n\t}\n\treturn sum;\n}\n\nconst Matrix Matrix::triangulate() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\te = tmp.get(j, p) / tmp.get(i, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst int Matrix::rank() const {\n\tMatrix tmp(triangulate());\n\tfor (int i = min(tmp.m - 1, tmp.n - 1); i >= 0; i--) {\n\t\tfor (int j = tmp.n - 1; j >= i; j--)\n\t\t\tif (isZero(tmp.get(i, j)))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn i + 1;\n\t}\n\treturn 0;\n}\n\nconst Matrix Matrix::pre_inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, ((i + j) % 2 == 0 ? 1 : -1)*cofactor(i, j).det());\n\treturn tmp.transport();\n}\n\n/*O(n!)????£?\nconst Matrix Matrix::inverse() const {\nMatrix tmp(pre_inverse());\nElem e = det();\nassert(!isZero(e));\ntmp = 1 / e * tmp;\nreturn tmp.transport();\n}*/\n\nconst Matrix Matrix::inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n * 2), tmp2(m, n);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, get(i, j));\n\tfor (int i = 0; i < m; i++)\n\t\ttmp.set(i, i + n, 1);\n\n\ttmp = tmp.rowReduction();\n\n\t//?????????????????¨??????????????????????????§??????\n\tfor (int i = 0; i < m; i++)\n\t\tassert(isZero(tmp.get(i, i) - 1));\n\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp2.set(i, j, tmp.get(i, j + n));\n\n\treturn tmp2;\n}\n\n/*\na b c j\nd e f k\ng h i l\n\nax+by+cz=j;\ndx+ey+fz=k;\ngx+hy+iz=l;\n\n|\nV\n\n1 0 0 x\n0 1 0 y\n0 0 1 z\n???????????????\n*/\nconst Matrix Matrix::rowReduction() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\te = 1 / tmp.get(i, p);\n\t\ttmp.set(i, p, 1);\n\t\tfor (int k = i + 1; k < n; k++)\n\t\t\ttmp.set(i, k, tmp.get(i, k)*e);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i == j) continue;\n\t\t\te = tmp.get(j, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nint main() {\n\twhile (1) {\n\t\tint M, N, D; cin >> M >> N >> D;\n\t\tif (!M)break;\n\t\tvector<vector<int>>field(N, vector<int>(M));\n\t\tvector<vector<Mod>>gyou(N*M,vector<Mod>(N*M+1));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tconst int ahash = i*M + j;\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tgyou[ahash][N*M] = field[i][j];\n\t\t\t\tgyou[ahash][ahash] = 1;\n\t\t\t\tfor (int dy = -D; dy <= D; ++dy) {\n\t\t\t\t\t{\n\t\t\t\t\t\tconst int dx = D - abs(dy);\n\t\t\t\t\t\tconst int nx = j + dx;\n\t\t\t\t\t\tconst int ny = i + dy;\n\t\t\t\t\t\tif (nx >= 0 && nx < M&&ny >= 0 && ny < N) {\n\t\t\t\t\t\t\tconst int nhash = ny*M + nx;\n\t\t\t\t\t\t\tgyou[ahash][nhash] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t{\n\t\t\t\t\t\tconst int dx =-( D - abs(dy));\n\t\t\t\t\t\tconst int nx = j + dx;\n\t\t\t\t\t\tconst int ny = i + dy;\n\t\t\t\t\t\tif (nx >= 0 && nx < M&&ny >= 0 && ny < N) {\n\t\t\t\t\t\t\tconst int nhash = ny*M+ nx;\n\t\t\t\t\t\t\tgyou[ahash][nhash] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tMatrix mat(gyou);\n\t\tmat = mat.rowReduction();\n\t\tvector<int>nums(N*M);\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N*M; ++i) {\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j <=N*M; ++j) {\n\t\t\t\tif (j == N*M) {\n\t\t\t\t\tif (!flag&&mat[i][j])ok = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (mat[i][j].num) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tnums[j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << ok << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N, D;\n  while (cin>>M>>N>>D && M) {\n    int S[25][25];\n    REP(i, M)REP(j, N) cin>>S[i][j];\n    int G[25 * 25][26] = {};\n    REP(i, M)REP(j, N){\n      REP(k, M)REP(l, N){\n        if(abs(i - k) + abs(j - l) == D || (i == k && j == l)){\n          G[i + M * j][k] |= 1<<l;\n        }\n      }\n      G[i + M * j][25] = S[i][j];\n    }\n    bool ans = true;\n    for(int i = 0; i < M * N; i++){\n      int pivot = -1;\n      for(int j = i; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))) pivot = j;\n      }\n      if(pivot == -1) continue;\n      int tmp[26];\n      //swap(G[i], G[pivot]);\n      memcpy(tmp, G[i], sizeof(tmp));\n      memcpy(G[i], G[pivot], sizeof(tmp));\n      memcpy(G[pivot], tmp, sizeof(tmp));\n      for(int j = 0; j < M * N; j++){\n        if(i != j && (G[j][i / N] & (1 << (i % N)))){\n          for(int k = 0; k < M; k++){\n            G[j][k] ^= G[i][k];\n          }\n          G[j][25] ^= G[i][25];\n        }\n      }\n    }\n    for(int i = M * N - 1; i >= 0; i--){\n      if(!(G[i][i / N] & (1 << (i % N))) && G[i][25]){\n        ans = false;\n      }\n    }\n    if(ans) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <cassert>\nusing namespace std;\n\n// mod2 行列ライブラリ (bitset を使って高速化、横は SIZE 固定とする)\n// TODO: 乗算の verify\nstruct BinaryMatrix {\n    int H, W;\n    static const int SIZE = 2010;\n    vector< bitset<SIZE> > mat;\n    BinaryMatrix(int H_, int W_) : H(H_), W(W_), mat(H_) {}\n\n    // 乗算に使用 (これ微妙に転置じゃないけどなんていうんだ)\n    BinaryMatrix T(const BinaryMatrix& A) {\n        int h = A.H, w = A.W;\n        BinaryMatrix res(w, h);\n        for(int i=0; i<h; i++) {\n            for(int j=0; j<w; j++) {\n                res[j][i] = A[i][j];\n            }\n        }\n        return res;\n    }\n\n    BinaryMatrix& operator*=(const BinaryMatrix& rhs) {\n        assert(W == rhs.H);\n        BinaryMatrix res(H, rhs.W), trhs = T(rhs);\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<rhs.W; j++) {\n                res[i][j] = (mat[i] & trhs[j]).count() % 2;\n            }\n        }\n        return (*this = res);\n    }\n    BinaryMatrix& operator+=(const BinaryMatrix &rhs) {\n        assert(H == rhs.H and W == rhs.W);\n        for(int i=0; i<H; i++) mat[i] ^= rhs[i];\n        return *this;\n    }\n    BinaryMatrix& operator-=(const BinaryMatrix &rhs) {\n        return (*this += rhs);\n    }\n\n    BinaryMatrix operator*(const BinaryMatrix &rhs) {\n        return (BinaryMatrix(*this) *= rhs);\n    }\n    BinaryMatrix operator+(const BinaryMatrix &rhs) {\n        return (BinaryMatrix(*this) += rhs);\n    }\n    BinaryMatrix operator-(const BinaryMatrix &rhs) {\n        return (BinaryMatrix(*this) -= rhs);\n    }\n\n    bool operator==(const BinaryMatrix &rhs) const {\n        if(H != rhs.H or W != rhs.W) return false;\n        for(int i=0; i<H; i++) if(mat[i] != rhs[i]) return false;\n        return true;\n    }\n    bool operator!=(const BinaryMatrix &rhs) const {\n        return !(*this == rhs);\n    }\n\n    const bitset<SIZE>& operator[](int k) const { return mat[k]; }\n    bitset<SIZE>& operator[](int k) { return mat[k]; }\n};\n\nBinaryMatrix eigen(size_t N) {\n    BinaryMatrix res(N, N);\n    for(size_t i=0; i<N; i++) res[i][i] = 1;\n    return res;\n}\n\nBinaryMatrix pow(BinaryMatrix mat, long long int k) {\n    BinaryMatrix res = eigen(mat.H);\n    for(; k>0; k>>=1) {\n        if(k & 1) res *= mat;\n        mat *= mat;\n    }\n    return res;\n}\n\nint gaussianEliminationBinary(BinaryMatrix &mat, bool ext=false) {\n    int N = mat.H, M = mat.W, rank = 0;\n    for(int j=0; j+ext<M; j++) {\n        int piv = -1;\n        for(int i=rank; i<N; i++) {\n            if(mat[i][j] != 0) piv = i, i = N;\n        }\n        if(piv < 0) continue;\n        swap(mat[rank], mat[piv]);\n        for(int i=0; i<N; i++) {\n            if(i == rank or mat[i][j] == 0) continue;\n            mat[i] ^= mat[rank];\n        }\n        rank++;\n    }\n    return rank;\n}\n\nvector<int> linearEquationBinary(BinaryMatrix A, vector<int> b) {\n    int N = A.H, M = A.W;\n    BinaryMatrix mat(N, M+1);\n    for(int i=0; i<N; i++) {\n        for(int j=0; j<=M; j++) {\n            mat[i][j] = (j < M ? A[i][j] : b[i]);\n        }\n    }\n\n    int rank = gaussianEliminationBinary(mat, true);\n    vector<int> res(N);\n    for(int i=0; i<N; i++) {\n        res[i] = mat[i][M];\n        if(i >= rank and mat[i][M] != 0) return {};\n    }\n    return res;\n}\n\nint detBinary(BinaryMatrix A) {\n    int N = A.H;\n    for(int j=0; j<N; j++) {\n        int piv = -1;\n        for(int i=j; i<N; i++) {\n            if(A[i][j] != 0) piv = i, i = N;\n        }\n        if(piv < 0) return 0;\n        swap(A[piv], A[j]);\n        for(int i=j+1; i<N; i++) {\n            if(A[i][j]) A[i] ^= A[j];\n        }\n    }\n    int res = 1;\n    for(int i=0; i<N; i++) res *= A[i][i];\n    return res;\n}\n\nint solve_testcase() {\n    int W, H, D; cin >> W >> H >> D;\n    if(W == 0 and H == 0 and D == 0) return 1;\n\n    vector< vector<int> > A(H, vector<int>(W));\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            cin >> A[i][j];\n        }\n    }\n\n    auto get_idx = [&](int r, int c) {\n        return r * W + c;\n    };\n\n    int N = H * W;\n    BinaryMatrix mat(N, N);\n    vector<int> vec(N);\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            int x = get_idx(i, j);\n            mat[x][x] = 1;\n            vec[x] = A[i][j];\n            \n            for(int dx=0; dx<=D; dx++) {\n                int dy = D - dx;\n                for(int f=-1; f<=1; f++) {\n                    for(int g=-1; g<=1; g++) {\n                        if(f == 0 or g == 0) continue;\n                        int k = i + f * dx;\n                        int l = j + g * dy;\n                        if(k < 0 or k >= H or l < 0 or l >= W) continue;\n                        // fprintf(stderr, \"i = %d, j = %d, k = %d, l = %d\\n\", i, j, k, l);\n\n                        int y = get_idx(k, l);\n                        mat[x][y] = 1;\n                    }\n                }\n            }\n        }\n    }\n\n    auto res = linearEquationBinary(mat, vec);\n    cout << (res.size() > 0) << endl;\n    // for(auto e : res) cerr << e << \" \";\n    // cerr << endl;\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int64_t ll;\n#define REP(i, n) for(auto i = 0 * (n); i < (n); ++i)\n#define FOR(i, s, n) for(size_t i = (s); i < (n); ++i)\n\ntypedef vector<ll> Vector;\ntypedef vector<Vector> Matrix;\nstruct GaussJordan {\n\ttypedef size_t T;\n\tGaussJordan(Matrix mat, T m) : x(move(mat)) {\n\t\tT row = x.size(), col = x[0].size(), r = 0;\n\t\tREP(c, col) {\n\t\t\tT p = r;\n\t\t\tFOR(i, r, row) if (abs(x[i][c]) > abs(x[p][c])) p = i;\n\t\t\tswap(x[r], x[p]);\n\t\t\tif (x[r][c]) {\n\t\t\t\tif (c == col - 1) impossible = 1; // ??????????????????????????????????????????\n\t\t\t\tdet = det * x[r][c] % m; // ??????????????????????????????????????????\n\t\t\t\t//FOR(j, c + 1, col) x[r][j] = x[r][j] * inverse(x[r][c], m) % m;\n\t\t\t\tFOR(j, c + 1, col) x[r][j] = x[r][j] * x[r][c];\n\t\t\t\tx[r][c] = 1;\n\t\t\t\tREP(i, row) if (r != i) {\n\t\t\t\t\t//FOR(j, c + 1, col) x[i][j] = (x[i][j] - x[i][c] * x[r][j] % m + m) % m;\n\t\t\t\t\tFOR(j, c + 1, col) x[i][j] ^= x[i][c] * x[r][j];\n\t\t\t\t\tx[i][c] = 0;\n\t\t\t\t}\n                if (++r == row) break;\n\t\t\t}\n\t\t}\n        rank = r;\n\t}\n\tMatrix x;\n\tT rank;\n\tll det = 1;  // mat ?????£??????????????? full rank ?????¨???????????????\n\tbool impossible = 0; // ?????¢????¬?????¨????????§£??????????????´???????????????????§£????????? <-> true\n};\n\nGaussJordan linear_equations(Matrix A, const Vector & b, size_t m) {\n\tREP(i, A.size()) A[i].push_back(b[i]);\n    return GaussJordan(move(A), m);\n}\n\nbool ba[30][30];\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint m, n, d;\n\twhile (cin >> m >> n >> d, m || n || d) {\n\t\tMatrix A(n * m, Vector(n * m));\n\t\tVector b(n * m);\n\t\tREP(i, n) {\n\t\t\tREP(j, m) {\n\t\t\t\tcin >> ba[i][j];\n\t\t\t\tA[i * m + j][i * m + j] = 1;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tREP(l, m) {\n\t\t\t\t\t\tint dis = abs(i - k) + abs(j - l);\n\t\t\t\t\t\tif (dis == d) {\n\t\t\t\t\t\t\tA[k * m + l][i * m + j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i * m + j] = ba[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << (linear_equations(move(A), b, 2).impossible ? 0 : 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing vvll = vector<vll>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\n//constexpr int INF = 1001001001;\nconstexpr ll INF = 1001001001001001001ll;\nconstexpr double EPS = 1e-10;\nusing number = long long;\n\n\nconst int MAX_ROW = 1010; // to be set appropriately\nconst int MAX_COL = 1010; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n    \n    friend ostream& operator << (ostream& os, BitMatrix A) {\n        os << endl;\n        for (int i = 0; i < A.H; ++i) {\n            for (int j = 0; j < A.W; ++j) {\n                os << A[i][j] << \", \";\n            }\n            os << endl;\n        }\n        return os;\n    }\n};\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n};\n\n\n\nint main() {\n    int N, M, D;\n    while (cin >> M >> N >> D, N) {\n        vector<vector<int> > a(N, vector<int>(M, 0));\n        for (int i = 0; i < N; ++i) for (int j = 0; j < M; ++j) cin >> a[i][j];\n\n        BitMatrix A(N * M, N * M);\n        vector<int> b(N * M, 0), res;\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < M; ++j) {\n                A[i * M + j][i * M + j] = 1;\n                for (int k = 0; k < N; ++k) {\n                    for (int l = 0; l < M; ++l) {\n                        if (abs(i - k) + abs(j - l) != D) continue;\n                        A[i * M + j][k * M + l] = 1;\n                    }\n                }\n                b[i * M + j] = 1 - a[i][j];\n            }\n        }\n        int rank = linear_equation(A, b, res);\n        if (rank == -1) cout << 0 << endl;\n        else cout << 1 << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\ntypedef pair<int, bool> sP;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\ntypedef bitset<625> bt;\n\nvoid Gauss_elim(vector<bt> &b) {\n\tint le = 0;\n\trep(j, 625) {\n\t\tRep(i, le, b.size()) {\n\t\t\tif (b[i][j]) {\n\t\t\t\tswap(b[le], b[i]);\n\t\t\t\trep(k, b.size()) {\n\t\t\t\t\tif (k == le)continue;\n\t\t\t\t\tif (b[k][j]) {\n\t\t\t\t\t\tb[k] ^= b[le];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tle++; break;\n\t\t\t}\n\t\t}\n\t}\n}\nint mp[25][25];\nint w, h, d;\nvoid solve() {\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\tvector<bt> b(h*w);\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\trep(k, h) {\n\t\t\t\trep(l, w) {\n\t\t\t\t\tint dist = abs(k - i) + abs(l - j);\n\t\t\t\t\tif (dist == d || dist == 0) {\n\t\t\t\t\t\tb[i*w + j][k*w + l] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tGauss_elim(b);\n\t/*rep(i, b.size()) {\n\t\trep(j, h*w)cout << b[i][j];\n\t\tcout << endl;\n\t}*/\n\tbt goal;\n\trep(i, h)rep(j, w)if (mp[i][j]) {\n\t\t//cout << i << \" \" << j << endl;\n\t\tgoal[i*w + j] = true;\n\t}\n\t/*rep(j, h*w)cout << goal[j];\n\tcout << endl;*/\n\trep(i, b.size()) {\n\t\trep(j, 625) {\n\t\t\tif (b[i][j]) {\n\t\t\t\tif (goal[j]) {\n\t\t\t\t\tgoal ^= b[i];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"ans is \";\n\tif (goal.count() == 0) {\n\t\tcout << 1 << endl;\n\t}\n\telse {\n\t\tcout << 0 << endl;\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\t//init();\n\twhile (cin >> w>>h>>d, w) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n#include<fstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint a[25 * 25][25 * 25 + 1];\n\nint manhattan(int x1, int y1, int x2, int y2){\n  return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint main(){\n  int n, m, d;\n\n  while(scanf(\"%d%d%d\", &m, &n, &d), n + m + d){\n    int s[25][25];\n    const int N = n * m;\n    REP(i,n) REP(j,m) scanf(\"%d\", &s[i][j]);\n\n    REP(i,N){\n      REP(j,N){\n        a[i][j] = 0;\n      }\n      a[i][N] = s[i / m][i % m];\n    }\n\n    REP(i1,n) REP(j1,m){\n      a[i1 * m + j1][i1 * m + j1] = 1;\n      REP(i2,n) REP(j2,m){\n        if(manhattan(i1, j1, i2, j2) == d){\n          a[i1 * m + j1][i2 * m + j2] = 1;\n        }\n      }\n    }\n\n    int ans = 1;\n\n    REP(i, N){\n      if(a[i][i] == 0){\n        for(int j = 0; j < N; j++){\n          if(j < i && a[j][j]) continue;\n          if(a[j][i] > 0){\n            for(int k = 0; k < N + 1; k++){\n              swap(a[i][k], a[j][k]);\n            }\n            break;\n          }\n        }\n        if(a[i][i] == 0){\n          continue;\n        }\n      }\n\n      for(int j = 0; j < N; j++){\n        if(i != j){\n          if(a[j][i] == 1){\n            for(int k = i; k < N + 1; k++){\n              a[j][k] = (a[j][k] + a[i][k]) % 2;\n            }\n          }\n        }\n      }\n    }\n\n    REP(i,N) if(a[i][i] == 0 && a[i][N] == 1) ans = 0;\n\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <random>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <functional>\n#include <iomanip>\n#include <random>\n\n#define FOR_LT(i, beg, end) for (int i = (int)(beg); i < (int)(end); i++)\n#define FOR_LE(i, beg, end) for (int i = (int)(beg); i <= (int)(end); i++)\n#define FOR_DW(i, beg, end) for (int i = (int)(beg); (int)(end) <= i; i--)\n#define REP(n)              for (int repeat_index = 0; repeat_index < (int)n; repeat_index++)\n\nusing namespace std;\n\nconst int MAX_ROW = 635; // to be set appropriately\nconst int MAX_COL = 635; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) { return val[i]; }\n};\n\nint GaussJordan(BitMatrix & A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector<int> b, vector<int> & res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n}\n\nvoid solve(int h, int w, int d)\n{\n\tint n = h * w;\n\tvector<int> bits(n);\n\tFOR_LT(i, 0, n) {\n        cin >> bits[i];\n\t}\n\n    BitMatrix A(n, n);\n    FOR_LT(i, 0, n) {\n        FOR_LT(j, 0, n) {\n            int x0 = i % w;\n            int y0 = i / w;\n            int x1 = j % w;\n            int y1 = j / w;\n            if (abs(x0 - x1) + abs(y0 - y1) == d || i == j) {\n                A[i][j] = 1;\n            }\n        }\n    }\n\n    vector<int> res(n);\n    int r = linear_equation(A, bits, res);\n    if (r == -1) {\n        cout << 0 << endl;\n    }\n    else {\n        cout << 1 << endl;\n    }\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout << fixed << setprecision(20);\n\n\twhile (true) {\n\t\tint w, h, d; cin >> w >> h >> d;\n\t\tif (w + h + d == 0) break;\n\n\t\tsolve(h, w, d);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nlong long int N, P, Q;\nlong long int getans(const long long int self, const vector<long long int>&vs) {\n\tvector<long long int>totals(vs);\n\tfor (int i = 0; i < vs.size(); ++i) {\n\t\ttotals[i] =-totals[i]-i*P;\n\t}\n\tsort(totals.begin(), totals.end(),greater<long long int>());\n\tlong long int ans = 0;\n\tfor (int i = 0; i < self; ++i) {\n\t\tans += totals[i];\n\t}\n\tans += self*(Q+(Q + 2 * (self - 1)))*P / 2ll;\n\treturn ans;\n}\n\n\nint main() {cin >> N >> P >> Q;\n\tvector<long long int>cs(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> cs[i];\n\t}\n\tint amin = 0;\n\tint amax = N + 1;\n\twhile (amin + 3 <= amax) {\n\t\tconst int amid1 = (amin * 2 + amax) / 3;\n\t\tconst int amid2 = (amin + amax * 2) / 3;\n\t\tconst long long int a1 = getans(amid1,cs);\n\t\tconst long long int a2 = getans(amid2,cs);\n\t\tif (a1 < a2) {\n\t\t\tamin = amid1;\n\t\t}\n\t\telse {\n\t\t\tamax = amid2;\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int s = amin; s < amax; ++s) {\n\t\tans = max(ans,getans(s, cs));\n\t}\n\tans += accumulate(cs.begin(), cs.end(), 0ll);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\nconst int maxn = 444444;\nint a[625][625];\nint solve(int a[][625],int n) {\n    int i , j ,k , r;\n    for(i = 0; i < n; i++) {\n      r = i;\n      for(j = i+1; j < n; j++) if(a[j][i] > a[r][i]) r = j;\n      if(!a[r][i]) continue;\n      if(r != i) for(j = 0; j <= n; j++) swap(a[i][j],a[r][j]);\n      for(k = 0; k < n; k++) if(k!=i && a[k][i]) \n        for(j = i; j <= n; j++) a[k][j] ^= a[i][j];\n    }\n    for(i = 0; i < n; i++) if(!a[i][i] && a[i][n]) return -1;\n    return 1;\n}\nint main() {\n  int t,n,x,y,m,d;\n  while(scanf(\"%d%d%d\",&n,&m,&d)!=EOF) {\n\t  if(!n) break;\n    memset(a,0,sizeof(a));\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tfor(int j = 0,k; j < n; j++)\n\t\t{\n\t\t\tscanf(\"%d\",&k);\n\t\t\ta[i*n+j][m*n] ^= k;\n\t\t\tfor(int x = 0; x < m; x++)\n\t\t\t{\n\t\t\t\tfor(int y = 0; y < n; y++)\n\t\t\t\t{\n\t\t\t\t\tif(abs(x-i) + abs(y-j) == d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i*n+j][x*n+y] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < m*n; i++) a[i][i] = 1;\n/*\tfor(int i = 0; i < m*n; i++)\n\t{\n\t\tfor(int j = 0; j < m*n; j++)\n\t\t{\n\t\t\tprintf(\"%d \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n    int ans = solve(a,n*m);\n    if(ans == -1) puts(\"0\");\n    else printf(\"1\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int m, n, d;\n    cin >> m >> n >> d;\n    while(m or n or d) {\n        vvi s(n, vi(m));\n        rep(i, n) rep(j, m) {\n            cin >> s[i][j];\n        }\n\n        auto num = [&](int i, int j) {\n            return i*m + j;\n        };\n\n        vector<bitset<625> > bits(625);\n        rep(i, n) rep(j, m) {\n            bitset<625> now(0);\n            now[num(i, j)] = 1;\n            rep(k, n) rep(l, m) if(abs(k-i) + abs(l-j) == d) {\n                now[num(k, l)] = 1;\n            }\n            int x = -1;\n            for(int k = 624; k >= 0; k--) {\n                if(now.test(k) and bits[k].test(k)) {\n                    now ^= bits[k];\n                }\n                if(now.test(k)) chmax(x, k);\n            }\n            if(x == -1) continue;\n            for(int k = 624; k > x; k--) {\n                if(bits[k].test(x)) {\n                    bits[k] ^= now;\n                }\n            }\n            bits[x] = now;\n        }\n\n        bitset<625> S(0);\n        rep(i, n) rep(j, m) {\n            if(s[i][j]) {\n                S.set(num(i, j));\n            }\n        }\n        //cout << S << endl;\n        for(int i = 624; i >= 0; i--) {\n            //cout << bits[i] << endl;\n            if(S.test(i) and bits[i].test(i)) {\n                S ^= bits[i];\n            }\n        }\n\n        cout << (S == bitset<625>(0)) << '\\n';\n        cin >> m >> n >> d;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint abs(int t){ return t>0?t:-t; }\n\nint main(){\n\tint m, n, d;\n\twhile(cin >> m >> n >> d, m){\n\t\tvector< vector<int> > v(n*m, vector<int>(n*m+1,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tcin >> v[i*m+j][n*m];\n\t\t\t\tfor(int ii=0;ii<n;ii++){\n\t\t\t\t\tfor(int jj=0;jj<m;jj++){\n\t\t\t\t\t\tint dist = abs(i-ii)+abs(j-jj);\n\t\t\t\t\t\tif(dist==0||dist==d) v[ii*m+jj][i*m+j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cur = 0;\n\t\tfor(int i=0;i<n*m;i++){\n\t\t\tint chg = cur;\n\t\t\twhile(chg<n*m && v[chg][i]==0) chg++;\n\t\t\tif(chg == n*m) continue;\n\t\t\tswap(v[cur], v[chg]);\n\t\t\tfor(int j=cur+1;j<n*m;j++){\n\t\t\t\tif(v[j][i]){\n\t\t\t\t\tfor(int k=i;k<n*m+1;k++)\n\t\t\t\t\t\tv[j][k] = (v[j][k]+v[cur][k])%2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\tint res = 1;\n\t\tfor(int i=cur;i<n*m;i++)\n\t\t\tif(v[i][n*m] == 1) res = 0;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int M, N, D;\n  bitset< 626 > matrix[625];\n\n  while(cin >> M >> N >> D, M) {\n    for(int i = 0; i < N * M; i++) {\n      int d;\n      cin >> d;\n      matrix[i][N * M] = d;\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < M; j++) {\n        for(int k = 0; k < N; k++) {\n          for(int l = 0; l < M; l++) {\n            matrix[i * M + j][k * M + l] = abs(i - k) + abs(j - l) == D;\n          }\n        }\n        matrix[i * M + j][i * M + j] = 1;\n      }\n    }\n\n    for(int i = 0; i < N * M; i++) {\n      int pos = -1;\n      for(int j = i; j < N * M; j++) {\n        if(matrix[j][i]) pos = j;\n      }\n      if(pos == -1) continue;\n      swap(matrix[pos], matrix[i]);\n      for(int j = 0; j < M * N; j++) {\n        if(i != j && matrix[j][i] == 1) matrix[j] ^= matrix[i];\n      }\n    }\n    bool flag = true;\n    for(int i = 0; i < M * N; i++) {\n      if(matrix[i][M * N] && !matrix[i][i]) flag = false;\n    }\n    cout << flag << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//      whn6325689\n//\t\tMr.Phoebe\n//\t\thttp://blog.csdn.net/u013007900\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <climits>\n#include <complex>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef complex<ld> point;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef vector<int> vi;\n\n#define CLR(x,y) memset(x,y,sizeof(x))\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define lowbit(x) (x&(-x))\n#define MID(x,y) (x+((y-x)>>1))\n#define eps 1e-9\n#define PI acos(-1.0)\n#define INF 0x3f3f3f3f\n#define LLINF 1LL<<62\n\ntemplate<class T>\ninline bool read(T &n)\n{\n    T x = 0, tmp = 1;\n    char c = getchar();\n    while((c < '0' || c > '9') && c != '-' && c != EOF) c = getchar();\n    if(c == EOF) return false;\n    if(c == '-') c = getchar(), tmp = -1;\n    while(c >= '0' && c <= '9') x *= 10, x += (c - '0'),c = getchar();\n    n = x*tmp;\n    return true;\n}\ntemplate <class T>\ninline void write(T n)\n{\n    if(n < 0)\n    {\n        putchar('-');\n        n = -n;\n    }\n    int len = 0,data[20];\n    while(n)\n    {\n        data[len++] = n%10;\n        n /= 10;\n    }\n    if(!len) data[len++] = 0;\n    while(len--) putchar(data[len]+48);\n}\n//-----------------------------------\n\nconst int MAXN=900;\n\nint b[MAXN][MAXN],a[MAXN][MAXN];\n\nbool Guass(int n)  \n{  \n    int i,j,row,col;  \n    for(row=0,col=0;row<n && col<n;row++,col++)  \n    {    \n        for(i=row;i<n;i++)\n            if(a[i][col])  \n                break;  \n        for(j=col;j<=n;j++)\n            swap(a[row][j],a[i][j]);\n\t\tif(!a[row][col])\n\t\t{\n\t\t\trow--;continue;\n\t\t} \n        for(i=row+1;i<n;i++)  \n            if(a[i][col])  \n                for(j=col+1;j<=n;j++)  \n                    a[i][j]=a[row][j]^a[i][j];  \n    }  \n    for(i=row;i<n;i++)  \n        if(a[i][n])\n\t\t\treturn 0;\n\treturn 1; \n} \n\nint main()\n{\n//\tfreopen(\"data.txt\",\"r\",stdin);\n\tint n,m,d;\n\twhile(~scanf(\"%d %d %d\",&m,&n,&d)&&n+m+d)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\tscanf(\"%d\",&b[i][j]);\n\t\tCLR(a,0);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\ta[i*m+j][n*m]=b[i][j];\n\t\t\t\ta[i*m+j][i*m+j]=1;\n\t\t\t\tfor(int x=0;x<n;x++)\n\t\t\t\t\tfor(int y=0;y<m;y++)\n\t\t\t\t\t\tif(abs(x-i)+abs(y-j)==d)\n\t\t\t\t\t\t\ta[i*m+j][x*m+y]=1;\n\t\t\t}\n\t\tif(Guass(n*m))\n\t\t\tputs(\"1\");\n\t\telse\n\t\t\tputs(\"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1308 Awkward Lights\n// 2018.3.8 bal4u\n\n//#include \"bits/stdc++.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define N 630\n#define ABS(a)\t((a)>=0?(a):-(a))\n#define p(r,c)\t((r)*m+(c))\n\nint main()\n{\n\tint m, n, mn, d, i, j, r, c, ans;\n\n\twhile (m = in()) {\n\t\tn = in(), d = in(), mn = m*n;\n\nbitset <N> B[N];\n\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < m; j++) {\n\t\t\tif (in()) B[p(i, j)][mn] = 1;\n\t\t\tfor (r = 0; r < n; r++) for (c = 0; c < m; c++) {\n\t\t\t\tif (r == i && c == j || ABS(r-i) + ABS(c-j) == d)\n\t\t\t\t\tB[p(i, j)][p(r, c)] = 1;\n\t\t\t}\n\t\t}\n\n\t\tn = mn;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfor (j = i; j < n; j++) if (B[j][i]) break;\n\t\t\tif (j == n) continue;\n\t\t\tswap(B[j], B[i]);\n\t\t\tfor (j = 0; j < n; j++) if (i != j && B[j][i]) B[j] ^= B[i];\n\t\t}\n\n\t\tans = '1';\n\t\tfor (i = 0; i < n; i++) if (!B[i][i] && B[i][n]) { ans = '0'; break; }\n\t\tputchar(ans), putchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n\nll modNorm(ll a, ll m) {\n  return (a%m+m)%m;\n}\n\n// ax+by=gcd(a,b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll invMod(ll a, ll p) {\n  ll x, y;\n  if (extgcd(a,p,x,y) == 1) return (x+p)%p;\n  return 0;\n}\n\ntypedef vector<bool> vec;\ntypedef vector<vec> mat;\n\nostream &operator<<(ostream &os, const vec &a) {\n  FOR(it, a) os << *it << \" \";\n  return os;\n}\nostream &operator<<(ostream &os, const mat &a) {\n  FOR(it, a) os << *it << endl;\n  return os;\n}\n\n\nbool gauss_jordan_cong(const mat &A, const vec &b, int m, vec &x) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  REP(i,n) REP(j,n)\n    B[i][j] = A[i][j];\n  REP(i, n) B[i][n] = b[i];\n\n  //cout << B << endl;\n  REP(i, n) {\n    int pivot = i;\n    for (int j=i; j<n; ++j)\n      if (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    swap(B[i], B[pivot]);\n    // 解がないか、一意でない\n    if (abs(B[i][i]) < EPS) {\n      if (abs(B[i][n]) > EPS) return 0;\n      continue;\n    }\n\n    // // 注目している変数の係数を１にする\n    // for (int j=i+1; j<=n; j++) B[i][j] = B[i][j] ^ B[i][i];\n    // B[i][i] = 1;\n    REP(j, n) {\n      if (i != j) {\n        // j番目の式からi番目の変数を消去\n        if (B[j][i])\n          for (int k=i+1; k<=n; ++k) B[j][k] = B[j][k] ^ B[i][k];\n        B[j][i] = 0;\n      }\n    }\n    //cout << B << endl;\n  }\n  //cout << B << endl;\n  x = vec(n);\n  REP(i, n) {\n    if (B[i][i] == 0 && B[i][n]) return 0;\n    x[i] = B[i][n];\n  }\n  return 1;\n}\n\nint main() {\n  int m, n, d;\n  int c = 0;\n  while(cin>>m>>n>>d, m||n||d) {\n    bool ba[n][m];\n    mat A(n*m, vec(n*m));\n    vec b(n*m);\n    REP(i,n) {\n      REP(j,m) {\n        cin >> ba[i][j];\n        A[i*m+j][i*m+j] = 1;\n        REP(k,n) {\n          REP(l,m) {\n            int dis = abs(i-k)+abs(j-l);\n            if (dis == d) {\n              A[k*m+l][i*m+j] = 1;\n              // A[i*m+j][k*m+l] = 1;\n            }\n          }\n        }\n        b[i*m+j] = ba[i][j];\n      }\n    }\n    vec x;\n    cout << gauss_jordan_cong(A,b,2,x) << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=1000;\n\nint A[N][N], a[N][N];\nint equation, variable;\nint n, m, manhaton;\n\nint gauss()\n{\n    int col=1, row=1;\n    for(; row<=equation && col<=variable; row++, col++)\n    {\n        int max_row=row;\n\n        for(int i=row+1; i<=equation; i++)\n            if(abs(A[i][col])>abs(A[max_row][col]))\n                max_row=i;\n\n        if(A[max_row][col]==0)\n        {\n            row--;\n            continue;\n        }\n\n        if(max_row!=row)\n        {\n            for(int i=col; i<=variable+1; i++)\n                swap(A[max_row][i], A[row][i]);\n        }\n\n        for(int i=row+1; i<=equation; i++)\n        {\n            if(i==row) continue;\n            if(A[i][col]==0) continue;\n            int GCD=__gcd(abs(A[i][col]), abs(A[row][col]));\n            int ta=abs(A[row][col]) / GCD;\n            int tb=abs(A[i][col])   / GCD;\n\n            if((A[i][col]>0 && A[row][col]<0) || (A[i][col]<0 && A[row][col]>0)) tb=-tb;\n\n            for(int j=col; j<=variable+1; j++)\n                A[i][j]=abs((A[i][j]*ta-A[row][j]*tb))%2;\n        }\n    }\n\n    for(int i=row; i<=equation; i++)\n        if(A[i][variable+1]!=0) return -1;\n\n    return 0;\n}\n\nvoid build(int n, int m)\n{\n    variable=n*m, equation=n*m;\n\n    for(int i=0; i<n; i++)\n        for(int j=0; j<m; j++)\n            scanf(\"%d\", &a[i][j]);\n\n    for(int i=1; i<=equation; i++)\n        for(int j=1; j<=variable+1; j++)\n            A[i][j]=0;\n\n    for(int i=0; i<n; i++)\n        for(int j=0; j<m; j++)\n        {\n            int id=i*m+j+1;\n            A[id][id]=1;\n            for(int x=0; x<n; x++)\n                for(int y=0; y<m; y++)\n                {\n                    if(abs(y-j)+abs(x-i)==manhaton) A[id][x*m+y+1]=1;\n                }\n            if(a[i][j]==1) A[id][variable+1]=1;\n        }\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d\", &m, &n, &manhaton), m!=0 || n!=0 || manhaton!=0)\n    {\n        build(n, m);\n        int ans=gauss();\n        if(ans==-1) printf(\"0\\n\"); else printf(\"1\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef vector<int> V;\ntypedef vector<V> M;\n\nbool gauss_jordan(M m, V v) {\n  for (int r = m.size(); r--; ) {\n    int p = r;\n    rep (i, r) if (abs(m[i][r]) > abs(m[p][r])) p = i;\n    swap(m[r], m[p]);\n    swap(v[r], v[p]);\n    if (m[r][r] == 0) continue;\n    rep (i, m.size()) if(i != r) {\n      v[i] ^= m[i][r] & v[r];\n      rep (k, r) m[i][k] ^= m[i][r] & m[r][k];\n    }\n  }\n  rep (i, m.size()) if (m[i][i] == 0 && v[i] != 0) return false;\n  return true;\n}\n\nint main() {\n  while (true) {\n    int m, n, d;\n    cin >> m >> n >> d;\n    if (m == 0 && n == 0 && d == 0) break;\n    V v(n * m);\n    rep (i, n * m) cin >> v[i];\n    M mat(n * m, V(n * m, 0));\n    rep (i, n * m) mat[i][i] = 1;\n    rep (i, n) rep (j, m) rep (ii, n) rep (jj, m) if (abs(i - ii) + abs(j - jj) == d) mat[i * m + j][ii * m + jj] = 1;\n    if (gauss_jordan(mat, v)) cout << 1 << endl;\n    else cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 625+2;\nconst int mod = 2;\nint mat[N][N];\n//if mod is prime\nint mypow(int n,int p){\n  if (p == 0)return 1;\n  int tmp=mypow(n,p/2);\n  tmp=(tmp*tmp)%mod;\n  if (tmp%2==1)tmp=(tmp*n)%mod;\n  return tmp%mod;\n}\n\nint inverse(int now){\n  if (now == 0)return -1;// now answer\n  return mypow(now,mod-2);\n}\n\n//if mod is not prime\n//extended euqlid?\n\n//partial pivot\nbool select_pivot(int r,int c,int k,int mat[N][N]){\n  int s=k;\n  int val=abs(mat[k][k]);\n  REP(i,k+1,r){\n    if (abs(mat[i][k])>val)val=abs(mat[i][k]),s=i;\n  }\n  if (val ==0)return false;\n  REP(i,k,c+1)swap(mat[k][i],mat[s][i]);\n  return true;\n}\n \n//parfect pivotting\nbool select_pivot(int r,int c,int k,int mat[N][N],int num[N]){\n  int s=k,t=k;//selected pivot\n  double val=fabs(mat[k][k]);\n  REP(i,k+1,r){\n    REP(j,k+1,c){\n      if (fabs(mat[i][j]) >val){\n\tval=fabs(mat[i][j]);\n\ts=i;\n\tt=j;\n      }\n    }\n  }\n  if (val == 0)return false;//cannot solve this linear equations.\n  rep(i,r)swap(mat[i][k],mat[i][t]);\n  swap(num[k],num[t]);\n  REP(i,k,r+1)swap(mat[k][i],mat[s][i]);\n  return true;//no problem for this pivot;\n}\n\nbool gauss(int r,int c,int mat[N][N],int num[N]){\n rep(k,c){\n   //if (!select_pivot(r,c,k,mat,num)){\n   if (!select_pivot(r,c,k,mat)){\n     REP(i,k,r)if (mat[i][c] == 1)return false;\n     return true;\n   }\n   assert(inverse(mat[k][k]) != -1);\n   REP(i,k+1,c+1)mat[k][i]=(mat[k][i]*inverse(mat[k][k]))%mod;\n   mat[k][k]=1;\n   REP(i,k+1,r){\n     REP(j,k+1,c+1)mat[i][j]=(mat[i][j]-(mat[i][k]*mat[k][j])+mod)%mod;\n     mat[i][k]=0;\n   }\n }\n for(int i=r-1;i>=0;i--){\n   REP(j,i+1,c){\n     mat[i][c]=(mat[i][c]-(mat[i][j]*mat[j][c])+mod)%mod;\n   }\n }\n return true;\n}\n\n#define GETPOS(c,i,j) ((i)*(c)+(j))\n\nmain(){\n  int r,c,d;\n  int num[N];\n  while(cin>>c>>r>>d && r){\n    int n=r*c;\n    rep(i,n)rep(j,n+1)mat[i][j]=0;\n    rep(i,n)num[i]=i;\n    rep(i,r)rep(j,c){\n      int tmp;cin>>tmp;\n      mat[GETPOS(c,i,j)][n]=(-tmp+mod)%mod;\n    }\n    rep(i,r){\n      rep(j,c){\n\tmat[GETPOS(c,i,j)][GETPOS(c,i,j)]=1;\n\trep(ii,r){\n\t  rep(jj,c){\n\t    if (abs(ii-i)+abs(jj-j) == d){\n\t      mat[GETPOS(c,i,j)][GETPOS(c,ii,jj)]=1;\n\t      //cout << \"(\" <<i<<\",\"<<j<<\"),(\"\n\t      //<< ii<<\",\"<<jj<<\")\"<<endl;\n\t      //cout << GETPOS(c,i,j)+1 <<\" \" << GETPOS(c,ii,jj)+1 << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    /*    rep(i,n){\n      rep(j,n+1)cout << mat[i][j] <<\" \";\n      cout << endl;\n    }      \n    */\n\n    cout << gauss(n,n,mat,num) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N, D;\n  while (cin>>M>>N>>D && M) {\n    int S[25][25];\n    REP(i, M)REP(j, N) cin>>S[i][j];\n    int G[25 * 25][26] = {};\n    REP(i, M)REP(j, N){\n      REP(k, M)REP(l, N){\n        if(abs(i - k) + abs(j - l) == D || (i == k && j == l)){\n          G[i + M * j][k] |= 1<<l;\n        }\n      }\n      G[i + M * j][25] = S[i][j];\n    }\n    bool ans = true;\n    for(int i = 0; i < M * N; i++){\n      int pivot = -1;\n      for(int j = i; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))) pivot = j;\n      }\n      if(pivot == -1) continue;\n      int tmp[26];\n      //swap(G[i], G[pivot]);\n      memcpy(tmp, G[i], sizeof(tmp));\n      memcpy(G[i], G[pivot], sizeof(tmp));\n      memcpy(G[pivot], tmp, sizeof(tmp));\n      for(int j = i + 1; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))){\n          for(int k = 0; k < M; k++){\n            G[j][k] ^= G[i][k];\n          }\n          G[j][25] ^= G[i][25];\n        }\n      }\n    }\n    int a[25 * 25] = {};\n    for(int i = M * N - 1; i >= 0; i--){\n      for(int j = 0; j < M * N; j++) if(G[i][j / N] & (1 << (j % N))) {\n        G[i][25] ^= a[j];\n      }\n      if(!(G[i][i / N] & (1 << (i % N))) && G[i][25] == 1){\n        ans = false;\n      }else{\n        a[i] = G[i][25];\n      }\n    }\n    if(ans) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst double EPS=1E-9;\nbool gauss_jordan(const mat& A,const vec& b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  \n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  \n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++)if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    swap(B[i],B[pivot]);\n\n    for(int j=0;j<n;j++)\n      if(i!=j)\n\tfor(int k=i+1;k<=n;k++)B[j][k]=(B[j][k]+B[j][i]*B[i][k])%2;\n  }\n  for(int i=0;i<n;i++)if(B[i][i]==0&&B[i][n]==1) return 0;\n  return 1;\n}\n\nint h,w,d,mp[25][25];\n\nint main(){\n  while(1){\n    cin>>w>>h>>d;\n    if(!w&&!h&&!d)break;\n    mat A(h*w,vec(h*w));\n    vec B(h*w);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>mp[i][j];\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tint idx=w*i+j;\n\tB[idx] = mp[i][j];\n\tfor(int y=0;y<h;y++)\n\t  for(int x=0;x<w;x++){\n\t    int t = abs(i-y)+abs(j-x);\n\t    if(t==d||t==0)A[idx][w*y+x]=1;\t\t\t\t\n\t  }\n      }\n    cout<<gauss_jordan(A,B)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct mod\n{\n  int m;\n  mod(int a) : m(a) {}\n  int operator()(int x) const { return ((x%m)+m)%m; }\n};\n\nstatic const int MAXN = 25*25;\n\nbool gaussian_elimination(int a[MAXN][MAXN], int b[MAXN], int N)\n{\n  static mod M(2);\n\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; a[i][i] == 0 && j < N; j++) {\n      for (int k = 0; k < N; k++) {\n        swap(a[i][k], a[j][k]);\n      }\n      swap(b[i], b[j]);\n    }\n    if (a[i][i] == 0) {\n      continue;\n    }\n\n    for (int j = 0; j < N; j++) {\n      if (i == j) {\n        continue;\n      }\n      const int u = a[j][i];\n      for (int k = i; k < N; k++) {\n        a[j][k] = M(a[j][k] - u*a[i][k]);\n      }\n      b[j] = M(b[j] - u*b[i]);\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (a[i][i] == 0 && b[i] != 0) {\n      // no solution\n      return false;\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int M, N, D;\n  while (scanf(\"%d %d %d\", &M, &N, &D) != EOF && M != 0) {\n    static int a[MAXN][MAXN];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        for (int k = 0; k < N; k++) {\n          for (int l = 0; l < M; l++) {\n            const int t = abs(i-k) + abs(j-l);\n            a[M*i+j][M*k+l] = (t == D || t == 0);\n          }\n        }\n      }\n    }\n\n    static int b[MAXN];\n    for (int i = 0; i < N*M; i++) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    printf(\"%d\\n\", gaussian_elimination(a, b, M*N));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//validate by AOJ 2397\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef int elm;\ntypedef vector<elm> vec;\ntypedef vector<vec> mat;\n\nbool gauss_jordan(const mat &A, const vec &b) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i = 0; i < n; ++i) {\n    for(int j = 0; j < n; ++j) {\n      B[i][j] = A[i][j];\n    }\n  }\n\n  for(int i = 0; i < n; ++i) B[i][n] = b[i];\n\n  for(int i = 0; i < n; ++i) {\n    int pivot = i;\n    for(int j = i; j < n; ++j) {\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i], B[pivot]);\n\n    if(B[i][i] == 0) continue;\n\n    //for(int j = i+1; j <= n; ++j) B[i][j] /= B[i][i];\n    for(int j = 0; j < n; ++j) {\n      if(i != j) {\n        for(int k = i + 1; k <= n; ++k) {\n          B[j][k] -= B[j][i] * B[i][k];\n          B[j][k] = (B[j][k] % 2 + 2) % 2;\n        }\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i) {\n    if(B[i][i] == 0 && B[i][n] != 0) return false;\n  }\n  return true;\n}\n\nint main() {\n  for(int c, r, d; cin >> c >> r >> d && (c|r|d); ) {\n    mat S(r, vector<elm>(c));\n    for(int i = 0; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        cin >> S[i][j];\n      }\n    }\n    mat T(r*c, vector<elm>(r*c));\n    for(int i = 0; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        for(int ti = 0; ti < r; ++ti) {\n          for(int tj = 0; tj < c; ++tj) {\n            int dist = abs(ti - i) + abs(tj - j);\n            T[ti*c+tj][i*c+j] = (!dist || dist == d);\n          }\n        }\n      }\n    }\n    vec b(r*c);\n    for(int i = 0; i < r; ++i) {\n      for(int j = 0; j < c; ++j) {\n        b[i*c+j] = S[i][j];\n      }\n    }\n    cout << gauss_jordan(T, b) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint mat[625][626];\n\nbool solve(int n){\n\tbool used[625]={};\n\trep(j,n){\n\t\tint i;\n\t\tfor(i=0;i<n;i++) if(!used[i] && mat[i][j]==1) break;\n\t\tif(i<n){\n\t\t\tused[i]=true;\n\t\t\trep(k,n) if(i!=k && mat[k][j]==1) {\n\t\t\t\tfor(int l=j;l<=n;l++) mat[k][l]=(mat[k][l]+mat[i][l])&1;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,n) if(!used[i] && mat[i][n]==1) return false;\n\n\treturn true;\n}\n\nint main(){\n\tfor(int m,n,d;scanf(\"%d%d%d\",&n,&m,&d),m;){\n\t\tint a[25][25];\n\t\trep(i,m) rep(j,n) scanf(\"%d\",a[i]+j);\n\n\t\tmemset(mat,0,sizeof mat);\n\t\trep(i,m) rep(j,n) {\n\t\t\tmat[i*n+j][i*n+j]=1;\n\t\t\trep(ii,m) rep(jj,n) if(abs(ii-i)+abs(jj-j)==d) {\n\t\t\t\tmat[ii*n+jj][i*n+j]=1;\n\t\t\t}\n\t\t\tmat[i*n+j][m*n]=a[i][j];\n\t\t}\n\n\t\tputs(solve(m*n)?\"1\":\"0\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint W,H,D;\nint field[25][25];\nint *A[25*25];\nint buf[25*25][25*25+1];\n\nint cos90[] = {+1, 0,-1, 0};\nint sin90[] = { 0,+1, 0,-1};\n\ninline int vec2int(int x, int y) { return y*W+x; }\n\nvoid setA(int cx, int cy)\n{\n\tint myidx=vec2int(cx,cy);\n\tfor(int d=0; d<D; d++)\n\t{\n\t\tint dx=  d;\n\t\tint dy=D-d;\n\t\tfor(int t=0; t<4; t++)\n\t\t{\n\t\t\t// sinツづosツづ嘉アツ転ツつウツつケツづ全ツ陛サツ古シツ催ャツづゥ\n\t\t\tint nx = cx + dx*cos90[t] - dy*sin90[t]; \n\t\t\tint ny = cy + dx*sin90[t] + dy*cos90[t];\n\n\t\t\tif(0<=nx && nx<W && 0<=ny && ny<H)\n\t\t\t{\n\t\t\t\tA[myidx][vec2int(nx,ny)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tA[myidx][myidx] = 1\t;\n\tA[myidx][W*H]   = field[cy][cx];\n}\n\nbool sweepout()\n{\n\tfor(int t=0; t<W*H; t++)\n\t{\n\t\t// 1ツづーツ探ツつキ\n\t\tfor(int y=t; y<W*H; y++)\n\t\t{\n\t\t\tif(A[y][t])\n\t\t\t{\n\t\t\t\tswap(A[t],A[y]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!A[t][t]) continue;\n\n\t\tfor(int y=t+1; y<W*H; y++)\n\t\t{\n\t\t\tif(A[y][t])\n\t\t\tfor(int x=t; x<W*H+1; x++)\n\t\t\t{\n\t\t\t\tA[y][x] = (A[y][x]+A[t][x])%2; \n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int t=W*H-1; t>=0; t--)\n\t{\n\t\tif(A[t][t])\n\t\tfor(int y=0; y<t; y++)\n\t\t{\n\t\t\tif(A[y][t])\n\t\t\t{\n\t\t\t\tA[y][t]   = 0;\n\t\t\t\tA[y][W*H] = (A[y][W*H]+A[t][W*H])%2; \n\t\t\t}\n\t\t}\n\t}\n\t\n\n\tfor(int t=0; t<W*H; t++)\n\t{\n\t\tif((!A[t][t]) && A[t][W*H])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tfor(int i=0; i<25*25; i++)\n\t{\n\t\tA[i] = buf[i];\n\t}\n\n\twhile(cin >> W >> H >> D, W||H||D)\n\t{\n\t\tfor(int y=0; y<H; y++)\n\t\tfor(int x=0; x<W; x++)\n\t\t{\n\t\t\tcin >> field[y][x];\n\t\t}\n\n\t\tmemset(buf,0,sizeof(buf));\n\t\tfor(int y=0; y<H; y++)\n\t\tfor(int x=0; x<W; x++)\n\t\t{\n\t\t\tsetA(x,y);\t\n\t\t}\n\n\t\tcout << (sweepout()?1:0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstruct mod\n{\n  int m;\n  mod(int a) : m(a) {}\n  int operator()(int x) const { return ((x%m)+m)%m; }\n};\n\nstatic const int MAXN = 25*25;\n\nbool gaussian_elimination(int a[MAXN][MAXN], int b[MAXN], int N)\n{\n  static mod M(2);\n\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; a[i][i] == 0 && j < N; j++) {\n      swap(a[i], a[j]);\n      swap(b[i], b[j]);\n    }\n    if (a[i][i] == 0) {\n      continue;\n    }\n\n    for (int j = 0; j < N; j++) {\n      if (i == j) {\n        continue;\n      }\n      const int u = a[j][i];\n      for (int k = i; k < N; k++) {\n        a[j][k] = M(a[j][k] - u*a[i][k]);\n      }\n      b[j] = M(b[j] - u*b[i]);\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (a[i][i] == 0 && b[i] != 0) {\n      // no solution\n      return false;\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int M, N, D;\n  while (scanf(\"%d %d %d\", &M, &N, &D) != EOF && M != 0) {\n    static int a[MAXN][MAXN];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        for (int k = 0; k < N; k++) {\n          for (int l = 0; l < M; l++) {\n            const int t = abs(i-k) + abs(j-l);\n            a[M*i+j][M*k+l] = (t == D || t == 0);\n          }\n        }\n      }\n    }\n\n    static int b[MAXN];\n    for (int i = 0; i < N*M; i++) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    printf(\"%d\\n\", gaussian_elimination(a, b, M*N));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool solve(vector<vector<int> > a, vector<int> b){\n\tint n = a.size();\n\tvector<vector<int> > B(n, vector<int>(n+1) );\n\t\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\tB[i][j] = a[i][j];\n\t\t}\n\t}\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tB[i][n] = b[i];\n\t}\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tint p = -1, val = -1;\n\t\tfor(int j=i ; j < n ; j++ ){\n\t\t\tif( val < abs(B[j][i]) ){\n\t\t\t\tp = j;\n\t\t\t\tval = abs(B[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( p == -1 || val <= 0 ) continue;\n\t\t\n\t\tswap(B[p], B[i]);\n\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\tif( i == j ) continue;\n\t\t\t\n\t\t\tint m = B[j][i];\n\t\t\tif( m == 1 ){\n\t\t\t\tfor(int k=i ; k <= n ; k++ ){\n\t\t\t\t\tB[j][k] = (B[j][k] + B[i][k]) % 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> res(n);\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tres[i] = B[i][n];\n\t\tif( B[i][i] == 0 && B[i][n] == 1 ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint w, h, d, s[25][25];\n\twhile( cin >> w >> h >> d, w || h || d ){\n\t\tfor(int y = 0 ; y < h ; y++ ){\n\t\t\tfor(int x = 0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > a(w*h, vector<int>(w*h) );\n\t\tvector<int> b(w*h, 0);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( s[y][x] ){\n\t\t\t\t\tb[y*w+x] = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int y_=0 ; y_ < h ; y_++ ){\n\t\t\t\t\tfor(int x_=0 ; x_ < w ; x_++ ){\n\t\t\t\t\t\tint dist = abs(x - x_) + abs(y - y_);\n\t\t\t\t\t\tif( dist == d || dist == 0 ){\n\t\t\t\t\t\t\ta[y*w+x][y_*w+x_] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = solve(a, b);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint a[25 * 25][25 * 25 + 1];\nint y[25 * 25];\n\nint manhattan(int x1, int y1, int x2, int y2){\n  return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint main(){\n  int n, m, d;\n\n  while(scanf(\"%d%d%d\", &n, &m, &d), n + m + d){\n    int s[25][25];\n    const int N = n * m;\n    REP(i,n) REP(j,m) scanf(\"%d\", &s[i][j]);\n\n    REP(i,N){\n      REP(j,N){\n        a[i][j] = 0;\n      }\n      a[i][N] = s[i / m][i % m];\n    }\n\n    REP(i1,n) REP(j1,m){\n      a[i1 * m + j1][i1 * m + j1] = 1;\n      REP(i2,n) REP(j2,m){\n        if(manhattan(i1, j1, i2, j2) == d){\n          a[i1 * m + j1][i2 * m + j2] = 1;\n        }\n      }\n    }\n\n    int ans = 1;\n\n    REP(i, N){\n      if(a[i][i] == 0){\n        for(int j = i + 1; j < N; j++){\n          if(a[j][i] > 0){\n            for(int k = 0; k < N + 1; k++){\n              swap(a[i][k], a[j][k]);\n            }\n          }\n        }\n        if(a[i][i] == 0){\n          continue;\n        }\n      }\n\n      for(int j = 0; j < N; j++) if(i != j){\n        if(a[j][i] == 1){\n          for(int k = i; k < N + 1; k++){\n            a[j][k] = (a[j][k] + a[i][k]) % 2;\n          }\n        }\n      }\n    }\n\n    REP(i,N) if(a[i][i] == 0 && a[i][N] == 1) ans = 0;\n\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int maxn=1000;\nconst int maxp=100;\nint n,m,d;\nint matrix[maxn][maxn];\nint Map[30][30];\nint row,col;\nint f(int i,int j)\n{\n    return i*m+j;\n}\nbool guass(int n)\n{\n\tint i=0,j=0,k,r,u;\n\twhile(i<n&&j<n)\n\t{\n\t\tr=i;\n\t\tfor(k=i;k<n;k++)\n\t\t\tif(matrix[k][j])\n\t\t\t{\n\t\t\t\tr=k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(matrix[r][j])\n\t\t{\n\t\t\tif(r!=i) for(k=0;k<=n;k++)swap(matrix[r][k],matrix[i][k]);\n\t\t\tfor(u=i+1;u<n;u++)if(matrix[u][j])\n\t\t\t\tfor(k=i;k<=n;k++) matrix[u][k]^=matrix[i][k];\n\t\t\ti++;\n\t\t}\n\t\tj++;\n\t}\n\tfor(;i<n;i++)if(matrix[i][n]==1)\n\t\treturn 0;\n\treturn 1;\n}\nint main()\n{\n    //freopen(\"data.in\",\"r\",stdin);\n    while(scanf(\"%d%d%d\",&n,&m,&d)&&(n&&m&&d))\n    {\n        memset(matrix,0,sizeof(matrix));\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n                scanf(\"%d\",&Map[i][j]);\n        col=row=n*m;\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n            {\n                matrix[f(i,j)][f(i,j)]=1;\n                matrix[f(i,j)][row]=Map[i][j];\n                for(int x=0;x<n;x++)\n                    for(int y=0;y<m;y++)\n                    {\n                        if(abs(x-i)+abs(y-j)==d)\n                        {\n                            matrix[f(i,j)][f(x,y)]=1;\n                        }\n                    }\n            }\n        if(guass(col))\n            printf(\"1\\n\");\n        else\n            printf(\"0\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int SIZE=25*25;\n\nint di[]={1,1,-1,-1};\nint dj[]={1,-1,-1,1};\nint inii[]={-1,0,1,0};\nint inij[]={0,1,0,-1};\nint solve(int m,int n,int d){\n    vector<bitset<SIZE>> bits(m*n);\n    vector<vector<int>> s(n,vector<int>(m));\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            cin>>s[i][j];\n        }\n    }\n    auto getV=[&](int i,int j){\n        return i*m+j;\n    };\n    auto isRange=[&](int i,int j){\n        return 0<=i && i<n && 0<=j && j<m;\n    };\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            bits[getV(i,j)][getV(i,j)]=true;\n            for(int dir=0;dir<4;dir++){\n                for(int k=0;k<d;k++){\n                    int toi=i+inii[dir]*d+di[dir]*k;\n                    int toj=j+inij[dir]*d+dj[dir]*k;\n                    if(isRange(toi,toj)){\n                        bits[getV(i,j)][getV(toi,toj)]=true;\n                    }\n                }\n            }\n        }\n    }\n    vector<int> flag(m*n);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            flag[getV(i,j)]=s[i][j];\n        }\n    }\n    int sz=n*m;\n    int row=0;\n    int col=0;\n    while(row<sz && col<sz){\n        int pivot=-1;\n        for(int j=row;j<sz;j++){\n            if(bits[j][col]){\n                pivot=j;\n                break;\n            }\n        }\n        if(pivot==-1){\n            col++;\n            continue;\n        }\n        else{\n            swap(bits[row],bits[pivot]);\n            swap(flag[row],flag[pivot]);\n            for(int i=0;i<sz;i++){\n                if(i!=row && bits[i][col]){\n                    bits[i]^=bits[row];\n                    flag[i]^=flag[row];\n                }\n            }\n            row++,col++;\n        }\n    }\n    for(int i=0;i<sz;i++){\n        if(bits[i]==0 && flag[i]){\n            return false;\n        }\n    }\n    return true;\n}\nint main(){\n    int m,n,d;\n    while(cin>>m>>n>>d,m){\n        cout<<solve(m,n,d)<<endl;        \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nconst double EPS = 1e-9;\ntemplate<class T> int GaussJordan(vector<vector<T>> &A, bool is_extended = false) {\n    int m = A.size(), n = A[0].size();\n    int rank = 0;\n    for (int col = 0; col < n; ++col) {\n        // 拡大係数行列の場合は最後の列は掃き出ししない\n        if (is_extended && col == n-1) break;\n\n        // ピボットを探す\n        int pivot = -1;\n        T ma = EPS;\n        for (int row = rank; row < m; ++row) {\n            if (abs(A[row][col]) > ma) {\n                ma = abs(A[row][col]);\n                pivot = row;\n            }\n        }\n        // ピボットがなかったら次の列へ\n        if (pivot == -1) continue;\n\n        // まずは行を swap\n        swap(A[pivot], A[rank]);\n\n        // ピボットの値を 1 にする\n        auto fac = A[rank][col];\n        for (int col2 = 0; col2 < n; ++col2) A[rank][col2] /= fac;\n\n        // ピボットのある列の値がすべて 0 になるように掃き出す\n        for (int row = 0; row < m; ++row) {\n            if (row != rank && abs(A[row][col]) > EPS) {\n                auto fac = A[row][col];\n                for (int col2 = 0; col2 < n; ++col2) {\n                    A[row][col2] ^= A[rank][col2] * fac;\n                }\n            }\n        }\n        ++rank;\n    }\n    return rank;\n}\n\ntemplate<class T> vector<T> linear_equation(vector<vector<T>> A, vector<T> b) {\n    // extended\n    int m = A.size(), n = A[0].size();\n    vector<vector<T>> M(m, vector<T>(n + 1));\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n    \n    // check if it has no solution\n    vector<T> res;\n    for (int row = rank; row < m; ++row) if (abs(M[row][n]) > EPS) return res;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return res;\n}\n\n\nvoid solve(int m,int n,int d){\n    vector<int> a(n*m);\n    rep(i,n)rep(j,m)cin>>a[m*i+j];\n    vector<vector<int>> mat(n*m,vector<int>(n*m));\n    rep(x1,n)rep(y1,m){\n        mat[x1*m+y1][x1*m+y1]=1;\n        rep(x2,n)rep(y2,m){\n            if(abs(x1-x2)+abs(y1-y2)==d){\n                mat[x1*m+y1][x2*m+y2]=1;\n            }\n        }\n    }\n    vector<int> res = linear_equation(mat,a);\n    if(!res.empty())cout<<1<<endl;\n    else cout<<0<<endl;\n\n}\nint main(){\n    int n,m,d;\n    while(cin>>n>>m>>d,n)solve(n,m,d);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <type_traits>\n#include <vector>\n#include <cstdint>\n#include <queue>\n#include <cmath>\n#include <utility>\n#include <bitset>\n#include <cassert>\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1308\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<usize column>\nclass bit_matrix\n{\npublic:\n    bit_matrix(const usize row) : row{row}, table(row) {}\n    bit_matrix(const bit_matrix& m) : row{m.row}, table{m.table} {}\n    bit_matrix& operator=(const bit_matrix& m)\n    {\n        assert(row == m.row), assert(column == m.column);\n        for (usize i = 0; i < row; i++) { table[i] = m[i]; }\n        return *this;\n    }\n    const std::bitset<column>& operator[](const usize r) const { return assert(r < row), table[r]; }\n    std::bitset<column>& operator[](const usize r) { return assert(r < row), table[r]; }\n    friend bit_matrix operator+(const bit_matrix& m) { return m; }\n    friend bit_matrix operator^(const bit_matrix& m1, const bit_matrix& m2)\n    {\n        assert(m1.row == m2.row);\n        bit_matrix ans(m1.row);\n        for (usize i = 0; i < m1.row; i++) { ans[i] = m1.table[i] ^ m2.table[i]; }\n        return ans;\n    }\n    template<usize col2>\n    friend bit_matrix operator*(const bit_matrix& m1, const bit_matrix<col2>& m2)\n    {\n        assert(column == m2.row);\n        bit_matrix<col2> ans(m1.row);\n        for (usize i = 0; i < m1.row; i++) {\n            for (usize j = 0; j < column; j++) {\n                if (not m1.table[i][j]) { continue; }\n                ans[i] ^= m2.table[j];\n            }\n        }\n        return ans;\n    }\n    friend bit_matrix operator^(const bit_matrix& m, const unsigned long long n) { return assert(m.row == m.column), n == 0 ? bit_matrix::id(m.row) : n % 2 == 1 ? m*(m ^ (n - 1)) : ((m * m) ^ (n / 2)); }\n    friend bit_matrix& operator^=(bit_matrix& m1, const bit_matrix& m2)\n    {\n        assert(m1.row == m2.row), assert(m1.column == m2.column);\n        for (usize i = 0; i < m1.row; i++) { m1.table[i] ^= m2.table[i]; }\n        return m1;\n    }\n    friend bit_matrix& operator*=(bit_matrix& m1, const bit_matrix& m2) { return m1 = m1 * m2; }\n    friend bit_matrix& operator^=(bit_matrix& m, const unsigned long long n) { return m = m ^ n; }\n    friend std::ostream& operator<<(std::ostream& os, const bit_matrix& m)\n    {\n        os << \"[\\n\";\n        for (usize i = 0; i < m.row; i++) { os << \"[\" << m[i] << \"]\\n\"; }\n        return (os << \"]\\n\");\n    }\n    static bit_matrix id(const usize n)\n    {\n        bit_matrix ans(n);\n        for (usize i = 0; i < n; i++) { ans[i].set(i); }\n        return ans;\n    }\n    usize row;\n\nprivate:\n    std::vector<std::bitset<column>> table;\n};\ntemplate<usize column>\nbit_matrix<column> gauss_jordan(bit_matrix<column> mat)\n{\n    for (usize r = 0, ci = 0; ci < column; ci++) {\n        const usize c = column - ci - 1;\n        if (r == mat.row) { break; }\n        usize piv = r;\n        for (; piv < mat.row and not mat[piv][c]; piv++) {}\n        if (piv == mat.row) { continue; }\n        std::swap(mat[piv], mat[r]);\n        for (usize j = 0; j < mat.row; j++) {\n            if (j == r) { continue; }\n            if (mat[j][c]) { mat[j] ^= mat[r]; }\n        }\n        r++;\n    }\n    return mat;\n}\nint main()\n{\n    while (true) {\n        const auto M = in<int>(), N = in<int>();\n        const auto D = in<int>();\n        if (M == 0 and N == 0 and D == 0) { break; }\n        using vec = std::bitset<625>;\n        bit_matrix<625> mat(M * N);\n        vec target;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                const int t = i * M + j;\n                int s       = in<int>();\n                target[t]   = s;\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                const int t = i * M + j;\n                for (int ni = 0; ni < N; ni++) {\n                    for (int nj = 0; nj < M; nj++) {\n                        const int nt = ni * M + nj;\n                        const int d  = std::abs(ni - i) + std::abs(nj - j);\n                        if (d == 0 or d == D) { mat[t][nt] = 1; }\n                    }\n                }\n            }\n        }\n        const auto gm = gauss_jordan(mat);\n        for (int i = 0; i < M * N; i++) {\n            const auto ntarget = target ^ gm[i];\n            if (ntarget.to_string() < target.to_string()) {\n                target = ntarget;\n            }\n        }\n        outln(target == vec{} ? 1 : 0);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nconst Int MAX = 2002;\nusing BS = bitset<MAX*2>;\nusing mat = vector<BS>;\n\nvoid gauss(mat &v){\n  int n=v.size();\n  for(Int i=0;i<n;i++){\n    for(Int k=i;k<n;k++){\n      if(v[k][i]){\n\tswap(v[i],v[k]);\n\tbreak;\n      }\n    }\n    for(Int k=0;k<n;k++)\n      if(i!=k&&v[k][i]) v[k]^=v[i];\n  }\n}\n\nint mrank(mat v,int m){\n  int n=v.size();\n  int r=0,c=0;\n  for(int i=0;i<n;i++){\n    int s=-1;\n    while(c<m){\n      for(int j=i;j<n;j++){\n\tif(v[j][c]){\n\t  s=j;\n\t  break;\n\t}\n      }\n      if(~s) break;\n      c++;\n    }\n    if(c>=m) break;\n    \n    swap(v[i],v[s]);\n    for(int j=0;j<n;j++)\n      if(i!=j&&v[j][c]) v[j]^=v[i];\n    \n    r++;c++;\n  }\n  return r;\n}\n\nmat mul(const mat &a,const mat &b){\n  int n=a.size();\n  vector<vector<int> > tmp(n,vector<int>(n,0));\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\ttmp[i][j]+=(a[i][k]&b[k][j]);\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      res[i][j]=tmp[i][j]&1;\n  \n  return res;\n}\n\nmat mat_pow(mat v,int k){\n  int n=v.size();\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    res[i][i]=1;\n  while(k){\n    if(k&1) res=mul(res,v);\n    v=mul(v,v);\n    k>>=1;\n  }\n  return res;\n}\n\n//END CUT HERE\nsigned CFR382_D(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m;\n  cin>>n>>m;\n  mat v(n,BS(0));\n  for(Int i=0;i<n;i++) v[i][n+i]=1;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++){\n    cin>>a[i]>>b[i];\n    a[i]--;b[i]--;\n    v[a[i]][b[i]]=1;\n  }\n  gauss(v);\n  for(Int i=0;i<m;i++)\n    cout<<(v[b[i]][a[i]+n]?\"NO\":\"YES\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://codeforces.com/contest/736/problem/D\n*/\n\nsigned ARC054_D(){\n  int n;\n  cin>>n;\n  mat v(n,BS(0));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      char c;\n      cin>>c;\n      v[i][j]=c-'0';\n    }\n  }\n  gauss(v);\n  int ans=1;\n  for(int i=0;i<n;i++) ans&=v[i][i];\n  cout<<(ans?\"Odd\":\"Even\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/22\nhttps://beta.atcoder.jp/contests/arc054/tasks/arc054_c\n*/\n\nsigned AOJ_1308(){\n  int m,n,d;\n  while(cin>>m>>n>>d,m){\n    vector<vector<int> > s(n,vector<int>(m));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tcin>>s[i][j];\n\n    mat v(n*m,BS(0));\n    auto idx=[&](int y,int x){return y*m+x;};\n    auto in=[&](int y,int x){return 0<=y&&y<n&&0<=x&&x<m;};\n    auto bfs=[&](int y,int x){\n      int z=idx(y,x);\n      v[z][z]=1;\n      v[z][n*m]=s[y][x];\n      \n      vector<vector<int> > dp(n,vector<int>(m,-1));\n      using P = pair<int, int>;\n      queue<P> q;\n      dp[y][x]=0;\n      q.emplace(y,x);\n      int dy[]={0,0,1,-1};\n      int dx[]={1,-1,0,0};\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(dp[y][x]==d) v[z][idx(y,x)]=1;\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=dp[y][x]+1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    \n    int a=mrank(v,n);\n    int b=mrank(v,n+1);\n    cout<<(a==b)<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1308\n*/\n\nsigned AOJ_2624(){\n  int n;\n  cin>>n;\n  mat v(n,BS(0));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int k;\n      cin>>k;\n      v[i][j]=k;\n    }\n  }\n  BS w;\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    w[i]=k;\n  }\n  int t;\n  cin>>t;\n  v=mat_pow(v,t);\n\n  int a=mrank(v,n);\n  for(int i=0;i<n;i++) v[i][n]=w[i];\n  int b=mrank(v,n+1);\n\n  if(a!=b){\n    cout<<\"none\"<<endl;\n    return 0;\n  }\n\n  if(a!=n){\n    cout<<\"ambiguous\"<<endl;\n    return 0;\n  }\n  \n  gauss(v);\n  for(int i=0;i<n;i++) cout<<v[i][n]<<\" \\n\"[i==n-1];\n  \n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2624\n*/\n\n\n\nsigned main(){\n  //CFR382_D();\n  //ARC054_D();\n  AOJ_1308();\n  //AOJ_2624();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n\nint modNorm(int a, int m) {\n  return (a%m+m)%m;\n}\n\n// ax+by=gcd(a,b)\nint extgcd(int a, int b, int &x, int &y) {\n  int g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nint invMod(int a, int p) {\n  int x, y;\n  if (extgcd(a,p,x,y) == 1) return (x+p)%p;\n  return 0;\n}\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nostream &operator<<(ostream &os, const vec &a) {\n  FOR(it, a) os << *it << \" \";\n  return os;\n}\nostream &operator<<(ostream &os, const mat &a) {\n  FOR(it, a) os << *it << endl;\n  return os;\n}\n\nbool modGaussElimination(const mat &A, const vec &b, int m, vec &res) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  REP(i,n) REP(j,n)\n    B[i][j] = A[i][j];\n  REP(i, n) B[i][n] = b[i];\n\n  //cout << B << endl;\n  int nowy = 0;\n  REP(x, n) {\n    int pivot = -1;\n    for (int j=nowy; j<n; ++j)\n      if (B[j][x]) {\n        pivot = j;break;\n      }\n    if (pivot == -1) continue;\n    swap(B[nowy], B[pivot]);\n\n    for (int j=nowy+1; j<n; ++j) {\n      int t = B[j][x] * invMod(B[nowy][x], m) % m;\n      if (t)\n        for (int k=x; k<=n; ++k)\n          B[j][k] = modNorm(B[j][k] - B[nowy][k] * t, m);\n    }\n    nowy++;\n  }\n  res.clear();\n  for (int y=nowy; y<n; ++y)\n    if (B[y][n])                // rank(A) != rank(A|b)\n      return 0;\n  if (nowy != n) {              // rank(A) == rank(A|b) != n\n    // 解が一意でない。ひとつ求める\n    res = vec(n,INF);           // INFは任意を表す\n    for (int y=n-1; y>=0; --y) {\n      int x;\n      for (x=y; x<n; ++x) {\n        if (B[y][x])\n          break;\n      }\n      if (x==n) continue;\n      int sum = B[y][n];\n\n      for (int i=x+1; i<n; ++i) {\n        if (res[i] == INF) res[i] = 0; // この時点でres[i]が決まってなかったら0とする\n        sum = modNorm(sum - res[i] * B[y][i], m);\n      }\n      res[x] = sum * invMod(B[y][x], m) % m;\n    }\n    REP(i, n) if (res[i]==INF) res[i] = 0;\n    return 0;\n  }\n  // 解が一意に決まる。普通に後退代入\n  res.resize(n);\n  for (int x=n-1; x>=0; --x) {\n    int sum = B[x][n];\n    for (int i=n-1; i>x; --i) {\n      sum = modNorm(sum - res[i] * B[x][i], m);\n    }\n    res[x] = sum * invMod(B[x][x], m) % m;\n  }\n\n  return 1;\n}\n\nint main() {\n  int m, n, d;\n  int c = 0;\n  while(cin>>m>>n>>d, m||n||d) {\n    bool ba[n][m];\n    mat A(n*m, vec(n*m));\n    vec b(n*m);\n    REP(i,n) {\n      REP(j,m) {\n        cin >> ba[i][j];\n        A[i*m+j][i*m+j] = 1;\n        REP(k,n) {\n          REP(l,m) {\n            int dis = abs(i-k)+abs(j-l);\n            if (dis == d) {\n              A[k*m+l][i*m+j] = 1;\n            }\n          }\n        }\n        b[i*m+j] = ba[i][j];\n      }\n    }\n    vec x;\n    modGaussElimination(A,b,2,x);\n    cout << (x.size() != 0) << endl;\n\n    // if (x.size()) {             // 解法表示\n    //   REP(i, n) {\n    //     REP(j, m) {\n    //       cout << x[i*m+j] << \" \";\n    //     }\n    //     cout << endl;\n    //   }\n    // } else\n    //   cout << \"no solution\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint getrank(mat A,int mod) {\n  int H = A.size(), W = A[0].size();\n  int r = 0;\n  for(int x = 0; x < W; x++){  \n    int pivot = -1;\n    for(int y = r; y < H; y++) if(A[y][x]) {\n      pivot = y;\n      break;\n    }\n    if( pivot == -1 )continue;\n    swap(A[r], A[pivot]);\n    for(int y = r+1; y < H; y++) {\n      int value = A[y][x] % mod;\n      // int value = A[y][x] / A[r][x];\n      if(value) for(int x2 = x; x2 < W; x2++) A[y][x2] = ((A[y][x2] - A[r][x2] * value)%mod + mod ) % mod;\n    }\n    r++;\n  }\n  return r;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    int m,n,d;\n    cin>>m>>n>>d;\n    if(m==0)break;\n    int N=n*m;\n    mat A(N,vec(N,0)),Ab(N,vec(N+1,0));\n    rep(i,n)rep(j,m){\n      int a=i*m+j;\n      A[a][a]=Ab[a][a]=1;\n      rep(ni,n)rep(nj,m){\n        int b=ni*m+nj;\n        if(abs(i-ni)+abs(j-nj)==d)A[a][b]=Ab[a][b]=1;\n      }\n      cin>>Ab[a][N];\n    }\n\n    cout<<(getrank(A,2)==getrank(Ab,2)?1:0)<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nvec gauss_jordan(const mat& A,const vec& b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  vector<int> can(n,1);\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j]; //n*(n+1)の配列にする。\n\n  for(int i=0;i<n;i++)B[i][n]=b[i]; //n番目に代入\n\n  for(int i=0;i<n;i++){\n    int pivot=i;//次の基準となる添え字。\n    for(int j=0;j<n;j++)if(can[j] && B[j][i])pivot=j;//0以外の1つを探す\n    swap(B[i],B[pivot]);//i行目に持ってくる。\n    if(B[i][i]==1)can[i] = 0;\n\n    \n    for(int j=0;j<n;j++){ //\n      if(i!=j && B[j][i])//i行目-i行目はスキップ\n        for(int k=i;k<=n;k++)B[j][k]=B[j][k] ^ B[i][k];//i列の値をi列目以外を0にする。\n    }\n  }\n  \n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  \n  int many = 0;\n  for(int i=0;i<n;i++){\n    if(B[i][i] == 0) many = 1;\n    if(B[i][i] == 0 && B[i][n] == 1) return vec();\n  }\n  if(many) return vec(n+1);\n  return x;\n}\n\nsigned main(){\n  \n  while(1){\n    \n    int w, h, d;\n    cin>>w>>h>>d;\n    \n    if( !w && !h && !d ) break;\n    \n    int a[25][25];\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++) cin>>a[i][j];\n    \n    mat A( h * w, vec( h * w ) );\n    \n    vec B( h * w );\n    \n    for(int i=0;i<h;i++){\n      \n      for(int j=0;j<w;j++){\n\t\n\tint idx = i * w + j;\n\t\n\tB[idx] = a[i][j];\n\tA[idx][idx] = 1;\n\t\n\tfor(int ni=0;ni<h;ni++){\n\t  \n\t  for(int nj=0;nj<w;nj++){\n\t    \n\t    if( abs( ni - i ) + abs( nj - j ) != d ) continue;\n\t    \n\t    int nidx = ni * w + nj;\n\t    \n\t    A[idx][nidx] = 1;\n\t    \n\t  }\n\t  \n\t}\n\t\n      }\n      \n    }\n    \n    vec ans = gauss_jordan( A, B );\n    \n    if( (int)ans.size() > 0 ) cout<<1<<endl;\n    else cout<<0<<endl;\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[]={-1,0,1,0},dx[]={0,-1,0,1},dy2[]={1,-1,-1,1},dx2[]={1,1,-1,-1};\nint m,n,d,s[25][25];\nint main()\n{\n\twhile(cin>>m>>n>>d,m){\n\t\tint N=m*n;\n\t\tvector<vi> a(N,vi(N+1,0));\n\t\trep(i,m)rep(j,n)cin>>s[i][j], a[i*n+j][N]=s[i][j];\n\t\t\n\t\trep(i,N)(a[i][i]+=1)%=2;\n\t\trep(i,m)rep(j,n)rep(dir,4)rep(k,d){\n\t\t\tint y=i+dy[dir]*d+dy2[dir]*k, x=j+dx[dir]*d+dx2[dir]*k;\n\t\t\tif(0<=y&&y<m&&0<=x&&x<n){\n\t\t\t\t(a[y*n+x][i*n+j]+=1)%=2;\n\t\t\t}\n\t\t}\n\t\trep(i,N){\n\t\t\tswap(a[i],*max_element(a.begin()+i,a.end()));\n\t\t\tif(a[i][i]){\n\t\t\t\trep(j,N)if(i<j&&a[j][i])rep(k,N+1)(a[j][k]+=a[i][k])%=2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool ok=1; int j=0;\n\t\trep(i,N)if(ok&&a[i][N]){\n\t\t\tfor(;j<N&&a[i][j]==0;j++);\n\t\t\tif(j>=N)ok=0;\n\t\t}\n\t\tcout<<(int)ok<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef int Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return (abs(dat) < EPS); }\n\nMatrix operator-(Matrix mat) {\n\tREP(i, mat.size()) REP(j, mat[0].size()) mat[i][j] = -mat[i][j];\n\treturn mat;\n}\n\nMatrix operator+(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] + rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator-(Matrix lhs, const Matrix &rhs) {\n\tREP(i, lhs.size()) REP(j, lhs[0].size()) lhs[i][j] = lhs[i][j] - rhs[i][j];\n\treturn lhs;\n}\n\nMatrix operator*(const Matrix &lhs, const Matrix &rhs) {\n\tMatrix res(lhs.size(), Array(rhs[0].size(), 0));\n\tREP(i, lhs.size()) REP(j, rhs[0].size()) REP(k, rhs.size())\n\t\tres[i][j] = fma(lhs[i][k], rhs[k][j], res[i][j]);\n\treturn res;\n}\n\nArray operator+(const Array &lhs, const Array &rhs) {\n\tArray res = lhs;\n\tREP(i, rhs.size()) res[i] = res[i] + rhs[i];\n\treturn res;\n}\n\nArray operator*(const Matrix &lhs, const Array &rhs) {\n\tArray res(lhs.size());\n\tREP(i, lhs.size())\n\t\tres[i] = inner_product(begin(lhs[i]), end(lhs[i]), begin(rhs), Data(0));\n\treturn res;\n}\n\nArray operator*(Data scalar, const Array &rhs) {\n\tArray res(rhs.size());\n\tREP(i, rhs.size())\n\t\tres[i] = scalar * rhs[i];\n\treturn res;\n}\n\nbool gauss_jordan(const Matrix& A, const Array& b)\n{\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tREP(i, n)REP(j, n) B[i][j] = A[i][j];\n\tREP(i, n) B[i][n] = b[i];\n\tREP(i, n)\n\t{\n\t\tint pivot = i;\n\t\tFOR(j, i + 1, n)\n\t\t{\n\t\t\tif (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (i != j && B[j][i])\n\t\t\t{\n\t\t\t\tFOR(k, i + 1, n + 1) B[j][k] = (B[j][k] + B[i][k]) % 2;\n\t\t\t}\n\t\t}\n\t}\n\tArray x(n);\n\tREP(i, n) x[i] = B[i][n];\n\tREP(i, n)\n\t{\n\t\tint p = 0;\n\t\tREP(j, n)\n\t\t{\n\t\t\tif (A[i][j]) p = (p + x[j]) % 2;\n\t\t}\n\t\tif (p != b[i]) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint m, n, d;\n\twhile (cin >> m >> n >> d, n)\n\t{\n\t\tArray s(n*m);\n\t\tMatrix mat(n*m, Array(n*m));\n\t\tREP(i, n*m)\n\t\t{\n\t\t\tint a; cin >> a;\n\t\t\ts[i] = a;\n\t\t}\n\t\tREP(i, n)REP(j, m)\n\t\t{\n\t\t\tint p = i*m + j;\n\t\t\tREP(k, n)REP(l, m)\n\t\t\t{\n\t\t\t\tint q = k*m + l;\n\t\t\t\tif (p == q || abs(i - k) + abs(j - l) == d) mat[p][q] = 1;\n\t\t\t\telse mat[p][q] = 0;\n\t\t\t}\n\t\t}\n\t\tif (gauss_jordan(mat, s)) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\n\nint abs(int x){ x > 0 ? x : -x; }\n\nint main(){\n\tint m, n, d;\n\twhile(cin >> m >> n >> d, m){\n\t\tvector< vector<int> > v(n*m, vector<int>(n*m+1,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tcin >> v[i*m+j][n*m];\n\t\t\t\tfor(int ii=0;ii<n;ii++){\n\t\t\t\t\tfor(int jj=0;jj<m;jj++){\n\t\t\t\t\t\tint dist = abs(i-ii)+abs(j-jj);\n\t\t\t\t\t\tif(dist==0||dist==d) v[ii*m+jj][i*m+j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cur = 0;\n\t\tfor(int i=0;i<n*m;i++){\n\t\t\tint chg = cur;\n\t\t\twhile(chg<n*m && v[chg][i]==0) chg++;\n\t\t\tif(chg == n*m) continue;\n\t\t\tswap(v[cur], v[chg]);\n\t\t\tfor(int j=cur+1;j<n*m;j++){\n\t\t\t\tif(v[j][i]){\n\t\t\t\t\tfor(int k=i;k<n*m+1;k++)\n\t\t\t\t\t\tv[j][k] = (v[j][k]+v[cur][k])%2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\tint res = 1;\n\t\tfor(int i=cur;i<n*m;i++)\n\t\t\tif(v[i][n*m] == 1) res = 0;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nconst Int MAX = 2002;\nusing BS = bitset<MAX*2>;\nusing mat = vector<BS>;\n\nvoid gauss(mat &v){\n  int n=v.size();\n  for(Int i=0;i<n;i++){\n    for(Int k=i;k<n;k++){\n      if(v[k][i]){\n\tswap(v[i],v[k]);\n\tbreak;\n      }\n    }\n    for(Int k=0;k<n;k++)\n      if(i!=k&&v[k][i]) v[k]^=v[i];\n  }\n}\n\nint mrank(mat v,int m){\n  int n=v.size();\n  int r=0,c=0;\n  for(int i=0;i<n;i++){\n    int s=-1;\n    while(c<m){\n      for(int j=i;j<n;j++){\n\tif(v[j][c]){\n\t  s=j;\n\t  break;\n\t}\n      }\n      if(~s) break;\n      c++;\n    }\n    if(c>=m) break;\n    \n    swap(v[i],v[s]);\n    for(int j=0;j<n;j++)\n      if(i!=j&&v[j][c]) v[j]^=v[i];\n    \n    r++;c++;\n  }\n  return r;\n}\n\nmat mul(const mat &a,const mat &b){\n  int n=a.size();\n  vector<vector<int> > tmp(n,vector<int>(n,0));\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\ttmp[i][j]+=(a[i][k]&b[k][j]);\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      res[i][j]=tmp[i][j]&1;\n  \n  return res;\n}\n\nmat mat_pow(mat v,int k){\n  int n=v.size();\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    res[i][i]=1;\n  while(k){\n    if(k&1) res=mul(res,v);\n    v=mul(v,v);\n    k>>=1;\n  }\n  return res;\n}\n\n//END CUT HERE\nsigned CFR382_D(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m;\n  cin>>n>>m;\n  mat v(n,BS(0));\n  for(Int i=0;i<n;i++) v[i][n+i]=1;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++){\n    cin>>a[i]>>b[i];\n    a[i]--;b[i]--;\n    v[a[i]][b[i]]=1;\n  }\n  gauss(v);\n  for(Int i=0;i<m;i++)\n    cout<<(v[b[i]][a[i]+n]?\"NO\":\"YES\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://codeforces.com/contest/736/problem/D\n*/\n\nsigned ARC054_D(){\n  int n;\n  cin>>n;\n  mat v(n,BS(0));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      char c;\n      cin>>c;\n      v[i][j]=c-'0';\n    }\n  }\n  gauss(v);\n  int ans=1;\n  for(int i=0;i<n;i++) ans&=v[i][i];\n  cout<<(ans?\"Odd\":\"Even\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/22\nhttps://beta.atcoder.jp/contests/arc054/tasks/arc054_c\n*/\n\nsigned AOJ_1308(){\n  int m,n,d;\n  while(cin>>m>>n>>d,m){\n    vector<vector<int> > s(n,vector<int>(m));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tcin>>s[i][j];\n\n    mat v(n*m,BS(0));\n    auto idx=[&](int y,int x){return y*m+x;};\n    auto in=[&](int y,int x){return 0<=y&&y<n&&0<=x&&x<m;};\n    auto bfs=[&](int y,int x){\n      int z=idx(y,x);\n      v[z][z]=1;\n      v[z][n*m]=s[y][x];\n      \n      vector<vector<int> > dp(n,vector<int>(m,-1));\n      using P = pair<int, int>;\n      queue<P> q;\n      dp[y][x]=0;\n      q.emplace(y,x);\n      int dy[]={0,0,1,-1};\n      int dx[]={1,-1,0,0};\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(dp[y][x]==d) v[z][idx(y,x)]=1;\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=dp[y][x]+1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    \n    int a=mrank(v,n);\n    int b=mrank(v,n+1);\n    cout<<(a==b)<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1308\n*/\n\nsigned AOJ_2624(){\n  int n;\n  cin>>n;\n  mat v(n,BS(0));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int k;\n      cin>>k;\n      v[i][j]=k;\n    }\n  }\n  BS w;\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    w[i]=k;\n  }\n  int t;\n  cin>>t;\n  v=mat_pow(v,t);\n\n  int a=mrank(v,n);\n  for(int i=0;i<n;i++) v[i][n]=w[i];\n  int b=mrank(v,n+1);\n\n  if(a!=b){\n    cout<<\"none\"<<endl;\n    return 0;\n  }\n\n  if(a!=n){\n    cout<<\"ambiguous\"<<endl;\n    return 0;\n  }\n  \n  gauss(v);\n  for(int i=0;i<n;i++) cout<<v[i][n]<<\" \\n\"[i==n-1];\n  \n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2624\n*/\n\n\n\nsigned main(){\n  //CFR382_D();\n  //ARC054_D();\n  AOJ_1308();\n  //AOJ_2624();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n  \nusing namespace std;\n  \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n  \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n  \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n  \nint main(){\n  int M, N, D;\n  while (cin>>N>>M>>D && M) {\n    int S[25][25];\n    REP(i, M)REP(j, N) cin>>S[i][j];\n    int G[25 * 25][26] = {};\n    REP(i, M)REP(j, N){\n      REP(k, M)REP(l, N){\n        if(abs(i - k) + abs(j - l) == D || (i == k && j == l)){\n          G[i + M * j][k] |= 1<<l;\n        }\n      }\n      G[i + M * j][25] = S[i][j];\n    }\n    bool ans = true;\n    for(int i = 0; i < M * N; i++){\n      int pivot = -1;\n      for(int j = i; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))) pivot = j;\n      }\n      if(pivot == -1) continue;\n      int tmp[26];\n      //swap(G[i], G[pivot]);\n      memcpy(tmp, G[i], sizeof(tmp));\n      memcpy(G[i], G[pivot], sizeof(tmp));\n      memcpy(G[pivot], tmp, sizeof(tmp));\n      for(int j = i + 1; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))){\n          for(int k = 0; k < M; k++){\n            G[j][k] ^= G[i][k];\n          }\n          G[j][25] ^= G[i][25];\n        }\n      }\n    }\n    for(int i = M * N - 1; i >= 0; i--){\n      if(!(G[i][i / N] & (1 << (i % N))) && G[i][25]){\n        ans = false;\n      }\n    }\n    if(ans) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\n// KEXÌÁ@ÅA§®ðÆ­\nvoid gauss_jordan(const mat&A,const vec &b,vector<int> &res){\n\tint n=A.size();\n\tmat B(n,vec(n+1));\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)B[i][j]=A[i][j];\n\tfor(int i = 0; i < n; i++)B[i][n]=b[i];\n\t// eÏÉÚ\n\tfor(int i = 0; i < n; i++){\n\t\t// evfð2ÅÁ½]èÉu«·¦é\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tif(abs(B[j][k])%2==1)B[j][k]=B[j][k]%2;\n\t\t\t\telse if(B[j][k]==0)B[j][k]=0;\n\t\t\t\telse if(B[j][k]>0)B[j][k]=2;\n\t\t\t\telse B[j][k]=-2;\n\t\t\t}\n\t\t\tB[j][n]=B[j][n]%2;\n\t\t}\n\t\t// ÅåÌWÌâÎlðàÂàÌðiÔÚÉÁÄ­é\n\t\tint piv=-1;\n\t\tint val=-1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(abs(B[j][i])==1){\n\t\t\t\tpiv=j;\n\t\t\t\tval=abs(B[j][i]);\n\t\t\t}\n\t\t}\n\t\t// ðª¡Ü½Íðª³¢\n\t\tif(piv==-1||val<EPS){\n\t\t\tif(B[i][n]!=0){\n\t\t\t\tres=vec();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ðª¡¶Ý·éÌÅA»Ì¤¿ÌêÂðßé\n\t\t\t\tB[i][n]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswap(B[piv],B[i]);\n\t\t// isÚð»ê¼êB[piv][i]ÌlÅé\n\t\tint divNum=B[i][i];\n\t\tfor(int j = i; j <= n; j++)B[i][j]/=divNum;\n\t\t// »ê¼êÌs©çAisÚÌlðø­©ñ¶\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i==j)continue;\n\t\t\tint mulnum=B[j][i];\n\t\t\tfor(int k = i; k <= n; k++)B[j][k]-=mulnum*B[i][k];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)res[i]=B[i][n];\n}\n\nint main(){\n\tint m,n,d;\n\tint field[30][30];\n\twhile(cin>>m>>n>>d&&(m|n|d)){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\tcin>>field[i][j];\n\t\tint mtSize=m*n;\n\t\tmat mt(mtSize,vec(mtSize));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t// (m*i+j)sÚÌsñÌeñÉÂ¢Äè\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tfor(int l=0;l<m;l++){\n\t\t\t\t\t\tint mhd=abs(k-i)+abs(l-j);\n\t\t\t\t\t\tmt[m*i+j][m*k+l]=(mhd==d||mhd==0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> r;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)r.push_back(field[i][j]);\n\t\tvec res(mtSize);\n\t\tgauss_jordan(mt,r,res);\n\t\tif(res.size()==0)cout<<0<<endl;\n\t\telse cout<<1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\ntypedef unsigned int ui;\n\n#define forn(i,n) for (int i = 0; i < int(n); i++)\n#define pb push_back\n#define si(c) ((int)(c).size())\ntypedef vector<ui> vi;\n\nconst int MAXN = 700;\n\nint m,n,d;\nvector<ui> row[MAXN*MAXN];\n\nint id(int i, int j) { return i*m + j; }\n\nvoid mark(int i, int j) {\n\trow[i][j>>5] |= ui(1)<<(j&31);\n}\n\nbool check(int i, int j) { return row[i][j>>5] & (1<<(j&31)); }\n\nvoid operator^=(vi &a, const vi &b) {\n        int n =si(a);\n        assert(n = si(b));\n        forn(i,n) a[i] ^= b[i];\n}\n\nvoid init(int N) {\n\tint sz = N/32 + 1;\n\tforn(i,N) row[i].clear(), row[i].resize(sz,0);\n}\n\nint main(int argc, char *argv[])\n{\n    ios_base::sync_with_stdio(false);\n\twhile (cin >> m >> n >> d && n) {\n\t\tint target = m*n;\n\t\tinit(target);\n\t\tforn(i,n) forn(j,m) {\n\t\t\tvi cols;\n\t\t\tint x; cin >> x;\n\t\t\tif (x) cols.pb(target);\n            cols.pb(id(i,j));\n\t\t\tfor (int ii = max(0,i-d); ii <= min(n-1,i+d); ii++) {\n\t\t\t\tint di = abs(i-ii), dj = d - di;\n\t\t\t\tint jj = j - dj;\n\t\t\t\tif (jj >= 0) cols.pb(id(ii,jj));\n\n\t\t\t\tif (dj == 0) continue;\n\t\t\t\tjj = j + dj;\n\t\t\t\tif (jj < m) cols.pb(id(ii,jj));\n\t\t\t}\n\t\t\tint ID = id(i,j);\n\t\t\tfor (int c : cols) mark(ID,c);\n\t\t}\n\n        vector<bool> vis(target,false);\n        forn(j,target) {\n                forn(i,target) if (!vis[i] && check(i,j)) {\n                        vis[i] = true;\n                        forn(i2,target) if (!vis[i2] && check(i2,j)) row[i2] ^= row[i];\n                        break;\n                }\n        }\n        vi bad(si(row[0]),0);\n        bad[target>>5] |= 1<<(target&31);\n        \n        bool res = true;\n        forn(i,target) if (row[i] == bad) { res = false; break; }\n\n        cout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\n#include <ctime>\n#include <numeric>\n#include <fstream>\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst long double pi=acos(-1.0);\nint dx[]={0,1,0,-1,1,1,-1,-1,0},dy[]={1,0,-1,0,1,-1,1,-1,0};\n\n\nint n,m,d;\n\n\nvoid solve(){\n  int mat[n*m][n*m+1];\n  memset(mat,0,sizeof(mat));\n\n  rep(i,m*n+1)mat[i][i]=1;\n  queue<PI> q;\n  q.push(mp(0,0));\n  set<PI> app;\n  vector<PI> man;\n  while(!q.empty()){\n    int cx=q.front().F;\n    int cy=q.front().S;\n    q.pop();\n    if(app.count(mp(cx,cy)))continue;\n    app.insert(mp(cx,cy));\n    if(abs(cx)+abs(cy)==d){\n      man.pb(mp(cx,cy));\n      continue;\n    }\n\n    rep(i,4){\n      int nx=cx+dx[i],ny=cy+dy[i];\n      if(app.count(mp(nx,ny)))continue;\n      q.push(mp(nx,ny));\n    }\n  }\n\n  rep(i,m*n)\n    FOR(it,man){\n    int x=i/m+it->F,y=i%m+it->S;\n    if(min(x,y)<0 || x>=n || y>=m)continue;\n    mat[i][x*m+y]=1;\n  }\n\n  rep(i,n)rep(j,m)\n    cin>>mat[i*m+j][m*n];\n\n\n  int ofs=0;\n  for(int i=0;i+ofs<m*n;++i){\n    /*\n    rep(j,m*n){\n      rep(k,m*n+1)cout<<mat[j][k]<<' ';\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n    if(!mat[i][i+ofs])\n      for(int j=m*n-1;j>i;--j)\n        if(mat[j][i+ofs]){\n          for(int k=0;k<m*n+1;++k)\n            swap(mat[i][k],mat[j][k]);\n          break;\n        }\n    \n    if(mat[i][i+ofs]){\n      for(int j=i+1;j<m*n;++j)\n        if(mat[j][i+ofs])\n          rep(k,m*n+1)\n            mat[j][k]^=mat[i][k];\n    }else ++ofs,--i;\n  }\n\n  for(int i=m*n-1;i>m*n-1-ofs;--i)\n    if(mat[i][m*n]){\n      cout<<0<<endl;\n      return;\n    }\n\n  cout<<1<<endl;\n}\n\nmain(){\n  while(cin>>n>>m>>d,n|m|d)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint calc_rank(mat A) {\n\tconst int n = A.size();\n\tconst int m = A[0].size();\n\n\tint res = 0;\n\tint col = -1;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint pivot;\n\t\tfor(;;) {\n\t\t\tif(++col == m) goto rank_end;\n\t\t\tpivot = -1;\n\t\t\tfor(int j = i; j < n; ++j) {\n\t\t\t\tif(A[j][col]) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tgoto pivot_end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tpivot_end:;\n\t\tA[i].swap(A[pivot]);\n\t\t++res;\n\n\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\tif(A[j][col]) {\n\t\t\t\tfor(int k = col + 1; k < m; ++k) {\n\t\t\t\t\tA[j][k] ^= A[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nrank_end:;\n\treturn res;\n}\n\nint calc_rank(const mat &A, const vec &b) {\n\tconst int n = A.size();\n\tconst int m = A[0].size() + 1;\n\tmat B(n, vec(m));\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < m - 1; ++j) {\n\t\t\tB[i][j] = A[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < n; ++i) {\n\t\tB[i][m - 1] = b[i];\n\t}\n\treturn calc_rank(move(B));\n}\n\nint w, h, d;\n\ninline bool solve(const mat &A, const vec &b) {\n\treturn calc_rank(A) == calc_rank(A, b);\n}\n\ninline int get_index(int x, int y) {\n\treturn x + y * w;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h >> d && h) {\n\t\tconst int number_of_cell = w * h;\n\t\tvec right(number_of_cell);\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tcin >> right[get_index(x, y)];\n\t\t\t}\n\t\t}\n\n\t\tmat left(number_of_cell, vec(number_of_cell, 0));\n\t\tfor(int i = 0; i < number_of_cell; ++i) {\n\t\t\tleft[i][i] = 1;\n\t\t}\n\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int ty = max(0, y - d); ty <= min(h - 1, y + d); ++ty) {\n\t\t\t\tfor(int sign = -1; sign <= 1; sign += 2) {\n\t\t\t\t\tconst int dx = sign * (d - abs(y - ty));\n\t\t\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\t\t\tconst int tx = x + dx;\n\t\t\t\t\t\tif(tx < 0 || tx >= w) continue;\n\t\t\t\t\t\tleft[get_index(x, y)][get_index(tx, ty)] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(left, right) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>//\"geometry.cpp\"\n#include<iomanip>//\"cout<<fixed<<setprecision(n)<<sth<<endl;\"\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<functional>//\"greater<T>\" Ex. sort(a,a+n,greater<int>());\n#include<cmath>//\"abs\", \"sqrt\"\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\n#define is insert\t//tentative\n\n//the maximum number of variants\n#define MATRIX_MAX_X 625//Caution! You need additional information here.\n\n#define MATRIX_T int//Caution! You need additional information here.\ntypedef vector<MATRIX_T> vec;//Be careful of the clash of type names, especially with vec in \"geometry.cpp\".\ntypedef vector<vec> mat;\n\nvec gauss_jordan(mat A,vec b){//MATRIX_T should be double, etc.\n\tint rk=0,f[MATRIX_MAX_X];\n\tfill(f,f+A[0].size(),-1);\n\tmat B(A.size(),vec(A[0].size()+1));\n\tfor(int i=0;i<A.size();++i){\n\t\tfor(int j=0;j<A[0].size();++j){\n\t\t\tB[i][j]=A[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<A.size();++i){\n\t\tB[i][A[0].size()]=b[i];\n\t}\n\tfor(int j=0;j<A[0].size()&&rk<A.size();++j){\n\t\tint pivot=rk;\n\t\tfor(int i=rk+1;i<A.size();++i){\n\t\t\tif(abs(B[i][j])>abs(B[pivot][j])){\n\t\t\t\tpivot=i;\n\t\t\t}\n\t\t}\n\t\tif(B[pivot][j]==0){\n\t\t\tcontinue;\n\t\t}\n\t\tswap(B[rk],B[pivot]);\n\t\tf[j]=rk;\n\t\tfor(int i=0;i<A.size();++i){//B[rk][j]????????????????????????\n\t\t\tif(i!=rk){\n\t\t\t\tfor(int k=j+1;k<=A[0].size();++k){\n\t\t\t\t\tB[i][k]-=B[i][j]*B[rk][k];\n\t\t\t\t\tB[i][k]=abs(B[i][k]);\n\t\t\t\t\tB[i][k]%=2;\n\t\t\t\t}\n\t\t\t\tB[i][j]=0;\n\t\t\t}\n\t\t}\n\t\t++rk;\n\t}\n\tfor(int i=rk;i<A.size();++i){\n\t\tif(B[i][A[0].size()]!=0){\n\t\t\treturn vec();//the case where there're no solutions.\n\t\t}\n\t}\n\tvec x(A[0].size());\n\tfor(int j=0;j<A[0].size();++j){\n\t\tif(f[j]<0){\n\t\t\tx[j]=0;\n\t\t}else{\n\t\t\tx[j]=B[f[j]][A[0].size()];\n\t\t}\n\t}\n\treturn x;//Note that this case includes the case where there're more than 1 solutions.\n}\n\nvoid solve(int m,int n,int d){\n\tvec s(m*n);\n\tfor(int k=0;k<n;++k){\n\t\tfor(int l=0;l<m;++l){\n\t\t\tcin>>s[m*k+l];\n\t\t}\n\t}\n\tmat A(m*n,vec(m*n));\n\tfor(int i=0;i<n;++i){//[i][j] corresponds to m*i+j.\n\t\tfor(int j=0;j<m;++j){\n\t\t\tfor(int k=0;k<n;++k){\n\t\t\t\tfor(int l=0;l<m;++l){\n\t\t\t\t\tint e=abs(k-i)+abs(l-j);\n\t\t\t\t\tif(e==0||e==d){\n\t\t\t\t\t\tA[m*k+l][m*i+j]=1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tA[m*k+l][m*i+j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(gauss_jordan(A,s)==vec()){\n\t\tcout<<0<<endl;\n\t}else{\n\t\tcout<<1<<endl;\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint m,n,d;\n\t\tcin>>m>>n>>d;\n\t\tif(m==0){\n\t\t\tbreak;\n\t\t}\n\t\tsolve(m,n,d);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n \nint main(){\n  int M, N, D;\n  while (cin>>N>>M>>D && M) {\n    int S[25][25];\n    REP(i, M)REP(j, N) cin>>S[i][j];\n    int G[25 * 25][26] = {};\n    REP(i, M)REP(j, N){\n      REP(k, M)REP(l, N){\n        if(abs(i - k) + abs(j - l) == D || (i == k && j == l)){\n          G[i + M * j][k] |= 1<<l;\n        }\n      }\n      G[i + M * j][25] = S[i][j];\n    }\n    bool ans = true;\n    for(int i = 0; i < M * N; i++){\n      int pivot = -1;\n      for(int j = i; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))) pivot = j;\n      }\n      if(pivot == -1) continue;\n      int tmp[26];\n      //swap(G[i], G[pivot]);\n      memcpy(tmp, G[i], sizeof(tmp));\n      memcpy(G[i], G[pivot], sizeof(tmp));\n      memcpy(G[pivot], tmp, sizeof(tmp));\n      for(int j = 0; j < M * N; j++){\n        if(i != j && G[j][i / N] & (1 << (i % N))){\n          for(int k = 0; k < M; k++){\n            G[j][k] ^= G[i][k];\n          }\n          G[j][25] ^= G[i][25];\n        }\n      }\n    }\n    for(int i = M * N - 1; i >= 0; i--){\n      if(!(G[i][i / N] & (1 << (i % N))) && G[i][25]){\n        ans = false;\n      }\n    }\n    if(ans) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\nconst int N = 25;\nconst int NN = N*N;\n\nclass Mat : public vector<vector<int> >{\npublic:\n  void init(int h,int w){\n    clear();\n    rep(i,h)push_back(vector<int>(w));\n  }\n  void print(){\n    rep(i,size()){\n      rep(j,at(i).size())printf(\"%d \",at(i).at(j));puts(\"\");\n    }\n  }\n};\n\nint haki(Mat& mat){\n  int used[NN]={0};\n  int y = mat.size();\n  int x = mat[0].size();\n\n  int rank = 0;\n  rep(i,x){\n    rep(j,y){\n      if(used[j]==0 && mat[j][i]==1){\n\tused[j] = 1;\n\trank++;\n\n\trep(k,y){\n\t  if(used[k]==0 && mat[k][i]==1){\n\t    rep(p,x)mat[k][p]^=mat[j][p];\n\t  }\n\t}\n      }\n    }\n  }\n\n  return rank;\n}\n\n\nint w,h,d;\nint board[N][N];\n\nbool input(){\n  cin>>w>>h>>d;\n  if(w==0)return false;\n\n  rep(i,h)rep(j,w)cin>>board[i][j];\n\n  return true;\n}\n\n\nMat A;\nMat B;\nint n;\nint solve(){\n  n=w*h;\n  A.init(n, n);\n  B.init(n, n+1);\n\n  rep(i,n){\n    rep(j,n){\n      int x = i%w;\n      int y = i/w;\n      int s = j%w;\n      int t  = j/w;\n      if((x==s && y==t) || abs(x-s)+abs(y-t)==d){\n\tA[i][j] = 1;\n\tB[i][j] = 1;\n      }\n    }\n  }\n\n  rep(i,n){\n    B[i][n]=board[i/w][i%w];\n  }\n\n  //  A.print();\n  //B.print();\n\n  int va = haki(A);\n  int vb = haki(B);\n\n  //printf(\"%d : %d\\n\",va,vb);\n  if(va==vb)return 1;\n  return 0;\n}\n\nint main(){\n  while(input())cout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int64_t ll;\nll inverse(ll a, ll m) {\n\tll b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\tswap(a -= t * b, b);\n\t\tswap(u -= t * v, v);\n\t}\n\treturn (u % m + m) % m;\n}\n#define REP(i, n) for(auto i = 0 * (n); i < (n); ++i)\n#define FOR(i, s, n) for(size_t i = (s); i < (n); ++i)\n\ntypedef vector<ll> Vector;\ntypedef vector<Vector> Matrix;\nstruct GaussJordan {\n\ttypedef size_t T;\n\tGaussJordan(Matrix mat, T m) : x(move(mat)) {\n\t\tT row = x.size(), col = x[0].size(), r = 0;\n\t\tREP(c, col) {\n\t\t\tT p = r;\n\t\t\tFOR(i, r, row) if (abs(x[i][c]) > abs(x[p][c])) p = i;\n\t\t\tswap(x[r], x[p]);\n\t\t\tif (x[r][c]) {\n\t\t\t\tif (c == col - 1) impossible = 1; // ??????????????????????????????????????????\n\t\t\t\tdet = det * x[r][c] % m; // ??????????????????????????????????????????\n\t\t\t\tFOR(j, c + 1, col) (x[r][j] *= inverse(x[r][c], m)) %= m;\n\t\t\t\tx[r][c] = 1;\n\t\t\t\tREP(i, row) if (r != i) {\n\t\t\t\t\tFOR(j, c + 1, col) x[i][j] = (x[i][j] - x[i][c] * x[r][j] % m + m) % m;\n\t\t\t\t\tx[i][c] = 0;\n\t\t\t\t}\n                if (++r == row) break;\n\t\t\t}\n\t\t}\n        rank = r;\n\t}\n\tMatrix x;\n\tT rank;\n\tll det = 1;  // mat ?????£??????????????? full rank ?????¨???????????????\n\tbool impossible = 0; // ?????¢????¬?????¨????????§£??????????????´???????????????????§£????????? <-> true\n};\n\nGaussJordan linear_equations(Matrix A, const Vector & b, size_t m) {\n\tREP(i, A.size()) A[i].push_back(b[i]);\n    return GaussJordan(move(A), m);\n}\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint m, n, d;\n\twhile (cin >> m >> n >> d, m || n || d) {\n\t\tvector<deque<bool>> ba(n, deque<bool>(m));\n\t\tMatrix A(n * m, Vector(n * m));\n\t\tVector b(n * m);\n\t\tREP(i, n) {\n\t\t\tREP(j, m) {\n\t\t\t\tcin >> ba[i][j];\n\t\t\t\tA[i * m + j][i * m + j] = 1;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tREP(l, m) {\n\t\t\t\t\t\tint dis = abs(i - k) + abs(j - l);\n\t\t\t\t\t\tif (dis == d) {\n\t\t\t\t\t\t\tA[k * m + l][i * m + j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i * m + j] = ba[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << (linear_equations(A, b, 2).impossible ? 0 : 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define MAX_H\t(25)\n#define MAX_W\t(25)\n#define MAX_HW\t(MAX_H * MAX_W)\n\n/* global variables */\n\nint h, w, hw, d;\nchar mat[MAX_HW][MAX_HW], v[MAX_HW];\n\n/* subroutines */\n\nbool solve() {\n  for (int i = 0; i < hw; i++) {\n    if (mat[i][i] == 0) {\n      for (int i0 = i + 1; i0 < hw; i0++) {\n        if (mat[i0][i] != 0) {\n\t  for (int j = 0; j < hw; j++) {\n\t    int tmp = mat[i0][j]; mat[i0][j] = mat[i][j]; mat[i][j] = tmp;\n\t  }\n          int tmp = v[i0]; v[i0] = v[i]; v[i] = tmp;\n          break;\n\t}\n      }\n    }\n\n    if (mat[i][i] != 0) {\n      for (int i0 = i + 1; i0 < hw; i0++) {\n        if (mat[i0][i] != 0) {\n          mat[i0][i] = 0;\n          for (int j = i + 1; j < hw; j++)\n            mat[i0][j] = (mat[i0][j] + mat[i][j]) & 1;\n          v[i0] = (v[i0] + v[i]) & 1;\n\t}\n      }\n    }\n  }\n  //p mat; p v\n\n  for (int i = hw - 1; i >= 0; i--) {\n    for (int j = i + 1; j < hw; j++)\n      v[i] = (v[i] + mat[i][j] * v[j]) & 1;\n    if (mat[i][i] == 0 && v[i] != 0) return false;\n  }\n  //p mat; p v\n  \n  return true;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> w >> h >> d;\n    if ((w | h | d) == 0) break;\n    //printf(\"w=%d,h=%d,d=%d\\n\", w, h, d);\n    \n    hw = h * w;\n\n    for (int y = 0; y < h; y++) {\n      for (int x = 0; x < w; x++) {\n\tint pos = y * w + x;\n\tint b;\n\tcin >> b;\n\tv[pos] = b;\n\n\tfor (int j = 0; j < hw; j++) mat[pos][j] = 0;\n\tmat[pos][pos] = 1;\n      \n\tfor (int dy = -d; dy <= d; dy++) {\n\t  int ddx = d - abs(dy);\n\t  int dxs[] = {-ddx, ddx};\n\t  \n\t  for (int dxi = 0; dxi < 2; dxi++) {\n\t    int dx = dxs[dxi];\n\t    int x0 = x + dx;\n\t    int y0 = y + dy;\n\t    if (x0 >= 0 && x0 < w && y0 >= 0 && y0 < h) {\n\t      int pos0 = y0 * w + x0;\n\t      mat[pos][pos0] = 1;\n\t    }\n\t  }\n\t}\n      }\n    }\n    //p v; p mat\n\n    puts (solve() ? \"1\" : \"0\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint solve(vvi a)\n{\n\tint n=a.size();\n\trep(i,n){\n\t\trepi(j,i,n) if(a[j][i]==1){\n\t\t\tswap(a[i],a[j]);\n\t\t\tbreak;\n\t\t}\n\t\tif(a[i][i]==0) continue;\n\t\trep(j,n) if(j!=i && a[j][i]==1)\n\t\t\trepi(k,i,n+1) a[j][k]^=a[i][k];\n\t}\n\trep(i,n) if(a[i][i]==0 && a[i][n]==1) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tfor(int n,m,d;cin>>n>>m>>d && n|m|d;){\n\t\tvvi a(m*n,vi(m*n+1));\n\t\trep(i,m) rep(j,n){\n\t\t\ta[i*n+j][i*n+j]=1;\n\t\t\trep(k,m) rep(l,n)\n\t\t\t\tif(abs(k-i)+abs(l-j)==d)\n\t\t\t\t\ta[k*n+l][i*n+j]=1;\n\t\t\tcin>>a[i*n+j][m*n];\n\t\t}\n\t\tcout<<solve(a)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\n// GF(2)の行列\ntemplate<int width=64>\nstruct matrix {\n    int h, w;\n    vector<bitset<width>> dat;\n    matrix() {}\n    matrix(int h) : h(h), w(width), dat(h) {}\n\n    matrix& operator+=(const matrix& r) {\n        assert(h==r.h && w==r.w);\n        REP(i, h) dat[i] ^= r.dat[i];\n        return *this;\n    }\n    matrix& operator-=(const matrix& r) {\n        assert(h==r.h && w==r.w);\n        REP(i, h) dat[i] ^= r.dat[i];\n        return *this;\n    }\n    matrix& operator*=(const matrix& r) {\n        assert(w==r.h);\n        matrix ret(h, w);\n        REP(i, h) REP(j, r.w) REP(k, w) {\n            ret.dat[i][j] ^= dat[i][k] & r.dat[k][j];\n        }\n        return (*this) = ret;\n    }\n    matrix operator+(const matrix& r) { return matrix(*this) += r; }\n    matrix operator-(const matrix& r) { return matrix(*this) -= r; }\n    matrix operator*(const matrix& r) { return matrix(*this) *= r; }\n    bool operator==(const matrix& a) { return dat==a.dat; }\n    bool operator!=(const matrix& a) { return dat!=a.dat; }\n\n    friend matrix pow(matrix p, ll n) {\n        matrix ret(p.h, p.w);\n        REP(i, p.h) ret.dat[i][i] = 1;\n        while(n > 0) {\n            if(n&1) {ret *= p; n--;}\n            else {p *= p; n >>= 1;}\n        }\n        return ret;\n    }\n    // 階段行列を求める O(HW^2)\n    friend int gauss_jordan(matrix &a) {\n        int rank = 0;\n        REP(i, a.w) {\n            int pivot = -1;\n            FOR(j, rank, a.h) if(a.dat[j][i] != 0) { pivot = j; break; }\n            if(pivot == -1) continue;\n            swap(a.dat[rank], a.dat[pivot]);\n            REP(j, a.h) if(j != rank && a.dat[j][i] != 0) {\n                a.dat[j] ^= a.dat[rank];\n            }\n            rank++;\n        }\n        return rank;\n    }\n\n    friend ostream &operator<<(ostream& os, matrix a) {\n        REP(i, a.h) {\n            REP(j, 10) os << a.dat[i][j] << \" \";\n            os << endl;\n        }\n        return os;\n    }\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(true) { \n        ll h, w, d;\n        cin >> w >> h >> d;\n        if(!w) break;\n        vector<vector<ll>> s(h, vector<ll>(w));\n        REP(i, h) REP(j, w) cin >> s[i][j];\n\n        matrix<630> mat(h*w);\n        REP(y, h) REP(x, w) {\n            mat.dat[y*w+x][y*w+x] = 1;\n            REP(i, h) REP(j, w) {\n                if(abs(y-i)+abs(x-j) != d) continue;\n                mat.dat[y*w+x][i*w+j] = 1;\n            }\n            mat.dat[y*w+x][h*w] = 1 - s[y][x];\n        }\n\n        bool ans = true;\n        gauss_jordan(mat);\n        REP(i, h*w) {\n            bool flag = true;\n            REP(j, h*w) if(mat.dat[i][j]) { flag = false; break; } \n            if(flag && mat.dat[i][h*w] == 1) ans = false; \n        }\n\n        if(ans) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define IDX(i, j) ((i)*m+(j))\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nint n;\nint m;\nint d;\nint S[114][514];\nint Case;\n\nint main() {\n  while (1) {\n    scanf(\"%d%d%d\", &m, &n, &d);\n    if ((n|m|d) == 0) return 0;\n\n    for (int i=0; i<n; i++) {\n      for (int j=0; j<m; j++) {\n        scanf(\"%d\", &S[i][j]);\n      }\n    }\n\n    int sz = n*m;\n    Mat aug(sz, Vec(sz+1, 0));\n    for (int i=0; i<n; i++) {\n      for (int j=0; j<m; j++) {\n        int idx = IDX(i, j);\n        aug[idx][idx] = 1;\n        aug[idx][sz] = S[i][j];\n        for (int k=0; k<n; k++) {\n          for (int l=0; l<m; l++) {\n            if (abs(k-i)+abs(l-j) == d) aug[idx][IDX(k, l)] = 1;\n          }\n        }\n      }\n    }\n\n    int lim = 0;\n    for (int idx=0; idx<sz+1; idx++) {\n      int chosen = -1;\n      for (int i=lim; i<sz; i++) {\n        if (aug[i][idx]) {\n          chosen = i;\n          break;\n        }\n      }\n\n      if (chosen == -1) continue;\n\n      swap(aug[chosen], aug[lim]);\n      for (int i=lim+1; i<sz; i++) {\n        if (i == lim) continue;\n        if (!aug[i][idx]) continue;\n        for (int j=idx; j<=sz; j++) {\n          aug[i][j] ^= aug[lim][j];\n        }\n      }\n\n      lim++;\n    }\n\n    bool fail = false;\n    for (int i=0; i<sz; i++) {\n      bool pos = true;\n      for (int j=0; j<sz; j++) {\n        if (aug[i][j]) {\n          pos = false;\n          break;\n        }\n      }\n\n      if (aug[i][sz] == 0) continue;\n      if (pos) {\n        fail = true;\n        break;\n      }\n    }\n\n    if (fail) puts(\"0\");\n    else puts(\"1\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst double EPS=1E-9;\nbool gauss_jordan(const mat& A,const vec& b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  \n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  \n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++)if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    swap(B[i],B[pivot]);\n    for(int j=0;j<n;j++)\n      if(i!=j&&B[j][i])\n\tfor(int k=i;k<=n;k++)B[j][k]=(B[j][k]+B[i][k])%2;\n  }\n  for(int i=0;i<n;i++)if(B[i][i]==0&&B[i][n]==1) return 0;\n  return 1;\n}\n\nint h,w,d,mp[25][25];\n\nint main(){\n  while(1){\n    cin>>w>>h>>d;\n    if(!w&&!h&&!d)break;\n    mat A(h*w,vec(h*w));\n    vec B(h*w);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>mp[i][j];\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tint idx=w*i+j;\n\tB[idx] = mp[i][j];\n\tfor(int y=0;y<h;y++)\n\t  for(int x=0;x<w;x++){\n\t    int t = abs(i-y)+abs(j-x);\n\t    if(t==d||t==0)A[idx][w*y+x]=1;\t\t\t\t\n\t  }\n      }\n    cout<<gauss_jordan(A,B)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define ABS(x) ((x)<0 ? -(x) : (x))\n\n#define MAXN 625+1\n#define MAXD 25\n\nint gaussjordan(int **A, int M, int N) {\n\tint i, j, k;\n\n\tint RANK = M;\n\tfor (i=0; i<M; i++) {\n\t\t//Busco una fila con un 1 en la columna i\n\t\tfor (k=i; k<M; k++) {\n\t\t\tif (A[k][i] == 1) break;\n\t\t}\n\n\t\t//Si no la encuentro\n\t\tif (k == M) {\n\t\t\tRANK--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Si la encuentro, pasa a ser la fila i\n\t\tfor (j=0; j<N; j++) swap(A[i][j], A[k][j]);\n\n\t\tfor (k=0; k<M; k++) {\n\t\t\tif (k != i && A[k][i] == 1) {\n\t\t\t\tfor (j=i; j<N; j++) {\n\t\t\t\t\tA[k][j] = ((A[k][j] - A[i][j])%2 + 2)%2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn RANK;\n}\n\nint main() {\n\n//freopen(\"in.txt\", \"r\", stdin);\n\nint i, j, k, l, N, n[MAXD][MAXD], a[MAXN][MAXN], *aa[MAXN], R, C, K;\nbool flag;\n\nfor (i=0; i<MAXN; i++) aa[i] = a[i];\n\ncin >> R;\ncin >> C;\ncin >> K;\n\ndo {\n\nN = 0;\nfor (i=0; i<R; i++) {\n\tfor (j=0; j<C; j++) {\n\t\tn[i][j] = N++;\n\t}\n}\n\nmemset(a, 0, sizeof(a));\nfor (i=0; i<R; i++) {\n\tfor (j=0; j<C; j++) {\n\t\tcin >> a[n[i][j]][N];\n\t\ta[n[i][j]][n[i][j]] = 1;\n\n\t\tfor (k=0; k<R; k++) {\n\t\t\tfor (l=0; l<C; l++) {\n\t\t\t\tif (ABS(i-k) + ABS(j-l) == K) {\n\t\t\t\t\ta[n[i][j]][n[k][l]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*for (i=0; i<N; i++) {\n\tfor (j=0; j<N; j++) {\n\t\tcout << a[i][j] << ' ';\n\t}\n\tcout << endl;\n}*/\n\ngaussjordan(aa, N, N+1);\n\nflag = true;\nfor (i=0; i<N && flag; i++) {\n\tfor (j=0; j<N; j++) {\n\t\tif (a[i][j] == 1) break;\n\t}\n\tif (j==N && a[i][N]==1) flag = false;\n}\nif (flag) cout << 1 << endl;\nelse cout << 0 << endl;\n\ncin >> R;\ncin >> C;\ncin >> K;\n\n} while (R!=0 || C!=0 || K!=0);\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst double EPS=1E-9;\nbool gauss_jordan(const mat& A,const vec& b){\n  int n=A.size();\n  mat B(n,vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)B[i][j]=A[i][j];\n  \n  for(int i=0;i<n;i++)B[i][n]=b[i];\n  \n  for(int i=0;i<n;i++){\n    int pivot=i;\n    for(int j=i;j<n;j++)if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n    swap(B[i],B[pivot]);\n\n    for(int j=0;j<n;j++)\n      if(i!=j)\n\tfor(int k=i+1;k<=n;k++)B[j][k]=(B[j][k]+B[j][i]*B[i][k])%2;\n  }\n  vec x(n);\n  for(int i=0;i<n;i++)x[i]=B[i][n];\n  for(int i=0;i<n;i++)if(B[i][i]==0&&x[i]==1) return 0;\n  return 1;\n}\n\nint h,w,d,mp[25][25];\n\nint main(){\n  while(1){\n    cin>>w>>h>>d;\n    if(!w&&!h&&!d)break;\n    mat A(h*w,vec(h*w));\n    vec B(h*w);\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)cin>>mp[i][j];\n    \n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tint idx=w*i+j;\n\tB[idx] = mp[i][j];\n\tfor(int y=0;y<h;y++)\n\t  for(int x=0;x<w;x++){\n\t    int t = abs(i-y)+abs(j-x);\n\t    if(t==d||t==0)A[idx][w*y+x]=1;\t\t\t\t\n\t  }\n      }\n    cout<<gauss_jordan(A,B)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nconst Int MAX = 2002;\nusing BS = bitset<MAX*2>;\nvoid det(vector<BS> &v){\n  int n=v.size();\n  for(Int i=0;i<n;i++){\n    for(Int k=i;k<n;k++){\n      if(v[k][i]){\n\tswap(v[i],v[k]);\n\tbreak;\n      }\n    }\n    for(Int k=0;k<n;k++)\n      if(i!=k&&v[k][i]) v[k]^=v[i];\n  }\n}\n//END CUT HERE\nsigned CFR382_D(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m;\n  cin>>n>>m;\n  vector<BS> v(n,BS(0));\n  for(Int i=0;i<n;i++) v[i][n+i]=1;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++){\n    cin>>a[i]>>b[i];\n    a[i]--;b[i]--;\n    v[a[i]][b[i]]=1;\n  }\n  det(v);\n  for(Int i=0;i<m;i++)\n    cout<<(v[b[i]][a[i]+n]?\"NO\":\"YES\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/09\nhttp://codeforces.com/contest/736/problem/D\n*/\n\nsigned ARC054_D(){\n  int n;\n  cin>>n;\n  vector<BS> v(n,BS(0));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      char c;\n      cin>>c;\n      v[i][j]=c-'0';\n    }\n  }\n  det(v);\n  int ans=1;\n  for(int i=0;i<n;i++) ans&=v[i][i];\n  cout<<(ans?\"Odd\":\"Even\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/09\nhttps://beta.atcoder.jp/contests/arc054/tasks/arc054_c\n*/\n\nsigned AOJ_1308(){\n  int m,n,d;\n  while(cin>>m>>n>>d,m){\n    vector<vector<int> > s(n,vector<int>(m));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tcin>>s[i][j];\n\n    vector<BS> v(n*m,BS(0));\n    auto idx=[&](int y,int x){return y*m+x;};\n    auto in=[&](int y,int x){return 0<=y&&y<n&&0<=x&&x<m;};\n    auto bfs=[&](int y,int x){\n      int z=idx(y,x);\n      v[z][z]=1;\n      v[z][n*m]=s[y][x];\n      \n      vector<vector<int> > dp(n,vector<int>(m,-1));\n      using P = pair<int, int>;\n      queue<P> q;\n      dp[y][x]=0;\n      q.emplace(y,x);\n      int dy[]={0,0,1,-1};\n      int dx[]={1,-1,0,0};\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(dp[y][x]==d) v[z][idx(y,x)]=1;\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=dp[y][x]+1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    auto u=v;\n    det(v);\n    int ans=1;\n    for(int i=0;i<n*m;i++){\n      int tmp=s[i/m][i%m];\n      for(int j=0;j<n*m;j++) tmp+=u[i][j]&v[j][n*m];\n      ans&=!(tmp&1);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2018/01/09\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1308\n*/\n\nsigned main(){\n  //CFR382_D();\n  //ARC054_D();\n  AOJ_1308();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[]={-1,0,1,0},dx[]={0,-1,0,1},dy2[]={1,-1,-1,1},dx2[]={1,1,-1,-1};\nint m,n,d,s[25][25];\nint main()\n{\n\twhile(scanf(\"%d%d%d\",&n,&m,&d),m){\n\t\tint N=m*n;\n\t\tvector<vi> a(N,vi(N+1,0));\n\t\trep(i,m)rep(j,n)scanf(\"%d\",s[i]+j), a[i*n+j][N]=s[i][j];\n\t\trep(i,N)(a[i][i]+=1)%=2;\n\t\trep(i,m)rep(j,n)rep(dir,4)rep(k,d){\n\t\t\tint y=i+dy[dir]*d+dy2[dir]*k, x=j+dx[dir]*d+dx2[dir]*k;\n\t\t\tif(0<=y&&y<m&&0<=x&&x<n){\n\t\t\t\t(a[y*n+x][i*n+j]+=1)%=2;\n\t\t\t}\n\t\t}\n\t\tint j=0;\n\t\trep(i,N){\n\t\t\tint mi=i;\n\t\t\tif(!a[mi][j])for(int k=i+1;k<N;k++)if(a[mi]<a[k]){\n\t\t\t\tmi=k;\n\t\t\t\tif(a[mi][j])break;\n\t\t\t}\n\t\t\tswap(a[i],a[mi]);\n\t\t\tfor(;j<N&&a[i][j]==0;j++);\n\t\t\tif(j>=N)break;\n\t\t\tassert(a[i][j]);\n\t\t\trep(k,N)if(i<k&&a[k][j])for(int l=j;l<=N;l++)(a[k][l]+=a[i][l])%=2;\n\t\t\tj++;\n\t\t}\n\t\tbool ok=1; j=0;\n\t\trep(i,N)if(ok&&a[i][N]){\n\t\t\tfor(;j<N&&a[i][j]==0;j++);\n\t\t\tif(j>=N)ok=0;\n\t\t}\n\t\tprintf(\"%d\\n\",(int)ok);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//59\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  for(int m,n,d;cin>>m>>n>>d,m|n|d;){\n    vector<vector<int> > v(m*n,vector<int>(m*n+1));\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tfor(int k=0;k<n;k++){\n\t  for(int l=0;l<m;l++){\n\t    int cd=abs(i-k)+abs(j-l);\n\t    v[i*n+j][k*n+l]=cd==0||cd==d;\n\t  }\n\t}\n\tcin>>v[i*n+j].back();\n      }\n    }\n    int dn=0;\n    for(int i=0;i<n*m;i++){\n      int j;\n      for(j=dn;j<v.size();j++){\n\tif(v[j][i])break;\n      }\n      if(j==v.size())continue;\n      swap(v[dn],v[j]);\n      for(int k=dn+1;k<v.size();k++){\n\tif(v[k][i]){\n\t  for(int l=0;l<v[k].size();l++){\n\t    v[k][l]^=v[dn][l];\n\t  }\n\t}\n      }\n      dn++;\n    }\n    int i;\n    for(i=dn;i<v.size();i++){\n      if(v[i].back())break;\n    }\n    cout<<(i==v.size())<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <math.h>\n#include <string>\nusing namespace std;\n\nconst int MAXN = 1000;\nint equ,var;\nint a[MAXN][MAXN];\nint x[MAXN];\n\nint Gauss()\n{\n\tint max_r,col,k;\n\tfor(k = 0,col = 0;k < equ && col < var;k++,col++)\n\t{\n\t\tmax_r = k;\n\t\tfor(int i = k+1;i < equ;i++)\n\t\t{\n\t\t\tif(abs(a[i][col]) > abs(a[max_r][k]))\n\t\t\t\tmax_r = i;\n\t\t}\n\t\tif(a[max_r][col] == 0)\n\t\t{\n\t\t\tk--;\n\t\t\tcontinue;\n\t\t}\n\t\tif(max_r != k)\n\t\t{\n\t\t\tfor(int j = col;j < var+1;j++)\n\t\t\t\tswap(a[k][j],a[max_r][j]);\n\t\t}\n\t\tfor(int i = k+1;i < equ;i++)\n\t\t{\n\t\t\tif(a[i][col] != 0)\n\t\t\t{\n\t\t\t\tfor(int j = col;j < var+1;j++)\n\t\t\t\t\ta[i][j] ^= a[k][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = k;i < equ;i++)\n\t\tif(a[i][col] != 0)\n\t\t\treturn -1;\n\tif(k < var)return var-k;\n\treturn 0;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\tint n,m,d;\n\twhile(scanf(\"%d%d%d\",&m,&n,&d) == 3)\n\t{\n\t\tif(n == 0 && m == 0 && d == 0)break;\n\t\tequ = var = n*m;\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(int i = 0;i < n*m;i++)\n\t\t\tscanf(\"%d\",&a[i][n*m]);\n\t\tfor(int j = 0;j < n*m;j++)\n\t\t{\n\t\t\ta[j][j] = 1;\n\t\t\tint x = j/m;\n\t\t\tint y = j%m;\n\t\t\tfor(int i= -d;i <= d;i++)\n\t\t\t{\n\t\t\t\tint xx = x+i;\n\t\t\t\tint yy = y - (d-abs(i));\n\t\t\t\tif(xx < 0 || xx >= n || yy < 0 || yy >= m)continue;\n\t\t\t\ta[xx*m + yy][j] = 1;\n\t\t\t}\n\t\t\tfor(int i= -d;i <= d;i++)\n\t\t\t{\n\t\t\t\tint xx = x+i;\n\t\t\t\tint yy = y + (d-abs(i));\n\t\t\t\tif(xx < 0 || xx >= n || yy < 0 || yy >= m)continue;\n\t\t\t\ta[xx*m + yy][j] = 1;\n\t\t\t}\n\t\t}\n\t\tif(Gauss() >= 0)printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nll S[50][50];\nvector<ll> XOR(vector<ll> a, vector<ll> b) {\n    vector<ll> ret(a.size());\n    for(int i = 0; i < a.size(); i++) {\n        ret[i] = (a[i] ^ b[i]);\n    }\n    return ret;\n}\nint H, W, D;\n\nvoid print(vector<ll> v) {\n    return;\n    for(auto tmp : v) {\n        cout << bitset<64>(tmp) << \" \";\n    }\n    cout << endl;\n}\n\nint solve() {\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            cin >> S[h][w];\n        }\n    }\n    vector<vector<ll>> base(H * W);\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            vector<ll> v;\n            ll num = 0;\n            for(int h1 = 0; h1 < H; h1++) {\n                for(int w1 = 0; w1 < W; w1++) {\n                    if(num == 0) v.push_back(0);\n                    int d = abs(h-h1) + abs(w-w1);\n                    if(d == 0 or d == D) v.back() |= (1LL << num);\n                    num++;\n                    num %= 62;\n                }\n            }\n            print(v);\n            for(int i = 0; i < h*W+w; i++) {\n                chmin(v, XOR(v, base[i]));\n            }\n            base[h*W+w] = v;\n        }\n    }\n    sort(base.begin(), base.end(), greater<vector<ll>>());\n    vector<ll> V;\n    for(int h = 0; h < H; h++) {\n        for(int w = 0; w < W; w++) {\n            ll num = h * W + w;\n            if(num % 62 == 0) V.push_back(0);\n            num %= 62;\n            V.back() += (S[h][w] * (1LL << num));\n        }\n    }\n    for(auto q : base) {\n        chmin(V, XOR(V, q));\n    }\n    int ans = 1;\n    for(auto tmp : V) {\n        if(tmp) ans = 0;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\nint main() {\n    while(cin >> W >> H >> D) {\n        if(W == 0) break;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1308 Awkward Lights\n// 2018.3.8 bal4u\n\n//#include \"bits/stdc++.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define N 630\n#define ABS(a)\t((a)>=0?(a):-(a))\n#define p(r,c)\t((r)*m+(c))\n\nint main()\n{\n\tint m, n, mn, d, i, j, k, r, c, ans;\n\n\twhile (m = in()) {\n\t\tn = in(), d = in(), mn = m*n;\n\nbitset <N> B[N];\n\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < m; j++) {\n\t\t\tif (in()) B[p(i, j)][mn] = 1;\n\t\t\tfor (r = 0; r < n; r++) for (c = 0; c < m; c++) {\n\t\t\t\tif (r == i && c == j || ABS(r-i) + ABS(c-j) == d)\n\t\t\t\t\tB[p(i, j)][p(r, c)] = 1;\n\t\t\t}\n\t\t}\n\n\t\tk = 0;\n\t\tfor (i = 0; i < mn; i++) {\n\t\t\tfor (j = k; j < mn; j++) if (B[j][i]) break;\n\t\t\tif (j == mn) continue;\n\t\t\tswap(B[j], B[k]);\n\t\t\tfor (j = k+1; j < mn; j++) if (B[j][i]) B[j] ^= B[k];\n\t\t\tk++;\n\t\t}\n\n\t\tans = '1';\n\t\tfor (i = k; i < mn; i++) if (B[i][mn]) { ans = '0'; break; }\n\t\tputchar(ans), putchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\n#ifdef _DEBUG\n#define DEBUG WRITE\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\n#else\n#define DEBUG(...)\ninline void readfrom(...) { }\ninline void writeto(...) { }\n#endif\n#ifdef ccout\n#  define cout ccout\n#  define endl cendl\n#endif\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, const pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << \"\";\n\tauto s = ss.str();\n\tout << s.substr(0, s.length());\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\n\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n// MODを法としたint\ntemplate <int MOD>\nstruct modint\n{\n\ttypedef int T;\n\ttypedef long DBL_T;\n\n\tT v;\n\tmodint(T v = 0) : v(mod(v)) { }\n\tbool operator == (modint i) const { return v == i.v; }\n\tbool operator != (modint i) const { return !(*this == i); }\n\n\tmodint operator -(modint i) const { return modint(v - i.v); }\n\tmodint& operator -=(modint i) { *this = *this - i; return *this; }\n\n\tmodint operator *(modint i) const { return FromValue((DBL_T)v * i.v % MOD); }\n\tstatic T mod(T v) { return v %= MOD, v < 0 ? v + MOD : v; }\n\n};\ntemplate <int MOD> ostream & operator << (ostream &out, modint<MOD> v) { out << v.v; return out; }\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, m, n, d);\n\t\tif (!(m | n | d)) { break; }\n\n\t\tint N = n * m;\n\t\ttypedef modint<2> I;\n\t\tvevector<I> x(N, N + 1);\n\t\t\n\t\tREP(i, n) REP(j, m)\n\t\t{\n\t\t\tx[i*m + j][i*m + j] = 1;\n\t\t\tFOR(k, -d, d + 1)\n\t\t\t{\n\t\t\t\tint l = d - abs(k);\n\t\t\t\tif (inRange(i + k, j + l, n, m)) { x[i * m + j][(i + k)*m + j + l] = 1; }\n\t\t\t\tif (inRange(i + k, j - l, n, m)) { x[i * m + j][(i + k)*m + j - l] = 1; }\n\t\t\t}\n\t\t}\n\n\t\tREP(i, N) { x[i][N] = read<int>(); }\n\n\t\ttry\n\t\t{\n\t\t\tREP(i, N)\n\t\t\t{\n\t\t\t\tFOR(j, i, N) { if (x[j][i] != 0) { x[i].swap(x[j]); break; } } // pivot select\n\t\t\t\tif (x[i][i] == 0) { if (x[i][N] == 0) { continue; } throw 1; }\n\t\t\t\tREP(k, N) if (k != i) if (x[k][i] != 0) FOR(j, i, N+1) x[k][j] -= x[i][j];\n\t\t\t}\n\t\t\tWRITE(1);\n\t\t}\n\t\tcatch (int)\n\t\t{\n\t\t\tWRITE(0);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct mod\n{\n  int m;\n  mod(int a) : m(a) {}\n  int operator()(int x) const { return ((x%m)+m)%m; }\n};\n\n\nvector<int> gaussian_elimination(vector<vector<int> > a, vector<int> b)\n{\n  static const int inv_tbl[2] = {-1, 1};\n  static mod M(2);\n  const int N = a.size();\n  const int NN = a[0].size();\n\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; a[i][i] == 0 && j < N; j++) {\n      swap(a[i], a[j]);\n      swap(b[i], b[j]);\n    }\n    if (a[i][i] == 0) {\n      continue;\n    }\n\n    const int t = inv_tbl[a[i][i]];\n    for (int k = i; k < NN; k++) {\n      a[i][k] = M(a[i][k] * t);\n    }\n    b[i] = M(b[i] * t);\n\n    for (int j = 0; j < N; j++) {\n      if (i == j) {\n        continue;\n      }\n      const int u = a[j][i];\n      for (int k = i; k < NN; k++) {\n        a[j][k] = M(a[j][k] - u*a[i][k]);\n      }\n      b[j] = M(b[j] - u*b[i]);\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (a[i][i] == 0 && b[i] != 0) {\n      // no solution\n      return vector<int>();\n    }\n  }\n  return b;\n}\n\nint main()\n{\n  int M, N, D;\n  while (cin >> M >> N >> D && M != 0) {\n    vector<vector<int> > a(M*N, vector<int>(M*N, 0));\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        a[N*i+j][N*i+j] = 1;\n        for (int k = -D; k <= D; k++) {\n          for (int l = -D; l <= D; l++) {\n            const int x = i+k, y = j+l;\n            if (abs(k)+abs(l) == D && 0 <= x && x < N && 0 <= y && y < M) {\n              a[M*i+j][M*x+y] = 1;\n            }\n          }\n        }\n      }\n    }\n\n    vector<int> b(N*M);\n    for (int i = 0; i < N*M; i++) {\n      cin >> b[i];\n    }\n\n    const vector<int> x = gaussian_elimination(a, b);\n    cout << !x.empty() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nbool gauss_jordan(const mat &A, const vec &b)\n{\n    int n = A.size();\n    mat B(n, vec(n+1));\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    B[i][j] = A[i][j];\n\t}\n    }\n    \n    for (int i = 0; i < n; i++) {\n\tB[i][n] = b[i];\n    }\n    \n    for (int i = 0; i < n; i++) {\n\tint pivot = i;\n\tfor (int j = i; j < n; j++) {\n\t    if (B[j][i] > B[pivot][i]) {\n\t\tpivot = j;\n\t    }\n\t}\n        \n\tswap(B[i], B[pivot]);              \n        \n\tfor (int j = 0; j < n; j++) {\n\t    if (i != j && B[j][i] == 1) {\n\t\tfor (int k = i; k <= n; k++) {\n\t\t    B[j][k] = (B[j][k] + B[i][k]) % 2;\n\t\t}\n\t    }\n\t}\n    }\n\n    for (int i = 0; i < n; i++) {\n        bool non_zero = 0;\n        for (int j = 0; j < n; j++) {\n            if (B[i][j] != 0) non_zero = 1;\n        }\n        if (!non_zero && B[i][n] == 1) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main()\n{\n    int W, H, D;\n    while (cin >> W >> H >> D, W) {\n        mat a(H, vec(W));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                cin >> a[i][j];\n            }\n        }\n        \n        mat A(H*W, vec(H*W, 0));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                int n = i * W + j;\n                A[n][n] = 1;\n                for (int k = 0; k < H; k++) {\n                    for (int l = 0; l < W; l++) {\n                        int MD = abs(i - k) + abs(j - l);\n                        int m = k * W + l;\n                        if (D == MD) {\n                            A[n][m] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        vec b(H*W);\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (a[i][j] == 1) b[i*W+j] = 1;\n            }\n        }\n        cout << (gauss_jordan(A, b) ? 1 : 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nint M, N, D, S[32][32], a[768][768];\n\nbool solve(int n) {\n    rep(k, n) {\n        int ix = -1;\n        for(int i=k; i<n; i++) if(a[i][k]) { ix=i; break; }\n        if(ix==-1) continue;\n        if(k!=ix) rep(i, n+1) swap(a[k][i], a[ix][i]);\n        rep(i, n) if(i!=k) if(a[i][k]) {\n            for(int j=k; j<=n; j++) a[i][j] ^= a[k][j];\n        }\n    }\n    rep(k, n) if(a[k][n]) {\n        bool any = false;\n        rep(i, n) if(a[k][i]) any = true;\n        if(!any) return false;\n    }\n    return true;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d%d%d\", &M, &N, &D);\n        if(M==0 && N==0 && D==0) return 0;\n        rep(i, N) rep(j, M) scanf(\"%d\", S[i]+j);\n        memset(a, 0, sizeof(a));\n        const int n = N*M;\n        rep(i, N) rep(j, M) {\n            const int ix = i*M+j;\n            a[ix][ix] = 1;\n            a[ix][n] = S[i][j];\n            rep(x, N) rep(y, M) if(abs(i-x)+abs(j-y)==D) a[ix][x*M+y] = 1;\n        }\n        printf(\"%d\\n\", (int)solve(n));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int64_t ll;\nll inverse(ll a, ll m) {\n\tll b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\tswap(a -= t * b, b);\n\t\tswap(u -= t * v, v);\n\t}\n\treturn (u % m + m) % m;\n}\n#define REP(i, n) for(auto i = 0 * (n); i < (n); ++i)\n#define FOR(i, s, n) for(size_t i = (s); i < (n); ++i)\n\ntypedef vector<ll> Vector;\ntypedef vector<Vector> Matrix;\nstruct GaussJordan {\n\ttypedef size_t T;\n\tGaussJordan(Matrix mat, T m) : x(move(mat)) {\n\t\tT row = x.size(), col = x[0].size(), r = 0;\n\t\tREP(c, col) {\n\t\t\tT p = r;\n\t\t\tFOR(i, r, row) if (abs(x[i][c]) > abs(x[p][c])) p = i;\n\t\t\tswap(x[r], x[p]);\n\t\t\tif (x[r][c]) {\n\t\t\t\tif (c == col - 1) impossible = 1; // ??????????????????????????????????????????\n\t\t\t\tdet = det * x[r][c] % m; // ??????????????????????????????????????????\n\t\t\t\t//FOR(j, c + 1, col) x[r][j] = x[r][j] * inverse(x[r][c], m) % m;\n\t\t\t\tFOR(j, c + 1, col) x[r][j] = x[r][j] * x[r][c];\n\t\t\t\tx[r][c] = 1;\n\t\t\t\tREP(i, row) if (r != i) {\n\t\t\t\t\tFOR(j, c + 1, col) x[i][j] = (x[i][j] - x[i][c] * x[r][j] % m + m) % m;\n\t\t\t\t\t//FOR(j, c + 1, col) x[i][j] ^= x[i][c] * x[r][j];\n\t\t\t\t\tx[i][c] = 0;\n\t\t\t\t}\n                if (++r == row) break;\n\t\t\t}\n\t\t}\n        rank = r;\n\t}\n\tMatrix x;\n\tT rank;\n\tll det = 1;  // mat ?????£??????????????? full rank ?????¨???????????????\n\tbool impossible = 0; // ?????¢????¬?????¨????????§£??????????????´???????????????????§£????????? <-> true\n};\n\nGaussJordan linear_equations(Matrix A, const Vector & b, size_t m) {\n\tREP(i, A.size()) A[i].push_back(b[i]);\n    return GaussJordan(move(A), m);\n}\n\nbool ba[30][30];\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint m, n, d;\n\twhile (cin >> m >> n >> d, m || n || d) {\n\t\tMatrix A(n * m, Vector(n * m));\n\t\tVector b(n * m);\n\t\tREP(i, n) {\n\t\t\tREP(j, m) {\n\t\t\t\tcin >> ba[i][j];\n\t\t\t\tA[i * m + j][i * m + j] = 1;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tREP(l, m) {\n\t\t\t\t\t\tint dis = abs(i - k) + abs(j - l);\n\t\t\t\t\t\tif (dis == d) {\n\t\t\t\t\t\t\tA[k * m + l][i * m + j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i * m + j] = ba[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << (linear_equations(move(A), b, 2).impossible ? 0 : 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define ABS(x) ((x)<0 ? -(x) : (x))\n\n#define MAXN 625+1\n#define MAXD 25\n\nint gaussjordan(int **A, int M, int N) {\n\tint i, j, k;\n\n\tint RANK = M;\n\tfor (i=0; i<M; i++) {\n\t\t//Busco una fila con un 1 en la columna i\n\t\tfor (k=i; k<M; k++) {\n\t\t\tif (A[k][i] == 1) break;\n\t\t}\n\n\t\t//Si no la encuentro\n\t\tif (k == M) {\n\t\t\tRANK--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Si la encuentro, pasa a ser la fila i\n\t\tfor (j=0; j<N; j++) swap(A[i][j], A[k][j]);\n\n\t\tfor (k=0; k<M; k++) {\n\t\t\tif (k != i && A[k][i] == 1) {\n\t\t\t\tfor (j=i; j<N; j++) {\n\t\t\t\t\tA[k][j] = ((A[k][j] - A[i][j])%2 + 2)%2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn RANK;\n}\n\nint main() {\n\n//freopen(\"in.txt\", \"r\", stdin);\n\nint i, j, k, l, N, n[MAXD][MAXD], a[MAXN][MAXN], *aa[MAXN], R, C, K;\nbool flag;\n\nfor (i=0; i<MAXN; i++) aa[i] = a[i];\n\ncin >> C;\ncin >> R;\ncin >> K;\n\ndo {\n\nN = 0;\nfor (i=0; i<R; i++) {\n\tfor (j=0; j<C; j++) {\n\t\tn[i][j] = N++;\n\t}\n}\n\nmemset(a, 0, sizeof(a));\nfor (i=0; i<R; i++) {\n\tfor (j=0; j<C; j++) {\n\t\tcin >> a[n[i][j]][N];\n\t\ta[n[i][j]][n[i][j]] = 1;\n\n\t\tfor (k=0; k<R; k++) {\n\t\t\tfor (l=0; l<C; l++) {\n\t\t\t\tif (ABS(i-k) + ABS(j-l) == K) {\n\t\t\t\t\ta[n[i][j]][n[k][l]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*for (i=0; i<N; i++) {\n\tfor (j=0; j<N; j++) {\n\t\tcout << a[i][j] << ' ';\n\t}\n\tcout << endl;\n}*/\n\ngaussjordan(aa, N, N+1);\n\nflag = true;\nfor (i=0; i<N && flag; i++) {\n\tfor (j=0; j<N; j++) {\n\t\tif (a[i][j] == 1) break;\n\t}\n\tif (j==N && a[i][N]==1) flag = false;\n}\nif (flag) cout << 1 << endl;\nelse cout << 0 << endl;\n\ncin >> C;\ncin >> R;\ncin >> K;\n\n} while (R!=0 || C!=0 || K!=0);\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define INF 1000000007\n#define EPS 1e-10\n#define ll long long\n\nusing namespace std;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n                    X[i][j] += (*this)[i][k]*another[k][j];\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    int rank(){\n\t\tint n = this->r;\n\t    int m = this->c;\n\t    int res = 0;\n\t    mat B(n,m);\n\t    for(int i=0;i<n;i++){\n\t        for(int j=0;j<m;j++){\n\t\t\t\tB[i][j] = (*this)[i][j];\n\t\t\t}\n\t    }\n\t    for(int i=0;i<m;i++){\n\t        if(res == n) return res;\n\t        int pivot = res;\n\t        for(int j=res+1;j<n;j++){\n\t            if(abs(B[j][i]) > abs(B[pivot][i])){\n\t                pivot = j;\n\t            }\n\t        }\n\t        if(abs(B[pivot][i]) < EPS) continue;\n\t        swap(B[pivot],B[res]);\n\t        for(int j=i+1;j<m;j++){\n\t            B[res][j] /= B[res][i];\n\t        }\n\t        for(int j=res+1;j<n;j++){\n\t            for(int k=i+1;k<m;k++){\n\t                B[j][k] -= B[res][k]*B[j][i];\n\t            }\n\t        }\n\t        res++;\n\t    }\n\t    return res;\n\t}\n    T det(){\n        if(this->r != this->c){\n            cout << \"正方行列でない(行列式定義不可)\" << endl;\n            exit(1);\n        }\n        T ans = 1;\n        int n = this->r;\n        mat B(n,n);\n        rep(i,n){\n            rep(j,n){\n                B[i][j] = (*this)[i][j];\n            }\n        }\n        rep(i,n) {\n            for(int j=i+1;j<n;j++){\n                for (; B[j][i] != 0; ans = -ans) {\n                    T r = B[i][i] / B[j][i];\n                    for(int k=i;k<n;k++) {\n                        T t = B[i][k] - r * B[j][k];\n                        B[i][k] = B[j][k];\n                        B[j][k] = t;\n                    }\n                }\n           }\n           ans *= B[i][i];\n       }\n       return ans;\n    }\n    mat inverse(){\n        if(this->r != this->c){\n            cout << \"正方行列でない(逆行列定義不可)\" << endl;\n            exit(1);\n        }\n        int n = this->r;\n        mat B(n,2*n);\n        rep(i,n){\n            rep(j,n){\n                B[i][j] = (*this)[i][j];\n            }\n        }\n        rep(i,n){\n            B[i][n+i] = 1;\n        }\n        rep(i,n){\n            int pivot = i;\n            for(int j=i;j<n;j++){\n                if(abs(B[j][i]) > abs(B[pivot][i])){\n                    pivot = j;\n                }\n            }\n            if(abs(B[pivot][i]) < EPS){\n                cout << \"解なしor不定\" << endl;\n                exit(1);\n            }\n            swap(B[i],B[pivot]);\n            for(int j=i+1;j<=2*n;j++){\n                B[i][j] /= B[i][i];\n            }\n            rep(j,n){\n                if(i != j){\n                    for(int k=i+1;k<=2*n;k++){\n                        B[j][k] -= B[j][i] * B[i][k];\n                    }\n                }\n            }\n        }\n        mat res(n,n);\n        rep(i,n){\n            rep(j,n){\n                res[i][j] = B[i][n+j];\n            }\n        }\n        return res;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> bool eq_solve(const mat<T>& A,const vector<T>& b){\n    if(A.row() != A.column()){\n        cout << \"正方行列でない(解なしor不定)\" << endl;\n        exit(1);\n    }\n    int n = A.row();\n    mat<T> B(n,n+1);\n    rep(i,n){\n        rep(j,n){\n            B[i][j] = A[i][j];\n        }\n    }\n    rep(i,n){\n        B[i][n] = b[i];\n    }\n    rep(i,n){\n        int pivot = i;\n        for(int j=i;j<n;j++){\n            if(abs(B[j][i]) > abs(B[pivot][i])){\n                pivot = j;\n            }\n        }\n        if(abs(B[pivot][i]) < EPS){\n            bool ok = true;\n            for(int j=i;j<n;j++){\n                bool ok2 = true;\n                for(int k=i;k<n;k++){\n                    if(B[j][k] > EPS){\n                        ok2 = false;\n                        break;\n                    }\n                }\n                if(ok2 && B[j][n] > EPS){\n                    ok = false;\n                    break;\n                }\n            }\n            return ok;\n        }\n        swap(B[i],B[pivot]);\n        for(int j=i+1;j<=n;j++){\n            B[i][j] /= B[i][i];\n        }\n        rep(j,n){\n            if(i != j){\n                for(int k=i+1;k<=n;k++){\n                    B[j][k] ^= B[j][i] * B[i][k];\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int m,n,d;\n        cin >> m >> n >> d;\n        if(m == 0) break;\n        vector<vector<int> > vec(n,vector<int>(m));\n        rep(i,n){\n            rep(j,m){\n                cin >> vec[i][j];\n            }\n        }\n        mat<int> A(n*m,n*m);\n        vector<int> b(n*m);\n        rep(i,n){\n            rep(j,m){\n                A[i*m+j][i*m+j] = 1;\n                rep(k,d){\n                    int x = i-d+k, y = j+k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                rep(k,d){\n                    int x = i+k, y = j+d-k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                rep(k,d){\n                    int x = i+d-k, y = j-k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                rep(k,d){\n                    int x = i-k, y = j-d+k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                b[i*m+j] = vec[i][j];\n            }\n        }\n        cout << eq_solve(A,b) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <fstream>\n\nusing namespace std;\n\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n#define EPS (1e-9)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\n// KEXÌÁ@ÅA§®ðÆ­\nvoid gauss_jordan(const mat&A,const vec &b,vector<int> &res){\n\tint n=A.size();\n\tmat B(n,vec(n+1));\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)B[i][j]=A[i][j];\n\tfor(int i = 0; i < n; i++)B[i][n]=b[i];\n\t// eÏÉÚ\n\tfor(int i = 0; i < n; i++){\n\t\t// evfð2ÅÁ½]èÉu«·¦é\n//\t\tfor(int j=0;j<n;j++){\n//\t\t\tfor(int k=0;k<n;k++){\n//\t\t\t\tif(abs(B[j][k])%2==1)B[j][k]=B[j][k]%2;\n//\t\t\t\telse if(B[j][k]==0)B[j][k]=0;\n//\t\t\t\telse if(B[j][k]>0)B[j][k]=2;\n//\t\t\t\telse B[j][k]=-2;\n//\t\t\t}\n//\t\t\tB[j][n]=B[j][n]%2;\n//\t\t}\n\t\t// ÅåÌWÌâÎlðàÂàÌðiÔÚÉÁÄ­é\n\t\tint piv=-1;\n\t\tint val=-1;\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(abs(B[j][i])==1){\n\t\t\t\tpiv=j;\n\t\t\t\tval=abs(B[j][i]);\n\t\t\t}\n\t\t}\n\t\t// ðª¡Ü½Íðª³¢\n\t\tif(piv==-1||val<EPS){\n\t\t\tif(B[i][n]!=0){\n\t\t\t\tres=vec();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// ðª¡¶Ý·éÌÅA»Ì¤¿ÌêÂðßé\n\t\t\t\tB[i][n]=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswap(B[piv],B[i]);\n\t\t// isÚð»ê¼êB[piv][i]ÌlÅé\n\t\t//\t\tint divNum=B[i][i];\n\t\t//\t\tfor(int j = i; j <= n; j++)B[i][j]/=divNum;\n\t\t// »ê¼êÌs©çAisÚÌlðø­©ñ¶\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i==j)continue;\n\t\t\tint mulnum=B[j][i];\n\t\t\tfor(int k = i; k <= n; k++){\n\t\t\t\tB[j][k]-=mulnum*B[i][k];\n\t\t\t\tif(k!=n){\n\t\t\t\t\tif(abs(B[j][k])%2==1)B[j][k]%=2;\n\t\t\t\t\telse if(B[j][k]==0)B[j][k]=0;\n\t\t\t\t\telse if(B[j][k]>0)B[j][k]=2;\n\t\t\t\t\telse B[j][k]=-2;\n\t\t\t\t}\n\t\t\t\telse B[j][n]%=2;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++)res[i]=B[i][n];\n}\n\nint main(){\n\tint m,n,d;\n\tint field[30][30];\n\twhile(cin>>m>>n>>d&&(m|n|d)){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\tcin>>field[i][j];\n\t\tint mtSize=m*n;\n\t\tmat mt(mtSize,vec(mtSize));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t// (m*i+j)sÚÌsñÌeñÉÂ¢Äè\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tfor(int l=0;l<m;l++){\n\t\t\t\t\t\tint mhd=abs(k-i)+abs(l-j);\n\t\t\t\t\t\tmt[m*i+j][m*k+l]=(mhd==d||mhd==0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> r;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)r.push_back(field[i][j]);\n\t\tvec res(mtSize);\n\t\tgauss_jordan(mt,r,res);\n\t\tif(res.size()==0)cout<<0<<endl;\n\t\telse cout<<1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\ninline int gauss_jordan(const mat& A, const vec& b){\n  int n = A.size();\n  mat B(n,vec(n+1));\n  rep(i,n)rep(j,n)B[i][j] = A[i][j];\n  rep(i,n)B[i][n] = b[i];\n\n  rep(i,n){\n    int p = i;\n    for(int j=i;j<n;j++){\n      if(B[j][i]==1){p = j; break;}\n    }\n    swap(B[i],B[p]);\n    if(B[i][i] == 0)continue;;\n    \n    rep(j,n){\n      if(i!=j && B[j][i]){\n\tfor(int k=i;k<=n;k++)(B[j][k] += B[i][k]) &= 1;\n      }\n    }\n  }\n  rep(i,n){\n    bool f = false;\n    rep(j,n)f |= (B[i][j]==1);\n    if(!f && B[i][n])return 0;\n  }\n  return 1;\n}\n\nconst int dy[] = {-1,-1,1,1}, dx[] = {-1,1,-1,1};\ninline vec manhattan(int y, int x, int d, int h, int w){\n  vec res(h*w,0);\n  res[y*w+x] = 1;\n  rep(dir,4){\n    rep(k,d+1){\n      int ny = y + k*dy[dir], nx = x + (d-k)*dx[dir];\n      if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n      res[ny*w+nx] = 1;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int w,h,d;\n  while(scanf(\"%d%d%d\",&w,&h,&d),h){\n    mat A(h*w);\n    vec b(h*w);\n    rep(i,h)rep(j,w){\n      A[i*w+j] = manhattan(i,j,d,h,w);\n      scanf(\"%d\",&b[i*w+j]);\n    }\n    cout << gauss_jordan(A,b) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int mod = 2; // assert mod is prime\n\ntemplate<int M>\nstruct Mint{\n\tint x;\n\tMint() : x(0){}\n\tMint(int y) : x(y >= 0 ? y % M : M - (-y) % M){}\n\tMint &operator += (const Mint &rhs){ if((x += rhs.x) >= M) x -= M; return *this; }\n\tMint &operator -= (const Mint &rhs){ if((x += M - rhs.x) >= M) x -= M; return *this; }\n\tMint &operator *= (const Mint &rhs){ x = 1LL * x*rhs.x % M; return *this; }\n\tMint &operator /= (const Mint &rhs){ x = (1LL * x*rhs.inv().x) % M; return *this; }\n\tMint operator - () const{ return Mint(-x); }\n\tMint operator + (const Mint &rhs) const{ return Mint(*this) += rhs; }\n\tMint operator - (const Mint &rhs) const{ return Mint(*this) -= rhs; }\n\tMint operator * (const Mint &rhs) const{ return Mint(*this) *= rhs; }\n\tMint operator / (const Mint &rhs) const{ return Mint(*this) /= rhs; }\n\tbool operator < (const Mint &rhs) const{ return x < rhs.x; }\n\tMint inv() const{\n\t\tsigned a = x, b = M, u = 1, v = 0, t;\n\t\twhile(b){ t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n\t\treturn Mint(u);\n\t}\n\tMint pow(long long t) const{\n\t\tMint e = *this, res = 1;\n\t\tfor(; t; e *= e, t >>= 1) if(t & 1) res *= e;\n\t\treturn res;\n\t}\n};\ntemplate <int M>\nostream &operator << (ostream &os, const Mint<M> &rhs){\n\treturn os << rhs.x;\n}\ntemplate <int M>\nistream &operator >> (istream &is, Mint<M> &rhs){\n\tlong long s; is >> s; rhs = Mint<M>(s); return is;\n};\n\nusing mint = Mint<mod>;\n\nusing Array = vector<mint>;\nusing Matrix = vector<Array>;\nconst double eps = 1e-10;\n\nvoid outMat(const Matrix& A){\n\tint n = A.size(), m = A[0].size();\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tcout << A[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nArray GaussJordan(const Matrix& A, const Array& b){\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\tB[i][j] = A[i][j];\n\tfor(int i = 0; i < n; i++) B[i][n] = b[i];\n\tfor(int i = 0; i < n; i++){\n\t\tint pivot = i;\n\t\tfor(int j = i; j < n; j++){\n\t\t\tif(B[j][i].x > B[pivot][i].x) pivot = j;\n\t\t\t//if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\t//outMat(B);\n\t\tswap(B[i], B[pivot]);\n\t\t//outMat(B);\n\n\t\t//if(abs(B[i][i]) < eps) return Array();\n\t\tfor(int j = i + 1; j <= n; j++) B[i][j] /= B[i][i];\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i != j){\n\t\t\t\tfor(int k = i + 1; k <= n; k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t}\n\t\t}\n\t\t//outMat(B);\n\t}\n\n\t//outMat(B);\n\n\tArray x(n);\n\tfor(int i = 0; i < n; i++) x[i] = B[i][n];\n\treturn x;\n}\n\nint b[25][25];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint m, n, d;\n\twhile(cin >> m >> n >> d, m){\n\t\tint N = n * m;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\n\t\tMatrix A(N, Array(N));\n\t\tArray B(N);\n\t\tfor(int i1 = 0; i1 < n; i1++){\n\t\t\tfor(int j1 = 0; j1 < m; j1++){\n\t\t\t\tfor(int i2 = 0; i2 < n; i2++){\n\t\t\t\t\tfor(int j2 = 0; j2 < m; j2++){\n\t\t\t\t\t\tint D = abs(i1 - i2) + abs(j1 - j2);\n\t\t\t\t\t\tA[i1 * n + j1][i2 * n + j2] = (D == 0 || D == d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tB[i1 * n + j1] = b[i1][j1];\n\t\t\t}\n\t\t}\n\t\t//outMat(A);\n\t\tauto X = GaussJordan(A, B);\n\n\t\tint ok = 1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tmint k = 0;\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tk += A[i][j] * X[j];\n\t\t\t}\n\t\t\tif(k.x != B[i].x){\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 625+2;\nconst int mod = 2;\nint mat[N][N];\n//if mod is prime\nint mypow(int n,int p){\n  if (p == 0)return 1;\n  int tmp=mypow(n,p/2);\n  tmp=(tmp*tmp)%mod;\n  if (tmp%2==1)tmp=(tmp*n)%mod;\n  return tmp%mod;\n}\n\ninline int inverse(int now){\n  if (now == 0)return -1;// now answer\n  return 1;\n  return mypow(now,mod-2);\n}\n\n//if mod is not prime\n//extended euqlid?\n\n//partial pivot\nbool select_pivot(int r,int c,int k,int mat[N][N]){\n  int s=k;\n  int val=abs(mat[k][k]);\n  REP(i,k+1,r){\n    if (abs(mat[i][k])>val)val=abs(mat[i][k]),s=i;\n  }\n  if (val ==0)return false;\n  REP(i,k,c+1)swap(mat[k][i],mat[s][i]);\n  return true;\n}\n \nbool select_pivot(int r,int c,int k,int mat[N][N],int num[N]){\n int s=k,t=k;//selected pivot\n double val=fabs(mat[k][k]);\n REP(i,k+1,r){\n   REP(j,k+1,c){\n     if (fabs(mat[i][j]) >val){\n       val=fabs(mat[i][j]);\n       s=i;\n       t=j;\n     }\n   }\n }\n \n if ( val<1)return false;//cannot solve this linear equations.\n \n rep(i,r)swap(mat[i][k],mat[i][t]);\n \n swap(num[k],num[t]);\n \n REP(i,k,c+1){\n   swap(mat[k][i],mat[s][i]);\n }\n return true;//no problem for this pivot;\n}\n\nbool gauss(int r,int c,int mat[N][N],int num[N]){\n  rep(k,c){\n    //if (!select_pivot(r,c,k,mat,num)){\n    if (!select_pivot(r,c,k,mat)){\n      REP(i,k,r)if (mat[i][c] == 1)return false;\n      return true;\n    }\n    assert(inverse(mat[k][k]) != -1);\n    int inv=inverse(mat[k][k]);\n    REP(i,k+1,c+1)mat[k][i]=(mat[k][i]*inv)%mod;\n    mat[k][k]=1;\n    REP(i,k+1,r){\n      REP(j,k+1,c+1)mat[i][j]=(mat[i][j]+(-mat[i][k]*mat[k][j]+mod))%mod;\n      mat[i][k]=0;\n    }\n  }\n  return true;\n  for(int i=r-1;i>=0;i--){\n    REP(j,i+1,c){\n      mat[i][c]=(mat[i][c]-(mat[i][j]*mat[j][c])+mod)%mod;\n    }\n  }\n  return true;\n}\n\n#define GETPOS(c,i,j) ((i)*(c)+(j))\n\nmain(){\n  int r,c,d;\n  int num[N];\n  while(cin>>c>>r>>d && r){\n    int n=r*c;\n    rep(i,n)rep(j,n+1)mat[i][j]=0;\n    rep(i,n)num[i]=i;\n    rep(i,r)rep(j,c){\n      int tmp;cin>>tmp;\n      mat[GETPOS(c,i,j)][n]=1-tmp;\n    }\n    rep(i,r){\n      rep(j,c){\n\tmat[GETPOS(c,i,j)][GETPOS(c,i,j)]=1;\n\trep(ii,r){\n\t  rep(jj,c){\n\t    if (abs(ii-i)+abs(jj-j) == d){\n\t      mat[GETPOS(c,i,j)][GETPOS(c,ii,jj)]=1;\n\t      //cout << \"(\" <<i<<\",\"<<j<<\"),(\"\n\t      //<< ii<<\",\"<<jj<<\")\"<<endl;\n\t      //cout << GETPOS(c,i,j)+1 <<\" \" << GETPOS(c,ii,jj)+1 << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    /*    rep(i,n){\n      rep(j,n+1)cout << mat[i][j] <<\" \";\n      cout << endl;\n    }      \n    */\n\n    cout << gauss(n,n,mat,num) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "//59\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  for(int m,n,d;cin>>m>>n>>d,m|n|d;){\n    vector<vector<int> > v(m*n,vector<int>(m*n+1));\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tfor(int k=0;k<n;k++){\n\t  for(int l=0;l<m;l++){\n\t    int cd=abs(i-k)+abs(j-l);\n\t    v[i*m+j][k*m+l]=cd==0||cd==d;\n\t  }\n\t}\n\tcin>>v[i*m+j].back();\n      }\n    }\n    int dn=0;\n    for(int i=0;i<n*m;i++){\n      int j;\n      for(j=dn;j<v.size();j++){\n\tif(v[j][i])break;\n      }\n      if(j==v.size())continue;\n      swap(v[dn],v[j]);\n      for(int k=dn+1;k<v.size();k++){\n\tif(v[k][i]){\n\t  for(int l=0;l<v[k].size();l++){\n\t    v[k][l]^=v[dn][l];\n\t  }\n\t}\n      }\n      dn++;\n    }\n    int i;\n    for(i=dn;i<v.size();i++){\n      if(v[i].back())break;\n    }\n    cout<<(i==v.size())<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<cstring>\n#include<cmath>\ninline int Input(){\n\tint ret=0;bool isN=0;char c=getchar();\n\twhile(c<'0' || c>'9'){\n\t\tif(c=='-') isN=1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn isN?-ret:ret;\n}\n\ninline void Output(long long x){\n    if(x<0){\n        putchar('-');x=-x;\n    }\n    int len=0,data[20];\n    while(x){\n        data[len++]=x%10;x/=10;\n    }\n    if(!len)    data[len++]=0;\n    while(len--)\n        putchar(data[len]+48);\n    putchar('\\n');\n}\n#pragma comment(linker,\"/STACK:124000000,124000000\")\n#include<map>\n#include<vector>\n#include<queue>\n#define eps 1e-10\n#define INF 2000000009\n#define maxn 150050\n#define maxm 2500010\n#define mod 1000000\n#define llINF 1LL<<60\nusing namespace std;\n\nconst int MAXN=900;\n\n\n\nint a[MAXN][MAXN];//蠅槫ケソ遏ゥ髦オ\nint x[MAXN];//隗」髮?//bool free_x[MAXN];//譬?ョー譏ッ蜷ヲ譏ッ荳咲。ョ螳夂噪蜿伜?\n\n\n\n/*\nvoid Debug(void)\n{\n    int i, j;\n    for (i = 0; i < equ; i++)\n    {\n        for (j = 0; j < var + 1; j++)\n        {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n*/\n\n\ninline int gcd(int a,int b)\n{\n    int t;\n    while(b!=0)\n    {\n        t=b;\n        b=a%b;\n        a=t;\n    }\n    return a;\n}\ninline int lcm(int a,int b)\n{\n    return a/gcd(a,b)*b;//蜈磯勁蜷惹ケ倬亟貅「蜃コ\n}\n\n// 鬮俶民豸亥?豕戊ァ」譁ケ遞狗サ?Gauss-Jordan elimination).(-2陦ィ遉コ譛画オョ轤ケ謨ー隗」?御ス?裏謨エ謨ー隗」??//-1陦ィ遉コ譌?ァ」??陦ィ遉コ蜚ッ荳?ァ」?悟、ァ莠?陦ィ遉コ譌?ゥキ隗」?悟ケカ霑泌屓閾ェ逕ア蜿伜?逧?クェ謨ー)\n//譛影qu荳ェ譁ケ遞具シ計ar荳ェ蜿伜?縲ょ「槫ケソ遏ゥ髦オ陦梧焚荳コequ,蛻?悪荳コ0蛻ーequ-1,蛻玲焚荳コvar+1,蛻?悪荳コ0蛻ーvar.\nint Gauss(int equ,int var)\n{\n    int i,j,k;\n    int max_r;// 蠖灘燕霑吝?扈晏ッケ蛟シ譛?、ァ逧?。?\n    int col;//蠖灘燕螟?炊逧??\n    int ta,tb;\n    int LCM;\n    int temp;\n    int free_x_num;\n    int free_index;\n    bool free_x[MAXN];\n    for(int i=0;i<=var;i++)\n    {\n        x[i]=0;\n        free_x[i]=true;\n    }\n\n    //霓ャ謐「荳コ髦カ譴ッ髦オ.\n    col=0; // 蠖灘燕螟?炊逧??\n    for(k = 0;k < equ && col < var;k++,col++)\n    {// 譫壻クセ蠖灘燕螟?炊逧?。?\n// 謇セ蛻ー隸・col蛻怜?邏?サ晏ッケ蛟シ譛?、ァ逧?ぅ陦御ク守ャャk陦御コ、謐「.(荳コ莠?惠髯、豕墓慮蜃丞ー剰ッッ蟾ョ)\n        max_r=k;\n        for(i=k+1;i<equ;i++)\n        {\n            if(abs(a[i][col])>abs(a[max_r][col])) max_r=i;\n        }\n        if(max_r!=k)\n        {// 荳守ャャk陦御コ、謐「.\n            for(j=k;j<var+1;j++) swap(a[k][j],a[max_r][j]);\n        }\n        if(a[k][col]==0)\n        {// 隸エ譏手ッ・col蛻礼ャャk陦御サ・荳句?譏ッ0莠?シ悟?螟?炊蠖灘燕陦檎噪荳倶ク??.\n            k--;\n            continue;\n        }\n        for(i=k+1;i<equ;i++)\n        {// 譫壻クセ隕∝唖蜴サ逧?。?\n            if(a[i][col]!=0)\n            {\n                LCM = lcm(abs(a[i][col]),abs(a[k][col]));\n                ta = LCM/abs(a[i][col]);\n                tb = LCM/abs(a[k][col]);\n                if(a[i][col]*a[k][col]<0)tb=-tb;//蠑ょ捷逧?ュ蜀オ譏ッ逶ク蜉?                for(j=col;j<var+1;j++)\n                {\n                    a[i][j] = abs(a[i][j]*ta-a[k][j]*tb)%2;\n                }\n            }\n        }\n    }\n\n  //  Debug();\n\n    // 1. 譌?ァ」逧?ュ蜀オ: 蛹也ョ?噪蠅槫ケソ髦オ荳ュ蟄伜惠(0, 0, ..., a)霑呎?逧?。?a != 0).\n    for (i = k; i < equ; i++)\n    { // 蟇ケ莠取裏遨キ隗」譚・隸エ?悟ヲよ棡隕∝愛譁ュ蜩ェ莠帶弍閾ェ逕ア蜿伜??碁ぅ荵亥?遲芽。悟序謐「荳ュ逧?コ、謐「蟆ア莨壼スア蜩搾シ悟?隕∬ョー蠖穂コ、謐「.\n        if (a[i][col]!= 0) return -1;\n    }\n    return 0;\n    // 2. 譌?ゥキ隗」逧?ュ蜀オ: 蝨ィvar * (var + 1)逧?「槫ケソ髦オ荳ュ蜃コ邇ー(0, 0, ..., 0)霑呎?逧?。鯉シ悟叉隸エ譏取イ。譛牙ス「謌蝉ク・譬シ逧?ク贋ク芽ァ帝亰.\n    // 荳泌?邇ー逧?。梧焚蜊ウ荳コ閾ェ逕ア蜿伜?逧?クェ謨ー.\n    if (k < var)\n    {\n        // 鬥門??瑚?逕ア蜿伜?譛益ar - k荳ェ?悟叉荳咲。ョ螳夂噪蜿伜?閾ウ蟆第怏var - k荳ェ.\n        for (i = k - 1; i >= 0; i--)\n        {\n            // 隨ャi陦御ク?ョ壻ク堺シ壽弍(0, 0, ..., 0)逧?ュ蜀オ?悟屏荳コ霑呎?逧?。梧弍蝨ィ隨ャk陦悟芦隨ャequ陦?\n            // 蜷梧??檎ャャi陦御ク?ョ壻ク堺シ壽弍(0, 0, ..., a), a != 0逧?ュ蜀オ?瑚ソ呎?逧?裏隗」逧?\n            free_x_num = 0; // 逕ィ莠主愛譁ュ隸・陦御クュ逧?ク咲。ョ螳夂噪蜿伜?逧?クェ謨ー?悟ヲよ棡雜?ソ?荳ェ?悟?譌?ウ墓アりァ」?悟ョ?サャ莉咲┯荳コ荳咲。ョ螳夂噪蜿伜?.\n            for (j = 0; j < var; j++)\n            {\n                if (a[i][j] != 0 && free_x[j]) free_x_num++, free_index = j;\n            }\n            if (free_x_num > 1) continue; // 譌?ウ墓アりァ」蜃コ遑ョ螳夂噪蜿伜?.\n            // 隸エ譏主ーア蜿ェ譛我ク?クェ荳咲。ョ螳夂噪蜿伜?free_index?碁ぅ荵亥庄莉・豎りァ」蜃コ隸・蜿伜??御ク碑ッ・蜿伜?譏ッ遑ョ螳夂噪.\n            temp = a[i][var];\n            for (j = 0; j < var; j++)\n            {\n                if (a[i][j] != 0 && j != free_index) temp -= a[i][j] * x[j];\n            }\n            x[free_index] = temp / a[i][free_index]; // 豎ょ?隸・蜿伜?.\n            free_x[free_index] = 0; // 隸・蜿伜?譏ッ遑ョ螳夂噪.\n        }\n        return var - k; // 閾ェ逕ア蜿伜?譛益ar - k荳ェ.\n    }\n    // 3. 蜚ッ荳?ァ」逧?ュ蜀オ: 蝨ィvar * (var + 1)逧?「槫ケソ髦オ荳ュ蠖「謌蝉ク・譬シ逧?ク贋ク芽ァ帝亰.\n    // 隶。邂怜?Xn-1, Xn-2 ... X0.\n    for (i = var - 1; i >= 0; i--)\n    {\n        temp = a[i][var];\n        for (j = i + 1; j < var; j++)\n        {\n            if (a[i][j] != 0) temp -= a[i][j] * x[j];\n        }\n        if (temp % a[i][i] != 0) return -2; // 隸エ譏取怏豬ョ轤ケ謨ー隗」?御ス?裏謨エ謨ー隗」.\n        x[i] = temp / a[i][i];\n    }\n    return 0;\n}\nint main()\n{\n    int n,m,d;\n    while(scanf(\"%d%d%d\",&m,&n,&d)&&n)\n    {\n        int t=n*m;\n        memset(a,0,sizeof(a));\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                scanf(\"%d\",&a[i*m+j][t]);\n            }\n        }\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<m;j++)\n            {\n                a[i*m+j][i*m+j]=1;\n                for(int x=0;x<n;x++)\n                {\n                    for(int y=0;y<m;y++)\n                    {\n                        if(abs(x-i)+abs(y-j)==d)\n                        {\n                            a[i*m+j][x*m+y]=1;\n                        }\n                    }\n                }\n            }\n        }\n//        for(int i=0;i<t;i++)\n//        {\n//            for(int j=0;j<=t;j++)\n//                printf(\"%d \",a[i][j]);\n//            printf(\"\\n\");\n//        }\n        int ans=Gauss(t,t);\n        if(ans>=0) printf(\"1\\n\");\n        else printf(\"0\\n\");\n//        for(int i=0;i<t;i++)\n//            printf(\"%d \",x[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M, N, D;\nint room[30][30];\nint mat[900][900];\nint vec[900];\nint dx[4] = { 1, 1, -1, -1};\nint dy[4] = { 1, -1, 1, -1};\nint sidx[900];\nint dim;\n\nint toIdx(int x, int y){\n\treturn y * M + x;\n}\nbool correct(int x, int y){\n\treturn 0 <= x && x < M && 0 <= y && y < N;\n}\n\nvoid outvec(){\n\tcout << \"========\" << endl;\n\tfor(int i = 0; i < dim; i++){\n\t\tfor(int j = 0; j < dim; j++){\n\t\t\tcout << \" \" << mat[sidx[i]][j];\n\t\t}\n\t\tcout << \" | \" << vec[sidx[i]] << endl;\n\t}\n}\n\nint main(){\n\twhile(cin >> M >> N >> D, M){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < M; j++){\n\t\t\t\tcin >> room[i][j];\n\t\t\t}\n\t\t}\n\t\tdim = M * N;\n\t\tfor(int i = 0; i < dim; i++){\n\t\t\tfor(int j = 0; j < dim; j++){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t\tvec[i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < M; j++){\n\t\t\t\tfor(int k = 0; k <= D; k++){\n\t\t\t\t\tint x = k;\n\t\t\t\t\tint y = D - k;\n\t\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\t\tint px = j + x * dx[l];\n\t\t\t\t\t\tint py = i + y * dy[l];\n\t\t\t\t\t\tif(correct(px, py)){\n\t\t\t\t\t\t\tmat[toIdx(j, i)][toIdx(px, py)] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmat[toIdx(j, i)][toIdx(j, i)] = 1;\n\t\t\t\tif(room[i][j]){\n\t\t\t\t\tvec[toIdx(j, i)] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < dim; i++) sidx[i] = i;\n\t\tfor(int i = 0; i < dim; i++){\n\t\t\t//outvec();\n\t\t\tint mi = i;\n\t\t\tfor(int j = i + 1; j < dim; j++){\n\t\t\t\tfor(int k = i; k < dim; k++){\n\t\t\t\t\tif(mat[sidx[mi]][k] < mat[sidx[j]][k]){\n\t\t\t\t\t\tmi = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else if(mat[sidx[mi]][k] > mat[sidx[j]][k]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint tmp = sidx[mi];\n\t\t\tsidx[mi] = sidx[i];\n\t\t\tsidx[i] = tmp;\n\t\t\tint v = mat[sidx[i]][i];\n\t\t\tif(v == 0) continue;\n\n\t\t\tfor(int j = i + 1; j < dim; j++){\n\t\t\t\tv = mat[sidx[j]][i];\n\t\t\t\tfor(int k = i + 1; k < dim; k++){\n\t\t\t\t\tint val1 = mat[sidx[j]][k];\n\t\t\t\t\tint val2 = mat[sidx[i]][k];\n\t\t\t\t\tmat[sidx[j]][k] = (val1 - val2 * v + 2) % 2;\n\t\t\t\t}\n\t\t\t\tvec[sidx[j]] = (vec[sidx[j]] - vec[sidx[i]] * v + 2) % 2;\n\n\t\t\t\tmat[sidx[j]][i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t//outvec();\n\t\tbool f2 = true;\t\n\t\tfor(int i = dim - 1; i >= 0; i--){\n\t\t\tbool flg = true;\n\t\t\tfor(int j = 0; j < dim; j++){\n\t\t\t\tif(mat[sidx[i]][j] != 0) flg = false;\n\t\t\t}\n\t\t\tif(flg && vec[sidx[i]] != 0){\n\t\t\t\tf2 = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(f2){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define ABS(x) ((x)<0 ? -(x) : (x))\n\n#define MAXN 625+1\n#define MAXD 25\n\nint gaussjordan(int **A, int M, int N) {\n\tint i, j, k;\n\n\tint RANK = M;\n\tfor (i=0; i<M; i++) {\n\t\t//Busco una fila con un 1 en la columna i\n\t\tfor (k=i; k<M; k++) {\n\t\t\tif (A[k][i] == 1) break;\n\t\t}\n\n\t\t//Si no la encuentro\n\t\tif (k == M) {\n\t\t\tRANK--;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Si la encuentro, pasa a ser la fila i\n\t\tfor (j=0; j<N; j++) swap(A[i][j], A[k][j]);\n\n\t\tfor (k=0; k<M; k++) {\n\t\t\tif (k != i && A[k][i] == 1) {\n\t\t\t\tfor (j=i; j<N; j++) {\n\t\t\t\t\tA[k][j] = ((A[k][j] - A[i][j])%2 + 2)%2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn RANK;\n}\n\nint main() {\n\nfreopen(\"in.txt\", \"r\", stdin);\n\nint i, j, k, l, N, n[MAXD][MAXD], a[MAXN][MAXN], *aa[MAXN], R, C, K;\nbool flag;\n\nfor (i=0; i<MAXN; i++) aa[i] = a[i];\n\ncin >> C;\ncin >> R;\ncin >> K;\n\ndo {\n\nN = 0;\nfor (i=0; i<R; i++) {\n\tfor (j=0; j<C; j++) {\n\t\tn[i][j] = N++;\n\t}\n}\n\nmemset(a, 0, sizeof(a));\nfor (i=0; i<R; i++) {\n\tfor (j=0; j<C; j++) {\n\t\tcin >> a[n[i][j]][N];\n\t\ta[n[i][j]][n[i][j]] = 1;\n\n\t\tfor (k=0; k<R; k++) {\n\t\t\tfor (l=0; l<C; l++) {\n\t\t\t\tif (ABS(i-k) + ABS(j-l) == K) {\n\t\t\t\t\ta[n[i][j]][n[k][l]] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*for (i=0; i<N; i++) {\n\tfor (j=0; j<N; j++) {\n\t\tcout << a[i][j] << ' ';\n\t}\n\tcout << endl;\n}*/\n\ngaussjordan(aa, N, N+1);\n\nflag = true;\nfor (i=0; i<N && flag; i++) {\n\tfor (j=0; j<N; j++) {\n\t\tif (a[i][j] == 1) break;\n\t}\n\tif (j==N && a[i][N]==1) flag = false;\n}\nif (flag) cout << 1 << endl;\nelse cout << 0 << endl;\n\ncin >> C;\ncin >> R;\ncin >> K;\n\n} while (R!=0 || C!=0 || K!=0);\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <algorithm>\n#define coor(i,j) ((i)+(j)*m)\n#define in(i,j) (0<=(i)&&(i)<m&&0<=(j)&&(j)<n)\nusing namespace std;\nvector<bitset<626> > M(625);\n\nint main(){\n\tint m,n,d;\n\tint i,j,k;\n\tint success,ans;\n\tfor(;cin>>m>>n>>d,d;cout<<ans<<endl){\n\t\t//create M\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tM[coor(i,j)].reset();\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tM[coor(i,j)][coor(i,j)]=1;\n\t\t\t\tcin>>k;M[coor(i,j)][m*n]=k;\n\n\t\t\t\tfor(k=0;k<=d;k++){\n\t\t\t\t\tif(in(i-k,j-(d-k)))M[coor(i,j)][coor(i-k,j-(d-k))]=1;\n\t\t\t\t\tif(in(i+k,j-(d-k)))M[coor(i,j)][coor(i+k,j-(d-k))]=1;\n\t\t\t\t\tif(in(i-k,j+(d-k)))M[coor(i,j)][coor(i-k,j+(d-k))]=1;\n\t\t\t\t\tif(in(i+k,j+(d-k)))M[coor(i,j)][coor(i+k,j+(d-k))]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//solve\n\t\tk=0;\n\t\tfor(i=0;i<m*n;i++){\n\t\t\tfor(j=k;j<m*n&&!M[j][i];j++);\n\t\t\tif(j==m*n)continue;\n\t\t\tswap(M[k],M[j]);\n\t\t\tfor(j=k+1;j<m*n;j++)if(M[j][i])M[j]^=M[k];\n\t\t\tk++;\n\t\t}\n\n\t\t//finalize\n\t\tans=1;\n\t\tfor(j=k;j<m*n;j++)if(M[j][m*n])ans=0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int M, N, D;\n  while (cin>>M>>N>>D && M) {\n    int S[25][25];\n    REP(i, M)REP(j, N) cin>>S[i][j];\n    int G[25 * 25][26] = {};\n    REP(i, M)REP(j, N){\n      REP(k, M)REP(l, N){\n        if(abs(i - k) + abs(j - l) == D || (i == k && j == l)){\n          G[i + M * j][k] |= 1<<l;\n        }\n      }\n      G[i + M * j][25] = S[i][j];\n    }\n    bool ans = true;\n    for(int i = 0; i < M * N; i++){\n      int pivot = -1;\n      for(int j = i; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))) pivot = j;\n      }\n      if(pivot == -1) continue;\n      int tmp[26];\n      //swap(G[i], G[pivot]);\n      memcpy(tmp, G[i], sizeof(tmp));\n      memcpy(G[i], G[pivot], sizeof(tmp));\n      memcpy(G[pivot], tmp, sizeof(tmp));\n      for(int j = i + 1; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))){\n          for(int k = 0; k < M; k++){\n            G[j][k] ^= G[i][k];\n          }\n          G[j][25] ^= G[i][25];\n        }\n      }\n    }\n    int a[25 * 25] = {};\n    bool twoways[25 * 25] = {};\n    for(int i = M * N - 1; i >= 0; i--){\n      bool have_two = false;\n      for(int j = 0; j < M * N; j++) if(G[i][j / N] & (1 << (j % N))) {\n        G[i][25] ^= a[j];\n        if(twoways[j]) have_two = true;\n      }\n      if(!(G[i][i / N] & (1 << (i % N)))) {\n        if(G[i][25] == 1 && !have_two) ans = false;\n        else twoways[i] = true;\n      }else{\n        a[i] = G[i][25];\n      }\n    }\n    if(ans) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint mat[625][626];\n\nbool solve(int n){\n\tbool used[625]={};\n\trep(j,n){\n\t\tint i;\n\t\tfor(i=0;i<n;i++) if(!used[i] && mat[i][j]==1) break;\n\t\tif(i<n){\n\t\t\tused[i]=true;\n\t\t\trep(k,n) if(i!=k && mat[k][j]==1) {\n\t\t\t\trep(l,n+1) mat[k][l]=(mat[k][l]+mat[i][l])&1;\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i,n) if(!used[i] && mat[i][n]==1) return false;\n\n\treturn true;\n}\n\nint main(){\n\tfor(int m,n,d;scanf(\"%d%d%d\",&n,&m,&d),m;){\n\t\tint a[25][25];\n\t\trep(i,m) rep(j,n) scanf(\"%d\",a[i]+j);\n\n\t\tmemset(mat,0,sizeof mat);\n\t\trep(i,m) rep(j,n) {\n\t\t\tmat[i*n+j][i*n+j]=1;\n\t\t\trep(ii,m) rep(jj,n) if(abs(ii-i)+abs(jj-j)==d) {\n\t\t\t\tmat[ii*n+jj][i*n+j]=1;\n\t\t\t}\n\t\t\tmat[i*n+j][m*n]=a[i][j];\n\t\t}\n\n\t\tputs(solve(m*n)?\"1\":\"0\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool solve(vector<vector<int> > a, vector<int> b){\n\tint n = a.size();\n\tvector<vector<int> > B(n, vector<int>(n+1) );\n\t\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\tB[i][j] = a[i][j];\n\t\t}\n\t}\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tB[i][n] = b[i];\n\t}\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tint p = -1, val = -1;\n\t\tfor(int j=i ; j < n ; j++ ){\n\t\t\tif( val < abs(B[j][i]) ){\n\t\t\t\tp = j;\n\t\t\t\tval = abs(B[j][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( p == -1 || val <= 0 ) continue;\n\t\t\n\t\tswap(B[p], B[i]);\n\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\tif( i == j ) continue;\n\t\t\t\n\t\t\tint m = B[j][i];\n\t\t\tif( m == 1 ){\n\t\t\t\tfor(int k=i ; k <= n ; k++ ){\n\t\t\t\t\tB[j][k] = (B[j][k] + B[i][k]) % 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> res(n);\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tres[i] = B[i][n];\n\t\tif( B[i][i] == 0 && B[i][n] == 1 ){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint w, h, d, s[25][25];\n\twhile( cin >> w >> h >> d, w || h || d ){\n\t\tfor(int y = 0 ; y < h ; y++ ){\n\t\t\tfor(int x = 0 ; x < w ; x++ ){\n\t\t\t\tcin >> s[y][x];\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > a(w*h, vector<int>(w*h) );\n\t\tvector<int> b(w*h, 0);\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( s[y][x] ){\n\t\t\t\t\tb[y*w+x] = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int y_=0 ; y_ < h ; y_++ ){\n\t\t\t\t\tfor(int x_=0 ; x_ < w ; x_++ ){\n\t\t\t\t\t\tint dist = abs(x - x_) + abs(y - y_);\n\t\t\t\t\t\tif( dist == d || dist == 0 ){\n\t\t\t\t\t\t\ta[y*w+x][y_*w+x_] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ans = solve(a, b);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 625+2;\nconst int mod = 2;\nint mat[N][N];\n//if mod is prime\nint mypow(int n,int p){\n  if (p == 0)return 1;\n  int tmp=mypow(n,p/2);\n  tmp=(tmp*tmp)%mod;\n  if (tmp%2==1)tmp=(tmp*n)%mod;\n  return tmp%mod;\n}\n\ninline int inverse(int now){\n  if (now == 0)return -1;// now answer\n  return 1;\n  return mypow(now,mod-2);\n}\n\n//if mod is not prime\n//extended euqlid?\n\n//partial pivot\nbool select_pivot(int r,int c,int k,int mat[N][N]){\n  int s=k;\n  int val=abs(mat[k][k]);\n  REP(i,k+1,r){\n    if (abs(mat[i][k])>val)val=abs(mat[i][k]),s=i;\n  }\n  if (val ==0)return false;\n  REP(i,k,c+1)swap(mat[k][i],mat[s][i]);\n  return true;\n}\n \nbool select_pivot(int r,int c,int k,int mat[N][N],int num[N]){\n int s=k,t=k;//selected pivot\n double val=fabs(mat[k][k]);\n REP(i,k+1,r){\n   REP(j,k+1,c){\n     if (fabs(mat[i][j]) >val){\n       val=fabs(mat[i][j]);\n       s=i;\n       t=j;\n     }\n   }\n }\n \n if ( val<1)return false;//cannot solve this linear equations.\n \n rep(i,r)swap(mat[i][k],mat[i][t]);\n \n swap(num[k],num[t]);\n \n REP(i,k,c+1){\n   swap(mat[k][i],mat[s][i]);\n }\n return true;//no problem for this pivot;\n}\n\nbool gauss(int r,int c,int mat[N][N],int num[N]){\n  rep(k,c){\n    if (!select_pivot(r,c,k,mat,num)){\n      //if (!select_pivot(r,c,k,mat)){\n      REP(i,k,r)if (mat[i][c] == 1)return false;\n      return true;\n    }\n    assert(inverse(mat[k][k]) != -1);\n    REP(i,k+1,c+1)mat[k][i]=(mat[k][i]*inverse(mat[k][k]))%mod;\n    mat[k][k]=1;\n    REP(i,k+1,r){\n      REP(j,k+1,c+1)mat[i][j]=(mat[i][j]+(-mat[i][k]*mat[k][j]+mod))%mod;\n      mat[i][k]=0;\n    }\n  }\n  return true;\n  for(int i=r-1;i>=0;i--){\n    REP(j,i+1,c){\n      mat[i][c]=(mat[i][c]-(mat[i][j]*mat[j][c])+mod)%mod;\n    }\n  }\n  return true;\n}\n\n#define GETPOS(c,i,j) ((i)*(c)+(j))\n\nmain(){\n  int r,c,d;\n  int num[N];\n  while(cin>>c>>r>>d && r){\n    int n=r*c;\n    rep(i,n)rep(j,n+1)mat[i][j]=0;\n    rep(i,n)num[i]=i;\n    rep(i,r)rep(j,c){\n      int tmp;cin>>tmp;\n      mat[GETPOS(c,i,j)][n]=1-tmp;\n    }\n    rep(i,r){\n      rep(j,c){\n\tmat[GETPOS(c,i,j)][GETPOS(c,i,j)]=1;\n\trep(ii,r){\n\t  rep(jj,c){\n\t    if (abs(ii-i)+abs(jj-j) == d){\n\t      mat[GETPOS(c,i,j)][GETPOS(c,ii,jj)]=1;\n\t      //cout << \"(\" <<i<<\",\"<<j<<\"),(\"\n\t      //<< ii<<\",\"<<jj<<\")\"<<endl;\n\t      //cout << GETPOS(c,i,j)+1 <<\" \" << GETPOS(c,ii,jj)+1 << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    /*    rep(i,n){\n      rep(j,n+1)cout << mat[i][j] <<\" \";\n      cout << endl;\n    }      \n    */\n\n    cout << gauss(n,n,mat,num) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\n#include <ctime>\n#include <numeric>\n#include <fstream>\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst long double pi=acos(-1.0);\nint dx[]={0,1,0,-1,1,1,-1,-1,0},dy[]={1,0,-1,0,1,-1,1,-1,0};\n\n\nint n,m,d;\n\n\nvoid solve(){\n  int mat[n*m][n*m+1];\n  memset(mat,0,sizeof(mat));\n\n  rep(i,m*n)mat[i][i]=1;\n  queue<PI> q;\n  q.push(mp(0,0));\n  set<PI> app;\n  vector<PI> man;\n  while(!q.empty()){\n    int cx=q.front().F;\n    int cy=q.front().S;\n    q.pop();\n    if(app.count(mp(cx,cy)))continue;\n    app.insert(mp(cx,cy));\n    if(abs(cx)+abs(cy)==d){\n      man.pb(mp(cx,cy));\n      continue;\n    }\n\n    rep(i,4){\n      int nx=cx+dx[i],ny=cy+dy[i];\n      if(app.count(mp(nx,ny)))continue;\n      q.push(mp(nx,ny));\n    }\n  }\n\n  rep(i,m*n)\n    FOR(it,man){\n    int x=i/m+it->F,y=i%m+it->S;\n    if(min(x,y)<0 || x>=n || y>=m)continue;\n    mat[i][x*m+y]=1;\n  }\n\n  rep(i,n)rep(j,m)\n    cin>>mat[i*m+j][m*n];\n\n\n  int ofs=0;\n  for(int i=0;i+ofs<m*n;++i){\n    /*\n    rep(j,m*n){\n      rep(k,m*n+1)cout<<mat[j][k]<<' ';\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n    if(!mat[i][i+ofs])\n      for(int j=m*n-1;j>i;--j)\n        if(mat[j][i+ofs]){\n          for(int k=0;k<m*n+1;++k)\n            swap(mat[i][k],mat[j][k]);\n          break;\n        }\n    \n    if(mat[i][i+ofs]){\n      for(int j=i+1;j<m*n;++j)\n        if(mat[j][i+ofs])\n          rep(k,m*n+1)\n            mat[j][k]^=mat[i][k];\n    }else ++ofs,--i;\n  }\n\n  for(int i=m*n-1;i>m*n-1-ofs;--i)\n    if(mat[i][m*n]){\n      cout<<0<<endl;\n      return;\n    }\n\n  cout<<1<<endl;\n}\n\nmain(){\n  while(cin>>m>>n>>d,n|m|d)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\ntypedef vector<int> V;\ntypedef vector<V> MATRIX;\n\nint W,H,D,SIZE;\nint table[25][25];\n\n\nbool gauss_jordan(MATRIX A){\n\n\tMATRIX C(SIZE,V(SIZE+1));\n\n\tfor(int row = 0; row < SIZE; row++){\n\t\tfor(int col = 0; col < SIZE+1; col++)C[row][col] = A[row][col];\n\t}\n\n\tint base_row;\n\tfor(int i = 0; i < SIZE; i++){\n\t\tbase_row = i;\n\t\tfor(int row = i+1; row < SIZE; row++){\n\t\t\tif(abs(C[row][i]) > abs(C[base_row][i])){\n\t\t\t\tbase_row = row;\n\t\t\t}\n\t\t}\n\n\t\tif(abs(C[base_row][i]) == 0)continue; //操作不要\n\n\t\tif(base_row != i)swap(C[base_row],C[i]);\n\n\t\tfor(int row = 0; row < SIZE; row++){\n\t\t\tif(row == i || C[row][i] == 0)continue;\n\n\t\t\tfor(int col = i; col < SIZE+1; col++){\n\t\t\t\tC[row][col] -= C[i][col];\n\t\t\t\tC[row][col] += 2;\n\t\t\t\tC[row][col] %= 2;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool FLG;\n\n\tfor(int row = 0; row < SIZE; row++){\n\t\tif(C[row][SIZE] != 0){\n\t\t\tFLG = false;\n\t\t\tfor(int col = 0; col < SIZE; col++){\n\t\t\t\tif(C[row][col] != 0){\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!FLG)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\n\n\nvoid func(){\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&table[row][col]);\n\t\t}\n\t}\n\n\tSIZE = H*W;\n\n\tMATRIX A(SIZE,V(SIZE+1));\n\n\tint dist;\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int a = 0; a < H; a++){\n\t\t\t\tfor(int b = 0; b < W; b++){\n\t\t\t\t\tdist = abs(row-a)+abs(col-b);\n\t\t\t\t\tif(dist == 0 || dist == D){\n\t\t\t\t\t\tA[row*W+col][a*W+b] = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tA[row*W+col][a*W+b] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tA[row*W+col][SIZE] = table[row][col];\n\t\t}\n\t}\n\n\tif(gauss_jordan(A)){\n\t\tprintf(\"1\\n\");\n\t}else{\n\t\tprintf(\"0\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&W,&H,&D);\n\t\tif(W == 0 && H == 0 && D == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n  \nusing namespace std;\n  \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n  \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n  \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n  \nint main(){\n  int M, N, D;\n  while (cin>>N>>M>>D && M) {\n    int S[25][25];\n    REP(i, M)REP(j, N) cin>>S[i][j];\n    int G[25 * 25][26] = {};\n    REP(i, M)REP(j, N){\n      REP(k, M)REP(l, N){\n        if(abs(i - k) + abs(j - l) == D || (i == k && j == l)){\n          G[i + M * j][k] |= 1<<l;\n        }\n      }\n      G[i + M * j][25] = S[i][j];\n    }\n    bool ans = true;\n    for(int i = 0; i < M * N; i++){\n      int pivot = -1;\n      for(int j = i; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))) pivot = j;\n      }\n      if(pivot == -1) continue;\n      int tmp[26];\n      //swap(G[i], G[pivot]);\n      memcpy(tmp, G[i], sizeof(tmp));\n      memcpy(G[i], G[pivot], sizeof(tmp));\n      memcpy(G[pivot], tmp, sizeof(tmp));\n      for(int j = 0; j < M * N; j++){\n        if(G[j][i / N] & (1 << (i % N))){\n          for(int k = 0; k < M; k++){\n            G[j][k] ^= G[i][k];\n          }\n          G[j][25] ^= G[i][25];\n        }\n      }\n    }\n    for(int i = M * N - 1; i >= 0; i--){\n      if(!(G[i][i / N] & (1 << (i % N))) && G[i][25]){\n        ans = false;\n      }\n    }\n    if(ans) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\nconst int maxn = 444444;\nint a[625][625];\nint solve(int a[][625],int n) {\n    int i , j ,k , r;\n    for(i = 0; i < n; i++) {\n      r = i;\n      for(j = i+1; j < n; j++) if(a[j][i] > a[r][i]) r = j;\n      if(!a[r][i]) continue;\n      if(r != i) for(j = 0; j <= n; j++) swap(a[i][j],a[r][j]);\n      for(k = 0; k < n; k++) if(k!=i && a[k][i]) \n        for(j = i; j <= n; j++) a[k][j] ^= a[i][j];\n    }\n    for(i = 0; i < n; i++) if(!a[i][i] && a[i][n]) return -1;\n    return 1;\n}\nint main() {\n  int t,n,x,y,m,d;\n  while(scanf(\"%d%d%d\",&n,&m,&d)!=EOF) {\n    memset(a,0,sizeof(a));\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tfor(int j = 0,k; j < n; j++)\n\t\t{\n\t\t\tscanf(\"%d\",&k);\n\t\t\ta[i*n+j][m*n] ^= k;\n\t\t\tfor(int x = 0; x < m; x++)\n\t\t\t{\n\t\t\t\tfor(int y = 0; y < n; y++)\n\t\t\t\t{\n\t\t\t\t\tif(abs(x-i) + abs(y-j) == d)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i*n+j][x*n+y] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < m*n; i++) a[i][i] = 1;\n/*\tfor(int i = 0; i < m*n; i++)\n\t{\n\t\tfor(int j = 0; j < m*n; j++)\n\t\t{\n\t\t\tprintf(\"%d \",a[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}*/\n    int ans = solve(a,n*m);\n    if(ans == -1) puts(\"0\");\n    else printf(\"1\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nconst Int MAX = 2002;\nusing BS = bitset<MAX*2>;\nusing mat = vector<BS>;\n\nvoid gauss(mat &v){\n  int n=v.size();\n  for(Int i=0;i<n;i++){\n    for(Int k=i;k<n;k++){\n      if(v[k][i]){\n\tswap(v[i],v[k]);\n\tbreak;\n      }\n    }\n    for(Int k=0;k<n;k++)\n      if(i!=k&&v[k][i]) v[k]^=v[i];\n  }\n}\n\nint mrank(mat v,int m){\n  int n=v.size();\n  int r=0,c=0;\n  for(int i=0;i<n;i++){\n    int s=-1;\n    while(c<m){\n      for(int j=i;j<n;j++){\n\tif(v[j][c]){\n\t  s=j;\n\t  break;\n\t}\n      }\n      if(~s) break;\n      c++;\n    }\n    if(c>=m) break;\n    \n    swap(v[i],v[s]);\n    for(int j=0;j<n;j++)\n      if(i!=j&&v[j][c]) v[j]^=v[i];\n    \n    r++;c++;\n  }\n  return r;\n}\n\nmat mul(const mat &a,const mat &b){\n  int n=a.size();\n  vector<vector<int> > tmp(n,vector<int>(n,0));\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\ttmp[i][j]+=(a[i][k]&b[k][j]);\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      res[i][j]=tmp[i][j]&1;\n  \n  return res;\n}\n\nmat mat_pow(mat v,int k){\n  int n=v.size();\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    res[i][i]=1;\n  while(k){\n    if(k&1) res=mul(res,v);\n    v=mul(v,v);\n    k>>=1;\n  }\n  return res;\n}\n\n//END CUT HERE\nsigned CFR382_D(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m;\n  cin>>n>>m;\n  mat v(n,BS(0));\n  for(Int i=0;i<n;i++) v[i][n+i]=1;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++){\n    cin>>a[i]>>b[i];\n    a[i]--;b[i]--;\n    v[a[i]][b[i]]=1;\n  }\n  gauss(v);\n  for(Int i=0;i<m;i++)\n    cout<<(v[b[i]][a[i]+n]?\"NO\":\"YES\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/09\nhttp://codeforces.com/contest/736/problem/D\n*/\n\nsigned ARC054_D(){\n  int n;\n  cin>>n;\n  mat v(n,BS(0));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      char c;\n      cin>>c;\n      v[i][j]=c-'0';\n    }\n  }\n  gauss(v);\n  int ans=1;\n  for(int i=0;i<n;i++) ans&=v[i][i];\n  cout<<(ans?\"Odd\":\"Even\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/09\nhttps://beta.atcoder.jp/contests/arc054/tasks/arc054_c\n*/\n\nsigned AOJ_1308(){\n  int m,n,d;\n  while(cin>>m>>n>>d,m){\n    vector<vector<int> > s(n,vector<int>(m));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tcin>>s[i][j];\n\n    mat v(n*m,BS(0));\n    auto idx=[&](int y,int x){return y*m+x;};\n    auto in=[&](int y,int x){return 0<=y&&y<n&&0<=x&&x<m;};\n    auto bfs=[&](int y,int x){\n      int z=idx(y,x);\n      v[z][z]=1;\n      v[z][n*m]=s[y][x];\n      \n      vector<vector<int> > dp(n,vector<int>(m,-1));\n      using P = pair<int, int>;\n      queue<P> q;\n      dp[y][x]=0;\n      q.emplace(y,x);\n      int dy[]={0,0,1,-1};\n      int dx[]={1,-1,0,0};\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(dp[y][x]==d) v[z][idx(y,x)]=1;\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=dp[y][x]+1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    auto u=v;\n    gauss(v);\n    int ans=1;\n    for(int i=0;i<n*m;i++){\n      int tmp=s[i/m][i%m];\n      for(int j=0;j<n*m;j++) tmp+=u[i][j]&v[j][n*m];\n      ans&=!(tmp&1);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2018/01/09\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1308\n*/\n\nsigned AOJ_2624(){\n  int n;\n  cin>>n;\n  mat v(n,BS(0));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int k;\n      cin>>k;\n      v[i][j]=k;\n    }\n  }\n  BS w;\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    w[i]=k;\n  }\n  int t;\n  cin>>t;\n  v=mat_pow(v,t);\n\n  int a=mrank(v,n);\n  for(int i=0;i<n;i++) v[i][n]=w[i];\n  int b=mrank(v,n+1);\n\n  if(a!=b){\n    cout<<\"none\"<<endl;\n    return 0;\n  }\n\n  if(a!=n){\n    cout<<\"ambiguous\"<<endl;\n    return 0;\n  }\n  \n  gauss(v);\n  for(int i=0;i<n;i++) cout<<v[i][n]<<\" \\n\"[i==n-1];\n  \n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2624\n*/\n\n\n\nsigned main(){\n  //CFR382_D();\n  //ARC054_D();\n  AOJ_1308();\n  //AOJ_2624();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n  \nusing namespace std;\n  \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n  \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n  \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint matrix[25 * 25][25 * 25];\nint vect[25 * 25];\nbool gaussian(int W, int H){\n  int N = W * H;\n  int target = 0;\n  REP(x, N){\n    int pivot = target;\n    FOR(y, target + 1, N) if(matrix[y][x] == 1) pivot = y;\n    if(matrix[pivot][x] == 0) continue;\n    REP(i, N) swap(matrix[pivot][i], matrix[target][i]);\n    swap(vect[pivot], vect[target]);\n    FOR(y, target + 1, N) if(matrix[y][x] == 1){\n      FOR(i, x, N) matrix[y][i] ^= matrix[target][i];\n      vect[y] ^= vect[target];\n    }\n    target ++;\n  }\n  FOR(y, target, N) if(vect[y] == 1) return false;\n  return true;\n}\n  \nint main(){\n  int W, H, D;\n  while (cin>>W>>H>>D && W) {\n    memset(matrix, 0, sizeof(matrix));\n    memset(vect, 0, sizeof(vect));\n    REP(y, H)REP(x, W) cin>>vect[y * W + x];\n    REP(y1, H)REP(x1, W){\n      REP(y2, H)REP(x2, W){\n        if(abs(y1 - y2) + abs(x1 - x2) == D || (x1 == x2 && y1 == y2)){\n          matrix[y1 * W + x1][y2 * W + x2] = 1;\n        }\n      }\n    }\n    int N = W * H;\n    bool ans = gaussian(W, H);\n    if(ans) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MAX = 30*30;\nusing BS = bitset<MAX*2>;\nusing mat = vector<BS>;\n\nvoid gauss(mat &v){\n  int n=v.size();\n  for(Int i=0;i<n;i++){\n    for(Int k=i;k<n;k++){\n      if(v[k][i]){\n\tswap(v[i],v[k]);\n\tbreak;\n      }\n    }\n    for(Int k=0;k<n;k++)\n      if(i!=k&&v[k][i]) v[k]^=v[i];\n  }\n}\n\nint mrank(mat v,int m){\n  int n=v.size();\n  int r=0,c=0;\n  for(int i=0;i<n;i++){\n    int s=-1;\n    while(c<m){\n      for(int j=i;j<n;j++){\n\tif(v[j][c]){\n\t  s=j;\n\t  break;\n\t}\n      }\n      if(~s) break;\n      c++;\n    }\n    if(c>=m) break;\n    \n    swap(v[i],v[s]);\n    for(int j=0;j<n;j++)\n      if(i!=j&&v[j][c]) v[j]^=v[i];\n    \n    r++;c++;\n  }\n  return r;\n}\n\nmat mul(const mat &a,const mat &b){\n  int n=a.size();\n  vector<vector<int> > tmp(n,vector<int>(n,0));\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\ttmp[i][j]+=(a[i][k]&b[k][j]);\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      res[i][j]=tmp[i][j]&1;\n  \n  return res;\n}\n\nmat mat_pow(mat v,int k){\n  int n=v.size();\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    res[i][i]=1;\n  while(k){\n    if(k&1) res=mul(res,v);\n    v=mul(v,v);\n    k>>=1;\n  }\n  return res;\n}\n\nsigned main(){\n  int m,n,d;\n  while(cin>>m>>n>>d,m){\n    vector<vector<int> > s(n,vector<int>(m));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tcin>>s[i][j];\n\n    mat v(n*m,BS(0));\n    auto idx=[&](int y,int x){return y*m+x;};\n    auto in=[&](int y,int x){return 0<=y&&y<n&&0<=x&&x<m;};\n    auto bfs=[&](int y,int x){\n      int z=idx(y,x);\n      v[z][z]=1;\n      v[z][n*m]=s[y][x];\n      \n      vector<vector<int> > dp(n,vector<int>(m,-1));\n      using P = pair<int, int>;\n      queue<P> q;\n      dp[y][x]=0;\n      q.emplace(y,x);\n      int dy[]={0,0,1,-1};\n      int dx[]={1,-1,0,0};\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(dp[y][x]==d) v[z][idx(y,x)]=1;\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=dp[y][x]+1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    int a=mrank(v,n*m);\n    int b=mrank(v,n*m+1);\n    cout<<(a==b)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconst int mod = 2;\nconst int eps = 0;\n\nstruct Mod {\n  int n;\n  Mod () : n(0) {;}\n  Mod (int m) : n(m) {\n    if (n >= mod) n %= mod;\n    else if (n < 0) n = (n % mod + mod) % mod;\n  }\n  Mod& operator=(const Mod&) = default;\n  operator int() { return n; }\n};\n\nbool operator==(Mod a, Mod b) { return a.n == b.n; }\nMod operator+=(Mod &a, Mod b) { a.n += b.n; if (a.n >= mod) a.n -= mod; return a; }\nMod operator-=(Mod &a, Mod b) { a.n -= b.n; if (a.n < 0) a.n += mod; return a; }\nMod operator*=(Mod &a, Mod b) { a.n = ((long long)a.n * b.n) % mod; return a; }\nMod operator+(Mod a, Mod b) { return a += b; }\nMod operator-(Mod a, Mod b) { return a -= b; }\nMod operator*(Mod a, Mod b) { return a *= b; }\nMod operator^(Mod a, int n) {\n  if (n == 0) return Mod(1);\n  Mod res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\n\nusing ll = int64_t;\nll inv(ll a, ll p) {\n  return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nMod operator/(Mod a, Mod b) { return a * Mod(inv(b, mod)); }\nMod operator/=(Mod &a, Mod b) { a.n = ((long long)a.n / b.n); return a; }\ntypedef Mod Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return dat == Mod(0); }\n\ntuple<Matrix, int> solve(Matrix A) {\n  const int n = A.size(), m = A[0].size();\n  int r = 0;\n  for (int i = 0; r < n && i < m; ++i) {\n    int pivot = r;\n    for (int j = r; j < n; ++j) {\n      if (A[j][i]) {\n        pivot = j;\n        break;\n      }\n    }\n    swap(A[pivot], A[r]);\n    if (is_zero(A[r][i])) continue;\n    for(int j = r+1; j < n; ++j)\n      for(int k = m-1; k >= i; --k)\n        A[j][k] -= A[r][k] * A[j][i];\n    ++r;\n  }\n  return make_pair(A, r);\n}\n\nint main() {\n  while(1) {\n    int n,m,d;\n    cin>>n>>m>>d;\n    if (!n) break;\n    vector<Mod> tb(n*m);\n    REP(i,n)REP(j,m) {\n      int v;\n      cin>>v;\n      tb[i*m+j] = v;\n    }\n    int dim = n*m;\n    Matrix mat(dim, Array(dim+1));\n    REP(i,n)REP(j,m) {\n      REP(k,n)REP(l,m) {\n        if (abs(k-i)+abs(l-j) == d) {\n          mat[i*m+j][k*m+l] = 1;\n        }\n      }\n      mat[i*m+j][i*m+j] = 1;\n      mat[i*m+j][dim] = tb[i*m+j];\n    }\n    Matrix res;\n    int rank;\n    tie(res, rank) = solve(mat);\n    bool ok = false;\n    REP(i,dim) if (res[rank-1][i]) ok = true;\n    if (ok) {\n      cout << 1 << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#define eps 1e-9\n\nusing namespace std;\n\nint m, n, d, N;\nint mat[650][650];\n\nvoid swapRow(int x, int y)\n{\n\tint t;\n\tfor(int i = 0; i < N+1; i++){\n\t\tt = mat[x][i];\n\t\tmat[x][i] = mat[y][i];\n\t\tmat[y][i] = t;\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> m >> n >> d;\n\t\tif(m == 0 && n == 0 & d == 0) break;\n\t\t\n\t\tN = m*n;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tmat[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tfor(int ii = 0; ii < n; ii++){\n\t\t\t\t\tfor(int jj = 0; jj < n; jj++){\n\t\t\t\t\t\tif( abs(i - ii) + abs(j - jj) == d){\n\t\t\t\t\t\t\tmat[i*m+j][ii*m+jj] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(i == ii && j == jj) mat[i*m+j][ii*m+jj] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint s;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> s;\n\t\t\tmat[i][N] = s;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tint piv, val = 0;\n\t\t\tfor(int j = i; j < N; j++){\n\t\t\t\tif(val < mat[j][i]){\n\t\t\t\t\tval = mat[j][i];\n\t\t\t\t\tpiv = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(val == 0) continue;\n\t\t\tswapRow(i, piv);\n\t\t\t\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(mat[j][i] == 0) continue;\n\t\t\t\tfor(int k = 0; k < N+1; k++){\n\t\t\t\t\tmat[j][k] += mat[i][k];\n\t\t\t\t\tmat[j][k] %= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tbool ans = true;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(mat[i][i] == 0 && mat[i][N] == 1){\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <bitset>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint n, m, D;\nint a[30][30];\nbitset <650> G[650];\n\ninline int id(int x, int y) {\n    return x * m + y;\n}\n\nbool Gauss(int equ, int var) {\n    int col = 0, k;\n    for(k = 0; k < equ && col < var; ++k, ++col) {\n        if(!G[k][col]) {\n            for(int i = k + 1; i < equ; ++i) if(G[i][col]) {\n                G[k] ^= G[i];\n                break;\n            }\n        }\n        if(!G[k][col]) {\n            k--;\n            continue;\n        }\n        for(int i = k + 1; i < equ; ++i) \n\t\t\tif(G[i][col]) \n\t\t\t\tG[i] ^= G[k];\n    }\n    for(int i = k; i < equ; ++i) \n\t\tif(G[i][var]) \n\t\t\treturn 0;\n    return 1;\n}\n\nint main() {\n    while(scanf(\"%d%d%d\", &m, &n, &D)) {\n        if(n == 0) break;\n        for(int i = 0; i < n; ++i) \n\t\t\tfor(int j = 0; j < m; ++j) \n\t\t\t\tscanf(\"%d\", &a[i][j]);\n        int U = n * m;\n        for(int i = 0; i < U; ++i) G[i].reset();\n        for(int i = 0; i < n; ++i) \n\t\t\tfor(int j = 0; j < m; ++j) {\n\t            int u = id(i, j);\n\t            G[u][u] = 1;\n\t            for(int x = 0; x < n; ++x) \n\t\t\t\t\tfor(int y = 0; y < m; ++y) {\n\t\t                if(abs(x - i) + abs(y - j) != D) continue;\n\t\t                G[id(x, y)][u] = 1;\n\t\t            }\n        }\n        for(int i = 0; i < n; ++i) \n\t\t\tfor(int j = 0; j < m; ++j) {\n            if(!a[i][j]) continue;\n            G[id(i, j)][n * m] = 1;\n        }\n        puts(Gauss(n * m, n * m) ? \"1\" : \"0\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct mod\n{\n  int m;\n  mod(int a) : m(a) {}\n  int operator()(int x) const { return ((x%m)+m)%m; }\n};\n\n\nvector<int> gaussian_elimination(vector<vector<int> > a, vector<int> b)\n{\n  static mod M(2);\n  const int N = a.size();\n\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; a[i][i] == 0 && j < N; j++) {\n      swap(a[i], a[j]);\n      swap(b[i], b[j]);\n    }\n    if (a[i][i] == 0) {\n      continue;\n    }\n\n    for (int j = 0; j < N; j++) {\n      if (i == j) {\n        continue;\n      }\n      const int u = a[j][i];\n      for (int k = i; k < N; k++) {\n        a[j][k] = M(a[j][k] - u*a[i][k]);\n      }\n      b[j] = M(b[j] - u*b[i]);\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (a[i][i] == 0 && b[i] != 0) {\n      // no solution\n      return vector<int>();\n    }\n  }\n  return b;\n}\n\nint main()\n{\n  int M, N, D;\n  while (cin >> M >> N >> D && M != 0) {\n    vector<vector<int> > a(M*N, vector<int>(M*N, 0));\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        a[M*i+j][M*i+j] = 1;\n        for (int k = 0; k < N; k++) {\n          for (int l = 0; l < M; l++) {\n            if (abs(i-k)+abs(j-l) == D) {\n              a[M*i+j][M*k+l] = 1;\n            }\n          }\n        }\n      }\n    }\n\n    vector<int> b(N*M);\n    for (int i = 0; i < N*M; i++) {\n      cin >> b[i];\n    }\n\n    const vector<int> x = gaussian_elimination(a, b);\n    cout << !x.empty() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[]={-1,0,1,0},dx[]={0,-1,0,1},dy2[]={1,-1,-1,1},dx2[]={1,1,-1,-1};\nint m,n,d,s[25][25];\nint main()\n{\n\twhile(cin>>m>>n>>d,m){\n\t\tint N=m*n;\n\t\tvector<vi> a(N,vi(N+1,0));\n\t\trep(i,m)rep(j,n)cin>>s[i][j], a[i*n+j][N]=s[i][j];\n\t\t\n\t\t//rep(i,N)rep(j,N+1)cerr<<a[i][j]<<(j==N?\"\\n\":\" \");\n\t\t\n\t\trep(i,N)(a[i][i]+=1)%=2;\n\t\trep(i,m)rep(j,n)rep(dir,4)rep(k,d){\n\t\t\tint y=i+dy[dir]*d+dy2[dir]*k, x=j+dx[dir]*d+dx2[dir]*k;\n\t\t\tif(0<=y&&y<m&&0<=x&&x<n){\n\t\t\t\t(a[y*n+x][i*n+j]+=1)%=2;\n\t\t\t}\n\t\t}\n\t\t//rep(i,N)rep(j,N+1)cerr<<a[i][j]<<(j==N?\"\\n\":\" \");\n\t\t\n\t\trep(i,N){\n\t\t\tsort(a.begin()+i,a.end(),greater<vi>());\n\t\t\tif(a[i][i]){\n\t\t\t\trep(j,N)if(i!=j&&a[j][i])rep(k,N+1)(a[j][k]+=a[i][k])%=2;\n\t\t\t}\n\t\t}\n\t\t//rep(i,N)rep(j,N+1)cerr<<a[i][j]<<(j==N?\"\\n\":\" \");\n\t\t\n\t\tbool ok=1;\n\t\trep(i,N)if(ok&&a[i][N]){\n\t\t\tbool exist=0;\n\t\t\trep(j,N)if(a[i][j])exist=1;\n\t\t\tif(!exist)ok=0;\n\t\t}\n\t\tcout<<(int)ok<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int M, N, D;\n  bool matrix[625][626];\n\n  while(cin >> M >> N >> D, M) {\n    for(int i = 0; i < N * M; i++) {\n      cin >> matrix[i][N * M];\n    }\n\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < M; j++) {\n        for(int k = 0; k < N; k++) {\n          for(int l = 0; l < M; l++) {\n            matrix[i * M + j][k * M + l] = abs(i - k) + abs(j - l) == D;\n          }\n        }\n        matrix[i * M + j][i * M + j] = 1;\n      }\n    }\n\n    for(int i = 0; i < N * M; i++) {\n      int pos = -1;\n      for(int j = i; j < N * M; j++) {\n        if(matrix[j][i]) pos = j;\n      }\n      if(pos == -1) continue;\n      swap(matrix[pos], matrix[i]);\n      for(int j = 0; j < M * N; j++) {\n        if(i == j) continue;\n        if(matrix[j][i] == 1) {\n          for(int k = 0; k <= M * N; k++) {\n            matrix[j][k] ^= matrix[i][k];\n          }\n        }\n      }\n    }\n    bool flag = true;\n    for(int i = 0; i < M * N; i++) {\n      if(matrix[i][M * N] && !matrix[i][i]) flag = false;\n    }\n    cout << flag << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\nvoid print_matrix(const vector<vector<int> > &v) {\n    for(int r = 0; r < v.size(); ++r) {\n        for(int c = 0; c < v[r].size(); ++c) {\n            cout << v[r][c] << ' ';\n        }\n        cout << endl;\n    }\n}\n\nvector<vector<int> > mult_matrix(const vector<vector<int> > &a, const vector<vector<int> > &b) {\n    int R = a.size();\n    int C = b[0].size();\n    int K = a[0].size();\n    vector<vector<int> > res(R, vector<int>(C, 0));\n    for(int i = 0; i < R; ++i) {\n        for(int j = 0; j < C; ++j) {\n            for(int k = 0; k < K; ++k) res[i][j] ^= a[i][k]&b[k][j];\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    while(true) {\n        int M, N, D;\n        cin >> M >> N >> D;\n        if(!M && !N && !D) break;\n\n        vector<vector<int> > v(N, vector<int>(M));\n        for(int r = 0; r < N; ++r) \n            for(int c = 0; c < M; ++c)\n                cin >> v[r][c];\n\n        vector<vector<int> > mat(M*N, vector<int>(M*N, 0));\n        for(int r = 0; r < N; ++r) {\n            for(int c = 0; c < M; ++c) {\n                const int a = r*M + c;\n                mat[a][a] = 1;\n                for(int dr = -D; dr <= D; ++dr) {\n                    if(r+dr < 0 || N <= r+dr) continue;\n                    int dc = D - abs(dr);\n                    if(c+dc < M) {\n                        const int b = (r+dr)*M + (c+dc);\n                        mat[b][a] = 1;\n                    }\n                    if(dc > 0 && c-dc >= 0) {\n                        const int b = (r+dr)*M + (c-dc);\n                        mat[b][a] = 1;\n                    }\n                }\n            }\n        }\n        vector<vector<int> > mat_org = mat;\n        vector<vector<int> > inv(M*N, vector<int>(M*N, 0));\n        for(int i = 0; i < inv.size(); ++i) inv[i][i] = 1;\n        for(int r = 0; r < M*N; ++r) {\n            if(mat[r][r] == 0) {\n                //Find pivot\n                for(int nr = r+1; nr < M*N; ++nr) {\n                    if(mat[nr][r] == 1) {\n                        swap(mat[nr], mat[r]);\n                        swap(inv[nr], inv[r]);\n                        break;\n                    }\n                }\n            }\n            /*\n            if(mat[r][r] == 0) {\n                for(int nc = r+1; nc < M*N; ++nc) {\n                    if(mat[r][nc] == 1) {\n                        for(int nr = 0; nr < M*N; ++nr) {\n                            swap(mat[nr][r], mat[nr][nc]);\n                            swap(inv[nr][r], mat[nr][nc]);\n                        }\n                        break;\n                    }\n                }\n            }\n            */\n            for(int nr = 0; nr < M*N; ++nr) {\n                if(nr == r) continue;\n                if(mat[nr][r] == 1) {\n                    for(int c = 0; c < M*N; ++c) {\n                        mat[nr][c] ^= mat[r][c];\n                        inv[nr][c] ^= inv[r][c];\n                    }\n                }\n            }\n        }\n\n        //print_matrix(mat);\n        bool ok = true;\n        for(int r = 0; r < M*N; ++r) {\n            bool all0 = true;\n            for(int c = 0; c < M*N; ++c) {\n                if(mat[r][c] == 1) {\n                    all0 = false;\n                    break;\n                }\n            }\n            if(all0) {\n                int cnt = 0;\n                for(int c = 0; c < M*N; ++c) {\n                    if(inv[r][c]) {\n                        cnt ^= v[c/M][c%M];\n                    }\n                }\n                if(cnt != 0) {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n\n        cout << (ok?1:0) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define IDX(i, j) ((i)*m+(j))\n\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nint n;\nint m;\nint d;\nint S[114][514];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d%d\", &n, &m, &d);\n    if ((n|m|d) == 0) return 0;\n\n    for (int i=0; i<n; i++) {\n      for (int j=0; j<m; j++) {\n        scanf(\"%d\", &S[i][j]);\n      }\n    }\n\n    int sz = n*m;\n    Mat aug(sz, Vec(sz+1, 0));\n    for (int i=0; i<n; i++) {\n      for (int j=0; j<m; j++) {\n        int idx = IDX(i, j);\n        aug[idx][idx] = 1;\n        aug[idx][sz] = S[i][j];\n        for (int k=0; k<n; k++) {\n          for (int l=0; l<m; l++) {\n            if (abs(k-i)+abs(l-j) == d) aug[idx][IDX(k, l)] = 1;\n          }\n        }\n      }\n    }\n\n    int lim = 0;\n    for (int idx=0; idx<sz+1; idx++) {\n      int chosen = -1;\n      for (int i=lim; i<sz; i++) {\n        if (aug[i][idx]) {\n          chosen = i;\n          break;\n        }\n      }\n\n      if (chosen == -1) continue;\n\n      swap(aug[chosen], aug[lim]);\n      for (int i=0; i<sz; i++) {\n        if (i == lim) continue;\n        if (!aug[i][idx]) continue;\n        for (int j=idx; j<=sz; j++) {\n          aug[i][j] = (2+aug[i][j]-aug[lim][j])%2;\n        }\n      }\n\n      lim++;\n    }\n\n    bool fail = false;\n    for (int i=0; i<sz; i++) {\n      bool pos = true;\n      for (int j=0; j<sz; j++) {\n        if (aug[i][j]) {\n          pos = false;\n          break;\n        }\n      }\n\n      if (aug[i][sz] == 0) continue;\n      if (pos) {\n        fail = true;\n        break;\n      }\n    }\n\n    if (fail) puts(\"0\");\n    else puts(\"1\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int64_t ll;\nll inverse(ll a, ll m) {\n\tll b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\tswap(a -= t * b, b);\n\t\tswap(u -= t * v, v);\n\t}\n\treturn (u % m + m) % m;\n}\n#define REP(i, n) for(auto i = 0 * (n); i < (n); ++i)\n#define FOR(i, s, n) for(size_t i = (s); i < (n); ++i)\n\ntypedef vector<ll> Vector;\ntypedef vector<Vector> Matrix;\nstruct GaussJordan {\n\ttypedef size_t T;\n\tGaussJordan(Matrix mat, T m) : x(move(mat)) {\n\t\tT row = x.size(), col = x[0].size(), r = 0;\n\t\tREP(c, col) {\n\t\t\tT p = r;\n\t\t\tFOR(i, r, row) if (abs(x[i][c]) > abs(x[p][c])) p = i;\n\t\t\tswap(x[r], x[p]);\n\t\t\tif (x[r][c]) {\n\t\t\t\tif (c == col - 1) impossible = 1; // ??????????????????????????????????????????\n\t\t\t\tdet = det * x[r][c] % m; // ??????????????????????????????????????????\n\t\t\t\tFOR(j, c + 1, col) (x[r][j] *= inverse(x[r][c], m)) %= m;\n\t\t\t\tx[r][c] = 1;\n\t\t\t\tREP(i, row) if (r != i) {\n\t\t\t\t\tFOR(j, c + 1, col) x[i][j] = (x[i][j] - x[i][c] * x[r][j] % m + m) % m;\n\t\t\t\t\tx[i][c] = 0;\n\t\t\t\t}\n                if (++r == row) break;\n\t\t\t}\n\t\t}\n        rank = r;\n\t}\n\tMatrix x;\n\tT rank;\n\tll det = 1;  // mat ?????£??????????????? full rank ?????¨???????????????\n\tbool impossible = 0; // ?????¢????¬?????¨????????§£??????????????´???????????????????§£????????? <-> true\n};\n\nGaussJordan linear_equations(Matrix A, const Vector & b, size_t m) {\n\tREP(i, A.size()) A[i].push_back(b[i]);\n    return GaussJordan(A, m);\n}\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint m, n, d;\n\twhile (cin >> m >> n >> d, m || n || d) {\n\t\tvector<vector<bool>> ba(n, vector<bool>(m));\n\t\tMatrix A(n * m, Vector(n * m));\n\t\tVector b(n * m);\n\t\tREP(i, n) {\n\t\t\tREP(j, m) {\n\t\t\t\t{\n\t\t\t\t\tbool bb; cin >> bb;\n\t\t\t\t\tba[i][j] = bb;\n\t\t\t\t}\n\t\t\t\tA[i * m + j][i * m + j] = 1;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tREP(l, m) {\n\t\t\t\t\t\tint dis = abs(i - k) + abs(j - l);\n\t\t\t\t\t\tif (dis == d) {\n\t\t\t\t\t\t\tA[k * m + l][i * m + j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i * m + j] = ba[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << (linear_equations(A, b, 2).impossible ? 0 : 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 625+2;\nconst int mod = 2;\nint mat[N][N];\n//if mod is prime\nint mypow(int n,int p){\n  if (p == 0)return 1;\n  int tmp=mypow(n,p/2);\n  tmp=(tmp*tmp)%mod;\n  if (tmp%2==1)tmp=(tmp*n)%mod;\n  return tmp%mod;\n}\n\ninline int inverse(int now){\n  if (now == 0)return -1;// now answer\n  return 1;\n  return mypow(now,mod-2);\n}\n\n//if mod is not prime\n//extended euqlid?\n\n//partial pivot\nbool select_pivot(int r,int c,int k,int mat[N][N]){\n  int s=k;\n  int val=abs(mat[k][k]);\n  REP(i,k+1,r){\n    if (abs(mat[i][k])>val)val=abs(mat[i][k]),s=i;\n  }\n  if (val ==0)return false;\n  REP(i,k,c+1)swap(mat[k][i],mat[s][i]);\n  return true;\n}\n \nbool select_pivot(int r,int c,int k,int mat[N][N],int num[N]){\n int s=k,t=k;//selected pivot\n int val=fabs(mat[k][k]);\n REP(i,k+1,r){\n   if (val == 1)break;\n   REP(j,k+1,c){\n     if (val == 1)break;\n     if (fabs(mat[i][j]) >val){\n       val=fabs(mat[i][j]);\n       s=i;\n       t=j;\n     }\n   }\n }\n \n if ( val<1)return false;//cannot solve this linear equations.\n \n rep(i,r)swap(mat[i][k],mat[i][t]);\n \n swap(num[k],num[t]);\n \n REP(i,k,c+1){\n   swap(mat[k][i],mat[s][i]);\n }\n return true;//no problem for this pivot;\n}\n\nbool gauss(int r,int c,int mat[N][N],int num[N]){\n  rep(k,c){\n    if (!select_pivot(r,c,k,mat,num)){\n      //if (!select_pivot(r,c,k,mat)){\n      REP(i,k,r)if (mat[i][c] == 1)return false;\n      return true;\n    }\n    assert(inverse(mat[k][k]) != -1);\n    int inv=inverse(mat[k][k]);\n    REP(i,k+1,c+1)mat[k][i]=(mat[k][i]*inv)%mod;\n    mat[k][k]=1;\n    REP(i,k+1,r){\n      REP(j,k+1,c+1)mat[i][j]=(mat[i][j]+(-mat[i][k]*mat[k][j]+mod))%mod;\n      mat[i][k]=0;\n    }\n  }\n  return true;\n  for(int i=r-1;i>=0;i--){\n    REP(j,i+1,c){\n      mat[i][c]=(mat[i][c]-(mat[i][j]*mat[j][c])+mod)%mod;\n    }\n  }\n  return true;\n}\n\n#define GETPOS(c,i,j) ((i)*(c)+(j))\n\nmain(){\n  int r,c,d;\n  int num[N];\n  while(cin>>c>>r>>d && r){\n    int n=r*c;\n    rep(i,n)rep(j,n+1)mat[i][j]=0;\n    rep(i,n)num[i]=i;\n    rep(i,r)rep(j,c){\n      int tmp;cin>>tmp;\n      mat[GETPOS(c,i,j)][n]=1-tmp;\n    }\n    rep(i,r){\n      rep(j,c){\n\tmat[GETPOS(c,i,j)][GETPOS(c,i,j)]=1;\n\trep(ii,r){\n\t  rep(jj,c){\n\t    if (abs(ii-i)+abs(jj-j) == d){\n\t      mat[GETPOS(c,i,j)][GETPOS(c,ii,jj)]=1;\n\t      //cout << \"(\" <<i<<\",\"<<j<<\"),(\"\n\t      //<< ii<<\",\"<<jj<<\")\"<<endl;\n\t      //cout << GETPOS(c,i,j)+1 <<\" \" << GETPOS(c,ii,jj)+1 << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    /*    rep(i,n){\n      rep(j,n+1)cout << mat[i][j] <<\" \";\n      cout << endl;\n    }      \n    */\n\n    cout << gauss(n,n,mat,num) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n   \nusing namespace std;\n   \n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n\nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = ten(9) + 7;\n\n\nbool gauss(const vector<vector<int> >& _a, const vector<int>& b)\n{\n    const int n = _a.size();\n    vector<vector<int> > a(n, vector<int>(n + 1));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            a[i][j] = _a[i][j];\n    for (int i = 0; i < n; ++i)\n        a[i][n] = b[i];\n\n    for (int i = 0; i < n; ++i)\n    {\n        int pivot = -1;\n        for (int j = i; j < n; ++j)\n        {\n            if (a[j][i] != 0)\n            {\n                pivot = j;\n                break;\n            }\n        }\n        if (pivot == -1)\n            continue;\n\n        swap(a[i], a[pivot]);\n\n        for (int j = 0; j < n; ++j)\n        {\n            if (i != j && a[j][i] != 0)\n            {\n                for (int k = i; k <= n; ++k)\n                    a[j][k] = (a[j][k] + a[i][k]) % 2;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i)\n    {\n        if (a[i][i] == 0 && a[i][n] == 1)\n            return false;\n    }\n    return true;\n}\nint main()\n{\n    fast_io();\n\n    int w, h, d;\n    while (cin >> w >> h >> d, w)\n    {\n        int s[33][33];\n        rep(i, h) rep(j, w)\n            cin >> s[i][j];\n\n        const int n = w * h;\n        vector<vector<int> > a(n, vector<int>(n));\n        vector<int> b(n);\n        rep(i, h) rep(j, w)\n        {\n            int k = i * w + j;\n            b[k] = s[i][j];\n\n            rep(p, h) rep(q, w)\n            {\n                int r = p * w + q;\n                int dis = abs(i - p) + abs(j - q);\n                if (dis == 0 || dis == d)\n                    a[k][r] = 1;\n            }\n        }\n\n        cout << (gauss(a, b) ? 1 : 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconst int mod = 2;\nconst int eps = 0;\n\nstruct Mod {\n  int n;\n  Mod () : n(0) {;}\n  Mod (int m) : n(m) {\n    if (n >= mod) n %= mod;\n    else if (n < 0) n = (n % mod + mod) % mod;\n  }\n  Mod& operator=(const Mod&) = default;\n  operator int() { return n; }\n};\n\nbool operator==(Mod a, Mod b) { return a.n == b.n; }\nMod operator+=(Mod &a, Mod b) { a.n += b.n; if (a.n >= mod) a.n -= mod; return a; }\nMod operator-=(Mod &a, Mod b) { a.n -= b.n; if (a.n < 0) a.n += mod; return a; }\nMod operator*=(Mod &a, Mod b) { a.n = ((long long)a.n * b.n) % mod; return a; }\nMod operator+(Mod a, Mod b) { return a += b; }\nMod operator-(Mod a, Mod b) { return a -= b; }\nMod operator*(Mod a, Mod b) { return a *= b; }\nMod operator^(Mod a, int n) {\n  if (n == 0) return Mod(1);\n  Mod res = (a * a) ^ (n / 2);\n  if (n % 2) res = res * a;\n  return res;\n}\n\nusing ll = int64_t;\nll inv(ll a, ll p) {\n  return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nMod operator/(Mod a, Mod b) { return a * Mod(inv(b, mod)); }\nMod operator/=(Mod &a, Mod b) { a.n = ((long long)a.n / b.n); return a; }\ntypedef Mod Data;\ntypedef vector<Data> Array;\ntypedef vector<Array> Matrix;\n\nbool is_zero(Data dat) { return dat == Mod(0); }\n\ntuple<Matrix, int> solve(Matrix A) {\n  const int n = A.size(), m = A[0].size();\n  int r = 0;\n  for (int i = 0; r < n && i < m; ++i) {\n    int pivot = r;\n    for (int j = r; j < n; ++j) {\n      if (A[j][i]) {\n        pivot = j;\n        break;\n      }\n    }\n    swap(A[pivot], A[r]);\n    if (is_zero(A[r][i])) continue;\n    for(int j = r+1; j < n; ++j)\n      for(int k = m-1; k >= i; --k)\n        A[j][k] -= A[r][k] * A[j][i];\n    ++r;\n  }\n  return make_pair(A, r);\n}\n\nint main() {\n  while(1) {\n    int n,m,d;\n    cin>>m>>n>>d;\n    if (!n) break;\n    vector<Mod> tb(n*m);\n    REP(i,n)REP(j,m) {\n      int v;\n      cin>>v;\n      tb[i*m+j] = v;\n    }\n    int dim = n*m;\n    Matrix mat(dim, Array(dim+1));\n    REP(i,n)REP(j,m) {\n      REP(k,n)REP(l,m) {\n        if (abs(k-i)+abs(l-j) == d) {\n          mat[i*m+j][k*m+l] = 1;\n        }\n      }\n      mat[i*m+j][i*m+j] = 1;\n      mat[i*m+j][dim] = tb[i*m+j];\n    }\n    Matrix res;\n    int rank;\n    tie(res, rank) = solve(mat);\n    bool ok = false;\n    REP(i,dim) if (res[rank-1][i]) ok = true;\n    if (ok) {\n      cout << 1 << endl;\n    } else {\n      cout << 0 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <complex>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\ntypedef complex<double> Point;\nconst static double EPS = 1e-12;\n\nvector<P> edges[25][25][25*25];\nint A[25*25][25*25];\nint B[25*25];\n\nint main(){\n  for(int sy = 0; sy < 25; sy++){\n    for(int sx = 0; sx < 25; sx++){\n      for(int dy = 0; dy < 25; dy++){\n        for(int dx = 0; dx < 25; dx++){\n          edges[sy][sx][abs(dy-sy) + abs(dx-sx)].push_back(P(dx,dy));\n        }\n      }\n    }\n  }\n\n  int cols;\n  int rows;\n  int proper_distance;\n  while(~scanf(\"%d %d %d\",&cols,&rows,&proper_distance)){\n    if(cols == 0 && rows == 0 && proper_distance == 0) break;\n\n    memset(A,0,sizeof(A));\n    memset(B,0,sizeof(B));\n\n    for(int y = 0; y < rows; y++){\n      for(int x = 0; x < cols; x++){\n        int status;\n        scanf(\"%d\",&status);\n        B[y * cols + x] = status;\n      }\n    }\n\n    for(int sy = 0; sy < rows; sy++){\n      for(int sx = 0; sx < cols; sx++){\n        A[sy * cols + sx][sy * cols + sx] = 1;\n        for(int i = 0; i < edges[sy][sx][proper_distance].size(); i++){\n          int dx = edges[sy][sx][proper_distance][i].first;\n          int dy = edges[sy][sx][proper_distance][i].second;\n          if(dx < 0 || dx >= cols || dy < 0 || dy >= rows) continue;\n          A[sy * cols + sx][dy * cols + dx] = 1;\n        }\n      }\n    }\n\n    for(int round = 0; round < rows * cols; round++){\n\n      int pivot = round;\n      bool has_pivot= false;\n      for(int row = round; row < rows * cols; row++){\n        if(A[row][round] == 1){\n          has_pivot = true;\n          pivot = row;\n          break;\n        }\n      }\n      if(!has_pivot) continue;\n\n      swap(A[pivot],A[round]);\n      swap(B[pivot],B[round]);\n      for(int row = 0; row < rows * cols; row++){\n        if(round == row) continue;\n        if(A[row][round] == 0) continue;\n\n        B[row] ^= B[round];\n        for(int col = round; col < rows * cols; col++){\n          A[row][col] ^= A[round][col];\n        }\n      }\n    }\n\n    bool isok = true;\n\n    for(int pos = 0; pos < cols * rows; pos++){\n      if(A[pos][pos] == 0 && B[pos] == 1){\n              isok = false;\n              break;\n      }\n    }\n    printf(\"%d\\n\",isok ? 1 : 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// aribon3-2-3_4_f Awkward Lights\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"../cxx-prettyprint/prettyprint.hpp\"\n#endif\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define REP(i, n) for (int (i) = 0 ; (i) < (int)(n) ; ++(i))\n#define REPN(i, m, n) for (int (i) = m ; (i) < (int)(n) ; ++(i))\n#define REP_REV(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define REPN_REV(i, m, n) for (int (i) = (int)(n) - 1 ; (i) >= m ; --(i))\n#define ALL(x) x.begin(), x.end()\n\n#define INF ((1 << 29)-1)\n#define MOD (1000000007)\n\n#define print2D(h, w, arr) REP(i, h) { REP(j, w) cout << arr[i][j] << \" \"; cout << endl; }\ntemplate<class T> void print(const T& x){cout << x << endl;}\ntemplate<class T, class... A> void print(const T& first, const A&... rest) { cout << first << \" \"; print(rest...); }\nstruct PreMain {PreMain(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(20);}} premain;\n\nint mod_pow(ll a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\ntemplate <int mod>\nstruct mint {\n    ll x;\n    mint(ll x=0):x(x%mod){}\n    mint(const mint& m):x(m.x){}\n    mint& operator+=(const mint a) { if ((x += a.x) >= mod) x -= mod; return *this; }\n    mint& operator-=(const mint a) { if ((x += mod-a.x) >= mod) x -= mod; return *this; }\n    mint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }\n    mint operator+(const mint a) const { mint res(*this); return res+=a; }\n    mint operator-(const mint a) const { mint res(*this); return res-=a; }\n    mint operator*(const mint a) const { mint res(*this); return res*=a; }\n    bool operator==(const mint a) const { return x == a.x;}\n    bool operator==(const ll a) const { return x == a;}\n    bool operator==(const int a) const { return x == a;}\n    bool operator!=(const mint a) const { return x != a.x;}\n    bool operator!=(const ll a) const { return x != a;}\n    bool operator!=(const int a) const { return x != a;}\n    operator bool() const {return x>0;}\n\n    mint pow(ll t) const {mint r=1,a=*this; do{if(t&1)r*=a;a*=a;}while(t>>=1);return r;}\n    mint inv() const { return pow(mod-2); }\n    mint& operator/=(const mint a) { return (*this) *= a.inv(); }\n    mint operator/(const mint a) const { mint res(*this); return res/=a; }\n};\ntemplate <int mod> ostream& operator<<(ostream& os, const mint<mod>& m) {cout << m.x; return os;}\n\nint M, N, D;\nvector<vector<int>> S;\n\n// m行n列\ntemplate <typename T> struct Mat {\n    int m, n;\n    vector<vector<T>> val;\n    Mat(int m, int n, T x=0) : m(m),n(n),val(m, vector<T>(n, x)) {};\n    void assign(initializer_list<vector<T>> X){ val.assign(X); }\n    inline vector<T>& operator [] (int i) {return val[i];}\n\n    Mat<T> operator*(Mat<T> B) const{\n        assert(n == B.m);\n        Mat<T> R(m, B.n);\n        REP(i, m) REP(j, B.n) REP(k, n) { R[i][j] += val[i][k] * B[k][j]; }\n        return R;\n    }\n    Mat<T>& operator*=(Mat<T> B) { return *this=*this*B; }\n\n    Mat<T> pow(int t) const {\n        assert(m == n);\n        Mat<T> A(*this);\n        Mat<T> R(m, m);\n        REP(i, m) R[i][i] = 1;\n        while(t > 0) {\n            if (t & 1) R *= A;\n            A *= A;\n            t >>= 1;\n        }\n        return R;\n    }\n\n    vector<T> dot(vector<T> x) const {\n        assert(n == x.size());\n        vector<T> y(m, 0);\n        REP(i, m) REP(j, n) y[i] += val[i][j] * x[j];\n        return y;\n    }\n};\ntemplate <typename T> ostream& operator<<(ostream& os, const Mat<T>& mat) {cout << mat.val; return os;}\n\n\n\n// is_extended: Aが拡大係数だったとき、最終列は掃き出さない\ntemplate <typename T>\nint gauss_jordan(Mat<T>& A, bool is_extended=true){\n\n    int rank = 0;\n    REP(col, A.n){\n        if (is_extended && col == A.n-1) break;\n\n        // 非ゼロをさがす\n        int pivot = -1;\n        REPN(row, rank, A.m) {\n            if (A[row][col] != 0) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n\n        // 対象行を1にする\n        swap(A[pivot], A[rank]);\n        REP(c, A.n) A[rank][c] /= A[rank][col];\n\n        // 対象行以外を0にする\n        REP(row, A.m) if (row != rank && A[row][col]){\n            auto coeff = A[row][col];\n            REP(c, A.n) A[row][c] -= coeff * A[rank][c];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\ntemplate <typename T>\nint linear_equation(Mat<T> A, vector<T> b, vector<T> &res) {\n\n    // 拡大係数行列\n    Mat<T> M(A.m, A.n + 1);\n    REP(i, A.m) {\n        REP(j, A.n) M[i][j] = A[i][j];\n        M[i][A.n] = b[i];\n    }\n\n    // ジョルダン変形\n    int rank = gauss_jordan(M);\n\n    // ランクを超えた部分に非ゼロがあるとアウト\n    REPN(row, rank, A.n) {\n        if (M[row][A.n]) return -1;\n    }\n\n    // answer\n    res.assign(A.n, 0);\n    REP(i, A.n) res[i] = M[i][A.n];\n    return rank;\n}\n\n\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"../arg.txt\"); cin.rdbuf(in.rdbuf());\n#endif\n\n    while (true){\n        cin >> M >> N >> D;\n        if (M == 0 && N == 0 && D == 0) break;\n\n        S.assign(N, vector<int>(M, 0));\n        REP(i, N) REP(j, M) cin >> S[i][j];\n\n        Mat<mint<2>> A(N*M, N*M);\n        vector<mint<2>> b(N*M);\n\n        REP(i, N) REP(j, M){\n            REP(i2, N) REP(j2, M){\n                int d = abs(i - i2) + abs(j - j2);\n                if (d == D || (i==i2 && j==j2)){\n                    A[i2*M+j2][i*M+j] = 1;\n                }\n            }\n            b[i*M+j] = S[i][j];\n        }\n\n        vector<mint<2>> res;\n        int rank = linear_equation(A, b, res);\n        print(rank != -1);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n\nll modNorm(ll a, ll m) {\n  return (a%m+m)%m;\n}\n\n// ax+by=gcd(a,b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll invMod(ll a, ll p) {\n  ll x, y;\n  if (extgcd(a,p,x,y) == 1) return (x+p)%p;\n  return 0;\n}\n\ntypedef vector<bool> vec;\ntypedef vector<vec> mat;\n\nostream &operator<<(ostream &os, const vec &a) {\n  FOR(it, a) os << *it << \" \";\n  return os;\n}\nostream &operator<<(ostream &os, const mat &a) {\n  FOR(it, a) os << *it << endl;\n  return os;\n}\n\n\nbool gauss_jordan_cong(const mat &A, const vec &b, int m, vec &x) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  REP(i,n) REP(j,n)\n    B[i][j] = A[i][j];\n  REP(i, n) B[i][n] = b[i];\n\n  //cout << B << endl;\n  REP(i, n) {\n    int pivot = i;\n    for (int j=i; j<n; ++j)\n      if (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    swap(B[i], B[pivot]);\n    // 解がないか、一意でない\n    if (abs(B[i][i]) < EPS) {\n      if (abs(B[i][n]) > EPS) return 0;\n      continue;\n    }\n\n    // // 注目している変数の係数を１にする\n    // for (int j=i+1; j<=n; j++) B[i][j] = B[i][j] ^ B[i][i];\n    // B[i][i] = 1;\n    REP(j, n) {\n      if (i != j) {\n        // j番目の式からi番目の変数を消去\n        if (B[j][i])\n          for (int k=i+1; k<=n; ++k) B[j][k] = B[j][k] ^ B[i][k];\n        B[j][i] = 0;\n      }\n    }\n    //cout << B << endl;\n  }\n  //cout << B << endl;\n  x = vec(n);\n  REP(i, n) {\n    if (B[i][i] == 0 && B[i][n]) return 0;\n    x[i] = B[i][n];\n  }\n  return 1;\n}\n\nint main() {\n  int m, n, d;\n  int c = 0;\n  while(cin>>m>>n>>d, m||n||d) {\n    bool ba[n][m];\n    mat A(n*m, vec(n*m));\n    vec b(n*m);\n    REP(i,n) {\n      REP(j,m) {\n        cin >> ba[i][j];\n        A[i*m+j][i*m+j] = 1;\n        REP(k,n) {\n          REP(l,m) {\n            int dis = abs(i-k)+abs(j-l);\n            if (dis == d) {\n              A[k*m+l][i*m+j] = 1;\n              // A[i*m+j][k*m+l] = 1;\n            }\n          }\n        }\n        b[i*m+j] = ba[i][j];\n      }\n    }\n    vec x;\n    cout << gauss_jordan_cong(A,b,2,x) << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld EPS = 1e-9;\n\n\ntemplate<class T>\nint GaussJordanElimination(vector<vector<T>>& mat) {\n    int H = SZ(mat), W = SZ(mat[0]), rank = 0;\n    for (int col = 0; col < W; ++col) {\n        int pivot = -1;\n        for (int row = rank; row < H; ++row) {\n            if (mat[row][col] != 0) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(mat[rank], mat[pivot]);\n        T topLeft = mat[rank][col];\n        for (int c = col; c < W; ++c) {\n            // mat[rank][c] /= topLeft;\n        }\n        for (int row = rank+1; row < H; ++row) {\n            T ratio = mat[row][col];\n            for (int c = col; c < W; ++c)\n                // mat[row][c] -= ratio * mat[rank][c];\n                mat[row][c] ^= ratio * mat[rank][c];\n        }\n        ++rank;\n    }\n    return (rank);\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int m, n, d;\n        cin >> m >> n >> d;\n        if (m == 0) break;\n\n        vvi mat(n*m, vi(n*m+1));\n\n        REP(i, n) REP(j, m) cin >> mat[i*m + j][n*m];\n        // debug(b);\n\n        REP(i, n) REP(j, m) {\n                mat[i*m + j][i*m + j] = 1;\n                REP(y, n) REP(x, m) {\n                        if (abs(y - i) + abs(x - j) == d) {\n                            mat[i*m + j][y*m + x] = 1;\n                        }\n                    }\n            }\n\n        // debug(Q);\n        GaussJordanElimination(mat);\n        // debug(Q);\n\n        int ans = true;\n        REP(i, n * m) {\n            int allZero = true;\n            REP(j, n * m) {\n                if (mat[i][j] != 0) {\n                    allZero = false;\n                    break;\n                }\n            }\n            if (allZero and mat[i][n * m] == 1) {\n                ans = false;\n                break;\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nbool light[50][50];\n\nbool gauss(const mat &A, const vec &b){\n\tint n = A.size();\n\tmat B(n, vec(n+1));\n\trep(i, n)rep(j, n){\n\t\tB[i][j] = A[i][j];\n\t}\n\trep(i, n) B[i][n] = b[i];\n\trep(i, n){\n\t\tint pivot = 0;\n\t\trep2(j, i, n){\n\t\t\tif(B[j][i]){\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\t\tif(B[i][i] == 0){\n\t\t\tif(B[i][n]) return false;\n\t\t\telse continue;\n\t\t}\n\n\t\trep(j, n){\n\t\t\tif(i != j && B[j][i]){\n\t\t\t\trep2(k, i + 1, n + 1) if(B[i][k]) B[j][k] = (1 - B[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint m, n, d;\n\tint s;\n\twhile(cin >> m >> n >> d && (m || n || d)){\n\t\trep(i, n)rep(j, m){\n\t\t\tcin >> s;\n\t\t\tif(s) light[i][j] = true;\n\t\t\telse light[i][j] = false;\n\t\t}\n\t\tint sz = m * n;\n\t\tmat A(sz, vec(sz));\n\t\tvec b(sz);\n\t\trep(i, n)rep(j, m){\n\t\t\tint a = i * m + j;\n\t\t\trep(k, n)rep(l, m){\n\t\t\t\tif(d == abs(k - i) + abs(l - j) || 0 == abs(k - i) + abs(l - j)){\n\t\t\t\t\tA[a][k*m+l] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tA[a][k*m+l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, m){\n\t\t\tif(light[i][j]) b[i*m+j] = 1;\n\t\t\telse b[i*m+j] = 0;\n\t\t}\n\t\tif(gauss(A, b)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ALL(c) (c).begin(), (c).end()\n#define REP(i, n) for(auto i = 0 * (n); i < (n); ++i)\n#define FOR(i, s, n) for(size_t i = (s); i < (n); ++i)\n\ntypedef bitset<26*25> Vector;\ntypedef vector<Vector> Matrix;\nstruct GaussJordanBit {\n\ttypedef size_t T;\n\tGaussJordanBit(Matrix mat, T col) : x(move(mat)) {\n\t\tT row = x.size(), r = 0;\n\t\tREP(c, col) {\n\t\t\tT p = r;\n\t\t\tFOR(i, r, row) if (x[i][c]) p = i;\n\t\t\tswap(x[r], x[p]);\n\t\t\tif (x[r][c]) {\n\t\t\t\tif (c == col - 1) possible = 0; // ??????????????????????????????????????????\n\t\t\t\tREP(i, row) if (r != i && x[i][c]) x[i] ^= x[r];\n\t\t\t\tif (++r == row) break;\n\t\t\t}\n\t\t}\n\t\trank = r;\n\t}\n\tMatrix x;\n\tT rank;\n\tbool possible = 1; // ?????¢????¬?????¨????????§£??????????????´???????????????????§£????????? <-> true\n};\n\nbool ba[30][30];\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint m, n, d;\n\twhile (cin >> m >> n >> d, m || n || d) {\n\t\tMatrix A(n * m);\n\t\tREP(i, n) {\n\t\t\tREP(j, m) {\n\t\t\t\tcin >> ba[i][j];\n\t\t\t\tA[i * m + j][i * m + j] = 1;\n\t\t\t\tREP(k, n) {\n\t\t\t\t\tREP(l, m) {\n\t\t\t\t\t\tint dis = abs(i - k) + abs(j - l);\n\t\t\t\t\t\tif (dis == d) {\n\t\t\t\t\t\t\tA[k * m + l][i * m + j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tA[i * m + j][n * m] = ba[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << (GaussJordanBit(move(A), n * m + 1).possible ? 1 : 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <algorithm>\n#define coor(i,j) ((i)+(j)*m)\n#define in(i,j) (0<=(i)&&(i)<m&&0<=(j)&&(j)<n)\nusing namespace std;\nvector<bitset<626> > M(625);\n\nint main(){\n\tint m,n,d;\n\tint i,j,k;\n\tint success,ans;\n\tfor(;cin>>m>>n>>d,d;cout<<ans<<endl){\n\t\t//create M\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tM[coor(i,j)].reset();\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tM[coor(i,j)][coor(i,j)]=1;\n\t\t\t\tcin>>k;M[coor(i,j)][m*n]=k;\n\t\t\t\tfor(k=0;k<=d;k++){\n\t\t\t\t\tif(in(i-k,j-(d-k)))M[coor(i-k,j-(d-k))][coor(i,j)]=1;\n\t\t\t\t\tif(in(i+k,j-(d-k)))M[coor(i+k,j-(d-k))][coor(i,j)]=1;\n\t\t\t\t\tif(in(i-k,j+(d-k)))M[coor(i-k,j+(d-k))][coor(i,j)]=1;\n\t\t\t\t\tif(in(i+k,j+(d-k)))M[coor(i+k,j+(d-k))][coor(i,j)]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//solve\n\t\tk=0;\n\t\tfor(i=0;i<m*n;i++){\n\t\t\tfor(j=k;j<m*n&&!M[j][i];j++);\n\t\t\tif(j==m*n)continue;\n\t\t\tswap(M[k],M[j]);\n\t\t\tfor(j=k+1;j<m*n;j++)if(M[j][i])M[j]^=M[k];\n\t\t\tk++;\n\t\t}\n\n\t\t//finalize\n\t\tans=1;\n\t\tfor(j=k;j<m*n;j++)if(M[j][m*n])ans=0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct mod\n{\n  int m;\n  mod(int a) : m(a) {}\n  int operator()(int x) const { return ((x%m)+m)%m; }\n};\n\n\nvector<int> gaussian_elimination(vector<vector<int> > a, vector<int> b)\n{\n  static const int inv_tbl[2] = {-1, 1};\n  static mod M(2);\n  const int N = a.size();\n\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; a[i][i] == 0 && j < N; j++) {\n      swap(a[i], a[j]);\n      swap(b[i], b[j]);\n    }\n    if (a[i][i] == 0) {\n      continue;\n    }\n\n    const int t = inv_tbl[a[i][i]];\n    for (int k = i; k < N; k++) {\n      a[i][k] = M(a[i][k] * t);\n    }\n    b[i] = M(b[i] * t);\n\n    for (int j = 0; j < N; j++) {\n      if (i == j) {\n        continue;\n      }\n      const int u = a[j][i];\n      for (int k = i; k < N; k++) {\n        a[j][k] = M(a[j][k] - u*a[i][k]);\n      }\n      b[j] = M(b[j] - u*b[i]);\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (a[i][i] == 0 && b[i] != 0) {\n      // no solution\n      return vector<int>();\n    }\n  }\n  return b;\n}\n\nint main()\n{\n  int M, N, D;\n  while (cin >> M >> N >> D && M != 0) {\n    vector<vector<int> > a(M*N, vector<int>(M*N, 0));\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        a[N*i+j][N*i+j] = 1;\n        for (int k = -D; k <= D; k++) {\n          for (int l = -D; l <= D; l++) {\n            const int x = i+k, y = j+l;\n            if (abs(k)+abs(l) == D && 0 <= x && x < N && 0 <= y && y < M) {\n              a[M*i+j][M*x+y] = 1;\n            }\n          }\n        }\n      }\n    }\n\n    vector<int> b(N*M);\n    for (int i = 0; i < N*M; i++) {\n      cin >> b[i];\n    }\n\n    const vector<int> x = gaussian_elimination(a, b);\n    cout << !x.empty() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nint M, N, D, S[32][32], a[768][768];\n\nbool solve(int n) {\n    int h = 0;\n    rep(k, n) {\n        int ix = -1;\n        for(int i=h; i<n; i++) if(a[i][k]) { ix=i; break; }\n        if(ix==-1) continue;\n        if(h!=ix) rep(i, n+1) swap(a[h][i], a[ix][i]);\n        rep(i, n) if(i!=h) if(a[i][k]) {\n            for(int j=k; j<=n; j++) a[i][j] ^= a[h][j];\n        }\n        h++;\n    }\n    for(int i=h; i<n; i++) if(a[i][n]==1) return false;\n    return true;\n}\n\nint main() {\n    for(;;) {\n        scanf(\"%d%d%d\", &M, &N, &D);\n        if(M==0 && N==0 && D==0) return 0;\n        rep(i, N) rep(j, M) scanf(\"%d\", S[i]+j);\n        memset(a, 0, sizeof(a));\n        const int n = N*M;\n        rep(i, N) rep(j, M) {\n            const int ix = i*M+j;\n            a[ix][ix] = 1;\n            a[ix][n] = S[i][j];\n            rep(x, N) rep(y, M) if(abs(i-x)+abs(j-y)==D) a[ix][x*M+y] = 1;\n        }\n        printf(\"%d\\n\", (int)solve(n));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1308 Awkward Lights\n// 2018.3.8 bal4u\n\n//#include <stdio.h>\n//#include <string.h>\n//#include \"bits/stdc++.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint inbit()\n{\n\tint c = getchar_unlocked();\n\tgetchar_unlocked();\n\treturn c & 1;\n}\n\n#define N 630\n\nbitset <N> B[N];\n\nint gauss_jordan(int n)\n{\n\tint i, j, pivot;\n\n\tfor (i = 0; i < n; i++) {\n\t\tpivot = -1;\n\t\tfor (j = i; j < n; j++) if (B[j][i]) { pivot = j; break; }\n\t\tif (pivot < 0) continue;\n\n\t\tswap(B[pivot], B[i]);\n\n\t\tfor (j = 0; j < n; j++) if (i != j && B[j][i]) B[j] ^= B[i];\n\t}\n\n\tfor (i = 0; i < n; i++) if (!B[i][i] && B[i][n]) return 0;\n\treturn 1;\n}\n\n#define ABS(a)\t((a)>=0?(a):-(a))\n#define ID(r,c)\t((r)*m+(c))\n\nint main()\n{\n\tint m, n, mn, d, i, j, r, c;\n\n\twhile (m = in()) {\n\t\tn = in(), d = in(), mn = m*n;\n\t\tmemset(B, 0, sizeof(B));\n\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < m; j++) {\n\t\t\tif (inbit()) B[ID(i,j)][mn] = 1;\n\t\t\tfor (r = 0; r < n; r++) for (c = 0; c < m; c++) {\n\t\t\t\tif (r == i && c == j || ABS(r-i)+ABS(c-j) == d)\n\t\t\t\t\tB[ID(i,j)][ID(r,c)] = 1;\n\t\t\t}\n\t\t}\n\t\tputchar('0' + gauss_jordan(mn)), putchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <bitset>\nusing namespace std;\n\nconst int MAX_ROW = 1005;\nconst int MAX_COL = 1005;\n\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int n = 1, int m = 1) : H(n), W(m) {}\n    inline bitset<MAX_COL> &operator[] (int i) { return val[i]; }\n};\n\n// O(HW)\nint gauss_jordan(BitMatrix &A, bool extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; col++) {\n        if (extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; row++) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[rank], A[pivot]);\n        for (int row = 0; row < A.H; row++) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix &A, vector<int> const &b, vector<int> &ans) {\n    int n = A.H;\n    int m = A.W;\n    BitMatrix M(n, m+1);\n    for (int i = 0; i < n; i++) {\n        M[i] = A[i];\n        M[i][m] = b[i];\n    }\n    int rank = gauss_jordan(M, true);\n\n    ans.resize(0);\n    for (int i = rank; i < n; i++) if (M[i][m]) return rank;\n    ans.resize(n, 0);\n    for (int i = 0; i < rank; i++) ans[i] = M[i][m];\n    return rank;\n}\n\n// Aizu1308 - Awkward Lights\nbool solve() {\n    int M, N, D;\n    cin >> M >> N >> D;\n    if (!(M || N || D)) return false;\n    vector<int> b(M*N);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            int a;\n            cin >> a;\n            b[i * M + j] = a;\n        }\n    }\n    BitMatrix A(N*M, N*M);\n    for (int r1 = 0; r1 < N; r1++) {\n        for (int c1 = 0; c1 < M; c1++) {\n            for (int r2 = 0; r2 < N; r2++) {\n                for (int c2 = 0; c2 < M; c2++) {\n                    int dis = abs(r1 - r2) + abs(c1 - c2);\n                    if (dis == 0 || dis == D) A[r1 * M + c1][r2 * M + c2] = true;\n                }\n            }\n        }\n    }\n    vector<int> ans;\n    linear_equation(A, b, ans);\n    if (ans.size() > 0) cout << 1 << endl;\n    else cout << 0 << endl;\n    return true;\n}\n\nint main() {\n    bool flag = true;\n    while (flag) flag = solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ninline int countPopulation(unsigned int x) {\n\tx -= ((x >> 1) & 0x55555555);\n\tx = ((x >> 2) & 0x33333333) + (x & 0x33333333);\n\tx = ((x >> 4) + x) & 0x0f0f0f0f;\n\tx += (x >> 8);\n\tx += (x >> 16);\n\treturn (x & 0x0000003f);\n}\n\ninline int countPopulation64(unsigned long long x) {\n\treturn countPopulation(x & 0xffffffff) + countPopulation(x >> 32);\n}\n\n\nstruct BitSet {\n\ttypedef unsigned long long uint64;\n\tstatic const int MAX_BIT_LENGTH = int(25*25+1);\n\tuint64 bits[1 + ((MAX_BIT_LENGTH + 0x3f)>>6)];\n\tint size, last;\n\tuint64 lastMask;\n\n\tBitSet(){}\n\n\tvoid init(const int size_) {\n\t\tsize = size_;\n\t\tlast = (size+0x3f)>>6;\n\t\tlastMask = (1ULL<<(size&0x3f)) - 1;\n\t\tmemset(bits, 0, sizeof(uint64)*last);\n\t}\n\n\tinline int getIthBit(const int i) const {\n\t\treturn (bits[i>>6]>>(i&0x3f))&1;\n\t}\n\n\tinline int operator [](const int i) const {\n\t\treturn getIthBit(i);\n\t}\n\n\tinline void flip(const int i) {\n\t\tbits[i>>6] ^= (1ULL<<(i&0x3f));\n\t}\n\n\tinline void turnOn(const int i) {\n\t\tbits[i>>6] |= (1ULL<<(i&0x3f));\n\t}\n\n\tinline void turnOff(const int i) {\n\t\tbits[i>>6] &= ~(1ULL<<(i&0x3f));\n\t}\n\n\tinline void allFlip() {\n\t\tfor (int i = 0; i < last - 1; ++i) {\n\t\t\tbits[i] ^= ~0ULL;\n\t\t}\n\t\tbits[last - 1] ^= lastMask;\n\t}\n\n\tinline void allTurnOn() {\n\t\tmemset(bits, ~0, sizeof(uint64)*(last - 1));\n\t\tbits[last-1] = lastMask;\n\t}\n\n\tinline void allTurnOff() {\n\t\tmemset(bits, 0, sizeof(uint64)*last);\n\t}\n\n\tinline void rangeFlip(const int from, const int to) {\n\t\tconst int beg = from >> 6, ed = to >> 6;\n\t\tconst uint64 begMask = ~((1ULL<<(from&0x3f)) - 1), edMask = (1ULL<<(to&0x3f)) - 1;\n\t\tfor (int i = from + 1; i < ed; ++i) {\n\t\t\tbits[i] ^= ~0ULL;\n\t\t}\n\t\tif (beg == ed) {\n\t\t\tbits[beg] ^= begMask & edMask;\n\t\t}\n\t\telse {\n\t\t\tbits[beg] ^= begMask;\n\t\t\tbits[ed]  ^= edMask;\n\t\t}\n\t}\n\n\tinline void rangeTurnOn(const int from, const int to) {\n\t\tconst int beg = from >> 6, ed = to >> 6;\n\t\tconst uint64 begMask = ~((1ULL<<(from&0x3f)) - 1), edMask = (1ULL<<(to&0x3f)) - 1;\n\t\tfor (int i = from + 1; i < ed; ++i) {\n\t\t\tbits[i] = ~0ULL;\n\t\t}\n\t\tif (beg == ed) {\n\t\t\tbits[beg] |= begMask & edMask;\n\t\t}\n\t\telse {\n\t\t\tbits[beg] |= begMask;\n\t\t\tbits[ed]  |= edMask;\n\t\t}\n\t}\n\n\tinline void rangeTurnOff(const int from, const int to) {\n\t\tconst int beg = from >> 6, ed = to >> 6;\n\t\tconst uint64 begMask = ~((1ULL<<(from&0x3f)) - 1), edMask = (1ULL<<(to&0x3f)) - 1;\n\t\tfor (int i = from + 1; i < ed; ++i) {\n\t\t\tbits[i] = 0;\n\t\t}\n\t\tif (beg == ed) {\n\t\t\tbits[beg] &= ~(begMask & edMask);\n\t\t}\n\t\telse {\n\t\t\tbits[beg] &= ~begMask;\n\t\t\tbits[ed]  &= ~edMask;\n\t\t}\n\t}\n\n\tinline int countPopulation() const {\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tans += countPopulation64(bits[i]);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tinline int countRangePopulation(const int from, const int to) const {\n\t\tconst int beg = from >> 6, ed = to >> 6;\n\t\tconst uint64 begMask = ~((1ULL<<(from&0x3f)) - 1), edMask = (1ULL<<(to&0x3f)) - 1;\n\t\tint ans = 0;\n\t\tfor (int i = from + 1; i < ed; ++i) {\n\t\t\tans += countPopulation64(bits[i]);\n\t\t}\n\t\tif (beg == ed) {\n\t\t\tans += countPopulation64(bits[beg] &~ (begMask & edMask));\n\t\t}\n\t\telse {\n\t\t\tans += countPopulation64(bits[beg] &~ begMask);\n\t\t\tans += countPopulation64(bits[ed]  &~ edMask);\n\t\t}\n\t\treturn ans;\n\t}\n\n\tBitSet operator& (const BitSet &x) const {\n\t\tBitSet ret = *this;\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tret.bits[i] &= x.bits[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBitSet operator| (const BitSet &x) const {\n\t\tBitSet ret = *this;\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tret.bits[i] |= x.bits[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBitSet operator^ (const BitSet &x) const {\n\t\tBitSet ret = *this;\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tret.bits[i] ^= x.bits[i];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBitSet operator~ () const {\n\t\tBitSet ret = *this;\n\t\tret.allFlip();\n\t\treturn ret;\n\t}\n\n\tBitSet &operator^= (const BitSet &x) {\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tbits[i] ^= x.bits[i];\n\t\t}\n\t\treturn *this;\n\t}\n\n\tBitSet &operator&= (const BitSet &x) {\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tbits[i] &= x.bits[i];\n\t\t}\n\t\treturn *this;\n\t}\n\n\tBitSet &operator|= (const BitSet &x) {\n\t\tfor (int i = 0; i < last; ++i) {\n\t\t\tbits[i] |= x.bits[i];\n\t\t}\n\t\treturn *this;\n\t}\n};\n\n\nint calcEquationSystemMod2(vector<BitSet> &Ab, BitSet& x) {\n\tconst int n = Ab.size(), m = Ab[0].size - 1;\n\tx.init(m);\n\tbool uniq = true;\n\tint val = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (val == m) {\n\t\t\tfor (int j = i; j < n; ++j) {\n\t\t\t\tif (Ab[j][val]) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tint foundOne = -1;\n\t\tfor (int j = i; j < n; ++j) {\n\t\t\tif (Ab[j][val]) {\n\t\t\t\tfoundOne = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (foundOne >= 0) {\n\t\t\tswap(Ab[i], Ab[foundOne]);\n\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\tif (Ab[j][val]) {\n\t\t\t\t\tAb[j] ^= Ab[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tuniq = false;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tAb[j].turnOff(val);\n\t\t\t}\n\t\t\t--i;\n\t\t}\n\t\t++val;\n\t}\n\treturn 1;\n\tval = m - 1;\n\tint i = n - 1;\n\tfor (;i >= 0 && Ab[i].countPopulation() == 0; --i) ;\n\tfor (;i >= 0 && val >= 0; --val) {\n\t\tif (Ab[i][val]) {\n\t\t\tif (Ab[i][m]) {\n\t\t\t\tx.turnOn(val);\n\t\t\t\tfor (int j = 0; j < i; ++j) if (Ab[j][val]) {\n\t\t\t\t\tAb[j].turnOff(val);\n\t\t\t\t\tAb[j].flip(m);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\t\tAb[j].turnOff(val);\n\t\t\t\t}\n\t\t\t}\n\t\t\t--i;\n\t\t}\n\t}\n\n\treturn uniq ? 1 : -1;\n}\n\nconst int MAX_N = 25;\nint W, H, D;\nint board[MAX_N][MAX_N];\n\ninline int toIndex(int y, int x) {\n\treturn y * W + x;\n}\n\nbool init() {\n\tscanf(\"%d%d%d\", &W, &H, &D);\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", board[i] + j);\n\t\t}\n\t}\n\treturn H > 0;\n}\n\ninline int getDist(int y1, int x1, int y2, int x2) {\n\treturn abs(y1 - y2) + abs(x1 - x2);\n}\n\nbool solve() {\n\tvector<BitSet> matrix(W*H);\n\tfor (int i = 0; i < W*H; ++i) {\n\t\tmatrix[i].init(W*H+1);\n\t}\n\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tmatrix[toIndex(i,j)].turnOn(toIndex(i,j));\n\t\t\tif (board[i][j]) {\n\t\t\t\tmatrix[toIndex(i,j)].turnOn(W*H);\n\t\t\t}\n\t\t\tfor (int ii = 0; ii < H; ++ii) {\n\t\t\t\tfor (int jj = 0; jj < W; ++jj) {\n\t\t\t\t\tif (getDist(i,j,ii,jj) == D) {\n\t\t\t\t\t\tmatrix[toIndex(i,j)].turnOn(toIndex(ii,jj));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tBitSet x;\n\tbool ans = calcEquationSystemMod2(matrix, x);\n\t//cout << x << endl;\n\treturn ans;\n}\n\nint main() {\n\t/*\n\tstatic BitSet b;\n\tb.init(100);\n\tcout << b << endl;\n\tb.rangeFlip(10, 40);\n\tcout << b << b.countPopulation() << endl;\n\tb.rangeFlip(30, 90);\n\tcout << b << b.countPopulation() << endl;\n\tb.rangeFlip(35, 35);\n\tb.rangeTurnOff(64, 67);\n\tcout << b << b.countPopulation() << endl;\n\tcout << ~b << (~b).countPopulation() << endl;\n\tBitSet x;\n\tx = b & (~b);\n\tcout << x << endl;\n\t*/\n\tfor (;init();) {\n\t\tputs(solve() ? \"1\" : \"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\ntypedef vector<int> V;\ntypedef vector<V> M;\n\nenum Status{OK, AMB, NONE};\nStatus gauss_jordan(M m, V v) {\n  for (int r = m.size(); r--; ) {\n  back:;\n    int p = r;\n    rep (i, r) if (abs(m[i][r]) > abs(m[p][r])) p = i;\n    swap(m[r], m[p]);\n    swap(v[r], v[p]);\n    if (m[r][r] == 0) {\n      rep (j, r) if (m[r][j]) {\n\trep (k, m.size()) swap(m[k][j], m[k][r]);\n\tgoto back;\n      }\n      if (v[r]) return NONE;\n    }\n    rep (i, m.size()) if(i != r) {\n      v[i] ^= m[i][r] & v[r];\n      rep (k, r) m[i][k] ^= m[i][r] & m[r][k];\n    }\n  }\n  if (m[0][0] == 0) return AMB;\n  return OK;\n}\n\nint main() {\n  while (true) {\n    int m, n, d;\n    cin >> m >> n >> d;\n    if (m == 0 && n == 0 && d == 0) break;\n    V v(n * m);\n    rep (i, n * m) cin >> v[i];\n    M mat(n * m, V(n * m, 0));\n    rep (i, n * m) mat[i][i] = 1;\n    rep (i, n) rep (j, m) rep (ii, n) rep (jj, m) if (abs(i - ii) + abs(j - jj) == d) mat[i * m + j][ii * m + jj] = 1;\n    if (gauss_jordan(mat, v) == NONE) cout << 0 << endl;\n    else cout << 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint calc_rank(mat A) {\n\tconst int n = A.size();\n\tconst int m = A[0].size();\n\n\tint res = 0;\n\tint col = -1;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint pivot;\n\t\tfor(;;) {\n\t\t\tif(++col == m) goto rank_end;\n\t\t\tpivot = -1;\n\t\t\tfor(int j = i; j < n; ++j) {\n\t\t\t\tif(A[j][col]) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tgoto pivot_end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tpivot_end:;\n\t\tA[i].swap(A[pivot]);\n\t\t++res;\n\n\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\tif(A[j][col]) {\n\t\t\t\tfor(int k = col + 1; k < m; ++k) {\n\t\t\t\t\tA[j][k] ^= A[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nrank_end:;\n\treturn res;\n}\n\nint calc_rank(const mat &A, const vec &b) {\n\tconst int n = A.size();\n\tconst int m = A[0].size() + 1;\n\tmat B(n, vec(m));\n\tfor(int i = 0; i < n; ++i) {\n\t\tcopy(A[i].begin(), A[i].end(), B[i].begin());\n\t\tB[i][m - 1] = b[i];\n\t}\n\treturn calc_rank(move(B));\n}\n\nint w, h, d;\n\ninline bool solve(mat A, const vec &b) {\n\treturn calc_rank(A, b) == calc_rank(move(A));\n}\n\ninline int get_index(int x, int y) {\n\treturn x + y * w;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h >> d && h) {\n\t\tconst int number_of_cell = w * h;\n\t\tvec right(number_of_cell);\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\tcin >> right[get_index(x, y)];\n\t\t\t}\n\t\t}\n\n\t\tmat left(number_of_cell, vec(number_of_cell, 0));\n\t\tfor(int i = 0; i < number_of_cell; ++i) {\n\t\t\tleft[i][i] = 1;\n\t\t}\n\n\t\tfor(int y = 0; y < h; ++y) {\n\t\t\tfor(int ty = max(0, y - d); ty <= min(h - 1, y + d); ++ty) {\n\t\t\t\tfor(int sign = -1; sign <= 1; sign += 2) {\n\t\t\t\t\tconst int dx = sign * (d - abs(y - ty));\n\t\t\t\t\tfor(int x = 0; x < w; ++x) {\n\t\t\t\t\t\tconst int tx = x + dx;\n\t\t\t\t\t\tif(tx < 0 || tx >= w) continue;\n\t\t\t\t\t\tleft[get_index(x, y)][get_index(tx, ty)] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << solve(move(left), right) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint const nMax = 650;\nint a[nMax][nMax];\nint g[nMax][nMax];\nint n,m,nn,d,num;\nvoid init()\n{\n    nn = n*m;\n    for(int i = 0;i < m;i++){\n        for(int j = 0;j < n;j++){\n            scanf(\"%d\",&g[i][j]);\n            a[i*n+j][nn] = g[i][j];\n        }\n    }\n}\nvoid add(int x,int y)\n{\n    int i;\n    for(i=0;i<=d;i++)\n    {\n        if(x+i<m&&y+d-i<n)\n            a[x*n+y][(x+i)*n+y+d-i]=1;\n        if(x+i<m&&y-d+i>=0)\n            a[x*n+y][(x+i)*n+y-d+i]=1;\n        if(x-i>=0&&y+d-i<n)\n            a[x*n+y][(x-i)*n+y+d-i]=1;\n        if(x-i>=0&&y-d+i>=0)\n            a[x*n+y][(x-i)*n+y-d+i]=1;\n    }\n    a[x*n+y][x*n+y]=1;\n}\nint gauss_ac()\n{\n    int i,j,r;\n    int lt[nMax];\n    for(r = i = 0;i < nn;i++){\n        for(j = r;j < nn&&!a[j][i];j++);\n        if( j >= nn )continue;\n        if( j > r )\n            for(int k = 0;k <= nn;k++)\n                swap(a[r][k],a[j][k]);\n        int countnum = 0;\n        for(int k = i;k <= nn;k++)\n            if( a[r][k] )\n                lt[++countnum] = k;\n        for(j = 0;j < nn;j++){\n            if( j != r && a[j][i] )\n                for(int k = 1;k <= countnum;k++)\n                    a[j][lt[k]]^=1;\n        }\n        ++r;\n    }\n    for(i = 0;i < nn;i++)\n        if( a[i][nn] )\n            for(j = 0;j < nn&&!a[i][j];j++);\n            if( j == nn )return 0;\n    return 1;\n}\nint main()\n{\n    while(scanf(\"%d%d%d\",&n,&m,&d),n||m||d){\n        memset(a,0,sizeof(a));\n        init();\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++)\n                add(i,j);\n        }\n        printf(\"%d\\n\",gauss_ac());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct mod\n{\n  int m;\n  mod(int a) : m(a) {}\n  int operator()(int x) const { return ((x%m)+m)%m; }\n};\n\nstatic mod M(2);\n// GF(p) ツづ可つィツつ「ツづ，x ツづ個湘ヲツ法ツづ個逆ツ個ウツづ債フツェツδ仰マツーツづ個渉ャツ津ィツ猟敖つゥツづァ x^(p-2) ツづ計ツ算ツづつォツづゥ\nint inv_tbl[7] = {-1, 1};\n\nvector<int> gaussian_elimination(vector<vector<int> > a, vector<int> b)\n{\n  const int N = a.size();\n\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; a[i][i] == 0 && j < N; j++) {\n      swap(a[i], a[j]);\n      swap(b[i], b[j]);\n    }\n    if (a[i][i] == 0) {\n      continue;\n    }\n\n    const int t = inv_tbl[a[i][i]];\n    for (int k = i; k < N; k++) {\n      a[i][k] = M(a[i][k] * t);\n    }\n    b[i] = M(b[i] * t);\n\n    for (int j = 0; j < N; j++) {\n      if (i == j) {\n        continue;\n      }\n      const int u = a[j][i];\n      for (int k = i; k < N; k++) {\n        a[j][k] = M(a[j][k] - u*a[i][k]);\n      }\n      b[j] = M(b[j] - u*b[i]);\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (a[i][i] == 0 && b[i] != 0) {\n      // no solution\n      return vector<int>();\n    }\n  }\n  return b;\n}\n\nint main()\n{\n  int M, N, D;\n  while (cin >> M >> N >> D && M != 0) {\n    vector<vector<int> > a(M*N, vector<int>(M*N, 0));\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        a[N*i+j][N*i+j] = 1;\n        for (int k = -D; k <= D; k++) {\n          for (int l = -D; l <= D; l++) {\n            const int x = i+k, y = j+l;\n            if (abs(k)+abs(l) == D && 0 <= x && x < N && 0 <= y && y < M) {\n              a[M*i+j][M*x+y] = 1;\n            }\n          }\n        }\n      }\n    }\n\n    vector<int> b(N*M);\n    for (int i = 0; i < N*M; i++) {\n      cin >> b[i];\n    }\n\n    const vector<int> x = gaussian_elimination(a, b);\n    cout << !x.empty() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\n\nconst int MAX_ROW = 630; // to be set appropriately\nconst int MAX_COL = 630; // to be set appropriately\n\nstruct BMAT {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BMAT(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nint GaussJordan(BMAT &A, bool is_extended = false) {\n    int rk = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rk; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rk]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rk && A[row][col]) A[row] ^= A[rk];\n        }\n        ++rk;\n    }\n    return rk;\n}\n\nint linear_equation(BMAT A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BMAT M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rk = GaussJordan(M, true);\n\n    for (int row = rk; row < m; ++row) if (M[row][n]) return -1;\n\n    res.assign(n, 0);\n    for (int i = 0; i < rk; ++i) res[i] = M[i][n];\n    return rk;\n}\n\nint main(){\n    int s[33][33];\n    int h,w,d;\n    while(cin>>w>>h>>d,w){\n        BMAT A(h*w,h*w);\n        vector<int> ans(h*w,0),res;\n        r(i,h)r(j,w)cin>>s[i][j];\n        r(i,h)r(j,w){\n            A[i*w+j][i*w+j]=1;\n            r(k,h)r(l,w){\n                if(abs(i-k)+abs(j-l)==d){\n                    A[i*w+j][k*w+l]=1;\n                }\n            }\n            if(!s[i][j])ans[i*w+j]=1;\n        }\n        if(linear_equation(A,ans,res)!=-1)cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n\nll modNorm(ll a, ll m) {\n  return (a%m+m)%m;\n}\n\n// ax+by=gcd(a,b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll invMod(ll a, ll p) {\n  ll x, y;\n  if (extgcd(a,p,x,y) == 1) return (x+p)%p;\n  return 0;\n}\n\ntypedef vector<bool> vec;\ntypedef vector<vec> mat;\n\nostream &operator<<(ostream &os, const vec &a) {\n  FOR(it, a) os << *it << \" \";\n  return os;\n}\nostream &operator<<(ostream &os, const mat &a) {\n  FOR(it, a) os << *it << endl;\n  return os;\n}\n\n\nbool gauss_jordan_cong(const mat &A, const vec &b, int m, vec &x) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  REP(i,n) REP(j,n)\n    B[i][j] = A[i][j];\n  REP(i, n) B[i][n] = b[i];\n\n  //cout << B << endl;\n  int rank = 0;\n  int nowy = 0;\n  REP(x, n) {\n    int pivot = nowy;\n    for (int j=nowy+1; j<n; ++j)\n      if (B[j][x]) pivot = j;\n    swap(B[nowy], B[pivot]);\n    // ツ嘉ーツつェツづ按つ「ツつゥツ、ツ暗ェツ暗督づづ按つ「\n    if (!B[nowy][x]) {\n      continue;\n    }\n    \n    for (int j=nowy+1; j<n; ++j) {\n      if (B[j][x])\n        for (int k=x; k<=n; ++k) B[j][k] = B[j][k] ^ B[nowy][k];\n    }\n    nowy++;\n    \n    //cout << B << endl;\n  }\n  //cout << B << endl;\n  for (int y=nowy; y<n; ++y)\n    if (B[y][n])\n      return 0;\n  return 1;\n}\n\nint main() {\n  int m, n, d;\n  int c = 0;\n  while(cin>>m>>n>>d, m||n||d) {\n    bool ba[n][m];\n    mat A(n*m, vec(n*m));\n    vec b(n*m);\n    REP(i,n) {\n      REP(j,m) {\n        cin >> ba[i][j];\n        A[i*m+j][i*m+j] = 1;\n        REP(k,n) {\n          REP(l,m) {\n            int dis = abs(i-k)+abs(j-l);\n            if (dis == d) {\n              A[i*m+j][k*m+l] = 1;\n            }\n          }\n        }\n        b[i*m+j] = ba[i][j];\n      }\n    }\n    vec x;\n    cout << gauss_jordan_cong(A,b,2,x) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nconst Int MAX = 2002;\nusing BS = bitset<MAX*2>;\nusing mat = vector<BS>;\n\nvoid gauss(mat &v){\n  int n=v.size();\n  for(Int i=0;i<n;i++){\n    for(Int k=i;k<n;k++){\n      if(v[k][i]){\n\tswap(v[i],v[k]);\n\tbreak;\n      }\n    }\n    for(Int k=0;k<n;k++)\n      if(i!=k&&v[k][i]) v[k]^=v[i];\n  }\n}\n\nint mrank(mat v,int m){\n  int n=v.size();\n  int r=0,c=0;\n  for(int i=0;i<n;i++){\n    int s=-1;\n    while(c<m){\n      for(int j=i;j<n;j++){\n\tif(v[j][c]){\n\t  s=j;\n\t  break;\n\t}\n      }\n      if(~s) break;\n      c++;\n    }\n    if(c>=m) break;\n    \n    swap(v[i],v[s]);\n    for(int j=0;j<n;j++)\n      if(i!=j&&v[j][c]) v[j]^=v[i];\n    \n    r++;c++;\n  }\n  return r;\n}\n\nmat mul(const mat &a,const mat &b){\n  int n=a.size();\n  vector<vector<int> > tmp(n,vector<int>(n,0));\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      for(int k=0;k<n;k++)\n\ttmp[i][j]+=(a[i][k]&b[k][j]);\n  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      res[i][j]=tmp[i][j]&1;\n  \n  return res;\n}\n\nmat mat_pow(mat v,int k){\n  int n=v.size();\n  mat res(n,BS(0));\n  for(int i=0;i<n;i++)\n    res[i][i]=1;\n  while(k){\n    if(k&1) res=mul(res,v);\n    v=mul(v,v);\n    k>>=1;\n  }\n  return res;\n}\n\n//END CUT HERE\nsigned CFR382_D(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m;\n  cin>>n>>m;\n  mat v(n,BS(0));\n  for(Int i=0;i<n;i++) v[i][n+i]=1;\n  vector<Int> a(m),b(m);\n  for(Int i=0;i<m;i++){\n    cin>>a[i]>>b[i];\n    a[i]--;b[i]--;\n    v[a[i]][b[i]]=1;\n  }\n  gauss(v);\n  for(Int i=0;i<m;i++)\n    cout<<(v[b[i]][a[i]+n]?\"NO\":\"YES\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://codeforces.com/contest/736/problem/D\n*/\n\nsigned ARC054_D(){\n  int n;\n  cin>>n;\n  mat v(n,BS(0));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      char c;\n      cin>>c;\n      v[i][j]=c-'0';\n    }\n  }\n  gauss(v);\n  int ans=1;\n  for(int i=0;i<n;i++) ans&=v[i][i];\n  cout<<(ans?\"Odd\":\"Even\")<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/22\nhttps://beta.atcoder.jp/contests/arc054/tasks/arc054_c\n*/\n\nsigned AOJ_1308(){\n  int m,n,d;\n  while(cin>>m>>n>>d,m){\n    vector<vector<int> > s(n,vector<int>(m));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tcin>>s[i][j];\n\n    mat v(n*m,BS(0));\n    auto idx=[&](int y,int x){return y*m+x;};\n    auto in=[&](int y,int x){return 0<=y&&y<n&&0<=x&&x<m;};\n    auto bfs=[&](int y,int x){\n      int z=idx(y,x);\n      v[z][z]=1;\n      v[z][n*m]=s[y][x];\n      \n      vector<vector<int> > dp(n,vector<int>(m,-1));\n      using P = pair<int, int>;\n      queue<P> q;\n      dp[y][x]=0;\n      q.emplace(y,x);\n      int dy[]={0,0,1,-1};\n      int dx[]={1,-1,0,0};\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(dp[y][x]==d) v[z][idx(y,x)]=1;\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=dp[y][x]+1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n    \n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    int a=mrank(v,n*m);\n    int b=mrank(v,n*m+1);\n    cout<<(a==b)<<endl;\n  }\n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1308\n*/\n\nsigned AOJ_2624(){\n  int n;\n  cin>>n;\n  mat v(n,BS(0));\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      int k;\n      cin>>k;\n      v[i][j]=k;\n    }\n  }\n  BS w;\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    w[i]=k;\n  }\n  int t;\n  cin>>t;\n  v=mat_pow(v,t);\n\n  int a=mrank(v,n);\n  for(int i=0;i<n;i++) v[i][n]=w[i];\n  int b=mrank(v,n+1);\n\n  if(a!=b){\n    cout<<\"none\"<<endl;\n    return 0;\n  }\n\n  if(a!=n){\n    cout<<\"ambiguous\"<<endl;\n    return 0;\n  }\n  \n  gauss(v);\n  for(int i=0;i<n;i++) cout<<v[i][n]<<\" \\n\"[i==n-1];\n  \n  return 0;\n}\n/*\nverified on 2018/01/22\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2624\n*/\n\n\n\nsigned main(){\n  //CFR382_D();\n  //ARC054_D();\n  AOJ_1308();\n  //AOJ_2624();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <algorithm>\n#define coor(i,j) ((i)+(j)*m)\n#define in(i,j) (0<=(i)&&(i)<m&&0<=(j)&&(j)<n)\nusing namespace std;\nvector<bitset<626> > M(625);\nmain(){\n\tint m,n,d;\n\tint i,j,k;\n\tint success,ans;\n\tfor(;cin>>m>>n>>d,d;cout<<ans<<endl){\n\t\tfor(j=0;j<n;j++)\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tM[coor(i,j)].reset();\n\t\t\t\tM[coor(i,j)][coor(i,j)]=1;\n\t\t\t\tcin>>k;M[coor(i,j)][m*n]=k;\n\t\t\t\tfor(k=0;k<=d;k++){\n\t\t\t\t\tif(in(i-k,j-(d-k)))M[coor(i,j)][coor(i-k,j-(d-k))]=1;\n\t\t\t\t\tif(in(i+k,j-(d-k)))M[coor(i,j)][coor(i+k,j-(d-k))]=1;\n\t\t\t\t\tif(in(i-k,j+(d-k)))M[coor(i,j)][coor(i-k,j+(d-k))]=1;\n\t\t\t\t\tif(in(i+k,j+(d-k)))M[coor(i,j)][coor(i+k,j+(d-k))]=1;\n\t\t\t\t}\n\t\t\t}\n\t\tk=0;\n\t\tfor(i=0;i<m*n;i++){\n\t\t\tfor(j=k;j<m*n&&!M[j][i];j++);\n\t\t\tif(j==m*n)continue;\n\t\t\tswap(M[k],M[j]);\n\t\t\tfor(j=k+1;j<m*n;j++)if(M[j][i])M[j]^=M[k];\n\t\t\tk++;\n\t\t}\n\t\tans=1;\n\t\tfor(j=0;j<m*n;j++)if(M[j][m*n]&&M[j].count()==1)ans=0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[]={-1,0,1,0},dx[]={0,-1,0,1},dy2[]={1,-1,-1,1},dx2[]={1,1,-1,-1};\nint m,n,d,s[25][25];\nint main()\n{\n\twhile(cin>>m>>n>>d,m){\n\t\tint N=m*n;\n\t\tvector<vi> a(N,vi(N+1,0));\n\t\trep(i,m)rep(j,n)cin>>s[i][j], a[i*n+j][N]=s[i][j];\n\t\t\n\t\trep(i,N)(a[i][i]+=1)%=2;\n\t\trep(i,m)rep(j,n)rep(dir,4)rep(k,d){\n\t\t\tint y=i+dy[dir]*d+dy2[dir]*k, x=j+dx[dir]*d+dx2[dir]*k;\n\t\t\tif(0<=y&&y<m&&0<=x&&x<n){\n\t\t\t\t(a[y*n+x][i*n+j]+=1)%=2;\n\t\t\t}\n\t\t}\n\t\tint j=0;\n\t\trep(i,N){\n\t\t\tswap(a[i],*max_element(a.begin()+i,a.end()));\n\t\t\tfor(;j<N&&a[i][j]==0;j++);\n\t\t\tif(j<N&&a[i][j]){\n\t\t\t\trep(k,N)if(i<k&&a[k][j])rep(l,N+1)(a[k][l]+=a[i][l])%=2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool ok=1; j=0;\n\t\trep(i,N)if(ok&&a[i][N]){\n\t\t\tfor(;j<N&&a[i][j]==0;j++);\n\t\t\tif(j>=N)ok=0;\n\t\t}\n\t\tcout<<(int)ok<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//      whn6325689\n//\t\tMr.Phoebe\n//\t\thttp://blog.csdn.net/u013007900\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <climits>\n#include <complex>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef complex<ld> point;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef vector<int> vi;\n\n#define CLR(x,y) memset(x,y,sizeof(x))\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define lowbit(x) (x&(-x))\n#define MID(x,y) (x+((y-x)>>1))\n#define eps 1e-9\n#define PI acos(-1.0)\n#define INF 0x3f3f3f3f\n#define LLINF 1LL<<62\n\ntemplate<class T>\ninline bool read(T &n)\n{\n    T x = 0, tmp = 1;\n    char c = getchar();\n    while((c < '0' || c > '9') && c != '-' && c != EOF) c = getchar();\n    if(c == EOF) return false;\n    if(c == '-') c = getchar(), tmp = -1;\n    while(c >= '0' && c <= '9') x *= 10, x += (c - '0'),c = getchar();\n    n = x*tmp;\n    return true;\n}\ntemplate <class T>\ninline void write(T n)\n{\n    if(n < 0)\n    {\n        putchar('-');\n        n = -n;\n    }\n    int len = 0,data[20];\n    while(n)\n    {\n        data[len++] = n%10;\n        n /= 10;\n    }\n    if(!len) data[len++] = 0;\n    while(len--) putchar(data[len]+48);\n}\n//-----------------------------------\n\nconst int MAXN=26*26;\n\nint b[MAXN][MAXN],ans[MAXN];\nint a[MAXN][MAXN];\n\nint Guass(int n)\n{\n\tint i,j,p,row=0,col=0;\n\tfor(;row<n&&col<n;row++,col++)\n\t{\n\t\tfor(i=row,p=row;i<n;i++)\n\t\t\tif(a[i][col])\n\t\t\t{p=i;break;}\n\t\tif(p!=row)\n\t\t\tfor(j=col;j<=n;j++)\n\t\t\t\tswap(a[p][j],a[row][j]);\n\t\tif(!a[row][col]) \n\t\t{\n\t\t\trow--;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i=row+1;i<n;i++)\n\t\t\tif(a[i][col])\n\t\t\tfor(j=col+1;j<=n;j++)\n\t\t\t\ta[i][j]^=a[row][j];\n\t}\n\tfor(i=row;i<n;i++)\n\t\tif(a[i][n]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n//\tfreopen(\"data.txt\",\"r\",stdin);\n\tint n,m,d;\n\twhile(read(m)&&read(n)&&read(d)&&(n+m+d))\n\t{\n\t\tCLR(a,0);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\tread(b[i][j]);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\ta[i*m+j][n*m]=b[i][j];\n\t\t\t\ta[i*m+j][i*m+j]=1;\n\t\t\t\tfor(int x=0;x<n;x++)\n\t\t\t\t\tfor(int y=0;y<m;y++)\n\t\t\t\t\t\tif(abs(x-i)+abs(y-j)==d)\n\t\t\t\t\t\t\ta[i*m+j][x*m+y]=1;\n\t\t\t}\n\t\tif(Guass(n*m))\n\t\t\tputs(\"1\");\n\t\telse\n\t\t\tputs(\"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 0 or 1 の世界の連立方程式ということはわかるが、これを実装するということか。。。\n\nusing D = double;\nconst D EPS = 1e-10;\n\n// matrix\ntemplate <class T>\nstruct Matrix\n{\n    vector<vector<T>> val;\n    Matrix(int n, int m, T x = 0) : val(n, vector<T>(m, x)) {}\n    void init(int n, int m, T x = 0) { val.assign(n, vector<T>(m, x)); }\n    size_t size() const { return val.size(); }\n    inline vector<T> &operator[](int i) { return val[i]; } // Matrix[][]でアクセスするため。\n};\n\ntemplate <class T>\nint GaussJordan(Matrix<T> &A, bool is_extended = false)\n{\n    int m = A.size(), n = A[0].size();\n    int rank = 0;\n    for (int col = 0; col < n; ++col)\n    {\n        // 拡大係数行列の場合は最後の列は掃き出ししない\n        if (is_extended && col == n - 1)\n            break;\n\n        // ピボットを探す\n        int pivot = -1;\n        T ma = EPS;\n        for (int row = rank; row < m; ++row)\n        {\n            if (abs(A[row][col]) > ma)\n            {\n                ma = abs(A[row][col]);\n                pivot = row;\n            }\n        }\n        // ピボットがなかったら次の列へ\n        if (pivot == -1)\n            continue;\n\n        // まずは行を swap\n        swap(A[pivot], A[rank]);\n\n        // // ピボットの値を 1 にする // 2進法なら不要\n        // auto fac = A[rank][col];\n        // for (int col2 = 0; col2 < n; ++col2)\n        //     A[rank][col2] /= fac;\n\n        // ピボットのある列の値がすべて 0 になるように掃き出す\n        for (int row = 0; row < m; ++row)\n        {\n            if (row != rank && abs(A[row][col]) > EPS)\n            {\n                //auto fac = A[row][col];// 2進法なら不要\n                for (int col2 = 0; col2 < n; ++col2)\n                {\n                    A[row][col2] -= A[rank][col2];// * fac; // 2進法ならfac不要\n                    if (A[row][col2] == -1) A[row][col2] = 1; // 2進法\n                }\n            }\n        }\n        ++rank;\n    }\n    return rank;\n}\n\ntemplate <class T>\nvector<T> linear_equation(Matrix<T> A, vector<T> b)\n{\n    // extended\n    int m = A.size(), n = A[0].size();\n    Matrix<T> M(m, n + 1);\n    for (int i = 0; i < m; ++i)\n    {\n        for (int j = 0; j < n; ++j)\n            M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    vector<T> res;\n    for (int row = rank; row < m; ++row)\n    {\n        if (abs(M[row][n]) > EPS)\n        {\n            return res;\n        }\n    }\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i)\n        res[i] = M[i][n];\n\n    return res;\n}\n\nint main(void)\n{  \n    vector<int> answer;\n    while (1)\n    {\n        int m, n, d;\n        cin >> m >> n >> d;\n        if (0 == m + n + d)\n        {\n            break;\n        }\n        Matrix<int> mat(n * m, n * m);\n        vector<int> vec(n * m);\n        for (int j = 0; j < n; j++)\n        {\n            for (int i = 0; i < m; i++)\n            {\n                cin >> vec[i + (j * m)];\n                //vec[i + (j * m)] = 1 - vec[i + (j * m)];\n                mat[i + (j * m)][i + (j * m)] = 1;\n                for (int k = 0; k < m; ++k) {\n                    for (int l = 0; l < n; ++l) {\n                        if (abs(i - k) + abs(j - l) != d) continue;\n                        mat[i + (j * m)][k + (l * m)] = 1;\n                    }\n                }\n            }\n        }\n\n        auto ans = linear_equation(mat, vec);\n\n        answer.push_back((0 == ans.size())?0:1);\n    }\n\n    for (auto i = answer.begin(); i < answer.end(); i++)\n    {\n        cout << *i << endl;\n    } \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n#define EPS (1e-9)\n\n// KEXÌÁ@ÅA§®ðÆ­\nbool gauss_jordan(const mat&A,const vec &b){\n    int n=A.size();\n    mat B(n,vec(n+1));\n    for(int i = 0; i < n;i++)\n        for(int j=0;j<n;j++)\n            B[i][j]=A[i][j];\n    for(int i = 0; i < n; i++)\n        B[i][n]=b[i];\n    // eÏÉÚ\n    for(int i = 0; i < n; i++){\n        // ÅåÌWÌâÎlðàÂàÌðiÔÚÉÁÄ­é\n        int piv=-1;\n        int val=-1;\n        for(int j=i;j<n;j++){\n            if(val<abs(B[j][i])){\n                piv=j;\n                val=abs(B[j][i]);\n            }\n        }\n        // EÓª0ÉÈé©Ç¤©²×é\n        if(piv==-1||val<=0)\n            continue;\n        swap(B[piv],B[i]);\n        for(int j = 0; j < n; j++){\n            if(i==j)continue;\n            int mulnum=B[j][i];\n            if(mulnum==1){\n                for(int k = i; k <= n; k++)\n                    B[j][k]=(B[j][k]+B[i][k])%2;\n            }\n        }\n    }\n    vec res(n);\n    for(int i = 0; i < n; i++){\n        res[i]=B[i][n];\n        if(B[i][i]==0){\n            if(B[i][n]==1)return false;\n        }\n    }\n    return true;\n}\nint M,N,D;\nint field[101][101];\n\nint main(){\n\n    while(cin>>M>>N>>D&&(M|N|D)){\n        for(int i=0;i<N;i++)for(int j=0;j<M;j++)cin>>field[i][j];\n        mat A(M*N,vec(M*N));\n        vec B(M*N,0);\n        for(int i=0;i<N;i++){\n            for(int j=0;j<M;j++){\n                if(field[i][j])B[i*M+j]=1;\n                for(int k=0;k<N;k++){\n                    for(int l=0;l<M;l++){\n                        // }nb^£\n                        int dist=abs(l-j)+abs(i-k);\n                        if(dist==D||dist==0)A[i*M+j][k*M+l]=1;\n                    }\n                }\n            }\n        }\n        bool res=gauss_jordan(A,B);\n        if(res)cout<<1<<endl;\n        else cout<<0<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ntypedef valarray<int> vec;\ntypedef valarray<vec> mat;\n\nbool check(mat &a){\n\tint n=a.size(),m=a[0].size();\n\tint r=0,c=0;\n\trep(i,n-1){\n\t\tint index=-1;\n\n\t\twhile(c<m&&index==-1){\n\t\t\trange(j,i,n) if(a[j][c]) index=j;\n\t\t\tif(index==-1)\n\t\t\t\tc++;\n\t\t\telse if(i!=index)\n\t\t\t\tswap(a[i],a[index]);\n\t\t}\n\t\tif(index==-1) break;\n\n\t\trange(j,i+1,n){\n\t\t\tint d=a[j][c]/a[i][c];\n\t\t\trange(k,c,m){\n\t\t\t\ta[j][k]+=a[i][k]*d;\n\t\t\t\ta[j][k]%=2;\n\t\t\t}\n\t\t}\n\t\tc++;\n\t}\n\tint rank=0,add=0;\n\tr=0,c=0;\n\twhile(r<n&&c<m-1){\n\t\twhile(c<m-1&&a[r][c]==0) c++;\n\t\tif(c==m-1) break;\n\t\trank++,r++;\n\t\twhile(r<n&&a[r][c]!=0) r++;\n\t\tif(r==n) break;\n\t}\n\n\tif(r<n) range(i,r,n) if(a[i][m-1]!=0) add=1;\n\treturn !add;\n}\n\n\nint main(void){\n\tint m,n,d;\n\twhile(cin >> m >> n >> d){\n\t\tint num=m*n;\n\t\tif(num==0) break;\n\t\tmat state(vec(0,num+1),num);\n\t\trep(i,n)rep(j,m){\n\t\t\tint row=i*m+j;\n\t\t\trep(a,n)rep(b,m){\n\t\t\t\tint col=a*m+b;\n\t\t\t\tint dist=abs(i-a)+abs(j-b);\n\t\t\t\tif(dist==d) state[row][col]=1;\n\t\t\t}\n\t\t\tstate[row][row]=1;\n\t\t\tcin >> state[row][num];\n\t\t}\n\t\tcout << check(state) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n// ??£???????¬?????¨????????§£???\ntypedef vector<int> nvector;\ntypedef vector<nvector> matrix;\nconst double eps = 1e-9;\nbool gauss_jordan(const matrix& A, const nvector& b)\n{\n  int n = A.size();\n  // ?????§?????°??????\n  matrix Ab(n, nvector(n + 1));\n  for(int i = 0; i < n; i++) {\n    for(int j = 0; j < n; j++) Ab[i][j] = A[i][j];\n  }\n  for(int i = 0; i < n; i++) Ab[i][n] = b[i];\n\n  // ?§£???\n  for(int i = 0; i < n; i++) {\n    int pivot = i;\n    for(int j = i; j < n; j++) {\n      if(abs(Ab[pivot][i]) < abs(Ab[j][i])) pivot = j;\n    }\n    swap(Ab[i], Ab[pivot]);\n    if(abs(Ab[i][i]) <= 0) continue;//return nvector();\n    // ?????????????????°??§??????\n    // for(int j = i+1; j < n+1; j++) Ab[i][j] /= Ab[i][i];\n    // ????????????\n    for(int j = 0; j < n; j++) {\n      if(i != j && Ab[j][i] == 1) {\n\tfor(int k = i; k < n+1; k++) Ab[j][k] = (Ab[j][k] + Ab[i][k]) % 2;\n      }\n    }\n  }\n\n  // ?§£\n  //nvector x(n);\n  for(int i = 0; i < n; i++) {\n    //x[i] = Ab[i][n];\n    if(Ab[i][i] == 0 && Ab[i][n] == 1) return false;\n  }\n\n  return true;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int m, n, d;\n  int S[30][30];\n  while(cin >> m >> n >> d, m) {\n    rep(i, n) rep(j, m) cin >> S[i][j];\n\n    matrix A(m*n, nvector(m*n, 0));\n    rep(i, n) rep(j, m) {\n      A[i*m+j][i*m+j] = 1;\n      rep(k, n) rep(l, m) {\n\tint dist = abs(j - l) + abs(i - k);\n\tif(dist == d) A[i*m+j][k*m+l] = 1;\n      }\n    }\n\n    nvector b(m*n, 0);\n    rep(i, n) rep(j, m) b[i*m+j] = S[i][j];\n\n    cout << (int)gauss_jordan(A, b) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\nconst int MAX_ROW = 625; // to be set appropriately\nconst int MAX_COL = 625; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) { }\n    bitset<MAX_COL>& operator[] (int i) { return val[i]; }\n};\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) { pivot = row; break; }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);          // augmented matrix (A|B)\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n    // check if it has no solution\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n};\n\nint main() {\n    int m, n, d;\n    while (cin >> m >> n >> d, m) {\n        vector<vector<int>> a(n, vector<int>(m));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) cin >> a[i][j];\n        }\n        BitMatrix A(m * n, m * n);\n        vector<int> b(m * n, 0), res;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                A[i * m + j][i * m + j] = 1;\n                for (int k = 0; k < n; k++) {\n                    for (int l = 0; l < m; l++) {\n                        if (abs(i - k) + abs(j - l) != d) continue;\n                        A[k * m + l][i * m + j] = 1;\n                    }\n                }\n                b[i * m + j] = a[i][j];\n            }\n        }\n        int rank = linear_equation(A, b, res);\n        cout << (rank != -1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\nint W,H,D,a[625][625],b[625];\nint id(int i,int j){\n\treturn i*W+j;\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H>>D;\n\t\tif(W==0) break;\n\t\trep(i,H) rep(j,W) cin>>b[id(i,j)];\n\t\trep(i,H) rep(j,W) rep(k,H) rep(h,W){\n\t\t\ta[id(k,h)][id(i,j)]=0;\n\t\t\tint d=abs(i-k)+abs(j-h);\n\t\t\tif(d==D||d==0) a[id(k,h)][id(i,j)]=1;\n\t\t}\n\t\tbool used[625]={};\n\t\tint eq=H*W;\n\t\trep(j,eq){\n\t\t\tint i=0;\n\t\t\twhile(i<eq && (used[i]||a[i][j]==0)) i++;\n\t\t\tif(i==eq) continue;\n\t\t\tused[i]=true;\n\t\t\trep(k,eq){\n\t\t\t\tif(i==k) continue;\n\t\t\t\tif(a[k][j]==0) continue;\n\t\t\t\trep(l,eq) a[k][l]^=a[i][l];\n\t\t\t\tb[k]^=b[i];\n\t\t\t}\n\t\t}\n\t\tbool can=true;\n\t\trep(i,eq) if(!used[i]&&b[i]!=0) can=false;\n\t\tcout<<can<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint M,N,D;\n\n\nvoid view( const mat& a ){\n  cout << \"mat view\" << endl;\n  for(int i=0;i<(int)a.size();i++){\n    for(int j=0;j<(int)a[i].size();j++) cout << a[i][j] << \" \";\n    cout << endl;\n  }\n}\nvoid view( const vec& a ){\n  cout<<\"vec view\" << endl;\n  for( int i : a ){\n    cout <<i <<  \" \";\n  }\n  cout << endl;\n}\n\nint getid(int y,int x){\n  return y+x*N;\n}\n\nvec mod_gauss_jordan( const mat &A, const vec& b ){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for( int i=0;i<n;i++ )\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n  \n  //view( B );\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if( B[j][i]>B[pivot][i] ) pivot = j;\n    swap(B[pivot],B[i]);\n    \n    //if( B[i][i] < 1 ) return vec();\n\n    for(int j=0;j<n;j++)\n      if( i != j && B[j][i] )\n        for(int k=i;k<=n;k++){\n          B[j][k] = (B[j][k] + B[i][k])%2;            \n        }\n    \n    //cout << \"in \" << i << endl;\n    //view( B );\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n\n  for(int i=0;i<n;i++){\n    int p = 0;\n    for(int j=0;j<n;j++){\n      //cout << A[i][j]<<  \" : \"<< x[j] << endl;\n      if( A[i][j] ) p = (p+x[j])%2;\n    }\n    //cout << p << \" = \" << b[i] << endl;\n    if( p!=b[i] ) return vec();\n    assert( p==b[i] );\n  }\n  return x;\n}\n\n\nint main(){\n  while( cin >> M >> N >> D && (M||N||D) ){\n    int S[30][30];\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)\n        cin >> S[i][j];\n\n    mat mt = mat(N*M);\n    for(int i=0;i<N;i++){\n      for(int j=0;j<M;j++){\n        vec V = vec(N*M,0);\n        for(int y=0;y<N;y++){\n          for(int x=0;x<M;x++){\n            int d = abs(y-i) + abs(x-j);\n            if( d == D ) \n              V[getid(y,x)] = 1;            \n          }\n        }        \n        V[getid(i,j)] = 1;\n        assert( getid(i,j)%N == i && getid(i,j)/N == j );\n        mt[getid(i,j)] = V;\n      }\n    }\n    vec B = vec( N*M );\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)\n        if( S[i][j] == 1 ) B[getid(i,j)] = 1;\n\n    //view(mt);\n    //view(B);\n    vec res = mod_gauss_jordan( mt, B );\n    if( res.empty() ) cout << 0 << endl;\n    else {\n      cout << 1 << endl;\n      for(int i=0;i<N*M;i++){\n        int iy = i%N, ix = i/N;\n        assert( getid(iy,ix) == i );\n        if( res[i] ){  \n          S[iy][ix] = 1-S[iy][ix];\n          for(int y=0;y<N;y++)\n            for(int x=0;x<N;x++)\n              if( D == abs( y-iy ) + abs( x-ix )  )\n                S[y][x] = 1-S[y][x];\n        }\n      }/*\n      for(int i=0;i<N;i++){\n        for(int j=0;j<M;j++) cout << S[i][j];\n        cout << endl;\n        }*/\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint solve(vector< vector<int> > mat,vector<int> A){\n\tint n = mat.size();\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint p = -1;\n\t\tfor(int j = i ; j < n ; j++){\n\t\t\tif( mat[j][i] == 1 ){\n\t\t\t\tp = i;\n\t\t\t\tswap(A[i],A[j]);\n\t\t\t\tfor(int k = 0 ; k < n ; k++)\n\t\t\t\t\tswap(mat[i][k],mat[j][k]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif( p == -1 ) continue;\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tif( mat[j][i] == 1 && j != p ){\n\t\t\t\tA[j] ^= A[p];\n\t\t\t\tfor(int k = 0 ; k < n ; k++){\n\t\t\t\t\tmat[j][k] ^= mat[p][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint answer = 0;\n\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\tif( mat[i][j] ) answer++;\n\t\t}\n\t\tif( answer == 0 && A[i] == 1 ) return 0;\n\t}\n\treturn 1;\n\t\n\t\n}\nint main(){\n\tint W,H,K;\n\twhile(cin >> W >> H >> K && W){\n\t\tvector<int> A(W*H);\n\t\tfor(int i = 0 ; i < H ; i++)\n\t\t\tfor(int j = 0 ; j < W ; j++)\n\t\t\t\tcin >> A[i*W+j];\n\t\t\n\t\tvector< vector<int> > mat(H*W,vector<int>(H*W));\n\t\tfor(int i = 0 ; i < H ; i++){\n\t\t\tfor(int j = 0 ; j < W ; j++){\n\t\t\t\tfor(int k = 0 ; k < H ; k++){\n\t\t\t\t\tfor(int l = 0 ; l < W ; l++){\n\t\t\t\t\t\tint d = abs(i-k) + abs(j-l);\n\t\t\t\t\t\tif( d == K || d == 0 ){\n\t\t\t\t\t\t\tmat[i*W+j][k*W+l] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << solve(mat,A) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAXN = 25*25;\n\nbool gaussian_elimination(int a[MAXN][MAXN], int b[MAXN], int N)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; a[i][i] == 0 && j < N; j++) {\n      for (int k = 0; k < N; k++) {\n        swap(a[i][k], a[j][k]);\n      }\n      swap(b[i], b[j]);\n    }\n    if (a[i][i] == 0) {\n      continue;\n    }\n\n    for (int j = 0; j < N; j++) {\n      if (i == j) {\n        continue;\n      }\n      const int u = a[j][i];\n      if (u != 0) {\n        for (int k = i; k < N; k++) {\n          a[j][k] ^= a[i][k];\n        }\n        b[j] ^= b[i];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (a[i][i] == 0 && b[i] != 0) {\n      // no solution\n      return false;\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int M, N, D;\n  while (scanf(\"%d %d %d\", &M, &N, &D) != EOF && M != 0) {\n    static int a[MAXN][MAXN];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        a[M*i+j][M*i+j] = 1;\n        for (int k = 0; k < N; k++) {\n          for (int l = 0; l < M; l++) {\n            const int t = abs(i-k) + abs(j-l);\n            a[M*i+j][M*k+l] = (t == D || t == 0);\n          }\n        }\n      }\n    }\n\n    static int b[MAXN];\n    for (int i = 0; i < N*M; i++) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    printf(\"%d\\n\", gaussian_elimination(a, b, M*N));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n\nvoid func(const mat &A){\n  for(int i=0;i<(int)A.size();i++){\n    for(int j=0;j<(int)A[i].size();j++){\n      cout<<A[i][j];\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n}\n\nbool gauss_jordan(const mat& A, const vec& b) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      B[i][j]=A[i][j];\n  for(int i=0;i<n;i++)B[i][n]=b[i];\n\n  for(int i=0;i<n;i++) {\n    //    cout<<i<<endl;\n    //    func(B);\n    int pivot=i;\n    for(int j=i;j<n;j++){\n      if(B[j][i]>0){\n        pivot=j;\n        break;\n      }\n    }\n    swap(B[i], B[pivot]);\n    //    cout<<pivot<<' '<<'?'<<endl;\n    //    func(B);\n    if(B[i][i]==0)continue;\n    for(int j=0;j<n;j++){\n      if(i==j||B[j][i]==0)continue;\n      for(int k=0;k<=n;k++){\n        B[j][k]+=B[i][k];\n        B[j][k]%=2;\n      }\n    }\n  }\n  // func(B);\n  for(int i=0;i<n;i++){\n    if(B[i][i]==0&&B[i][n]>0)return false;\n  }\n  return true;\n}\n\nint n,m,d;\nint t[30][30];\n\nint main(){\n    while(1){\n    cin>>m>>n>>d;\n    if(n==0&&m==0&&d==0)break;\n    mat A(n*m,vec(n*m,0));\n    vec B(n*m);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n        cin>>t[i][j];\n        B[i*m+j]=t[i][j];\n        A[i*m+j][i*m+j]=1;\n        for(int k=0;k<n;k++){\n          for(int l=0;l<m;l++){\n            if(abs(i-k)+abs(j-l)==d){\n              A[i*m+j][k*m+l]=1;\n            }\n          }\n        }\n      }\n    }\n    cout<<gauss_jordan(A,B)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <valarray>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint M, N, D;\n\nint solve(valarray<valarray<int> >& A) {\n    int p = 0;\n    for (int i = 0; i < M*N; i++) {\n        int r;\n        for (r = p; r < M*N; r++) {\n            if (A[r][i] != 0) break;\n        }\n        if (r == M*N) continue;\n        swap(A[p], A[r]);\n        for (int j = p+1; j < M*N; j++) {\n            if (A[j][i]) {\n                A[j] += A[p];\n                A[j] %= 2;\n            }\n        }\n        p++;\n    }\n    for (int r = 0; r < M*N; r++) {\n        if (A[r][M*N] != 0) {\n            int i;\n            for (i = 0; i < M*N; i++) {\n                if (A[r][i] != 0) break;\n            }\n            if (i == M*N) return 0;\n        }\n    }\n    return 1;\n}\n\nint main(void) {\n    while (cin >> M >> N >> D && M) {\n        valarray<valarray<int> > A(valarray<int>(0, M*N+1), M*N);\n        for (int i = 0; i < M*N; i++) {\n            cin >> A[i][M*N];\n            int x0 = i % M, y0 = i / M;\n            for (int j = 0; j < M*N; j++) {\n                int x1 = j%M, y1 = j/M;\n                int d = abs(x0 - x1) + abs(y0 - y1);\n                if (d == 0 || d == D) A[i][j] = 1;\n            }\n        }\n        cout << solve(A) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, m, d;\nbool mat[650][650];\nbool a[25][25];\n\nbool valid(int x, int y)\n{\n    if(x < n && x >= 0 && y < m && y >= 0) return true;\n    return false;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d%d\", &n, &m, &d), n + m + d)\n    {\n        memset(mat, 0, sizeof mat);\n\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < m; j++)\n                scanf(\"%d\", &a[i][j]);\n\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < m; j++)\n            {\n                for(int k = 0; k <= d; k++)\n                {\n                    int t1x = i + k, t1y = j + d - k;\n                    int t2x = i - k, t2y = j + d - k;\n                    int t3x = i + k, t3y = j - d + k;\n                    int t4x = i - k, t4y = j - d + k;\n                    if(valid(t1x, t1y)) mat[t1x * m + t1y][i * m + j] = 1;\n                    if(valid(t2x, t2y)) mat[t2x * m + t2y][i * m + j] = 1;\n                    if(valid(t3x, t3y)) mat[t3x * m + t3y][i * m + j] = 1;\n                    if(valid(t4x, t4y)) mat[t4x * m + t4y][i * m + j] = 1;\n                }\n                mat[i * m + j][i * m + j] = 1;\n            }\n        }\n\n        int flag = 0, pivot = 0;\n\n        for(int i = 0; i < n * m; i++)\n            mat[i][n * m] = a[i / m][i % m];\n\n        int ansl = 0, matl = 0;\n        int row = n * m, col = n * m + 1;\n        for(int i = 0; i < col - 1; i++)\n        {\n            int pt = pivot;\n            while(mat[pt][i] == 0 && pt < row) pt++;\n            if(pt >= row) continue;\n            for(int j = 0; j < col; j++) swap(mat[pivot][j], mat[pt][j]);\n            for(int j = pivot + 1; j < row; j++)\n                if(mat[j][i] == 1)\n                    for(int k = i; k < col; k++)\n                        mat[j][k] ^= mat[pivot][k];\n            pivot++;\n        }\n\n        for(int u = row - 1; u >= 0; u--)\n        {\n            int fla = 0;\n            for(int v = 0; v < col - 1; v++)\n                if(mat[u][v] == 1) fla = 1;\n            if(fla == 0 && mat[u][col - 1] == 1)\n            {\n                flag = 1;\n                break;\n            }\n        }\n        printf(\"%d\\n\", flag ^ 1);\n    }\n    return 0;\n}\n\n/*\n1 1 1\n0\n4 4 2\n1 1 0 1\n0 0 0 1\n1 0 1 1\n1 0 0 0\n2 2 1\n1 1\n1 1\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\nusing namespace std;\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\n\nconst int MAX_ROW = 1010; // to be set appropriately\nconst int MAX_COL = 1010; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\n\nostream& operator << (ostream& s, BitMatrix A) {\n    s << endl; \n    for (int i = 0; i < A.H; ++i) {\n        for (int j = 0; j < A.W; ++j) {\n            s << A[i][j] << \", \";\n        }\n        s << endl;\n    }\n    return s;\n}\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n};\n\n\n\nint main() {\n    int N, M, D;\n    while (cin >> M >> N >> D, N) {\n        vector<vector<int> > a(N, vector<int>(M, 0));\n        for (int i = 0; i < N; ++i) for (int j = 0; j < M; ++j) cin >> a[i][j];\n\n        BitMatrix A(N*M, N*M);\n        vector<int> b(N*M, 0), res;\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < M; ++j) {\n                A[i*M+j][i*M+j] = 1;\n                for (int k = 0; k < N; ++k) {\n                    for (int l = 0; l < M; ++l) {\n                        if (abs(i - k) + abs(j - l) != D) continue;\n                        A[i*M+j][k*M+l] = 1;\n                    }\n                }\n                b[i*M+j] = 1 - a[i][j];\n            }\n        }\n        int rank = linear_equation(A, b, res);\n        if (rank == -1) cout << 0 << endl;\n        else cout << 1 << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint width, height, d;\nint matrix[1000][1000];\nint vect[1000];\n\nbool gauss() {\n  int n = width * height;\n  int target = 0;\n  REP(x, n) {\n    int pivot = target;\n    FOR(i, target + 1, n) {\n      if (matrix[i][x] > matrix[pivot][x]) { pivot = i; break; }\n    }\n    if (matrix[pivot][x] == 0) { continue; }\n    REP(i, n) { swap(matrix[pivot][i], matrix[target][i]); }\n    swap(vect[target], vect[pivot]);\n    FOR(y, target + 1, n) {\n      if (matrix[y][x] == 0) { continue; }\n      FOR(i, x, n) {\n        matrix[y][i] ^= matrix[target][i];\n      }\n      vect[y] ^= vect[target];\n    }\n    target++;\n  }\n  for (int y = target; y < n; y++) {\n    if (vect[y] == 1) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &width, &height, &d), width|height|d) {\n    MEMSET(matrix, 0);\n    MEMSET(vect, 0);\n    REP(y, height) {\n      REP(x, width) {\n        scanf(\"%d\", &vect[y * width + x]);\n      }\n    }\n    REP(y1, height) {\n      REP(x1, width) {\n        REP(y2, height) {\n          REP(x2, width) {\n            if ((x1 == x2 && y1 == y2) || abs(x1 - x2) + abs(y1 - y2) == d) {\n              matrix[y1 * width + x1][y2 * width + x2] = 1;\n            }\n          }\n        }\n      }\n    }\n\n    if (gauss()) {\n      puts(\"1\");\n    } else {\n      puts(\"0\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\n#ifdef _DEBUG\n#define DEBUG WRITE\ninline void readfrom(string filename) { freopen(filename.c_str(), \"r\", stdin); }\ninline void writeto(string filename) { freopen(filename.c_str(), \"w\", stdout); }\n#else\n#define DEBUG(...)\ninline void readfrom(...) { }\ninline void writeto(...) { }\n#endif\n#ifdef ccout\n#  define cout ccout\n#  define endl cendl\n#endif\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, const pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << \"\";\n\tauto s = ss.str();\n\tout << s.substr(0, s.length());\n\treturn out;\n}\n\n//// start up ////\nvoid solve();\n\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n// MODを法としたint\ntemplate <int MOD>\nstruct modint\n{\n\ttypedef int T;\n\ttypedef long DBL_T;\n\n\tT v;\n\tmodint(T v = 0) : v(mod(v)) { }\n\tbool operator == (modint i) const { return v == i.v; }\n\tbool operator != (modint i) const { return !(*this == i); }\n\n\tmodint operator +(modint i) const { return modint(v + i.v); }\n\tmodint operator -(modint i) const { return modint(v - i.v); }\n\tmodint& operator -=(modint i) { *this = *this - i; return *this; }\n\n\tmodint operator *(modint i) const { return FromValue((DBL_T)v * i.v % MOD); }\n\tstatic T mod(T v) { return v %= MOD, v < 0 ? v + MOD : v; }\n\n};\ntemplate <int MOD> ostream & operator << (ostream &out, modint<MOD> v) { out << v.v; return out; }\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, m, n, d);\n\t\tif (!(m | n | d)) { break; }\n\n\t\tint N = n * m;\n\t\ttypedef modint<2> I;\n\t\tvevector<I> x(N, N + 1);\n\t\t\n\t\tREP(i, n) REP(j, m)\n\t\t{\n\t\t\tx[i*m + j][i*m + j] = 1;\n\t\t\tFOR(k, -d, d + 1)\n\t\t\t{\n\t\t\t\tint l = d - abs(k);\n\t\t\t\tif (inRange(i + k, j + l, n, m)) { x[i * m + j][(i + k)*m + j + l] = 1; }\n\t\t\t\tif (inRange(i + k, j - l, n, m)) { x[i * m + j][(i + k)*m + j - l] = 1; }\n\t\t\t}\n\t\t}\n\n\t\tREP(i, N) { x[i][N] = read<int>(); }\n\n\t\tREP(i, N)\n\t\t{\n\t\t\tFOR(j, i, N) { if (x[j][i] != 0) { x[i].swap(x[j]); break; } } // pivot select\n\t\t\tif (x[i][i] == 0) continue;\n\t\t\tREP(k, N) if (k != i) if (x[k][i] != 0) FOR(j, i, N+1) x[k][j] -= x[i][j];\n\t\t}\n\n\t\tint result = 1;\n\t\tREP(i,N) if (x[i][i] == 0 && x[i][N] != 0) result = 0;\n\t\tWRITE(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n\ninline bool in(int a, int b, int c){\n\treturn a <= b && b < c;\n}\n\n\nint main(){\n\tint m, n, d, s;\n\twhile( scanf(\"%d%d%d\", &m, &n, &d), m != 0 ){\n\t\tint sz = m * n;\n\t\tvector<bitset<626> > v(sz);\n\t\tbitset<625> used;\n\n\t\tint p = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < m; ++j, ++p){\n\t\t\t\tv[p][p] = true;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < d; ++k){\n\t\t\t\t\tif( in(0, i - d + k, n) && in(0, j + k, m) ){\n\t\t\t\t\t\tv[p][(i - d + k) * m + (j + k)] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif( in(0, i + k, n) && in(0, j + d - k, m) ){\n\t\t\t\t\t\tv[p][(i + k) * m + (j + d - k)] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif( in(0, i + d - k, n) && in(0, j - k, m) ){\n\t\t\t\t\t\tv[p][(i + d - k) * m + (j - k)] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif( in(0, i - k, n) && in(0, j - d + k, m) ){\n\t\t\t\t\t\tv[p][(i - k) * m + (j - d + k)] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscanf(\"%d\", &s);\n\t\t\t\tif( s != 0 ){\n\t\t\t\t\tv[p][sz] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < sz; ++i){\n\t\t\tint index = -1;\n\n\t\t\tfor(int j = 0; j < sz; ++j){\n\t\t\t\tif( !used[j] && v[j][i] ){\n\t\t\t\t\tindex = j;\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( index >= 0 ){\n\t\t\t\tfor(int j = 0; j < sz; ++j){\n\t\t\t\t\tif( j == index || !v[j][i] ) continue;\n\n\t\t\t\t\tfor(int k = 0; k <= sz; ++k){\n\t\t\t\t\t\tif( v[index][k] ){\n\t\t\t\t\t\t\tv[j].flip(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint ans = 1;\n\t\tfor(int i = 0; i < sz; ++i){\n\t\t\tif( v[i][sz] && v[i].count() == 1 ){\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<typeinfo>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\ntemplate<long long int mod=1000000007>\nstruct Mod_Int{\n    typedef long long int ll;\n    typedef pair<ll,ll> pll;\n    typedef Mod_Int<mod> M;\n    ll a;\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        for(int i=0;i<63;i++){\n            if(x>>i&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    Mod_Int(ll A=1):a(A){\n        a%=mod;\n        if(a<0){a+=mod;}\n    }\n    \n    Mod_Int(const M &b):a(b.a){}\n    \n    M & operator += (const M &b){\n        a+=b.a;\n        if(a>=mod){a-=mod;}\n        return *this;\n    }\n    \n    M operator + (const M &b) const {\n        M c=*this;\n        return c+=b;\n    }\n    \n    M & operator -= (const M &b){\n        a-=b.a;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n    \n    M operator - (const M &b) const {\n        M c=*this;\n        return c-=b;\n    }\n    \n    M & operator *= (const M &b){\n        (a*=b.a)%=mod;\n        return *this;\n    }\n    \n    M operator * (const M &b) const {\n        M c=*this;\n        return c*=b;\n    }\n    \n    M & operator /= (const M &b){\n        (a*=R(b.a))%=mod;\n        return *this;\n    }\n    \n    M operator / (const M &b) const {\n        M c=*this;\n        return c/=b;\n    }\n    \n    M & mod_pow_equal(ll x){\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        a=ans;\n        return *this;\n    }\n    \n    M & mod_pow(ll x){\n        M c(a);\n        return c.mod_pow_equal(x);\n    }\n    \n    bool operator == (const M &b) const {return a==b.a;}\n    \n    bool operator != (const M &b) const {return a!=b.a;}\n    \n    bool operator <= (const M &b) const {return a<=b.a;}\n    \n    bool operator < (const M &b) const {return a<b.a;}\n    \n    bool operator > (const M &b) const {return a>b.a;}\n    \n    bool operator >= (const M &b) const {return a>=b.a;}\n    \n    M & operator = (const M &b){\n        a=b.a;\n        return *this;\n    }\n    \n    M & operator = (const ll &b){\n        (a=b)%=mod;\n        if(a<0){a+=mod;}\n        return *this;\n    }\n};\n\ntypedef Mod_Int<2> Int;\n\n/*\n //Mod_Intで行う場合\n //showを使うならそれも変える\n \n const R EPS=0;\n \n inline T fabs(const T &a) const {return a;}\n \n inline bool equals(const R &a,const R &b) const {\n return fabs(a-b)<=EPS;\n }\n */\ntemplate<typename T,typename R=double> //要素の型、実数の型 //両方とも実数型を推奨\nclass Matrix{\nprivate:\n    typedef unsigned long ul;\n    typedef long long int ll;\n    typedef unsigned long long int ull;\n    typedef Matrix<T,R> Mat;\n    typedef Matrix<R,R> RMat;\n    const R EPS=0;\n    ul n,m;\n    vector<vector<T>> M;\n    \n    inline T fabs(const T &a) const {return a;}\n    \n    inline bool equals(const R &a,const R &b) const {\n        return fabs(a-b)<=EPS;\n    }\n    \n    //A+=B\n    template<typename U>\n    vector<U> & pls (vector<U> &A,const vector<U> &B,U a) const {\n        assert(A.size()==B.size());\n        for(int i=0;i<A.size();i++){\n            A[i]+=B[i]*a;\n        }\n        return A;\n    }\n    \n    //A-=B\n    template<typename U>\n    vector<U> & mns (vector<U> &A,const vector<U> &B,const U &a) const {\n        assert(A.size()==B.size());\n        for(int i=0;i<A.size();i++){\n            A[i]-=B[i]*a;\n        }\n        return A;\n    }\n    \n    //A/=b\n    template<typename U>\n    vector<U> & normalization(vector<U> &A,const U &b) const {\n        for(int i=0;i<A.size();i++){\n            A[i]/=b;\n        }\n        return A;\n    }\n    \n    Mat & Row_Permutation(const vector<ul> &P){\n        assert(P.size()==n);\n        Mat cp=*this;\n        for(int i=0;i<n;i++){\n            if(P[i]==i){continue;}\n            M[i]=cp[P[i]];\n        }\n        return *this;\n    }\n    \n    Mat & Col_Permutation(const vector<ul> &P){\n        assert(P.size()==m);\n        Mat cp=*this;\n        for(int i=0;i<m;i++){\n            if(P[i]==i){continue;}\n            for(int t=0;t<n;t++){\n                M[t][i]=cp[t][P[i]];\n            }\n        }\n        return *this;\n    }\n    \n    vector<ul> inverseP(const vector<ul> &P) const {\n        vector<ul> ret(P.size());\n        for(int i=0;i<P.size();i++){\n            ret[P[i]]=i;\n        }\n        return ret;\n    }\n    \n    RMat inverseL(RMat L) const {\n        RMat ret; ret=ret.I(L.size());\n        for(int i=0;i<L.size();i++){\n            R d=L[i][i];\n            if(equals(d,0)){return RMat(L.size(),L.size(),0);}\n            if(equals(d,1)){continue;}\n            ret[i][i]/=d;\n            for(int t=0;t<=i;t++){\n                L[i][t]/=d;\n            }\n        }\n        for(int i=0;i<L.size();i++){\n            for(int t=i+1;t<n;t++){\n                if(equals(L.row(t)[i],0)){continue;}\n                mns(ret[t],ret[i],L.row(t)[i]);\n            }\n        }\n        return ret;\n    }\n    \n    RMat inverseU(RMat U) const {\n        RMat ret; ret=ret.I(U.size());\n        for(int i=0;i<U.size();i++){\n            R d=U[i][i];\n            if(equals(d,0)){return RMat(U.size(),U.size(),0);}\n            if(equals(d,1)){continue;}\n            ret[i][i]/=d;\n            for(int t=i;t<U.size();t++){\n                U[i][t]/=d;\n            }\n        }\n        for(ll i=U.size()-1;i>=0;i--){\n            for(ll t=i-1;t>=0;t--){\n                if(equals(U[t][i],0)){continue;}\n                mns(ret[t],ret[i],U[t][i]);\n            }\n        }\n        return ret;\n    }\n    \npublic:\n    Matrix(const ul &n=0,const ul &m=0,const T &a=T()):n(n),m(m),M(vector<vector<T>>(n,vector<T>(m,a))){}\n    \n    Matrix(const vector<vector<T>> &M):n(M.size()),m(M[0].size()),M(M){\n        for(int i=1;i<M.size();i++){assert(M[i].size()==m);}\n    }\n    \n    /*\n     template<typename K,typename L>\n     Matrix(const Matrix<K,L> &A):n(A.size()),m(A.csize()),M(vector<vector<T>>(n,vector<T>(m,T()))){\n     for(int i=0;i<n;i++){\n     for(int t=0;t<m;t++){\n     M[i][t]=T(A.row(i)[t]);\n     }\n     }\n     }\n     */\n    \n    vector<T> & operator [] (ul k){\n        assert(k<n);\n        return M[k];\n    }\n    \n    template<typename K,typename L>\n    Mat & operator = (const Matrix<K,L> &A){\n        n=A.size(); m=A.csize();\n        M.resize(n);\n        for(int i=0;i<n;i++){\n            M[i].resize(m);\n            for(int t=0;t<m;t++){\n                M[i][t]=T(A.row(i)[t]);\n            }\n        }\n        return *this;\n    }\n    \n    Mat & operator = (const Mat &A){\n        n=A.n; m=A.m;\n        M=A.M;\n        return *this;\n    }\n    \n    bool operator == (const Mat &A) const {\n        return A.M==M;\n    }\n    \n    bool operator != (const Mat &A) const {\n        return A.M!=M;\n    }\n    \n    bool operator < (const Mat &A) const {\n        if(n<A.n){return true;}\n        if(n>A.n){return false;}\n        if(m<A.m){return true;}\n        if(m>A.m){return false;}\n        return M<A.M;\n    }\n    \n    bool operator <= (const Mat &A) const {\n        if(n<A.n){return true;}\n        if(n>A.n){return false;}\n        if(m<A.m){return true;}\n        if(m>A.m){return false;}\n        return M<=A.M;\n    }\n    \n    bool operator > (const Mat &A) const {\n        return A<(*this);\n    }\n    \n    bool operator >= (const Mat &A) const {\n        return A<=(*this);\n    }\n    \n    Mat & operator += (const Mat &A){\n        assert(n==A.n && m==A.m);\n        for(int i=0;i<n;i++){\n            for(int t=0;t<m;t++){\n                M[i][t]+=A[i][t];\n            }\n        }\n        return *this;\n    }\n    \n    Mat operator + (const Mat &A) const {\n        Mat ret=*this;\n        return ret+=A;\n    }\n    \n    Mat operator += (const T &a){\n        for(int i=0;i<n;i++){\n            for(int t=0;t<m;t++){\n                M[i][t]+=a;\n            }\n        }\n        return *this;\n    }\n    \n    Mat operator + (const T &a) const {\n        Mat ret=*this;\n        return ret+=a;\n    }\n    \n    Mat operator -= (const Mat &A){\n        assert(n==A.n && m==A.m);\n        for(int i=0;i<n;i++){\n            for(int t=0;t<m;t++){\n                M[i][t]-=A[i][t];\n            }\n        }\n        return *this;\n    }\n    \n    Mat operator - (const Mat &A) const {\n        Mat ret=*this;\n        return ret-=A;\n    }\n    \n    Mat operator -= (const T &a){\n        for(int i=0;i<n;i++){\n            for(int t=0;t<m;t++){\n                M[i][t]-=a;\n            }\n        }\n        return *this;\n    }\n    \n    Mat operator - (const T &a) const {\n        Mat ret=*this;\n        return ret-=a;\n    }\n    \n    Mat & operator *= (const Mat &B){\n        (*this)=(*this)*B;\n        return *this;\n    }\n    \n    Mat operator * (const Mat &B) const {\n        assert(m==B.n);\n        Mat ret(n,B.m);\n        for(int i=0;i<n;i++){\n            for(int t=0;t<B.m;t++){\n                for(int h=0;h<m;h++){\n                    ret[i][t]+=M[i][h]*B.row(h)[t];\n                }\n            }\n        }\n        return ret;\n    }\n    \n    Mat operator *= (const T &a){\n        for(int i=0;i<n;i++){\n            for(int t=0;t<m;t++){\n                M[i][t]*=a;\n            }\n        }\n        return *this;\n    }\n    \n    Mat operator * (const T &a) const {\n        Mat ret=*this;\n        return ret*=a;\n    }\n    \n    Mat operator /= (const T &a){\n        for(int i=0;i<n;i++){\n            for(int t=0;t<m;t++){\n                M[i][t]/=a;\n            }\n        }\n        return *this;\n    }\n    \n    Mat operator / (const T &a) const {\n        Mat ret=*this;\n        return ret/=a;\n    }\n    \n    Mat operator %= (const T &a){\n        for(int i=0;i<n;i++){\n            for(int t=0;t<m;t++){\n                M[i][t]%=a;\n            }\n        }\n        return *this;\n    }\n    \n    Mat operator % (const T &a) const {\n        Mat ret=*this;\n        return ret%=a;\n    }\n    \n    ul size() const {return n;}\n    \n    ul csize() const {return m;}\n    \n    void resize(const ul &x,const ul &y){\n        n=x; m=y;\n        M.resize(n);\n        for(int i=0;i<n;i++){\n            M[i].resize(y);\n        }\n    }\n    \n    void clear(){\n        n=0; m=0;\n        M.clear();\n    }\n    \n    const vector<T> & row(ul x) const {\n        assert(x<n);\n        return M[x];\n    }\n    \n    R det() const {\n        //*\n        //LUPD\n        return LUPD().F.F;\n        //*/\n        \n        /*\n         //Gaussian_Elimination\n         assert(n==m);\n         return Gaussian_Elimination(RMat(n,0)).S;\n         //*/\n    }\n    \n    RMat inverse() const {\n        //*\n        //LUPD\n        pair<pair<R,vector<ul>>,pair<RMat,RMat>> ret=LUPD();\n        ret.S.F=inverseL(ret.S.F);\n        ret.S.S=inverseU(ret.S.S);\n        ret.F.S=inverseP(ret.F.S);\n        return (ret.S.S*ret.S.F).Col_Permutation(ret.F.S);\n        //*/\n        \n        /*\n         //Gaussian_Elimination\n         assert(n==m);\n         RMat y; y=y.I(n);\n         return Gaussian_Elimination(y).F;\n         //*/\n    }\n    \n    Mat I(const ul &size) const {\n        Mat ret(size,size,(T)0);\n        for(int i=0;i<size;i++){\n            ret[i][i]=(T)1;\n        }\n        return ret;\n    }\n    \n    Mat mod_pow(ull x,const T &mod) const {\n        assert(n==m);\n        Mat ret=I(n);\n        Mat A=*this;\n        for(ul i=0;i<64;i++){\n            if(x&1){ret*=A;}\n            x>>=1;\n            if(x==0){break;}\n            A*=A;\n            A%=mod;\n        }\n        return ret;\n    }\n    \n    RMat equation(const RMat &Y) const {\n        return inverse()*Y;\n        //return Gaussian_Elimination(Y).F;\n    }\n    \n    pair<RMat,RMat> LUD() const {\n        assert(n==m);\n        RMat A; A=(*this);\n        RMat L; L=L.I(n);\n        RMat U(n,n);\n        for(int i=0;i<n;i++){\n            for(int t=0;t<n;t++){\n                for(int h=0;h<min(i,t);h++){\n                    A[i][t]-=L[i][h]*U[h][t];\n                }\n                if(i>t){\n                    if(equals(A[i][t],0)){L[i][t]=0;}\n                    else{L[i][t]=A[i][t]/U[t][t];}\n                }\n                else{U[i][t]=A[i][t];}\n            }\n        }\n        return {L,U};\n    }\n    \n    //det,P,L,U\n    pair<pair<R,vector<ul>>,pair<RMat,RMat>> LUPD() const {\n        assert(n==m);\n        RMat A; A=(*this);\n        RMat L(n,n,(R)0);\n        RMat U; U=U.I(n);\n        vector<ul> P(n);\n        R det=(R)1;\n        for(int i=0;i<n;i++){P[i]=i;}\n        for(int i=0;i<n;i++){\n            for(int t=i;t<n;t++){\n                for(int h=0;h<i;h++){\n                    A[t][i]-=L[t][h]*U[h][i];\n                }\n            }\n            R mx=fabs(A[i][i]);\n            ll w=i;\n            for(int t=i+1;t<n;t++){\n                if(mx<fabs(A[t][i])){mx=fabs(A[t][i]); w=t;}\n            }\n            if(equals(mx,0)){return {{0,P},{RMat(n,n,(R)0),U.I(n)}};}\n            if(i!=w){\n                det*=(R)-1;\n                swap(P[i],P[w]);\n                swap(A[i],A[w]);\n                swap(L[i],L[w]);\n            }\n            for(int t=i;t<n;t++){\n                L[t][i]=A[t][i];\n            }\n            det*=L[i][i];\n            for(int t=i+1;t<n;t++){\n                for(int h=0;h<i;h++){\n                    A[i][t]-=L[i][h]*U[h][t];\n                }\n                U[i][t]=A[i][t]/L[i][i];\n            }\n        }\n        return {{det,P},{L,U}};\n    }\n    \n    pair<RMat,RMat> Gaussian_Elimination(RMat y) const {\n        RMat A=*this;\n        R k=(R)1;\n        for(int i=0;i<n;i++){\n            R mx=fabs(A[i][i]);\n            ll w=i;\n            for(int t=i+1;t<n;t++){\n                if(mx<fabs(A[t][i])){mx=fabs(A[t][i]); w=t;}\n            }\n            if(w!=i){\n                swap(A[i],A[w]);\n                swap(y[i],y[w]);\n                k*=(R)-1;\n            }\n            R d=A[i][i];\n            k*=d;\n            if(!equals(d,0)){\n                normalization(y[i],d);\n                normalization(A[i],d);\n                for(int t=0;t<n;t++){\n                    if(i==t){continue;}\n                    R e=A[t][i];\n                    if(equals(e,0)){continue;}\n                    mns(y[t],y[i],e);\n                    mns(A[t],A[i],e);\n                }\n            }\n            else{\n                //return {RMat(y.size(),y.csize(),R(0)),(R)0};\n            }\n        }\n        return {A,y};\n    }\n    \n    void show() const {\n        for(int i=0;i<n;i++){\n            for(int t=0;t<m;t++){\n                if(equals(M[i][t],0)){cout<<0;}\n                else{cout<<M[i][t];}\n                if(t!=m-1){cout<<\" \";}\n            }\n            cout<<endl;\n        }\n    }\n};\n\ntypedef Matrix<Int,Int> M;\n\n    \nint main(){\n    vector<ll> ans;\n    ll h,w,d;\n    while(cin>>w>>h>>d && h){\n    M m(h*w,h*w+1,0);\n    for(int i=0;i<h;i++){\n        for(int t=0;t<w;t++){\n            for(int x=0;x<h;x++){\n                for(int y=0;y<w;y++){\n                    if(i==x && t==y){m[i*w+t][x*w+y]=1;}\n                    else if(abs(i-x)+abs(t-y)==d){\n                        m[i*w+t][x*w+y]=1;\n                    }\n                }\n            }\n        }\n    }\n    M y(h*w,1,0);\n    for(int i=0;i<h;i++){\n        for(int t=0;t<w;t++){\n            ll a;\n            cin>>a;\n            y[i*w+t][0]=a;\n        }\n    }\n    bool done=true;\n        pair<M,M> ret=m.Gaussian_Elimination(y);\n    for(int i=0;i<m.size() && done;i++){\n        bool none=true;\n        for(int t=0;t<m.size() && done;t++){\n            if(ret.F[i][t].a){none=false;}\n        }\n        if(none && ret.S[i][0]!=0){done=false;}\n    }\n        ans.push_back(done);\n        //cout<<done<<endl;\n    \n    }\n    for(int i=0;i<ans.size();i++){\n        cout<<ans[i]<<endl;\n    }\n    \n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MAX = 30*30;\nusing BS = bitset<MAX*2>;\nvoid det(vector<BS> &v){\n  int n=v.size();\n  for(Int i=0;i<n;i++){\n    for(Int k=i;k<n;k++){\n      if(v[k][i]){\n\tswap(v[i],v[k]);\n\tbreak;\n      }\n    }\n    for(Int k=0;k<n;k++)\n      if(i!=k&&v[k][i]) v[k]^=v[i];\n  }\n}\n\nsigned main(){\n  int m,n,d;\n  while(cin>>m>>n>>d,m){\n    vector<vector<int> > s(n,vector<int>(m));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tcin>>s[i][j];\n\n    vector<BS> v(n*m,BS(0));\n    auto idx=[&](int y,int x){return y*m+x;};\n    auto in=[&](int y,int x){return 0<=y&&y<n&&0<=x&&x<m;};\n    auto bfs=[&](int y,int x){\n      int z=idx(y,x);\n      v[z][z]=1;\n      v[z][n*m]=s[y][x];\n      \n      vector<vector<int> > dp(n,vector<int>(m,-1));\n      using P = pair<int, int>;\n      queue<P> q;\n      dp[y][x]=0;\n      q.emplace(y,x);\n      int dy[]={0,0,1,-1};\n      int dx[]={1,-1,0,0};\n      while(!q.empty()){\n\ttie(y,x)=q.front();q.pop();\n\tif(dp[y][x]==d) v[z][idx(y,x)]=1;\n\tfor(int k=0;k<4;k++){\n\t  int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||~dp[ny][nx]) continue;\n\t  dp[ny][nx]=dp[y][x]+1;\n\t  q.emplace(ny,nx);\n\t}\n      }\n    };\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n\tbfs(i,j);\n    \n    auto u=v;\n    det(v);\n    int ans=1;\n    for(int i=0;i<n*m;i++){\n      int tmp=s[i/m][i%m];\n      for(int j=0;j<n*m;j++) tmp+=u[i][j]&v[j][n*m];\n      ans&=!(tmp&1);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\n\nll modNorm(ll a, ll m) {\n  return (a%m+m)%m;\n}\n\n// ax+by=gcd(a,b)\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll invMod(ll a, ll p) {\n  ll x, y;\n  if (extgcd(a,p,x,y) == 1) return (x+p)%p;\n  return 0;\n}\n\ntypedef vector<bool> vec;\ntypedef vector<vec> mat;\n\nostream &operator<<(ostream &os, const vec &a) {\n  FOR(it, a) os << *it << \" \";\n  return os;\n}\nostream &operator<<(ostream &os, const mat &a) {\n  FOR(it, a) os << *it << endl;\n  return os;\n}\n\n\nbool gauss_jordan_cong(const mat &A, const vec &b, int m, vec &x) {\n  int n = A.size();\n  mat B(n, vec(n+1));\n  REP(i,n) REP(j,n)\n    B[i][j] = A[i][j];\n  REP(i, n) B[i][n] = b[i];\n\n  //cout << B << endl;\n  REP(i, n) {\n    int pivot = i;\n    for (int j=i; j<n; ++j)\n      if (abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    swap(B[i], B[pivot]);\n    // ðªÈ¢©AêÓÅÈ¢\n    if (abs(B[i][i]) < EPS) {\n      if (abs(B[i][n]) > EPS) return 0;\n      continue;\n    }\n    \n    // // ÚµÄ¢éÏÌWðPÉ·é\n    // for (int j=i+1; j<=n; j++) B[i][j] = B[i][j] ^ B[i][i];\n    // B[i][i] = 1;\n    REP(j, n) {\n      if (i != j) {\n        // jÔÚÌ®©çiÔÚÌÏðÁ\n        if (B[j][i])\n          for (int k=i+1; k<=n; ++k) B[j][k] = B[j][k] ^ B[i][k];\n        B[j][i] = 0;\n      }\n    }\n    //cout << B << endl;\n  }\n  //cout << B << endl;\n  x = vec(n);\n  REP(i, n) {\n    if (B[i][i] == 0 && B[i][n]) return 0;\n    x[i] = B[i][n];\n  }\n  return 1;\n}\n\nint main() {\n  int m, n, d;\n  int c = 0;\n  while(cin>>m>>n>>d, m||n||d) {\n    bool ba[n][m];\n    mat A(n*m, vec(n*m));\n    vec b(n*m);\n    REP(i,n) {\n      REP(j,m) {\n        cin >> ba[i][j];\n        A[i*m+j][i*m+j] = 1;\n        REP(k,n) {\n          REP(l,m) {\n            int dis = abs(i-k)+abs(j-l);\n            if (dis == d) {\n              A[i*m+j][k*m+l] = 1;\n            }\n          }\n        }\n        b[i*m+j] = ba[i][j];\n      }\n    }\n    vec x;\n    cout << gauss_jordan_cong(A,b,2,x) << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[]={-1,0,1,0},dx[]={0,-1,0,1},dy2[]={1,-1,-1,1},dx2[]={1,1,-1,-1};\nint m,n,d,s[25][25];\nint main()\n{\n\twhile(cin>>m>>n>>d,m){\n\t\tint N=m*n;\n\t\tvector<vi> a(N,vi(N+1,0));\n\t\trep(i,m)rep(j,n)cin>>s[i][j], a[i*n+j][N]=s[i][j];\n\t\t\n\t\t//rep(i,N)rep(j,N+1)cerr<<a[i][j]<<(j==N?\"\\n\":\" \");\n\t\t\n\t\trep(i,N)(a[i][i]+=1)%=2;\n\t\trep(i,m)rep(j,n)rep(dir,4)rep(k,d){\n\t\t\tint y=i+dy[dir]*d+dy2[dir]*k, x=j+dx[dir]*d+dx2[dir]*k;\n\t\t\tif(0<=y&&y<m&&0<=x&&x<n){\n\t\t\t\t(a[y*n+x][i*n+j]+=1)%=2;\n\t\t\t}\n\t\t}\n\t\t//rep(i,N)rep(j,N+1)cerr<<a[i][j]<<(j==N?\"\\n\":\" \");\n\t\t\n\t\trep(i,N){\n\t\t\tsort(a.begin()+i,a.end(),greater<vi>());\n\t\t\tif(a[i][i]){\n\t\t\t\trep(j,N)if(i<j&&a[j][i])rep(k,N+1)(a[j][k]+=a[i][k])%=2;\n\t\t\t}\n\t\t}\n\t\t//rep(i,N)rep(j,N+1)cerr<<a[i][j]<<(j==N?\"\\n\":\" \");\n\t\t\n\t\tbool ok=1;\n\t\trep(i,N)if(ok&&a[i][N]){\n\t\t\tbool exist=0;\n\t\t\trep(j,N)if(a[i][j])exist=1;\n\t\t\tif(!exist)ok=0;\n\t\t}\n\t\tcout<<(int)ok<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define INF 1000000007\n#define EPS 1e-10\n#define ll long long\n\nusing namespace std;\n\ntemplate<typename T> class mat : public vector<vector<T> > {\nprivate:\n    int r,c;    //行,列\npublic:\n    int row() const {\n        return r;\n    }\n    int column() const {\n        return c;\n    }\n    mat(int n,int m,T val = 0){\n        this->r = n,this->c = m;\n        rep(i,n){\n            this->push_back(vector<T>(m,val));\n        }\n    }\n    mat operator+(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"足し算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator+(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] + val;\n            }\n        }\n        return X;\n    }\n    mat operator-(const mat& another){\n        if(this->r != another.r && this->c != another.c){\n            cout << \"引き算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - another[i][j];\n            }\n        }\n        return X;\n    }\n    mat operator-(const T val){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = (*this)[i][j] - val;\n            }\n        }\n        return X;\n    }\n    vector<T> operator*(const vector<T>& another){\n        if(this->c != (int)another.size()){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        vector<T> vec(this->r,0);\n        rep(i,this->r){\n            rep(j,this->c){\n                vec[i] += (*this)[i][j] * another[j];\n            }\n        }\n        return vec;\n    }\n    mat operator*(const mat& another){\n        if(this->c != another.r){\n            cout << \"掛け算失敗(サイズ不一致)\" << endl;\n            exit(1);\n        }\n        mat<T> X(this->r,another.c);\n        rep(i,this->r){\n            rep(k,this->c){\n                rep(j,another.c){\n                    X[i][j] += (*this)[i][k]*another[k][j];\n                }\n            }\n        }\n        return X;\n    }\n    mat operator-(){\n        mat<T> X(this->r,this->c);\n        rep(i,this->r){\n            rep(j,this->c){\n                X[i][j] = -(*this)[i][j];\n            }\n        }\n        return X;\n    }\n    int rank(){\n\t\tint n = this->r;\n\t    int m = this->c;\n\t    int res = 0;\n\t    mat B(n,m);\n\t    for(int i=0;i<n;i++){\n\t        for(int j=0;j<m;j++){\n\t\t\t\tB[i][j] = (*this)[i][j];\n\t\t\t}\n\t    }\n\t    for(int i=0;i<m;i++){\n\t        if(res == n) return res;\n\t        int pivot = res;\n\t        for(int j=res+1;j<n;j++){\n\t            if(abs(B[j][i]) > abs(B[pivot][i])){\n\t                pivot = j;\n\t            }\n\t        }\n\t        if(abs(B[pivot][i]) < EPS) continue;\n\t        swap(B[pivot],B[res]);\n\t        for(int j=i+1;j<m;j++){\n\t            B[res][j] /= B[res][i];\n\t        }\n\t        for(int j=res+1;j<n;j++){\n\t            for(int k=i+1;k<m;k++){\n\t                B[j][k] -= B[res][k]*B[j][i];\n\t            }\n\t        }\n\t        res++;\n\t    }\n\t    return res;\n\t}\n    T det(){\n        if(this->r != this->c){\n            cout << \"正方行列でない(行列式定義不可)\" << endl;\n            exit(1);\n        }\n        T ans = 1;\n        int n = this->r;\n        mat B(n,n);\n        rep(i,n){\n            rep(j,n){\n                B[i][j] = (*this)[i][j];\n            }\n        }\n        rep(i,n) {\n            for(int j=i+1;j<n;j++){\n                for (; B[j][i] != 0; ans = -ans) {\n                    T r = B[i][i] / B[j][i];\n                    for(int k=i;k<n;k++) {\n                        T t = B[i][k] - r * B[j][k];\n                        B[i][k] = B[j][k];\n                        B[j][k] = t;\n                    }\n                }\n           }\n           ans *= B[i][i];\n       }\n       return ans;\n    }\n    mat inverse(){\n        if(this->r != this->c){\n            cout << \"正方行列でない(逆行列定義不可)\" << endl;\n            exit(1);\n        }\n        int n = this->r;\n        mat B(n,2*n);\n        rep(i,n){\n            rep(j,n){\n                B[i][j] = (*this)[i][j];\n            }\n        }\n        rep(i,n){\n            B[i][n+i] = 1;\n        }\n        rep(i,n){\n            int pivot = i;\n            for(int j=i;j<n;j++){\n                if(abs(B[j][i]) > abs(B[pivot][i])){\n                    pivot = j;\n                }\n            }\n            if(abs(B[pivot][i]) < EPS){\n                cout << \"解なしor不定\" << endl;\n                exit(1);\n            }\n            swap(B[i],B[pivot]);\n            for(int j=i+1;j<=2*n;j++){\n                B[i][j] /= B[i][i];\n            }\n            rep(j,n){\n                if(i != j){\n                    for(int k=i+1;k<=2*n;k++){\n                        B[j][k] -= B[j][i] * B[i][k];\n                    }\n                }\n            }\n        }\n        mat res(n,n);\n        rep(i,n){\n            rep(j,n){\n                res[i][j] = B[i][n+j];\n            }\n        }\n        return res;\n    }\n    void print(){\n        rep(i,this->r){\n            rep(j,(this->c)-1){\n                cout << (*this)[i][j] << \",\";\n            }\n            cout << (*this)[i][(this->c)-1] << endl;\n        }\n    }\n};\n\ntemplate<typename T> bool eq_solve(const mat<T>& A,const vector<T>& b){\n    if(A.row() != A.column()){\n        cout << \"正方行列でない(解なしor不定)\" << endl;\n        exit(1);\n    }\n    int n = A.row();\n    mat<T> B(n,n+1);\n    rep(i,n){\n        rep(j,n){\n            B[i][j] = A[i][j];\n        }\n    }\n    rep(i,n){\n        B[i][n] = b[i];\n    }\n    int i = 0, l = 0;\n    while(i+l < n){\n        int pivot = i;\n        for(int j=i;j<n;j++){\n            if(abs(B[j][i+l]) > abs(B[pivot][i+l])){\n                pivot = j;\n            }\n        }\n        if(abs(B[pivot][i+l]) < EPS){\n            l++;\n            continue;\n        }\n        swap(B[i],B[pivot]);\n        for(int j=i+l+1;j<=n;j++){\n            B[i][j] /= B[i][i+l];\n        }\n        rep(j,n){\n            if(i != j){\n                for(int k=i+l+1;k<=n;k++){\n                    B[j][k] ^= B[j][i+l] * B[i][k];\n                }\n            }\n        }\n        i++;\n    }\n    bool ok = true;\n    for(int j=i;j<n;j++){\n        if(B[j][n] > EPS){\n            ok = false;\n            break;\n        }\n    }\n    return ok;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int m,n,d;\n        cin >> m >> n >> d;\n        if(m == 0) break;\n        vector<vector<int> > vec(n,vector<int>(m));\n        rep(i,n){\n            rep(j,m){\n                cin >> vec[i][j];\n            }\n        }\n        mat<int> A(n*m,n*m);\n        vector<int> b(n*m);\n        rep(i,n){\n            rep(j,m){\n                A[i*m+j][i*m+j] = 1;\n                rep(k,d){\n                    int x = i-d+k, y = j+k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                rep(k,d){\n                    int x = i+k, y = j+d-k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                rep(k,d){\n                    int x = i+d-k, y = j-k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                rep(k,d){\n                    int x = i-k, y = j-d+k;\n                    if(0 <= x && x < n && 0 <= y && y < m){\n                        A[i*m+j][x*m+y] = 1;\n                    }\n                }\n                b[i*m+j] = vec[i][j];\n            }\n        }\n        cout << eq_solve(A,b) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint a[25 * 25][25 * 25 + 1];\nint y[25 * 25];\n\nint manhattan(int x1, int y1, int x2, int y2){\n  return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint main(){\n  int n, m, d;\n\n  while(scanf(\"%d%d%d\", &n, &m, &d), n + m + d){\n    int s[25][25];\n    const int N = n * m;\n    REP(i,n) REP(j,m) scanf(\"%d\", &s[i][j]);\n\n    REP(i,N){\n      REP(j,N){\n        a[i][j] = 0;\n      }\n      a[i][N] = s[i / m][i % m];\n    }\n\n    REP(i1,n) REP(j1,m){\n      a[i1 * m + j1][i1 * m + j1] = 1;\n      REP(i2,n) REP(j2,m){\n        if(manhattan(i1, j1, i2, j2) == d){\n          a[i1 * m + j1][i2 * m + j2] = 1;\n        }\n      }\n    }\n\n    int ans = 1;\n\n    REP(i, N){\n      if(a[i][i] == 0){\n        for(int j = i + 1; j < N; j++){\n          if(a[j][i] > 0){\n            for(int k = 0; k < N + 1; k++){\n              swap(a[i][k], a[j][k]);\n            }\n          }\n        }\n        if(a[i][i] == 0){\n          if(a[i][N] == 1){\n            ans = 0;\n            break;\n          }else{\n            continue;\n          }\n        }\n      }\n\n      for(int j = 0; j < N; j++) if(i != j){\n        if(a[j][i] == 1){\n          for(int k = i; k < N + 1; k++){\n            a[j][k] = (a[j][k] + a[i][k]) % 2;\n          }\n        }\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\n\n\nconst double EPS=-1e8;\ntypedef vector<int> vec;\ntypedef vector<vec>mat;\n\n//Ax=b????§£??? A?????£?????????\n//?§£???????????????????????§????????´????????????0??????????????????\nvec gauss_jordan(const mat& A, const vec &b){\n    int n=A.size();\n    mat B(n,vec(n+1));\n    REP(i,n){\n        REP(j,n){\n            B[i][j]=A[i][j];\n        }\n    }\n    //??????A????????????b????????????????????????????????????\n    REP(i,n)B[i][n]=b[i];\n    \n    REP(i,n){\n        //??¨????????????????????°????????°?????¶???????????§????????????i??????????????£?????????\n        int pivot =i;\n        for(int j=i;j<n;j++){\n            if(abs(B[j][i])>abs(B[pivot][i]))pivot=j;\n        }\n        swap(B[i],B[pivot]);\n        \n        //?§£????????????????????§??????\n        if(abs(B[i][i])<EPS){\n            cout<<\"i=\"<<i<<endl;\n           return vec();\n        }\n        //??¨????????????????????°????????°???1?????????\n        //for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];\n        REP(j,n){\n            if(i!=j){\n               //j??????????????????i??????????????°????¶????\n               for(int k=i+1; k<=n; k++){\n                   if(B[j][i]==1){\n                      B[j][k] ^=(B[i][k]);\n                   }\n               }\n            }\n        }\n    }\n    vec x(n);\n    //??????????????????b????§£?????????\n    REP(i,n)x[i]=B[i][n];\n    return x;\n}\n\nint main(){\n    int m,n,d;\n    while(cin>>m>>n>>d,m){\n          int S[30][30];\n          REP(i,n){\n              REP(j,m){\n                  cin>>S[i][j];\n              }\n          }\n          mat A(n*m,vec(n*m));\n          vec b(n*m);\n          \n          REP(i,n){\n              REP(j,m){\n                  REP(k,n){\n                      REP(l,m){\n                          if(abs(k-i)+abs(j-l)==0||abs(k-i)+abs(j-l)==d){\n                               A[i*m+j][k*m+l]=1;\n                          }else{\n                               A[i*m+j][k*m+l]=0;\n                          }\n                      }\n                  }\n                  b[i*m+j]=S[i][j];\n              }\n          }\n          /*REP(i,n*m){\n              REP(j,n*m)cout<<A[i][j];\n              cout<<b[i];\n              cout<<endl;\n          }*/\n          vec c=gauss_jordan(A,b);\n          REP(i,n){\n              REP(j,m){\n                  if(c[i*m+j]==1){\n                     REP(k,n){\n                         REP(l,m){\n                             if(abs(k-i)+abs(j-l)==0||abs(k-i)+abs(j-l)==d){\n                               S[k][l]=1-S[k][l];\n                             }\n                         }\n                     }\n                  }\n              }\n          }\n          bool cc=true;\n          REP(i,n){\n              REP(j,m){\n                  if(S[i][j]==1)cc=false;\n              }\n          }\n          \n          if(cc){\n             cout<<1<<endl;\n          }else{\n             cout<<0<<endl;\n          }\n    }\n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cstdlib>\n#include <utility>\nusing namespace std;\n\nconstexpr int varc = 625;\npair<bool, bitset<varc>> solve_linear_eq_F2(vector<bitset<varc+1>> g, int varnum){\n    int n = g.size();\n    for(int i=0, p=0; i<n and p<varc+1; i++, p++){\n        for(int j=i+1; j<n; j++){\n            if(g[j][p] == 1){\n                swap(g[i], g[j]);\n                break;\n            }\n        }\n        if(g[i][p] == 0){\n            i--;\n            continue;\n        }\n        for(int j=i-1; j<n; j++){\n            if(j != i and g[j][p] == 1){\n                g[j] ^= g[i];\n            }\n        }\n    }\n    \n    bool has_sol = true;\n    bitset<varc> res, decided;\n    for(int i=n-1; i>=0; i--){\n        int right = g[i][varnum];\n        vector<int> vars;\n        for(int j=0; j<varnum; j++){\n            if(g[i][j]==1){\n                if(decided[j]==1 and res[j]==1){\n                    right ^= 1;\n                }else if(decided[j]==0){\n                    vars.push_back(j);\n                }\n            }\n        }\n        for(int j: vars){\n            res[j] = 0;\n            decided[j] = 1;\n        }\n        if(right==1){\n            if(vars.empty()){\n                has_sol = false;\n                break;\n            }else{\n                res[vars[0]] = 1;\n            }\n        }\n    }\n    return make_pair(has_sol, res);\n}\n\nint main(){\n    while(1){\n        int m,n,d;\n        cin >> m >> n >> d;\n        if(m == 0) break;\n        \n        vector<vector<int>> s(n, vector<int>(m));\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                cin >> s[i][j];\n            }\n        }\n        vector<bitset<varc+1>> g(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                g[i*m+j][i*m+j] = 1;\n                g[i*m+j][n*m] = s[i][j];\n                for(int k=0; k<n; k++){\n                    for(int l=0; l<m; l++){\n                        if(abs(i-k) + abs(j-l) == d){\n                            g[i*m+j][k*m+l] = 1;\n                        }\n                    }\n                }\n            }\n        }     \n        auto ret = solve_linear_eq_F2(g, n*m);\n        cout << ret.first << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-10)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nint h,w,d,n;\n\nint extgcd(int a,int b,int& x,int& y)\n{\n  int d = a;\n  if(b != 0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }\n  else\n    x = 1,y = 0;\n  return d;\n}\n\nint mod_inv(int a,int m)\n{\n  int x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m)%m;\n}\n\n\nint rank(vector<vector<int> > A,int mod)\n{\n  int H = A.size(), W = A[0].size();\n  int r = 0;\n  rep(x,W)\n    {  \n      int pivot = inf;\n      REP(y,r,H)\n\tif(A[y][x])\n\t  {\n\t    pivot = y;\n\t    break;\n\t  }\n      if(pivot == inf)continue;\n      swap(A[r],A[pivot]);\n\n      REP(y,r+1,H)\n\t{\n\t  int value = A[y][x] * mod_inv(A[r][x],mod) % mod;\n\t  if(value)REP(x2,x,W)\n\t\t     A[y][x2] = ((A[y][x2] - A[r][x2] * value)%mod + mod ) % mod; \n\t}\n      r++;\n    }\n  return r;\n}\n\n\nint main()\n{\n  while(cin >> w >> h >> d,w|h|d)\n    {\n      n = h*w;\n      vi b(n);\n      vvi mat(n,vi(n+1,0)),mat2(n,vi(n,0));\n      rep(y,h)rep(x,w)\n\t{\n\t  bool boo;\n\t  cin >> boo;\n\t  b[y*w+x] = boo;\n\t  mat[y*w+x][y*w+x] = mat2[y*w+x][y*w+x] = 1;\n\t  rep(i,h)rep(j,w)\n\t    if(abs(x-j)+abs(y-i) == d)\n\t      mat[y*w+x][i*w+j] = mat2[y*w+x][i*w+j] = 1;\n\t  mat[y*w+x][n] = boo;\n\t}\n      /*\n      rep(i,n)\n\t{\n\t  rep(j,n+1)\n\t    cout << mat[i][j] << \" \";\n\t  cout << endl;\n\t}\t\n      */\n      cout << (rank(mat,2)==rank(mat2,2)?1:0) << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define MAX_N\t(20)\n#define MAX_NN\t(MAX_N * (MAX_N - 1) / 2)\n#define MAX_D\t(400)\n#define MAX_ND\t(MAX_N * MAX_D)\n\n/* typedef */\n\ntypedef map<int,int> mii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n/* global variables */\n\nint n, nn;\nint max_d;\nint ps[MAX_N], ds[MAX_NN];\nint dmap[MAX_ND];\nvvi ans;\n\n/* subroutines */\n\nvoid push_ans() {\n  vi *vp = new vi();\n  for (int i = 1; i < n; i++)\n    (*vp).push_back(ps[i] - ps[i - 1]);\n  if (find(ans.begin(), ans.end(), *vp) == ans.end())\n    ans.push_back(*vp);\n}\n\nbool check(int i0, int i1, int j, int& k, int* used) {\n  int pj = ps[j];\n  for (int i = i0; i <= i1; i++) {\n    int d = abs(pj - ps[i]);\n    if (! dmap[d]) return false;\n    dmap[d]--;\n    used[k++] = d;\n  }\n  return true;\n}\n\nvoid rec(int i0, int i1) {\n  if (false) {\n    printf(\"(%d,%d): \", i0, i1);\n    for (int i = 0; i < n; i++) {\n      if (i > 0) putchar(',');\n      printf(\"%d\", ps[i]);\n    }\n    putchar('\\n');\n    for (int d = 1; d <= ds[0]; d++)\n      if (dmap[d] > 0) printf(\" %d:%d\", d, dmap[d]);\n    putchar('\\n');\n  }\n  \n  if (i0 + 1 == i1) {\n    push_ans();\n    return;\n  }\n\n  int prvd = max_d;\n  while (dmap[max_d] == 0) max_d--;\n  //printf(\" max_d=%d\\n\", max_d);\n  \n  int used[MAX_NN];\n  int k = 0;\n  \n  ps[i0 + 1] = ps[n - 1] - max_d;\n  if (check(0, i0, i0 + 1, k, used) &&\n      check(i1, n - 1, i0 + 1, k, used))\n    rec(i0 + 1, i1);\n  ps[i0 + 1] = 0;\n  while (k > 0) dmap[used[--k]]++;\n  \n  ps[i1 - 1] = ps[0] + max_d;\n  if (check(0, i0, i1 - 1, k, used) &&\n      check(i1, n - 1, i1 - 1, k, used))\n    rec(i0, i1 - 1);\n  ps[i1 - 1] = 0;\n  while (k > 0) dmap[used[--k]]++;\n  \n  max_d = prvd;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    nn = n * (n - 1) / 2;\n    memset(dmap, 0, sizeof(dmap));\n    ans.clear();\n    \n    for (int i = 0; i < nn; i++) {\n      cin >> ds[i];\n      dmap[ds[i]]++;\n    }\n\n    memset(ps, 0, sizeof(ps));\n\n    ps[0] = 0;\n    ps[n - 1] = ds[0];\n    dmap[ds[0]]--;\n    max_d = ds[0];\n    \n    rec(0, n - 1);\n\n    sort(ans.begin(), ans.end());\n    \n    for (int i = 0; i < ans.size(); i++) {\n      vi& ai = ans[i];\n\n      for (int j = 0; j < ai.size(); j++) {\n\tif (j > 0) cout << ' ';\n\tcout << ai[j];\n      }\n      cout << endl;\n    }\n    \n    cout << \"-----\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nbool light[50][50];\n\nbool gauss(const mat &A, const vec &b){\n\tint n = A.size();\n\tmat B(n, vec(n+1));\n\trep(i, n)rep(j, n){\n\t\tB[i][j] = A[i][j];\n\t}\n\trep(i, n) B[i][n] = b[i];\n\trep(i, n){\n\t\tint pivot = i;\n\t\trep2(j, i, n){\n\t\t\tif(B[j][i]){\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\t\tif(B[i][i] == 0){\n\t\t\tif(B[i][n]) return false;\n\t\t\telse continue;\n\t\t}\n\n\t\trep(j, n){\n\t\t\tif(i != j && B[j][i]){\n\t\t\t\trep2(k, i + 1, n + 1) if(B[i][k]) B[j][k] = (1 - B[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\tint m, n, d;\n\tint s;\n\twhile(cin >> m >> n >> d && (m || n || d)){\n\t\trep(i, n)rep(j, m){\n\t\t\tcin >> s;\n\t\t\tif(s) light[i][j] = true;\n\t\t\telse light[i][j] = false;\n\t\t}\n\t\tint sz = m * n;\n\t\tmat A(sz, vec(sz));\n\t\tvec b(sz);\n\t\trep(i, n)rep(j, m){\n\t\t\tint a = i * m + j;\n\t\t\trep(k, n)rep(l, m){\n\t\t\t\tif(d == abs(k - i) + abs(l - j) || 0 == abs(k - i) + abs(l - j)){\n\t\t\t\t\tA[a][k*m+l] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tA[a][k*m+l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, m){\n\t\t\tif(light[i][j]) b[i*m+j] = 1;\n\t\t\telse b[i*m+j] = 0;\n\t\t}\n\t\tif(gauss(A, b)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 625+2;\nconst int mod = 2;\nint mat[N][N];\n//if mod is prime\nint mypow(int n,int p){\n  if (p == 0)return 1;\n  int tmp=mypow(n,p/2);\n  tmp=(tmp*tmp)%mod;\n  if (tmp%2==1)tmp=(tmp*n)%mod;\n  return tmp%mod;\n}\n\nint inverse(int now){\n  if (now == 0)return -1;// now answer\n  return mypow(now,mod-2);\n}\n\n//if mod is not prime\n//extended euqlid?\n\n//partial pivot\nbool select_pivot(int r,int c,int k,int mat[N][N]){\n  int s=k;\n  int val=abs(mat[k][k]);\n  REP(i,k+1,r){\n    if (abs(mat[i][k])>val)val=abs(mat[i][k]),s=i;\n  }\n  if (val ==0)return false;\n  REP(i,k,c+1)swap(mat[k][i],mat[s][i]);\n  return true;\n}\n \nbool select_pivot(int r,int c,int k,int mat[N][N],int num[N]){\n int s=k,t=k;//selected pivot\n double val=fabs(mat[k][k]);\n REP(i,k+1,r){\n   REP(j,k+1,c){\n     if (fabs(mat[i][j]) >val){\n       val=fabs(mat[i][j]);\n       s=i;\n       t=j;\n     }\n   }\n }\n \n if ( val<1)return false;//cannot solve this linear equations.\n \n rep(i,r)swap(mat[i][k],mat[i][t]);\n \n swap(num[k],num[t]);\n \n REP(i,k,c+1){\n   swap(mat[k][i],mat[s][i]);\n }\n return true;//no problem for this pivot;\n}\n\nbool gauss(int r,int c,int mat[N][N],int num[N]){\n  rep(k,c){\n    if (!select_pivot(r,c,k,mat,num)){\n      //if (!select_pivot(r,c,k,mat)){\n      REP(i,k,r)if (mat[i][c] == 1)return false;\n      return true;\n    }\n    assert(inverse(mat[k][k]) != -1);\n    REP(i,k+1,c+1)mat[k][i]=(mat[k][i]*inverse(mat[k][k]))%mod;\n    mat[k][k]=1;\n    REP(i,k+1,r){\n      REP(j,k+1,c+1)mat[i][j]=(mat[i][j]+(-mat[i][k]*mat[k][j]+mod))%mod;\n      mat[i][k]=0;\n    }\n  }\n  for(int i=r-1;i>=0;i--){\n    REP(j,i+1,c){\n      mat[i][c]=(mat[i][c]-(mat[i][j]*mat[j][c])+mod)%mod;\n    }\n  }\n  return true;\n}\n\n#define GETPOS(c,i,j) ((i)*(c)+(j))\n\nmain(){\n  int r,c,d;\n  int num[N];\n  while(cin>>c>>r>>d && r){\n    int n=r*c;\n    rep(i,n)rep(j,n+1)mat[i][j]=0;\n    rep(i,n)num[i]=i;\n    rep(i,r)rep(j,c){\n      int tmp;cin>>tmp;\n      mat[GETPOS(c,i,j)][n]=1-tmp;\n    }\n    rep(i,r){\n      rep(j,c){\n\tmat[GETPOS(c,i,j)][GETPOS(c,i,j)]=1;\n\trep(ii,r){\n\t  rep(jj,c){\n\t    if (abs(ii-i)+abs(jj-j) == d){\n\t      mat[GETPOS(c,i,j)][GETPOS(c,ii,jj)]=1;\n\t      //cout << \"(\" <<i<<\",\"<<j<<\"),(\"\n\t      //<< ii<<\",\"<<jj<<\")\"<<endl;\n\t      //cout << GETPOS(c,i,j)+1 <<\" \" << GETPOS(c,ii,jj)+1 << endl;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    /*    rep(i,n){\n      rep(j,n+1)cout << mat[i][j] <<\" \";\n      cout << endl;\n    }      \n    */\n\n    cout << gauss(n,n,mat,num) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 800\n#define maxm 1009\nusing namespace std;\nint b[maxn][maxn],a[maxn][maxn];\nint  guass(int n)\n{\n\tint i,j,p,row=0,col=0;\n\tfor(;row<n&&col<n;row++,col++)\n\t{\n\t\tfor(i=row,p=row;i<n;i++)\n\t\t\tif(a[i][col])\n\t\t\t{p=i;break;}\n\t\tif(p!=row)\n\t\t\tfor(j=col;j<=n;j++)\n\t\t\t\tswap(a[p][j],a[row][j]);\n\t\tif(!a[row][col]) \n\t\t{\n\t\t\trow--;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(i=row+1;i<n;i++)\n\t\t\tif(a[i][col])\n\t\t\tfor(j=col+1;j<=n;j++)\n\t\t\t\ta[i][j]^=a[row][j];\n\t}\n\tfor(i=row;i<n;i++)\n\t\tif(a[i][n]) return 0;\n\treturn 1;\n}\nint main()\n{\n\tint n,m,d;\n\twhile(scanf(\"%d%d%d\",&m,&n,&d)!=EOF&&n+m+d)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t\tscanf(\"%d\",&b[i][j]);\n\t\t}\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\ta[i*m+j][n*m]=b[i][j];\n\t\t\t\ta[i*m+j][i*m+j]=1;\n\t\t\t\tfor(int x=0;x<n;x++)\n\t\t\t\t{\n\t\t\t\t\tfor(int y=0;y<m;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(abs(x-i)+abs(y-j)==d)\n\t\t\t\t\t\t\ta[i*m+j][x*m+y]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(guass(n*m))\n\t\t\tputs(\"1\");\n\t\telse\n\t\t\tputs(\"0\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main(){\n\tint m, n, d;\n\twhile(cin >> m >> n >> d, m){\n\t\tvector< vector<int> > v(n*m, vector<int>(n*m+1,0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tcin >> v[i*m+j][n*m];\n\t\t\t\tfor(int ii=0;ii<n;ii++){\n\t\t\t\t\tfor(int jj=0;jj<m;jj++){\n\t\t\t\t\t\tint dist = abs(i-ii)+abs(j-jj);\n\t\t\t\t\t\tif(dist==0||dist==d) v[ii*m+jj][i*m+j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cur = 0;\n\t\tfor(int i=0;i<n*m;i++){\n\t\t\tint chg = cur;\n\t\t\twhile(chg<n*m && v[chg][i]==0) chg++;\n\t\t\tif(chg == n*m) continue;\n\t\t\tswap(v[cur], v[chg]);\n\t\t\tfor(int j=cur+1;j<n*m;j++){\n\t\t\t\tif(v[j][i]){\n\t\t\t\t\tfor(int k=i;k<n*m+1;k++)\n\t\t\t\t\t\tv[j][k] = (v[j][k]+v[cur][k])%2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur++;\n\t\t}\n\t\tint res = 1;\n\t\tfor(int i=cur;i<n*m;i++)\n\t\t\tif(v[i][n*m] == 1) res = 0;\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nconst int dy[]={-1,0,1,0},dx[]={0,-1,0,1},dy2[]={1,-1,-1,1},dx2[]={1,1,-1,-1};\nint m,n,d,s[25][25];\nint main()\n{\n\tint cs=0;\n\twhile(scanf(\"%d%d%d\",&m,&n,&d),m){\n\t\tint N=m*n;\n\t\tvector<vi> a(N,vi(N+1,0));\n\t\trep(i,m)rep(j,n)scanf(\"%d\",s[i]+j), a[i*n+j][N]=s[i][j];\n\t\t/*if(++cs==413||cs==415){\n\t\t\tcerr<<d<<\" \"<<m<<\" \"<<n<<endl;\n\t\t\trep(i,m)rep(j,n)cerr<<s[i][j]<<(j==n-1?\"\\n\":\" \");\n\t\t}*/\n\t\trep(i,N)(a[i][i]+=1)%=2;\n\t\trep(i,m)rep(j,n)rep(dir,4)rep(k,d){\n\t\t\tint y=i+dy[dir]*d+dy2[dir]*k, x=j+dx[dir]*d+dx2[dir]*k;\n\t\t\tif(0<=y&&y<m&&0<=x&&x<n){\n\t\t\t\t(a[y*n+x][i*n+j]+=1)%=2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint j=0;\n\t\trep(i,N){\n\t\t\tint mi=i;\n\t\t\tif(!a[mi][j])for(int k=i+1;k<N;k++)if(a[mi]<a[k]){\n\t\t\t\tmi=k;\n\t\t\t\tif(a[mi][j])break;\n\t\t\t}\n\t\t\tswap(a[i],a[mi]);\n\t\t\tfor(;j<N&&a[i][j]==0;j++);\n\t\t\tif(j>=N)break;\n\t\t\tassert(a[i][j]);\n\t\t\trep(k,N)if(i<k&&a[k][j])for(int l=j;l<=N;l++)(a[k][l]+=a[i][l])%=2;\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tbool ok=1; j=0;\n\t\trep(i,N)if(ok&&a[i][N]){\n\t\t\tfor(;j<N&&a[i][j]==0;j++);\n\t\t\tif(j>=N)ok=0;\n\t\t}\n\t\t//if(cs==413||cs==415)cerr<<(int)ok<<endl;\n\t\tprintf(\"%d\\n\",(int)ok);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n\nconst ll mod = 2;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    mint add_inv() const{\n        if(x==0) return 0;\n        return mod-x;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nclass matrix{\npublic:\n    vector<vector<mint>> A;\n    int N,M;\n    matrix(int n,int m,vector<vector<mint>> v){\n        N = n; M = m;\n        A = v;\n    }\n    void row_reduction(){\n        int p = 0;\n        for(int j=0;j<M-1;j++){\n            int row = p;\n            while(row<N && !A[row][j].x) row++;\n            if(row==N) continue;\n            swap(A[p],A[row]);\n            for(int i=p+1;i<N;i++){\n                if(A[i][j].x){\n                    mint a = A[i][j]/A[p][p];\n                    for(int k=0;k<M;k++){\n                        A[i][k] -= a*A[p][k];\n                    }\n                }\n            }\n            p++;\n        }\n    }\n};\n\nint main(){\n    int M,N,D;\n    while(cin >> M >> N >> D && M){\n        vector<vector<mint>> v(N*M,vector<mint>(N*M+1));\n        for(int i=0;i<N;i++) for(int j=0;j<M;j++){\n            int a;\n            cin >> a;\n            if(a) v[i*M+j][N*M] = 1;\n            for(int k=0;k<N;k++) for(int l=0;l<M;l++){\n                int d = abs(i-k)+abs(j-l);\n                if(d==0 || d==D) v[i*M+j][k*M+l] = 1;\n            }        \n        }\n        matrix mat(N*M,N*M+1,v);\n/*         for(int i=0;i<N*M;i++) for(int j=0;j<N*M+1;j++) cerr << mat.A[i][j].x << (j!=N*M? \" \":\"\\n\");\n        cerr << endl;\n*/        mat.row_reduction();\n//        for(int i=0;i<N*M;i++) for(int j=0;j<N*M+1;j++) cerr << mat.A[i][j].x << (j!=N*M? \" \":\"\\n\");\n        bool ok = true;\n        for(int i=0;i<N*M;i++){\n            if(!mat.A[i][N*M].x) continue;\n            ok = false;\n            for(int j=0;j<N*M;j++) if(mat.A[i][j].x) ok = true;\n            if(!ok) break;\n        }\n        cout << ok << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint m,n,d,s[25][25];\nint main()\n{\n\twhile(cin>>m>>n>>d,m){\n\t\tint N=m*n;\n\t\tvector<vi> a(N,vi(N+1,0));\n\t\trep(i,m)rep(j,n)cin>>s[i][j], a[i*n+j][N]=s[i][j];\n\t\t\n\t\t//rep(i,N)rep(j,N+1)cerr<<a[i][j]<<(j==N?\"\\n\":\" \");\n\t\t\n\t\trep(i,m)rep(j,n)for(int y=i-d;y<=i+d;y++)for(int x=j-d;x<=j+d;x++)\n\t\tif(0<=y&&y<m&&0<=x&&x<n)\n\t\tif(y==i&&x==j||abs(y-i)+abs(x-j)==d){\n\t\t\t(a[y*n+x][i*n+j]+=1)%=2;\n\t\t}\n\t\t//rep(i,N)rep(j,N+1)cerr<<a[i][j]<<(j==N?\"\\n\":\" \");\n\t\t\n\t\trep(i,N){\n\t\t\tsort(a.begin()+i,a.end(),greater<vi>());\n\t\t\tif(a[i][i]){\n\t\t\t\trep(j,N)if(i!=j&&a[j][i])rep(k,N+1)(a[j][k]+=a[i][k])%=2;\n\t\t\t}\n\t\t}\n\t\t//rep(i,N)rep(j,N+1)cerr<<a[i][j]<<(j==N?\"\\n\":\" \");\n\t\t\n\t\tbool ok=1;\n\t\trep(i,N)if(a[i][N]){\n\t\t\tbool exist=0;\n\t\t\trep(j,N)if(a[i][j])exist=1;\n\t\t\tif(!exist)ok=0;\n\t\t}\n\t\tcout<<(int)ok<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <bitset>\nusing namespace std;\n\n\ninline bool in(int a, int b, int c){\n\treturn a <= b && b < c;\n}\n\n\nint main(){\n\tint m, n, d, s;\n\twhile( scanf(\"%d%d%d\", &m, &n, &d), m != 0 ){\n\t\tint sz = m * n;\n\t\tvector<bitset<626> > v(sz);\n\t\tbitset<625> used;\n\n\t\tint p = 0;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < m; ++j, ++p){\n\t\t\t\tv[p][p] = true;\n\t\t\t\t\n\t\t\t\tfor(int k = 0; k < d; ++k){\n\t\t\t\t\tif( in(0, i - d + k, n) && in(0, j + k, m) ){\n\t\t\t\t\t\tv[p][(i - d + k) * m + (j + k)] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif( in(0, i + k, n) && in(0, j + d - k, m) ){\n\t\t\t\t\t\tv[p][(i + k) * m + (j + d - k)] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif( in(0, i + d - k, n) && in(0, j - k, m) ){\n\t\t\t\t\t\tv[p][(i + d - k) * m + (j - k)] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif( in(0, i - k, n) && in(0, j - d + k, m) ){\n\t\t\t\t\t\tv[p][(i - k) * m + (j - d + k)] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tscanf(\"%d\", &s);\n\t\t\t\tif( s != 0 ){\n\t\t\t\t\tv[p][sz] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < sz; ++i){\n\t\t\tint index = -1;\n\n\t\t\tfor(int j = 0; j < sz; ++j){\n\t\t\t\tif( !used[j] && v[j][i] ){\n\t\t\t\t\tindex = j;\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( index >= 0 ){\n\t\t\t\tfor(int j = 0; j < sz; ++j){\n\t\t\t\t\tif( j != index && v[j][i] ){\n\t\t\t\t\t\tv[j] ^= v[index];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tint ans = 1;\n\t\tfor(int i = 0; i < sz; ++i){\n\t\t\tif( v[i][sz] && v[i].count() == 1 ){\n\t\t\t\tans = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nbool light[50][50];\n\nbool gauss(const mat &A, const vec &b){\n\tint n = A.size();\n\tmat B(n, vec(n+1));\n\trep(i, n)rep(j, n){\n\t\tB[i][j] = A[i][j];\n\t}\n\trep(i, n) B[i][n] = b[i];\n\trep(i, n){\n\t\tint pivot = i;\n\t\trep2(j, i, n){\n\t\t\tif(B[j][i]){\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tswap(B[i], B[pivot]);\n\t\tif(B[i][i] == 0){\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(j, n){\n\t\t\tif(i != j && B[j][i]){\n\t\t\t\trep2(k, i, n + 1) if(B[i][k]) B[j][k] = (1 - B[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, n){\n\t\tbool f = false;\n\t\trep(j, n) if(B[i][j]) f = true;\n\t\tif(!f && B[i][n]) return false;\n\t}\n\n\treturn true;\n}\n\nint main(){\n\tint m, n, d;\n\tint s;\n\twhile(cin >> m >> n >> d && (m || n || d)){\n\t\trep(i, n)rep(j, m){\n\t\t\tcin >> s;\n\t\t\tif(s) light[i][j] = true;\n\t\t\telse light[i][j] = false;\n\t\t}\n\t\tint sz = m * n;\n\t\tmat A(sz, vec(sz));\n\t\tvec b(sz);\n\t\trep(i, n)rep(j, m){\n\t\t\tint a = i * m + j;\n\t\t\trep(k, n)rep(l, m){\n\t\t\t\tif(d == abs(k - i) + abs(l - j) || 0 == abs(k - i) + abs(l - j)){\n\t\t\t\t\tA[a][k*m+l] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tA[a][k*m+l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, n)rep(j, m){\n\t\t\tif(light[i][j]) b[i*m+j] = 1;\n\t\t\telse b[i*m+j] = 0;\n\t\t}\n\t\tif(gauss(A, b)) cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing Vec = vector<int>;\nusing Mat = vector<Vec>;\n\n// ??¬??????????¶?????????§??£???????????¨???\nbool gauss_jordan(const Mat & A, const Vec & b, Vec & res){\n    int n = A.size();\n    Mat B(n, Vec(n + 1));\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            B[i][j] = A[i][j];\n    for(int i = 0; i < n; i++)\n        B[i][n] = b[i];\n\n    // ????????°?????¨???\n    for(int i = 0; i < n; i++){\n\n        // ?????§????????°?????¶????????????????????????i??????????????£?????????\n        int piv = -1;\n        int val = -1;\n        for(int j = i; j < n; j++){\n            if(val < abs(B[j][i])){\n                piv = j;\n                val = abs(B[j][i]);\n            }\n        }\n\n        // ?????????0??????????????????????????????\n        if(piv == -1 || val <= 0)\n            continue;\n        swap(B[piv], B[i]);\n        for(int j = 0; j < n; j++){\n            if(i == j) continue;\n            int mulnum = B[j][i];\n            if(mulnum != 0){\n                for(int k = i; k <= n; k++)\n                    B[j][k] = (B[j][k] + B[i][k]) % 2;\n            }\n        }\n    }\n    res = Vec(n);\n\n    // ???????????????0????????£???????????????????????°????????????0????????£?????????????????????\n    // ?????£?????????????????°????§£????????¨?????????\n    // ?????????0????????????????????????0??????????????????0???????????¨????????????????????°?§£?????¨\n    // ??????????????´??????????§£????????????????????¨\n    for(int i = 0; i < n; i++){\n        res[i] = B[i][n];\n        if(B[i][i] == 0){\n            if(B[i][n] != 0) return false;\n        }\n    }\n    return true;\n}\n\nint main(void){\n    for(int w, h, d; cin >> w >> h >> d, w;){\n        vector<vi> field(h, vi(w));\n        rep(i, h) rep(j, w) cin >> field[i][j];\n\n        Mat a(w * h, Vec(w * h));\n        Vec b(w * h);\n        rep(i, w * h){\n            int y = i / w, x = i % w;\n            b[i] = field[y][x];\n\n            a[i][i] = 1;\n            rep(ni, w * h){\n                int ny = ni / w, nx = ni % w;\n                if(abs(y - ny) + abs(x - nx) == d){\n                    a[i][ni] = 1;\n                }\n            }\n        }\n\n        Vec c;\n        cout << (gauss_jordan(a, b, c) ? 1:0) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct mod\n{\n  int m;\n  mod(int a) : m(a) {}\n  int operator()(int x) const { return ((x%m)+m)%m; }\n};\n\n\nvector<int> gaussian_elimination(vector<vector<int> > a, vector<int> b)\n{\n  static mod M(2);\n  const int N = a.size();\n\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; a[i][i] == 0 && j < N; j++) {\n      swap(a[i], a[j]);\n      swap(b[i], b[j]);\n    }\n    if (a[i][i] == 0) {\n      continue;\n    }\n\n    for (int j = 0; j < N; j++) {\n      if (i == j) {\n        continue;\n      }\n      const int u = a[j][i];\n      for (int k = i; k < N; k++) {\n        a[j][k] = M(a[j][k] - u*a[i][k]);\n      }\n      b[j] = M(b[j] - u*b[i]);\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (a[i][i] == 0 && b[i] != 0) {\n      // no solution\n      return vector<int>();\n    }\n  }\n  return b;\n}\n\nint main()\n{\n  int M, N, D;\n  while (cin >> M >> N >> D && M != 0) {\n    vector<vector<int> > a(M*N, vector<int>(M*N, 0));\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        a[N*i+j][N*i+j] = 1;\n        for (int k = -D; k <= D; k++) {\n          for (int l = -D; l <= D; l++) {\n            const int x = i+k, y = j+l;\n            if (abs(k)+abs(l) == D && 0 <= x && x < N && 0 <= y && y < M) {\n              a[M*i+j][M*x+y] = 1;\n            }\n          }\n        }\n      }\n    }\n\n    vector<int> b(N*M);\n    for (int i = 0; i < N*M; i++) {\n      cin >> b[i];\n    }\n\n    const vector<int> x = gaussian_elimination(a, b);\n    cout << !x.empty() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\n#include <ctime>\n#include <numeric>\n#include <fstream>\nusing namespace std;\nstatic const double EPS = 1e-6;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst long double pi=acos(-1.0);\nint dx[]={0,1,0,-1,1,1,-1,-1,0},dy[]={1,0,-1,0,1,-1,1,-1,0};\n\n\nint n,m,d;\n\n\nvoid solve(){\n  int mat[n*m][n*m+1];\n  memset(mat,0,sizeof(mat));\n\n  rep(i,m*n)mat[i][i]=1;\n  queue<PI> q;\n  q.push(mp(0,0));\n  set<PI> app;\n  vector<PI> man;\n  while(!q.empty()){\n    int cx=q.front().F;\n    int cy=q.front().S;\n    q.pop();\n    if(app.count(mp(cx,cy)))continue;\n    app.insert(mp(cx,cy));\n    if(abs(cx)+abs(cy)==d){\n      man.pb(mp(cx,cy));\n      continue;\n    }\n\n    rep(i,4){\n      int nx=cx+dx[i],ny=cy+dy[i];\n      if(app.count(mp(nx,ny)))continue;\n      q.push(mp(nx,ny));\n    }\n  }\n\n  rep(i,m*n)\n    FOR(it,man){\n    int x=i/m+it->F,y=i%m+it->S;\n    if(min(x,y)<0 || x>=n || y>=m)continue;\n    mat[i][x*m+y]=1;\n  }\n\n  rep(i,n)rep(j,m)\n    cin>>mat[i*m+j][m*n];\n\n\n  int ofs=0;\n  for(int i=0;i+ofs<m*n;++i){\n    /*\n    rep(j,m*n){\n      rep(k,m*n+1)cout<<mat[j][k]<<' ';\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n    if(!mat[i][i+ofs])\n      for(int j=m*n-1;j>i;--j)\n        if(mat[j][i+ofs]){\n          for(int k=0;k<m*n+1;++k)\n            swap(mat[i][k],mat[j][k]);\n          break;\n        }\n    \n    if(mat[i][i+ofs]){\n      for(int j=i+1;j<m*n;++j)\n        if(mat[j][i+ofs])\n          rep(k,m*n+1)\n            mat[j][k]^=mat[i][k];\n    }else ++ofs,--i;\n  }\n\n  for(int i=m*n-1;i>m*n-1-ofs;--i)\n    if(mat[i][m*n]){\n      cout<<0<<endl;\n      return;\n    }\n\n  cout<<1<<endl;\n}\n\nmain(){\n  while(cin>>n>>m>>d,n|m|d)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAXN = 25*25;\n\nbool gaussian_elimination(int a[MAXN][MAXN], int b[MAXN], int N)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = i+1; a[i][i] == 0 && j < N; j++) {\n      for (int k = 0; k < N; k++) {\n        swap(a[i][k], a[j][k]);\n      }\n      swap(b[i], b[j]);\n    }\n    if (a[i][i] == 0) {\n      continue;\n    }\n\n    for (int j = 0; j < N; j++) {\n      if (i == j) {\n        continue;\n      }\n      const int u = a[j][i];\n      for (int k = i; k < N; k++) {\n        a[j][k] = a[j][k] ^ u*a[i][k];\n      }\n      b[j] = b[j] ^ u*b[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    if (a[i][i] == 0 && b[i] != 0) {\n      // no solution\n      return false;\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int M, N, D;\n  while (scanf(\"%d %d %d\", &M, &N, &D) != EOF && M != 0) {\n    static int a[MAXN][MAXN];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < M; j++) {\n        a[M*i+j][M*i+j] = 1;\n        for (int k = 0; k < N; k++) {\n          for (int l = 0; l < M; l++) {\n            const int t = abs(i-k) + abs(j-l);\n            a[M*i+j][M*k+l] = (t == D || t == 0);\n          }\n        }\n      }\n    }\n\n    static int b[MAXN];\n    for (int i = 0; i < N*M; i++) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    printf(\"%d\\n\", gaussian_elimination(a, b, M*N));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <valarray>\n#include <string>\n#include <algorithm>\n#include <set>\ntypedef unsigned long long ull;\ntypedef long long ll;\n\n#define rep(i,n) for(ull i = 0;i<(n);i++)\n#define rep1(i,n) for(ull i = 1;i<=(n);i++)\n#define revrep(i,n) for(ull i = (n-1);i>=0;i--)\n#define all(n) (n).begin(),(n).end()\n#define show(x) cout << \"debug \" << #x << \":\" << x << endl;\n#define showmat(x) cout << endl << \"debug \" << #x << \";\" << endl; \\\n\tfor(ull __i = 0;__i < x.size();__i++){ \\\n\t\tfor(ull __j = 0;__j<x[0].size();__j++){ \\\n\t\t\tcout << x[__i][__j] << \" \"; \\\n\t\t} \\\n\t\tcout << endl; \\\n\t} \\\n\tcout << endl;\n\nusing namespace std;\n\nll M,N,D;\ntypedef valarray<ll> array_t;\nint main(){\n\twhile(cin >> M >> N >> D && M){\n\t\tvalarray<array_t > mat(array_t(0LL,M*N+1), M*N);\n\t\trep(i,M*N){\n\t\t\tcin >> mat[i][M*N];\n\t\t\trep(j,M*N){\n\t\t\t\tint curx=i%M, cury=i/M, trgx=j%M, trgy=j/M;\n\t\t\t\tll d = abs(curx-trgx)+abs(cury-trgy);\n\t\t\t\tif(d == 0 || d == D){\n\t\t\t\t\tmat[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t//hakidashi\n\t\trep(i,M*N){\n\t\t\tint nonzeroR = -1;\n\t\t\tfor(ll p = i;p<M*N;p++){\n\t\t\t\tif(mat[p][i] != 0){\n\t\t\t\t\tnonzeroR = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nonzeroR == -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswap(mat[i],mat[nonzeroR]);\n\t\t\tfor(ll j = 0;j<M*N;j++){\n\t\t\t\tif(j == i){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(mat[j][i] == 1){\n\t\t\t\t\tmat[j] += mat[i];\n\t\t\t\t}\n\t\t\t\tmat[j] %= 2;\n\t\t\t}\n\t\t}\n\n\t\tbool ans = true;\n\t\trep(i,M*N){\n\t\t\tbool rowzero = true;\n\t\t\trep(j,M*N){\n\t\t\t\tif(mat[i][j] != 0){\n\t\t\t\t\trowzero = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rowzero && mat[i][M*N] == 1){\n\t\t\t\tans = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans){\n\t\t\tcout << 1 << endl;\n\t\t}else{\n\t\t\tcout << 0 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int MAX_ROW = 1010;\nconst int MAX_COL = 1010;\nstruct BitMatrix {\n    int H, W;\n    std::bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline std::bitset<MAX_COL>& operator [] (int i) {return val[i];}\n};\nstd::ostream& operator << (std::ostream& s, BitMatrix A) {\n    s << std::endl;\n    for (int i = 0; i < A.H; ++i) {\n        for (int j = 0; j < A.W; ++j) {\n            s << A[i][j] << \", \";\n        }\n        s << std::endl;\n    }\n    return s;\n}\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col < A.W; ++col) {\n        if (is_extended && col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row < A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        std::swap(A[pivot], A[rank]);\n        for (int row = 0; row < A.H; ++row) {\n            if (row != rank && A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\nint linear_equation(BitMatrix A, std::vector<int> b, std::vector<int> &res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n    for (int row = rank; row < m; ++row) if (M[row][n]) return -1;\n    res.assign(n, 0);\n    for (int i = 0; i < rank; ++i) res[i] = M[i][n];\n    return rank;\n};\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst ld eps = 1e-9;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nvoid solve(int m) {\n  int n, d; cin >> n >> d;\n  vvi v(n, vi(m));\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<m;++j) {\n      cin >> v[i][j];\n    }\n  }\n  BitMatrix A(n*m, n*m);\n  vi b(n*m);\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<m;++j) {\n      A[i*m+j][i*m+j] = !A[i*m+j][i*m+j];\n      b[i*m+j] = v[i][j];\n      for(int k=0;k<n;++k) {\n        for(int l=0;l<m;++l) {\n          if(abs(i-k)+abs(j-l) == d) {\n            A[i*m+j][k*m+l] = !A[i*m+j][k*m+l];\n          }\n        }\n      }\n    }\n  }\n  vi res(n*m);\n  int result = linear_equation(A, b, res);\n  if(result == -1) {\n    cout << 0 << endl;\n  } else {\n    cout << 1 << endl;\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int m; cin >> m;\n    if(m == 0) break;\n    solve(m);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n#include <bitset>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nvector<bitset<626> > v(625);\nint n,m,d;\n\nbool inside(int x, int y) {\n\tif (x<0 || x>=n) return 0;\n\tif (y<0 || y>=m) return 0;\n\treturn 1;\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d%d\",&m,&n,&d) && n!=0) {\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tfor (int j=0; j<m; j++) {\n\t\t\t\tint k = i*m+j;\n\t\t\t\tv[k].reset();\n\t\t\t\tv[k][k] = 1;\n\t\t\t\tint b;\n\t\t\t\tcin>>b;\n\t\t\t\tv[k][n*m] = b;\n\t\t\t\tfor (int h=0; h<=d; h++) {\n\t\t\t\t\tint x = i+h;\n\t\t\t\t\tint y = j+(d-h);\n\t\t\t\t\tif (inside(x,y)) v[k][x*m+y] = 1;\n\t\t\t\t\tx = i+h;\n\t\t\t\t\ty = j-(d-h);\n\t\t\t\t\tif (inside(x,y)) v[k][x*m+y] = 1;\n\t\t\t\t\tx = i-h;\n\t\t\t\t\ty = j+(d-h);\n\t\t\t\t\tif (inside(x,y)) v[k][x*m+y] = 1;\n\t\t\t\t\tx = i-h;\n\t\t\t\t\ty = j-(d-h);\n\t\t\t\t\tif (inside(x,y)) v[k][x*m+y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint k = 0;\n\t\tfor (int i=0 ;i<m*n; i++) {\n\t\t\tint j = k;\n\t\t\twhile (j<m*n && !v[j][i]) j++;\n\t\t\tif (j==m*n) continue;\n\t\t\tswap(v[k],v[j]);\n\t\t\tfor (int j=k+1; j<m*n; j++) if (v[j][i]) v[j] ^= v[k];\n\t\t\tk++;\n\t\t}\n\t\tint ans = 1;\n\t\t\n\t\tfor (int j=0; j<m*n; j++) {\n\t\t\tif (v[j][m*n] && v[j].count()==1) ans = 0;\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t\t\n\t}\n\t\t\t\t\t\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <iostream>\n#include <algorithm>\n\n#define coor(i,j) ((i)+(j)*m)\n#define in(i,j) (0<=(i)&&(i)<m&&0<=(j)&&(j)<n)\nusing namespace std;\nvector<bitset<626> > M(625);\n\nmain(){\n\tint m,n,d;\n\tint i,j,k;\n\tint success,ans;\n\tfor(;cin>>m>>n>>d,d;cout<<ans<<endl){\n\t\t//create M\n\t\tfor(j=0;j<n;j++)\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tM[coor(i,j)].reset();\n\t\t\t\tM[coor(i,j)][coor(i,j)]=1;\n\t\t\t\tcin>>k;M[coor(i,j)][m*n]=k;\n\n\t\t\t\tfor(k=0;k<=d;k++){\n\t\t\t\t\tif(in(i-k,j-(d-k)))M[coor(i,j)][coor(i-k,j-(d-k))]=1;\n\t\t\t\t\tif(in(i+k,j-(d-k)))M[coor(i,j)][coor(i+k,j-(d-k))]=1;\n\t\t\t\t\tif(in(i-k,j+(d-k)))M[coor(i,j)][coor(i-k,j+(d-k))]=1;\n\t\t\t\t\tif(in(i+k,j+(d-k)))M[coor(i,j)][coor(i+k,j+(d-k))]=1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t//solve\n\t\tk=0;\n\t\tfor(i=0;i<m*n;i++){\n\t\t\tfor(j=k;j<m*n&&!M[j][i];j++);\n\t\t\tif(j==m*n)continue;\n\t\t\tswap(M[k],M[j]);\n\t\t\tfor(j=k+1;j<m*n;j++)if(M[j][i])M[j]^=M[k];\n\t\t\tk++;\n\t\t}\n\n\t\t//finalize\n\t\tans=1;\n\t\tfor(j=k;j<m*n;j++)if(M[j][m*n])ans=0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1308\n// http://drken1215.hatenablog.com/entry/2019/03/20/160500\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n\nint dx[] = { 1, -1, 0, 0 };\nint dy[] = { 0, 0, 1, -1 };\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\n\nint gcd(int a, int b) {\n  if (a < b) { swap(a, b); }\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nbool prime(int n) {\n  for (int i = 2; i <= sqrt(n); ++i) {\n    if (n % i == 0) { return false; }\n  }\n  return n != 1;\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nconst ll INF = 1e9;\nconst ll MOD = 1000000007;  // 1e9 + 7\n\nll powmod(ll x, ll y) {\n  ll r = 1;\n  while (y) {\n    if (y & 1) {\n      r = r * x % MOD;\n    }\n    x = x * x % MOD;\n    y >>= 1;\n  }\n  return r;\n}\n\nconst int COM_MAX = 500010;\nll fac[COM_MAX], facinv[COM_MAX], inv[COM_MAX];\nvoid COMinit() {\n  fac[0] = fac[1] = 1;\n  facinv[0] = facinv[1] = 1;\n  inv[1] = 1;\n  for(int i = 2; i < COM_MAX; ++i) {\n    fac[i] = fac[i-1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    facinv[i] = facinv[i-1] * inv[i] % MOD;\n  }\n}\n\nll COM(ll n, ll k) {\n  return (fac[n] * facinv[k] % MOD) * facinv[n-k] % MOD;\n}\n\nll PERM(ll n, ll k) {\n  return (fac[n] * facinv[k] % MOD);\n}\n\nconst int MAX_ROW = 1010; // To be set appropriately.\nconst int MAX_COL = 1010; // To be set appropriately.\n\nclass BitMatrix {\npublic:\n  BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n  inline bitset<MAX_COL>& operator [] (int i) { return val[i]; }\n\n  int H, W;\n\nprivate:\n  bitset<MAX_COL> val[MAX_ROW];\n};\n\nostream& operator << (ostream& s, BitMatrix A) {\n  s << endl;\n  rep(i, A.H) {\n    rep(j, A.W) {\n      s << A[i][j] << \", \";\n    }\n    s << endl;\n  }\n  return s;\n}\n\nint GaussJordan(BitMatrix &A, bool is_extended = false) {\n  int rank = 0;\n  rep(col, A.W) {\n    if (is_extended && col == A.W - 1) { break; }\n    int pivot = -1;\n    for (int row = rank; row < A.H; ++row) {\n      if (A[row][col]) {\n        pivot = row;\n        break;\n      }\n    }\n    if (pivot == -1) continue;\n    swap(A[pivot], A[rank]);\n    rep(row, A.H) {\n      if (row != rank && A[row][col]) {\n        A[row] ^= A[rank];\n      }\n    }\n    ++rank;\n  }\n  return rank;\n}\n\nint linear_equation(BitMatrix A, vector<int> b, vector<int> &res) {\n  int m = A.H, n = A.W;\n  BitMatrix M(m, n + 1);\n  rep(i, m) {\n    rep(j, n) {\n      M[i][j] = A[i][j];\n    }\n    M[i][n] = b[i];\n  }\n  int rank = GaussJordan(M, true);\n\n  // check if it has no solution\n  for (int row = rank; row < m; ++row) {\n    if (M[row][n]) { return -1; }\n  }\n\n  // answer\n  res.assign(n, 0);\n  rep(i, rank) {\n    res[i] = M[i][n];\n  }\n  return rank;\n}\n\nint main(int argc, char** argv) {\n  while (true) {\n    int M, N, D;\n    cin >> M >> N >> D;\n    if (M == 0 && N == 0 && D == 0) { break; }\n\n    vector< vector<int> > a(N, vector<int>(M));\n    rep(i, N) {\n      rep(j, M) {\n        cin >> a[i][j];\n      }\n    }\n\n    BitMatrix A(N*M, N*M);\n    vector<int> b(N*M);\n    rep(i, N) {\n      rep(j, M) {\n        A[i*M+j][i*M+j] = 1;\n        rep(k, N) {\n          rep(l, M) {\n            if (abs(i-k) + abs(j-l) != D) { continue; }\n            A[i*M+j][k*M+l] = 1;\n          }\n        }\n        b[i*M+j] = 1 - a[i][j];\n      }\n    }\n\n    vector<int> res;\n    int rank = linear_equation(A, b, res);\n    if (rank == -1) {\n      cout << 0 << endl;\n    } else {\n      cout << 1 << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <valarray>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef valarray<int> array_t;\nint M, N, D;\n\nint solve(valarray<array_t>& A){\n\tint p = 0, r, k;\n\tfor(int i = 0; i < M*N; i++){\n\t\tfor(k = p; k < M*N; k++){\n\t\t\tif(A[k][i] != 0){\n\t\t\t\tr = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(k == M*N) continue;\n\t\tswap(A[p],A[r]);\n\t\tfor(int j = p + 1; j < M*N; j++){\n\t\t\tif(A[j][i]){\n\t\t\t\tA[j] += A[p];\n\t\t\t\tA[j] %= 2;\n\t\t\t}\n\t\t}\n\t\tp++;\n\t}\n\tfor(int r = 0; r < M*N; r++){\n\t\tif(A[r][M*N] != 0){\n\t\t\tint flag = 0;\n\t\t\tfor(int i = 0; i < M*N;i++) flag += A[r][i];\n\t\t\tif(flag == 0) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\twhile(cin >> M >> N >> D && M){\n\t\tvalarray<array_t> A(array_t(0, M*N+1), M*N);\n\t\tfor(int i = 0; i < M*N; i++){\n\t\t\tcin >> A[i][M*N];\n\t\t\tfor(int j = 0; j < M*N; j++){\n\t\t\t\tint x0 = i % M, y0 = i / M, x1 = j % M, y1 = j / M;\n\t\t\t\tint d = abs(x0-x1) + abs(y0-y1);\n\t\t\t\tif (d == 0 || d == D) A[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tcout << solve(A) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nint M,N,D;\n\n\nvoid view( const mat& a ){\n  cout << \"mat view\" << endl;\n  for(int i=0;i<(int)a.size();i++){\n    for(int j=0;j<(int)a[i].size();j++) cout << a[i][j] << \" \";\n    cout << endl;\n  }\n}\nvoid view( const vec& a ){\n  cout<<\"vec view\" << endl;\n  for( int i : a ){\n    cout <<i <<  \" \";\n  }\n  cout << endl;\n}\n\nint getid(int y,int x){\n  return y+x*N;\n}\n\nvec mod_gauss_jordan( const mat &A, const vec& b ){\n  int n = A.size();\n  mat B(n, vec(n+1));\n  for( int i=0;i<n;i++ )\n    for(int j=0;j<n;j++)\n      B[i][j] = A[i][j];\n  for(int i=0;i<n;i++) B[i][n] = b[i];\n  \n  //view( B );\n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i+1;j<n;j++) if( B[j][i]>B[pivot][i] ) pivot = j;\n    swap(B[pivot],B[i]);\n    \n    //if( B[i][i] < 1 ) return vec();\n\n    for(int j=0;j<n;j++)\n      if( i != j && B[j][i] )\n        for(int k=i;k<=n;k++){\n          B[j][k] = (B[j][k] + B[i][k])%2;            \n        }\n    \n    //cout << \"in \" << i << endl;\n    //view( B );\n  }\n  vec x(n);\n  for(int i=0;i<n;i++) x[i] = B[i][n];\n\n  for(int i=0;i<n;i++){\n    int p = 0;\n    for(int j=0;j<n;j++){\n      //cout << A[i][j]<<  \" : \"<< x[j] << endl;\n      if( A[i][j] ) p = (p+x[j])%2;\n    }\n    //cout << p << \" = \" << b[i] << endl;\n    if( p!=b[i] ) return vec();\n    assert( p==b[i] );\n  }\n  return x;\n}\n\n\nint main(){\n  while( cin >> M >> N >> D && (M||N||D) ){\n    int S[30][30];\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)\n        cin >> S[i][j];\n\n    mat mt = mat(N*M);\n    for(int i=0;i<N;i++){\n      for(int j=0;j<M;j++){\n        vec V = vec(N*M,0);\n        for(int y=0;y<N;y++){\n          for(int x=0;x<M;x++){\n            int d = abs(y-i) + abs(x-j);\n            if( d == D ) \n              V[getid(y,x)] = 1;            \n          }\n        }        \n        V[getid(i,j)] = 1;\n        assert( getid(i,j)%N == i && getid(i,j)/N == j );\n        mt[getid(i,j)] = V;\n      }\n    }\n    vec B = vec( N*M );\n    for(int i=0;i<N;i++)\n      for(int j=0;j<M;j++)\n        if( S[i][j] == 1 ) B[getid(i,j)] = 1;\n\n    //view(mt);\n    //view(B);\n    vec res = mod_gauss_jordan( mt, B );\n    if( res.empty() ) cout << 0 << endl;\n    else {\n      cout << 1 << endl;\n      for(int i=0;i<N*M;i++){\n        int iy = i%N, ix = i/N;\n        assert( getid(iy,ix) == i );\n        if( res[i] ){  \n          S[iy][ix] = 1-S[iy][ix];\n          for(int y=0;y<N;y++)\n            for(int x=0;x<N;x++)\n              if( D == abs( y-iy ) + abs( x-ix )  )\n                S[y][x] = 1-S[y][x];\n        }\n      }/*\n      for(int i=0;i<N;i++){\n        for(int j=0;j<M;j++) cout << S[i][j];\n        cout << endl;\n        }*/\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int mod = 2; // assert mod is prime\n\ntemplate<int M>\nstruct Mint{\n\tint x;\n\tMint() : x(0){}\n\tMint(int y) : x(y >= 0 ? y % M : M - (-y) % M){}\n\tMint &operator += (const Mint &rhs){ if((x += rhs.x) >= M) x -= M; return *this; }\n\tMint &operator -= (const Mint &rhs){ if((x += M - rhs.x) >= M) x -= M; return *this; }\n\tMint &operator *= (const Mint &rhs){ x = 1LL * x*rhs.x % M; return *this; }\n\tMint &operator /= (const Mint &rhs){ x = (1LL * x*rhs.inv().x) % M; return *this; }\n\tMint operator - () const{ return Mint(-x); }\n\tMint operator + (const Mint &rhs) const{ return Mint(*this) += rhs; }\n\tMint operator - (const Mint &rhs) const{ return Mint(*this) -= rhs; }\n\tMint operator * (const Mint &rhs) const{ return Mint(*this) *= rhs; }\n\tMint operator / (const Mint &rhs) const{ return Mint(*this) /= rhs; }\n\tbool operator < (const Mint &rhs) const{ return x < rhs.x; }\n\tMint inv() const{\n\t\tsigned a = x, b = M, u = 1, v = 0, t;\n\t\twhile(b){ t = a / b; a -= t * b; swap(a, b); u -= t * v; swap(u, v); }\n\t\treturn Mint(u);\n\t}\n\tMint pow(long long t) const{\n\t\tMint e = *this, res = 1;\n\t\tfor(; t; e *= e, t >>= 1) if(t & 1) res *= e;\n\t\treturn res;\n\t}\n};\ntemplate <int M>\nostream &operator << (ostream &os, const Mint<M> &rhs){\n\treturn os << rhs.x;\n}\ntemplate <int M>\nistream &operator >> (istream &is, Mint<M> &rhs){\n\tlong long s; is >> s; rhs = Mint<M>(s); return is;\n};\n\nusing mint = Mint<mod>;\n\nusing Array = vector<mint>;\nusing Matrix = vector<Array>;\nconst double eps = 1e-10;\n\nvoid outMat(const Matrix& A){\n\tint n = A.size(), m = A[0].size();\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tcout << A[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nArray GaussJordan(const Matrix& A, const Array& b){\n\tint n = A.size();\n\tMatrix B(n, Array(n + 1));\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\tB[i][j] = A[i][j];\n\tfor(int i = 0; i < n; i++) B[i][n] = b[i];\n\tfor(int i = 0; i < n; i++){\n\t\tint pivot = i;\n\t\tfor(int j = i; j < n; j++){\n\t\t\tif(B[j][i].x > B[pivot][i].x) pivot = j;\n\t\t\t//if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n\t\t}\n\t\t//outMat(B);\n\t\tswap(B[i], B[pivot]);\n\t\t//outMat(B);\n\n\t\t//if(abs(B[i][i]) < eps) return Array();\n\t\tfor(int j = i + 1; j <= n; j++) B[i][j] /= B[i][i];\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i != j){\n\t\t\t\tfor(int k = i + 1; k <= n; k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t}\n\t\t}\n\t\t//outMat(B);\n\t}\n\n\t//outMat(B);\n\n\tArray x(n);\n\tfor(int i = 0; i < n; i++) x[i] = B[i][n];\n\treturn x;\n}\n\nint b[25][25];\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint m, n, d;\n\twhile(cin >> m >> n >> d, m){\n\t\tint N = n * m;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tcin >> b[i][j];\n\t\t\t}\n\t\t}\n\n\t\tMatrix A(N, Array(N));\n\t\tArray B(N);\n\t\tfor(int i1 = 0; i1 < n; i1++){\n\t\t\tfor(int j1 = 0; j1 < m; j1++){\n\t\t\t\tfor(int i2 = 0; i2 < n; i2++){\n\t\t\t\t\tfor(int j2 = 0; j2 < m; j2++){\n\t\t\t\t\t\tint D = abs(i1 - i2) + abs(j1 - j2);\n\t\t\t\t\t\tA[i1 * m + j1][i2 * m + j2] = (D == 0 || D == d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tB[i1 * m + j1] = b[i1][j1];\n\t\t\t}\n\t\t}\n\t\t//outMat(A);\n\t\tauto X = GaussJordan(A, B);\n\n\t\tint ok = 1;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tmint k = 0;\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tk += A[i][j] * X[j];\n\t\t\t}\n\t\t\tif(k.x != B[i].x){\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << ok << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\n\ntemplate<class T> struct Matrix {\n    vector<vector<T> > val;\n    Matrix(int n = 1, int m = 1) {val.clear(); val.resize(n, vector<T>(m));}\n    Matrix(int n, int m, T x) {val.clear(); val.resize(n, vector<T>(m, x));}\n    void resize(int n, int m) {val.clear(); val.resize(n, vector<T>(m));}\n    int size() {return val.size();}\n    inline vector<T>& operator [] (int i) {return val[i];}\n    friend ostream& operator << (ostream& s, Matrix<T> M) {s << M.val; return s;}\n};\n\n\n\ntemplate<class T> int Gauss_Jordan(Matrix<T> A, vector<T> b, int p) {\n\tint rank = 0;\n    Matrix<T> M(A.size(), A[0].size()+1);\n    for (int i = 0; i < A.size(); ++i) {\n        for (int j = 0; j < A[0].size(); ++j) M[i][j] = A[i][j];\n        M[i][A[0].size()] = b[i];\n    }\n//    for (int i = 0; i < M.size(); ++i) \n//        for (int j = 0; j < M[0].size(); ++j)\n//            M[i][j] = mod(M[i][j], p);\n    \n    vint core, rem;\n\tfor (int i = 0; i < A[0].size(); ++i) {\n\t\tint pivot = rank;\n        bool exist = false;\n        for (int j = rank; j < M.size(); ++j) {\n            if (M[j][i] != 0) {\n                pivot = j;\n                exist = true;\n                break;\n            }\n        }\n\t\tif (exist) {\n            core.PB(i);\n\t\t\tswap(M[pivot], M[rank]);\n//            T inv = inverse(M[rank][i], p);\n            for (int j = 0; j < M[0].size(); ++j) {\n//                M[rank][j] = M[rank][j] * inv;\n                M[rank][j] = abs(M[rank][j]);\n            }\n\t\t\tfor (int j = 0; j < M.size(); ++j) {\n\t\t\t\tif (j != rank && abs(M[j][i]) > 0) {\n                    T fac = M[j][i];\n\t\t\t\t\tfor (int k = 0; k < M[0].size(); ++k) {\n                        M[j][k] = M[j][k] - M[rank][k] * fac;\n                        M[j][k] = abs(M[j][k]);\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t++rank;\n        }\n        else rem.PB(i);\n\t}\n    \n    for (int i = rank; i < M.size(); ++i) \n        if (abs(M[i][M[0].size()-1]) > 0) return -1;\n    \n    return A[0].size() - rank;\n};\n\n\nconst int MAX = 30;\nint m, n, d;\nint S[MAX][MAX];\n\nint get(int a, int b) {\n    return a * m + b;\n}\n\nint main() {\n    while (cin >> m >> n >> d) {\n        if (m == 0) break;\n        \n        for (int i = 0; i < n; ++i) \n            for (int j = 0; j < m; ++j)\n                cin >> S[i][j];\n        \n        Matrix<int> A(m*n, m*n, 0);\n        vector<int> b(m*n, 0);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (S[i][j] & 1) b[get(i,j)] = 1;\n                \n                for (int k = 0; k < n; ++k) {\n                    for (int l = 0; l < m; ++l) {\n                        int dist = abs(k-i) + abs(l-j);\n                        if (dist == 0 || dist == d) {\n                            A[get(i,j)][get(k,l)] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        int res = Gauss_Jordan(A, b, 2);\n\n        if (res >= 0) cout << 1 << endl;\n        else cout << 0 << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n\n#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <numeric>\n#include <list>\nusing namespace std;\n\nusing QWORD  = uint64_t;\nusing SQWORD = int64_t;\nusing DWORD  = uint32_t;\nusing SDWORD = int32_t;\nusing WORD   = uint16_t;\nusing SWORD  = int16_t;\nusing BYTE   = uint8_t;\nusing SBYTE  = int8_t;\nusing DOUBLE = double;\nusing FLOAT  = float;\n\n#define MIN_SDWORD (-2147483648)\n#define MAX_SDWORD (2147483647)\n#define MIN_SBYTE (-128)\n#define MAX_SBYTE (127)\n\n#define MIN_SQWORD (0x8000000000000000)\n#define MAX_SQWORD (0x7FFFFFFFFFFFFFFF)\n\n#define MAX_QWORD  (0xFFFFFFFFFFFFFFFF)\n#define MAX_DWORD  (0xFFFFFFFF)\n#define MAX_WORD   (0xFFFF)\n#define MAX_BYTE   (0xFF)\n\n#define MAX_DOUBLE      (1.0e+308)\n#define DOUBLE_EPS      (1.0e-12)\n#define MIN_DOUBLE_N    (-1.0e+308)\n\n#define ArrayLength(a)  (sizeof(a) / sizeof(a[0]))\n\nstatic inline DOUBLE MAX(DOUBLE a, DOUBLE b) { return a > b ? a : b; }\nstatic inline QWORD MAX(QWORD a, QWORD b) { return a > b ? a : b; }\nstatic inline DWORD MAX(DWORD a, DWORD b) { return a > b ? a : b; }\nstatic inline SDWORD MAX(SDWORD a, SDWORD b) { return a > b ? a : b; }\nstatic inline DOUBLE MIN(DOUBLE a, DOUBLE b) { return a < b ? a : b; }\nstatic inline QWORD MIN(QWORD a, QWORD b) { return a < b ? a : b; }\nstatic inline DWORD MIN(DWORD a, DWORD b) { return a < b ? a : b; }\nstatic inline SDWORD MIN(SDWORD a, SDWORD b) { return a < b ? a : b; }\n\n#define BYTE_BITS   (8)\n#define WORD_BITS   (16)\n#define DWORD_BITS  (32)\n#define QWORD_BITS  (64)\n\nstatic inline void inputStringSpSeparated(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c) || (' ' == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\nstatic inline void inputString(char *pcStr)\n{\n    char *pcCur = pcStr;\n    for (;;) {\n        char c = getchar();\n        if (('\\n' == c) || (EOF == c)) {\n            break;\n        }\n        *pcCur = c;\n        pcCur++;\n    }\n    *pcCur = '\\0';\n}\n\n\nstatic inline SQWORD inputSQWORD(void)\n{\n    SQWORD sqNumber = 0;\n    SQWORD sqMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                sqMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            sqNumber *= 10LL;\n            sqNumber += (SQWORD)(c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return sqNumber * sqMultiplier;\n            }\n        }\n    }\n}\n\n\nstatic inline SDWORD inputSDWORD(void)\n{\n    SDWORD lNumber = 0;\n    SDWORD lMultiplier = 1;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                lMultiplier = -1;\n            }\n        }\n        if (('0' <= c) && (c <= '9')) {\n            lNumber *= 10;\n            lNumber += (c - '0');\n            bRead = true;\n        } else {\n            if (bRead) {\n                return lNumber * lMultiplier;\n            }\n        }\n    }\n}\n\nstatic inline DOUBLE inputFP(void)\n{\n    DOUBLE dInt = 0.0;\n    DOUBLE dFrac = 0.0;\n    DOUBLE dMultiplier = 1.0;\n    DWORD dwFpCnt = 0;\n    DOUBLE *pdCur = &dInt;\n    bool bRead = false;\n    for (;;) {\n        char c = getchar();\n        if (!bRead) {\n            if ('-' == c) {\n                dMultiplier = -1;\n            }\n        }\n        if ('.' == c) {\n            pdCur = &dFrac;\n        } else if (('0' <= c) && (c <= '9')) {\n            (*pdCur) *= 10;\n            (*pdCur) += (DOUBLE)(c - '0');\n            bRead = true;\n            if (pdCur == &dFrac) {\n                dwFpCnt++;\n            }\n        } else {\n            if (bRead) {\n                return dMultiplier * (dInt + dFrac / (pow((DOUBLE)10.0 , (DOUBLE)dwFpCnt)));\n            }\n        }\n    }\n}\n\n\n/**\n *  mod による操作ライブラリ\n */\n\n#define ANS_MOD (1000000007LL)\n \nstatic SQWORD addMod(SQWORD x, SQWORD y)\n{ \n    return (x + y) % ANS_MOD;\n}\n \nstatic SQWORD subMod(SQWORD x, SQWORD y)\n{\n    return (x - y + ANS_MOD) % ANS_MOD;\n}\n \nstatic SQWORD mulMod(SQWORD x, SQWORD y) \n{\n    return (x * y) % ANS_MOD;\n}\n \nstatic SQWORD powMod(SQWORD x, SQWORD e) {\n    SQWORD v = 1;\n    for (; e; x = mulMod(x, x), e >>= 1) {\n        if (e & 1) {\n            v = mulMod(v, x);\n        }\n    }\n    return v;\n}\n \nstatic SQWORD divMod(SQWORD x, SQWORD y)\n{\n    return mulMod(x, powMod(y, ANS_MOD - 2));\n}\n \n \nstatic SQWORD combMod(SQWORD n, SQWORD k)\n{\n    SQWORD v=1;\n    for(SQWORD i=1; i<=k; i++) {\n        v = divMod(mulMod(v, n-i+1),i);\n    } \n    return v;\n}\n\n/*----------------------------------------------*/\n\nclass Matrix {\nprivate:\n    SQWORD nRows;\n    SQWORD nCols;\n    vector<SQWORD> vecsqVal;\n\n    SQWORD getIdx(SQWORD r, SQWORD c) {\n        return r * nCols + c;\n    }\n    SQWORD op_sub(SQWORD a, SQWORD b) {\n        return (a^b);\n    }\n\npublic:\n    Matrix(SQWORD r, SQWORD c) : nRows(r), nCols(c) {\n        vecsqVal.resize(r * c);\n    };\n    void setValue(SQWORD r, SQWORD c, SQWORD v) {\n        SQWORD sqIdx = getIdx(r, c);\n        vecsqVal[sqIdx] = v;\n    };\n    SQWORD getValue(SQWORD r, SQWORD c) {\n        SQWORD sqIdx = getIdx(r, c);\n        return vecsqVal[sqIdx];\n    }\n    SQWORD getRowNum(void) {return nRows;};\n    SQWORD getColNum(void) {return nCols;};\n    void swapRows(SQWORD r1, SQWORD r2) {\n        for (SQWORD sqColIdx = 0; sqColIdx < nCols; sqColIdx++) {\n            SQWORD sqIdx1 = getIdx(r1, sqColIdx);\n            SQWORD sqIdx2 = getIdx(r2, sqColIdx);\n            swap(vecsqVal[sqIdx1], vecsqVal[sqIdx2]);\n        }\n    }\n    void diffRows(SQWORD r1, SQWORD r2) {\n        for (SQWORD sqColIdx = 0; sqColIdx < nCols; sqColIdx++) {\n            SQWORD sqIdx1 = getIdx(r1, sqColIdx);\n            SQWORD sqIdx2 = getIdx(r2, sqColIdx);\n            vecsqVal[sqIdx1] = op_sub(vecsqVal[sqIdx1], vecsqVal[sqIdx2]);\n        }\n    }\n    void print(void) \n    {  \n        printf(\"---!\\n\");\n        for (SQWORD sqRowIdx = 0; sqRowIdx < nRows; sqRowIdx++) {\n            for (SQWORD sqColIdx = 0; sqColIdx < nCols; sqColIdx++) {\n                SQWORD sqIdx = getIdx(sqRowIdx, sqColIdx);\n                printf(\"%d \", vecsqVal[sqIdx]);\n            }\n            printf(\"\\n\");\n        }\n        printf(\"---!\\n\");\n    }\n\n    bool solve1DEquation(SQWORD& sqRank) {\n        sqRank = 0;\n        for (SQWORD sqColIdx = 0; sqColIdx < nCols - 1; sqColIdx++) {\n            bool bPivot = true;\n//            printf(\"%lld %lld\\n\", sqColIdx, sqRank);\n            if (0 == getValue(sqRank, sqColIdx)) {\n                /* search non zero pivot  ->  swap rows */\n                SQWORD sqSearchRow = sqRank + 1;\n                for (; sqSearchRow < nRows; sqSearchRow++) {\n                    if (0 != getValue(sqSearchRow, sqColIdx)) {\n                        break;\n                    }\n                }\n                if (sqSearchRow == nRows) {\n                    /* All Zero */\n                    bPivot = false;\n                } else {\n//                    printf(\"   s[%lld %lld]\\n\", sqRank, sqSearchRow);\n                    swapRows(sqRank, sqSearchRow);\n//                    print();\n                }\n            }\n            /* pivot */\n            if (bPivot) {\n                for (SQWORD sqTargetRow = 0; sqTargetRow < nRows; sqTargetRow++) {\n                    if (sqTargetRow != sqRank) {\n                        if (1 == getValue(sqTargetRow, sqColIdx)) {\n//                           printf(\"   d[%lld %lld]\\n\", sqTargetRow, sqRank);\n                            diffRows(sqTargetRow, sqRank);\n                        }\n                    }\n                }\n                sqRank++;\n            }\n        }\n        return true;\n    }\n};\n\n#define     N_MAX_ROW   (25)\n#define     N_MAX_COL   (25)\n#define     N_MAX_DIM   (N_MAX_ROW * N_MAX_COL)\n#define     N_MAX_EQ_ROWS   (N_MAX_DIM)\n#define     N_MAX_EQ_COLS   (N_MAX_DIM + 1)\n\nstatic SQWORD getEqCoeffIdx(\n    SQWORD sqRowIdx,\n    SQWORD sqColIdx,\n    SQWORD sqNrows,\n    SQWORD sqNcols)\n{\n    return sqRowIdx * sqNcols + sqColIdx;\n}\n\nstatic bool isInrange(\n    SQWORD sqRowIdx,\n    SQWORD sqColIdx,\n    SQWORD sqNrows,\n    SQWORD sqNcols)\n{\n    return (((0 <= sqRowIdx) && (sqRowIdx < sqNrows))\n            && ((0 <= sqColIdx) && (sqColIdx < sqNcols)));\n}\n\nstatic void configureCoeffs(\n    Matrix &Ary,\n    SQWORD sqNrows,\n    SQWORD sqNcols,\n    SQWORD sqDist) \n{\n    for (SQWORD sqRowIdx = 0; sqRowIdx < sqNrows; sqRowIdx++) {\n        for (SQWORD sqColIdx = 0; sqColIdx < sqNcols; sqColIdx++) {\n            SQWORD sqEqIdx = getEqCoeffIdx(sqRowIdx, sqColIdx, sqNrows, sqNcols);\n            for (SQWORD sqFlipRowIdx = sqRowIdx - sqDist; sqFlipRowIdx <= sqRowIdx + sqDist; sqFlipRowIdx++) {\n                SQWORD sqFlipCol1Idx = sqColIdx + (sqDist - abs(sqRowIdx - sqFlipRowIdx));\n                SQWORD sqFlipCol2Idx = sqColIdx - (sqDist - abs(sqRowIdx - sqFlipRowIdx));\n\n                if (isInrange(sqFlipRowIdx, sqFlipCol1Idx, sqNrows, sqNcols)) {\n                    SQWORD sqCoeffIdx = getEqCoeffIdx(sqFlipRowIdx, sqFlipCol1Idx, sqNrows, sqNcols);\n                    Ary.setValue(sqEqIdx, sqCoeffIdx, 1);\n                }\n                if (isInrange(sqFlipRowIdx, sqFlipCol2Idx, sqNrows, sqNcols)) {\n                    SQWORD sqCoeffIdx = getEqCoeffIdx(sqFlipRowIdx, sqFlipCol2Idx, sqNrows, sqNcols);\n                    Ary.setValue(sqEqIdx, sqCoeffIdx, 1);\n                }\n            }\n            /* 対角成分 */\n            Ary.setValue(sqEqIdx, sqEqIdx, 1);\n        }\n    }\n}\n\nbool solve(void)\n{\n    SQWORD sqInput_M = inputSQWORD();\n    SQWORD sqInput_N = inputSQWORD();\n\n    SQWORD sqDim = sqInput_M * sqInput_N;\n\n    SQWORD sqInput_D = inputSQWORD();\n\n    if ((0 == sqInput_M) && (0 == sqInput_M) && (0 == sqInput_D)) {\n        return false;\n    }\n\n    /* Coeff & ans */\n    Matrix matEq(sqDim, sqDim+1);\n\n    /* Configure A */\n    configureCoeffs(matEq, sqInput_N, sqInput_M, sqInput_D);\n\n    /* input b */\n    for (SQWORD sqRowIdx = 0; sqRowIdx < sqInput_N; sqRowIdx++) {\n        for (SQWORD sqColIdx = 0; sqColIdx < sqInput_M; sqColIdx++) {\n            SQWORD sqInput_S = inputSQWORD();\n            SQWORD sqEqIdx = getEqCoeffIdx(sqRowIdx, sqColIdx, sqInput_N, sqInput_M);\n            matEq.setValue(sqEqIdx, sqDim, sqInput_S);\n        }\n    }\n\n    /* solve */\n    SQWORD sqRank;\n    matEq.solve1DEquation(sqRank);\n\n    bool bAnsExist = true;\n    for (SQWORD sqIdx = sqRank; sqIdx < sqDim; sqIdx++) {\n        if (0 < matEq.getValue(sqIdx, sqDim)) {\n            bAnsExist = false;\n        }\n    }\n\n    if (bAnsExist) {\n        printf(\"1\\n\");\n    } else {\n        printf(\"0\\n\");\n    }\n    return true;\n}\n\nint main(void)\n{\n    while(1) {\n        if (!solve()) {\n            break;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1308 Awkward Lights\n// 2018.3.8 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define N 630\n\n// solve A X = C\n//char A[N][N], X[N], C[N];\nint B[N][N];\t\t\t\t// working\n\nint gauss_jordan(int n)\n{\n\tint i, j, k, t, pivot;\n\n//\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) B[i][j] = A[i][j];\n//\tfor (i = 0; i < n; i++) B[i][n] = C[i];\n\n\tfor (i = 0; i < n; i++) {\n\t\tpivot = -1, t = -1;\n\t\tfor (j = i; j < n; j++) if (B[j][i] > t) pivot = j, t = B[j][i];\n\t\tif (pivot < 0 || !t) continue;\n\n\t\tfor (j = 0; j <= n; j++) {\t\t\t\t\t// swap(B[i],B[pivot]);\n\t\t\tt = B[i][j], B[i][j] = B[pivot][j], B[pivot][j] = t;\n\t\t}\n\n\t\tfor (j = 0; j < n; j++) if (i != j && B[j][i]) {\n\t        for (k = i; k <= n; k++) B[j][k] = (B[j][k]+B[i][k]) & 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n//\t\tX[i] = B[i][n];\n\t\tif (!B[i][i] && B[i][n]) return 0;\n\t}\n\treturn 1;\n}\n\n#define ABS(a)\t((a)>=0?(a):-(a))\n#define ID(r,c)\t((r)*m+(c))\n\nint main()\n{\n\tint m, n, mn, d, i, j, r, c, t;\n\n\twhile (m = in()) {\n\t\tn = in(), d = in(), mn = m*n;\n\t\tmemset(B, 0, sizeof(B));\n\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < m; j++) {\n\t\t\tif (in()) B[ID(i,j)][mn] = 1;\n\t\t\tfor (r = 0; r < n; r++) for (c = 0; c < m; c++) {\n\t\t\t\tt = ABS(r-i)+ABS(c-j);\n\t\t\t\tif (t == d || t == 0) B[ID(i,j)][ID(r,c)] = 1;\n\t\t\t}\n\t\t}\n\t\tputchar('0' + gauss_jordan(m*n));\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1308 Awkward Lights\n// 2018.3.8 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint inbit()\n{\n\tint c = getchar_unlocked();\n\tgetchar_unlocked();\n\treturn c & 1;\n}\n\n#define N 630\n\n// solve A X = C\n//char A[N][N], X[N], C[N];\nchar B[N][N];\t\t\t\t// working\n\nint gauss_jordan(int n)\n{\n\tint i, j, k, t, pivot;\n\n//\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) B[i][j] = A[i][j];\n//\tfor (i = 0; i < n; i++) B[i][n] = C[i];\n\n\tfor (i = 0; i < n; i++) {\n\t\tpivot = -1;\n\t\tfor (j = i; j < n; j++) if (B[j][i]) { pivot = j; break; }\n\t\tif (pivot < 0) continue;\n\n\t\tfor (j = 0; j <= n; j++) {\t\t\t\t\t// swap(B[i],B[pivot]);\n\t\t\tt = B[i][j], B[i][j] = B[pivot][j], B[pivot][j] = t;\n\t\t}\n\n\t\tfor (j = 0; j < n; j++) if (i != j && B[j][i]) {\n\t        for (k = i; k <= n; k++) B[j][k] = (B[i][k] + B[j][k]) & 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n//\t\tX[i] = B[i][n];\n\t\tif (!B[i][i] && B[i][n]) return 0;\n\t}\n\treturn 1;\n}\n\n#define ABS(a)\t((a)>=0?(a):-(a))\n#define ID(r,c)\t((r)*m+(c))\n\nint main()\n{\n\tint m, n, mn, d, i, j, r, c;\n\n\twhile (m = in()) {\n\t\tn = in(), d = in(), mn = m*n;\n\t\tmemset(B, 0, sizeof(B));\n\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < m; j++) {\n\t\t\tif (inbit()) B[ID(i,j)][mn] = 1;\n\t\t\tfor (r = 0; r < n; r++) for (c = 0; c < m; c++) {\n\t\t\t\tif (r == i && c == j || ABS(r-i)+ABS(c-j) == d)\n\t\t\t\t\tB[ID(i,j)][ID(r,c)] = 1;\n\t\t\t}\n\t\t}\n\t\tputchar('0' + gauss_jordan(mn)), putchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1308 Awkward Lights\n// 2018.3.8 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\n#define N 630\n\n// solve A X = C\nint A[N][N], X[N], C[N];\nint B[N][N];\t\t\t\t// working\n\nint gauss_jordan(int n)\n{\n\tint i, j, k, t, pivot;\n\n\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) B[i][j] = A[i][j];\n\tfor (i = 0; i < n; i++) B[i][n] = C[i];\n\n\tfor (i = 0; i < n; i++) {\n\t\tpivot = -1, t = -1;\n\t\tfor (j = i; j < n; j++) if (B[j][i] > t) pivot = j, t = B[j][i];\n\t\tif (pivot < 0 || !t) continue;\n\n\t\tfor (j = 0; j <= n; j++) {\t\t\t\t\t// swap(B[i],B[pivot]);\n\t\t\tt = B[i][j], B[i][j] = B[pivot][j], B[pivot][j] = t;\n\t\t}\n\n\t\tfor (j = 0; j < n; j++) if (i != j && B[j][i]) {\n\t        for (k = i; k <= n; k++) B[j][k] = (B[j][k]+B[i][k]) & 1;\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tX[i] = B[i][n];\n\t\tif (!B[i][i] && B[i][n]) return 0;\n\t}\n\treturn 1;\n}\n\n#define ABS(a)\t((a)>=0?(a):-(a))\n#define ID(r,c)\t((r)*m+(c))\nint  s[28][28];\n\nint main()\n{\n\tint m, n, d, i, j, r, c, t;\n\n\twhile (m = in()) {\n\t\tn = in(), d = in();\n\t\tmemset(A, 0, sizeof(A)), memset(C, 0, sizeof(C));\n\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < m; j++) s[i][j] = in();\n\t\n\t\tfor (i = 0; i < n; i++) for (j = 0; j < m; j++) {\n\t\t\tif (s[i][j]) C[ID(i,j)] = 1;\n\t\t\tfor (r = 0; r < n; r++) for (c = 0; c < m; c++) {\n\t\t\t\tt = ABS(r-i)+ABS(c-j);\n\t\t\t\tif (t == d || t == 0) A[ID(i,j)][ID(r,c)] = 1;\n\t\t\t}\n\t\t}\n\t\tputchar('0' + gauss_jordan(m*n));\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int S ;\n\tstatic double EPS=1e-9;\n\n\tstatic boolean gauss(int[][] A) {\n\t\tfor(int i=0; i<S; i++) {\n\t\t\tint pivot=i;\n\t\t\tfor(int j=i; j<S; j++) {\n\t\t\t\tif(Math.abs(A[j][i])>Math.abs(A[pivot][i])) {\n\t\t\t\t\tpivot=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0; j<S+1; j++) {\n\t\t\t\tint a=A[i][j];\n\t\t\t\tA[i][j]=A[pivot][j];\n\t\t\t\tA[pivot][j]=a;\n\t\t\t}\n\n\t\t\tif(Math.abs(A[i][i])<EPS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=i+1; j<S+1; j++) {\n\t\t\t\tA[i][j]/=A[i][i];\n\t\t\t}\n\t\t\tA[i][i]/=A[i][i];//基準値を1にする\n\t\t\t\n//\t\t\tfor(int x=0; x<S; x++) {\n//\t\t\t\tfor(int y=0; y<S+1; y++) {\n//\t\t\t\t\tSystem.out.print(A[x][y]+\" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\n\t\t\tfor(int j=0; j<S; j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tfor(int k=i+1; k<S+1; k++) {\n\t\t\t\t\t\tA[j][k]-=A[j][i]*A[i][k];\n\t\t\t\t\t}\n\t\t\t\t\tA[j][i]-=A[j][i]*A[i][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tif(m==0) break;\n\t\t\t\tint[][] s=new int[n][m];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\ts[i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tS=n*m;\n\t\t\t\tint[][] mt=new int[m*n][m*n+1];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\tif(s[i][j]==1) {\n\t\t\t\t\t\t\tmt[i*m+j][n*m]=1;\n\t\t\t\t\t\t\t//System.out.println(\"mt[\"+(i*m+j)+\"][\"+n*m+\"]=1\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\tmt[i*m+j][i*m+j]=1;\n\t\t\t\t\t\t//System.out.println(\"mt[\"+(i*m+j)+\"][\"+(i*m+j)+\"]=1\");\n\t\t\t\t\t\tfor(int k=0; k<=d; k++) {\n\t\t\t\t\t\t\tfor(int l=0; l<4; l++) {\n\t\t\t\t\t\t\t\tint ny=i+((l&1)==1? k:-k);\n\t\t\t\t\t\t\t\tint nx=j+(((l>>1)&1)==1 ? d-k:k-d);\n\t\t\t\t\t\t\t\tif(0<=ny && ny<n && 0<=nx && nx<m) {\n\t\t\t\t\t\t\t\t\tmt[ny*m+nx][i*m+j]=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tfor(int i=0; i<S; i++) {\n//\t\t\t\t\tfor(int j=0; j<S+1; j++) {\n//\t\t\t\t\t\tSystem.out.print(mt[i][j]+\" \");\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println(gauss(mt)? 1:0);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\n\npublic class Main{\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {-1,0,1,0};\n\t\n\tint [] diax = {1, -1, -1, 1};\n\tint [] diay = {1, 1, -1, -1};\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tif((w|h|d) == 0) break;\n\t\t\t\n\t\t\tint wh = w * h;\n\t\t\tint [][] a = new int[wh][wh + 1];\n\t\t\tfor(int i = 0; i < wh; i++){\n\t\t\t\ta[i][wh] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < wh; i++){\n\t\t\t\ta[i][i] = 1;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint x = (i % w) + vx[j] * d;\n\t\t\t\t\tint y = (i / w) + vy[j] * d;\n\t\t\t\t\tif(isOK(x, y, w, h)){\n\t\t\t\t\t\ta[i][y * w + x] = 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int  k = 0; k < d-1; k++){\n\t\t\t\t\t\tx = x + diax[j];\n\t\t\t\t\t\ty = y + diay[j];\n\t\t\t\t\t\tif(isOK(x, y, w, h)){\n\t\t\t\t\t\t\ta[i][y * w + x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(solve(a, wh) ? 1 : 0);\n\t\t}\n\t}\n\t\n\tprivate boolean solve(int[][] a, int elementSize) {\n\t\tint n = a.length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint pivot = i;\n\t\t\tfor(int j = i; j < n; j++){\n\t\t\t\tif(Math.abs(a[j][i]) > Math.abs(a[pivot][i])) pivot = j;\n\t\t\t}\n\t\t\t\n\t\t\tif(Math.abs(a[pivot][i]) == 0) continue;\n\t\t\t\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tint temp = a[i][j];\n\t\t\t\ta[i][j] = a[pivot][j];\n\t\t\t\ta[pivot][j] = temp;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i != j && a[j][i] != 0){\n\t\t\t\t\tfor(int k = i; k <= n; k++){\n\t\t\t\t\t\ta[j][k] ^= a[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(a[i][i] == 0 && a[i][n] != 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate boolean isOK(int x, int y, int w, int h) {\n\t\treturn (0 <= x && x < w && 0 <= y && y < h);\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int S ;\n\tstatic double EPS=1e-9;\n\tstatic int[] ans;\n\t\n\tstatic boolean gauss(int[][] A) {\n        \n//      for(int i=0; i<=d; i++) {\n//          for(int j=0; j<=d+1; j++) {\n//              System.out.print(A[i][j]);\n//              if(j!=d+1) System.out.print(\" \");\n//          }\n//          System.out.println();\n//      }\n         \n        for(int i=0; i<S; i++) {\n            int pivot=i;\n            for(int j=i; j<S; j++) {\n                if(Math.abs(A[j][i])>Math.abs(A[pivot][i])) {\n                    pivot=j;\n                }\n            }\n             \n            //System.out.println(\"pivot=\"+pivot);\n             \n            for(int j=0; j<S+1; j++) {\n                int a=A[i][j];\n                A[i][j]=A[pivot][j];\n                A[pivot][j]=a;\n            }\n             \n//          for(int x=0; x<=d; x++) {\n//              for(int j=0; j<=d+1; j++) {\n//                  System.out.print(A[x][j]);\n//                  if(j!=d+1) System.out.print(\" \");\n//              }\n//              System.out.println();\n//          }\n             \n            if(Math.abs(A[i][i])<EPS) {\n                return false;\n            }\n             \n            for(int j=i+1; j<S+1; j++) {\n                A[i][j]/=A[i][i];\n            }\n            A[i][i]/=A[i][i];//基準値を1にする\n             \n            for(int j=0; j<S; j++) {\n                if(i!=j) {\n                    for(int k=i+1; k<S+1; k++) {\n                        A[j][k]-=A[j][i]*A[i][k];\n                        //System.out.println(\"A[\"+j+\"][\"+i+\"]=\"+A[j][i]+\"*A[\"+i+\"][\"+k+\"]=\"+A[i][k]);\n                    }\n                    A[j][i]-=A[j][i]*A[i][i];\n                }\n            }\n             \n//          System.out.println();\n//          for(int x=0; x<=d; x++) {\n//              for(int j=0; j<=d+1; j++) {\n//                  System.out.print(A[x][j]);\n//                  if(j!=d+1) System.out.print(\" \");\n//              }\n//              System.out.println();\n//          }\n             \n        }\n         \n        for(int i=0; i<S; i++) {\n            ans[i]=A[i][S];\n            //System.out.println(\"ans[\"+i+\"]=\"+ans[i]);\n        }\n        return true;\n    }\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tif(m==0) break;\n\t\t\t\tint[][] s=new int[n][m];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\ts[i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tS=n*m;\n\t\t\t\tint[][] mt=new int[m*n][m*n+1];\n\t\t\t\tans=new int[m*n];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\tif(s[i][j]==1) {\n\t\t\t\t\t\t\tmt[i*m+j][n*m]=1;\n\t\t\t\t\t\t\t//System.out.println(\"mt[\"+(i*m+j)+\"][\"+n*m+\"]=1\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\tmt[i*m+j][i*m+j]=1;\n\t\t\t\t\t\t//System.out.println(\"mt[\"+(i*m+j)+\"][\"+(i*m+j)+\"]=1\");\n\t\t\t\t\t\tfor(int k=0; k<=d; k++) {\n\t\t\t\t\t\t\tfor(int l=0; l<4; l++) {\n\t\t\t\t\t\t\t\tint ny=i+((l&1)==1? k:-k);\n\t\t\t\t\t\t\t\tint nx=j+(((l>>1)&1)==1 ? d-k:k-d);\n\t\t\t\t\t\t\t\tif(0<=ny && ny<n && 0<=nx && nx<m) {\n\t\t\t\t\t\t\t\t\tmt[ny*m+nx][i*m+j]=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tfor(int i=0; i<S; i++) {\n//\t\t\t\t\tfor(int j=0; j<S+1; j++) {\n//\t\t\t\t\t\tSystem.out.print(mt[i][j]);\n//\t\t\t\t\t\tif(j!=S) System.out.print(\" \");\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t\t\n\t\t\t\tSystem.out.println(gauss(mt)? 1:0);\n\t\t\t\t\n//\t\t\t\tfor(int i=0; i<S; i++){\n//\t\t\t\t\tboolean found = false;\n//\t\t\t\t\tint key = -1;\n//\t\t\t\t\tfor(int k=i; k<S; k++){\n//\t\t\t\t\t\tif(mt[k][i] == 1){\n//\t\t\t\t\t\t\tfound = true;\n//\t\t\t\t\t\t\tkey = k;\n//\t\t\t\t\t\t\tbreak;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\tif(found){\n//\t\t\t\t\t\tint[] tmp = mt[i].clone();\n//\t\t\t\t\t\tmt[i] = mt[key].clone();\n//\t\t\t\t\t\tmt[key] = tmp;\n//\t\t\t\t\t\tfor(int k=i+1; k<S; k++)if(mt[k][i] == 1){\n//\t\t\t\t\t\t\tfor(int j=i; j<=S; j++){\n//\t\t\t\t\t\t\t\tmt[k][j] ^= mt[i][j];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\tfor(int i=S-1; i>=0; i--){\n//\t\t\t\t\tif(mt[i][i] == 1){\n//\t\t\t\t\t\tfor(int k=i-1; k>=0; k--)if(mt[k][i] == 1){\n//\t\t\t\t\t\t\tfor(int j=S; j>=i; j--){\n//\t\t\t\t\t\t\t\tmt[k][j] ^= mt[i][j];\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tboolean tf=true;\n//\t\t\t\tfor(int i=0; i<S; i++){\n//\t\t\t\t\tif(mt[i][i] == 0 && mt[i][S] == 1){\n//\t\t\t\t\t\ttf=false;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println(tf? 1:0);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int S ;\n\tstatic double EPS=1e-9;\n\n\tstatic boolean gauss(int[][] A) {\n\t\tfor(int i=0; i<S; i++) {\n\t\t\tint pivot=i;\n\t\t\tfor(int j=i; j<S; j++) {\n\t\t\t\tif(Math.abs(A[j][i])>Math.abs(A[pivot][i])) {\n\t\t\t\t\tpivot=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0; j<S+1; j++) {\n\t\t\t\tint a=A[i][j];\n\t\t\t\tA[i][j]=A[pivot][j];\n\t\t\t\tA[pivot][j]=a;\n\t\t\t}\n\n\t\t\tif(Math.abs(A[i][i])<EPS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int j=i+1; j<S+1; j++) {\n//\t\t\t\tA[i][j]/=A[i][i];\n//\t\t\t}\n//\t\t\tA[i][i]/=A[i][i];//基準値を1にする\n\t\t\t\n//\t\t\tfor(int x=0; x<S; x++) {\n//\t\t\t\tfor(int y=0; y<S+1; y++) {\n//\t\t\t\t\tSystem.out.print(A[x][y]+\" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\n\t\t\tfor(int j=0; j<S; j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tfor(int k=i; k<S+1; k++) {\n\t\t\t\t\t\tA[j][k]=(A[j][k]+A[i][k])%2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tif(m==0) break;\n\t\t\t\tint[][] s=new int[n][m];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\ts[i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tS=n*m;\n\t\t\t\tint[][] mt=new int[m*n][m*n+1];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\tif(s[i][j]==1) {\n\t\t\t\t\t\t\tmt[i*m+j][n*m]=1;\n\t\t\t\t\t\t\t//System.out.println(\"mt[\"+(i*m+j)+\"][\"+n*m+\"]=1\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tfor(int i=0; i<S; i++) {\n//\t\t\t\t\tfor(int j=0; j<S+1; j++) {\n//\t\t\t\t\t\tSystem.out.print(mt[i][j]+\" \");\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\tmt[i*m+j][i*m+j]=1;\n\t\t\t\t\t\t//System.out.println(\"mt[\"+(i*m+j)+\"][\"+(i*m+j)+\"]=1\");\n\t\t\t\t\t\tfor(int k=0; k<=d; k++) {\n\t\t\t\t\t\t\tfor(int l=0; l<4; l++) {\n\t\t\t\t\t\t\t\tint ny=i+((l&1)==1? k:-k);\n\t\t\t\t\t\t\t\tint nx=j+(((l>>1)&1)==1 ? d-k:k-d);\n\t\t\t\t\t\t\t\tif(0<=ny && ny<n && 0<=nx && nx<m) {\n\t\t\t\t\t\t\t\t\tmt[ny*m+nx][i*m+j]=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(gauss(mt)? 1:0);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint h, w, d;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt(); h = sc.nextInt(); d = sc.nextInt();\n\t\t\tif((h|w|d) == 0) break;\n\t\t\t\n\t\t\tboolean[][] v = new boolean[h][w];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) v[i][j] = sc.nextInt() == 1;\n\t\t\t\n\t\t\tboolean[][][] A = new boolean[h][w][h*w];\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) {\n\t\t\t\tA[i][j][i*w+j] = true;\n\t\t\t\tfor(int k=-d;k<=d;k++) {\n\t\t\t\t\tint x = j + k, y = i + d - abs(k);\n\t\t\t\t\tif(!out(x, y)) A[i][j][y*w+x] = true;\n\t\t\t\t\ty = i - d + abs(k);\n\t\t\t\t\tif(!out(x, y)) A[i][j][y*w+x] = true;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor(boolean[][] a:A) for(boolean[] b: a)debug(b);\n\t\t\tboolean ng = false;\n\t\t\tfor(int i=0;i<h && !ng;i++) for(int j=0;j<w && !ng;j++) {\n\t\t\t\tint px = -1, py = -1;\n\t\t\t\tfor(int k=i*w+j;k<h*w;k++){\n\t\t\t\t\tint y = k/w, x = k%w;\n\t\t\t\t\tif(A[y][x][i*w+j]) {\n\t\t\t\t\t\tpx = x; py = y; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(px>=0) swap(j, i, px, py, A, v);\n\t\t\t\telse continue;\n\t\t\t\t\n\t\t\t\tfor(int k=0;k<h*w;k++)if(k != i*w+j) {\n\t\t\t\t\tint y = k/w, x = k%w;\n\t\t\t\t\tif(!A[y][x][i*w+j]) continue;\n\t\t\t\t\tfor(int l=i*w+j;l<w*h;l++) A[y][x][l] = A[y][x][l]^A[i][j][l];\n\t\t\t\t\tv[y][x] = v[y][x]^v[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) ng |= !A[i][j][i*w+j] && v[i][j];\n//\t\t\tdebug(ng);\n\t\t\tSystem.out.println((!ng? 1: 0));\n\t\t}\n\t}\n\t\n\tvoid swap(int x1, int y1, int x2, int y2, boolean[][][] A, boolean[][] v) {\n\t\tboolean[] tmp = new boolean[w*h];\n\t\tSystem.arraycopy(A[y1][x1], 0, tmp, 0, w*h);\n\t\tSystem.arraycopy(A[y2][x2], 0, A[y1][x1], 0, w*h);\n\t\tSystem.arraycopy(tmp, 0, A[y2][x2], 0, w*h);\n\t\tboolean tmp2 = v[y1][x1]; v[y1][x1] = v[y2][x2]; v[y2][x2] = tmp2;\n\t}\n\t\n\tboolean out(int x, int y) {\n\t\treturn x < 0 || y < 0 || x >= w || y >= h;\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M, D;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tM = sc.nextInt();\n\t\t\tN = sc.nextInt();\n\t\t\tD = sc.nextInt();\n\t\t\tif (M == 0) break;\n\t\t\tSystem.out.println(solve() ? 1 : 0);\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tBitSet[] mat = new BitSet[M * N];\n\t\tfor (int i = 0; i < N * M; ++i) {\n\t\t\tmat[i] = new BitSet(N * M + 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tif (sc.nextInt() == 1) mat[i * M + j].set(M * N);\n\t\t\t\tmat[i * M + j].set(i * M + j);\n\t\t\t\tfor (int k = -D; k <= D; ++k) {\n\t\t\t\t\tif (j + k < 0 || M <= j + k) continue;\n\t\t\t\t\tint dy = D - Math.abs(k);\n\t\t\t\t\tif (i - dy >= 0) mat[i * M + j].set((i - dy) * M + j + k);\n\t\t\t\t\tif (i + dy < N) mat[i * M + j].set((i + dy) * M + j + k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] used = new boolean[N * M];\n\t\tfor (int i = 0; i < N * M; ++i) {\n\t\t\tint pivot = -1;\n\t\t\tfor (int j = 0; j < N * M; ++j) {\n\t\t\t\tif (used[j]) continue;\n\t\t\t\tif (mat[j].get(i)) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pivot == -1) continue;\n\t\t\tused[pivot] = true;\n\t\t\tfor (int j = 0; j < N * M; ++j) {\n\t\t\t\tif (j == pivot || !mat[j].get(i)) continue;\n\t\t\t\tmat[j].xor(mat[pivot]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N * M; ++i) {\n\t\t\tif (!mat[i].get(N * M)) continue;\n\t\t\tmat[i].clear(N * M);\n\t\t\tif (mat[i].isEmpty()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint n,m,d;\n\tpublic void run(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tm = cin.nextInt();\n\t\t\tn = cin.nextInt();\n\t\t\td = cin.nextInt();\n\t\t\tif(m==0) break;\n\t\t\tint i,j,k,l;\n\t\t\tint[] board = new int[n * m];\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<m;j++){\n\t\t\t\t\tboard[i * m + j] = cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] matrix = new int[n*m][n*m];\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<m;j++){\n\t\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\t\tfor(l=0;l<m;l++){\n\t\t\t\t\t\t\tif(Math.abs(i-k)+Math.abs(j-l) == d){\n\t\t\t\t\t\t\t\tmatrix[i*m+j][k*m+l] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmatrix[i*m+j][i*m+j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint len = n*m;\n\t\t\tfor(i=0;i<len;i++){\n\t\t\t\tfor(j=i;j<len;j++){\n\t\t\t\t\tif(matrix[j][i]==1) break;\n\t\t\t\t}\n\t\t\t\tif(j!=len){\n\t\t\t\t\tint[] tmp = matrix[j].clone();\n\t\t\t\t\tmatrix[j] = matrix[i].clone();\n\t\t\t\t\tmatrix[i] = tmp.clone();\n\t\t\t\t\tfor(l=i+1;l<len;l++){\n\t\t\t\t\t\tif(matrix[l][i]==0) continue;\n\t\t\t\t\t\tfor(k=i;k<len;k++){\n\t\t\t\t\t\t\tmatrix[l][k] ^= matrix[i][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<len;i++){\n\t\t\t\tfor(j=0;j<len;j++){\n\t\t\t\t\t//System.out.print(matrix[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tint[] ret = new int[len];\n\t\t\tfor(i=0;i<len;i++){\n\t\t\t\tif(ret[i] != board[i]){\n\t\t\t\t\tif(matrix[i][i]==0) break;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(j=i;j<len;j++){\n\t\t\t\t\t\t\tret[j] ^= matrix[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(i);\n\t\t\tif(i!=len) System.out.println(0);\n\t\t\telse System.out.println(1);\n\t\t}\n\t}\n\n\tboolean ok(int y, int x){\n\t\treturn y>=0 && x >=0 && y<n && x<m;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M, D;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tM = sc.nextInt();\n\t\t\tN = sc.nextInt();\n\t\t\tD = sc.nextInt();\n\t\t\tif (M == 0) break;\n\t\t\tSystem.out.println(solve() ? 1 : 0);\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tint[][] mat = new int[M * N][M * N + 1];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tmat[i * M + j][M * N] = sc.nextInt();\n\t\t\t\tmat[i * M + j][i * M + j] = 1;\n\t\t\t\tfor (int k = -D; k <= D; ++k) {\n\t\t\t\t\tif (j + k < 0 || M <= j + k) continue;\n\t\t\t\t\tint dy = D - Math.abs(k);\n\t\t\t\t\tif (i - dy >= 0) {\n\t\t\t\t\t\tmat[i * M + j][(i - dy) * M + j + k] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (i + dy < N) {\n\t\t\t\t\t\tmat[i * M + j][(i + dy) * M + j + k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[] used = new boolean[N * M];\n\t\tfor (int i = 0; i < N * M; ++i) {\n\t\t\tint pivot = -1;\n\t\t\tfor (int j = 0; j < N * M; ++j) {\n\t\t\t\tif (used[j]) continue;\n\t\t\t\tif (mat[j][i] == 1) {\n\t\t\t\t\tpivot = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pivot == -1) continue;\n\t\t\tused[pivot] = true;\n\t\t\tfor (int j = 0; j < N * M; ++j) {\n\t\t\t\tif (j == pivot || mat[j][i] == 0) continue;\n\t\t\t\tfor (int k = 0; k <= N * M; ++k) {\n\t\t\t\t\tmat[j][k] += mat[pivot][k];\n\t\t\t\t\tif (mat[j][k] == 2) mat[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N * M; ++i) {\n\t\t\tif (mat[i][N * M] == 0) continue;\n\t\t\tboolean ok = false;\n\t\t\tfor (int j = 0; j < N * M; ++j) {\n\t\t\t\tif (mat[i][j] != 0) ok = true;\n\t\t\t}\n\t\t\tif (!ok) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int S ;\n\tstatic double EPS=1e-9;\n\n\tstatic boolean gauss(double[][] A) {\n\t\tfor(int i=0; i<S; i++) {\n\t\t\tint pivot=i;\n\t\t\tfor(int j=i; j<S; j++) {\n\t\t\t\tif(Math.abs(A[j][i])>Math.abs(A[pivot][i])) {\n\t\t\t\t\tpivot=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0; j<S+1; j++) {\n\t\t\t\tdouble a=A[i][j];\n\t\t\t\tA[i][j]=A[pivot][j];\n\t\t\t\tA[pivot][j]=a;\n\t\t\t}\n\n\t\t\tif(Math.abs(A[i][i])<EPS) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=i+1; j<S+1; j++) {\n\t\t\t\tA[i][j]/=A[i][i];\n\t\t\t}\n\t\t\tA[i][i]/=A[i][i];//基準値を1にする\n\t\t\t\n//\t\t\tfor(int x=0; x<S; x++) {\n//\t\t\t\tfor(int y=0; y<S+1; y++) {\n//\t\t\t\t\tSystem.out.print(A[x][y]+\" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tSystem.out.println();\n\n\t\t\tfor(int j=0; j<S; j++) {\n\t\t\t\tif(i!=j) {\n\t\t\t\t\tfor(int k=i+1; k<S+1; k++) {\n\t\t\t\t\t\tA[j][k]-=A[j][i]*A[i][k];\n\t\t\t\t\t}\n\t\t\t\t\tA[j][i]-=A[j][i]*A[i][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tint d=sc.nextInt();\n\t\t\t\tif(m==0) break;\n\t\t\t\tint[][] s=new int[n][m];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\ts[i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tS=n*m;\n\t\t\t\tdouble[][] mt=new double[m*n][m*n+1];\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\tif(s[i][j]==1) {\n\t\t\t\t\t\t\tmt[i*m+j][n*m]=1;\n\t\t\t\t\t\t\t//System.out.println(\"mt[\"+(i*m+j)+\"][\"+n*m+\"]=1\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\tmt[i*m+j][i*m+j]=1;\n\t\t\t\t\t\t//System.out.println(\"mt[\"+(i*m+j)+\"][\"+(i*m+j)+\"]=1\");\n\t\t\t\t\t\tfor(int k=0; k<=d; k++) {\n\t\t\t\t\t\t\tfor(int l=0; l<4; l++) {\n\t\t\t\t\t\t\t\tint ny=i+((l&1)==1? k:-k);\n\t\t\t\t\t\t\t\tint nx=j+(((l>>1)&1)==1 ? d-k:k-d);\n\t\t\t\t\t\t\t\tif(0<=ny && ny<n && 0<=nx && nx<m) {\n\t\t\t\t\t\t\t\t\tmt[ny*m+nx][i*m+j]=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tfor(int i=0; i<S; i++) {\n//\t\t\t\t\tfor(int j=0; j<S+1; j++) {\n//\t\t\t\t\t\tSystem.out.print(mt[i][j]+\" \");\n//\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t\tSystem.out.println(gauss(mt)? 1:0);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\n\npublic class Main{\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {-1,0,1,0};\n\t\n\tint [] diax = {1, -1, -1, 1};\n\tint [] diay = {1, 1, -1, -1};\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tif((w|h|d) == 0) break;\n\t\t\t\n\t\t\tint wh = w * h;\n\t\t\tint [][] a = new int[wh][wh + 1];\n\t\t\tfor(int i = 0; i < wh; i++){\n\t\t\t\ta[i][wh] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < wh; i++){\n\t\t\t\ta[i][i] = 1;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint x = (i % w) + vx[j] * d;\n\t\t\t\t\tint y = (i / w) + vy[j] * d;\n\t\t\t\t\tif(isOK(x,y, w,h)){\n\t\t\t\t\t\ta[y * h + x][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int  k = 0; k < d-1; k++){\n\t\t\t\t\t\tx = x + diax[j];\n\t\t\t\t\t\ty = y + diay[j];\n\t\t\t\t\t\tif(isOK(x, y, w, h)){\n\t\t\t\t\t\t\ta[i][y * h + x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(solve(a, wh) ? 1 : 0);\n\t\t}\n\t}\n\t\n\tprivate boolean solve(int[][] a, int elementSize) {\n\t\tint n = a.length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint pivot = i;\n\t\t\tfor(int j = i; j < n; j++){\n\t\t\t\tif(Math.abs(a[j][i]) > Math.abs(a[pivot][i])) pivot = j;\n\t\t\t}\n\t\t\t\n\t\t\tif(Math.abs(a[pivot][i]) == 0) continue;\n\t\t\t\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tint temp = a[i][j];\n\t\t\t\ta[i][j] = a[pivot][j];\n\t\t\t\ta[pivot][j] = temp;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i != j && a[j][i] != 0){\n\t\t\t\t\tfor(int k = i; k <= n; k++){\n\t\t\t\t\t\ta[j][k] ^= a[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(a[i][i] == 0 && a[i][n] != 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate boolean isOK(int x, int y, int w, int h) {\n\t\treturn (0 <= x && x < w && 0 <= y && y < h);\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\n\t\t\tif ((m | n | d) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint init[][] = new int[n][m];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tinit[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint push[][][][] = new int[n][m][n][m];\n\n\t\t\tint dx[] = { 1, 1, -1, -1 };\n\t\t\tint dy[] = { -1, 1, 1, -1 };\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\n\t\t\t\t\tpush[i][j][i][j] = 1;\n\n\t\t\t\t\tfor (int z = 0; z < 4; z++) {\n\t\t\t\t\t\tfor (int k = 0; k <= d; k++) {\n\t\t\t\t\t\t\tint ni = dx[z] * k + i;\n\t\t\t\t\t\t\tint nj = dy[z] * (d - k) + j;\n\n\t\t\t\t\t\t\tif (ni < n && ni >= 0) {\n\t\t\t\t\t\t\t\tif (nj < m && nj >= 0) {\n\t\t\t\t\t\t\t\t\tpush[i][j][ni][nj] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\n\t\t\tboolean ng = false;\n\n\t\t\tboolean used[][] = new boolean[n][m];\n\n\t\t\tfor (int i = 0; i < n && !ng; i++) {\n\t\t\t\tfor (int j = 0; j < m && !ng; j++) {\n\t\t\t\t\tint y = 0;\n\t\t\t\t\tint x = 0;\n\t\t\t\t\tboolean kkks = false;\n\t\t\t\t\tfor (y=0; y < n; y++) {\n\t\t\t\t\t\tfor (x=0; x < m; x++) {\n\t\t\t\t\t\t\tif (used[y][x]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (push[y][x][i][j] == 1) {\n\t\t\t\t\t\t\t\tkkks = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (kkks) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t\tif (y == n) {\n\t\t\t\t\t\tif (init[i][j] == 1) {\n\t\t\t\t\t//\t\tSystem.out.println(i +\" \" + j + \" fjsaoi\");\n\t\t\t\t\t\t\tng = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\n\t\t\t\t\tused[y][x] = true;\n\n\t\t\t\t\tfor (int zi = 0; zi < n; zi++) {\n\t\t\t\t\t\tfor (int zj = 0; zj < m; zj++) {\n\t\t\t\t\t\t\tif (zi == y && zj == x) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (push[zi][zj][i][j] == 1) {\n\t\t\t\t\t\t\t\tfor (int z1 = 0; z1 < n; z1++) {\n\t\t\t\t\t\t\t\t\tfor (int z2 = 0; z2 < m; z2++) {\n\t\t\t\t\t\t\t\t\t\tpush[zi][zj][z1][z2] = push[y][x][z1][z2]\n\t\t\t\t\t\t\t\t\t\t\t\t^ push[zi][zj][z1][z2];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (init[i][j] == 1) {\n\t\t\t\t\t\tfor (int z1 = 0; z1 < n; z1++) {\n\t\t\t\t\t\t\tfor (int z2 = 0; z2 < m; z2++) {\n\t\t\t\t\t\t\t\tinit[z1][z2] = init[z1][z2]\n\t\t\t\t\t\t\t\t\t\t^ push[y][x][z1][z2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n/*\t\t\t\n\t\t\tfor(int i =0; i < n ; i++){\n\t\t\t\tfor(int j = 0; j < m ; j++){\n\t\t\t\t\tSystem.out.println(\"-----------\\n\"+i+\" \"+j);\n\t\t\t\t\tfor(int k = 0; k < n ; k++){\n\t\t\t\t\t\tfor(int l = 0 ; l < m ; l++){\n\t\t\t\t\t\t\tSystem.out.print(push[i][j][k][l]+\" \");\n\t\t\t\t\t\t}\t\n\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t}\n\t\t*/\t\n\t\t\t\n\t\t\tif (ng) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int[][] s;\n\tstatic int m, n, d, S;\n\t\n\tstatic boolean gauss(int[][] A) {\n\t\tfor(int i=0; i<S; i++) {\n\t\t\tint pivot=i;\n\t\t\tfor(int j=i; j<S; j++) {\n\t\t\t\tif(A[j][i]!=0) {\n\t\t\t\t\tpivot=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=0; j<S+1; j++) {\n\t\t\t\tint a=A[i][j];\n\t\t\t\tA[i][j]=A[pivot][j];\n\t\t\t\tA[pivot][j]=a;\n\t\t\t}\n\t\t\t\n\t\t\tif(Math.abs(A[i][i])<0.000000001) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=0; j<S; j++) {\n\t\t\t\tif(i!=j && A[j][i]==1) {\n\t\t\t\t\tfor(int k=0; k<S+1; k++) {\n\t\t\t\t\t\tA[j][k]+=A[i][k];\n\t\t\t\t\t\tA[j][k]%=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<S; i++) {\n\t\t\tif(A[i][i]==0 && A[i][S]>0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tm=sc.nextInt();//width\n\t\t\t\tn=sc.nextInt();//hight\n\t\t\t\td=sc.nextInt();\n\t\t\t\tif(m==0) break;\n\t\t\t\ts=new int[n][m];\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\ts[i][j]=sc.nextInt();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tS=n*m;\n\t\t\t\tint[][] field=new int[S][S+1];\n\t\t\t\t//行列式を作る\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tfor(int j=0; j<m; j++) {\n\t\t\t\t\t\tfield[i*m+j][i*m+j]=1;\n\t\t\t\t\t\tif(s[i][j]==1) {\n\t\t\t\t\t\t\tfield[i*m+j][S]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int y=0; y<n; y++) {\n\t\t\t\t\t\t\tfor(int x=0; x<m; x++) {\n\t\t\t\t\t\t\t\tif(Math.abs(j-x)+Math.abs(i-y)==d ) {\n\t\t\t\t\t\t\t\t\tfield[y*m+x][i*m+j]=1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(gauss(field)? 1:0);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class D{\n\tint n,m,d;\n\tpublic void run(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tm = cin.nextInt();\n\t\t\tn = cin.nextInt();\n\t\t\td = cin.nextInt();\n\t\t\tif(m==0) break;\n\t\t\tint i,j,k,l;\n\t\t\tint[] board = new int[n * m];\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<m;j++){\n\t\t\t\t\tboard[i * m + j] = cin.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] matrix = new int[n*m][n*m];\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=0;j<m;j++){\n\t\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\t\tfor(l=0;l<m;l++){\n\t\t\t\t\t\t\tif(Math.abs(i-k)+Math.abs(j-l) == d){\n\t\t\t\t\t\t\t\tmatrix[i*m+j][k*m+l] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmatrix[i*m+j][i*m+j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint len = n*m;\n\t\t\tfor(i=0;i<len;i++){\n\t\t\t\tfor(j=i;j<len;j++){\n\t\t\t\t\tif(matrix[j][i]==1) break;\n\t\t\t\t}\n\t\t\t\tif(j!=len){\n\t\t\t\t\tint[] tmp = matrix[j].clone();\n\t\t\t\t\tmatrix[j] = matrix[i].clone();\n\t\t\t\t\tmatrix[i] = tmp.clone();\n\t\t\t\t\tfor(l=i+1;l<len;l++){\n\t\t\t\t\t\tif(matrix[l][i]==0) continue;\n\t\t\t\t\t\tfor(k=i;k<len;k++){\n\t\t\t\t\t\t\tmatrix[l][k] ^= matrix[i][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<len;i++){\n\t\t\t\tfor(j=0;j<len;j++){\n\t\t\t\t\t//System.out.print(matrix[i][j] + \" \");\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\t\n\t\t\tint[] ret = new int[len];\n\t\t\tfor(i=0;i<len;i++){\n\t\t\t\tif(ret[i] != board[i]){\n\t\t\t\t\tif(matrix[i][i]==0) break;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(j=i;j<len;j++){\n\t\t\t\t\t\t\tret[j] ^= matrix[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(i);\n\t\t\tif(i!=len) System.out.println(0);\n\t\t\telse System.out.println(1);\n\t\t}\n\t}\n\n\tboolean ok(int y, int x){\n\t\treturn y>=0 && x >=0 && y<n && x<m;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tnew D().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\n\npublic class Main{\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {-1,0,1,0};\n\t\n\tint [] diax = {1, -1, -1, 1};\n\tint [] diay = {1, 1, -1, -1};\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\t\t\tif((w|h|d) == 0) break;\n\t\t\t\n\t\t\tint wh = w * h;\n\t\t\tint [][] a = new int[wh][wh + 1];\n\t\t\tfor(int i = 0; i < wh; i++){\n\t\t\t\ta[i][wh] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < wh; i++){\n\t\t\t\ta[i][i] = 1;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint x = (i % w) + vx[j] * d;\n\t\t\t\t\tint y = (i / w) + vy[j] * d;\n\t\t\t\t\tif(isOK(x, y, w, h)){\n\t\t\t\t\t\ta[y * h + x][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int  k = 0; k < d-1; k++){\n\t\t\t\t\t\tx = x + diax[j];\n\t\t\t\t\t\ty = y + diay[j];\n\t\t\t\t\t\tif(isOK(x, y, w, h)){\n\t\t\t\t\t\t\ta[i][y * h + x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(solve(a, wh) ? 1 : 0);\n\t\t}\n\t}\n\t\n\tprivate boolean solve(int[][] a, int elementSize) {\n\t\tint n = a.length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint pivot = i;\n\t\t\tfor(int j = i; j < n; j++){\n\t\t\t\tif(Math.abs(a[j][i]) > Math.abs(a[pivot][i])) pivot = j;\n\t\t\t}\n\t\t\t\n\t\t\tif(Math.abs(a[pivot][i]) == 0) continue;\n\t\t\t\n\t\t\tfor(int j = 0; j <= n; j++){\n\t\t\t\tint temp = a[i][j];\n\t\t\t\ta[i][j] = a[pivot][j];\n\t\t\t\ta[pivot][j] = temp;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i != j && a[j][i] != 0){\n\t\t\t\t\tfor(int k = i; k <= n; k++){\n\t\t\t\t\t\ta[j][k] ^= a[i][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(a[i][i] == 0 && a[i][n] != 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate boolean isOK(int x, int y, int w, int h) {\n\t\treturn (0 <= x && x < w && 0 <= y && y < h);\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint[][] board;\n\tint d, M, N, S;\n\tint[][] matrix;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tM = in.nextInt();\n\t\t\tN = in.nextInt();\n\t\t\td = in.nextInt();\n\t\t\tif(M==0 && N==0 && d==0) return ;\n\t\t\tboard = new int[N][M];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\t\tboard[i][j] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(solve()?1:0);\n\t\t}\n\t}\n\n\tvoid setMatrix(){\n\t\tS = M*N;\n\t\tmatrix = new int[S][S+1];\n\t\tfor(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\tif(board[i][j] == 1){\n\t\t\t\t\tmatrix[i*M+j][S] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<N; i++){\n\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\tmatrix[i*M+j][i*M+j] = 1;\n\t\t\t\tfor(int k=0; k<=d; k++){\n\t\t\t\t\tfor(int l=0; l<4; l++){\n\t\t\t\t\t\tint ny = i + ((l&1)==1?k:-k),\n\t\t\t\t\t\t\tnx = j + (((l>>1)&1)==1?d-k:k-d);\n\t\t\t\t\t\tif(0<=ny && ny<N && 0<=nx && nx<M){\n\t\t\t\t\t\t\tmatrix[ny*M+nx][i*M+j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tboolean solve(){\n\t\tsetMatrix();\n\t\tfor(int i=0; i<S; i++){\n\t\t\tboolean found = false;\n\t\t\tint key = -1;\n\t\t\tfor(int k=i; k<S; k++){\n\t\t\t\tif(matrix[k][i] == 1){\n\t\t\t\t\tfound = true;\n\t\t\t\t\tkey = k;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found){\n\t\t\t\tint[] tmp = matrix[i].clone();\n\t\t\t\tmatrix[i] = matrix[key].clone();\n\t\t\t\tmatrix[key] = tmp;\n\t\t\t\tfor(int k=i+1; k<S; k++)if(matrix[k][i] == 1){\n\t\t\t\t\tfor(int j=i; j<=S; j++){\n\t\t\t\t\t\tmatrix[k][j] ^= matrix[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=S-1; i>=0; i--){\n\t\t\tif(matrix[i][i] == 1){\n\t\t\t\tfor(int k=i-1; k>=0; k--)if(matrix[k][i] == 1){\n\t\t\t\t\tfor(int j=S; j>=i; j--){\n\t\t\t\t\t\tmatrix[k][j] ^= matrix[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<S; i++){\n\t\t\tif(matrix[i][i] == 0 && matrix[i][S] == 1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tint d = sc.nextInt();\n\n\t\t\tif ((m | n | d) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint init[][] = new int[n][m];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tinit[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint push[][][][] = new int[n][m][n][m];\n\n\t\t\tint dx[] = { 1, 1, -1, -1 };\n\t\t\tint dy[] = { -1, 1, 1, -1 };\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\n\t\t\t\t\tpush[i][j][i][j] = 1;\n\n\t\t\t\t\tfor (int z = 0; z < 4; z++) {\n\t\t\t\t\t\tfor (int k = 0; k <= d; k++) {\n\t\t\t\t\t\t\tint ni = dx[z] * k + i;\n\t\t\t\t\t\t\tint nj = dy[z] * (d - k) + j;\n\n\t\t\t\t\t\t\tif (ni < n && ni >= 0) {\n\t\t\t\t\t\t\t\tif (nj < m && nj >= 0) {\n\t\t\t\t\t\t\t\t\tpush[i][j][ni][nj] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\n\t\t\tboolean ng = false;\n\n\t\t\tboolean used[][] = new boolean[n][m];\n\n\t\t\tfor (int i = 0; i < n && !ng; i++) {\n\t\t\t\tfor (int j = 0; j < m && !ng; j++) {\n\t\t\t\t\tint y = 0;\n\t\t\t\t\tint x = 0;\n\t\t\t\t\tboolean kkks = false;\n\t\t\t\t\tfor (y=0; y < n; y++) {\n\t\t\t\t\t\tfor (x=0; x < m; x++) {\n\t\t\t\t\t\t\tif (used[y][x]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (push[y][x][i][j] == 1) {\n\t\t\t\t\t\t\t\tkkks = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (kkks) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t\tif (y == n) {\n\t\t\t\t\t\tif (init[i][j] == 1) {\n\t\t\t\t\t//\t\tSystem.out.println(i +\" \" + j + \" fjsaoi\");\n\t\t\t\t\t\t\tng = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\n\t\t\t\t\tused[y][x] = true;\n\n\t\t\t\t\tfor (int zi = 0; zi < n; zi++) {\n\t\t\t\t\t\tfor (int zj = 0; zj < m; zj++) {\n\t\t\t\t\t\t\tif(used[zi][zj]){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (push[zi][zj][i][j] == 1) {\n\t\t\t\t\t\t\t\tfor (int z1 = 0; z1 < n; z1++) {\n\t\t\t\t\t\t\t\t\tfor (int z2 = 0; z2 < m; z2++) {\n\t\t\t\t\t\t\t\t\t\tpush[zi][zj][z1][z2] = push[y][x][z1][z2]\n\t\t\t\t\t\t\t\t\t\t\t\t^ push[zi][zj][z1][z2];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (init[i][j] == 1) {\n\t\t\t\t\t\tfor (int z1 = 0; z1 < n; z1++) {\n\t\t\t\t\t\t\tfor (int z2 = 0; z2 < m; z2++) {\n\t\t\t\t\t\t\t\tinit[z1][z2] = init[z1][z2]\n\t\t\t\t\t\t\t\t\t\t^ push[y][x][z1][z2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n/*\t\t\t\n\t\t\tfor(int i =0; i < n ; i++){\n\t\t\t\tfor(int j = 0; j < m ; j++){\n\t\t\t\t\tSystem.out.println(\"-----------\\n\"+i+\" \"+j);\n\t\t\t\t\tfor(int k = 0; k < n ; k++){\n\t\t\t\t\t\tfor(int l = 0 ; l < m ; l++){\n\t\t\t\t\t\t\tSystem.out.print(push[i][j][k][l]+\" \");\n\t\t\t\t\t\t}\t\n\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t}\n\t\t*/\t\n\t\t\t\n\t\t\tif (ng) {\n\t\t\t\tSystem.out.println(0);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "# -*- coding: utf-8 -*-\ndef solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    p(check_matrix(b))\n    end\nend\n\ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k)\n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) デバッグ用\n    # 行列が解を持つかの判定。持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend\n\nsolve"
  },
  {
    "language": "Ruby",
    "code": "solve\n\ndef solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    p(check_matrix(b))\n    end\nend\n\ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k)\n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) デバッグ用\n    # 行列が解を持つかの判定。持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend"
  },
  {
    "language": "Ruby",
    "code": "# -*- coding: utf-8 -*-\nclass Q1308\n\ndef solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    p(check_matrix(b))\n    end\nend\n\ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k)\n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) デバッグ用\n    # 行列が解を持つかの判定。持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend\n\nQ1308.new.solve"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef solve(n, mat, v)\n  for i in (0...n)\n    if mat[i][i] == 0\n      for i0 in ((i + 1)...n)\n        if mat[i0][i] != 0\n          tmp = mat[i0]; mat[i0] = mat[i]; mat[i] = tmp\n          tmp = v[i0]; v[i0] = v[i]; v[i] = tmp\n          break\n        end\n      end\n    end\n\n    if mat[i][i] != 0\n      for i0 in ((i + 1)...n)\n        if mat[i0][i] != 0\n          mat[i0][i] = 0\n          for j in ((i + 1)...n)\n            mat[i0][j] = (mat[i0][j] + mat[i][j]) % 2\n          end\n          v[i0] = (v[i0] + v[i]) % 2\n        end\n      end\n    end\n  end\n  #p mat; p v\n  \n  (n - 1).downto(0) do |i|\n    ((i + 1)...n).each{|j| v[i] = (v[i] + mat[i][j] * v[j]) % 2}\n    return false if mat[i][i] == 0 && v[i] != 0\n  end\n  #p mat; p v\n  \n  true\nend\n\n### main\n\nloop do\n  w, h, d = gets.split.map(&:to_i)\n  break if (w | h | d) == 0\n\n  hw = h * w\n  v = []\n  mat = []\n\n  for y in (0...h)\n    line = gets.split.map(&:to_i)\n    for x in (0...w)\n      pos = y * w + x\n      v[pos] = line[x]\n\n      mat[pos] = hw.times.map{0}\n      mat[pos][pos] = 1\n      \n      for dy in (-d..d)\n        ddx = d - dy.abs\n        for dx in [-ddx, ddx]\n          x0 = x + dx\n          y0 = y + dy\n          if x0 >= 0 && x0 < w && y0 >= 0 && y0 < h\n            pos0 = y0 * w + x0\n            mat[pos][pos0] = 1\n          end\n        end\n      end\n    end\n  end\n  #p v\n  #p mat\n\n  puts (solve(hw, mat, v) ? 1 : 0)\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve\n    while(1)\n    _input = STDIN.gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    printf(\"%d\\n\", check_matrix(b))\n    end\nend\n\ndef check_matrix(a) \n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        \n        max = maxrow(a,k)\n        swap(a,k,max)\n        \n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    \n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) \n    b = make2d(m * n,(m * n + 1)) \n    for i in 0..(n - 1) \n        for j in 0..(m - 1) \n            \n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            \n            b[i * m + j][i * m + j] = 1\n            \n            for k in 0..d\n                if (i + k > n - 1) then break \n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break \n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend\n\nsolve"
  },
  {
    "language": "Ruby",
    "code": "def solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = STDIN.gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    printf(\"%d\\n\", check_matrix(b))\n    end\nend\n\ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k)\n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) デバッグ用\n    # 行列が解を持つかの判定。持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend\n\nsolve"
  },
  {
    "language": "Ruby",
    "code": "def solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    p(check_matrix(b))\n    end\nend\n        \ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k) \n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) デバッグ用\n    # 行列が解を持つかの判定　持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else \n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else \n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else \n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend"
  },
  {
    "language": "Ruby",
    "code": "def solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = STDIN.gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    printf(\"%d\\n\", check_matrix(b))\n    end\nend\n\ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k)\n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) #デバッグ用\n    # 行列が解を持つかの判定。持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend\n\nsolve"
  },
  {
    "language": "Ruby",
    "code": "def solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = STDIN.gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    p(check_matrix(b))\n    end\nend\n\ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k)\n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) デバッグ用\n    # 行列が解を持つかの判定。持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend\n\nsolve"
  },
  {
    "language": "Ruby",
    "code": "def solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    p(check_matrix(b))\n    end\nend\n\ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k)\n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) デバッグ用\n    # 行列が解を持つかの判定。持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend\n\nsolve"
  },
  {
    "language": "Ruby",
    "code": "# -*- coding: utf-8 -*-\ndef solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    p(check_matrix(b))\n    end\nend\n\ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k)\n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) デバッグ用\n    # 行列が解を持つかの判定。持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend\n\nif __FILE__ == $0\n  solve\nend"
  },
  {
    "language": "Ruby",
    "code": "# -*- coding: utf-8 -*-\nclass Q1308\n\ndef solve # 答えの判定  a行列を作ってmake_matrixに代入し、生成された行列をcheck_matrixで判定する\n    while(1)\n    _input = gets\n    input = _input.split()\n    for i in 1..3\n        m = input[0].to_i\n        n = input[1].to_i\n        d = input[2].to_i\n    end\n    if(m == 0 && n == 0 && d == 0) then break end\n    a = make2d(n,m)\n    for i in 0..(n - 1)\n        _input = gets\n        input = _input.split()\n        for j in 0..(m - 1)\n            a[i][j] = input[j].to_i\n        end\n    end\n    b = make_matrix(m,n,d,a)\n    p(check_matrix(b))\n    end\nend\n\ndef check_matrix(a) # 行列が解を持つかを判定する（最初の方は連立方程式を解くのと同じ）\n    height = a.length()\n    width = a[0].length\n    for k in 0..(width - 2)\n        # 行の入れ替え\n        max = maxrow(a,k)\n        swap(a,k,max)\n        # それぞれの成分は常に絶対値が1以下であることが保証されているので整数のまま足し算引き算しても問題ない\n        for i in 0..(height - 1)\n            if i != k\n                aik = a[i][k]\n                for j in k..(width - 1)\n                    a[i][j] = (a[i][j] - aik * a[k][j])\n                    if ABS(a[i][j]) > 1 then a[i][j] = a[i][j] % 2\n                    end\n                end\n            end\n        end\n    end\n    # p(a) デバッグ用\n    # 行列が解を持つかの判定。持ってなかったら0、持ってたら1を返す\n    flag = 1\n    for i in 0..(height - 1)\n        if (a[i][width - 1] != 0 && a[i][i] == 0) then flag = 0\n        end\n    end\n    if flag == 1 then 1\n    else 0\n    end\nend\n\ndef make_matrix(m,n,d,a) #解に至るための行列を作る\n    b = make2d(m * n,(m * n + 1)) # 基本的にbの成分は0\n    for i in 0..(n - 1) #たて\n        for j in 0..(m - 1) #横\n            #まずa[i][j]のライトがついてるかどうかで成分を決定\n            if a[i][j] == 1\n                b[i * m + j][m * n] = 1\n            else\n                b[i * m + j][m * n] = 0\n            end\n            #次にdだけ離れているところおよび自分ががON/OFF切り替えることでa[i][j]に影響するところをチェックする\n            b[i * m + j][i * m + j] = 1\n            #たて方向に0からdまで動かすときに縦方向にどれだけ距離をおくかを考える。その縦方向が存在すればOK\n            for k in 0..d\n                if (i + k > n - 1) then break #まずプラス方向を考える\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i + k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0) then  b[i * m + j][(i + k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n            for k in 0..d\n                if (i - k < 0) then break #マイナス方向\n                else\n                    if (j + (d - k) <= m - 1) then b[i * m + j][(i - k) * m + (j + d - k)] = 1\n                    end\n                    if (j - (d - k) >= 0)  then b[i * m + j][(i - k) * m + (j - d + k)] = 1\n                    end\n                end\n            end\n        end\n    end\n    b\nend\n\ndef maxrow(a,k)\n    row = a.length()\n    max = ABS(a[k][k])\n    max_index = k\n    for i in k..(row - 1)\n        if max < ABS(a[i][k])\n            max = ABS(a[i][k])\n            max_index = i\n        end\n    end\n    max_index\nend\n\ndef swap(a,k,l)\n    temp = a[k]\n    a[k] = a[l]\n    a[l] = temp\n    a\nend\n\ndef ABS(n)\n    if n < 0\n        -n\n    else\n        n\n    end\nend\n\ndef make1d(n)\n    a = Array.new(n)\n    for i in 0..(n - 1)\n        a[i] = 0\n    end\n    a\nend\n\ndef make2d(height,width)\n    a = Array.new(height)\n    for i in 0..(height-1)\n        a[i] = make1d(width)\n    end\n    a\nend\nend\nQ1308.new.solve"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass Matrix {\n    int Y, X;\n    int[][] F;\n    this(int Y, int X) {\n        this.Y = Y;\n        this.X = X;\n        F = new int[][](Y, X);\n    }\n    void set(int y, int x, int v) { F[y][x] = v; }\n    int get(int y, int x) { return F[y][x]; }\n    int[] get(int y) { return F[y]; }\n    override string toString() const {\n        string[] Ret;\n        foreach (L; F) Ret ~= L.map!\"a ? 'o' : 'x'\".array;\n        return Ret.join(\"\\n\");\n    }\n    // 繧ャ繧ヲ繧ケ縺ョ豸亥悉豕? 遐エ螢顔噪. rank繧定ソ斐☆.\n    int GaussianElimination() {\n        int rank = 0;\n        int ny = 0;\n        int pivot(int x) {\n            foreach (y; ny .. Y) {\n                if (F[y][x] != 0) return y;\n            }\n            return -1;\n        }\n        foreach (int px; 0 .. X) {\n            int py = pivot(px);\n            if (py < 0) continue;\n            rank++;\n            swap(F[py], F[ny]);\n            py = ny;\n            ny++;\n            foreach (int y; 0 .. Y) {\n                if (y == py) continue;\n                int d = F[y][px];\n                if (d == 0) continue;\n                foreach (int x; 0 .. X) {\n                    F[y][x] = (F[py][x] + F[y][x]) % 2;\n                }\n            }\n        }\n        return rank;\n    }\n}\n\n\nconst dy = [-1, 0, 1, 0],\n      dx = [0, 1, 0, -1];\n\nvoid main() {\n    int X, Y, D;\n    int[][] F;\n    bool input() {\n        scanf(\"%d %d %d\\n\", &X, &Y, &D);\n        if (X == 0 && Y == 0 && D == 0) return false;\n        F = new int[][Y];\n        foreach (i; 0 .. Y) F[i] = readln.chomp.split(\" \").map!(to!int).array;\n        return true;\n    }\n    void solve() {\n        Matrix m = new Matrix(Y * X, Y * X + 1);\n        Matrix n = new Matrix(Y * X, Y * X);\n        foreach (y; 0 .. Y) {\n            foreach (x; 0 .. X) {\n                m.set(Y * y + x, Y * X, F[y][x]);\n            }\n        }\n        foreach (y1; 0 .. Y) {\n            foreach (x1; 0 .. X) {\n                m.set(X * y1 + x1, X * y1 + x1, 1);\n                n.set(X * y1 + x1, X * y1 + x1, 1);\n                foreach (y2; 0 .. Y) {\n                    foreach (x2; 0 .. X) {\n                        if (abs(y1 - y2) + abs(x1 - x2) == D) {\n                            m.set(X * y1 + x1, X * y2 + x2, 1);\n                            n.set(X * y1 + x1, X * y2 + x2, 1);\n                        }\n                    }\n                }\n            }\n        }\n        writeln( ( m.GaussianElimination == n.GaussianElimination ).to!int );\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass Matrix {\n    int Y, X;\n    int[][] F;\n    this(int Y, int X) {\n        this.Y = Y;\n        this.X = X;\n        F = new int[][](Y, X);\n    }\n    void set(int y, int x, int v) { \n        F[y][x] = v; \n    }\n    int get(int y, int x) { return F[y][x]; }\n    int[] get(int y) { return F[y]; }\n    // 繧ャ繧ヲ繧ケ縺ョ豸亥悉豕? 遐エ螢顔噪. 陦悟?縺ィ諡。蠑オ陦悟?縺ョrank縺御ク??縺吶ｋ縺九←縺?°繧定ソ斐☆\n    bool GaussianElimination() {\n        int rank0 = 0, rank1 = 0;\n        int ny = 0;\n        int pivot(int x) {\n            foreach (y; ny .. Y) {\n                if (F[y][x] != 0) return y;\n            }\n            return -1;\n        }\n        foreach (int px; 0 .. X) {\n            int py = pivot(px);\n            if (py < 0) continue;\n            if (px < X - 1) rank0++;\n            rank1++;\n            swap(F[py], F[ny]);\n            py = ny;\n            ny++;\n            foreach (int y; ny .. Y) {\n                if (y == py) continue;\n                int d = F[y][px];\n                if (d == 0) continue;\n                foreach (int x; 0 .. X) {\n                    F[y][x] = (F[py][x] + F[y][x]) % 2;\n                }\n            }\n        }\n        return rank0 == rank1;\n    }\n}\n\n\nconst dy = [-1, 0, 1, 0],\n      dx = [0, 1, 0, -1];\n\nvoid main() {\n    int X, Y, D;\n    int[][] F;\n    bool input() {\n        scanf(\"%d %d %d\\n\", &X, &Y, &D);\n        if (X == 0 && Y == 0 && D == 0) return false;\n        F = new int[][Y];\n        foreach (i; 0 .. Y) F[i] = readln.chomp.split(\" \").map!(to!int).array;\n        return true;\n    }\n    void solve() {\n        Matrix m = new Matrix(Y * X, Y * X + 1);\n        foreach (y; 0 .. Y) {\n            foreach (x; 0 .. X) {\n                m.set(X * y + x, Y * X, F[y][x]);\n            }\n        }\n        foreach (y1; 0 .. Y) {\n            foreach (x1; 0 .. X) {\n                m.set(X * y1 + x1, X * y1 + x1, 1);\n                foreach (y2; 0 .. Y) {\n                    foreach (x2; 0 .. X) {\n                        if (abs(y1 - y2) + abs(x1 - x2) == D) {\n                            m.set(X * y1 + x1, X * y2 + x2, 1);\n                        }\n                    }\n                }\n            }\n        }\n        writeln( m.GaussianElimination.to!int );\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass Matrix {\n    int Y, X;\n    int[][] F;\n    this(int Y, int X) {\n        this.Y = Y;\n        this.X = X;\n        F = new int[][](Y, X);\n    }\n    void set(int y, int x, int v) { F[y][x] = v; }\n    int get(int y, int x) { return F[y][x]; }\n    int[] get(int y) { return F[y]; }\n    // 繧ャ繧ヲ繧ケ縺ョ豸亥悉豕? 遐エ螢顔噪. rank繧定ソ斐☆.\n    int GaussianElimination() {\n        int rank = 0;\n        int ny = 0;\n        int pivot(int x) {\n            foreach (y; ny .. Y) {\n                if (F[y][x] != 0) return y;\n            }\n            return -1;\n        }\n        foreach (int px; 0 .. X) {\n            int py = pivot(px);\n            if (py < 0) continue;\n            rank++;\n            swap(F[py], F[ny]);\n            py = ny;\n            ny++;\n            foreach (int y; 0 .. Y) {\n                if (y == py) continue;\n                int d = F[y][px];\n                if (d == 0) continue;\n                foreach (int x; 0 .. X) {\n                    F[y][x] = (F[py][x] + F[y][x]) % 2;\n                }\n            }\n        }\n        return rank;\n    }\n}\n\n\nconst dy = [-1, 0, 1, 0],\n      dx = [0, 1, 0, -1];\n\nvoid main() {\n    int X, Y, D;\n    int[][] F;\n    bool input() {\n        scanf(\"%d %d %d\\n\", &X, &Y, &D);\n        if (X == 0 && Y == 0 && D == 0) return false;\n        F = new int[][Y];\n        foreach (i; 0 .. Y) F[i] = readln.chomp.split(\" \").map!(to!int).array;\n        return true;\n    }\n    void solve() {\n        Matrix m = new Matrix(Y * X, Y * X + 1);\n        Matrix n = new Matrix(Y * X, Y * X);\n        foreach (y; 0 .. Y) {\n            foreach (x; 0 .. X) {\n                m.set(Y * y + x, Y * X, F[y][x]);\n            }\n        }\n        foreach (y1; 0 .. Y) {\n            foreach (x1; 0 .. X) {\n                m.set(X * y1 + x1, X * y1 + x1, 1);\n                n.set(X * y1 + x1, X * y1 + x1, 1);\n                foreach (y2; 0 .. Y) {\n                    foreach (x2; 0 .. X) {\n                        if (abs(y1 - y2) + abs(x1 - x2) == D) {\n                            m.set(X * y1 + x1, X * y2 + x2, 1);\n                            n.set(X * y1 + x1, X * y2 + x2, 1);\n                        }\n                    }\n                }\n            }\n        }\n        writeln( ( m.GaussianElimination == n.GaussianElimination ).to!int );\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass Matrix {\n    int Y, X;\n    int[][] F;\n    this(int Y, int X) {\n        this.Y = Y;\n        this.X = X;\n        F = new int[][](Y, X);\n    }\n    void set(int y, int x, int v) { \n        F[y][x] = v; \n    }\n    int get(int y, int x) { return F[y][x]; }\n    int[] get(int y) { return F[y]; }\n    // 繧ャ繧ヲ繧ケ縺ョ豸亥悉豕? 遐エ螢顔噪. 陦悟?縺ィ諡。蠑オ陦悟?縺ョrank縺御ク??縺吶ｋ縺九←縺?°繧定ソ斐☆\n    bool GaussianElimination() {\n        int rank0 = 0, rank1 = 0;\n        int ny = 0;\n        int pivot(int x) {\n            foreach (y; ny .. Y) {\n                if (F[y][x] != 0) return y;\n            }\n            return -1;\n        }\n        foreach (int px; 0 .. X) {\n            int py = pivot(px);\n            if (py < 0) continue;\n            if (px < X - 1) rank0++;\n            rank1++;\n            swap(F[py], F[ny]);\n            py = ny;\n            ny++;\n            foreach (int y; 0 .. Y) {\n                if (y == py) continue;\n                int d = F[y][px];\n                if (d == 0) continue;\n                foreach (int x; 0 .. X) {\n                    F[y][x] = (F[py][x] + F[y][x]) & 1;\n                }\n            }\n        }\n        return rank0 == rank1;\n    }\n}\n\n\nconst dy = [-1, 0, 1, 0],\n      dx = [0, 1, 0, -1];\n\nvoid main() {\n    int X, Y, D;\n    int[][] F;\n    bool input() {\n        scanf(\"%d %d %d\\n\", &X, &Y, &D);\n        if (X == 0 && Y == 0 && D == 0) return false;\n        F = new int[][Y];\n        foreach (i; 0 .. Y) F[i] = readln.chomp.split(\" \").map!(to!int).array;\n        return true;\n    }\n    void solve() {\n        Matrix m = new Matrix(Y * X, Y * X + 1);\n        foreach (y; 0 .. Y) {\n            foreach (x; 0 .. X) {\n                m.set(X * y + x, Y * X, F[y][x]);\n            }\n        }\n        foreach (y1; 0 .. Y) {\n            foreach (x1; 0 .. X) {\n                m.set(X * y1 + x1, X * y1 + x1, 1);\n                foreach (y2; 0 .. Y) {\n                    foreach (x2; 0 .. X) {\n                        if (abs(y1 - y2) + abs(x1 - x2) == D) {\n                            m.set(X * y1 + x1, X * y2 + x2, 1);\n                        }\n                    }\n                }\n            }\n        }\n        writeln( m.GaussianElimination.to!int );\n    }\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "import sys,queue,math,copy,itertools\nLI = lambda : [int(x) for x in sys.stdin.readline().split()]\n\nwhile True:\n    M,N,D = LI()\n    if N == 0 : break\n\n    S = []\n    for _ in range(N):\n        S.extend(LI())\n\n    x = []\n    for i in range(N):\n        for j in range(M):\n            y = [0 for _ in range(N*M)]\n            for p in range(-D,D+1):\n                q1 = j + (D - abs(p))\n                q2 = j - (D - abs(p))\n                if 0 <= i + p < N and 0 <= q1 < M:\n                    y[(i+p) * M + q1] = 1\n                if 0 <= i+ p < N and 0 <= q2 < M:\n                    y[(i+p) * M + q2] = 1\n            y[i * M + j] = 1\n            x.append(y)\n    x.append(S)\n\n    z = []\n    for i in range(N*M):\n        b = 0\n        for j in range(N*M+1):\n            b <<= 1\n            b += x[j][i]\n        z.append(b)\n\n\n    c = [True for _ in range(N*M)]\n    b = 1 << (N * M)\n    for i in range(N*M):\n        for j in range(N*M):\n            if z[j] & b and c[j]:\n                for k in range(N*M):\n                    if k == j or z[k] & b == 0: continue\n                    z[k] ^= z[j]\n                    c[j] = False\n                break\n        b >>= 1\n\n    if z.count(1):\n        print (0)\n    else:\n        print (1)\n"
  }
]