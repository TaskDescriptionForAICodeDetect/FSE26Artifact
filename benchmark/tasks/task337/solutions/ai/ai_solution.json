[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y, r;\n} Circle;\n\ndouble distance(Circle a, Circle b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy) - a.r - b.r;\n}\n\nint compareX(const void *a, const void *b) {\n    Circle *c1 = (Circle *)a;\n    Circle *c2 = (Circle *)b;\n    if (c1->x < c2->x) return -1;\n    if (c1->x > c2->x) return 1;\n    return 0;\n}\n\nint compareY(const void *a, const void *b) {\n    Circle *c1 = (Circle *)a;\n    Circle *c2 = (Circle *)b;\n    if (c1->y < c2->y) return -1;\n    if (c1->y > c2->y) return 1;\n    return 0;\n}\n\ndouble bruteForce(Circle circles[], int n) {\n    double min = DBL_MAX;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            double dist = distance(circles[i], circles[j]);\n            if (dist < min) {\n                min = dist;\n            }\n        }\n    }\n    return min;\n}\n\ndouble stripClosest(Circle strip[], int size, double d) {\n    double min = d;\n    qsort(strip, size, sizeof(Circle), compareY);\n    for (int i = 0; i < size; ++i) {\n        for (int j = i + 1; j < size && (strip[j].y - strip[i].y) < min; ++j) {\n            double dist = distance(strip[i], strip[j]);\n            if (dist < min) {\n                min = dist;\n            }\n        }\n    }\n    return min;\n}\n\ndouble closestUtil(Circle circles[], int n) {\n    if (n <= 3) {\n        return bruteForce(circles, n);\n    }\n    int mid = n / 2;\n    Circle midCircle = circles[mid];\n    double dl = closestUtil(circles, mid);\n    double dr = closestUtil(circles + mid, n - mid);\n    double d = fmin(dl, dr);\n    Circle strip[n];\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        if (fabs(circles[i].x - midCircle.x) < d) {\n            strip[j++] = circles[i];\n        }\n    }\n    return fmin(d, stripClosest(strip, j, d));\n}\n\ndouble closestPair(Circle circles[], int n) {\n    qsort(circles, n, sizeof(Circle), compareX);\n    return closestUtil(circles, n);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Circle circles[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf\", &circles[i].x, &circles[i].y, &circles[i].r);\n    }\n    double minDist = closestPair(circles, N);\n    if (minDist < 0) minDist = 0;\n    printf(\"%.6f\\n\", minDist);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Circle {\n    double x, y, r;\n};\n\ndouble distance(const Circle& a, const Circle& b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy) - a.r - b.r;\n}\n\nbool compareX(const Circle& a, const Circle& b) {\n    return a.x < b.x;\n}\n\nbool compareY(const Circle& a, const Circle& b) {\n    return a.y < b.y;\n}\n\ndouble bruteForce(const vector<Circle>& circles, int left, int right) {\n    double minDist = numeric_limits<double>::max();\n    for (int i = left; i <= right; ++i) {\n        for (int j = i + 1; j <= right; ++j) {\n            double dist = distance(circles[i], circles[j]);\n            if (dist < minDist) {\n                minDist = dist;\n            }\n        }\n    }\n    return minDist;\n}\n\ndouble closestPairUtil(vector<Circle>& circles, int left, int right) {\n    if (right - left <= 3) {\n        return bruteForce(circles, left, right);\n    }\n\n    int mid = (left + right) / 2;\n    Circle midCircle = circles[mid];\n\n    double dl = closestPairUtil(circles, left, mid);\n    double dr = closestPairUtil(circles, mid + 1, right);\n    double d = min(dl, dr);\n\n    vector<Circle> strip;\n    for (int i = left; i <= right; ++i) {\n        if (abs(circles[i].x - midCircle.x) < d) {\n            strip.push_back(circles[i]);\n        }\n    }\n\n    sort(strip.begin(), strip.end(), compareY);\n\n    for (size_t i = 0; i < strip.size(); ++i) {\n        for (size_t j = i + 1; j < strip.size() && (strip[j].y - strip[i].y) < d; ++j) {\n            double dist = distance(strip[i], strip[j]);\n            if (dist < d) {\n                d = dist;\n            }\n        }\n    }\n\n    return d;\n}\n\ndouble closestPair(vector<Circle>& circles) {\n    sort(circles.begin(), circles.end(), compareX);\n    return closestPairUtil(circles, 0, circles.size() - 1);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Circle> circles(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> circles[i].x >> circles[i].y >> circles[i].r;\n    }\n\n    double minDistance = closestPair(circles);\n    if (minDistance < 0) {\n        minDistance = 0;\n    }\n    cout.precision(10);\n    cout << fixed << minDistance << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Circle {\n    double x, y, r;\n\n    Circle(double x, double y, double r) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n    }\n}\n\npublic class ClosestPairOfCircles {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        List<Circle> circles = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            double r = scanner.nextDouble();\n            circles.add(new Circle(x, y, r));\n        }\n\n        double minDistance = Double.MAX_VALUE;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                Circle c1 = circles.get(i);\n                Circle c2 = circles.get(j);\n                double dx = c1.x - c2.x;\n                double dy = c1.y - c2.y;\n                double centerDistance = Math.sqrt(dx * dx + dy * dy);\n                double distance = Math.max(0, centerDistance - c1.r - c2.r);\n                if (distance < minDistance) {\n                    minDistance = distance;\n                }\n            }\n        }\n\n        System.out.printf(\"%.6f%n\", minDistance);\n    }\n}",
    "timestamp": "2025-08-05 21:09:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class Circle {\n        double x, y, radius;\n        \n        Circle(double x, double y, double radius) {\n            this.x = x;\n            this.y = y;\n            this.radius = radius;\n        }\n    }\n    \n    public static double findClosestCirclesDistance(Circle[] circles) {\n        int n = circles.length;\n        if (n < 2) return -1;\n        \n        double minDistance = Double.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                double centerDistance = Math.sqrt(\n                    Math.pow(circles[i].x - circles[j].x, 2) +\n                    Math.pow(circles[i].y - circles[j].y, 2)\n                );\n                \n                double distance = centerDistance - circles[i].radius - circles[j].radius;\n                minDistance = Math.min(minDistance, distance);\n            }\n        }\n        \n        return minDistance;\n    }\n    \n    public static void main(String[] args) {\n        Circle[] circles = {\n            new Circle(1, 2, 3),\n            new Circle(4, 5, 2),\n            new Circle(7, 8, 1)\n        };\n        \n        double result = findClosestCirclesDistance(circles);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:09:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y;\n    double radius;\n} Circle;\n\ndouble distance_between_circles(Circle c1, Circle c2) {\n    double center_dist = sqrt(pow(c1.x - c2.x, 2) + pow(c1.y - c2.y, 2));\n    return fmax(0, center_dist - c1.radius - c2.radius);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Circle* circles = malloc(N * sizeof(Circle));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf\", &circles[i].x, &circles[i].y, &circles[i].radius);\n    }\n\n    double min_distance = DBL_MAX;\n    double max_radius = -DBL_MAX;\n    double min_radius = DBL_MAX;\n\n    for (int i = 0; i < N; i++) {\n        max_radius = fmax(max_radius, circles[i].radius);\n        min_radius = fmin(min_radius, circles[i].radius);\n    }\n\n    if (max_radius > 2 * min_radius) {\n        printf(\"-1\\n\");\n        free(circles);\n        return 0;\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            double dist = distance_between_circles(circles[i], circles[j]);\n            min_distance = fmin(min_distance, dist);\n        }\n    }\n\n    printf(\"%.2f\\n\", min_distance);\n    \n    free(circles);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:09:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n#include <algorithm>\n\nstruct Circle {\n    double x, y, r;\n};\n\ndouble distance(const Circle& c1, const Circle& c2) {\n    double centerDist = std::sqrt(std::pow(c1.x - c2.x, 2) + std::pow(c1.y - c2.y, 2));\n    return std::max(0.0, centerDist - c1.r - c2.r);\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    std::vector<Circle> circles(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> circles[i].x >> circles[i].y >> circles[i].r;\n    }\n\n    double minDistance = std::numeric_limits<double>::max();\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            minDistance = std::min(minDistance, distance(circles[i], circles[j]));\n        }\n    }\n\n    std::cout << std::fixed << std::setprecision(6) << minDistance << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:09:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef circle_distance(circle1, circle2):\n    x1, y1, r1 = circle1\n    x2, y2, r2 = circle2\n    \n    center_distance = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n    return max(0, center_distance - (r1 + r2))\n\ndef closest_pair_of_circles(circles):\n    min_distance = float('inf')\n    closest_pair = None\n    \n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            distance = circle_distance(circles[i], circles[j])\n            if distance < min_distance:\n                min_distance = distance\n                closest_pair = (circles[i], circles[j])\n                \n    return min_distance\n\n# Example usage:\n# circles = [(x1, y1, r1), (x2, y2, r2), ..., (xN, yN, rN)]\n# N = number of circles\n# print(closest_pair_of_circles(circles))",
    "timestamp": "2025-08-13 05:09:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\nclass Circle {\n    double x, y, r;\n\n    Circle(double x, double y, double r) {\n        this.x = x;\n        this.y = y;\n        this.r = r;\n    }\n\n    double distanceTo(Circle other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)) - (this.r + other.r);\n    }\n}\n\npublic class ClosestCirclePair {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n\n        Circle[] circles = new Circle[N];\n        for (int i = 0; i < N; i++) {\n            double x = sc.nextDouble();\n            double y = sc.nextDouble();\n            double r = sc.nextDouble();\n            circles[i] = new Circle(x, y, r);\n        }\n\n        double minDistance = Double.MAX_VALUE;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                double distance = circles[i].distanceTo(circles[j]);\n                if (distance < minDistance) {\n                    minDistance = distance;\n                }\n            }\n        }\n\n        System.out.println(minDistance);\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 05:09:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x;\n    double y;\n    double r;\n} Circle;\n\ndouble distance(double x1, double y1, double x2, double y2) {\n    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n}\n\ndouble circleDistance(Circle c1, Circle c2) {\n    double centerDistance = distance(c1.x, c1.y, c2.x, c2.y);\n    return centerDistance - c1.r - c2.r;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    Circle circles[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf %lf\", &circles[i].x, &circles[i].y, &circles[i].r);\n    }\n\n    double minDistance = DBL_MAX;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            double dist = circleDistance(circles[i], circles[j]);\n            if (dist < minDistance) {\n                minDistance = dist;\n            }\n        }\n    }\n\n    printf(\"%.6lf\\n\", minDistance);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:09:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def distance_between_circles(c1, c2):\n    x1, y1, r1 = c1\n    x2, y2, r2 = c2\n    center_dist = ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n    return max(0, center_dist - r1 - r2)\n\ndef solve_closest_circles(circles):\n    if len(circles) < 2:\n        return -1\n    \n    min_radius = min(circle[2] for circle in circles)\n    max_radius = max(circle[2] for circle in circles)\n    \n    if max_radius > 2 * min_radius:\n        return -1\n    \n    min_distance = float('inf')\n    for i in range(len(circles)):\n        for j in range(i+1, len(circles)):\n            dist = distance_between_circles(circles[i], circles[j])\n            min_distance = min(min_distance, dist)\n    \n    return min_distance\n\n# Example usage\nN = int(input())\ncircles = []\nfor _ in range(N):\n    x, y, r = map(int, input().split())\n    circles.append((x, y, r))\n\nresult = solve_closest_circles(circles)\nprint(result)",
    "timestamp": "2025-08-13 05:10:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef closest_pair_of_circles(circles):\n    min_distance = float('inf')\n    n = len(circles)\n    for i in range(n):\n        x1, y1, r1 = circles[i]\n        for j in range(i + 1, n):\n            x2, y2, r2 = circles[j]\n            dx = x2 - x1\n            dy = y2 - y1\n            center_distance = math.sqrt(dx*dx + dy*dy)\n            distance = center_distance - r1 - r2\n            if distance < min_distance:\n                min_distance = distance\n    return max(min_distance, 0)  # Ensure non-negative distance\n\n# Read input\nn = int(input())\ncircles = []\nfor _ in range(n):\n    x, y, r = map(float, input().split())\n    circles.append((x, y, r))\n\n# Compute and print the result\nresult = closest_pair_of_circles(circles)\nprint(\"{0:.3f}\".format(result))",
    "timestamp": "2025-08-13 05:10:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nclass Circle {\npublic:\n    double x, y, radius;\n    Circle(double x, double y, double radius) : x(x), y(y), radius(radius) {}\n};\n\ndouble distanceBetweenCircles(const Circle& c1, const Circle& c2) {\n    double centerDistance = sqrt(pow(c2.x - c1.x, 2) + pow(c2.y - c1.y, 2));\n    double distance = centerDistance - c1.radius - c2.radius;\n    return distance >= 0 ? distance : 0;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<Circle> circles;\n    for (int i = 0; i < N; ++i) {\n        double x, y, radius;\n        cin >> x >> y >> radius;\n        circles.emplace_back(x, y, radius);\n    }\n    \n    double minDistance = numeric_limits<double>::max();\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            double distance = distanceBetweenCircles(circles[i], circles[j]);\n            if (distance < minDistance) {\n                minDistance = distance;\n            }\n        }\n    }\n    \n    cout << minDistance << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:23:18"
  }
]