[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#define ele int\nusing namespace std;\n#define maxn 100010\n#define INF 1e18\n#define eps 1e-7\nstruct circle{\n\tdouble x,y,r;\n};\nele n;\ndouble R;\ncircle a[maxn];\ninline bool cmp1(circle a,circle b){\n\treturn a.x<b.x;\n}\ninline bool cmp2(circle a,circle b){\n\treturn a.y<b.y;\n}\ninline double dis(circle a,circle b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))-a.r-b.r;\n}\ndouble solve(ele l,ele r){\n\tif (r-l+1<=10){\n\t\tdouble ans=INF;\n\t\tfor (int i=l; i<=r; ++i)\n\t\t\tfor (int j=i+1; j<=r; ++j)\n\t\t\t\tans=min(ans,dis(a[i],a[j]));\n\t\treturn ans;\n\t}\n\tele mid=(l+r)>>1;\n\tdouble ans=min(solve(l,mid-1),solve(mid+1,r));\n\tfor (int i=l; i<=r; ++i)\n\t\tif (i!=mid) ans=min(ans,dis(a[i],a[mid]));\n\tstatic circle p[maxn],q[maxn];\n\tele u=0,v=0;\n\tfor (int i=l; i<mid; ++i)\n\t\tif (a[mid].x-a[i].x<ans+R*2+eps) p[u++]=a[i];\n\tfor (int i=mid+1; i<=r; ++i)\n\t\tif (a[i].x-a[mid].x<ans+R*2+eps) q[v++]=a[i];\n\tif (!v) return ans;\n\tsort(p,p+u,cmp2); sort(q,q+v,cmp2);\n\tele s=0,t=0;\n\tfor (int i=0; i<u; ++i){\n\t\twhile (s<v-1 && p[i].y-q[s].y>ans+R*2+eps) ++s;\n\t\twhile (t<v-1 && q[t+1].y-p[i].y<ans+R*2+eps) ++t;\n\t\tfor (int j=s; j<=t; ++j) ans=min(ans,dis(p[i],q[j]));\n\t}\n\treturn ans;\n}\nint main(){\n\twhile (scanf(\"%d\",&n),n){\n\t\tR=0;\n\t\tfor (int i=0; i<n; ++i){\n\t\t\tscanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n\t\t\tR=max(R,a[i].r);\n\t\t}\n\t\tsort(a,a+n,cmp1);\n\t\tprintf(\"%.10lf\\n\",solve(0,n-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  //return a.o.imag() - a.r < b.o.imag() - b.r;\n  return a.o.imag() < b.o.imag();\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max((double)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble valM;\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    bool f = false;\n    if(x > a[i].o.real()){\n      if(a[i].o.real() <= x && x <= a[i].o.real() + a[i].r) f = true;\n      if(fabs(a[i].o.real() + a[i].r - x) < d) f = true;\n    }else{\n      if(a[i].o.real() - a[i].r <= x && x <= a[i].o.real()) f = true;\n      if(fabs(a[i].o.real() - a[i].r - x) < d) f = true;\n    }\n    if(!f) continue;\n    //if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(dy >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    //cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> P;\nstruct C{\n    P p;\n    double r;\n};\nbool operator < (const C& c, const C& d) {\n    return c.p.real() < d.p.real();\n}\n\nint main(){\n    int n;\n    while(cin >> n && n > 0) {\n        vector<C> cs(n);\n        double max_r = 0;\n        REP(i, n) {\n            double r, x, y;\n            cin >> r >> x >> y;\n            cs[i] = {{x, y}, r};\n\n            max_r = max(max_r, r);\n        }\n        sort(cs.begin(), cs.end());\n        double ans = 1e63;\n        REP(i, n) {\n            for(int j = i + 1; j < n; j++) {\n                if(ans < cs[j].p.real() - cs[i].p.real() - cs[i].r - max_r) {\n                    break;\n                }\n                ans = min(ans, abs(cs[i].p - cs[j].p) - cs[i].r - cs[j].r);\n            }\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst long double EPS = 1e-6;\nconst int MAX_N = 100000;\nconst long double INF = 1000000000000.0;\n\nbool equal(long double a, long double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   long double x, y, r;\n   Circle(){}\n   Circle(long double y, long double x, long double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\nlong double closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   long double x = a[m].x;\n   long double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) >= d + a[i].r) continue;\n      for(int j=0;j<b.size();j++){\n         long double dx = a[i].x - b[b.size()-j-1].x;\n         long double dy = a[i].y - b[b.size()-j-1].y;\n         long double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy >= d + dr) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    Point rotate(double theta) const{\n        return Point(x * sin(theta) + y * cos(theta), x * cos(theta) - y * sin(theta));\n    }\n    bool operator< (const Point& p) const{\n        return x < p.x;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<pair<Point, double> > v(n);\n        for(int i=0; i<n; ++i)\n            cin >> v[i].second >> v[i].first.x >> v[i].first.y;\n\n        double ret = DBL_MAX;\n        for(int i=0; i<100; ++i){\n            sort(v.begin(), v.end());\n            for(int j=1; j<n; ++j)\n                ret = min(ret, v[j].first.dist(v[j-1].first) - v[j].second - v[j-1].second);\n            for(int j=0; j<n; ++j)\n                v[j].first = v[j].first.rotate(2*PI/100);\n        }\n        printf(\"%.10f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    return o.real() - r < s.o.real() - s.r;\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  return a.o.imag() - a.r < b.o.imag() - b.r;\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max(0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(fabs(dy) >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    printf(\"%.8f\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  Point p1,p2,p3,p4,p5,p6,p7,p8,p9;\n  p1=p2=p3=p4=p5=p6=p7=p8=p9=BigPoint;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) < min_val+2*maxr){\n      min_val=min(min_val,a[i].dist(p1));\n      min_val=min(min_val,a[i].dist(p2));\n      min_val=min(min_val,a[i].dist(p3));\n      min_val=min(min_val,a[i].dist(p4));\n      min_val=min(min_val,a[i].dist(p5));\n      min_val=min(min_val,a[i].dist(p6));\n      min_val=min(min_val,a[i].dist(p7));\n      min_val=min(min_val,a[i].dist(p8));\n      min_val=min(min_val,a[i].dist(p9));\n      p1=p2;p2=p3;p3=p4;p4=p5;p5=p6;\n      p6=p7;p7=p8;p8=p9;p9=a[i];\n    }\n  }\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = i+1 ; j < min(i+2,n) ; j++){\n\t\t\t\tans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = i+1 ; j < min(i+2,n) ; j++){\n\t\t\t\tans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f%c\",ans,10);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\nconst double INF = 1e18;\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n    C(){}\n};\nbool xcomp(const C &a, const C &b){\n    return (a.p.X != b.p.X)? a.p.X<b.p.X : a.p.Y<b.p.Y;\n}\nbool ycomp(const C &a, const C &b){\n    return (a.p.Y != b.p.Y)? a.p.Y<b.p.Y : a.p.X<b.p.X;\n}\n\ndouble closest(vector<C> &c, int first, int last, double rmax){\n    if(last -first <= 1) return INF;\n    int mid = (first +last)/2;\n    double midx = c[mid].p.X;\n    double d = min(closest(c, first, mid, rmax), closest(c, mid, last, rmax));\n    inplace_merge(c.begin()+first, c.begin()+mid, c.begin()+last, ycomp);\n\n    vector<C> near;\n    for(int i=first; i<last; i++){\n        if(abs(c[i].p.X -midx) -c[i].r -rmax > d) continue;\n        for(int j=near.size()-1; j>=0; j--){\n            double dist = abs(c[i].p -near[j].p);\n            if(dist -c[i].r -rmax > d){\n                break;\n            }\n            d = min(d, dist -c[i].r -near[j].r);\n        }\n        near.push_back(c[i]);\n    }\n    return d;\n}\n \nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<C> c(n);\n        double rmax = 0;\n        for(int i=0; i<n; i++){\n            double r,x,y;\n            cin >> r >> x >> y;\n            c[i] = C(P(x, y), r);\n            rmax = max(rmax, r);\n        }\n        sort(c.begin(), c.end(), xcomp);\n\n        cout << fixed << setprecision(10);\n        cout << closest(c, 0, n, rmax) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-6)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tdouble r;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\n// \tVerified: AOJ 0081 A Symmetric Point\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t三角形の面積（外積）\n\n\t説明\n\t\t三頂点で定まる三角形の面積（の２倍）を求める\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n*/\ntemplate<class T>\nT area2(const point<T> &a, const point<T> &b, const point<T> &c ){\n\treturn abs(cross(b-a,c-a));\n}\n/*\n\t三角形の面積（Heron）\n\n\t説明\n\t\t三辺の長さで定まる三角形の面積を求める\n\t引数\n\t\ta : 一辺の長さ\n\t\tb : 一辺の長さ\n\t\tc : 一辺の長さ\n\t戻り値\n\t\t三角形の面積\n\t\t三角形が作れないとき、縮退しているときには 0\n\t制約\n\t\ta>=0, b>=0, c>=0\n\t\ta<b+c, b<c+a, c<a+b（三角形の成立条件）\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble area(double a, double b, double c ){\n\treturn sqrt((a+b-c)*(b+c-a)*(c+a-b)*(a+b-c))/4.;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079: Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n// (B)\n\n//enum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t線分と線分の距離\n*/\n\n/*\n\t三角形と点の包含判定\n\n\t説明\n\t\t三角形 abc が点 p を含むかどうかを判定する\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\t三角形は縮退していないこと\n\t\tすなわち、三点が同一直線上にないこと、（特に、どの二点も等しくないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形は CCW でも CW でもよい\n\t\t点が三角形の境界になるときは含むと判定する\n\t\tVerified: AOJ 0012: A Point in a Triangle\n\t\tVerified: AOJ 0143: Altair and Vega \n*/\ntemplate<class T>\nbool cover(const point<T> &a, const point<T> &b, const point<T> &c, const point<T> &p ){\n\tint d1 = ccw (p, a, b );\n\tint d2 = ccw (p, b, c );\n\tint d3 = ccw (p, c, a );\n\treturn !((d1 == CCW && d2 == CW ) || (d1 == CCW && d3 == CW ) || (d2 == CCW && d3 == CW ) || (d1 == CW && d2 == CCW ) || (d1 == CW && d3 == CCW ) || (d2 == CW && d3 == CCW ) );\n}\n\n/*\n\t直線と点の包含判定\n*/\n\n/*\n\t線分と点の包含判定\n*/\n\n/*\n\t多角形と点の包含判定\n*/\n\n/*\n\t多角形と多角形の包含判定\n*/\n\n/*\n\t円と点の包含判定\n\n\t説明\n\t\t円が点を含むかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tp : 点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\n// (A)\ntemplate<class T>\nbool cover (const circle<T> &C, const point<T> &p ){\n\treturn dist2(C.c, p) <= C.r*C.r;\n}\n\n// (B)\nbool cover (const circle<double> &C, const point<double> &p ){\n\treturn dist (C.c, p ) < C.r + EPS;\n}\n\n/*\n\t直線と直線の交差判定\n*/\n\n/*\n\t直線と線分の交差判定\n*/\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t多角形と線分の交差判定\n\n\t説明\n\t\t多角形と線分が交わるかどうかを判定する\n\t引数\n\t\tG : 多角形\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n)\n\t備考\n\t\tG は凸でなくていい。\n\t\tG は境界を含む\n\t\tS が G の内部にあるときは交わると判定する\n*/\ntemplate<class T>\nbool intersect(const polygon<T> &G, const segment<T> &S ){\n\tint n = G.size();\n\tif (cover(G, S.a ) || cover (G, S.b ) ) return true;\n\trep (i, n ) if (intersect((segment<T>){G[i], G[(i+1)%n]}, S ) ) return true;\n\treturn false;\n}\n\n/*\n\t多角形と多角形の交差判定\n*/\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\n/*\n\t二直線の交点\n\n\t説明\n\t\t二直線の交点を求める\n\t\t(A)（直線を特徴付ける点の）座標値が整数\n\t\t(B)（直線を特徴付ける点の）座標値が実数\n\t引数\n\t\tL1 : 直線\n\t\tL2 : 直線\n\t戻り値\n\t\tL1 と L2 の交点\n\t制約\n\t\t二直線は交点を持つこと。（平行でない or L1 == L2 )\n\t計算量\n\t\tO(1)\n\t備考\n\t\t交点が複数あるとき（L1 == L2）は L1.a を返す。\n\t\tこの仕様は線分 S と直線 L の交点を求めたいとき重要。\n\t\t（ S と L が同一直線上にあるときにも、S を第１引数に指定することで交点が正しく求まる。）\n\n*/\n// (A)\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1, const line<T> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1==0) return L1.a;\t// L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n// (B)\npoint<double> get_intersect(const line<double> &L1, const line<double> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1<EPS) return L1.a;\t// L1 == L2\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n/*\n\t二線分の交点\n*/\n\n/*\n\t円と直線の交点\n*/\n\n/*\n\t円と円の交点\n\n\t説明\n\t\t円と円の交点を求める\n\t引数\n\t\tC1 : 円\n\t\tC2 : 円\n\t\tres : 計算結果（交点の集合）\n\t戻り値\n\t\t交点の個数\n\t\tただし、交点が無限個になる（２つの円が等しい）ときは -1\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tres は初期化されない\n\t\t交点が無限個あるときは res には何も追加されない\n\t\tVerified: AOJ 0090 Overlaps of Seals\n*/\nint get_intersect(const circle<double> &C1, const circle<double> &C2, vector< point<double> > &res ){\n\tdouble r1=C1.r,r2=C2.r;\n\tpoint<double> p1=C1.c,p2=C2.c;\n\n\tdouble d=abs(p1-p2);\n\tif (d<EPS && abs(r1-r2)<EPS ){\t// C1 == C2\n\t\treturn -1;\n\t}else\n\tif (r1+r2<d-EPS || d+EPS<abs(r1-r2) ){\n\t\treturn 0;\n\t}else{\n\t\tdouble a = (r1*r1-r2*r2+d*d)/(2.*d);\n\t\tdouble h = sqrt(max(r1*r1-a*a, 0. ) );\n\t\tpoint<double> tmp1 = p1+a/d*(p2-p1);\n\t\tpoint<double> tmp2 = h/d*(p2-p1);\n\t\tif (abs(tmp2)<EPS ){\n\t\t\tres.push_back (tmp1 );\n\t\t\treturn 1;\n\t\t}else{\n\t\t\tres.push_back ((point<double>){tmp1.x-tmp2.y, tmp1.y+tmp2.x});\n\t\t\tres.push_back ((point<double>){tmp1.x+tmp2.y, tmp1.y-tmp2.x});\n\t\t\treturn 2;\n\t\t} // end if\n\t} // end if\n}\n\n/*\n\t点から円に引いた接線の交点\n*/\n\n/*\n\t円と円の共通接線\n*/\n\n/*\n\t垂直二等分線\n\n\t説明\n\t\t二点 a, b の垂直二等分線を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\ta と b の垂直二等分線\n\t計算量\n\t\tO(1)\n\t備考\n\t\t垂直二等分線を L とすると、L.a から L.b の方向を見たとき、左手に点 a が来る。\n*/\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a, const point<T> &b ){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0, (a.y+a.x+b.y-b.x)/2.0 },\n\t\t\t\t\t\t\t(point<double>){(a.x+a.y+b.x-b.y)/2.0, (a.y-a.x+b.y+b.x)/2.0 }};\n}\n\n/*\n\t点対称\n\n\t説明\n\t\t点 b を基準に点 a を点対称を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点対称の点\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\npoint<T> symmetry_point (const point<T> a, const point<T> b )\n{\n\treturn (point<T>){2*b.x-a.x, 2*b.y-a.y};\n}\n\n/*\n\t多角形の重心の座標\n\n\t説明\n\t\t頂点数 n の凸多角形をひとつの頂点を基準に n - 2 個の三角形に分割した三角形の面積を Sk,\n\t\t重心を gk とおくと n の凸多角形の重心 G は\n\n\t\tG = \\sum_{k=1}^{n-2}Sk*gk/(\\sum_{k=1}^{n-2}Sk)\n\n\t\tで求められる。\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t点\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 2442: ConvexCut しかし EPS=1e-6 にしないと WA.\n*/\ntemplate<class T>\npoint<T> centerG(const polygon<T> &G ){\n\tint n = G.size();\n\tdouble S = 0.;\n\tpoint<double> g; g.x = 0.; g.y = 0.;\n\tint u = G.size()-1;\n\tfor (int i = 0; i < n; u=i++ ){\n\t\tdouble sk = cross (G[u], G[i] );\n\t\tS += sk;\n\t\tg.x += (G[u].x + G[i].x)*sk;\n\t\tg.y += (G[u].y + G[i].y)*sk;\n\t} // end for\n\tg /= (3.*S);\n\n\treturn g;\n/*\n\tint n = G.size();\n\tdouble ar = 0.;\n\tdouble x = 0., y = 0.;\n\trep (i, n - 2 ){\n\t\tdouble k = area2 (G[n-1], G[i], G[i+1] );\n\t\tar += k;\n\t\tx += (G[n-1].x + G[i].x)*k;\n\t\ty += (G[n-1].y + G[i].y)*k;\n\t} // end rep\n\tx /= (3.*ar );\n\ty /= (3.*ar );\n\t\n\treturn (point<T>){x,y};\n*/\n}\n\n/*\n\t二点と半径で定まる円\n*/\n\n/*\n\t凸性判定\n\t\n\t説明\n\t\t多角形が凸かどうかを判定する\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tG は単調かつ頂点の順番が CCW で与えられていること\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\ntemplate<class T>\nbool is_convex(const polygon<T> &G ){\n\tint n = G.size();\n\trep (i, n ) if (ccw (G[i], G[(i+1)%n], G[(i+2)%n])== CW ) return false;\n\treturn true;\n}\n\n/*\n\t凸包\n\n\t説明\n\t\t点集合の凸包を求める\n\t引数\n\t\tP : 点集合\n\t戻り値\n\t\tP の凸包\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n log n )\n\t備考\n\t\tP は破壊される。\n\n\t\tsort は (x, y ) の辞書順。\n\n\t\t凸包の同じ直線上にある頂点は端のものだけを拾う。\n\t\t辺上になる頂点を全部拾うようにしたいときは != CCW を ==CW と修正すればよい。\n*/\ntemplate<class T>\npolygon<T> convex_hull(vector< point<T> > &P ){\n\tint n = P.size();\n\tpolygon<T> CH;\n\tif (n <= 1 ){\n\t\tCH.insert (CH.end(), P.begin(), P.end() );\n\t\treturn CH;\n\t} // end if\n\tsort (ALL (P ) );\n\trep (cnt, 2 ){\n\t\tint m = 0;\n\t\tvector< point<T> > half(n );\n\t\trep (i, n ){\n\t\t\thalf[m++] = P[i];\n\t\t\twhile (m >= 3 && ccw (half[m-3], half[m-2], half[m-1] ) != CCW ){\n\t\t\t\thalf[m-2] = half[m-1];\n\t\t\t\tm--;\n\t\t\t} // end while\n\t\t} // end rep\n\t\tCH.insert (CH.end(), half.begin(), half.begin()+m-1 );\n\t\treverse (ALL (P ) );\n\t} // end rep\n\t\n\treturn CH;\n}\n\n/*\n\t凸多角形の切断\n*/\n\n/*\n\t内接円の半径\n\n\t説明\n\t\t辺長がそれぞれ、a, b, c である三角形の内接円の半径を求める\n\t引数\n\t\ta: 辺長\n\t\tb: 辺長\n\t\tc: 辺長\n\t戻り値\n\t\t内接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, c < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble inradius(double a, double b, double c ){\n\treturn sqrt ((b+c-a)*(c+a-b)*(a+b-c)/(a+b+c))/2.;\n}\n\n/*\n\t外接円\n\n\t説明\n\t\t三角形 abc の外接円を求める\n\t引数\n\t\ta: 頂点\n\t\tb: 頂点\n\t\tc: 頂点\n\t戻り値\n\t\t外接円\n\t制約\n\t\ta, b, c は同一直線上にないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\ta, b, c が同一直線上にあるときは外接円は存在しない\n\t\t頂点が整数座標のとき、外心の座標と半径の二乗は有理数となる\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ncircle<double> circumcircle(const point<double> &a, point<double> b, point<double> c ){\n\tb-=a; c-=a;\n\tdouble A2 = abs2(b-c), B2 = abs2(b), C2 = abs2(c);\n\tdouble d = 2*cross(b,c);\n\tdouble nx = c.y*B2-b.y*C2;\n\tdouble ny = b.x*C2-c.x*B2;\n\tdouble r2 = A2*B2*C2/(d*d);\n\treturn (circle<double>){a+(point<double>){nx/d, ny/d}, sqrt(r2)};\n}\n\n/*\n\t外接円の半径\n\t\n\t説明\n\t\t辺長がそれぞれ a, b, c である三角形の外接円の半径を求める\n\t引数\n\t\ta : 辺長\n\t\tb : 辺長\n\t\tc : 辺長\n\t戻り値\n\t\t外接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, b < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ndouble circumradius(double a, double b, double c ){\n\treturn a*b*c/sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c) );\n}\n\n/*\n\t最小包含球\n*/\n\n/*\n\t線分アレンジメント\n*/\n\n/*\n\t最近点対\n\n\t説明\n\t\t最近点対問題を解く\n\t引数\n\t\tn : 点の個数\n\t\tp : 点集合\n\t戻り値\n\t\t最近点対の距離\n\t制約\n\t\tn>=2\n\t計算量\n\t\tO(n log n)\n\t備考\n\t\tsort は (x,y) の辞書順。\n\t\tP の順番は破壊される（内部でソートするため）\n*/\nstruct cmp_y{\nbool operator()(const point<double> &a, const point<double> &b ){\n\treturn (a.y+EPS<b.y || (abs(a.y-b.y)<EPS && a.x+EPS<b.x ) );\n}};\n\n\ndouble closest_pair(int n, point<double> *P){\n\tdouble r_max = 0.;\n\trep (i, n ) r_max = max (r_max, P[i].r );\n\tsort (P, P+n );\n\tdouble d = dist(P[0],P[1] ) - P[0].r - P[1].r;\n\tset<point<double>, cmp_y> S;\n\tset<point<double>, cmp_y>::iterator it_l, it_r, it;\n\tfor (int i = 0, j = 0; i < n; i++ ){\n\t\tit_l = S.lower_bound ((point<double>){0,P[i].y-d-2.*r_max});\n\t\tit_r = S.upper_bound ((point<double>){0,P[i].y+d+2.*r_max});\n\t\tfor (it=it_l;it!=it_r;++it) d=min(d, dist(*it,P[i]));\n\t\twhile(P[i].x-P[j].x>d+2.*r_max+EPS ) S.erase(P[j++] );\n\t\tS.insert(P[i] );\n\t} // end for\n\n\treturn d;\n}\n\n/*\n\t楕円の周長\n*/\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.2057\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tstatic point<double> p[(int)1e5+5];\n\t\trep (i, n ) scanf (\"%lf %lf %lf\",&p[i].r, &p[i].x, &p[i].y );\n\t\tdouble res = closest_pair(n, p );\n\t\tprintf (\"%.5lf\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define MAX 2000000\n#define all(n) (n).begin(),(n).end()\nusing namespace std;\nstruct Circle\n{\n  double x,y,r;\n  Circle(double x=inf,double y=inf,double r=inf):x(x),y(y),r(r){}\n  bool operator < (const Circle& c)const\n  {\n    if(!equals(x,c.x))return x < c.x;\n    return y < c.y;\n  }\n};\n\nbool compare_y(Circle a,Circle b)\n{\n  return a.y < b.y;\n}\n\nint N;\nCircle A[MAX];\n\ndouble compute(Circle *a,int n)\n{\n  if(n <= 1)return inf;\n  int m = n/2;\n  double x = a[m].x;\n  double y = a[m].y;\n  double r = a[m].r;\n  double d = min(compute(a,m),compute(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Circle> b;\n\n  rep(i,n)\n    {\n      double nx = a[i].x - x;\n      double ny = a[i].y - y;\n      double ndist = sqrt(nx*nx + ny*ny) - a[i].r - r;\n      //if(equals(ndist,d) || ndist > d)continue;\n      //if(nx >= d)continue;\n     \n      rep(j,(int)min((int)b.size(),3))\n\t{\n\t  int last = b.size()-j-1;\n\t  double dx = a[i].x - b[last].x;\n\t  double dy = a[i].y - b[last].y;\n\t  double dist = sqrt(dx*dx + dy*dy) - a[i].r - b[last].r;\n\n\t  if(equals(dist,d) || dist > d)continue;\n\t  d = min(d,sqrt(dx*dx + dy*dy) - a[i].r - b[last].r);\n\t}\n      b.push_back(a[i]);\n    }\n  return d;\n}\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      assert(N < MAX);\n      rep(i,N)cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A,A+N);\n\n\n      cout << setiosflags(ios::fixed) << setprecision(8) << compute(A,N) << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nclass Circle{\npublic:\n  P cp;\n  double r;\n};\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double INF=-1;\nconst int band=10;\nint main(){\n  int n;\n  while(cin>>n&&n!=0){\n    int xsortedIdxs[100001];\n    int ysortedIdxs[100001];\n    vector<Circle> cs;\n    vector<pair<double,int> > xsorted;\n    vector<pair<double,int> > ysorted;\n    double x,y,r;\n    for(int i = 0; i < n; i++){\n      Circle c;\n      cin>>r>>x>>y;\n      c.r=r;\n      c.cp=P(x,y);\n      cs.push_back(c);\n      xsorted.push_back(make_pair(x,i));\n      ysorted.push_back(make_pair(y,i));\n    }\n    sort(xsorted.begin(),xsorted.end());\n    sort(ysorted.begin(),ysorted.end());\n    for(int i = 0; i < n; i++){\n      xsortedIdxs[xsorted[i].second]=i;\n      ysortedIdxs[ysorted[i].second]=i;\n    }\n    double minDist=INF;\n    for(int i = 0; i < n; i++){\n      // x,zÀW»ê¼êÉÂ¢ÄA\n      // ©ªÌê©ç-10,+10ÌÆ±ëðTõ\n      int xsidx=xsortedIdxs[i];\n      int ysidx=ysortedIdxs[i];\n      for(int j = xsidx; j < min(xsidx+band,n);j++){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = xsidx; j >= max(0,xsidx-band); j--){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j < min(ysidx+band,n);j++){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j >= max(0,ysidx-band); j--){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n    }\n    printf(\"%.8f\\n\",minDist);\n    //cout<<minDist<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    double ret = sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n    if ( ret<0)ret=0;\n    return ret;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) < min_val+2*maxr){\n      tarray[p++]=a[i];\n    }\n  }\n  rep(i,p){\n    REP(j,i+1,p && abs(tarray[j].y-tarray[i].y)<2*maxr+min_val){\n      min_val=min(min_val,tarray[j].dist(a[i]));\n    }\n  }\n\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define MAX_N (2000010)\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nstruct Circle\n{\n  P p; double r;\n  Circle(P p=P(0,0), double r=0.)\n    : p(p), r(r) {}\n};\n\nbool operator < (Circle const& a, Circle const& b) {\n  return a.p.real() < b.p.real();\n}\n\nbool compare_y(Circle const& a, Circle const& b) {\n  return a.p.imag() < b.p.imag();\n}\n\nint N;\nCircle A[MAX_N];\ndouble MaxR;\n\ndouble const INF = 1e60;\n\ninline double calc(Circle const& a, Circle const& b) {\n  double x = a.p.real()-b.p.real();\n  double y = a.p.imag()-b.p.imag();\n  return sqrt(x*x + y*y) - a.r - b.r;\n}\n\ndouble circle_closest_pair(Circle *a, int n) {\n  if(n <= 1) return INF;\n  int mid = n / 2;\n  double delta = min(circle_closest_pair(a, mid),\n\t\t     circle_closest_pair(a+mid, n-mid));\n  \n  //  delta += MaxR*2;\n  \n  // inplace_merge(BidirectionalIterator first, middle, last, Compare cmp);\n  inplace_merge(a, a+mid, a+n, compare_y);\n  \n  // merge\n  vector<Circle> b; // <- circles < delta\n  rep(i, n) {\n    double mid_x = a[mid].p.real();\n    if(abs(a[i].p.real()-mid_x) >= delta - 2.*MaxR) { continue; }\n    \n    rep(j, b.size()) {\n      int bid = (int)b.size()-1-j;\n      double dy = a[i].p.imag() - b[bid].p.imag();\n      if(delta + 2.*MaxR <= dy) { break; }\n      delta = min(delta, calc(a[i], b[bid]));\n    }\n    b.push_back(a[i]);\n  }\n  \n  return delta;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    MaxR = 0.;\n    rep(i, N) {\n      //      cin >> A[i].r >> A[i].p.real() >> A[i].p.imag();\n      double x, y, r; cin >> r >> x >> y;\n      A[i].p = P(x, y); A[i].r = r;\n      MaxR = max(MaxR, A[i].r);\n    }\n    sort(A, A+N);\n    printf(\"%.8f\\n\", circle_closest_pair(A, N));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n\ndouble circle[100001][3];\n\ndouble distance(i,j){\nreturn sqrt((circle[i][0]-circle[j][0])*(circle[i][0]-circle[j][0])+(circle[i][1]-circle[j][1])*(circle[i][1]-circle[j][1]))\n-circle[i][2]-circle[j][2];\n}\n\nint main(){\n\tint n,i,j;\ndouble min;\n\nwhile(0<=scanf(\"%d\",&n)){\nif(n==0)break;\n\nfor(i=0;i<n;i++){\nscanf(\"%lf%lf%lf\",&circle[i][2],&circle[i][1],&circle[i][0]);\n}\nmin=distance(0,1);\nfor(i=0;i<n-1;i++){\nfor(j=i+1;j<n;j++){\nif(min>distance(i,j))min=distance(i,j);\n}\n}\nprintf(\"%lf\\n\",min);\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nconst int DIFF = 2000;\n\nstruct Circle{\n  double x,y,r;\n  bool operator < (const Circle& c) const{\n    return sqrt(x*x+y*y) < sqrt(c.x*c.x+c.y*c.y);\n  }\n};\n\ndouble dist(const Circle& c1, const Circle& c2){\n  return sqrt((c1.x-c2.x)*(c1.x-c2.x) + (c1.y-c2.y)*(c1.y-c2.y))-c1.r-c2.r;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<Circle> V(n);\n    for(int i = 0; i < n; i++) cin >> V[i].r >> V[i].x >> V[i].y;\n    \n    double ans = 1e50;\n\n    for(int i = 0; i < n; i++)\n      for(int j = max(0,i-DIFF); j < min(n, i+DIFF); j++){\n\tif(i == j) continue;\n\tans = min(ans,dist(V[i],V[j]));\n      }\n   \n    printf(\"%.5f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = max(0,i-300) ; j < min(i+300,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = max(0,i-300) ; j < min(i+300,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<29\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\nP p[1000000];\n\nbool cmp_y(P a,P b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if( (a[i].F.F+a[i].S)-(x-r)  >= d)continue;\n    }\n    else{\n      if( (x+r)-(a[i].F.F+a[i].S) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S)  >= d )break;\n      }\n      else{\n\tif((a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S) >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int N;\n  double R,X,Y;\n\n  while(cin >> N && N){\n    for(int i=0;i<N;i++){\n      cin >> p[i].S >> p[i].F.F >> p[i].F.S;\n    }\n    sort(p,p+N);\n    printf(\"%.6f\\n\",rec(p,N));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  //return a.o.imag() - a.r < b.o.imag() - b.r;\n  return a.o.imag() < b.o.imag();\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max((double)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble valM;\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    bool f = false;\n    if(x > a[i].o.real()){\n      if(x <= a[i].o.real() + a[i].r) f = true;\n      if(x - a[i].o.real() + a[i].r - valM < d) f = true;\n    }else{\n      if(a[i].o.real() - a[i].r <= x) f = true;\n      if(a[i].o.real() - a[i].r - x - valM < d) f = true;\n    }\n    if(!f) continue;\n    //if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(dy >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    valM = 0.0;\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n      valM = max(valM, c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    //cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  //return a.o.imag() - a.r < b.o.imag() - b.r;\n  return a.o.imag() < b.o.imag();\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max((double)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble valM;\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    bool f = false;\n    if(x > a[i].o.real()){\n      if(a[i].o.real() <= x && x <= a[i].o.real() + a[i].r) f = true;\n      if(fabs(a[i].o.real() + a[i].r - x)) f = true;\n    }else{\n      if(a[i].o.real() - a[i].r <= x && x <= a[i].o.real()) f = true;\n      if(fabs(a[i].o.real() - a[i].r - x)) f = true;\n    }\n    if(!f) continue;\n    //if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(dy >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    //cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle{\n\tdouble x,y,r;\n\tbool operator < (const Circle &)const;\n};\n\nbool Circle::operator < (const Circle &a)const{\n\treturn (x*x+y*y)<(a.x*a.x+a.y*a.y);\n}\n\ndouble dist(const Circle &a,const Circle &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))-a.r-b.r;\n}\n\nconst int MAX_N=100000;\n\nint N;\nCircle c[MAX_N];\n\nvector<double> out;\n\nint main(){\n\tdo{\n\t\tscanf(\"%d\",&N);\n\t\tif (N){\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tscanf(\"%lf %lf %lf\",&c[i].r,&c[i].x,&c[i].y);\n\t\t\t}\n\t\t\tsort(c,c+N);\n\t\t\tdouble ans=1e50;\n\t\t\tprintf(\"%.8f\\n\",ans);\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tfor (int j=i+1;j<min(N,i+5001);j++){\n\t\t\t\t\tans=min(ans,dist(c[i],c[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.push_back(ans);\n\t\t}\n\t}while(N);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%.12f\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst double INF = 1e+12;\n\ndouble equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nstruct C{\n  P p;\n  double r;\n  C(P p=P(0,0),double r=0.0):p(p),r(r){}\n  bool operator < (const C &c) const {\n    return equal(real(p),real(c.p)) ? imag(p) < imag(c.p) : real(p) < real(c.p);\n  }\n};\n\n\nC v[100000];\n\nbool compare_y(C a, C b){\n  return imag(a.p) < imag(b.p);\n}\n\ndouble closest(C a[], int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double x = real(a[m].p);\n  double d = min(closest(a,m), closest(a+m,n-m));\n  inplace_merge(a, a+m, a+n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(real(a[i].p) - x) >= d || equal(fabs(real(a[i].p) - x),d)) continue;\n\n    for(int j=0;j<b.size();j++){\n      C bc = b[b.size()-j-1];\n      if(imag(a[i].p-bc.p) >= d || equal(imag(a[i].p-bc.p),d)) break;\n      //cout << a[i].p << ' ' << bc.p << endl;\n      d = min(d, abs(a[i].p-bc.p) - a[i].r - bc.r);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> v[i].r >> x >> y;\n      v[i].p = P(x,y);\n    }\n    sort(v,v+n);\n    printf(\"%f\\n\",closest(v,n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <random>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\ntypedef pair<double, double> P;\nstruct C{\n    P p;\n    double r;\n};\nbool operator < (const C& c, const C& d){\n    return (c.p.first - c.r) < (d.p.first - d.r);\n}\ninline double sq(double x) { return x * x; }\ndouble dist(const C& c, const C& d){\n    return sqrt(sq(c.p.first - d.p.first) + sq(c.p.second - d.p.second)) - c.r - d.r;\n}\n\nint main(){\n    auto rand = bind(uniform_real_distribution<double>(0, 2.0 * M_PI), mt19937(0));\n\n    for(int N; cin >> N && N;){\n        vector<C> cs(N);\n        for(auto& c : cs) cin >> c.r >> c.p.first >> c.p.second;\n\n        double th = rand();\n        for(auto& c : cs){\n            double nx = c.p.first * cos(th) + c.p.second * sin(th);\n            double ny = c.p.first * -sin(th) + c.p.second * cos(th);\n            c.p.first = nx, c.p.second = ny;\n        }\n\n        sort(cs.begin(), cs.end());\n        double ans = 1e63;\n        for(int i = 0; i < N; i++){\n            const C& c = cs[i];\n            for(int j = i + 1; j < N; j++){\n                const C& d = cs[j];\n                if(c.p.first + c.r + ans < c.p.second - c.r) break;\n                ans = min(ans, dist(c, d));\n            }\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <random>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\ntypedef pair<double, double> P;\nstruct C{\n    P p;\n    double r;\n};\nbool operator < (const C& c, const C& d){\n    return (c.p.first - c.r) < (d.p.first - d.r);\n}\ninline double sq(double x) { return x * x; }\ndouble dist(const C& c, const C& d){\n    return sqrt(sq(c.p.first - d.p.first) + sq(c.p.second - d.p.second)) - c.r - d.r;\n}\n\nint main(){\n    auto rand = bind(uniform_real_distribution<double>(0, 2.0 * M_PI), mt19937(0));\n\n    for(int N; cin >> N && N;){\n        vector<C> cs(N);\n        for(auto& c : cs) cin >> c.r >> c.p.first >> c.p.second;\n\n        double th = rand();\n        for(auto& c : cs){\n            double nx = c.p.first * cos(th) + c.p.second * sin(th);\n            double ny = c.p.first * -sin(th) + c.p.second * cos(th);\n            c.p.first = nx, c.p.second = ny;\n        }\n\n        sort(cs.begin(), cs.end());\n        double ans = 1e63;\n        for(int i = 0; i < N; i++){\n            const C& c = cs[i];\n            for(int j = i + 1; j < N; j++){\n                const C& d = cs[j];\n                if(c.p.first + c.r + ans < c.p.second - c.r) break;\n                ans = min(ans, dist(c, d));\n            }\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\ndouble max_r;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){ //基準線より中心が左\n\t\tif(info[index].x+info[index].r+dist < x-2*max_r){ //★★中心線より反対側に円がはみ出す場合がある\n\t\t\treturn false;\n\t\t}\n\n\t}else{ //基準線より中心が右\n\t\tif(info[index].x-info[index].r-dist > x+2*max_r){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線\n\tdouble r = array[mid].r; //半径\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\t//if(!is_OK(i,x,dist))continue; //異なる領域間での、新最小値を作り得ない場合は無視\n\t\tif(fabs(info[i].x-x)-(info[i].r+r) >= dist)continue;\n\n\t\tleft = 0,right = V.size()-1,m = (left+right)/2;\n\t\tsearch_left = V.size()-1;\n\n\t\t//Vはy座標の昇順にpushされている→自分よりy座標が小さいもののみが入っている\n\t\twhile(left <= right){\n\t\t\tif((info[i].y-info[i].r)-(info[m].y+info[m].r) < dist){ //y座標の差がdist未満の場合\n\t\t\t\tsearch_left = m;\n\t\t\t\tright = m-1; //より左へ\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\t//for(int k = search_left; k < V.size(); k++){\n\t\tfor(int k = 0; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tmax_r = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t\tmax_r = max(max_r,info[i].r);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nconst int DIFF = 5000;\n\nstruct Circle{\n  double x,y,r;\n  bool operator < (const Circle& c) const{\n    return sqrt(x*x+y*y) < sqrt(c.x*c.x+c.y*c.y);\n  }\n};\n\ndouble dist(const Circle& c1, const Circle& c2){\n  return sqrt((c1.x-c2.x)*(c1.x-c2.x) + (c1.y-c2.y)*(c1.y-c2.y))-c1.r-c2.r;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<Circle> V(n);\n    for(int i = 0; i < n; i++) cin >> V[i].r >> V[i].x >> V[i].y;\n    \n    double ans = 1e50;\n\n    for(int i = 0; i < n; i++)\n      for(int j = max(0,i-DIFF); j < min(n, i+DIFF); j++){\n\tif(i == j) continue;\n\tans = min(ans,dist(V[i],V[j]));\n      }\n   \n    printf(\"%.5f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst long double EPS = 1e-10;\nconst int MAX_N = 100000;\nconst long double INF = 100000000000000000.0;\n\nbool equal(long double a, long double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   long double x, y, r;\n   Circle(){}\n   Circle(long double y, long double x, long double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\nlong double closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   long double x = a[m].x;\n   long double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) > d + a[i].r || equal(fabs(a[i].x - x), d+a[i].r)) continue;\n      for(int j=0;j<b.size();j++){\n         long double dx = a[i].x - b[b.size()-j-1].x;\n         long double dy = a[i].y - b[b.size()-j-1].y;\n         long double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy > d + dr || equal(dy, d+dr)) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-6;\nconst int MAX_N = 100000;\nconst double INF = 100000000.0;\n\nbool equal(double a, double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   double x, y, r;\n   Circle(){}\n   Circle(double y, double x, double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   if(equal(a.y, b.y)){\n      return a.r > b.r;\n   }\n   return a.y < b.y;\n}\n\ndouble closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   double x = a[m].x;\n   double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) > d + a[i].r || equal(fabs(a[i].x - x), d+a[i].r)) continue;\n      for(int j=0;j<b.size();j++){\n         double dx = a[i].x - b[b.size()-j-1].x;\n         double dy = a[i].y - b[b.size()-j-1].y;\n         double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy > d + dr || equal(dy, d+dr)) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      fill(A, A+N, Circle(INF, INF, INF));\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  //return a.o.imag() - a.r < b.o.imag() - b.r;\n  return a.o.imag() < b.o.imag();\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max((double)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble valM;\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    bool f = false;\n    if(a[i].o.real() < x){\n      if(!(x > a[i].o.real() + a[i].r)) f = true;\n      if(x - a[i].o.real() - a[i].r - valM < d) f = true;\n    }else{ // x < a[i].o.real()\n      if(!(a[i].o.real() - a[i].r > x)) f = true;\n      if(a[i].o.real() - a[i].r - x - valM < d) f = true;\n    }\n    if(!f) continue;\n    //if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(dy >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    valM = 0.0;\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n      valM = max(valM, c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    //cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst long double EPS = 1e-8;\nconst int MAX_N = 100000;\nconst long double INF = 1000000000000000.0;\n\nbool equal(long double a, long double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   long double x, y, r;\n   Circle(){}\n   Circle(long double y, long double x, long double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\nlong double closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   long double x = a[m].x;\n   long double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) >= d + a[i].r) continue;\n      for(int j=0;j<b.size();j++){\n         long double dx = a[i].x - b[b.size()-j-1].x;\n         long double dy = a[i].y - b[b.size()-j-1].y;\n         long double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy >= d + dr) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  Point p1,p2,p3,p4,p5;\n  p1=p2=p3=p4=p5=BigPoint;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) < min_val+2*maxr){\n      min_val=min(min_val,a[i].dist(p1));\n      min_val=min(min_val,a[i].dist(p2));\n      min_val=min(min_val,a[i].dist(p3));\n      min_val=min(min_val,a[i].dist(p4));\n      min_val=min(min_val,a[i].dist(p5));\n      p1=p2;p2=p3;p3=p4;p4=p5;p5=a[i];\n    }\n  }\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = i+1 ; j < min(i+25,n) ; j++){\n\t\t\t\tans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = i+1 ; j < min(i+25,n) ; j++){\n\t\t\t\tans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f%c\",ans,10);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<pair<double,double>,double> data;\n\ntemplate<class T> inline T dbl(T a){ return a * a; }\n\ninline double dist(const data &a, const data &b){\n  return sqrt(dbl(a.f.f - b.f.f) + dbl(a.f.s - b.f.s)) - (a.s + b.s);\n}\n\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n), n){\n    vector<data> v(n);\n\n    REP(i,n)\n      scanf(\"%lf%lf%lf\", &v[i].s, &v[i].f.s, &v[i].f.f);\n\n    sort(v.begin(), v.end());\n\n    double ans = 1e20;\n    double r  = 0.0; REP(i,n) r = max(r, v[i].s); r *= 2;\n\n    for(int i = 0; i < n; i++){\n      double x1 = v[i].f.f;\n      for(int j = i + 1; j < n; j++){\n\tdouble x2 = v[j].f.f;\n\n\tif((x2 - x1 - r) > ans) break;\n\n\tans = min(ans, dist(v[i], v[j]));\n      }\n    }\n    \n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = max(0,i-25) ; j < min(i+25,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = max(0,i-25) ; j < min(i+25,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f%c\",ans,10);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) <1e-5+ min_val+2*maxr){\n      for(int j=p-1;j>=0 && abs(tarray[j].y-a[i].y)<1e-5+2*maxr+min_val;j--){\n\tmin_val=min(tarray[j].dist(a[i]),min_val);\n      }\n      tarray[p++]=a[i];\n    }\n  }\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n    Point rotate(double theta) const{\n        return Point(x * sin(theta) + y * cos(theta), x * cos(theta) - y * sin(theta));\n    }\n    bool operator< (const Point& p) const{\n        return x < p.x;\n    }\n};\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<pair<Point, double> > v(n);\n        for(int i=0; i<n; ++i)\n            cin >> v[i].second >> v[i].first.x >> v[i].first.y;\n\n        double ret = DBL_MAX;\n        for(int i=0; i<30; ++i){\n            sort(v.begin(), v.end());\n            for(int j=1; j<n; ++j)\n                ret = min(ret, v[j].first.dist(v[j-1].first) - v[j].second - v[j-1].second);\n            for(int j=0; j<n; ++j)\n                v[j].first = v[j].first.rotate(2*PI/100);\n        }\n        printf(\"%.10f\\n\", ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define EPS 1e-8\n#define PI acos(-1)\n#define Vector Point\n\nstruct Point\n{\n    double x, y, r;\n    Point(){}\n    Point(double a, double b, double c) { x = a; y = b; r = c; }\n    double mod2() { return x*x + y*y; }\n    double mod()  { return sqrt(x*x + y*y); }\n};\n\nbool operator ==(const Point &a, const Point &b)\n{\n    return fabs(a.x - b.x) < EPS && fabs(a.y - b.y) < EPS;\n}\nbool operator !=(const Point &a, const Point &b)\n{\n    return !(a==b);\n}\nbool operator <(const Point &a, const Point &b)\n{\n    if(a.x != b.x) return a.x < b.x;\n    return a.y < b.y;\n}\n\nbool XYorder(Point P1, Point P2)\n{\n\tif(P1.x != P2.x) return P1.x < P2.x;\n\treturn P1.y < P2.y;\n}\nbool YXorder(Point P1, Point P2)\n{\n\tif(P1.y != P2.y) return P1.y < P2.y;\n\treturn P1.x < P2.x;\n}\n\ndouble dist(const Point &A, const Point &B)\n{\n\treturn hypot(A.x - B.x, A.y - B.y) - A.r - B.r;\n}\n\ndouble R;\n\ndouble closest_recursive(vector <Point> vx, vector <Point> vy)\n{\n\tif(vx.size()==1) return 1e20;\n\tif(vx.size()==2) return dist(vx[0], vx[1]);\n\t\n\tPoint cut = vx[vx.size()/2];\n\t\n\tvector <Point> vxL, vxR;\n\tfor(int i=0; i<vx.size(); i++)\n\t\tif(vx[i].x < cut.x || (vx[i].x == cut.x && vx[i].y <= cut.y))\n\t\t\tvxL.push_back(vx[i]);\n\t\telse vxR.push_back(vx[i]);\n\t\n\tvector <Point> vyL, vyR;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(vy[i].x < cut.x || (vy[i].x == cut.x && vy[i].y <= cut.y))\n\t\t\tvyL.push_back(vy[i]);\n\t\telse vyR.push_back(vy[i]);\n\t\n\tdouble dL = closest_recursive(vxL, vyL);\n\tdouble dR = closest_recursive(vxR, vyR);\n\tdouble d = min(dL, dR);\n\t\n\tvector <Point> b;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(abs(vy[i].x - cut.x) <= d + 2*R)\n\t\t\tb.push_back(vy[i]);\n\t\n\tfor(int i=0; i<b.size(); i++)\n\t\tfor(int j=i+1; j<b.size() && (b[j].y - b[i].y) <= d + 2*R; j++)\n\t\t\td = min(d, dist(b[i], b[j]));\n\t\n\treturn d;\n}\ndouble closest(vector <Point> points)\n{\n\tvector <Point> vx = points, vy = points;\n\tsort(vx.begin(), vx.end(), XYorder);\n\tsort(vy.begin(), vy.end(), YXorder);\n\treturn closest_recursive(vx,vy);\n}\n\nint main()\n{\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tif(n == 0) break;\n\t\tR = 0;\n\t\t\n\t\tvector <Point> P(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin>>P[i].r>>P[i].x>>P[i].y;\n\t\t\tR = max(R, P[i].r);\n\t\t}\n\t\tcout<<closest(P)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-6)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tdouble r;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\n// \tVerified: AOJ 0081 A Symmetric Point\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t三角形の面積（外積）\n\n\t説明\n\t\t三頂点で定まる三角形の面積（の２倍）を求める\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n*/\ntemplate<class T>\nT area2(const point<T> &a, const point<T> &b, const point<T> &c ){\n\treturn abs(cross(b-a,c-a));\n}\n/*\n\t三角形の面積（Heron）\n\n\t説明\n\t\t三辺の長さで定まる三角形の面積を求める\n\t引数\n\t\ta : 一辺の長さ\n\t\tb : 一辺の長さ\n\t\tc : 一辺の長さ\n\t戻り値\n\t\t三角形の面積\n\t\t三角形が作れないとき、縮退しているときには 0\n\t制約\n\t\ta>=0, b>=0, c>=0\n\t\ta<b+c, b<c+a, c<a+b（三角形の成立条件）\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble area(double a, double b, double c ){\n\treturn sqrt((a+b-c)*(b+c-a)*(c+a-b)*(a+b-c))/4.;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079: Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n// (B)\n\n//enum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t線分と線分の距離\n*/\n\n/*\n\t三角形と点の包含判定\n\n\t説明\n\t\t三角形 abc が点 p を含むかどうかを判定する\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\t三角形は縮退していないこと\n\t\tすなわち、三点が同一直線上にないこと、（特に、どの二点も等しくないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形は CCW でも CW でもよい\n\t\t点が三角形の境界になるときは含むと判定する\n\t\tVerified: AOJ 0012: A Point in a Triangle\n\t\tVerified: AOJ 0143: Altair and Vega \n*/\ntemplate<class T>\nbool cover(const point<T> &a, const point<T> &b, const point<T> &c, const point<T> &p ){\n\tint d1 = ccw (p, a, b );\n\tint d2 = ccw (p, b, c );\n\tint d3 = ccw (p, c, a );\n\treturn !((d1 == CCW && d2 == CW ) || (d1 == CCW && d3 == CW ) || (d2 == CCW && d3 == CW ) || (d1 == CW && d2 == CCW ) || (d1 == CW && d3 == CCW ) || (d2 == CW && d3 == CCW ) );\n}\n\n/*\n\t直線と点の包含判定\n*/\n\n/*\n\t線分と点の包含判定\n*/\n\n/*\n\t多角形と点の包含判定\n*/\n\n/*\n\t多角形と多角形の包含判定\n*/\n\n/*\n\t円と点の包含判定\n\n\t説明\n\t\t円が点を含むかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tp : 点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\n// (A)\ntemplate<class T>\nbool cover (const circle<T> &C, const point<T> &p ){\n\treturn dist2(C.c, p) <= C.r*C.r;\n}\n\n// (B)\nbool cover (const circle<double> &C, const point<double> &p ){\n\treturn dist (C.c, p ) < C.r + EPS;\n}\n\n/*\n\t直線と直線の交差判定\n*/\n\n/*\n\t直線と線分の交差判定\n*/\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t多角形と線分の交差判定\n\n\t説明\n\t\t多角形と線分が交わるかどうかを判定する\n\t引数\n\t\tG : 多角形\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n)\n\t備考\n\t\tG は凸でなくていい。\n\t\tG は境界を含む\n\t\tS が G の内部にあるときは交わると判定する\n*/\ntemplate<class T>\nbool intersect(const polygon<T> &G, const segment<T> &S ){\n\tint n = G.size();\n\tif (cover(G, S.a ) || cover (G, S.b ) ) return true;\n\trep (i, n ) if (intersect((segment<T>){G[i], G[(i+1)%n]}, S ) ) return true;\n\treturn false;\n}\n\n/*\n\t多角形と多角形の交差判定\n*/\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\n/*\n\t二直線の交点\n\n\t説明\n\t\t二直線の交点を求める\n\t\t(A)（直線を特徴付ける点の）座標値が整数\n\t\t(B)（直線を特徴付ける点の）座標値が実数\n\t引数\n\t\tL1 : 直線\n\t\tL2 : 直線\n\t戻り値\n\t\tL1 と L2 の交点\n\t制約\n\t\t二直線は交点を持つこと。（平行でない or L1 == L2 )\n\t計算量\n\t\tO(1)\n\t備考\n\t\t交点が複数あるとき（L1 == L2）は L1.a を返す。\n\t\tこの仕様は線分 S と直線 L の交点を求めたいとき重要。\n\t\t（ S と L が同一直線上にあるときにも、S を第１引数に指定することで交点が正しく求まる。）\n\n*/\n// (A)\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1, const line<T> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1==0) return L1.a;\t// L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n// (B)\npoint<double> get_intersect(const line<double> &L1, const line<double> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1<EPS) return L1.a;\t// L1 == L2\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n/*\n\t二線分の交点\n*/\n\n/*\n\t円と直線の交点\n*/\n\n/*\n\t円と円の交点\n\n\t説明\n\t\t円と円の交点を求める\n\t引数\n\t\tC1 : 円\n\t\tC2 : 円\n\t\tres : 計算結果（交点の集合）\n\t戻り値\n\t\t交点の個数\n\t\tただし、交点が無限個になる（２つの円が等しい）ときは -1\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tres は初期化されない\n\t\t交点が無限個あるときは res には何も追加されない\n\t\tVerified: AOJ 0090 Overlaps of Seals\n*/\nint get_intersect(const circle<double> &C1, const circle<double> &C2, vector< point<double> > &res ){\n\tdouble r1=C1.r,r2=C2.r;\n\tpoint<double> p1=C1.c,p2=C2.c;\n\n\tdouble d=abs(p1-p2);\n\tif (d<EPS && abs(r1-r2)<EPS ){\t// C1 == C2\n\t\treturn -1;\n\t}else\n\tif (r1+r2<d-EPS || d+EPS<abs(r1-r2) ){\n\t\treturn 0;\n\t}else{\n\t\tdouble a = (r1*r1-r2*r2+d*d)/(2.*d);\n\t\tdouble h = sqrt(max(r1*r1-a*a, 0. ) );\n\t\tpoint<double> tmp1 = p1+a/d*(p2-p1);\n\t\tpoint<double> tmp2 = h/d*(p2-p1);\n\t\tif (abs(tmp2)<EPS ){\n\t\t\tres.push_back (tmp1 );\n\t\t\treturn 1;\n\t\t}else{\n\t\t\tres.push_back ((point<double>){tmp1.x-tmp2.y, tmp1.y+tmp2.x});\n\t\t\tres.push_back ((point<double>){tmp1.x+tmp2.y, tmp1.y-tmp2.x});\n\t\t\treturn 2;\n\t\t} // end if\n\t} // end if\n}\n\n/*\n\t点から円に引いた接線の交点\n*/\n\n/*\n\t円と円の共通接線\n*/\n\n/*\n\t垂直二等分線\n\n\t説明\n\t\t二点 a, b の垂直二等分線を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\ta と b の垂直二等分線\n\t計算量\n\t\tO(1)\n\t備考\n\t\t垂直二等分線を L とすると、L.a から L.b の方向を見たとき、左手に点 a が来る。\n*/\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a, const point<T> &b ){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0, (a.y+a.x+b.y-b.x)/2.0 },\n\t\t\t\t\t\t\t(point<double>){(a.x+a.y+b.x-b.y)/2.0, (a.y-a.x+b.y+b.x)/2.0 }};\n}\n\n/*\n\t点対称\n\n\t説明\n\t\t点 b を基準に点 a を点対称を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点対称の点\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\npoint<T> symmetry_point (const point<T> a, const point<T> b )\n{\n\treturn (point<T>){2*b.x-a.x, 2*b.y-a.y};\n}\n\n/*\n\t多角形の重心の座標\n\n\t説明\n\t\t頂点数 n の凸多角形をひとつの頂点を基準に n - 2 個の三角形に分割した三角形の面積を Sk,\n\t\t重心を gk とおくと n の凸多角形の重心 G は\n\n\t\tG = \\sum_{k=1}^{n-2}Sk*gk/(\\sum_{k=1}^{n-2}Sk)\n\n\t\tで求められる。\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t点\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 2442: ConvexCut しかし EPS=1e-6 にしないと WA.\n*/\ntemplate<class T>\npoint<T> centerG(const polygon<T> &G ){\n\tint n = G.size();\n\tdouble S = 0.;\n\tpoint<double> g; g.x = 0.; g.y = 0.;\n\tint u = G.size()-1;\n\tfor (int i = 0; i < n; u=i++ ){\n\t\tdouble sk = cross (G[u], G[i] );\n\t\tS += sk;\n\t\tg.x += (G[u].x + G[i].x)*sk;\n\t\tg.y += (G[u].y + G[i].y)*sk;\n\t} // end for\n\tg /= (3.*S);\n\n\treturn g;\n/*\n\tint n = G.size();\n\tdouble ar = 0.;\n\tdouble x = 0., y = 0.;\n\trep (i, n - 2 ){\n\t\tdouble k = area2 (G[n-1], G[i], G[i+1] );\n\t\tar += k;\n\t\tx += (G[n-1].x + G[i].x)*k;\n\t\ty += (G[n-1].y + G[i].y)*k;\n\t} // end rep\n\tx /= (3.*ar );\n\ty /= (3.*ar );\n\t\n\treturn (point<T>){x,y};\n*/\n}\n\n/*\n\t二点と半径で定まる円\n*/\n\n/*\n\t凸性判定\n\t\n\t説明\n\t\t多角形が凸かどうかを判定する\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tG は単調かつ頂点の順番が CCW で与えられていること\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\ntemplate<class T>\nbool is_convex(const polygon<T> &G ){\n\tint n = G.size();\n\trep (i, n ) if (ccw (G[i], G[(i+1)%n], G[(i+2)%n])== CW ) return false;\n\treturn true;\n}\n\n/*\n\t凸包\n\n\t説明\n\t\t点集合の凸包を求める\n\t引数\n\t\tP : 点集合\n\t戻り値\n\t\tP の凸包\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n log n )\n\t備考\n\t\tP は破壊される。\n\n\t\tsort は (x, y ) の辞書順。\n\n\t\t凸包の同じ直線上にある頂点は端のものだけを拾う。\n\t\t辺上になる頂点を全部拾うようにしたいときは != CCW を ==CW と修正すればよい。\n*/\ntemplate<class T>\npolygon<T> convex_hull(vector< point<T> > &P ){\n\tint n = P.size();\n\tpolygon<T> CH;\n\tif (n <= 1 ){\n\t\tCH.insert (CH.end(), P.begin(), P.end() );\n\t\treturn CH;\n\t} // end if\n\tsort (ALL (P ) );\n\trep (cnt, 2 ){\n\t\tint m = 0;\n\t\tvector< point<T> > half(n );\n\t\trep (i, n ){\n\t\t\thalf[m++] = P[i];\n\t\t\twhile (m >= 3 && ccw (half[m-3], half[m-2], half[m-1] ) != CCW ){\n\t\t\t\thalf[m-2] = half[m-1];\n\t\t\t\tm--;\n\t\t\t} // end while\n\t\t} // end rep\n\t\tCH.insert (CH.end(), half.begin(), half.begin()+m-1 );\n\t\treverse (ALL (P ) );\n\t} // end rep\n\t\n\treturn CH;\n}\n\n/*\n\t凸多角形の切断\n*/\n\n/*\n\t内接円の半径\n\n\t説明\n\t\t辺長がそれぞれ、a, b, c である三角形の内接円の半径を求める\n\t引数\n\t\ta: 辺長\n\t\tb: 辺長\n\t\tc: 辺長\n\t戻り値\n\t\t内接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, c < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble inradius(double a, double b, double c ){\n\treturn sqrt ((b+c-a)*(c+a-b)*(a+b-c)/(a+b+c))/2.;\n}\n\n/*\n\t外接円\n\n\t説明\n\t\t三角形 abc の外接円を求める\n\t引数\n\t\ta: 頂点\n\t\tb: 頂点\n\t\tc: 頂点\n\t戻り値\n\t\t外接円\n\t制約\n\t\ta, b, c は同一直線上にないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\ta, b, c が同一直線上にあるときは外接円は存在しない\n\t\t頂点が整数座標のとき、外心の座標と半径の二乗は有理数となる\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ncircle<double> circumcircle(const point<double> &a, point<double> b, point<double> c ){\n\tb-=a; c-=a;\n\tdouble A2 = abs2(b-c), B2 = abs2(b), C2 = abs2(c);\n\tdouble d = 2*cross(b,c);\n\tdouble nx = c.y*B2-b.y*C2;\n\tdouble ny = b.x*C2-c.x*B2;\n\tdouble r2 = A2*B2*C2/(d*d);\n\treturn (circle<double>){a+(point<double>){nx/d, ny/d}, sqrt(r2)};\n}\n\n/*\n\t外接円の半径\n\t\n\t説明\n\t\t辺長がそれぞれ a, b, c である三角形の外接円の半径を求める\n\t引数\n\t\ta : 辺長\n\t\tb : 辺長\n\t\tc : 辺長\n\t戻り値\n\t\t外接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, b < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ndouble circumradius(double a, double b, double c ){\n\treturn a*b*c/sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c) );\n}\n\n/*\n\t最小包含球\n*/\n\n/*\n\t線分アレンジメント\n*/\n\n/*\n\t最近点対\n\n\t説明\n\t\t最近点対問題を解く\n\t引数\n\t\tn : 点の個数\n\t\tp : 点集合\n\t戻り値\n\t\t最近点対の距離\n\t制約\n\t\tn>=2\n\t計算量\n\t\tO(n log n)\n\t備考\n\t\tsort は (x,y) の辞書順。\n\t\tP の順番は破壊される（内部でソートするため）\n*/\nstruct cmp_y{\nbool operator()(const point<double> &a, const point<double> &b ){\n\treturn (a.y+EPS<b.y || (abs(a.y-b.y)<EPS && a.x+EPS<b.x ) );\n}};\n\n\ndouble closest_pair(int n, point<double> *P ){\n\tdouble r_max = 0.;\n\trep (i, n ) r_max = max (r_max, P[i].r );\n\tsort (P, P+n );\n\tdouble d = dist(P[0],P[1] ) - P[0].r - P[1].r;\n\tset<point<double>, cmp_y> S;\n\tset<point<double>, cmp_y>::iterator it_l, it_r, it;\n\tfor (int i = 0, j = 0; i < n; i++ ){\n\t\tit_l = S.lower_bound ((point<double>){0,P[i].y-d-1.-2.*r_max});\n\t\tit_r = S.upper_bound ((point<double>){0,P[i].y+d+1.+2.*r_max});\n\t\tfor (it=it_l;it!=it_r;++it) d=min(d, dist(*it,P[i])-(it->r)-P[i].r);\n\t\twhile(P[i].x-P[j].x>d+2.*r_max+EPS ) S.erase(P[j++] );\n\t\tS.insert(P[i] );\n\t} // end for\n\n\treturn d;\n}\n\n/*\n\t楕円の周長\n*/\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.2057\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tstatic point<double> p[(int)1e5+5];\n\t\trep (i, n ) scanf (\"%lf %lf %lf\",&p[i].r, &p[i].x, &p[i].y );\n\t\tdouble res = closest_pair(n, p );\n\t\tprintf (\"%.5lf\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = max(0,i-50) ; j < min(i+50,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = max(0,i-50) ; j < min(i+50,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f%c\",ans,10);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\n\ntemplate<typename T>\nvoid chmin(T &a,T b){if(a>b) a=b;}\ntemplate<typename T>\nvoid chmax(T &a,T b){if(a<b) a=b;}\n\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    vector<Circle> v(n);\n    for(int i=0;i<n;i++) cin>>v[i].r>>v[i].c;\n    auto calc=[](Circle a,Circle b){\n      return abs(a.c-b.c)-(a.r+b.r);\n    };\n    double ans=calc(v[0],v[1]);\n    for(int k=0;k<10;k++){\n      sort(v.begin(),v.end(),[](Circle a,Circle b){return sort_x(a.c,b.c);});\n      for(int i=0;i<n-1;i++) chmin(ans,calc(v[i],v[i+1]));\n      sort(v.begin(),v.end(),[](Circle a,Circle b){return sort_y(a.c,b.c);});\n      for(int i=0;i<n-1;i++) chmin(ans,calc(v[i],v[i+1]));\n      for(int i=0;i<n;i++) v[i].c=translate(v[i].c,PI/100);\n    }\n    cout<<fixed<<setprecision(12)<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nconst int DIFF = 2000;\n\nstruct Circle{\n  double x,y,r;\n  bool operator < (const Circle& c) const{\n    return sqrt(x*x+y*y) < sqrt(c.x*c.x+c.y*c.y);\n  }\n};\n\ndouble dist(const Circle& c1, const Circle& c2){\n  return sqrt((c1.x-c2.x)*(c1.x-c2.x) + (c1.y-c2.y)*(c1.y-c2.y))-c1.r-c2.r;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<Circle> V(n);\n    for(int i = 0; i < n; i++) cin >> V[i].r >> V[i].x >> V[i].y;\n    \n    sort(V.begin(),V.end());\n\n    double ans = 1e50;\n\n    for(int i = 0; i < n; i++)\n      for(int j = max(0,i-DIFF); j < min(n, i+DIFF); j++){\n\tif(i == j) continue;\n\tans = min(ans,dist(V[i],V[j]));\n      }\n   \n    printf(\"%.5f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    return o.real() - r < s.o.real() - s.r;\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  return a.o.imag() - a.r < b.o.imag() - b.r;\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max(0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].o.real() - x) - r - a[i].r >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dx = a[i].o.real() - b[id].o.real() - b[id].r;\n      double dy = a[i].o.imag() - b[id].o.imag() - b[id].r;\n      if(fabs(dy) >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    printf(\"%.8f\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle{\n\tdouble x,y,r;\n\tbool operator < (const Circle &)const;\n};\n\nbool Circle::operator < (const Circle &a)const{\n\treturn (x*x+y*y)<(a.x*a.x+a.y*a.y);\n}\n\ndouble dist(const Circle &a,const Circle &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))-a.r-b.r;\n}\n\nconst int MAX_N=100000;\n\nint N;\nCircle c[MAX_N];\n\nvector<double> out;\n\nint main(){\n\tdo{\n\t\tscanf(\"%d\",&N);\n\t\tif (N){\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tscanf(\"%lf %lf %lf\",&c[i].r,&c[i].x,&c[i].y);\n\t\t\t}\n\t\t\tsort(c,c+N);\n\t\t\tdouble ans=1e50;\n\t\t\tprintf(\"%.8f\\n\",ans);\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tfor (int j=i+1;j<min(N,i+2001);j++){\n\t\t\t\t\tans=min(ans,dist(c[i],c[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.push_back(ans);\n\t\t}\n\t}while(N);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%.12f\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    return o.real() - r < s.o.real() - s.r;\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  return a.o.imag() - a.r < b.o.imag() - b.r;\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return sqrt(dx * dx + dy * dy) - a.r - b.r;\n}\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(x - a[i].o.real()) - r - a[i].r >= d) continue;\n    //if(fabs(a[i].o.real() - x) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dx = a[i].o.real() - b[id].o.real() - a[i].r - b[id].r;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(fabs(dy) >= d) break;\n      d = min(d, dist(a[i], b[id]));\n      //d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    printf(\"%.8f\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define EPS 1e-8\n\nstruct Circle\n{\n    double x, y, r;\n};\n\nbool XYorder(Circle P1, Circle P2)\n{\n\tif(P1.x != P2.x) return P1.x < P2.x;\n\treturn P1.y < P2.y;\n}\nbool YXorder(Circle P1, Circle P2)\n{\n\tif(P1.y != P2.y) return P1.y < P2.y;\n\treturn P1.x < P2.x;\n}\n\ndouble dist(const Circle &A, const Circle &B)\n{\n\treturn hypot(A.x - B.x, A.y - B.y) - A.r - B.r;\n}\n\ndouble R;\n\ndouble closest_recursive(vector <Circle> vx, vector <Circle> vy)\n{\n\tif(vx.size()==1) return 1e20;\n\tif(vx.size()==2) return dist(vx[0], vx[1]);\n\t\n\tCircle cut = vx[vx.size()/2];\n\t\n\tvector <Circle> vxL, vxR;\n\tfor(int i=0; i<vx.size(); i++)\n\t\tif(vx[i].x < cut.x || (vx[i].x == cut.x && vx[i].y <= cut.y))\n\t\t\tvxL.push_back(vx[i]);\n\t\telse vxR.push_back(vx[i]);\n\t\n\tvector <Circle> vyL, vyR;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(vy[i].x < cut.x || (vy[i].x == cut.x && vy[i].y <= cut.y))\n\t\t\tvyL.push_back(vy[i]);\n\t\telse vyR.push_back(vy[i]);\n\t\n\tdouble dL = closest_recursive(vxL, vyL);\n\tdouble dR = closest_recursive(vxR, vyR);\n\tdouble d = min(dL, dR);\n\t\n\tvector <Circle> b;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(abs(vy[i].x - cut.x) <= d + 2*R + EPS)\n\t\t\tb.push_back(vy[i]);\n\t\n\tfor(int i=0; i<b.size(); i++)\n\t\tfor(int j=i+1; j<b.size() && (b[j].y - b[i].y) <= d + 2*R + EPS; j++)\n\t\t\td = min(d, dist(b[i], b[j]));\n\t\n\treturn d;\n}\ndouble closest(vector <Circle> Circles)\n{\n\tvector <Circle> vx = Circles, vy = Circles;\n\tsort(vx.begin(), vx.end(), XYorder);\n\tsort(vy.begin(), vy.end(), YXorder);\n\treturn closest_recursive(vx,vy);\n}\n\nint main()\n{\n\tint n;\n\twhile(scanf(\"%d\", &n) == 1)\n\t{\n\t\tif(n == 0) break;\n\t\tR = 0;\n\t\t\n\t\tvector <Circle> P(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%lf %lf %lf\", &P[i].r, &P[i].x, &P[i].y);\n\t\t\tR = max(R, P[i].r);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", closest(P));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nclass Circle{\npublic:\n  P cp;\n  double r;\n};\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double INF=-1;\nint xsortedIdxs[100001];\nint ysortedIdxs[100001];\n\n\nint main(){\n  int n;\n  while(cin>>n&&n!=0){\n    vector<Circle> cs;\n    vector<pair<int,int> > xsorted;\n    vector<pair<int,int> > ysorted;\n    double x,y,r;\n    for(int i = 0; i < n; i++){\n      Circle c;\n      cin>>r>>x>>y;\n      c.r=r;\n      c.cp=P(x,y);\n      cs.push_back(c);\n      xsorted.push_back(make_pair(x,i));\n      ysorted.push_back(make_pair(y,i));\n    }\n    sort(xsorted.begin(),xsorted.end());\n    sort(ysorted.begin(),ysorted.end());\n    for(int i = 0; i < n; i++){\n      xsortedIdxs[xsorted[i].second]=i;\n      ysortedIdxs[ysorted[i].second]=i;\n    }\n    double minDist=INF;\n    for(int i = 0; i < n; i++){\n      // x,zÀW»ê¼êÉÂ¢ÄA\n      // ©ªÌê©ç-10,+10ÌÆ±ëðTõ\n      int xsidx=xsortedIdxs[i];\n      int ysidx=ysortedIdxs[i];\n      for(int j = xsidx; j < min(xsidx+50,n);j++){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = xsidx; j >= max(0,xsidx-50); j--){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j < min(ysidx+50,n);j++){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j >= max(0,ysidx-50); j--){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n    }\n    cout<<minDist<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<pair<double,double>,double> data;\n\ntemplate<class T> inline T dbl(T a){ return a * a; }\n\ninline double dist(const data &a, const data &b){\n  return sqrt(dbl(a.f.f - b.f.f) + dbl(a.f.s - b.f.s)) - (a.s + b.s);\n}\n\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n), n){\n    vector<data> v(n);\n\n    REP(i,n)\n      scanf(\"%lf%lf%lf\", &v[i].s, &v[i].f.f, &v[i].f.s);\n\n    double a1 = 0.0; REP(i,n) a1 += v[i].f.f; a1 /= n;\n    double a2 = 0.0; REP(i,n) a2 += v[i].f.s; a2 /= n;\n\n    double b1 = 0.0; REP(i,n) b1 += dbl(v[i].f.f - a1); b1 /= n;\n    double b2 = 0.0; REP(i,n) b2 += dbl(v[i].f.s - a2); b2 /= n;\n\n    if(b1 < b2) REP(i,n) swap(v[i].f.f, v[i].f.s);\n\n    sort(v.begin(), v.end());\n\n    double ans = 1e20;\n\n    for(int i = 0; i < v.size(); i++){\n      double x1 = v[i].f.f;\n      double r  = v[i].s;\n      for(int j = i + 1; j < v.size(); j++){\n\tdouble x2 = v[j].f.f;\n\n\tif((x2 - x1 + r) > ans) break;\n\n\tans = min(ans, dist(v[i], v[j]));\n      }\n    }\n    \n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define EPS 1e-8\n#define PI acos(-1)\n#define Vector Point\n\nstruct Point\n{\n    double x, y, r;\n    Point(){}\n    Point(double a, double b, double c) { x = a; y = b; r = c; }\n    double mod2() { return x*x + y*y; }\n    double mod()  { return sqrt(x*x + y*y); }\n};\n\nbool operator ==(const Point &a, const Point &b)\n{\n    return fabs(a.x - b.x) < EPS && fabs(a.y - b.y) < EPS;\n}\nbool operator !=(const Point &a, const Point &b)\n{\n    return !(a==b);\n}\nbool operator <(const Point &a, const Point &b)\n{\n    if(a.x != b.x) return a.x < b.x;\n    return a.y < b.y;\n}\n\nbool XYorder(Point P1, Point P2)\n{\n\tif(P1.x != P2.x) return P1.x < P2.x;\n\treturn P1.y < P2.y;\n}\nbool YXorder(Point P1, Point P2)\n{\n\tif(P1.y != P2.y) return P1.y < P2.y;\n\treturn P1.x < P2.x;\n}\n\ndouble dist(const Point &A, const Point &B)\n{\n\treturn hypot(A.x - B.x, A.y - B.y) - A.r - B.r;\n}\n\ndouble R;\n\ndouble closest_recursive(vector <Point> vx, vector <Point> vy)\n{\n\tif(vx.size()==1) return 1e20;\n\tif(vx.size()==2) return dist(vx[0], vx[1]);\n\t\n\tPoint cut = vx[vx.size()/2];\n\t\n\tvector <Point> vxL, vxR;\n\tfor(int i=0; i<vx.size(); i++)\n\t\tif(vx[i].x < cut.x || (vx[i].x == cut.x && vx[i].y <= cut.y))\n\t\t\tvxL.push_back(vx[i]);\n\t\telse vxR.push_back(vx[i]);\n\t\n\tvector <Point> vyL, vyR;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(vy[i].x < cut.x || (vy[i].x == cut.x && vy[i].y <= cut.y))\n\t\t\tvyL.push_back(vy[i]);\n\t\telse vyR.push_back(vy[i]);\n\t\n\tdouble dL = closest_recursive(vxL, vyL);\n\tdouble dR = closest_recursive(vxR, vyR);\n\tdouble d = min(dL, dR);\n\t\n\tvector <Point> b;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(abs(vy[i].x - cut.x) <= d + 2*R + EPS)\n\t\t\tb.push_back(vy[i]);\n\t\n\tfor(int i=0; i<b.size(); i++)\n\t\tfor(int j=i+1; j<b.size() && (b[j].y - b[i].y) <= d + 2*R + EPS; j++)\n\t\t\td = min(d, dist(b[i], b[j]));\n\t\n\treturn d;\n}\ndouble closest(vector <Point> points)\n{\n\tvector <Point> vx = points, vy = points;\n\tsort(vx.begin(), vx.end(), XYorder);\n\tsort(vy.begin(), vy.end(), YXorder);\n\treturn closest_recursive(vx,vy);\n}\n\nint main()\n{\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tif(n == 0) break;\n\t\tR = 0;\n\t\t\n\t\tvector <Point> P(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin>>P[i].r>>P[i].x>>P[i].y;\n\t\t\tR = max(R, P[i].r);\n\t\t}\n\t\tprintf(\"%.10lf\\n\", closest(P));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle{\n\tdouble x,y,r;\n\tbool operator < (const Circle &)const;\n};\n\nbool Circle::operator < (const Circle &a)const{\n\treturn sqrt(x*x+y*y)<sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble dist(const Circle &a,const Circle &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))-a.r-b.r;\n}\n\nconst int MAX_N=100000;\n\nint N;\nCircle c[MAX_N];\n\nvector<double> out;\n\nint main(){\n\tdo{\n\t\tscanf(\"%d\",&N);\n\t\tif (N){\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tscanf(\"%lf %lf %lf\",&c[i].r,&c[i].x,&c[i].y);\n\t\t\t}\n\t\t\tsort(c,c+N);\n\t\t\tdouble ans=dist(c[0],c[1]);\n\t\t\tprintf(\"%.8f\\n\",ans);\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tfor (int j=i+1;j<min(N,i+101);j++){\n\t\t\t\t\tans=min(ans,dist(c[i],c[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.push_back(ans);\n\t\t}\n\t}while(N);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%.8f\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define MAX_N (2000010)\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nstruct Circle\n{\n  P p; double r;\n  Circle(P p=P(0,0), double r=0.)\n    : p(p), r(r) {}\n};\n\nbool operator < (Circle const& a, Circle const& b) {\n  return a.p.real() < b.p.real();\n}\n\nbool compare_y(Circle const& a, Circle const& b) {\n  return a.p.imag() < b.p.imag();\n}\n\nint N;\nCircle A[MAX_N];\ndouble MaxR;\n\ndouble const INF = 1e60;\n\ninline double calc(Circle const& a, Circle const& b) {\n  double x = a.p.real()-b.p.real();\n  double y = a.p.imag()-b.p.imag();\n  return sqrt(x*x + y*y) - a.r - b.r;\n}\n\ndouble circle_closest_pair(Circle *a, int n) {\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double delta = min(circle_closest_pair(a, m),\n\t\t     circle_closest_pair(a+m, n-m));\n  \n  delta += MaxR*2;\n  \n  // inplace_merge(BidirectionalIterator first, middle, last, Compare cmp);\n  inplace_merge(a, a+m, a+n, compare_y);\n  \n  // merge\n  vector<Circle> b; // <- circles < delta\n  rep(i, n) {\n    double mx = a[m].p.real();\n    if(abs(a[i].p.real()-mx) >= delta) { continue; }\n    \n    rep(j, b.size()) {\n      int bid = (int)b.size()-1-j;\n      double dy = a[i].p.imag() - b[bid].p.imag();\n      if(delta <= dy) { break; }\n      delta = min(delta, calc(a[i], b[bid]));\n    }\n    b.push_back(a[i]);\n  }\n  \n  return delta/2;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    MaxR = 0.;\n    rep(i, N) {\n      //      cin >> A[i].r >> A[i].p.real() >> A[i].p.imag();\n      double x, y, r; cin >> r >> x >> y;\n      A[i].p = P(x, y); A[i].r = r;\n      MaxR = max(MaxR, A[i].r);\n    }\n    sort(A, A+N);\n    printf(\"%.8f\\n\", circle_closest_pair(A, N));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nclass Circle{\npublic:\n  P cp;\n  double r;\n};\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double INF=-1;\nconst int band=3;\nint main(){\n  int n;\n  while(cin>>n&&n!=0){\n    int xsortedIdxs[100001];\n    int ysortedIdxs[100001];\n    vector<Circle> cs;\n    vector<pair<double,int> > xsorted;\n    vector<pair<double,int> > ysorted;\n    double x,y,r;\n    for(int i = 0; i < n; i++){\n      Circle c;\n      cin>>r>>x>>y;\n      c.r=r;\n      c.cp=P(x,y);\n      cs.push_back(c);\n      xsorted.push_back(make_pair(x,i));\n      ysorted.push_back(make_pair(y,i));\n    }\n    sort(xsorted.begin(),xsorted.end());\n    sort(ysorted.begin(),ysorted.end());\n    for(int i = 0; i < n; i++){\n      xsortedIdxs[xsorted[i].second]=i;\n      ysortedIdxs[ysorted[i].second]=i;\n    }\n    double minDist=INF;\n    for(int i = 0; i < n; i++){\n      // x,zÀW»ê¼êÉÂ¢ÄA\n      // ©ªÌê©ç-10,+10ÌÆ±ëðTõ\n      int xsidx=xsortedIdxs[i];\n      int ysidx=ysortedIdxs[i];\n      for(int j = xsidx; j < min(xsidx+band,n);j++){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = xsidx; j >= max(0,xsidx-band); j--){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j < min(ysidx+band,n);j++){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j >= max(0,ysidx-band); j--){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n    }\n    printf(\"%.8f\\n\",minDist);\n    //cout<<minDist<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  return a.o.imag() - a.r < b.o.imag() - b.r;\n  //return a.o.imag() < b.o.imag();\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max(0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(fabs(dy) >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    printf(\"%.8f\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\n\ntemplate<typename T>\nvoid chmin(T &a,T b){if(a>b) a=b;}\ntemplate<typename T>\nvoid chmax(T &a,T b){if(a<b) a=b;}\n\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    vector<Circle> v(n);\n    for(int i=0;i<n;i++) cin>>v[i].r>>v[i].c;\n    auto calc=[](Circle a,Circle b){\n      return abs(a.c-b.c)-(a.r+b.r);\n    };\n    double ans=calc(v[0],v[1]);\n    for(int k=0;k<10;k++){\n      sort(v.begin(),v.end(),[](Circle a,Circle b){return sort_x(a.c,b.c);});\n      for(int i=0;i<n-1;i++) chmin(ans,calc(v[i],v[i+1]));\n      sort(v.begin(),v.end(),[](Circle a,Circle b){return sort_y(a.c,b.c);});\n      for(int i=0;i<n-1;i++) chmin(ans,calc(v[i],v[i+1]));\n      for(int i=0;i<n;i++) v[i].c=translate(v[i].c,PI/100);\n    }\n    cout<<fixed<<setprecision(12)<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double inf = 1e100;\nconst double pi = acos(-1);\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(a.real() != b.real()) return a.real() < b.real();\n    return a.imag() < b.imag();\n  }\n}\n\nconst int MAXN = 100005;\nint N;\npair<P,double> ps[MAXN];\ndouble maxR[MAXN];\n\nP getRotateP(P p, double rad) {\n  return P(cos(rad)*p.real() - sin(rad)*p.imag(),\n           sin(rad)*p.real() + cos(rad)*p.imag());\n}\n\nint main() {\n  while(cin >> N && N) {\n    double rad = (double)rand() / (double)RAND_MAX * 2.0 * pi;\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].second >> ps[i].first.real() >> ps[i].first.imag();\n      ps[i].first = getRotateP(ps[i].first, rad);\n    }\n    sort(ps, ps+N);\n    maxR[N] = -inf;\n    for(int i = N-1; i >= 0; --i) {\n      maxR[i] = max(maxR[i+1], ps[i].second);\n    }\n    double ans = inf;\n    for(int i = 0; i < N; ++i) {\n      P p1 = ps[i].first;\n      double r1 = ps[i].second;\n      for(int j = i+1; j < N; ++j) {\n        P p2 = ps[j].first;\n        double r2 = ps[j].second;\n        if(p2.real() - p1.real() - r1 - maxR[j] >= ans) break;\n        double dist = sqrt((p1.real()-p2.real())*(p1.real()-p2.real())\n                           +(p1.imag()-p2.imag())*(p1.imag()-p2.imag())) - r1 - r2;\n        ans = min(ans, dist);\n      }\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){\n\t\tif(info[index].x+info[index].r+dist < x){\n\t\t\treturn false;\n\t\t}\n\n\t}else{\n\t\tif(info[index].x-info[index].r-dist > x){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2;\n\n\tdouble x = array[mid].x;\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid));\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y);\n\n\tvector<int> V;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(!is_OK(i,x,dist))continue;\n\n\t\tfor(int k = 0; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}\n\t\tV.push_back(i);\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> P;\nstruct C{\n    P p;\n    double r;\n};\nbool operator < (const C& c, const C& d) {\n    return c.p.real() < d.p.real();\n}\n\nint main(){\n    int n;\n    while(cin >> n && n > 0) {\n        vector<C> cs(n);\n        double max_r = 0;\n        double th = M_PI / 6;\n        REP(i, n) {\n            double r, x, y;\n            cin >> r >> x >> y;\n\n            P p(x, y);\n            p *= polar(1.0, th);\n\n            cs[i] = {p, r};\n\n            max_r = max(max_r, r);\n        }\n\n        sort(cs.begin(), cs.end());\n        double ans = 1e63;\n\n        REP(i, n) {\n            for(int j = i + 1; j < n; j++) {\n                if(ans < cs[j].p.real() - cs[i].p.real() - cs[i].r - max_r) {\n                    break;\n                }\n                ans = min(ans, abs(cs[i].p - cs[j].p) - cs[i].r - cs[j].r);\n            }\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define EPS 1e-8\n#define PI acos(-1)\n#define Vector Point\n\nstruct Point\n{\n    double x, y, r;\n    Point(){}\n    Point(double a, double b, double c) { x = a; y = b; r = c; }\n    double mod2() { return x*x + y*y; }\n    double mod()  { return sqrt(x*x + y*y); }\n};\n\nbool operator ==(const Point &a, const Point &b)\n{\n    return fabs(a.x - b.x) < EPS && fabs(a.y - b.y) < EPS;\n}\nbool operator !=(const Point &a, const Point &b)\n{\n    return !(a==b);\n}\nbool operator <(const Point &a, const Point &b)\n{\n    if(a.x != b.x) return a.x < b.x;\n    return a.y < b.y;\n}\n\nbool XYorder(Point P1, Point P2)\n{\n\tif(P1.x != P2.x) return P1.x < P2.x;\n\treturn P1.y < P2.y;\n}\nbool YXorder(Point P1, Point P2)\n{\n\tif(P1.y != P2.y) return P1.y < P2.y;\n\treturn P1.x < P2.x;\n}\n\ndouble dist(const Point &A, const Point &B)\n{\n\treturn hypot(A.x - B.x, A.y - B.y) - A.r - B.r;\n}\n\ndouble R;\n\ndouble closest_recursive(vector <Point> vx, vector <Point> vy)\n{\n\tif(vx.size()==1) return 1e20;\n\tif(vx.size()==2) return dist(vx[0], vx[1]);\n\t\n\tPoint cut = vx[vx.size()/2];\n\t\n\tvector <Point> vxL, vxR;\n\tfor(int i=0; i<vx.size(); i++)\n\t\tif(vx[i].x < cut.x || (vx[i].x == cut.x && vx[i].y <= cut.y))\n\t\t\tvxL.push_back(vx[i]);\n\t\telse vxR.push_back(vx[i]);\n\t\n\tvector <Point> vyL, vyR;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(vy[i].x < cut.x || (vy[i].x == cut.x && vy[i].y <= cut.y))\n\t\t\tvyL.push_back(vy[i]);\n\t\telse vyR.push_back(vy[i]);\n\t\n\tdouble dL = closest_recursive(vxL, vyL);\n\tdouble dR = closest_recursive(vxR, vyR);\n\tdouble d = min(dL, dR);\n\t\n\tvector <Point> b;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(abs(vy[i].x - cut.x) <= d + 2*R + EPS)\n\t\t\tb.push_back(vy[i]);\n\t\n\tfor(int i=0; i<b.size(); i++)\n\t\tfor(int j=i+1; j<b.size() && (b[j].y - b[i].y) <= d + 2*R + EPS; j++)\n\t\t\td = min(d, dist(b[i], b[j]));\n\t\n\treturn d;\n}\ndouble closest(vector <Point> points)\n{\n\tvector <Point> vx = points, vy = points;\n\tsort(vx.begin(), vx.end(), XYorder);\n\tsort(vy.begin(), vy.end(), YXorder);\n\treturn closest_recursive(vx,vy);\n}\n\nint main()\n{\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tif(n == 0) break;\n\t\tR = 0;\n\t\t\n\t\tvector <Point> P(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin>>P[i].r>>P[i].x>>P[i].y;\n\t\t\tR = max(R, P[i].r);\n\t\t}\n\t\tcout<<closest(P)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  //return a.o.imag() - a.r < b.o.imag() - b.r;\n  return a.o.imag() < b.o.imag();\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max((double)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble valM;\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    bool f = false;\n    if(x > a[i].o.real()){\n      if(a[i].o.real() <= x && x <= a[i].o.real() + a[i].r) f = true;\n      if(fabs(a[i].o.real() + a[i].r - x) < max(valM, d)) f = true;\n    }else{\n      if(a[i].o.real() - a[i].r <= x && x <= a[i].o.real()) f = true;\n      if(fabs(a[i].o.real() - a[i].r - x) < max(valM, d)) f = true;\n    }\n    if(!f) continue;\n    //if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(dy >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    valM = 0.0;\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n      valM = max(valM, c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    //cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<29\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\nP p[1000000];\n\nbool cmp_y(P a,P b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if( (a[i].F.F+a[i].S)-(x-r)  >= d)continue;\n    }\n    else{\n      if( (x+r)-(a[i].F.F+a[i].S) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif(fabs( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S) ) >= d )break;\n      }\n      else{\n\tif(fabs((a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S)) >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int N;\n  double R,X,Y;\n\n  while(cin >> N && N){\n    for(int i=0;i<N;i++){\n      cin >> p[i].S >> p[i].F.F >> p[i].F.S;\n    }\n    sort(p,p+N);\n    printf(\"%.6f\\n\",rec(p,N));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define MAX 2000000\n#define all(n) (n).begin(),(n).end()\nusing namespace std;\nstruct Circle\n{\n  double x,y,r;\n  Circle(double x=inf,double y=inf,double r=inf):x(x),y(y),r(r){}\n  bool operator < (const Circle& c)const\n  {\n    if(!equals(x,c.x))return x < c.x;\n    return y < c.y;\n  }\n};\n\nbool compare_y(Circle a,Circle b)\n{\n  return a.y < b.y;\n}\n\nint N;\nCircle A[MAX];\n\ndouble compute(Circle *a,int n)\n{\n  if(n <= 1)return inf;\n  int m = n/2;\n  double x = a[m].x;\n  double y = a[m].y;\n  double r = a[m].r;\n  double d = min(compute(a,m),compute(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Circle> b;\n\n  rep(i,n)\n    {\n      double nx = a[i].x - x;\n      double ny = a[i].y - y;\n      double ndist = sqrt(nx*nx + ny*ny) - a[i].r - r;\n      //if(equals(ndist,d) || ndist > d)continue;\n      //if(nx >= d)continue;\n     \n      rep(j,(int)min((int)b.size(),1))\n\t{\n\t  int last = b.size()-j-1;\n\t  double dx = a[i].x - b[last].x;\n\t  double dy = a[i].y - b[last].y;\n\t  double dist = sqrt(dx*dx + dy*dy) - a[i].r - b[last].r;\n\n\t  if(equals(dist,d) || dist > d)continue;\n\t  d = min(d,sqrt(dx*dx + dy*dy) - a[i].r - b[last].r);\n\t}\n      b.push_back(a[i]);\n    }\n  return d;\n}\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      assert(N < MAX);\n      rep(i,N)cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A,A+N);\n\n\n      cout << setiosflags(ios::fixed) << setprecision(8) << compute(A,N) << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nconst int DIFF = 1000;\n\nstruct Circle{\n  double x,y,r;\n  bool operator < (const Circle& c) const{\n    return sqrt(x*x+y*y) < sqrt(c.x*c.x+c.y*c.y);\n  }\n};\n\ndouble dist(const Circle& c1, const Circle& c2){\n  return sqrt((c1.x-c2.x)*(c1.x-c2.x) + (c1.y-c2.y)*(c1.y-c2.y))-c1.r-c2.r;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<Circle> V(n);\n    for(int i = 0; i < n; i++) cin >> V[i].r >> V[i].x >> V[i].y;\n    \n    double ans = 1e50;\n\n    for(int i = 0; i < n; i++)\n      for(int j = max(0,i-DIFF); j < min(n, i+DIFF); j++){\n\tif(i == j) continue;\n\tans = min(ans,dist(V[i],V[j]));\n      }\n   \n    printf(\"%.5f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define MAX 2000000\n#define all(n) (n).begin(),(n).end()\nusing namespace std;\nstruct Circle\n{\n  double x,y,r;\n  Circle(double x=inf,double y=inf,double r=inf):x(x),y(y),r(r){}\n  bool operator < (const Circle& c)const\n  {\n    if(!equals(x,c.x))return x < c.x;\n    return y < c.y;\n  }\n};\n\nbool compare_y(Circle a,Circle b)\n{\n  return a.y < b.y;\n}\n\nint N;\nCircle A[MAX];\n\ndouble compute(Circle *a,int n)\n{\n  if(n <= 1)return inf;\n  int m = n/2;\n  double x = a[m].x;\n  double y = a[m].y;\n  double r = a[m].r;\n  double d = min(compute(a,m),compute(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Circle> b;\n\n  rep(i,n)\n    {\n      double nx = a[i].x - x;\n      double ny = a[i].y - y;\n      double ndist = sqrt(nx*nx + ny*ny) - a[i].r - r;\n      //if(equals(ndist,d) || ndist > d)continue;\n      //if(nx >= d)continue;\n     \n      rep(j,(int)min((int)b.size(),10))\n\t{\n\t  int last = b.size()-j-1;\n\t  double dx = a[i].x - b[last].x;\n\t  double dy = a[i].y - b[last].y;\n\t  double dist = sqrt(dx*dx + dy*dy) - a[i].r - b[last].r;\n\n\t  if(equals(dist,d) || dist > d)continue;\n\t  d = min(d,sqrt(dx*dx + dy*dy) - a[i].r - b[last].r);\n\t}\n      b.push_back(a[i]);\n    }\n  return d;\n}\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      assert(N < MAX);\n      rep(i,N)cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A,A+N);\n\n\n      cout << setiosflags(ios::fixed) << setprecision(8) << compute(A,N) << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) < min_val+2*maxr){\n      for(int j=p-1;j>=0 && abs(tarray[j].y-a[i].y)<min_val;j--){\n\tmin_val=min(tarray[j].dist(a[i]),min_val);\n      }\n      tarray[p++]=a[i];\n    }\n  }\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst double INF = 1e+12;\n\ndouble equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nstruct C{\n  P p;\n  double r;\n  C(P p=P(0,0),double r=0.0):p(p),r(r){}\n  bool operator < (const C &c) const {\n    return equal(real(p),real(c.p)) ? imag(p) < imag(c.p) : real(p) < real(c.p);\n  }\n};\n\n\nC v[100000];\n\nbool compare_y(C a, C b){\n  return imag(a.p) < imag(b.p);\n}\n\ndouble closest(C a[], int n){\n  if(n <= 1) return INF;\n  int m = n / 2;\n  double x = real(a[m].p);\n  double d = min(closest(a,m), closest(a+m,n-m));\n  inplace_merge(a, a+m, a+n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(real(a[i].p) - x) >= d || equal(fabs(real(a[i].p) - x),d)) continue;\n\n    for(int j=0;j<b.size();j++){\n      C bc = b[b.size()-j-1];\n      if(imag(a[i].p-bc.p) >= d || equal(imag(a[i].p-bc.p),d)) break;\n      //cout << a[i].p << ' ' << bc.p << endl;\n      d = min(d, abs(a[i].p-bc.p) - a[i].r - bc.r);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> v[i].r >> x >> y;\n      v[i].p = P(x,y);\n    }\n    sort(v,v+n);\n    cout << closest(v,n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<29\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\n\nbool cmp_y(const P &a,const P &b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if(fabs( (a[i].F.F+a[i].S)-(x-r) ) >= d)continue;\n    }\n    else{\n      if( fabs((x+r)-(a[i].F.F+a[i].S)) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif( fabs( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S)     )   >= d )break;\n      }\n      else{\n\tif( fabs( (a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S)     )  >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  double R,X,Y;\n  vector<P> p;\n  while(cin >> n && n){\n    p.clear();\n    for(int i=0;i<n;i++){\n      cin >> R >> X >> Y;\n      p.push_back(P(Pos(X,Y),R));\n    }\n    sort(p.begin(),p.end());\n    printf(\"%.6f\\n\",rec(&p[0],n));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct circle { double x, y, r; };\nint n; circle x[100009];\nbool operator<(const circle& c1, const circle& c2) {\n\treturn c1.x - c1.r < c2.x - c2.r;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf%lf%lf\", &x[i].r, &x[i].x, &x[i].y);\n\t\t\tdouble ex = x[i].x * 0.28 - x[i].y * 0.96;\n\t\t\tdouble ey = x[i].x * 0.96 + x[i].y * 0.28;\n\t\t\tx[i].x = ex, x[i].y = ey;\n\t\t}\n\t\tsort(x, x + n);\n\t\tdouble ret = 1.0e+9;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (x[i].x + x[i].r + ret < x[j].x - x[j].r) break;\n\t\t\t\tdouble dist = hypot(x[i].x - x[j].x, x[i].y - x[j].y) - x[i].r - x[j].r;\n\t\t\t\tret = min(ret, dist);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.15lf\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    return o.real() - r < s.o.real() - s.r;\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  return a.o.imag() - a.r < b.o.imag() - b.r;\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return sqrt(dx * dx + dy * dy) - a.r - b.r;\n}\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m= n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(x - a[i].o.real()) - r - a[i].r >= d) continue;\n    //if(fabs(a[i].o.real() - x) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dx = a[i].o.real() - b[id].o.real() - a[i].r - b[id].r;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(dy >= d) break;\n      d = dist(a[i], b[id]);\n      //d = min(d, sqrt(dx * dx + dy * dy));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    printf(\"%.8f\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<24\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\n\nbool cmp_y(const P &a,const P &b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if(fabs( (a[i].F.F+a[i].S)-(x-r) ) >= d)continue;\n    }\n    else{\n      if( fabs((x+r)-(a[i].F.F+a[i].S)) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif( fabs( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S)     )   >= d )break;\n      }\n      else{\n\tif( fabs( (a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S)     )  >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  double R,X,Y;\n  vector<P> p;\n  while(cin >> n && n){\n    p.clear();\n    for(int i=0;i<n;i++){\n      cin >> R >> X >> Y;\n      p.push_back(P(Pos(X,Y),R));\n    }\n    sort(p.begin(),p.end());\n    printf(\"%.6f\\n\",rec(&p[0],n));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst long double EPS = 1e-9;\nconst int MAX_N = 100000;\nconst long double INF = 1e80;\n\nbool equal(long double a, long double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   long double x, y, r;\n   Circle(){}\n   Circle(long double y, long double x, long double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   if(equal(a.y, b.y)){\n      return a.r > b.r;\n   }\n   return a.y < b.y;\n}\n\nlong double closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   long double x = a[m].x;\n   long double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) > d + a[i].r || equal(fabs(a[i].x - x), d+a[i].r)) continue;\n      for(int j=0;j<b.size();j++){\n         long double dx = a[i].x - b[b.size()-j-1].x;\n         long double dy = a[i].y - b[b.size()-j-1].y;\n         long double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy > d + dr || equal(dy, d+dr)) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      fill(A, A+N, Circle(INF, INF, INF));\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a;cin>>a;\n\t\t\tP p=pin();\n\t\t\t//p=turn(p,17);\n\t\t\tc.pb(C(p,a));\n\t\t}\n\t\tsort(all(c),[](C a,C b){\n\t\t\treturn a.c<b.c;\n\t\t});\n\t\tdouble out=inf;\n\t\trep(i,n){\n\t\t\tint r=max(0,i-10),l=min(i+10,n);\n\t\t\tloop(j,r,l)if(j!=i){\n\t\t\t\tout=min(out,abs(c[i].c-c[j].c)-c[i].r-c[j].r);\n\t\t\t}\n\t\t}\n\t\tcout<<shosu(9)<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst double INF = 1e+12;\n\ndouble equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nstruct C{\n  P p;\n  double r;\n  C(P p=P(0,0),double r=0.0):p(p),r(r){}\n  bool operator < (const C &c) const {\n    return equal(real(p),real(c.p)) ? imag(p) < imag(c.p) : real(p) < real(c.p);\n  }\n};\n\n\nC v[100000];\nbool f;\n\nbool compare_y(C a, C b){\n  return imag(a.p) < imag(b.p);\n}\n\ndouble closest(C a[], int n){\n  if(n <= 1) return INF;\n  if(f) return 0.0;\n  int m = n / 2;\n  double x = real(a[m].p);\n  double d = min(closest(a,m), closest(a+m,n-m));\n  inplace_merge(a, a+m, a+n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(real(a[i].p) - x) >= d || equal(fabs(real(a[i].p) - x),d)) continue;\n\n    for(int j=0;j<b.size();j++){\n      C bc = b[b.size()-j-1];\n      if(imag(a[i].p-bc.p) >= d || equal(imag(a[i].p-bc.p),d)) break;\n      //cout << a[i].p << ' ' << bc.p << endl;\n      d = min(d, abs(a[i].p-bc.p) - a[i].r - bc.r);\n      if(equal(d,0.0)){\n        f = true;\n        return 0.0;\n      }\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> v[i].r >> x >> y;\n      v[i].p = P(x,y);\n    }\n    sort(v,v+n);\n    f = false;\n    printf(\"%.6g\\n\",closest(v,n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nclass Circle{\npublic:\n  P cp;\n  double r;\n};\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double INF=-1;\nconst int band=50;\nint main(){\n  int n;\n  while(cin>>n&&n!=0){\n    int xsortedIdxs[100001];\n    int ysortedIdxs[100001];\n    vector<Circle> cs;\n    vector<pair<double,int> > xsorted;\n    vector<pair<double,int> > ysorted;\n    double x,y,r;\n    for(int i = 0; i < n; i++){\n      Circle c;\n      cin>>r>>x>>y;\n      c.r=r;\n      c.cp=P(x,y);\n      cs.push_back(c);\n      xsorted.push_back(make_pair(x,i));\n      ysorted.push_back(make_pair(y,i));\n    }\n    sort(xsorted.begin(),xsorted.end());\n    sort(ysorted.begin(),ysorted.end());\n    for(int i = 0; i < n; i++){\n      xsortedIdxs[xsorted[i].second]=i;\n      ysortedIdxs[ysorted[i].second]=i;\n    }\n    double minDist=INF;\n    for(int i = 0; i < n; i++){\n      // x,zÀW»ê¼êÉÂ¢ÄA\n      // ©ªÌê©ç-10,+10ÌÆ±ëðTõ\n      int xsidx=xsortedIdxs[i];\n      int ysidx=ysortedIdxs[i];\n      for(int j = xsidx; j < min(xsidx+band,n);j++){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = xsidx; j >= max(0,xsidx-band); j--){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j < min(ysidx+band,n);j++){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j >= max(0,ysidx-band); j--){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n    }\n    cout<<minDist<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = max(0,i-100) ; j < min(i+100,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = max(0,i-100) ; j < min(i+100,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle{\n\tdouble x,y,r;\n\tbool operator < (const Circle &)const;\n};\n\nbool Circle::operator < (const Circle &a)const{\n\treturn (x*x+y*y)<(a.x*a.x+a.y*a.y);\n}\n\ndouble dist(const Circle &a,const Circle &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))-a.r-b.r;\n}\n\nconst int MAX_N=100000;\n\nint N;\nCircle c[MAX_N];\n\nvector<double> out;\n\nint main(){\n\tdo{\n\t\tscanf(\"%d\",&N);\n\t\tif (N){\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tscanf(\"%lf %lf %lf\",&c[i].r,&c[i].x,&c[i].y);\n\t\t\t}\n\t\t\tsort(c,c+N);\n\t\t\tdouble ans=1e50;\n\t\t\tprintf(\"%.8f\\n\",ans);\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tfor (int j=i+1;j<min(N,i+4001);j++){\n\t\t\t\t\tans=min(ans,dist(c[i],c[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.push_back(ans);\n\t\t}\n\t}while(N);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%.12f\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<29\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\nP p[1000000];\nbool cmp_y(P a,P b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if(fabs( (a[i].F.F+a[i].S)-(x-r) ) >= d)continue;\n    }\n    else{\n      if( fabs((x+r)-(a[i].F.F+a[i].S)) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif( fabs( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S)     )   >= d )break;\n      }\n      else{\n\tif( fabs( (a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S)     )  >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int N;\n  double R,X,Y;\n\n  while(cin >> N && N){\n    for(int i=0;i<N;i++){\n      cin >> p[i].S >> p[i].F.F >> p[i].F.S;\n    }\n    sort(p,p+N);\n    printf(\"%.6f\\n\",rec(p,N));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nconst int DIFF = 500;\n\nstruct Circle{\n  double x,y,r;\n  bool operator < (const Circle& c) const{\n    return sqrt(x*x+y*y) < sqrt(c.x*c.x+c.y*c.y);\n  }\n};\n\ndouble dist(const Circle& c1, const Circle& c2){\n  return sqrt((c1.x-c2.x)*(c1.x-c2.x) + (c1.y-c2.y)*(c1.y-c2.y))-c1.r-c2.r;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<Circle> V(n);\n    for(int i = 0; i < n; i++) cin >> V[i].r >> V[i].x >> V[i].y;\n    \n    double ans = 1e50;\n\n    for(int i = 0; i < n; i++)\n      for(int j = max(0,i-DIFF); j < min(n, i+DIFF); j++){\n\tif(i == j) continue;\n\tans = min(ans,dist(V[i],V[j]));\n      }\n   \n    printf(\"%.5f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> P;\nstruct C{\n    P p;\n    double r;\n};\nbool operator < (const C& c, const C& d) {\n    return c.p.real() < d.p.real();\n}\n\nint main(){\n    int n;\n    while(cin >> n && n > 0) {\n        vector<C> cs(n);\n        double max_r = 0;\n        double th = M_PI / 6;\n        REP(i, n) {\n            double r, x, y;\n            cin >> r >> x >> y;\n\n            P p(x, y);\n            p *= polar(1.0, th);\n\n            cs[i] = {p, r};\n\n            max_r = max(max_r, r);\n        }\n\n        sort(cs.begin(), cs.end());\n        double ans = 1e63;\n\n        REP(i, n) {\n            for(int j = i + 1; j < n; j++) {\n                assert(cs[j].p.real() >= cs[i].p.real());\n                if(ans < cs[j].p.real() - cs[i].p.real() - cs[i].r - max_r) {\n                    break;\n                }\n                ans = min(ans, abs(cs[i].p - cs[j].p) - cs[i].r - cs[j].r);\n            }\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nstruct C {\n\tP p;\n\tdouble r;\n\tC(const P p, double r): p(p), r(r){};\n};\n\n#define X real()\n#define Y imag()\n\ndouble dis(C c1, C c2) {\n\tP p1 = c1.p;\n\tP p2 = c2.p;\n\treturn sqrt((p1.X-p2.X)*(p1.X-p2.X)+(p1.Y-p2.Y)*(p1.Y-p2.Y))-c1.r-c2.r;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tdouble x, y, r;\n\t\tvector<C> data;\n\t\tdouble MIN;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r >> x >> y;\n\t\t\tdata.push_back(C(P(x, y), r));\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (i == 1) {\n\t\t\t\t\tMIN = dis(data[j], data[i]);\n\t\t\t\t} else {\n\t\t\t\t\tMIN = min(MIN, dis(data[j], data[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << MIN << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a;cin>>a;\n\t\t\tP p=pin();\n\t\t\tp=turn(p,17);\n\t\t\tc.pb(C(p,a));\n\t\t}\n\t\tsort(all(c),[](C a,C b){\n\t\t\treturn a.c<b.c;\n\t\t});\n\t\tdouble out=inf;\n\t\trep(i,n){\n\t\t\tint r=max(0,i-10),l=min(i+10,n);\n\t\t\tloop(j,r,l)if(j!=i){\n\t\t\t\tout=min(out,abs(c[i].c-c[j].c)-c[i].r-c[j].r);\n\t\t\t}\n\t\t}\n\t\tcout<<shosu(9)<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    return o.real() - r < s.o.real() - s.r;\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  return a.o.imag() - a.r < b.o.imag() - b.r;\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max(0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].o.real() - x) - r - a[i].r >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dx = a[i].o.real() - b[id].o.real() - b[id].r - a[i].r;\n      double dy = a[i].o.imag() - b[id].o.imag() - b[id].r - a[i].r;\n      if(fabs(dy) >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    printf(\"%.8f\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> P;\nstruct C{\n    P p;\n    double r;\n};\nbool operator < (const C& c, const C& d) {\n    return c.p.real() < d.p.real();\n}\n\nint main(){\n    int n;\n    while(cin >> n && n > 0) {\n        vector<C> cs(n);\n        double max_r = 0;\n        double th = M_PI / 4;\n        REP(i, n) {\n            double r, x, y;\n            cin >> r >> x >> y;\n\n            P p(x, y);\n            p *= polar(1.0, th);\n\n            cs[i] = {p, r};\n\n            max_r = max(max_r, r);\n        }\n\n        sort(cs.begin(), cs.end());\n        double ans = 1e63;\n\n        REP(i, n) {\n            for(int j = i + 1; j < n; j++) {\n                if(ans < cs[j].p.real() - cs[i].p.real() - cs[i].r - max_r) {\n                    break;\n                }\n                ans = min(ans, abs(cs[i].p - cs[j].p) - cs[i].r - cs[j].r);\n            }\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\ntypedef long double Double;\n\ntypedef complex<Double> P;\nstruct C {\n  P p; Double r;\n  C(const P &p, Double r) : p(p), r(r) { }\n  C() {}\n};\nbool p1(const C &a, const C &b) {\n  return a.p.real() != b.p.real() ? a.p.real() < b.p.real() : a.p.imag() < b.p.imag();\n}\nbool p2(const C &a, const C &b) {\n  return a.p.imag() != b.p.imag() ? a.p.imag() < b.p.imag() : a.p.real() < b.p.real();\n}\n\nC circle[100000];\nDouble minR;\n\nDouble solve(int s, int t) {\n  if (s+1>=t) return INF;\n  Double m1 = solve(s, (s+t)/2);\n  Double m2 = solve((s+t)/2, t);\n  Double mid = (circle[(s+t)/2-1].p.real() + circle[(s+t)/2].p.real()) / 2;\n  Double d = min(m1, m2) + 2*minR+1;\n  int start = lower_bound(circle+s, circle+t, C(P(mid-d, -INF), 0), p1) - circle;\n  int end = upper_bound(circle+s, circle+t, C(P(mid+d, INF), 0), p1) - circle;\n  vector<C> v;\n  //cout << s << \" \" <<t << endl;\n  for (int i=start; i<end; ++i) {\n    v.push_back(circle[i]);\n    //cout << circle[i].p << endl;\n  }\n  sort(ALL(v), p2);\n  Double res = min(m1, m2);\n  for (int i=0; i<v.size(); ++i) {\n    for (int k=i+1; k<v.size() && (v[k].p.imag()-v[i].p.imag())<d; ++k) {\n      res = min(res, abs(v[k].p-v[i].p)-v[k].r-v[i].r);\n    }\n  }\n  //cout << res << endl;\n  return res;\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    minR = INF;\n    REP(i,n) {\n      Double x, y, r;\n      cin >> r >> x >> y;\n      circle[i] = C(P(x,y),r);\n      minR = min(minR, r);\n    }\n    sort(circle, circle+n, p1);\n    printf(\"%.6Lf\\n\", solve(0, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nclass Circle{\npublic:\n  P cp;\n  double r;\n};\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double INF=-1;\nconst int band=100;\nint main(){\n  int n;\n  while(cin>>n&&n!=0){\n    int xsortedIdxs[100001];\n    int ysortedIdxs[100001];\n    vector<Circle> cs;\n    vector<pair<double,int> > xsorted;\n    vector<pair<double,int> > ysorted;\n    double x,y,r;\n    for(int i = 0; i < n; i++){\n      Circle c;\n      cin>>r>>x>>y;\n      c.r=r;\n      c.cp=P(x,y);\n      cs.push_back(c);\n      xsorted.push_back(make_pair(x,i));\n      ysorted.push_back(make_pair(y,i));\n    }\n    sort(xsorted.begin(),xsorted.end());\n    sort(ysorted.begin(),ysorted.end());\n    for(int i = 0; i < n; i++){\n      xsortedIdxs[xsorted[i].second]=i;\n      ysortedIdxs[ysorted[i].second]=i;\n    }\n    double minDist=INF;\n    for(int i = 0; i < n; i++){\n      // x,zÀW»ê¼êÉÂ¢ÄA\n      // ©ªÌê©ç-10,+10ÌÆ±ëðTõ\n      int xsidx=xsortedIdxs[i];\n      int ysidx=ysortedIdxs[i];\n      for(int j = xsidx; j < min(xsidx+band,n);j++){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = xsidx; j >= max(0,xsidx-band); j--){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j < min(ysidx+band,n);j++){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j >= max(0,ysidx-band); j--){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(minDist==INF||minDist>d)\n\t  minDist=d;\n      }\n    }\n    cout<<minDist<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\ndouble max_r;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){ //基準線より中心が左\n\t\tif(info[index].x+info[index].r+dist < x-max_r){ //★★中心線より反対側に円がはみ出す場合がある\n\t\t\treturn false;\n\t\t}\n\n\t}else{ //基準線より中心が右\n\t\tif(info[index].x-info[index].r-dist > x+max_r){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\t//if(!is_OK(i,x,dist))continue; //異なる領域間での、新最小値を作り得ない場合は無視\n\n\t\tleft = 0,right = V.size()-1,m = (left+right)/2;\n\t\tsearch_left = V.size()-1;\n\n\t\t//Vはy座標の昇順にpushされている→自分よりy座標が小さいもののみが入っている\n\t\twhile(left <= right){\n\t\t\tif((info[i].y-info[i].r)-(info[m].y+info[m].r) < dist){ //y座標の差がdist未満の場合\n\t\t\t\tsearch_left = m;\n\t\t\t\tright = m-1; //より左へ\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tfor(int k = search_left; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tmax_r = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t\tmax_r = max(max_r,info[i].r);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = max(0,i-100) ; j < min(i+100,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = max(0,i-100) ; j < min(i+100,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f%c\",ans,10);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double INF = 1e18;\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n    C(){}\n};\nbool xcomp(const C &a, const C &b){\n    return (a.p.X != b.p.X)? a.p.X<b.p.X : a.p.Y<b.p.Y;\n}\nbool ycomp(const C &a, const C &b){\n    return (a.p.Y != b.p.Y)? a.p.Y<b.p.Y : a.p.X<b.p.X;\n}\n\ndouble closest(vector<C> &c, int first, int last, double rmax){\n    if(last -first <= 1) return INF;\n    int mid = (first +last)/2;\n    double midx = c[mid].p.X;\n    double d = min(closest(c, first, mid, rmax), closest(c, mid, last, rmax));\n    inplace_merge(c.begin()+first, c.begin()+mid, c.begin()+last, ycomp);\n\n    vector<C> near;\n    for(int i=first; i<last; i++){\n        if(abs(c[i].p.X -midx) -c[i].r -rmax > d +EPS) continue;\n        for(int j=near.size()-1; j>=0; j--){\n            if(abs(c[i].p.Y -near[j].p.Y) -c[i].r -rmax > d +EPS){\n                break;\n            }\n            d = min(d, abs(c[i].p -near[j].p) -c[i].r -near[j].r);\n        }\n        near.push_back(c[i]);\n    }\n    return d;\n}\n \nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<C> c(n);\n        double rmax = 0;\n        for(int i=0; i<n; i++){\n            double r,x,y;\n            cin >> r >> x >> y;\n            c[i] = C(P(x, y), r);\n            rmax = max(rmax, r);\n        }\n        sort(c.begin(), c.end(), xcomp);\n\n        cout << fixed << setprecision(10);\n        cout << closest(c, 0, n, rmax) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  Point p1,p2,p3,p4;\n  p1=p2=p3=p4=BigPoint;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) < min_val+2*maxr){\n      min_val=min(min_val,a[i].dist(p1));\n      min_val=min(min_val,a[i].dist(p2));\n      min_val=min(min_val,a[i].dist(p3));\n      min_val=min(min_val,a[i].dist(p4));\n      p1=p2;p2=p3;p3=p4;p4=a[i];\n    }\n  }\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define MAX 2000000\n#define all(n) (n).begin(),(n).end()\nusing namespace std;\nstruct Circle\n{\n  double x,y,r;\n  Circle(double x=inf,double y=inf,double r=inf):x(x),y(y),r(r){}\n  bool operator < (const Circle& c)const\n  {\n    if(!equals(x,c.x))return x < c.x;\n    return y < c.y;\n  }\n};\n\nbool compare_y(Circle a,Circle b)\n{\n  return a.y < b.y;\n}\n\nint N;\nCircle A[MAX];\n\ndouble compute(Circle *a,int n)\n{\n  if(n <= 1)return inf;\n  int m = n/2;\n  double x = a[m].x;\n  double y = a[m].y;\n  double r = a[m].r;\n  double d = min(compute(a,m),compute(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Circle> b;\n\n  rep(i,n)\n    {\n      double nx = a[i].x - x;\n      double ny = a[i].y - y;\n      double ndist = sqrt(nx*nx + ny*ny) - a[i].r - r;\n      //if(equals(ndist,d) || ndist > d)continue;\n      //if(nx >= d)continue;\n     \n      rep(j,(int)min((int)b.size(),2))\n\t{\n\t  int last = b.size()-j-1;\n\t  double dx = a[i].x - b[last].x;\n\t  double dy = a[i].y - b[last].y;\n\t  double dist = sqrt(dx*dx + dy*dy) - a[i].r - b[last].r;\n\n\t  if(equals(dist,d) || dist > d)continue;\n\t  d = min(d,sqrt(dx*dx + dy*dy) - a[i].r - b[last].r);\n\t}\n      b.push_back(a[i]);\n    }\n  return d;\n}\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      assert(N < MAX);\n      rep(i,N)cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A,A+N);\n\n\n      cout << setiosflags(ios::fixed) << setprecision(8) << compute(A,N) << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tdouble r;\n};\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nstruct cmp_y{\nbool operator()(const point<double> &a,const point<double> &b){\n\treturn a.y+EPS<b.y || abs(a.y-b.y)<EPS && a.x+EPS<b.x;\n}};\n\ndouble closest_pair(int n,point<double> *P){\n\tdouble r_max=0;\n\trep(i,n) r_max=max(r_max,P[i].r);\n\n\tsort(P,P+n);\n\n\tdouble d=dist(P[0],P[1])-P[0].r-P[1].r;\n\n\tset<point<double>,cmp_y> S;\n\tset<point<double>,cmp_y>::iterator it_l,it_r,it;\n\tfor(int i=0,j=0;i<n;i++){\n\t\tit_l=S.lower_bound((point<double>){0,P[i].y-d-1-2*r_max});\n\t\tit_r=S.upper_bound((point<double>){0,P[i].y+d+1+2*r_max});\n\n\t\tfor(it=it_l;it!=it_r;++it) d=min(d,dist(*it,P[i])-(it->r)-P[i].r);\n\n\t\twhile(2*r_max+d+EPS<P[i].x-P[j].x) S.erase(P[j++]);\n\t\tS.insert(P[i]);\n\t}\n\n\treturn d;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstatic point<double> P[100000];\n\t\trep(i,n) scanf(\"%lf%lf%lf\",&P[i].r,&P[i].x,&P[i].y);\n\t\tprintf(\"%f\\n\",closest_pair(n,P));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) <1e-10+ min_val+2*maxr){\n      tarray[p++]=a[i];\n    }\n  }\n  rep(i,p){\n    //REP(j,i+1,p && abs(tarray[j].y-tarray[i].y)<1e-10+2*maxr+min_val){\n    REP(j,i+1,p){\n      min_val=min(min_val,tarray[j].dist(a[i]));\n    }\n  }\n\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst double INF = __DBL_MAX__;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\n/* global variables */\n\nint n;\ndouble rs[MAX_N], xs[MAX_N], ys[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    for (int i = 0; i < n; i++) cin >> rs[i] >> xs[i] >> ys[i];\n\n    double min_d = INF;\n    for (int i = 0; i < n; i++)\n      for (int j = i + 1; j < n; j++) {\n\tdouble dx = xs[j] - xs[i], dy = ys[j] - ys[i];\n\tdouble d = sqrt(dx * dx + dy * dy) - rs[j] - rs[i];\n\tif (min_d > d) min_d = d;\n      }\n\n    printf(\"%.6lf\\n\", min_d);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nstruct circle { double x, y, r; };\nint n; circle x[100009];\nbool operator<(const circle& c1, const circle& c2) {\n\treturn c1.x - c1.r < c2.x - c2.r;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) cin >> x[i].r >> x[i].x >> x[i].y;\n\t\tsort(x, x + n);\n\t\tdouble ret = 1.0e+9;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (x[i].x + x[i].r + ret < x[j].x - x[j].r) break;\n\t\t\t\tdouble dist = hypot(x[i].x - x[j].x, x[i].y - x[j].y) - x[i].r - x[j].r;\n\t\t\t\tret = min(ret, dist);\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(15) << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef complex<double> P;\nstruct C{\n    P p;\n    double r;\n};\nbool operator < (const C& c, const C& d) {\n    return c.p.real() < d.p.real();\n}\n\nint main(){\n    int n;\n    while(cin >> n && n > 0) {\n        vector<C> cs(n);\n        double max_r = 0;\n        double th = M_PI / 2;\n        REP(i, n) {\n            double r, x, y;\n            cin >> r >> x >> y;\n\n            P p(x, y);\n            p *= polar(1.0, th);\n\n            cs[i] = {p, r};\n\n            max_r = max(max_r, r);\n        }\n\n        sort(cs.begin(), cs.end());\n        double ans = 1e63;\n\n        REP(i, n) {\n            for(int j = i + 1; j < n; j++) {\n                if(ans < cs[j].p.real() - cs[i].p.real() - cs[i].r - max_r) {\n                    break;\n                }\n                ans = min(ans, abs(cs[i].p - cs[j].p) - cs[i].r - cs[j].r);\n            }\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <utility>\n#include <iomanip>\n#include <cmath>\nusing namespace std;\nconst double INF = 1e18;\ntypedef complex<double> P;\n#define X real()\n#define Y imag()\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n}\nP rotate(const P &p, double rad){\n    return p *P(cos(rad), sin(rad));\n}\n \nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<pair<P, double> > c(n);\n        double rmax = 0;\n        for(int i=0; i<n; i++){\n            double r,x,y;\n            cin >> r >> x >> y;\n            c[i] = make_pair(rotate(P(x, y), 114514), r);\n            rmax = max(rmax, r);\n        }\n        sort(c.begin(), c.end());\n\n        double ans = INF;\n        for(int i=0; i<n; i++){\n            for(int j=i-1; j>=0; j--){\n                if((c[j].first.X -c[i].first.X) -c[i].second -rmax > ans) break;\n                ans = min(ans, abs(c[i].first -c[j].first) -c[i].second -c[j].second);\n            }       \n        }\n        cout << fixed << setprecision(10);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a;cin>>a;\n\t\t\tP p=pin();\n\t\t\tp=turn(p,17);\n\t\t\tc.pb(C(p,a));\n\t\t}\n\t\tsort(all(c),[](C a,C b){\n\t\t\treturn a.c<b.c;\n\t\t});\n\t\tdouble out=inf;\n\t\trep(i,n){\n\t\t\tint r=max(0,i-10),l=min(i+10,n);\n\t\t\tloop(j,r,l)if(j!=i){\n\t\t\t\tout=min(out,abs(c[i].c-c[j].c)-c[i].r-c[j].r);\n\t\t\t}\n\t\t}\n\t\tcout<<shosu(9)<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){\n\n\treturn left.y < right.y;\n\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble calc_y_dist(int a,int b){\n\treturn (info[b].y-info[b].r)-(info[a].y+info[a].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2;\n\n\tdouble x = array[mid].x;\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid));\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y);\n\n\tvector<int> V;\n\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\n\t\tfor(int k = 0; k < min((int)V.size(),2); k++){\n\t\t\tdist = min(dist,calc_dist(V[V.size()-1-k],i));\n\t\t}\n\n\t\tV.push_back(i);\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<pair<double,double>,double> data;\n\ntemplate<class T> inline T dbl(T a){ return a * a; }\n\ninline double dist(const data &a, const data &b){\n  return sqrt(dbl(a.f.f - b.f.f) + dbl(a.f.s - b.f.s)) - (a.s + b.s);\n}\n\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n), n){\n    vector<data> v(n);\n\n    REP(i,n)\n      scanf(\"%lf%lf%lf\", &v[i].s, &v[i].f.f, &v[i].f.s);\n\n    double a1 = 0.0; REP(i,n) a1 += v[i].f.f; a1 /= n;\n    double a2 = 0.0; REP(i,n) a2 += v[i].f.s; a2 /= n;\n\n    double b1 = 0.0; REP(i,n) b1 += dbl(v[i].f.f - a1); b1 /= n;\n    double b2 = 0.0; REP(i,n) b2 += dbl(v[i].f.s - a2); b2 /= n;\n\n    if(b1 < b2) REP(i,n) swap(v[i].f.f, v[i].f.s);\n\n    sort(v.begin(), v.end());\n\n    double ans = 1e20;\n\n    for(int i = 0; i < v.size(); i++){\n      double x1 = v[i].f.f;\n      double r  = v[i].s;\n      for(int j = i + 1; j < v.size(); j++){\n\tdouble x2 = v[j].f.f;\n\n\tif((x2 - x1 + r) > ans) break;\n\n\tans = min(ans, dist(v[i], v[j]));\n      }\n    }\n    \n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<29\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\nP p[1000000];\nbool cmp_y(const P &a,const P &b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if(fabs( (a[i].F.F+a[i].S)-(x-r) ) >= d)continue;\n    }\n    else{\n      if( fabs((x+r)-(a[i].F.F+a[i].S)) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif( fabs( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S)     )   >= d )break;\n      }\n      else{\n\tif( fabs( (a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S)     )  >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int N;\n  double R,X,Y;\n\n  while(cin >> N && N){\n    for(int i=0;i<N;i++){\n      cin >> p[i].S >> p[i].F.F >> p[i].F.S;\n    }\n    sort(p,p+N);\n    printf(\"%.6f\\n\",rec(p,N));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct P{\n  double x,y,r;\n};\n\nP A[100000];\ndouble mr;\nint N;\n\ndouble closest_pair(P *a,int n){\n  if(n<=1)return 1e9;\n  int m=n/2;\n  double x=a[m].x;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,[](const P &a,const P &b){\n      return a.y<b.y;\n    });\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].x-x)>=d+2*mr)continue;\n    for(int j=0;j<b.size();j++){\n      auto bj=b[b.size()-j-1];\n      double dx=a[i].x-bj.x;\n      double dy=a[i].y-bj.y;\n      if(dy>=d+2*mr)break;\n      d=min(d,sqrt(dx*dx+dy*dy)-a[i].r-bj.r);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  while(cin>>N,N){\n    mr=0;\n    for(int i=0;i<N;i++){\n      cin>>A[i].r>>A[i].x>>A[i].y;\n      mr=max(mr,A[i].r);\n    }\n    sort(A,A+N,[](const P &a,const P &b){\n\treturn a.x<b.x;\n      });\n    cout<<fixed<<closest_pair(A,N)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ndouble x[110000];\ndouble y[110000];\ndouble r[110000];\npair<double,int>p[110000];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble tx,ty;\n\t\t\tscanf(\"%lf%lf%lf\",r+i,&tx,&ty);\n\t\t\tx[i]=cos(1)*tx-sin(1)*ty;\n\t\t\ty[i]=sin(1)*tx+cos(1)*ty;\n\t\t}\n\t\tdouble ret=sqrt((x[0]-x[1])*(x[0]-x[1])+(y[0]-y[1])*(y[0]-y[1]))-r[0]-r[1];\n\t\tfor(int i=0;i<a;i++){\n\t\t\tp[i]=make_pair(x[i]+r[i],i);\n\t\t}\n\t\tstd::sort(p,p+a);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tif(p[i].first-r[p[i].second]*2-p[j].first>ret)break;\n\t\t\t\tint L=p[i].second;\n\t\t\t\tint R=p[j].second;\n\t\t\t\tret=min(ret,sqrt((x[L]-x[R])*(x[L]-x[R])+(y[L]-y[R])*(y[L]-y[R]))-r[L]-r[R]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.12f\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){ //基準線より中心が左\n\t\tif(info[index].x+info[index].r+dist < x){\n\t\t\treturn false;\n\t\t}\n\n\t}else{ //基準線より中心が右\n\t\tif(info[index].x-info[index].r-dist > x){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble calc_y_dist(int a,int b){\n\treturn (info[b].y-info[b].r)-(info[a].y+info[a].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線x\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(!is_OK(i,x,dist))continue; //基準線より最小距離以上離れている点は無視(★異なる領域間での、新最小値を作り得ないということ★)\n\n\t\t//★★Vはyの昇順に並んでいる:自分よりy座標が小さいもののみ、入っている★★\n\n\t\t//2分探索で、検索範囲を定める\n\t\tleft = 0,right = V.size()-1,m = (left+right)/2;\n\t\tsearch_left = 0;\n\n\t\twhile(left <= right){\n\t\t\tif(calc_y_dist(V[m],i) < dist){ //y座標の差がdist未満\n\t\t\t\tsearch_left = m;\n\t\t\t\tright = m-1; //より左へ\n\t\t\t}else{\n\t\t\t\tleft = m+1; //より右へ\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tfor(int k = search_left; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}\n\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\n#define MAX_N (2000010)\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nstruct Circle\n{\n  P p; double r;\n  Circle(P p=P(0,0), double r=0.)\n    : p(p), r(r) {}\n};\n\nbool operator < (Circle const& a, Circle const& b) {\n  return a.p.real() < b.p.real();\n}\n\nbool compare_y(Circle const& a, Circle const& b) {\n  return a.p.imag() < b.p.imag();\n}\n\nint N;\nCircle A[MAX_N];\ndouble MaxR;\n\ndouble const INF = 1e60;\n\ninline double calc(Circle const& a, Circle const& b) {\n  double x = a.p.real()-b.p.real();\n  double y = a.p.imag()-b.p.imag();\n  return sqrt(x*x + y*y) - a.r - b.r;\n}\n\ndouble circle_closest_pair(Circle *a, int n) {\n  if(n <= 1) return INF;\n  int mid = n / 2;\n  double delta = min(circle_closest_pair(a, mid),\n\t\t     circle_closest_pair(a+mid, n-mid));\n  \n  //  delta += MaxR*2;\n  \n  // inplace_merge(BidirectionalIterator first, middle, last, Compare cmp);\n  inplace_merge(a, a+mid, a+n, compare_y);\n  \n  // merge\n  vector<Circle> b; // <- circles < delta\n  rep(i, n) {\n    double mid_x = a[mid].p.real();\n    if(abs(a[i].p.real()-mid_x) >= delta + 2.*MaxR) { continue; }\n    \n    rep(j, b.size()) {\n      int bid = (int)b.size()-1-j;\n      double dy = a[i].p.imag() - b[bid].p.imag();\n      if(delta + 2.*MaxR <= dy) { break; }\n      delta = min(delta, calc(a[i], b[bid]));\n    }\n    b.push_back(a[i]);\n  }\n  \n  return delta;\n}\n\nint main() {\n  \n  int N;\n  while(cin >> N && N) {\n    MaxR = 0.;\n    rep(i, N) {\n      //      cin >> A[i].r >> A[i].p.real() >> A[i].p.imag();\n      double x, y, r; cin >> r >> x >> y;\n      A[i].p = P(x, y); A[i].r = r;\n      MaxR = max(MaxR, A[i].r);\n    }\n    sort(A, A+N);\n    printf(\"%.8f\\n\", circle_closest_pair(A, N));\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst long double EPS = 1e-9;\nconst int MAX_N = 100000;\nconst long double INF = 1000000000000000000000000000000.0;\n\nbool equal(long double a, long double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   long double x, y, r;\n   Circle(){}\n   Circle(long double y, long double x, long double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   if(equal(a.y, b.y)){\n      return a.r > b.r;\n   }\n   return a.y < b.y;\n}\n\nlong double closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   long double x = a[m].x;\n   long double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) > d + a[i].r || equal(fabs(a[i].x - x), d+a[i].r)) continue;\n      for(int j=0;j<b.size();j++){\n         long double dx = a[i].x - b[b.size()-j-1].x;\n         long double dy = a[i].y - b[b.size()-j-1].y;\n         long double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy > d + dr || equal(dy, d+dr)) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      fill(A, A+N, Circle(INF, INF, INF));\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS 1e-10\ntypedef pair<double,int> P;\nstruct Point{double x,y,r;};\nint n;\nPoint p[100010];\n\ndouble cl(int i,int j,double k=0.0){\n  return sqrt(pow(p[i].x-p[j].x,2)+pow(p[i].y-p[j].y,2))-(p[i].r+p[j].r+k*2.0);\n}\n\nint solve(double k){\n  \n  vector<P> events;\n  \n  for(int i=0;i<n;i++){\n    double x1=p[i].x-p[i].r-k;\n    double x2=p[i].x+p[i].r+k;\n    events.push_back(P(x1,i));\n    events.push_back(P(x2,i+n));\n  }\n  sort(events.begin(),events.end());\n\n  set<P> outers;\n  for(int i=0;i<events.size();i++){\n    int id=events[i].second%n;\n    if(events[i].second<n){\n      set<P>::iterator it = outers.lower_bound(P(p[id].y,id));\n      if(it!=outers.end()&&cl(id,it->second,k)<=0)return 0;\n      if(it!=outers.begin()&&cl(id,(--it)->second,k)<=0)return 0;\n      outers.insert(P(p[id].y,id));\n    }else{\n      outers.erase(P(p[id].y,id));\n    }\n  }\n  return 1;\n}\n\nint main(){\n  \n  while(cin>>n,n){\n\n    for(int i=0;i<n;i++){\n      cin>>p[i].r>>p[i].x>>p[i].y;\n    }\n\n    double ok=0,ng=cl(0,1),mid;\n    while(ng-ok>EPS){\n      mid=(ok+ng)/2.0;\n      if(solve(mid))ok=mid;\n      else ng=mid;\n    }\n  \n    printf(\"%.10lf\\n\",ok*2.0);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-6;\nconst int MAX_N = 100000;\nconst double INF = 1000000000.0;\n\nbool equal(double a, double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   double x, y, r;\n   Circle(){}\n   Circle(double y, double x, double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\ndouble closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   double x = a[m].x;\n   double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) >= d + a[i].r) continue;\n      for(int j=0;j<b.size();j++){\n         double dx = a[i].x - b[b.size()-j-1].x;\n         double dy = a[i].y - b[b.size()-j-1].y;\n         double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy >= d + dr) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n \nusing namespace std;\n \nconst double eps = 1e-9;\n \n \nbool eq(double a, double b){\n  return abs(b-a)<eps;\n}\n \nbool ls(double a, double b){\n  return !eq(a,b) && a<b;\n}\n \nclass Point{\npublic:\n  double r,x,y;\n  bool operator<(const Point &a)const{\n    if(!eq(x,a.x))return ls(x,a.x);\n    return ls(y,a.y);\n  }\n   \n  double dist(const Point &a)const{\n    return sqrt((a.x-x)*(a.x-x)+(a.y-y)*(a.y-y))-r-a.r;\n  }\n};\n \ndouble min_val = 1e80;\nconst double MAXPOINT = 1e80;\n \nPoint BigPoint = {0,MAXPOINT,MAXPOINT};\n \nvoid Merge(Point *a, int l, int mid, int r, double midx){\n  int n1 = mid-l+1, n2 = r-mid,pr=0,pl=0;\n  Point L[n1+1], R[n2+1];\n  for(int i = 0; i < n1; ++i) L[i] = a[l+i];\n  for(int i = 0; i < n2; ++i) R[i] = a[mid+1+i];\n   \n  L[n1] = R[n2] = BigPoint;\n  for(int i = l; i < r + 1; ++i){\n    if( L[pl].y < R[pr].y ) a[i] = L[pl++];\n    else a[i] = R[pr++];\n  }\n  Point p1 = BigPoint, p2 = BigPoint, p3 = BigPoint, p4 = BigPoint;\n  for(int i = l; i < r+1; ++i){\n    //if( ls( abs(midx-a[i].x), min_val) ){\n      min_val = min(min_val, a[i].dist(p1));\n      min_val = min(min_val, a[i].dist(p2));\n      min_val = min(min_val, a[i].dist(p3));\n      min_val = min(min_val, a[i].dist(p4));\n      p1=p2;p2=p3;p3=p4;p4=a[i];\n      //}\n  }\n}\n \nvoid MergeSort( Point *a, int l, int r){\n  if(l<r){\n    int q = (r+l)/2;\n    double midx = a[q].x;\n    MergeSort(a,l,q);\n    MergeSort(a,q+1,r);\n    Merge(a,l,q,r,midx);\n  }\n}\n \nint main()\n{\n  int n;\n  while(cin >> n && n){\n    Point a[n];\n    min_val = 1e80;\n    for(int i = 0; i < n; ++i)cin>>a[i].r>>a[i].x>>a[i].y;\n    sort(a,a+n);\n    MergeSort(a,0,n-1);\n    cout << fixed << setprecision(10) << min_val << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = max(0,i-1000) ; j < min(i+1000,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = max(0,i-1000) ; j < min(i+1000,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n \ntypedef pair<double,double> P;\ntypedef pair<P,double> P2;\n \nP rot(P p, double a){\n  a=a*M_PI/180.0;\n  return P(p.first*cos(a)+p.second*(-sin(a)),\n  p.first*sin(a)+p.second*cos(a));\n}\n \ndouble abss(P a,P b){\n  return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));\n}\n \ndouble x,y,r;int tt;\nvector<P2>v;\nint main(){\n \n  int n;\n  while(cin >> n,n){\n \n    double ans=1e13;\n     \n    v.clear();\n   \n    r(i,n){\n      cin>>r>>x>>y;\n      v.push_back(P2(P(x,y),r));\n    }\n \n    r(i,1){\n      sort(v.begin(),v.end());\n      r(j,n){\n    for(int k=j+1,c=0;k<n;k++,c++){\n      if(c>50)break;\n      ans=min(ans,abss(v[k].first,v[j].first)-v[k].second-v[j].second);\n    }\n      }\n      r(j,n)v[i].first=rot(v[i].first,0.5);\n    }\n \n    printf(\"%.9f\\n\",ans);\n     \n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst double INF = 1e+12;\n\ndouble equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nstruct C{\n  P p;\n  double r;\n  C(P p=P(0,0),double r=0.0):p(p),r(r){}\n  bool operator < (const C &c) const {\n    return equal(real(p),real(c.p)) ? imag(p) < imag(c.p) : real(p) < real(c.p);\n  }\n};\n\n\nC v[100000];\nbool f;\n\nbool compare_y(C a, C b){\n  return imag(a.p) < imag(b.p);\n}\n\ndouble closest(C a[], int n){\n  if(n <= 1) return INF;\n  //if(f) return 0.0;\n  int m = n / 2;\n  double x = real(a[m].p);\n  double d = min(closest(a,m), closest(a+m,n-m));\n  inplace_merge(a, a+m, a+n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(real(a[i].p) - x) >= d || equal(fabs(real(a[i].p) - x),d)) continue;\n\n    for(int j=0;j<b.size();j++){\n      C bc = b[b.size()-j-1];\n      if(imag(a[i].p-bc.p) >= d || equal(imag(a[i].p-bc.p),d)) break;\n      //cout << a[i].p << ' ' << bc.p << endl;\n      d = min(d, abs(a[i].p-bc.p) - a[i].r - bc.r);\n      if(equal(d,0.0)){\n        f = true;\n        //return 0.0;\n      }\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> v[i].r >> x >> y;\n      v[i].p = P(x,y);\n    }\n    sort(v,v+n);\n    f = false;\n    assert(!(closest(v,n) < -EPS));\n    sort(v,v+n);\n    printf(\"%.6g\\n\",closest(v,n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct P{\n  double x,y,r;\n};\n\nP A[100000];\ndouble m;\nint N;\n\ndouble closest_pair(P *a,int n){\n  if(n<=1)return 1e9;\n  int m=n/2;\n  double x=a[m].x;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,[](const P &a,const P &b){\n      return a.y<b.y;\n    });\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].x-x)>=d+2*m)continue;\n    for(int j=0;j<b.size();j++){\n      auto bj=b[b.size()-j-1];\n      double dx=a[i].x-bj.x;\n      double dy=a[i].y-bj.y;\n      if(dy>=d+2*m)break;\n      d=min(d,sqrt(dx*dx+dy*dy)-a[i].r-bj.r);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  while(cin>>N,N){\n    m=0;\n    for(int i=0;i<N;i++){\n      cin>>A[i].r>>A[i].x>>A[i].y;\n      m=max(m,A[i].r);\n    }\n    sort(A,A+N,[](const P &a,const P &b){\n\treturn a.x<b.x;\n      });\n    cout<<fixed<<closest_pair(A,N)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-6;\nconst int MAX_N = 100000;\nconst double INF = 100000000.0;\n\nbool equal(double a, double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   double x, y, r;\n   Circle(){}\n   Circle(double y, double x, double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         /*if(equal(y, s.y)){\n            return r > s.r;\n            }*/\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\ndouble closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   double x = a[m].x;\n   double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) > d + a[i].r || equal(fabs(a[i].x - x), d+a[i].r)) continue;\n      for(int j=0;j<b.size();j++){\n         double dx = a[i].x - b[b.size()-j-1].x;\n         double dy = a[i].y - b[b.size()-j-1].y;\n         double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy > d + dr || equal(dy, d+dr)) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      fill(A, A+N, Circle(INF, INF, INF));\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\n\nclass C{\npublic:\n  P o;\n  ld r;\n  C(){}\n  C(P o, ld r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    return o.real() - r < s.o.real() - s.r;\n    //return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst ld INF = 1e77;\n\nbool compare_y(C a, C b){\n  return a.o.imag() - a.r < b.o.imag() - b.r;\n  //return a.o.imag() < b.o.imag();\n}\n\nld dist(C a, C b){\n  ld dx = a.o.real() - b.o.real();\n  ld dy = a.o.imag() - b.o.imag();\n  return max((ld)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\nld closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  ld x = a[m].o.real();\n  ld r = a[m].r;\n  ld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    bool f = false;\n    if(x > a[i].o.real()){\n      if(x - a[i].o.real() < d) f = true;\n      if(fabs(a[i].o.real() + a[i].r - x) < d) f = true;\n    }else{\n      if(a[i].o.real() - x < d) f = true;\n      if(fabs(a[i].o.real() - a[i].r - x) < d) f = true;\n    }\n    if(!f) continue;\n    //if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      ld dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(fabs(dy) >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      ld a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    //printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst double INF = 1e+12;\n\ndouble equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nstruct C{\n  P p;\n  double r;\n  C(P p=P(0,0),double r=0.0):p(p),r(r){}\n  bool operator < (const C &c) const {\n    return equal(real(p)+r,real(c.p)-c.r) ? imag(p)+r < imag(c.p)-c.r : real(p)+r < real(c.p)-c.r;\n  }\n};\n\n\nC v[100000];\nbool f;\n\nbool compare_y(C a, C b){\n  return imag(a.p)+a.r < imag(b.p)-b.r;\n}\n\ndouble closest(C a[], int n){\n  if(n <= 1) return INF;\n  if(f) return 0.0;\n  int m = n / 2;\n  double x = real(a[m].p);\n  double d = min(closest(a,m), closest(a+m,n-m));\n  inplace_merge(a, a+m, a+n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(real(a[i].p) - x)-a[i].r >= d || equal(fabs(real(a[i].p) - x)-a[i].r,d)) continue;\n\n    for(int j=0;j<b.size();j++){\n      C bc = b[b.size()-j-1];\n      if(imag(a[i].p-bc.p)-bc.r >= d || equal(imag(a[i].p-bc.p)-bc.r,d)) break;\n      //cout << a[i].p << ' ' << bc.p << endl;\n      d = min(d, abs(a[i].p-bc.p) - a[i].r - bc.r);\n      if(equal(d,0.0)){\n        f = true;\n        return 0.0;\n      }\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> v[i].r >> x >> y;\n      v[i].p = P(x,y);\n    }\n    sort(v,v+n);\n    f = false;\n    assert(!(closest(v,n) < -EPS));\n    sort(v,v+n);\n    printf(\"%.6g\\n\",closest(v,n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define MAX 2000000\n#define all(n) (n).begin(),(n).end()\nusing namespace std;\nstruct Circle\n{\n  double x,y,r;\n  Circle(double x=inf,double y=inf,double r=inf):x(x),y(y),r(r){}\n  bool operator < (const Circle& c)const\n  {\n    if(!equals(x,c.x))return x < c.x;\n    return y < c.y;\n  }\n};\n\nbool compare_y(Circle a,Circle b)\n{\n  return a.y < b.y;\n}\n\nint N;\nCircle A[MAX];\n\ndouble compute(Circle *a,int n)\n{\n  if(n <= 1)return inf;\n  int m = n/2;\n  double x = a[m].x;\n  double y = a[m].y;\n  double d = min(compute(a,m),compute(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Circle> b;\n  double r = a[m].r;\n  rep(i,n)\n    {\n      double nx = a[i].x - x;\n      double ny = a[i].y - y;\n      double ndist = sqrt(nx*nx + ny*ny) - a[i].r - r;\n      if(equals(ndist,d) || ndist > d)continue;\n\n      rep(j,b.size())\n\t{\n\t  int last = b.size()-j-1;\n\t  double dx = a[i].x - b[last].x;\n\t  double dy = a[i].y - b[last].y;\n\t  double dist = sqrt(dx*dx + dy*dy) - a[i].r - b[last].r;\n\t  if(equals(dist,d) || dist > d)break;\n\n\t    \n\t  d = min(d,sqrt(dx*dx + dy*dy) - a[i].r - b[last].r);\n\t}\n      b.push_back(a[i]);\n    }\n  return d;\n}\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      assert(N < MAX);\n      rep(i,N)cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A,A+N);\n\n\n      cout << setiosflags(ios::fixed) << setprecision(8) << compute(A,N) << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle{\n\tdouble x,y,r;\n\tbool operator < (const Circle &)const;\n};\n\nbool Circle::operator < (const Circle &a)const{\n\treturn sqrt(x*x+y*y)<sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble dist(const Circle &a,const Circle &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))-a.r-a.r;\n}\n\nconst int MAX_N=100000;\n\nint N;\nCircle c[MAX_N];\n\nvector<double> out;\n\nint main(){\n\tdo{\n\t\tscanf(\"%d\",&N);\n\t\tif (N){\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tscanf(\"%lf %lf %lf\",&c[i].r,&c[i].x,&c[i].y);\n\t\t\t}\n\t\t\tsort(c,c+N);\n\t\t\tdouble ans=dist(c[0],c[1]);\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tfor (int j=i+1;j<min(N,i+101);j++){\n\t\t\t\t\tans=min(ans,dist(c[i],c[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.push_back(ans);\n\t\t}\n\t}while(N);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%.8f\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) <1e-10+ min_val+2*maxr){\n      for(int j=p-1;j>=0 && abs(tarray[j].y-a[i].y)<min_val;j--){\n\tmin_val=min(tarray[j].dist(a[i]),min_val);\n      }\n      tarray[p++]=a[i];\n    }\n  }\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\n\nclass C{\npublic:\n  P o;\n  ld r;\n  C(){}\n  C(P o, ld r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst ld INF = 1e77;\n\nbool compare_y(C a, C b){\n  //return a.o.imag() - a.r < b.o.imag() - b.r;\n  return a.o.imag() < b.o.imag();\n}\n\nld dist(C a, C b){\n  ld dx = a.o.real() - b.o.real();\n  ld dy = a.o.imag() - b.o.imag();\n  return max((ld)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\nld closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  ld x = a[m].o.real();\n  ld r = a[m].r;\n  ld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    bool f = false;\n    if(x > a[i].o.real()){\n      if(x - a[i].o.real() < d) f = true;\n      if(fabs(a[i].o.real() + a[i].r - x) < d) f = true;\n    }else{\n      if(a[i].o.real() - x < d) f = true;\n      if(fabs(a[i].o.real() - a[i].r - x) < d) f = true;\n    }\n    if(!f) continue;\n    //if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      ld dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(dy >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      ld a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    //printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\ndouble max_r;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){ //基準線より中心が左\n\t\tif(info[index].x+info[index].r+dist < x-2*max_r){ //★★中心線より反対側に円がはみ出す場合がある\n\t\t\treturn false;\n\t\t}\n\n\t}else{ //基準線より中心が右\n\t\tif(info[index].x-info[index].r-dist > x+2*max_r){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線\n\tdouble r = array[mid].r; //半径\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\t//if(!is_OK(i,x,dist))continue; //異なる領域間での、新最小値を作り得ない場合は無視\n\t\tif(fabs(info[i].x-x)-(info[i].r+r) >= dist)continue;\n\n\t\tleft = 0,right = V.size()-1,m = (left+right)/2;\n\t\tsearch_left = V.size()-1;\n\n\t\t//Vはy座標の昇順にpushされている→自分よりy座標が小さいもののみが入っている\n\t\twhile(left <= right){\n\t\t\tif((info[i].y-info[i].r)-(info[m].y+info[m].r) < dist){ //y座標の差がdist未満の場合\n\t\t\t\tsearch_left = m;\n\t\t\t\tright = m-1; //より左へ\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tfor(int k = search_left; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tmax_r = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t\tmax_r = max(max_r,info[i].r);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) <1e-10+ min_val+2*maxr){\n      /*\n      for(int j=p-1;j>=0 && abs(tarray[j].y-a[i].y)<1e-10+2*maxr+min_val;j--){\n\tmin_val=min(tarray[j].dist(a[i]),min_val);\n      }\n      */\n      tarray[p++]=a[i];\n    }\n  }\n  rep(i,p){\n    REP(j,i+1,p && abs(tarray[j].y-tarray[i].y)<1e-10+2*maxr+min_val){\n      min_val=min(min_val,tarray[j].dist(a[i]));\n    }\n  }\n\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\ndouble max_r;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){ //基準線より中心が左\n\t\tif(info[index].x+info[index].r+dist < x-max_r){ //★★中心線より反対側に円がはみ出す場合がある\n\t\t\treturn false;\n\t\t}\n\n\t}else{ //基準線より中心が右\n\t\tif(info[index].x-info[index].r-dist > x+max_r){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(!is_OK(i,x,dist))continue; //異なる領域間での、新最小値を作り得ない場合は無視\n\n\t\tleft = 0,right = V.size()-1,m = (left+right)/2;\n\t\tsearch_left = V.size()-1;\n\n\t\t//Vはy座標の昇順にpushされている→自分よりy座標が小さいもののみが入っている\n\t\twhile(left <= right){\n\t\t\tif((info[i].y-info[i].r)-(info[m].y+info[m].r) < dist){ //y座標の差がdist未満の場合\n\t\t\t\tsearch_left = m;\n\t\t\t\tright = m-1; //より左へ\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tfor(int k = search_left; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tmax_r = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t\tmax_r = max(max_r,info[i].r);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nclass Circle{\npublic:\n  P cp;\n  double r;\n};\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double INF=-1;\nconst int band=100;\nint main(){\n  int n;\n  while(cin>>n&&n!=0){\n    int xsortedIdxs[100001];\n    int ysortedIdxs[100001];\n    vector<Circle> cs;\n    vector<pair<double,int> > xsorted;\n    vector<pair<double,int> > ysorted;\n    double x,y,r;\n    for(int i = 0; i < n; i++){\n      Circle c;\n      cin>>r>>x>>y;\n      c.r=r;\n      c.cp=P(x,y);\n      cs.push_back(c);\n      xsorted.push_back(make_pair(x,i));\n      ysorted.push_back(make_pair(y,i));\n    }\n    sort(xsorted.begin(),xsorted.end());\n    sort(ysorted.begin(),ysorted.end());\n    for(int i = 0; i < n; i++){\n      xsortedIdxs[xsorted[i].second]=i;\n      ysortedIdxs[ysorted[i].second]=i;\n    }\n    double minDist=INF;\n    for(int i = 0; i < n; i++){\n      // x,zÀW»ê¼êÉÂ¢ÄA\n      // ©ªÌê©ç-10,+10ÌÆ±ëðTõ\n      int xsidx=xsortedIdxs[i];\n      int ysidx=ysortedIdxs[i];\n      for(int j = xsidx; j < min(xsidx+band,n);j++){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = xsidx; j >= max(0,xsidx-band); j--){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j < min(ysidx+band,n);j++){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j >= max(0,ysidx-band); j--){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n    }\n    cout<<minDist<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//accepter by 10245\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point & a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point & a){\n    return sqrt((a.x-x)*(a.x-x)+(a.y-y)*(a.y-y))-r-a.r;\n  }\n};\ndouble min_val=10000;//need to insert Largest value\n#define MAXPOINT 1e250\nPoint BigPoint ={MAXPOINT,MAXPOINT};\ndouble maxr;\n\nvoid Merge(Point *a,int l,int mid,int r,double midx){\n  int n1 = mid-l+1,n2 = r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  for(int i=0;i<n1;i++)L[i]=a[l+i];\n  for(int i=0;i<n2;i++)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  for(int i=l;i<r+1;i++){\n    if ( L[pl].y < R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n\n  vector<Point> t;\n  for(int i=l;i<r+1;i++){\n    if ( abs(midx-a[i].x)< min_val+2*maxr){\n      t.push_back(a[i]);\n    } \n  }\n  for(int i=0;i<t.size();i++){\n    for(int j=i+1;j<t.size();j++){\n      min_val=min(min_val,t[i].dist(t[j]));\n    }\n  }\n\n\n}\n\n\nvoid MergeSort(Point *a,int l,int r){//include r that means <=r\n  if ( l<r){\n    int q = (r+l)/2;\n    double midx = a[q].x;\n    MergeSort(a,l,q);\n    MergeSort(a,q+1,r);\n    Merge(a,l,q,r,midx);\n  }\n}\n\n\nmain(){\nint n;\n  while(cin >>n && n){\n    min_val = 1e250;\n    Point a[n];\n    maxr=0;\n    for(int i=0;i<n;i++){\n      cin>>a[i].r>>a[i].x>>a[i].y;\n      maxr=max(maxr,a[i].r);\n    }\n    sort(a,a+n);\n    MergeSort(a,0,n-1);\n    printf(\"%.10lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\ntypedef complex<double> P;\n\nconst double inf = 1e100;\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(a.real() != b.real()) return a.real() < b.real();\n    return a.imag() < b.imag();\n  }\n}\n\nconst int MAXN = 100005;\nint N;\npair<P,double> ps[MAXN];\ndouble maxR[MAXN];\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].second >> ps[i].first.real() >> ps[i].first.imag();\n    }\n    sort(ps, ps+N);\n    maxR[N] = -inf;\n    for(int i = N-1; i >= 0; --i) {\n      maxR[i] = max(maxR[i+1], ps[i].second);\n    }\n    double ans = inf;\n    for(int i = 0; i < N; ++i) {\n      P p1 = ps[i].first;\n      double r1 = ps[i].second;\n      for(int j = i+1; j < N; ++j) {\n        P p2 = ps[j].first;\n        double r2 = ps[j].second;\n        if(p2.real() - p1.real() - r1 - maxR[j] >= ans) break;\n        double dist = sqrt((p1.real()-p2.real())*(p1.real()-p2.real())\n                           +(p1.imag()-p2.imag())*(p1.imag()-p2.imag())) - r1 - r2;\n        ans = min(ans, dist);\n      }\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst long double EPS = 1e-8;\nconst int MAX_N = 100000;\nconst long double INF = 1000000000000000.0;\n\nbool equal(long double a, long double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   long double x, y, r;\n   Circle(){}\n   Circle(long double y, long double x, long double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\nlong double closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   long double x = a[m].x;\n   long double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) >= d + a[i].r) continue;\n      for(int j=0;j<b.size();j++){\n         long double dx = a[i].x - b[b.size()-j-1].x;\n         long double dy = a[i].y - b[b.size()-j-1].y;\n         long double dr = a[i].r + b[b.size()-j-1].r;\n         //if(dy >= d) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define MAX 2000000\n#define all(n) (n).begin(),(n).end()\nusing namespace std;\nstruct Circle\n{\n  double x,y,r;\n  Circle(double x=inf,double y=inf,double r=inf):x(x),y(y),r(r){}\n  bool operator < (const Circle& c)const\n  {\n    if(!equals(x,c.x))return x < c.x;\n    return y < c.y;\n  }\n};\n\nbool compare_y(Circle a,Circle b)\n{\n  return a.y < b.y;\n}\n\nint N;\nCircle A[MAX];\n\ndouble compute(Circle *a,int n)\n{\n  if(n <= 1)return inf;\n  int m = n/2;\n  double x = a[m].x;\n  double y = a[m].y;\n  double r = a[m].r;\n  double d = min(compute(a,m),compute(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Circle> b;\n\n  rep(i,n)\n    {\n      double nx = a[i].x - x;\n      double ny = a[i].y - y;\n      double ndist = sqrt(nx*nx + ny*ny) - a[i].r - r;\n      //if(equals(ndist,d) || ndist > d)continue;\n      //if(nx >= d)continue;\n     \n      rep(j,(int)min((int)b.size(),10))\n\t{\n\t  int last = b.size()-j-1;\n\t  double dx = a[i].x - b[last].x;\n\t  double dy = a[i].y - b[last].y;\n\t  double dist = sqrt(dx*dx + dy*dy) - a[i].r - b[last].r;\n\n\t  if(equals(dist,d) || dist > d)continue;\n\t  d = min(d,sqrt(dx*dx + dy*dy) - a[i].r - b[last].r);\n\t}\n      b.push_back(a[i]);\n    }\n  return d;\n}\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      assert(N < MAX);\n      rep(i,N)cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A,A+N);\n\n\n      cout << setiosflags(ios::fixed) << setprecision(8) << compute(A,N) << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct P{\n  double x,y,r;\n};\n\nP A[100000];\ndouble m;\nint N;\n\ndouble closest_pair(P *a,int n){\n  if(n<=1)return 1e9;\n  int m=n/2;\n  double x=a[m].x;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,[](P a,P b){\n      return a.y<b.y;\n    });\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].x)-x>=d+2*m)continue;\n    for(int j=0;j<b.size();j++){\n      auto bj=b[b.size()-j-1];\n      double dx=a[i].x-bj.x;\n      double dy=a[i].y-bj.y;\n      if(dy>=d+2*m)break;\n      d=min(d,sqrt(dx*dx+dy*dy)-a[i].r-bj.r);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  while(cin>>N,N){\n    m=0;\n    for(int i=0;i<N;i++){\n      cin>>A[i].r>>A[i].x>>A[i].y;\n      m=max(m,A[i].r);\n    }\n    sort(A,A+N,[](P a,P b){\n\treturn a.x<b.x;\n      });\n    cout<<fixed<<closest_pair(A,N)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tdouble r;\n};\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nstruct cmp_y{\nbool operator()(const point<double> &a,const point<double> &b){\n\treturn a.y+EPS<b.y || abs(a.y-b.y)<EPS && a.x+EPS<b.x;\n}};\n\ndouble closest_pair(int n,point<double> *P){\n\tdouble r_max=0;\n\trep(i,n) r_max=max(r_max,P[i].r);\n\n\tsort(P,P+n);\n\n\tdouble d=dist(P[0],P[1])-P[0].r-P[1].r;\n\n\tset<point<double>,cmp_y> S;\n\tset<point<double>,cmp_y>::iterator it_l,it_r,it;\n\tfor(int i=0,j=0;i<n;i++){\n\t\tit_l=S.lower_bound((point<double>){0,P[i].y-d-1-2*r_max});\n\t\tit_r=S.upper_bound((point<double>){0,P[i].y+d+1+2*r_max});\n\n\t\tfor(it=it_l;it!=it_r;++it) d=min(d,dist(*it,P[i]));\n\n\t\twhile(2*r_max+d+EPS<P[i].x-P[j].x) S.erase(P[j++]);\n\t\tS.insert(P[i]);\n\t}\n\n\treturn d;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstatic point<double> P[100000];\n\t\trep(i,n) scanf(\"%lf%lf%lf\",&P[i].r,&P[i].x,&P[i].y);\n\t\tprintf(\"%f\\n\",closest_pair(n,P));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<29\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\nP p[200000];\nbool cmp_y(const P &a,const P &b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if(fabs( (a[i].F.F+a[i].S)-(x-r) ) >= d)continue;\n    }\n    else{\n      if( fabs((x+r)-(a[i].F.F+a[i].S)) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif( fabs( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S)     )   >= d )break;\n      }\n      else{\n\tif( fabs( (a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S)     )  >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int N;\n  double R,X,Y;\n\n  while(cin >> N && N){\n    for(int i=0;i<N;i++){\n      cin >> p[i].S >> p[i].F.F >> p[i].F.S;\n    }\n    sort(p,p+N);\n    printf(\"%.6f\\n\",rec(p,N));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tdouble r;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nstruct cmp_y{\nbool operator()(const point<double> &a,const point<double> &b){\n\treturn a.y+EPS<b.y || abs(a.y-b.y)<EPS && a.x+EPS<b.x;\n}};\n\ndouble closest_pair(int n,point<double> *P){\n\tsort(P,P+n);\n\n\tdouble d=dist(P[0],P[1])-P[0].r-P[1].r;\n\n\tset<point<double>,cmp_y> S;\n\tset<point<double>,cmp_y>::iterator it_l,it_r,it;\n\tfor(int i=0,j=0;i<n;i++){\n\t\tit_l=S.lower_bound((point<double>){0,P[i].y-d-1});\n\t\tit_r=S.upper_bound((point<double>){0,P[i].y+d+1});\n\n\t\tfor(it=it_l;it!=it_r;++it) d=min(d,dist(*it,P[i]));\n\n\t\twhile(d+EPS<P[i].x-P[j].x-P[i].r+P[j].r) S.erase(P[j++]);\n\t\tS.insert(P[i]);\n\t}\n\n\treturn d;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstatic point<double> P[100000];\n\t\trep(i,n) scanf(\"%lf%lf%lf\",&P[i].r,&P[i].x,&P[i].y);\n\n\t\tprintf(\"%f\\n\",closest_pair(n,P));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-5;\nconst int MAX_N = 100000;\nconst double INF = 100000000.0;\n\nbool equal(double a, double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   double x, y, r;\n   Circle(){}\n   Circle(double y, double x, double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\ndouble closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   double x = a[m].x;\n   double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) > d + a[i].r || equal(fabs(a[i].x - x), d+a[i].r)) continue;\n      for(int j=0;j<b.size();j++){\n         double dx = a[i].x - b[b.size()-j-1].x;\n         double dy = a[i].y - b[b.size()-j-1].y;\n         double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy > d + dr || equal(dy, d+dr)) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      fill(A, A+N, Circle(INF, INF, INF));\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<C>c;\n\t\trep(i,n){\n\t\t\tdouble a;cin>>a;\n\t\t\tP p=pin();\n\t\t\t//p=turn(p,17);\n\t\t\tc.pb(C(p,a));\n\t\t}\n\t\tsort(all(c),[](C a,C b){\n\t\t\treturn a.c<b.c;\n\t\t});\n\t\tdouble out=inf;\n\t\trep(i,n){\n\t\t\tint r=max(0,i-10),l=min(i+10,n);\n\t\t\tloop(j,r,l)if(j!=i){\n\t\t\t\tout=min(out,abs(c[i].c-c[j].c)-c[i].r-c[j].r);\n\t\t\t}\n\t\t}\n\t\tcout<<shosu(9)<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) < min_val+2*maxr){\n      for(int j=p-1;j>=0 && abs(tarray[j].y-a[i].y)<2*maxr+min_val;j--){\n\tmin_val=min(tarray[j].dist(a[i]),min_val);\n      }\n      tarray[p++]=a[i];\n    }\n  }\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n\n\nusing namespace std;\n\nconst int DIFF = 2000;\n\nstruct Circle{\n  double x,y,r;\n  bool operator < (const Circle& c) const{\n    return sqrt(x*x+y*y) < sqrt(c.x*c.x+c.y*c.y);\n  }\n};\n\ndouble dist(const Circle& c1, const Circle& c2){\n  return sqrt((c1.x-c2.x)*(c1.x-c2.x) + (c1.y-c2.y)*(c1.y-c2.y))-c1.r-c2.r;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<Circle> V(n);\n    for(int i = 0; i < n; i++) cin >> V[i].r >> V[i].x >> V[i].y;\n    \n    sort(V.begin(),V.end());\n\n    double ans = 1e50;\n\n    for(int i = 0; i < n; i++)\n      for(int j = max(0,i-DIFF); j < min(n, i+DIFF); j++){\n\tif(i == j) continue;\n\tans = min(ans,dist(V[i],V[j]));\n      }\n   \n    printf(\"%.5f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){ //基準線より中心が左\n\t\tif(info[index].x+info[index].r+dist < x){\n\t\t\treturn false;\n\t\t}\n\n\t}else{ //基準線より中心が右\n\t\tif(info[index].x-info[index].r-dist > x){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble calc_y_dist(int a,int b){\n\treturn (info[b].y-info[b].r)-(info[a].y+info[a].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線x\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\t//if(!is_OK(i,x,dist))continue; //基準線より最小距離以上離れている点は無視(★異なる領域間での、新最小値を作り得ないということ★)\n\n\t\t//★★Vはyの昇順に並んでいる:自分よりy座標が小さいもののみ、入っている★★\n\n\t\t//2分探索で、検索範囲を定める\n\t\t/*left = 0,right = V.size()-1,m = (left+right)/2;\n\t\tsearch_left = 0;\n\n\t\twhile(left <= right){\n\t\t\tif(calc_y_dist(V[m],i) < dist){ //y座標の差がdist未満\n\t\t\t\tsearch_left = m;\n\t\t\t\tright = m-1; //より左へ\n\t\t\t}else{\n\t\t\t\tleft = m+1; //より右へ\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}*/\n\n\t\t/*for(int k = search_left; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}*/\n\n\t\tfor(int k = 0; k < min((int)V.size(),2); k++){\n\t\t\tdist = min(dist,calc_dist(V[V.size()-1-k],i));\n\t\t}\n\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\n\nclass C{\npublic:\n  P o;\n  ld r;\n  C(){}\n  C(P o, ld r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst ld INF = 1e77;\n\nbool compare_y(C a, C b){\n  return a.o.imag() - a.r < b.o.imag() - b.r;\n  //return a.o.imag() < b.o.imag();\n}\n\nld dist(C a, C b){\n  ld dx = a.o.real() - b.o.real();\n  ld dy = a.o.imag() - b.o.imag();\n  return max((ld)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\nld closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  ld x = a[m].o.real();\n  ld r = a[m].r;\n  ld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    bool f = false;\n    if(x > a[i].o.real()){\n      if(x - a[i].o.real() < d) f = true;\n      if(fabs(a[i].o.real() + a[i].r - x) < d) f = true;\n    }else{\n      if(a[i].o.real() - x < d) f = true;\n      if(fabs(a[i].o.real() - a[i].r - x) < d) f = true;\n    }\n    if(!f) continue;\n    //if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      ld dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(fabs(dy) >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      ld a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    //printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nunsigned char memo[1<<20];\nint mask[5][5][6][6];\n\nvoid printS(int s){\n  int tmp[5][5];\n  fill(tmp[0], tmp[5], 0);\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      tmp[i][j] = s >> (i*5+j) & 1;\n    }\n  }\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      cout << tmp[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid init(){\n  fill(memo, memo + (1<<20), -1);\n  fill(mask[0][0][0], mask[5][0][0], 0);\n  for(int i=0;i<5;i++){\n    for(int j=0;j<5;j++){\n      for(int h=1;i+h<=5;h++){\n        for(int w=1;j+w<=5;w++){\n          int tmp = (1 << w) - 1 << j;\n          for(int k=0;k<h;k++){\n            mask[i][j][h][w] |= tmp << (i+k) * 5;\n          }\n        }\n      }\n    }\n  }\n  queue<int> q;\n  memo[0] = 0;\n  q.push(0);\n  while(!q.empty()){\n    int u = q.front();\n    q.pop();\n    for(int i=0;i<4;i++){\n      for(int j=0;j<5;j++){\n        for(int h=1;i+h<=4;h++){\n          for(int w=1;j+w<=5;w++){\n            int v = u ^ mask[i][j][h][w];\n            if(memo[v] > memo[u] + 1){\n              memo[v] = memo[u] + 1;\n              /*if((int)memo[v] == 2 && 0){\n                cout << \"cost = \" << (int)memo[v] << endl;\n                printS(v);\n                }*/\n              q.push(v);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nconst int INF = 1 << 28;\n\nint rec(int s, int t, int x, int cnt){\n  if(x == 5) return s == t ? cnt : INF;\n  int res = rec(s, t, x+1, cnt);\n  for(int i=0;i<5;i++){\n    for(int j=x;j<5;j++){\n      int nt = t ^ mask[i][x][5-i][j-x+1];\n      res = min(res, rec(s, nt, x+1, cnt+1));\n    }\n  }\n  return res;\n}\n\nint solve(int s){\n  int res = memo[s&(1<<20)-1];\n  return res + rec(s, s, 0, 0);\n}\n\nmain(){\n  init();\n  int n;\n  while(cin >> n && n){\n    int m = 0;\n    for(int i=0;i<n;i++){\n      int t = 0, c;\n      for(int j=0;j<n;j++){\n        cin >> c;\n        t |= c << j;\n      }\n      m |= t << i * 5;\n    }\n    int ans = n < 5 ? memo[m] : solve(m);\n    for(int i=0;i<ans;i++){\n      cout << \"myon\";\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nclass Circle{\npublic:\n  P cp;\n  double r;\n};\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double INF=-1;\nconst int band=2;\nint main(){\n  int n;\n  while(cin>>n&&n!=0){\n    int xsortedIdxs[100001];\n    int ysortedIdxs[100001];\n    vector<Circle> cs;\n    vector<pair<double,int> > xsorted;\n    vector<pair<double,int> > ysorted;\n    double x,y,r;\n    for(int i = 0; i < n; i++){\n      Circle c;\n      cin>>r>>x>>y;\n      c.r=r;\n      c.cp=P(x,y);\n      cs.push_back(c);\n      xsorted.push_back(make_pair(x,i));\n      ysorted.push_back(make_pair(y,i));\n    }\n    sort(xsorted.begin(),xsorted.end());\n    sort(ysorted.begin(),ysorted.end());\n    for(int i = 0; i < n; i++){\n      xsortedIdxs[xsorted[i].second]=i;\n      ysortedIdxs[ysorted[i].second]=i;\n    }\n    double minDist=INF;\n    for(int i = 0; i < n; i++){\n      // x,zÀW»ê¼êÉÂ¢ÄA\n      // ©ªÌê©ç-10,+10ÌÆ±ëðTõ\n      int xsidx=xsortedIdxs[i];\n      int ysidx=ysortedIdxs[i];\n      for(int j = xsidx; j < min(xsidx+band,n);j++){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = xsidx; j >= max(0,xsidx-band); j--){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j < min(ysidx+band,n);j++){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j >= max(0,ysidx-band); j--){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n    }\n    printf(\"%.8f\\n\",minDist);\n    //cout<<minDist<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\n\nclass C{\npublic:\n  P o;\n  ld r;\n  C(){}\n  C(P o, ld r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst ld INF = 1e77;\n\nbool compare_y(C a, C b){\n  return a.o.imag() - a.r < b.o.imag() - b.r;\n  //return a.o.imag() < b.o.imag();\n}\n\nld dist(C a, C b){\n  ld dx = a.o.real() - b.o.real();\n  ld dy = a.o.imag() - b.o.imag();\n  return max((ld)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\nld closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  ld x = a[m].o.real();\n  ld r = a[m].r;\n  ld d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      ld dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(fabs(dy) >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      ld a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    //printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) < min_val+2*maxr){\n      rep(j,p){\n\tmin_val=min(tarray[j].dist(a[i]),min_val);\n      }\n      tarray[p++]=a[i];\n    }\n  }\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  //return a.o.imag() - a.r < b.o.imag() - b.r;\n  return a.o.imag() < b.o.imag();\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max(0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(fabs(dy) >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    printf(\"%.8f\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle{\n\tdouble x,y,r;\n\tbool operator < (const Circle &)const;\n};\n\nbool Circle::operator < (const Circle &a)const{\n\treturn sqrt(x*x+y*y)<sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble dist(const Circle &a,const Circle &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))-a.r-b.r;\n}\n\nconst int MAX_N=100000;\n\nint N;\nCircle c[MAX_N];\n\nvector<double> out;\n\nint main(){\n\tdo{\n\t\tscanf(\"%d\",&N);\n\t\tif (N){\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tscanf(\"%lf %lf %lf\",&c[i].r,&c[i].x,&c[i].y);\n\t\t\t}\n\t\t\tsort(c,c+N);\n\t\t\tdouble ans=dist(c[0],c[1]);\n\t\t\tprintf(\"%.8f\\n\",ans);\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tfor (int j=i+1;j<min(N,i+2001);j++){\n\t\t\t\t\tans=min(ans,dist(c[i],c[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.push_back(ans);\n\t\t}\n\t}while(N);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%.8f\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double y,double dist){\n\tif(info[index].x < x){\n\t\tif(info[index].x+info[index].r+dist < x){\n\t\t\treturn false;\n\t\t}\n\n\t}else{\n\t\tif(info[index].x-info[index].r-dist > x){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif(info[index].y > y){\n\t\tif(info[index].x-info[index].r-dist > x){\n\t\t\treturn false;\n\t\t}\n\t}else{\n\t\tif(info[index].x+info[index].r+dist < x){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2;\n\n\tdouble x = array[mid].x;\n\tdouble y = array[mid].y;\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid));\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y);\n\n\tvector<int> V;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(!is_OK(i,x,y,dist))continue;\n\n\t\tfor(int k = 0; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}\n\t\tV.push_back(i);\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<double> P;\n\nclass C{\npublic:\n  P o;\n  double r;\n  C(){}\n  C(P o, double r) : o(o), r(r){}\n  bool operator < (const C &s) const {\n    //return o.real() - r < s.o.real() - s.r;\n    return o.real() < s.o.real();\n  }\n};\n\nconst int N = 100000;\nconst double INF = 1e77;\n\nbool compare_y(C a, C b){\n  //return a.o.imag() - a.r < b.o.imag() - b.r;\n  return a.o.imag() < b.o.imag();\n}\n\ndouble dist(C a, C b){\n  double dx = a.o.real() - b.o.real();\n  double dy = a.o.imag() - b.o.imag();\n  return max((double)0.0, sqrt(dx * dx + dy * dy) - a.r - b.r);\n}\n\ndouble closest_pair(C *a, int n){\n  if(n <= 1) return INF; \n  int m = n / 2;\n  double x = a[m].o.real();\n  double r = a[m].r;\n  double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n  inplace_merge(a, a + m, a + n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    bool f = false;\n    if(x > a[i].o.real()){\n      if(a[i].o.real() <= x && x <= a[i].o.real() + a[i].r) f = true;\n    }else{\n      if(a[i].o.real() - a[i].r <= x && x <= a[i].o.real()) f = true;\n    }\n    if(!f) continue;\n    //if(fabs(fabs(a[i].o.real() - x) - a[i].r) >= d) continue;\n    for(int j=0;j<b.size();j++){\n      int id = (int)b.size()-j-1;\n      double dy = a[i].o.imag() - b[id].o.imag() - a[i].r - b[id].r;\n      if(dy >= d) break;\n      d = min(d, dist(a[i], b[id]));\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nmain(){\n  int n;\n  static C A[N];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double a, b, c;\n      cin >> c >> a >> b;\n      A[i] = C(P(a, b), c);\n    }\n    /*for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        printf(\"%d %d %.8f\\n\", i, j, dist(A[i], A[j]));\n      }\n      }*/\n    sort(A, A+n);\n    //cout << fixed << setprecision(8) << closest_pair(A, n) << endl;\n    printf(\"%.8lf\\n\", closest_pair(A, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\n// \tVerified: AOJ 0081 A Symmetric Point\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t三角形の面積（外積）\n\n\t説明\n\t\t三頂点で定まる三角形の面積（の２倍）を求める\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n*/\ntemplate<class T>\nT area2(const point<T> &a, const point<T> &b, const point<T> &c ){\n\treturn abs(cross(b-a,c-a));\n}\n/*\n\t三角形の面積（Heron）\n\n\t説明\n\t\t三辺の長さで定まる三角形の面積を求める\n\t引数\n\t\ta : 一辺の長さ\n\t\tb : 一辺の長さ\n\t\tc : 一辺の長さ\n\t戻り値\n\t\t三角形の面積\n\t\t三角形が作れないとき、縮退しているときには 0\n\t制約\n\t\ta>=0, b>=0, c>=0\n\t\ta<b+c, b<c+a, c<a+b（三角形の成立条件）\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble area(double a, double b, double c ){\n\treturn sqrt((a+b-c)*(b+c-a)*(c+a-b)*(a+b-c))/4.;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079: Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n// (B)\n\n//enum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t線分と線分の距離\n*/\n\n/*\n\t三角形と点の包含判定\n\n\t説明\n\t\t三角形 abc が点 p を含むかどうかを判定する\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\t三角形は縮退していないこと\n\t\tすなわち、三点が同一直線上にないこと、（特に、どの二点も等しくないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形は CCW でも CW でもよい\n\t\t点が三角形の境界になるときは含むと判定する\n\t\tVerified: AOJ 0012: A Point in a Triangle\n\t\tVerified: AOJ 0143: Altair and Vega \n*/\ntemplate<class T>\nbool cover(const point<T> &a, const point<T> &b, const point<T> &c, const point<T> &p ){\n\tint d1 = ccw (p, a, b );\n\tint d2 = ccw (p, b, c );\n\tint d3 = ccw (p, c, a );\n\treturn !((d1 == CCW && d2 == CW ) || (d1 == CCW && d3 == CW ) || (d2 == CCW && d3 == CW ) || (d1 == CW && d2 == CCW ) || (d1 == CW && d3 == CCW ) || (d2 == CW && d3 == CCW ) );\n}\n\n/*\n\t直線と点の包含判定\n*/\n\n/*\n\t線分と点の包含判定\n*/\n\n/*\n\t多角形と点の包含判定\n*/\n\n/*\n\t多角形と多角形の包含判定\n*/\n\n/*\n\t円と点の包含判定\n\n\t説明\n\t\t円が点を含むかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tp : 点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\n// (A)\ntemplate<class T>\nbool cover (const circle<T> &C, const point<T> &p ){\n\treturn dist2(C.c, p) <= C.r*C.r;\n}\n\n// (B)\nbool cover (const circle<double> &C, const point<double> &p ){\n\treturn dist (C.c, p ) < C.r + EPS;\n}\n\n/*\n\t直線と直線の交差判定\n*/\n\n/*\n\t直線と線分の交差判定\n*/\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t多角形と線分の交差判定\n\n\t説明\n\t\t多角形と線分が交わるかどうかを判定する\n\t引数\n\t\tG : 多角形\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n)\n\t備考\n\t\tG は凸でなくていい。\n\t\tG は境界を含む\n\t\tS が G の内部にあるときは交わると判定する\n*/\ntemplate<class T>\nbool intersect(const polygon<T> &G, const segment<T> &S ){\n\tint n = G.size();\n\tif (cover(G, S.a ) || cover (G, S.b ) ) return true;\n\trep (i, n ) if (intersect((segment<T>){G[i], G[(i+1)%n]}, S ) ) return true;\n\treturn false;\n}\n\n/*\n\t多角形と多角形の交差判定\n*/\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\n/*\n\t二直線の交点\n\n\t説明\n\t\t二直線の交点を求める\n\t\t(A)（直線を特徴付ける点の）座標値が整数\n\t\t(B)（直線を特徴付ける点の）座標値が実数\n\t引数\n\t\tL1 : 直線\n\t\tL2 : 直線\n\t戻り値\n\t\tL1 と L2 の交点\n\t制約\n\t\t二直線は交点を持つこと。（平行でない or L1 == L2 )\n\t計算量\n\t\tO(1)\n\t備考\n\t\t交点が複数あるとき（L1 == L2）は L1.a を返す。\n\t\tこの仕様は線分 S と直線 L の交点を求めたいとき重要。\n\t\t（ S と L が同一直線上にあるときにも、S を第１引数に指定することで交点が正しく求まる。）\n\n*/\n// (A)\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1, const line<T> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1==0) return L1.a;\t// L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n// (B)\npoint<double> get_intersect(const line<double> &L1, const line<double> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1<EPS) return L1.a;\t// L1 == L2\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n/*\n\t二線分の交点\n*/\n\n/*\n\t円と直線の交点\n*/\n\n/*\n\t円と円の交点\n\n\t説明\n\t\t円と円の交点を求める\n\t引数\n\t\tC1 : 円\n\t\tC2 : 円\n\t\tres : 計算結果（交点の集合）\n\t戻り値\n\t\t交点の個数\n\t\tただし、交点が無限個になる（２つの円が等しい）ときは -1\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tres は初期化されない\n\t\t交点が無限個あるときは res には何も追加されない\n\t\tVerified: AOJ 0090 Overlaps of Seals\n*/\nint get_intersect(const circle<double> &C1, const circle<double> &C2, vector< point<double> > &res ){\n\tdouble r1=C1.r,r2=C2.r;\n\tpoint<double> p1=C1.c,p2=C2.c;\n\n\tdouble d=abs(p1-p2);\n\tif (d<EPS && abs(r1-r2)<EPS ){\t// C1 == C2\n\t\treturn -1;\n\t}else\n\tif (r1+r2<d-EPS || d+EPS<abs(r1-r2) ){\n\t\treturn 0;\n\t}else{\n\t\tdouble a = (r1*r1-r2*r2+d*d)/(2.*d);\n\t\tdouble h = sqrt(max(r1*r1-a*a, 0. ) );\n\t\tpoint<double> tmp1 = p1+a/d*(p2-p1);\n\t\tpoint<double> tmp2 = h/d*(p2-p1);\n\t\tif (abs(tmp2)<EPS ){\n\t\t\tres.push_back (tmp1 );\n\t\t\treturn 1;\n\t\t}else{\n\t\t\tres.push_back ((point<double>){tmp1.x-tmp2.y, tmp1.y+tmp2.x});\n\t\t\tres.push_back ((point<double>){tmp1.x+tmp2.y, tmp1.y-tmp2.x});\n\t\t\treturn 2;\n\t\t} // end if\n\t} // end if\n}\n\n/*\n\t点から円に引いた接線の交点\n*/\n\n/*\n\t円と円の共通接線\n*/\n\n/*\n\t垂直二等分線\n\n\t説明\n\t\t二点 a, b の垂直二等分線を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\ta と b の垂直二等分線\n\t計算量\n\t\tO(1)\n\t備考\n\t\t垂直二等分線を L とすると、L.a から L.b の方向を見たとき、左手に点 a が来る。\n*/\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a, const point<T> &b ){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0, (a.y+a.x+b.y-b.x)/2.0 },\n\t\t\t\t\t\t\t(point<double>){(a.x+a.y+b.x-b.y)/2.0, (a.y-a.x+b.y+b.x)/2.0 }};\n}\n\n/*\n\t点対称\n\n\t説明\n\t\t点 b を基準に点 a を点対称を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点対称の点\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\npoint<T> symmetry_point (const point<T> a, const point<T> b )\n{\n\treturn (point<T>){2*b.x-a.x, 2*b.y-a.y};\n}\n\n/*\n\t多角形の重心の座標\n\n\t説明\n\t\t頂点数 n の凸多角形をひとつの頂点を基準に n - 2 個の三角形に分割した三角形の面積を Sk,\n\t\t重心を gk とおくと n の凸多角形の重心 G は\n\n\t\tG = \\sum_{k=1}^{n-2}Sk*gk/(\\sum_{k=1}^{n-2}Sk)\n\n\t\tで求められる。\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t点\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 2442: ConvexCut しかし EPS=1e-6 にしないと WA.\n*/\ntemplate<class T>\npoint<T> centerG(const polygon<T> &G ){\n\tint n = G.size();\n\tdouble S = 0.;\n\tpoint<double> g; g.x = 0.; g.y = 0.;\n\tint u = G.size()-1;\n\tfor (int i = 0; i < n; u=i++ ){\n\t\tdouble sk = cross (G[u], G[i] );\n\t\tS += sk;\n\t\tg.x += (G[u].x + G[i].x)*sk;\n\t\tg.y += (G[u].y + G[i].y)*sk;\n\t} // end for\n\tg /= (3.*S);\n\n\treturn g;\n/*\n\tint n = G.size();\n\tdouble ar = 0.;\n\tdouble x = 0., y = 0.;\n\trep (i, n - 2 ){\n\t\tdouble k = area2 (G[n-1], G[i], G[i+1] );\n\t\tar += k;\n\t\tx += (G[n-1].x + G[i].x)*k;\n\t\ty += (G[n-1].y + G[i].y)*k;\n\t} // end rep\n\tx /= (3.*ar );\n\ty /= (3.*ar );\n\t\n\treturn (point<T>){x,y};\n*/\n}\n\n/*\n\t二点と半径で定まる円\n*/\n\n/*\n\t凸性判定\n\t\n\t説明\n\t\t多角形が凸かどうかを判定する\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tG は単調かつ頂点の順番が CCW で与えられていること\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\ntemplate<class T>\nbool is_convex(const polygon<T> &G ){\n\tint n = G.size();\n\trep (i, n ) if (ccw (G[i], G[(i+1)%n], G[(i+2)%n])== CW ) return false;\n\treturn true;\n}\n\n/*\n\t凸包\n\n\t説明\n\t\t点集合の凸包を求める\n\t引数\n\t\tP : 点集合\n\t戻り値\n\t\tP の凸包\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n log n )\n\t備考\n\t\tP は破壊される。\n\n\t\tsort は (x, y ) の辞書順。\n\n\t\t凸包の同じ直線上にある頂点は端のものだけを拾う。\n\t\t辺上になる頂点を全部拾うようにしたいときは != CCW を ==CW と修正すればよい。\n*/\ntemplate<class T>\npolygon<T> convex_hull(vector< point<T> > &P ){\n\tint n = P.size();\n\tpolygon<T> CH;\n\tif (n <= 1 ){\n\t\tCH.insert (CH.end(), P.begin(), P.end() );\n\t\treturn CH;\n\t} // end if\n\tsort (ALL (P ) );\n\trep (cnt, 2 ){\n\t\tint m = 0;\n\t\tvector< point<T> > half(n );\n\t\trep (i, n ){\n\t\t\thalf[m++] = P[i];\n\t\t\twhile (m >= 3 && ccw (half[m-3], half[m-2], half[m-1] ) != CCW ){\n\t\t\t\thalf[m-2] = half[m-1];\n\t\t\t\tm--;\n\t\t\t} // end while\n\t\t} // end rep\n\t\tCH.insert (CH.end(), half.begin(), half.begin()+m-1 );\n\t\treverse (ALL (P ) );\n\t} // end rep\n\t\n\treturn CH;\n}\n\n/*\n\t凸多角形の切断\n*/\n\n/*\n\t内接円の半径\n\n\t説明\n\t\t辺長がそれぞれ、a, b, c である三角形の内接円の半径を求める\n\t引数\n\t\ta: 辺長\n\t\tb: 辺長\n\t\tc: 辺長\n\t戻り値\n\t\t内接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, c < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble inradius(double a, double b, double c ){\n\treturn sqrt ((b+c-a)*(c+a-b)*(a+b-c)/(a+b+c))/2.;\n}\n\n/*\n\t外接円\n\n\t説明\n\t\t三角形 abc の外接円を求める\n\t引数\n\t\ta: 頂点\n\t\tb: 頂点\n\t\tc: 頂点\n\t戻り値\n\t\t外接円\n\t制約\n\t\ta, b, c は同一直線上にないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\ta, b, c が同一直線上にあるときは外接円は存在しない\n\t\t頂点が整数座標のとき、外心の座標と半径の二乗は有理数となる\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ncircle<double> circumcircle(const point<double> &a, point<double> b, point<double> c ){\n\tb-=a; c-=a;\n\tdouble A2 = abs2(b-c), B2 = abs2(b), C2 = abs2(c);\n\tdouble d = 2*cross(b,c);\n\tdouble nx = c.y*B2-b.y*C2;\n\tdouble ny = b.x*C2-c.x*B2;\n\tdouble r2 = A2*B2*C2/(d*d);\n\treturn (circle<double>){a+(point<double>){nx/d, ny/d}, sqrt(r2)};\n}\n\n/*\n\t外接円の半径\n\t\n\t説明\n\t\t辺長がそれぞれ a, b, c である三角形の外接円の半径を求める\n\t引数\n\t\ta : 辺長\n\t\tb : 辺長\n\t\tc : 辺長\n\t戻り値\n\t\t外接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, b < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ndouble circumradius(double a, double b, double c ){\n\treturn a*b*c/sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c) );\n}\n\n/*\n\t最小包含球\n*/\n\n/*\n\t線分アレンジメント\n*/\n\n/*\n\t最近点対\n\n\t説明\n\t\t最近点対問題を解く\n\t引数\n\t\tn : 点の個数\n\t\tp : 点集合\n\t戻り値\n\t\t最近点対の距離\n\t制約\n\t\tn>=2\n\t計算量\n\t\tO(n log n)\n\t備考\n\t\tsort は (x,y) の辞書順。\n\t\tP の順番は破壊される（内部でソートするため）\n*/\nstruct cmp_y{\nbool operator()(const point<double> &a, const point<double> &b ){\n\treturn (a.y+EPS<b.y || (abs(a.y-b.y)<EPS && a.x+EPS<b.x ) );\n}};\n\ndouble closest_pair(int n, point<double> *P){\n\tsort (P, P+n );\n\tdouble d = dist(P[0],P[1] );\n\tset<point<double>, cmp_y> S;\n\tset<point<double>, cmp_y>::iterator it_l, it_r, it;\n\tfor (int i = 0, j = 0; i < n; i++ ){\n\t\tit_l = S.lower_bound ((point<double>){0,P[i].y-d-1.});\n\t\tit_r = S.upper_bound ((point<double>){0,P[i].y+d+1.});\n\t\tfor (it=it_l;it!=it_r;++it) d=min(d, dist(*it,P[i]));\n\t\twhile(P[i].x-P[j].x>d+EPS ) S.erase(P[j++] );\n\t\tS.insert(P[i] );\n\t} // end for\n\n\treturn d;\n}\n\n/*\n\t楕円の周長\n*/\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.2057\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tpoint<double> p[n];\n\t\tdouble r;\n\t\trep (i, n ) scanf (\"%lf %lf %lf\",&p[i].x, &p[i].y, &r );\n\t\tdouble res = closest_pair(n, p );\n\t\tprintf (\"%.5lf\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\ndouble max_r;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線\n\tdouble r = array[mid].r; //半径\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\tdouble diff_y;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(fabs(info[i].x-x)-(info[i].r+r) >= dist)continue; //基準円とのx座標の距離の差がdist以上ならSKIP\n\n\t\tfor(int k = 0; k < V.size(); k++){\n\t\t\tdiff_y = info[i].y-info[V[V.size()-1-k]].y;\n\t\t\tif(diff_y >= dist+r+info[i].r)break;\n\t\t\tdist = min(dist,calc_dist(V[V.size()-1-k],i));\n\t\t}\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tmax_r = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t\tmax_r = max(max_r,info[i].r);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<iomanip>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define MAX 2000000\n#define all(n) (n).begin(),(n).end()\nusing namespace std;\nstruct Circle\n{\n  double x,y,r;\n  Circle(double x=inf,double y=inf,double r=inf):x(x),y(y),r(r){}\n  bool operator < (const Circle& c)const\n  {\n    if(!equals(x,c.x))return x < c.x;\n    return y < c.y;\n  }\n};\n\nbool compare_y(Circle a,Circle b)\n{\n  return a.y < b.y;\n}\n\nint N;\nCircle A[MAX];\n\ndouble compute(Circle *a,int n)\n{\n  if(n <= 1)return inf;\n  int m = n/2;\n  double x = a[m].x;\n  double y = a[m].y;\n  double r = a[m].r;\n  double d = min(compute(a,m),compute(a+m,n-m));\n  inplace_merge(a,a+m,a+n,compare_y);\n\n  vector<Circle> b;\n\n  rep(i,n)\n    {\n      double nx = a[i].x - x;\n      double ny = a[i].y - y;\n      double ndist = sqrt(nx*nx + ny*ny) - a[i].r - r;\n      //if(equals(ndist,d) || ndist > d)continue;\n      //if(nx >= d)continue;\n     \n      rep(j,(int)min((int)b.size(),5))\n\t{\n\t  int last = b.size()-j-1;\n\t  double dx = a[i].x - b[last].x;\n\t  double dy = a[i].y - b[last].y;\n\t  double dist = sqrt(dx*dx + dy*dy) - a[i].r - b[last].r;\n\n\t  if(equals(dist,d) || dist > d)continue;\n\t  d = min(d,sqrt(dx*dx + dy*dy) - a[i].r - b[last].r);\n\t}\n      b.push_back(a[i]);\n    }\n  return d;\n}\n\n\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      assert(N < MAX);\n      rep(i,N)cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A,A+N);\n\n\n      cout << setiosflags(ios::fixed) << setprecision(8) << compute(A,N) << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst double INF = 1e+12;\n\ndouble equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nstruct C{\n  P p;\n  double r;\n  C(P p=P(0,0),double r=0.0):p(p),r(r){}\n  bool operator < (const C &c) const {\n    return equal(real(p)+r,real(c.p)-c.r) ? imag(p)+r < imag(c.p)-c.r : real(p)+r < real(c.p)-c.r;\n  }\n};\n\n\nC v[100000];\nbool f;\n\nbool compare_y(C a, C b){\n  return imag(a.p)+a.r < imag(b.p)-b.r;\n}\n\ndouble closest(C a[], int n){\n  if(n <= 1) return INF;\n  if(f) return 0.0;\n  int m = n / 2;\n  double x = real(a[m].p);\n  double d = min(closest(a,m), closest(a+m,n-m));\n  inplace_merge(a, a+m, a+n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(real(a[i].p) - x)-a[i].r-a[m].r >= d || equal(fabs(real(a[i].p) - x)-a[i].r-a[m].r,d)) continue;\n\n    for(int j=0;j<b.size();j++){\n      C bc = b[b.size()-j-1];\n      if(imag(a[i].p-bc.p)-bc.r-a[i].r >= d || equal(imag(a[i].p-bc.p)-bc.r-a[i].r,d)) break;\n      //cout << a[i].p << ' ' << bc.p << endl;\n      d = min(d, abs(a[i].p-bc.p) - a[i].r - bc.r);\n      if(equal(d,0.0)){\n        f = true;\n        return 0.0;\n      }\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> v[i].r >> x >> y;\n      v[i].p = P(x,y);\n    }\n    sort(v,v+n);\n    f = false;\n    assert(!(closest(v,n) < -EPS));\n    sort(v,v+n);\n    printf(\"%.6g\\n\",closest(v,n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\ntypedef double DD;\n\nconst DD INF = 1LL<<60;\nconst DD EPS = 1e-10;\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\nPoint operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\nPoint operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\nPoint conj(const Point &p) {return Point(p.x, -p.y);}\nPoint rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(const Point &p) {return Point(-p.y, p.x);}\nDD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\nDD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\nDD norm(const Point &p) {return dot(p, p);}\nDD abs(const Point &p) {return sqrt(dot(p, p));}\nDD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\nbool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\nbool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\nbool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\nPoint operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n};\n\nstruct Circle : Point{\n    DD r;\n    Circle(Point p = Point(0.0, 0.0), DD r = 0.0) : Point(p), r(r) {}\n};\n\n\nDD MAX_R;\nbool compare_y(Circle a, Circle b) { return a.y < b.y; }\n\nDD Rec(vector<Circle>::iterator it, int n) {\n    if (n <= 1) return INF;\n    int m = n/2;\n    DD x = it[m].x;\n    DD d = min(Rec(it, m), Rec(it+m, n-m));\n    inplace_merge(it, it+m, it+n, compare_y);\n    \n    vector<Circle> vec;\n    for (int i = 0; i < n; ++i) {\n        if (fabs(it[i].x - x) >= d + MAX_R*2) continue;\n        for (int j = 0; j < vec.size(); ++j) {\n            DD dx = it[i].x - vec[vec.size()-j-1].x;\n            DD dy = it[i].y - vec[vec.size()-j-1].y;\n            if (dy >= d + MAX_R*2) break;\n            d = min(d, abs(sqrt(dx*dx+dy*dy) - it[i].r - vec[vec.size()-j-1].r));\n        }\n        vec.push_back(it[i]);\n    }\n    return d;\n}\n\nDD Closet(vector<Circle> vc) {\n    int n = vc.size();\n    sort(vc.begin(), vc.end());\n    return Rec(vc.begin(), n);\n}\n\n\nint n;\ndouble r, x, y;\n\nint main() {\n    while (cin >> n) {\n        if (n == 0) break;\n        MAX_R = 0.0;\n        vector<Circle> vc(n);\n        for (int i = 0; i < n; ++i) cin >> vc[i].r >> vc[i].x >> vc[i].y, chmax(MAX_R, vc[i].r);\n        double res = Closet(vc);\n        cout << fixed << setprecision(9) << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef pair<P,double> P2;\n\nP rot(P p, double a){\n  a=a*M_PI/180.0;\n  return P(p.first*cos(a)+p.second*(-sin(a)),\n  p.first*sin(a)+p.second*cos(a));\n}\n\ndouble abss(P a,P b){\n  return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));\n}\n\ndouble x,y,r;int tt;\nvector<P2>v;\nint main(){\n\n  int n;\n  while(cin >> n,n){\n\n    double ans=1e13;\n    \n    v.clear();\n  \n    r(i,n){\n      cin>>r>>x>>y;\n      v.push_back(P2(P(x,y),r));\n    }\n\n    r(i,1){\n      sort(v.begin(),v.end());\n      r(j,n){\n\tfor(int k=j+1,c=0;k<n;k++,c++){\n\t  if(c>50)break;\n\t  ans=min(ans,abss(v[k].first,v[j].first)-v[k].second-v[j].second);\n\t}\n      }\n      r(j,n)v[i].first=rot(v[i].first,0.5);\n    }\n\n    printf(\"%.9f\\n\",ans);\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nclass Circle{\npublic:\n  P cp;\n  double r;\n};\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double INF=-1;\nconst int band=5;\nint main(){\n  int n;\n  while(cin>>n&&n!=0){\n    int xsortedIdxs[100001];\n    int ysortedIdxs[100001];\n    vector<Circle> cs;\n    vector<pair<double,int> > xsorted;\n    vector<pair<double,int> > ysorted;\n    double x,y,r;\n    for(int i = 0; i < n; i++){\n      Circle c;\n      cin>>r>>x>>y;\n      c.r=r;\n      c.cp=P(x,y);\n      cs.push_back(c);\n      xsorted.push_back(make_pair(x,i));\n      ysorted.push_back(make_pair(y,i));\n    }\n    sort(xsorted.begin(),xsorted.end());\n    sort(ysorted.begin(),ysorted.end());\n    for(int i = 0; i < n; i++){\n      xsortedIdxs[xsorted[i].second]=i;\n      ysortedIdxs[ysorted[i].second]=i;\n    }\n    double minDist=INF;\n    for(int i = 0; i < n; i++){\n      // x,zÀW»ê¼êÉÂ¢ÄA\n      // ©ªÌê©ç-10,+10ÌÆ±ëðTõ\n      int xsidx=xsortedIdxs[i];\n      int ysidx=ysortedIdxs[i];\n      for(int j = xsidx; j < min(xsidx+band,n);j++){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = xsidx; j >= max(0,xsidx-band); j--){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j < min(ysidx+band,n);j++){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j >= max(0,ysidx-band); j--){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n    }\n    printf(\"%.8f\\n\",minDist);\n    //cout<<minDist<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-6)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\n// \tVerified: AOJ 0081 A Symmetric Point\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t三角形の面積（外積）\n\n\t説明\n\t\t三頂点で定まる三角形の面積（の２倍）を求める\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n*/\ntemplate<class T>\nT area2(const point<T> &a, const point<T> &b, const point<T> &c ){\n\treturn abs(cross(b-a,c-a));\n}\n/*\n\t三角形の面積（Heron）\n\n\t説明\n\t\t三辺の長さで定まる三角形の面積を求める\n\t引数\n\t\ta : 一辺の長さ\n\t\tb : 一辺の長さ\n\t\tc : 一辺の長さ\n\t戻り値\n\t\t三角形の面積\n\t\t三角形が作れないとき、縮退しているときには 0\n\t制約\n\t\ta>=0, b>=0, c>=0\n\t\ta<b+c, b<c+a, c<a+b（三角形の成立条件）\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble area(double a, double b, double c ){\n\treturn sqrt((a+b-c)*(b+c-a)*(c+a-b)*(a+b-c))/4.;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079: Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n// (B)\n\n//enum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n\n/*\n\t線分と線分の距離\n*/\n\n/*\n\t三角形と点の包含判定\n\n\t説明\n\t\t三角形 abc が点 p を含むかどうかを判定する\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\t三角形は縮退していないこと\n\t\tすなわち、三点が同一直線上にないこと、（特に、どの二点も等しくないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形は CCW でも CW でもよい\n\t\t点が三角形の境界になるときは含むと判定する\n\t\tVerified: AOJ 0012: A Point in a Triangle\n\t\tVerified: AOJ 0143: Altair and Vega \n*/\ntemplate<class T>\nbool cover(const point<T> &a, const point<T> &b, const point<T> &c, const point<T> &p ){\n\tint d1 = ccw (p, a, b );\n\tint d2 = ccw (p, b, c );\n\tint d3 = ccw (p, c, a );\n\treturn !((d1 == CCW && d2 == CW ) || (d1 == CCW && d3 == CW ) || (d2 == CCW && d3 == CW ) || (d1 == CW && d2 == CCW ) || (d1 == CW && d3 == CCW ) || (d2 == CW && d3 == CCW ) );\n}\n\n/*\n\t直線と点の包含判定\n*/\n\n/*\n\t線分と点の包含判定\n*/\n\n/*\n\t多角形と点の包含判定\n*/\n\n/*\n\t多角形と多角形の包含判定\n*/\n\n/*\n\t円と点の包含判定\n\n\t説明\n\t\t円が点を含むかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tp : 点\n\t戻り値\n\t\t含むなら true, 含まないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\n// (A)\ntemplate<class T>\nbool cover (const circle<T> &C, const point<T> &p ){\n\treturn dist2(C.c, p) <= C.r*C.r;\n}\n\n// (B)\nbool cover (const circle<double> &C, const point<double> &p ){\n\treturn dist (C.c, p ) < C.r + EPS;\n}\n\n/*\n\t直線と直線の交差判定\n*/\n\n/*\n\t直線と線分の交差判定\n*/\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t多角形と線分の交差判定\n\n\t説明\n\t\t多角形と線分が交わるかどうかを判定する\n\t引数\n\t\tG : 多角形\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n)\n\t備考\n\t\tG は凸でなくていい。\n\t\tG は境界を含む\n\t\tS が G の内部にあるときは交わると判定する\n*/\ntemplate<class T>\nbool intersect(const polygon<T> &G, const segment<T> &S ){\n\tint n = G.size();\n\tif (cover(G, S.a ) || cover (G, S.b ) ) return true;\n\trep (i, n ) if (intersect((segment<T>){G[i], G[(i+1)%n]}, S ) ) return true;\n\treturn false;\n}\n\n/*\n\t多角形と多角形の交差判定\n*/\n\n/*\n\t円と直線の交差判定\n\n\t説明\n\t\t円と直線が交わるかどうかを判定する\n\t引数\t\n\t\tC: 円\n\t\tL: 直線\n\t戻り値\n\t\t交点の個数\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t\n*/\nint intersect(const circle<double> &C, const line<double> &L ){\n\tpoint<double> m=proj(C.c, L );\n\tdouble d = abs (C.c - m );\n\tif (C.r + EPS < d ) return 0;\n\tif (C.r - EPS < d ) return 1;\n\treturn 2;\n}\n\n/*\n\t円と線分の交差判定\n\n\t説明\n\t\t円と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tC : 円\n\t\tS : 線分\n\t戻り値\n\t\t交わるなら true 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t線分が円の内部になるときは交わると判定する。\n*/\n// (A)\ntemplate<class T>\nbool intersect(const circle<T> &C, const segment<T> &S ){\n\treturn dist2(S, C.c ) <= C.r*C.r;\n}\n// (B)\nbool intersect(const circle<double> &C, const segment<double> &S ){\n\treturn dist(S, C.c ) < C.r + EPS;\n}\n\n/*\n\t二直線の交点\n\n\t説明\n\t\t二直線の交点を求める\n\t\t(A)（直線を特徴付ける点の）座標値が整数\n\t\t(B)（直線を特徴付ける点の）座標値が実数\n\t引数\n\t\tL1 : 直線\n\t\tL2 : 直線\n\t戻り値\n\t\tL1 と L2 の交点\n\t制約\n\t\t二直線は交点を持つこと。（平行でない or L1 == L2 )\n\t計算量\n\t\tO(1)\n\t備考\n\t\t交点が複数あるとき（L1 == L2）は L1.a を返す。\n\t\tこの仕様は線分 S と直線 L の交点を求めたいとき重要。\n\t\t（ S と L が同一直線上にあるときにも、S を第１引数に指定することで交点が正しく求まる。）\n\n*/\n// (A)\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1, const line<T> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1==0) return L1.a;\t// L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n// (B)\npoint<double> get_intersect(const line<double> &L1, const line<double> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1<EPS) return L1.a;\t// L1 == L2\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n/*\n\t二線分の交点\n*/\n\n/*\n\t円と直線の交点\n*/\n\n/*\n\t円と円の交点\n\n\t説明\n\t\t円と円の交点を求める\n\t引数\n\t\tC1 : 円\n\t\tC2 : 円\n\t\tres : 計算結果（交点の集合）\n\t戻り値\n\t\t交点の個数\n\t\tただし、交点が無限個になる（２つの円が等しい）ときは -1\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tres は初期化されない\n\t\t交点が無限個あるときは res には何も追加されない\n\t\tVerified: AOJ 0090 Overlaps of Seals\n*/\nint get_intersect(const circle<double> &C1, const circle<double> &C2, vector< point<double> > &res ){\n\tdouble r1=C1.r,r2=C2.r;\n\tpoint<double> p1=C1.c,p2=C2.c;\n\n\tdouble d=abs(p1-p2);\n\tif (d<EPS && abs(r1-r2)<EPS ){\t// C1 == C2\n\t\treturn -1;\n\t}else\n\tif (r1+r2<d-EPS || d+EPS<abs(r1-r2) ){\n\t\treturn 0;\n\t}else{\n\t\tdouble a = (r1*r1-r2*r2+d*d)/(2.*d);\n\t\tdouble h = sqrt(max(r1*r1-a*a, 0. ) );\n\t\tpoint<double> tmp1 = p1+a/d*(p2-p1);\n\t\tpoint<double> tmp2 = h/d*(p2-p1);\n\t\tif (abs(tmp2)<EPS ){\n\t\t\tres.push_back (tmp1 );\n\t\t\treturn 1;\n\t\t}else{\n\t\t\tres.push_back ((point<double>){tmp1.x-tmp2.y, tmp1.y+tmp2.x});\n\t\t\tres.push_back ((point<double>){tmp1.x+tmp2.y, tmp1.y-tmp2.x});\n\t\t\treturn 2;\n\t\t} // end if\n\t} // end if\n}\n\n/*\n\t点から円に引いた接線の交点\n*/\n\n/*\n\t円と円の共通接線\n*/\n\n/*\n\t垂直二等分線\n\n\t説明\n\t\t二点 a, b の垂直二等分線を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\ta と b の垂直二等分線\n\t計算量\n\t\tO(1)\n\t備考\n\t\t垂直二等分線を L とすると、L.a から L.b の方向を見たとき、左手に点 a が来る。\n*/\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a, const point<T> &b ){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0, (a.y+a.x+b.y-b.x)/2.0 },\n\t\t\t\t\t\t\t(point<double>){(a.x+a.y+b.x-b.y)/2.0, (a.y-a.x+b.y+b.x)/2.0 }};\n}\n\n/*\n\t点対称\n\n\t説明\n\t\t点 b を基準に点 a を点対称を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点対称の点\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\npoint<T> symmetry_point (const point<T> a, const point<T> b )\n{\n\treturn (point<T>){2*b.x-a.x, 2*b.y-a.y};\n}\n\n/*\n\t多角形の重心の座標\n\n\t説明\n\t\t頂点数 n の凸多角形をひとつの頂点を基準に n - 2 個の三角形に分割した三角形の面積を Sk,\n\t\t重心を gk とおくと n の凸多角形の重心 G は\n\n\t\tG = \\sum_{k=1}^{n-2}Sk*gk/(\\sum_{k=1}^{n-2}Sk)\n\n\t\tで求められる。\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t点\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 2442: ConvexCut しかし EPS=1e-6 にしないと WA.\n*/\ntemplate<class T>\npoint<T> centerG(const polygon<T> &G ){\n\tint n = G.size();\n\tdouble S = 0.;\n\tpoint<double> g; g.x = 0.; g.y = 0.;\n\tint u = G.size()-1;\n\tfor (int i = 0; i < n; u=i++ ){\n\t\tdouble sk = cross (G[u], G[i] );\n\t\tS += sk;\n\t\tg.x += (G[u].x + G[i].x)*sk;\n\t\tg.y += (G[u].y + G[i].y)*sk;\n\t} // end for\n\tg /= (3.*S);\n\n\treturn g;\n/*\n\tint n = G.size();\n\tdouble ar = 0.;\n\tdouble x = 0., y = 0.;\n\trep (i, n - 2 ){\n\t\tdouble k = area2 (G[n-1], G[i], G[i+1] );\n\t\tar += k;\n\t\tx += (G[n-1].x + G[i].x)*k;\n\t\ty += (G[n-1].y + G[i].y)*k;\n\t} // end rep\n\tx /= (3.*ar );\n\ty /= (3.*ar );\n\t\n\treturn (point<T>){x,y};\n*/\n}\n\n/*\n\t二点と半径で定まる円\n*/\n\n/*\n\t凸性判定\n\t\n\t説明\n\t\t多角形が凸かどうかを判定する\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tG は単調かつ頂点の順番が CCW で与えられていること\n\t計算量\n\t\tO(n)\n\t備考\n\t\tVerified: AOJ 0035: Is it Convex?\n*/\ntemplate<class T>\nbool is_convex(const polygon<T> &G ){\n\tint n = G.size();\n\trep (i, n ) if (ccw (G[i], G[(i+1)%n], G[(i+2)%n])== CW ) return false;\n\treturn true;\n}\n\n/*\n\t凸包\n\n\t説明\n\t\t点集合の凸包を求める\n\t引数\n\t\tP : 点集合\n\t戻り値\n\t\tP の凸包\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n log n )\n\t備考\n\t\tP は破壊される。\n\n\t\tsort は (x, y ) の辞書順。\n\n\t\t凸包の同じ直線上にある頂点は端のものだけを拾う。\n\t\t辺上になる頂点を全部拾うようにしたいときは != CCW を ==CW と修正すればよい。\n*/\ntemplate<class T>\npolygon<T> convex_hull(vector< point<T> > &P ){\n\tint n = P.size();\n\tpolygon<T> CH;\n\tif (n <= 1 ){\n\t\tCH.insert (CH.end(), P.begin(), P.end() );\n\t\treturn CH;\n\t} // end if\n\tsort (ALL (P ) );\n\trep (cnt, 2 ){\n\t\tint m = 0;\n\t\tvector< point<T> > half(n );\n\t\trep (i, n ){\n\t\t\thalf[m++] = P[i];\n\t\t\twhile (m >= 3 && ccw (half[m-3], half[m-2], half[m-1] ) != CCW ){\n\t\t\t\thalf[m-2] = half[m-1];\n\t\t\t\tm--;\n\t\t\t} // end while\n\t\t} // end rep\n\t\tCH.insert (CH.end(), half.begin(), half.begin()+m-1 );\n\t\treverse (ALL (P ) );\n\t} // end rep\n\t\n\treturn CH;\n}\n\n/*\n\t凸多角形の切断\n*/\n\n/*\n\t内接円の半径\n\n\t説明\n\t\t辺長がそれぞれ、a, b, c である三角形の内接円の半径を求める\n\t引数\n\t\ta: 辺長\n\t\tb: 辺長\n\t\tc: 辺長\n\t戻り値\n\t\t内接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, c < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble inradius(double a, double b, double c ){\n\treturn sqrt ((b+c-a)*(c+a-b)*(a+b-c)/(a+b+c))/2.;\n}\n\n/*\n\t外接円\n\n\t説明\n\t\t三角形 abc の外接円を求める\n\t引数\n\t\ta: 頂点\n\t\tb: 頂点\n\t\tc: 頂点\n\t戻り値\n\t\t外接円\n\t制約\n\t\ta, b, c は同一直線上にないこと\n\t計算量\n\t\tO(1)\n\t備考\n\t\ta, b, c が同一直線上にあるときは外接円は存在しない\n\t\t頂点が整数座標のとき、外心の座標と半径の二乗は有理数となる\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ncircle<double> circumcircle(const point<double> &a, point<double> b, point<double> c ){\n\tb-=a; c-=a;\n\tdouble A2 = abs2(b-c), B2 = abs2(b), C2 = abs2(c);\n\tdouble d = 2*cross(b,c);\n\tdouble nx = c.y*B2-b.y*C2;\n\tdouble ny = b.x*C2-c.x*B2;\n\tdouble r2 = A2*B2*C2/(d*d);\n\treturn (circle<double>){a+(point<double>){nx/d, ny/d}, sqrt(r2)};\n}\n\n/*\n\t外接円の半径\n\t\n\t説明\n\t\t辺長がそれぞれ a, b, c である三角形の外接円の半径を求める\n\t引数\n\t\ta : 辺長\n\t\tb : 辺長\n\t\tc : 辺長\n\t戻り値\n\t\t外接円の半径\n\t制約\n\t\ta >= 0, b >= 0, c >= 0\n\t\ta < b + c, b < c + a, c < a + b (三角形の成立条件)\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n\n\t\tVerified: AOJ 0010 Circumscribed Circle of a Triangle\n\n*/\ndouble circumradius(double a, double b, double c ){\n\treturn a*b*c/sqrt((a+b+c)*(b+c-a)*(c+a-b)*(a+b-c) );\n}\n\n/*\n\t最小包含球\n*/\n\n/*\n\t線分アレンジメント\n*/\n\n/*\n\t最近点対\n\n\t説明\n\t\t最近点対問題を解く\n\t引数\n\t\tn : 点の個数\n\t\tp : 点集合\n\t戻り値\n\t\t最近点対の距離\n\t制約\n\t\tn>=2\n\t計算量\n\t\tO(n log n)\n\t備考\n\t\tsort は (x,y) の辞書順。\n\t\tP の順番は破壊される（内部でソートするため）\n*/\nstruct cmp_y{\nbool operator()(const point<double> &a, const point<double> &b ){\n\treturn (a.y+EPS<b.y || (abs(a.y-b.y)<EPS && a.x+EPS<b.x ) );\n}};\n\ndouble closest_pair(int n, point<double> *P){\n\tsort (P, P+n );\n\tdouble d = dist(P[0],P[1] );\n\tset<point<double>, cmp_y> S;\n\tset<point<double>, cmp_y>::iterator it_l, it_r, it;\n\tfor (int i = 0, j = 0; i < n; i++ ){\n\t\tit_l = S.lower_bound ((point<double>){0,P[i].y-d-1.});\n\t\tit_r = S.upper_bound ((point<double>){0,P[i].y+d+1.});\n\t\tfor (it=it_l;it!=it_r;++it) d=min(d, dist(*it,P[i]));\n\t\twhile(P[i].x-P[j].x>d+EPS ) S.erase(P[j++] );\n\t\tS.insert(P[i] );\n\t} // end for\n\n\treturn d;\n}\n\n/*\n\t楕円の周長\n*/\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.2057\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tpoint<double> p[n];\n\t\tdouble r;\n\t\trep (i, n ) scanf (\"%lf %lf %lf\",&p[i].x, &p[i].y, &r );\n\t\tdouble res = closest_pair(n, p );\n\t\tprintf (\"%.5lf\\n\", res );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst double INF = 1e+12;\n\ndouble equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nstruct C{\n  P p;\n  double r;\n  C(P p=P(0,0),double r=0.0):p(p),r(r){}\n  bool operator < (const C &c) const {\n    return equal(real(p)+r,real(c.p)-c.r) ? imag(p)+r < imag(c.p)-c.r : real(p)+r < real(c.p)-c.r;\n  }\n};\n\n\nC v[100000];\nbool f;\n\nbool compare_y(C a, C b){\n  return imag(a.p)+a.r < imag(b.p)-b.r;\n}\n\ndouble closest(C a[], int n){\n  if(n <= 1) return INF;\n  if(f) return 0.0;\n  int m = n / 2;\n  double x = real(a[m].p);\n  double d = min(closest(a,m), closest(a+m,n-m));\n  inplace_merge(a, a+m, a+n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(real(a[i].p) - x)-a[i].r-a[m].r >= d || equal(fabs(real(a[i].p) - x)-a[i].r-a[m].r,d)) continue;\n\n    for(int j=0;j<b.size();j++){\n      C bc = b[b.size()-j-1];\n      if(imag(a[i].p-bc.p)-bc.r-a[i].r >= d || equal(imag(a[i].p-bc.p)-bc.r-a[i].r,d)) break;\n      //cout << a[i].p << ' ' << bc.p << endl;\n      d = min(d, abs(a[i].p-bc.p) - a[i].r - bc.r);\n      if(equal(d,0.0)){\n        f = true;\n        return 0.0;\n      }\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> v[i].r >> x >> y;\n      v[i].p = P(x,y);\n    }\n    f = false;\n    sort(v,v+n);\n    printf(\"%f\\n\",closest(v,n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define INF 1e10\nusing namespace std;\n\nint n;\nstruct P{\n\tdouble x,y,r;\n\tP(){}\n\tP(double xx,double yy,double rr){\n\t\tx=xx;\n\t\ty=yy;\n\t\tr=rr;\n\t}\n\tbool operator<(const P &p1)const{\n\t\treturn x<p1.x;\n\t}\n};\n\nbool compare_y(P a,P b){\n\treturn a.y<b.y;\n}\n\n\ndouble closest_pair(P *a,int n){\n\tif(n<=1)return INF;\n\tint m=n/2;\n\tdouble x=a[m].x;\n\tdouble r=a[m].r;\n\tdouble d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n\tinplace_merge(a,a+m,a+n,compare_y);\n\tvector<P> b;\n\tfor(int i=0;i<n;i++){\n\t\tif(fabs(a[i].x-x)-a[i].r-r>=d)continue;\n\t\tfor(int j=0;j<b.size();j++){\n\t\t\tdouble dx=a[i].x-b[b.size()-j-1].x;\n\t\t\tdouble dy=a[i].y-b[b.size()-j-1].y;\n\t\t\tif(dy>=d+r+a[i].r)break;\n\t\t\td=min(d,sqrt(dx*dx+dy*dy)-b[b.size()-j-1].r-a[i].r);\n\t\t}\n\t\tb.push_back(a[i]);\n\t\tr=max(a[i].r,r);\n\t}\n\treturn d;\n}\n\nP p[100001];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%lf %lf %lf\",&p[i].r,&p[i].x,&p[i].y);\n\t\t}\n\t\tsort(p,p+n);\n\t\tprintf(\"%.9f\\n\",closest_pair(p,n));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = i+1 ; j < min(i+6,n) ; j++){\n\t\t\t\tans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = i+1 ; j < min(i+6,n) ; j++){\n\t\t\t\tans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f%c\",ans,10);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\ndouble max_r;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線\n\tdouble r = array[mid].r; //半径\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\tdouble diff_y;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(fabs(array[i].x-x)-(array[i].r+r) >= dist)continue; //基準円とのx座標の距離の差がdist以上ならSKIP\n\n\t\tfor(int k = 0; k < V.size(); k++){\n\t\t\tdiff_y = array[i].y-array[V[V.size()-1-k]].y;\n\t\t\tif(diff_y >= dist+r+array[i].r)break;\n\t\t\tdist = min(dist,calc_dist(V[V.size()-1-k],i));\n\t\t}\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tmax_r = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t\tmax_r = max(max_r,info[i].r);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    double ret = sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n    if ( ret<0)ret=0;\n    return ret;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) <1e-10+ min_val+2*maxr){\n      tarray[p++]=a[i];\n    }\n  }\n  rep(i,p){\n    REP(j,i+1,p && abs(tarray[j].y-tarray[i].y)<1e-10+2*maxr+min_val){\n      min_val=min(min_val,tarray[j].dist(a[i]));\n    }\n  }\n\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<29\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\n\nbool cmp_y(const P &a,const P &b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if(fabs( (a[i].F.F+a[i].S)-(x-r) ) >= d)continue;\n    }\n    else{\n      if( fabs((x+r)-(a[i].F.F+a[i].S)) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif( fabs( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S)     )   >= d )break;\n      }\n      else{\n\tif( fabs( (a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S)     )  >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int N;\n  double R,X,Y;\n \n  while(cin >> N && N){\n    vector<P> p(N);\n    for(int i=0;i<N;i++){\n      cin >> R >> X >> Y;\n      p.push_back(P(Pos(X,Y),R));\n    }\n    sort(p.begin(),p.end());\n    printf(\"%.6f\\n\",rec(p,N));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = max(0,i-300) ; j < min(i+300,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = max(0,i-300) ; j < min(i+300,n) ; j++){\n\t\t\t\tif(i!=j) ans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f%c\",ans,10);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<24\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\n\nbool cmp_y(const P &a,const P &b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if(fabs( (a[i].F.F+a[i].S)-(x-r) ) >= d)continue;\n    }\n    else{\n      if( fabs((x+r)-(a[i].F.F+a[i].S)) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif( fabs( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S)     )   >= d )break;\n      }\n      else{\n\tif( fabs( (a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S)     )  >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  double R,X,Y;\n  vector<P> p;\n  while(cin >> n && n){\n    p.clear();\n    for(int i=0;i<n;i++){\n      cin >> R >> X >> Y;\n      p.push_back(P(Pos(X,Y),R));\n    }\n    sort(p.begin(),p.end());\n    printf(\"%.6f\\n\",rec(&p[0],n));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <vector>\n#include <cstdio>\n#include <cassert>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\nconst double INF = 1e+12;\n\ndouble equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nstruct C{\n  P p;\n  double r;\n  C(P p=P(0,0),double r=0.0):p(p),r(r){}\n  bool operator < (const C &c) const {\n    //return equal(real(p)+r,real(c.p)-c.r) ? imag(p)+r < imag(c.p)-c.r : real(p)+r < real(c.p)-c.r;\nreturn equal(real(p),real(c.p)) ? imag(p) < imag(c.p) : real(p) < real(c.p);\n  }\n};\n\n\nC v[100000];\nbool f;\n\nbool compare_y(C a, C b){\n  return imag(a.p) < imag(b.p);\n}\n\ndouble closest(C a[], int n){\n  if(n <= 1) return INF;\n  if(f) return 0.0;\n  int m = n / 2;\n  double x = real(a[m].p);\n  double d = min(closest(a,m), closest(a+m,n-m));\n  inplace_merge(a, a+m, a+n, compare_y);\n\n  vector<C> b;\n  for(int i=0;i<n;i++){\n    if(fabs(real(a[i].p) - x)-a[i].r-a[m].r >= d || equal(fabs(real(a[i].p) - x)-a[i].r-a[m].r,d)) continue;\n\n    for(int j=0;j<b.size();j++){\n      C bc = b[b.size()-j-1];\n      if(imag(a[i].p-bc.p)-bc.r-a[i].r >= d || equal(imag(a[i].p-bc.p)-bc.r-a[i].r,d)) break;\n      //cout << a[i].p << ' ' << bc.p << endl;\n      d = min(d, abs(a[i].p-bc.p) - a[i].r - bc.r);\n      if(equal(d,0.0)){\n        f = true;\n        return 0.0;\n      }\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin >> v[i].r >> x >> y;\n      v[i].p = P(x,y);\n    }\n    f = false;\n    sort(v,v+n);\n    printf(\"%f\\n\",closest(v,n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  Point p1,p2,p3,p4;\n  p1=p2=p3=p4=BigPoint;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x)-a[i].r < min_val+maxr){\n      min_val=min(min_val,a[i].dist(p1));\n      min_val=min(min_val,a[i].dist(p2));\n      min_val=min(min_val,a[i].dist(p3));\n      min_val=min(min_val,a[i].dist(p4));\n      p1=p2;p2=p3;p3=p4;p4=a[i];\n    }\n  }\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<pair<double,double>,double> data;\n\ntemplate<class T> inline T dbl(T a){ return a * a; }\n\ninline double dist(const data &a, const data &b){\n  return sqrt(dbl(a.f.f - b.f.f) + dbl(a.f.s - b.f.s)) - (a.s + b.s);\n}\n\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n), n){\n    vector<data> v(n);\n\n    REP(i,n)\n      scanf(\"%lf%lf%lf\", &v[i].s, &v[i].f.f, &v[i].f.s);\n\n    double a1 = 0.0; REP(i,n) a1 += v[i].f.f; a1 /= n;\n    double a2 = 0.0; REP(i,n) a2 += v[i].f.s; a2 /= n;\n\n    double b1 = 0.0; REP(i,n) b1 += dbl(v[i].f.f - a1); b1 /= n;\n    double b2 = 0.0; REP(i,n) b2 += dbl(v[i].f.s - a2); b2 /= n;\n\n    if(b1 < b2) REP(i,n) swap(v[i].f.f, v[i].f.s);\n\n    sort(v.begin(), v.end());\n\n    double ans = 1e20;\n\n    double r  = 0.0; REP(i,n) r = max(r, v[i].s); r *= 2;\n\n\n    for(int i = 0; i < n; i++){\n      double x1 = v[i].f.f;\n      for(int j = i + 1; j < n; j++){\n\tdouble x2 = v[j].f.f;\n\n\tif((x2 - x1 - r) > ans) break;\n\n\tans = min(ans, dist(v[i], v[j]));\n      }\n    }\n    \n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n\tint index;\n};\n\nint N;\ndouble max_r;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){ //基準線より中心が左\n\t\tif(info[index].x+info[index].r+dist < x-max_r){ //★★中心線より反対側に円がはみ出す場合がある\n\t\t\treturn false;\n\t\t}\n\n\t}else{ //基準線より中心が右\n\t\tif(info[index].x-info[index].r-dist > x+max_r){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線\n\tdouble r = array[mid].r; //半径\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(!is_OK(array[i].index,x,dist))continue; //異なる領域間での、新最小値を作り得ない場合は無視\n\n\t\tleft = 0,right = V.size()-1,m = (left+right)/2;\n\t\tsearch_left = V.size()-1;\n\n\t\t//Vはy座標の昇順にpushされている→自分よりy座標が小さいもののみが入っている\n\t\twhile(left <= right){\n\t\t\tif((info[array[i].index].y-info[array[i].index].r)-(info[array[V[m]].index].y+info[array[V[m]].index].r) < dist){ //y座標の差がdist未満の場合\n\t\t\t\tsearch_left = m;\n\t\t\t\tright = m-1; //より左へ\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tfor(int k = search_left; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tmax_r = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t\tinfo[i].index = i;\n\t\tmax_r = max(max_r,info[i].r);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\ndouble max_r;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){ //基準線より中心が左\n\t\tif(info[index].x+info[index].r+dist < x-2*max_r){ //★★中心線より反対側に円がはみ出す場合がある\n\t\t\treturn false;\n\t\t}\n\n\t}else{ //基準線より中心が右\n\t\tif(info[index].x-info[index].r-dist > x+2*max_r){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(!is_OK(i,x,dist))continue; //異なる領域間での、新最小値を作り得ない場合は無視\n\n\t\tleft = 0,right = V.size()-1,m = (left+right)/2;\n\t\tsearch_left = V.size()-1;\n\n\t\t//Vはy座標の昇順にpushされている→自分よりy座標が小さいもののみが入っている\n\t\twhile(left <= right){\n\t\t\tif((info[i].y-info[i].r)-(info[m].y+info[m].r) < dist){ //y座標の差がdist未満の場合\n\t\t\t\tsearch_left = m;\n\t\t\t\tright = m-1; //より左へ\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tfor(int k = search_left; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tmax_r = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t\tmax_r = max(max_r,info[i].r);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<pair<double,double>,double> data;\n\ntemplate<class T> inline T dbl(T a){ return a * a; }\n\ninline double dist(const data &a, const data &b){\n  return sqrt(dbl(a.f.f - b.f.f) + dbl(a.f.s - b.f.s)) - (a.s + b.s);\n}\n\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n), n){\n    vector<data> v(n);\n\n    REP(i,n)\n      scanf(\"%lf%lf%lf\", &v[i].s, &v[i].f.f, &v[i].f.s);\n\n    sort(v.begin(), v.end());\n\n    double ans = 1e20;\n    double r  = 0.0; REP(i,n) r = max(r, v[i].s); r *= 2;\n\n    for(int i = 0; i < n; i++){\n      double x1 = v[i].f.f;\n      for(int j = i + 1; j < n; j++){\n\tdouble x2 = v[j].f.f;\n\n\tif((x2 - x1 - r) > ans) break;\n\n\tans = min(ans, dist(v[i], v[j]));\n      }\n    }\n    \n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n\n  double dist(Point &a);\n\n};\ndouble Point::dist(Point &a){\n  double ret = sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  if ( ret<0)ret=0;\n  return ret;\n}\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\n\n\nvoid merge(vector<Point> &a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  vector<Point> t;\n  for(int i=l;i<r+1;i++){\n    if ( abs(midx-a[i].x)< min_val+2*maxr){\n      t.push_back(a[i]);\n    } \n  }\n  for(int i=0;i<t.size();i++){\n    for(int j=i+1;j<t.size()&&abs(t[i].y-t[j].y)<min_val+2*maxr;j++){\n      min_val=min(min_val,t[i].dist(t[j]));\n    }\n  }\n\n  \n\n}\n\nvoid MergeSort(vector<Point> & a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    vector<Point> a;\n    double maxr=0;\n    rep(i,n){\n      Point t;\n      scanf(\"%lf%lf%lf\",&t.r,&t.x,&t.y);\n      maxr=max(maxr,t.r);\n      a.push_back(t);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  C() {}\n};\nbool p1(const C &a, const C &b) {\n  return a.p.real() != b.p.real() ? a.p.real() < b.p.real() : a.p.imag() < b.p.imag();\n}\nbool p2(const C &a, const C &b) {\n  return a.p.imag() != b.p.imag() ? a.p.imag() < b.p.imag() : a.p.real() < b.p.real();\n}\n\n\nC circle[100000];\ndouble minR;\n\ndouble solve(int s, int t) {\n  if (s+1>=t) return INF;\n  double m1 = solve(s, (s+t)/2);\n  double m2 = solve((s+t)/2, t);\n  double mid = (circle[(s+t)/2-1].p.real() + circle[(s+t)/2].p.real()) / 2;\n  double d = min(m1, m2) + 2*minR + 1;\n  int start = lower_bound(circle+s, circle+t, C(P(mid-d-1, -INF), 0), p1) - circle;\n  int end = upper_bound(circle+s, circle+t, C(P(mid+d, INF), 0), p1) - circle;\n  vector<C> v;\n  //cout << s << \" \" <<t << endl;\n  for (int i=start; i<end; ++i) {\n    v.push_back(circle[i]);\n    //cout << circle[i].p << endl;\n  }\n  sort(ALL(v), p2);\n  double res = min(m1, m2);\n  for (int i=0; i<v.size(); ++i) {\n    for (int k=i+1; k<v.size() && (v[k].p.imag()-v[i].p.imag())<d; ++k) {\n      res = min(res, abs(v[k].p-v[i].p)-v[k].r-v[i].r);\n    }\n  }\n  //cout << res << endl;\n  return res;\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    minR = INF;\n    REP(i,n) {\n      double x, y, r;\n      cin >> r >> x >> y;\n      circle[i] = C(P(x,y),r);\n      minR = min(minR, r);\n    }\n    sort(circle, circle+n, p1);\n    printf(\"%.10f\\n\", solve(0, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) <1e-10+ min_val+2*maxr){\n      for(int j=p-1;j>=0 && abs(tarray[j].y-a[i].y)<1e-10+2*maxr+min_val;j--){\n\tmin_val=min(tarray[j].dist(a[i]),min_val);\n      }\n      tarray[p++]=a[i];\n    }\n  }\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\ntypedef complex<double> P;\nint n;\nclass Circle{\npublic:\n  P cp;\n  double r;\n};\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\nconst double INF=-1;\nconst int band=100;\nint main(){\n  int n;\n  while(cin>>n&&n!=0){\n    int xsortedIdxs[100001];\n    int ysortedIdxs[100001];\n    vector<Circle> cs;\n    vector<pair<double,int> > xsorted;\n    vector<pair<double,int> > ysorted;\n    double x,y,r;\n    for(int i = 0; i < n; i++){\n      Circle c;\n      cin>>r>>x>>y;\n      c.r=r;\n      c.cp=P(x,y);\n      cs.push_back(c);\n      xsorted.push_back(make_pair(x,i));\n      ysorted.push_back(make_pair(y,i));\n    }\n    sort(xsorted.begin(),xsorted.end());\n    sort(ysorted.begin(),ysorted.end());\n    for(int i = 0; i < n; i++){\n      xsortedIdxs[xsorted[i].second]=i;\n      ysortedIdxs[ysorted[i].second]=i;\n    }\n    double minDist=INF;\n    for(int i = 0; i < n; i++){\n      // x,zÀW»ê¼êÉÂ¢ÄA\n      // ©ªÌê©ç-10,+10ÌÆ±ëðTõ\n      int xsidx=xsortedIdxs[i];\n      int ysidx=ysortedIdxs[i];\n      for(int j = xsidx; j < min(xsidx+band,n);j++){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = xsidx; j >= max(0,xsidx-band); j--){\n\tint idx=xsorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j < min(ysidx+band,n);j++){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n      for(int j = ysidx; j >= max(0,ysidx-band); j--){\n\tint idx=ysorted[j].second;\n\tif(i==idx)continue;\n\tdouble d=abs(cs[idx].cp-cs[i].cp)\n\t  -cs[idx].r-cs[i].r;\n\tif(EQ(minDist,INF)||minDist>d)\n\t  minDist=d;\n      }\n    }\n    printf(\"%.8f\\n\",minDist);\n    //cout<<minDist<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n  C() {}\n};\nbool p1(const C &a, const C &b) {\n  return a.p.real() != b.p.real() ? a.p.real() < b.p.real() : a.p.imag() < b.p.imag();\n}\nbool p2(const C &a, const C &b) {\n  return a.p.imag() != b.p.imag() ? a.p.imag() < b.p.imag() : a.p.real() < b.p.real();\n}\n\n\nC circle[100000];\ndouble minR;\n\ndouble solve(int s, int t) {\n  if (s+1>=t) return INF;\n  double m1 = solve(s, (s+t)/2);\n  double m2 = solve((s+t)/2, t);\n  double mid = (circle[(s+t)/2-1].p.real() + circle[(s+t)/2].p.real()) / 2;\n  double d = min(m1, m2) + 2*minR;\n  int start = lower_bound(circle+s, circle+t, C(P(mid-d, -INF), 0), p1) - circle;\n  int end = upper_bound(circle+s, circle+t, C(P(mid+d, INF), 0), p1) - circle;\n  vector<C> v;\n  //cout << s << \" \" <<t << endl;\n  for (int i=start; i<end; ++i) {\n    v.push_back(circle[i]);\n    //cout << circle[i].p << endl;\n  }\n  sort(ALL(v), p2);\n  double res = min(m1, m2);\n  for (int i=0; i<v.size(); ++i) {\n    for (int k=i+1; k<v.size() && (v[k].p.imag()-v[i].p.imag())<d; ++k) {\n      res = min(res, abs(v[k].p-v[i].p)-v[k].r-v[i].r);\n    }\n  }\n  //cout << res << endl;\n  return res;\n}\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    minR = INF;\n    REP(i,n) {\n      double x, y, r;\n      cin >> r >> x >> y;\n      circle[i] = C(P(x,y),r);\n      minR = min(minR, r);\n    }\n    sort(circle, circle+n, p1);\n    printf(\"%.10f\\n\", solve(0, n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-5;\nconst int MAX_N = 100000;\nconst double INF = 100000000.0;\n\nbool equal(double a, double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   double x, y, r;\n   Circle(){}\n   Circle(double y, double x, double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         /*if(equal(y, s.y)){\n            return r > s.r;\n            }*/\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\ndouble closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   double x = a[m].x;\n   double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) > d + a[i].r || equal(fabs(a[i].x - x), d+a[i].r)) continue;\n      for(int j=0;j<b.size();j++){\n         double dx = a[i].x - b[b.size()-j-1].x;\n         double dy = a[i].y - b[b.size()-j-1].y;\n         double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy > d + dr || equal(dy, d+dr)) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      fill(A, A+N, Circle(INF, INF, INF));\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){ //順序付け関数\n\n\treturn left.y < right.y;\n\n}\n\nbool is_OK(int index,double x,double dist){\n\tif(info[index].x < x){ //基準線より中心が左\n\t\tif(info[index].x+info[index].r+dist < x){\n\t\t\treturn false;\n\t\t}\n\n\t}else{ //基準線より中心が右\n\t\tif(info[index].x-info[index].r-dist > x){\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble calc_y_dist(int a,int b){\n\treturn (info[b].y-info[b].r)-(info[a].y+info[a].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2; //中央のインデックス\n\n\tdouble x = array[mid].x; //基準線x\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid)); //集合を2分割し、再帰的に最小距離を求める\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y); //2つのソート済の範囲をマージ\n\n\tvector<int> V; //★★再帰毎にメモリを確保(indexをpush)★★\n\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\t\tif(!is_OK(i,x,dist))continue; //基準線より最小距離以上離れている点は無視(★異なる領域間での、新最小値を作り得ないということ★)\n\n\t\t//★★Vはyの昇順に並んでいる:自分よりy座標が小さいもののみ、入っている★★\n\n\t\t//2分探索で、検索範囲を定める\n\t\t/*left = 0,right = V.size()-1,m = (left+right)/2;\n\t\tsearch_left = 0;\n\n\t\twhile(left <= right){\n\t\t\tif(calc_y_dist(V[m],i) < dist){ //y座標の差がdist未満\n\t\t\t\tsearch_left = m;\n\t\t\t\tright = m-1; //より左へ\n\t\t\t}else{\n\t\t\t\tleft = m+1; //より右へ\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}*/\n\n\t\t/*for(int k = search_left; k < V.size(); k++){\n\t\t\tdist = min(dist,calc_dist(V[k],i));\n\t\t}*/\n\n\t\tfor(int k = 0; k < min((int)V.size(),2); k++){\n\t\t\tdist = min(dist,calc_dist(V[V.size()-1-k],i));\n\t\t}\n\n\t\tV.push_back(i); //可能性あり集合に、iを追加\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#define EPS 1e-10\n#define F first\n#define S second\n#define INF 1<<29\nusing namespace std;\n\ntypedef pair<double,double> Pos;\ntypedef pair<Pos,double> P;\n\nbool cmp_y(const P &a,const P &b){\n  return a.F.S < b.F.S;\n}\n\ndouble rec(P *a,int n){\n  if(n<=1)return INF;\n  int m = n/2;\n  double x = a[m].F.F;\n  double r = a[m].S;\n  double d = min(rec(a,m),rec(a+m,n-m));  \n  inplace_merge(a,a+m,a+n,cmp_y);\n\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(a[i].F.F < x){\n      if(fabs( (a[i].F.F+a[i].S)-(x-r) ) >= d)continue;\n    }\n    else{\n      if( fabs((x+r)-(a[i].F.F+a[i].S)) >= d)continue;\n    }\n\n    for(int j=0;j<b.size();j++){\n      double dx = a[i].F.F - b[b.size()-j-1].F.F;\n      double dy = a[i].F.S - b[b.size()-j-1].F.S;\n    \n      if(a[i].F.S < b[b.size()-j-1].F.S){\n\tif( fabs( (b[b.size()-j-1].F.S-b[b.size()-j-1].S)-(a[i].F.S+a[i].S)     )   >= d )break;\n      }\n      else{\n\tif( fabs( (a[i].F.S-a[i].S)-(b[b.size()-j-i].F.S+b[b.size()-j-1].S)     )  >= d)break;\n      } \n    \n      d = min(d,sqrt(dx*dx+dy*dy)-a[i].S-b[b.size()-j-1].S);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  int n;\n  double R,X,Y;\n  vector<P> p;\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      cin >> R >> X >> Y;\n      p.push_back(P(Pos(X,Y),R));\n    }\n    sort(p.begin(),p.end());\n    printf(\"%.6f\\n\",rec(&p[0],n));\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tbool operator<(const struct Info &arg) const{\n\t\tif(x != arg.x){\n\t\t\treturn x < arg.x;\n\t\t}else{\n\t\t\treturn y < arg.y;\n\t\t}\n\t}\n\tdouble x,y,r;\n};\n\nint N;\nInfo info[100001];\n\nbool compare_y(Info left,Info right){\n\n\treturn left.y < right.y;\n\n}\n\ndouble calc_dist(int a,int b){\n\treturn sqrt((info[a].x-info[b].x)*(info[a].x-info[b].x)+(info[a].y-info[b].y)*(info[a].y-info[b].y))-(info[a].r+info[b].r);\n}\n\ndouble calc_y_dist(int a,int b){\n\treturn (info[b].y-info[b].r)-(info[a].y+info[a].r);\n}\n\ndouble closest_pair(Info* array,int tmp_N){\n\tif(tmp_N <= 1)return DBL_MAX;\n\n\tint mid = tmp_N/2;\n\n\tdouble x = array[mid].x;\n\tdouble dist = min(closest_pair(array,mid),closest_pair(array+mid,tmp_N-mid));\n\tinplace_merge(array,array+mid,array+tmp_N,compare_y);\n\n\tvector<int> V;\n\n\n\tint left,right,m,search_left;\n\n\tfor(int i = 0; i < tmp_N; i++){\n\n\t\tfor(int k = 0; k < min((int)V.size(),2); k++){\n\t\t\tdist = min(dist,calc_dist(V[V.size()-1-k],i));\n\t\t}\n\n\t\tV.push_back(i);\n\t}\n\treturn dist;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf %lf\",&info[i].r,&info[i].x,&info[i].y);\n\t}\n\tsort(info,info+N);\n\n\tprintf(\"%.10lf\\n\",closest_pair(info,N));\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  int n;\n  cin>>n;\n  using C = tuple<double,double,double>;\n  vector<C> v;\n  for(int i=0;i<n;i++){\n    double r,x,y;\n    cin>>r>>x>>y;\n    v.emplace_back(r,x,y);\n  }\n  auto calc=[&](int i,int j){\n    double ar,ax,ay,br,bx,by;\n    tie(ar,ax,ay)=v[i];\n    tie(br,bx,by)=v[j];\n    return sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by))-(ar+br);\n  };\n  double ans=calc(0,1);\n  sort(v.begin(),v.end(),[](C a,C b){return get<1>(a)<get<1>(b);});\n  for(int i=0;i<n-1;i++) ans=min(ans,calc(i,i+1));\n  sort(v.begin(),v.end(),[](C a,C b){return get<2>(a)<get<2>(b);});\n  for(int i=0;i<n-1;i++) ans=min(ans,calc(i,i+1));\n  cout<<fixed<<setprecision(12)<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct Circle{\n\tdouble x,y,r;\n\tbool operator < (const Circle &)const;\n};\n\nbool Circle::operator < (const Circle &a)const{\n\treturn (x*x+y*y)<(a.x*a.x+a.y*a.y);\n}\n\ndouble dist(const Circle &a,const Circle &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y))-a.r-b.r;\n}\n\nconst int MAX_N=100000;\n\nint N;\nCircle c[MAX_N];\n\nvector<double> out;\n\nint main(){\n\tdo{\n\t\tscanf(\"%d\",&N);\n\t\tif (N){\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tscanf(\"%lf %lf %lf\",&c[i].r,&c[i].x,&c[i].y);\n\t\t\t}\n\t\t\tsort(c,c+N);\n\t\t\tdouble ans=1e50;\n\t\t\tfor (int i=0;i<N;i++){\n\t\t\t\tfor (int j=i+1;j<min(N,i+4001);j++){\n\t\t\t\t\tans=min(ans,dist(c[i],c[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.push_back(ans);\n\t\t}\n\t}while(N);\n\tfor (int i=0;i<out.size();i++){\n\t\tprintf(\"%.12f\\n\",out[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct P{\n  double x,y,r;\n};\n\nP A[100000];\ndouble m;\nint N;\n\ndouble closest_pair(P *a,int n){\n  if(n<=1)return 1e9;\n  int m=n/2;\n  double x=a[m].x;\n  double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n  inplace_merge(a,a+m,a+n,[](const P &a,const P &b){\n      return a.y<b.y;\n    });\n  vector<P> b;\n  for(int i=0;i<n;i++){\n    if(fabs(a[i].x)-x>=d+2*m)continue;\n    for(int j=0;j<b.size();j++){\n      auto bj=b[b.size()-j-1];\n      double dx=a[i].x-bj.x;\n      double dy=a[i].y-bj.y;\n      if(dy>=d+2*m)break;\n      d=min(d,sqrt(dx*dx+dy*dy)-a[i].r-bj.r);\n    }\n    b.push_back(a[i]);\n  }\n  return d;\n}\n\nint main(){\n  while(cin>>N,N){\n    m=0;\n    for(int i=0;i<N;i++){\n      cin>>A[i].r>>A[i].x>>A[i].y;\n      m=max(m,A[i].r);\n    }\n    sort(A,A+N,[](const P &a,const P &b){\n\treturn a.x<b.x;\n      });\n    cout<<fixed<<closest_pair(A,N)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<pair<double,double>,double> data;\n\ntemplate<class T> inline T dbl(T a){ return a * a; }\n\ninline double dist(const data &a, const data &b){\n  return sqrt(dbl(a.f.f - b.f.f) + dbl(a.f.s - b.f.s)) - (a.s + b.s);\n}\n\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n), n){\n    vector<data> v(n);\n\n    REP(i,n)\n      scanf(\"%lf%lf%lf\", &v[i].s, &v[i].f.f, &v[i].f.s);\n\n    double a1 = 0.0; REP(i,n) a1 += v[i].f.f; a1 /= n;\n    double a2 = 0.0; REP(i,n) a2 += v[i].f.s; a2 /= n;\n\n    double b1 = 0.0; REP(i,n) b1 += dbl(v[i].f.f - a1); b1 /= n;\n    double b2 = 0.0; REP(i,n) b2 += dbl(v[i].f.s - a2); b2 /= n;\n\n    if(b1 < b2) REP(i,n) swap(v[i].f.f, v[i].f.s);\n\n    sort(v.begin(), v.end());\n\n    double ans = 1e20;\n\n    for(int i = 0; i < v.size(); i++){\n      double x1 = v[i].f.f;\n      double r  = v[i].s;\n      for(int j = i + 1; j < v.size(); j++){\n\tdouble x2 = v[j].f.f;\n\n\tif((x2 - x1 + r) > ans) break;\n\n\tans = min(ans, dist(v[i], v[j]));\n      }\n    }\n    \n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst long double EPS = 1e-8;\nconst int MAX_N = 100000;\nconst long double INF = 1000000000000000.0;\n\nbool equal(long double a, long double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   long double x, y, r;\n   Circle(){}\n   Circle(long double y, long double x, long double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\nlong double closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   long double x = a[m].x;\n   long double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) > d + a[i].r || equal(fabs(a[i].x - x), d+a[i].r)) continue;\n      for(int j=0;j<b.size();j++){\n         long double dx = a[i].x - b[b.size()-j-1].x;\n         long double dy = a[i].y - b[b.size()-j-1].y;\n         long double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy > d + dr || equal(dy, d+dr)) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<pair<double,double>,double> data;\n\ntemplate<class T> inline T dbl(T a){ return a * a; }\n\ninline double dist(const data &a, const data &b){\n  return sqrt(dbl(a.f.f - b.f.f) + dbl(a.f.s - b.f.s)) - (a.s + b.s);\n}\n\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n), n){\n    vector<data> v(n);\n\n    REP(i,n)\n      scanf(\"%lf%lf%lf\", &v[i].s, &v[i].f.f, &v[i].f.s);\n\n    double a1 = 0.0; REP(i,n) a1 += v[i].f.f; a1 /= n;\n    double a2 = 0.0; REP(i,n) a2 += v[i].f.s; a2 /= n;\n\n    double b1 = 0.0; REP(i,n) b1 += dbl(v[i].f.f - a1); b1 /= n;\n    double b2 = 0.0; REP(i,n) b2 += dbl(v[i].f.s - a2); b2 /= n;\n\n    if(b1 < b2) REP(i,n) swap(v[i].f.f, v[i].f.s);\n\n    sort(v.begin(), v.end());\n\n    double ans = 1e20;\n\n    for(int i = 0; i < v.size(); i++){\n      double x1 = v[i].f.f;\n      double r  = v[i].s;\n      for(int j = i + 1; j < v.size(); j++){\n\tdouble x2 = v[j].f.f;\n\n\tif((x2 - x1 + r) > ans) break;\n\n\tans = min(ans, dist(v[i], v[j]));\n      }\n    }\n    \n    printf(\"%.6f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//accepter by 10245\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point & a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point & a){\n    return sqrt((a.x-x)*(a.x-x)+(a.y-y)*(a.y-y))-r-a.r;\n  }\n};\ndouble min_val=10000;//need to insert Largest value\n#define MAXPOINT 1e250\nPoint BigPoint ={MAXPOINT,MAXPOINT};\ndouble maxr;\n\nvoid Merge(Point *a,int l,int mid,int r,double midx){\n  int n1 = mid-l+1,n2 = r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  for(int i=0;i<n1;i++)L[i]=a[l+i];\n  for(int i=0;i<n2;i++)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  for(int i=l;i<r+1;i++){\n    if ( L[pl].y < R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n\n  vector<Point> t;\n  for(int i=l;i<r+1;i++){\n    if ( abs(midx-a[i].x)< min_val+2*maxr){\n      t.push_back(a[i]);\n    } \n  }\n  for(int i=0;i<t.size();i++){\n    for(int j=i+1;j<t.size()&&abs(t[i].y-t[j].y)<min_val+2*maxr;j++){\n      min_val=min(min_val,t[i].dist(t[j]));\n    }\n  }\n\n\n}\n\n\nvoid MergeSort(Point *a,int l,int r){//include r that means <=r\n  if ( l<r){\n    int q = (r+l)/2;\n    double midx = a[q].x;\n    MergeSort(a,l,q);\n    MergeSort(a,q+1,r);\n    Merge(a,l,q,r,midx);\n  }\n}\n\n\nmain(){\nint n;\n  while(cin >>n && n){\n    min_val = 1e250;\n    Point a[n];\n    maxr=0;\n    for(int i=0;i<n;i++){\n      cin>>a[i].r>>a[i].x>>a[i].y;\n      maxr=max(maxr,a[i].r);\n    }\n    sort(a,a+n);\n    MergeSort(a,0,n-1);\n    printf(\"%.10lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nstruct C{\n\tdouble r,x,y;\n\tC(double r,double x,double y) : r(r) , x(x) , y(y) {}\n};\n\nbool cmp_x(const C &a,const C &b){ return a.x == b.x ? a.y < b.y : a.x < b.x ; }\nbool cmp_y(const C &a,const C &b){ return a.y == b.y ? a.x < b.x : a.y < b.y ; }\n\ndouble dist(const C &a,const C &b){\n\tdouble x = a.x - b.x;\n\tdouble y = a.y - b.y;\n\treturn sqrt( x * x + y * y );\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tvector<C> a,b;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble r,x,y;\n\t\t\tcin >> r >> x >> y;\n\t\t\ta.push_back(C(r,x,y));\n\t\t\tb.push_back(C(r,x,y));\n\t\t}\n\t\tdouble ans = 1e15;\n\t\tsort(a.begin(),a.end(),cmp_x);\n\t\tsort(b.begin(),b.end(),cmp_y);\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = i+1 ; j < min(i+12,n) ; j++){\n\t\t\t\tans = min(ans,dist(a[i],a[j])-a[i].r-a[j].r);\n\t\t\t}\n\t\t\tfor(int j = i+1 ; j < min(i+12,n) ; j++){\n\t\t\t\tans = min(ans,dist(b[i],b[j])-b[i].r-b[j].r);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f%c\",ans,10);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst double EPS = 1e-5;\nconst int MAX_N = 100000;\nconst double INF = 100000000.0;\n\nbool equal(double a, double b){\n   return fabs(a - b) < EPS;\n}\n\nclass Circle{\npublic:\n   double x, y, r;\n   Circle(){}\n   Circle(double y, double x, double r) : y(y), x(x), r(r) {}\n   bool operator < (const Circle& s) const {\n      if(equal(x, s.x)){\n         if(equal(y, s.y)){\n            return r > s.r;\n         }\n         return y < s.y;\n      }\n      return x < s.x;\n   }\n};\n\nint N;\nCircle A[MAX_N];\n\nbool compare_y(Circle a, Circle b){\n   return a.y < b.y;\n}\n\ndouble closest_pair(Circle* a, int n){\n   if(n <= 1) return INF;\n   int m = n / 2;\n   double x = a[m].x;\n   double d = min(closest_pair(a, m), closest_pair(a + m, n - m));\n   inplace_merge(a, a + m, a + n, compare_y);\n\n   vector<Circle> b;\n   for(int i=0;i<n;i++){\n      if(fabs(a[i].x - x) > d + a[i].r || equal(fabs(a[i].x - x), d+a[i].r)) continue;\n      for(int j=0;j<b.size();j++){\n         double dx = a[i].x - b[b.size()-j-1].x;\n         double dy = a[i].y - b[b.size()-j-1].y;\n         double dr = a[i].r + b[b.size()-j-1].r;\n         if(dy > d + dr || equal(dy, d+dr)) break;\n         d = min(d, sqrt(dx * dx + dy * dy) - dr);\n      }\n      b.push_back(a[i]);\n   }\n   return d;\n}\n\nmain(){\n   while(cin >> N && N){\n      for(int i=0;i<N;i++) cin >> A[i].r >> A[i].x >> A[i].y;\n      sort(A, A+N);\n      cout << closest_pair(A, N) << endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\nstruct Circle{\n  double r;\n  double x, y;\n};\n\ndouble GetDistance(const Circle, const Circle);\nvoid SearchLeft(const Circle, multimap<double, Circle>, double&);\nvoid SearchRight(const Circle, multimap<double, Circle>, double&);\n\nint main(){\n  int i, n;\n  double min, left_edge, right_edge;\n  multimap<double, Circle> left, right;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    for(i=0; i<n; ++i){\n      Circle circle;\n      cin >> circle.r >> circle.x >> circle.y;\n\n      if(i == 1)\n\tmin = GetDistance(circle, left.begin()->second);\n      else if(i != 0 && circle.x <= (left_edge + right_edge)/2)\n\tSearchLeft(circle, left, min);\n      else if(i != 0)\n\tSearchLeft(circle, right, min);\n\n      left.insert(make_pair(circle.x - circle.r, circle));\n      right.insert(make_pair(circle.x + circle.r, circle));\n      if(i == 0 || left_edge > circle.x - circle.r)\n\tleft_edge = circle.x - circle.r;\n      if(i == 0 || right_edge < circle.x + circle.r)\n\tright_edge = circle.x + circle.r;\n    }\n\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.precision(10);\n    cout << min << endl;\n  }\n  return 0;\n}\n\ndouble GetDistance(const Circle a, const Circle b){\n  double x, y, r;\n  x = a.x - b.x;\n  y = a.y - b.y;\n  return sqrt(x*x + y*y) - a.r - b.r;\n}\n\nvoid SearchLeft(const Circle circle, multimap<double, Circle> left, double& min){\n  double _min;\n  multimap<double, Circle>::iterator i;\n  for(i=left.begin(); i!=left.end(); ++i){\n    if(i->second.x - i->second.r >= circle.x + circle.r + min) return;\n    if(i->second.x + i->second.r <= circle.x - circle.r - min) continue;\n    if(i->second.y - i->second.r <= circle.y - circle.r - min) continue;\n    if(i->second.y + i->second.r >= circle.y + circle.r + min) continue;\n\n    _min = GetDistance(circle, i->second);\n    if(min > _min) min = _min;\n  }\n}\n\nvoid SearchRight(const Circle circle, multimap<double, Circle> right, double& min){\n  double _min;\n  multimap<double, Circle>::reverse_iterator i;\n  for(i=right.rbegin(); i!=right.rend(); ++i){\n    if(i->second.x + i->second.r <= circle.x - circle.r - min) return;\n    if(i->second.x - i->second.r >= circle.x + circle.r + min) continue;\n    if(i->second.y - i->second.r <= circle.y - circle.r - min) continue;\n    if(i->second.y + i->second.r >= circle.y + circle.r + min) continue;\n\n    _min = GetDistance(circle, i->second);\n    if(min > _min) min = _min;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass Point{\npublic:\n  double x,y,r;\n  bool operator<(const Point &a)const{\n    if ( x != a.x)return x < a.x;\n    return y < a.y;\n  }\n  double dist(Point &a){\n    return sqrt((x-a.x)*(x-a.x)+(y-a.y)*(y-a.y))-r-a.r;\n  }\n};\n\n#define MAXPOINT\nPoint BigPoint={1e250,1e250,1e250};\ndouble min_val;\nPoint tarray[100000];\n\nvoid merge(Point *a,int l,int mid,int r,double midx,double &maxr){\n  int n1=mid-l+1,n2=r-mid,pr=0,pl=0;\n  Point L[n1+1],R[n2+1];\n  rep(i,n1)L[i]=a[l+i];\n  rep(i,n2)R[i]=a[mid+1+i];\n  L[n1]=R[n2]=BigPoint;\n  REP(i,l,r+1){\n    if ( L[pl].y<R[pr].y)a[i]=L[pl++];\n    else a[i]=R[pr++];\n  }\n  \n  int p=0;\n  REP(i,l,r+1){\n    if ( abs(midx-a[i].x) <1e-10+ min_val+3*maxr){\n      for(int j=p-1;j>=0 && abs(tarray[j].y-a[i].y)<1e-10+3*maxr+min_val;j--){\n\tmin_val=min(tarray[j].dist(a[i]),min_val);\n      }\n      tarray[p++]=a[i];\n    }\n  }\n\n}\n\nvoid MergeSort(Point *a,int l,int r,double &maxr){\n  if (l<r){\n    int q = (r+l)/2;\n    double midx=a[q].x;\n    MergeSort(a,l,q,maxr);\n    MergeSort(a,q+1,r,maxr);\n    merge(a,l,q,r,midx,maxr);\n  }\n}\n\nmain(){\n  int n;\n  while(scanf(\"%d\",&n) && n){\n    Point a[n];\n    double maxr=0;\n    rep(i,n){\n      scanf(\"%lf%lf%lf\",&a[i].r,&a[i].x,&a[i].y);\n      maxr=max(maxr,a[i].r);\n    }\n    min_val = 1e250;\n    MergeSort(a,0,n-1,maxr);\n    printf(\"%.7lf\\n\",min_val);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n\ndouble circle[100001][3];\n\ndouble distance(int i,int j){\nreturn sqrt((circle[i][0]-circle[j][0])*(circle[i][0]-circle[j][0])+(circle[i][1]-circle[j][1])*(circle[i][1]-circle[j][1]))\n-circle[i][2]-circle[j][2];\n}\n\nint main(){\n\tint n,i,j;\ndouble min;\n\nwhile(0<=scanf(\"%d\",&n)){\nif(n==0)break;\n\nfor(i=0;i<n;i++){\nscanf(\"%lf%lf%lf\",&circle[i][2],&circle[i][1],&circle[i][0]);\n}\nmin=distance(0,1);\nfor(i=0;i<n-1;i++){\nfor(j=i+1;j<n;j++){\nif(min>distance(i,j))min=distance(i,j);\n}\n}\nprintf(\"%lf\\n\",min);\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <set>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n\nusing namespace std;\n\n#define EPS 1e-8\n#define PI acos(-1)\n#define Vector Point\n\nstruct Point\n{\n    double x, y, r;\n    Point(){}\n    Point(double a, double b, double c) { x = a; y = b; r = c; }\n    double mod2() { return x*x + y*y; }\n    double mod()  { return sqrt(x*x + y*y); }\n};\n\nbool operator ==(const Point &a, const Point &b)\n{\n    return fabs(a.x - b.x) < EPS && fabs(a.y - b.y) < EPS;\n}\nbool operator !=(const Point &a, const Point &b)\n{\n    return !(a==b);\n}\nbool operator <(const Point &a, const Point &b)\n{\n    if(a.x != b.x) return a.x < b.x;\n    return a.y < b.y;\n}\n\nbool XYorder(Point P1, Point P2)\n{\n\tif(P1.x != P2.x) return P1.x < P2.x;\n\treturn P1.y < P2.y;\n}\nbool YXorder(Point P1, Point P2)\n{\n\tif(P1.y != P2.y) return P1.y < P2.y;\n\treturn P1.x < P2.x;\n}\n\ndouble dist(const Point &A, const Point &B)\n{\n\treturn hypot(A.x - B.x, A.y - B.y) - A.r - B.r;\n}\n\ndouble closest_recursive(vector <Point> vx, vector <Point> vy)\n{\n\tif(vx.size()==1) return 1e20;\n\tif(vx.size()==2) return dist(vx[0], vx[1]);\n\t\n\tPoint cut = vx[vx.size()/2];\n\t\n\tvector <Point> vxL, vxR;\n\tfor(int i=0; i<vx.size(); i++)\n\t\tif(vx[i].x < cut.x || (vx[i].x == cut.x && vx[i].y <= cut.y))\n\t\t\tvxL.push_back(vx[i]);\n\t\telse vxR.push_back(vx[i]);\n\t\n\tvector <Point> vyL, vyR;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(vy[i].x < cut.x || (vy[i].x == cut.x && vy[i].y <= cut.y))\n\t\t\tvyL.push_back(vy[i]);\n\t\telse vyR.push_back(vy[i]);\n\t\n\tdouble dL = closest_recursive(vxL, vyL);\n\tdouble dR = closest_recursive(vxR, vyR);\n\tdouble d = min(dL, dR);\n\t\n\tvector <Point> b;\n\tfor(int i=0; i<vy.size(); i++)\n\t\tif(abs(vy[i].x - cut.x) <= d)\n\t\t\tb.push_back(vy[i]);\n\t\n\tfor(int i=0; i<b.size(); i++)\n\t\tfor(int j=i+1; j<b.size() && (b[j].y - b[i].y) <= d; j++)\n\t\t\td = min(d, dist(b[i], b[j]));\n\t\n\treturn d;\n}\ndouble closest(vector <Point> points)\n{\n\tvector <Point> vx = points, vy = points;\n\tsort(vx.begin(), vx.end(), XYorder);\n\tsort(vy.begin(), vy.end(), YXorder);\n\treturn closest_recursive(vx,vy);\n}\n\nint main()\n{\n\tint n;\n\twhile(cin>>n)\n\t{\n\t\tif(n == 0) break;\n\t\t\n\t\tvector <Point> P(n);\n\t\tfor(int i=0; i<n; i++)\n\t\t\tcin>>P[i].r>>P[i].x>>P[i].y;\n\t\tcout<<closest(P)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2057 The Closest Circle\n// 2018.3.14 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n\n#define INF     1e12\n#define EPS     1e-7\n#define PI180   0.01745329251994329576923690768489\t\t// PI/180\n\ntypedef struct { double x, y, r; } T;\nT tbl[100002];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ndouble getdbl()\n{\n\tint minus = 0;\n\tdouble x, y;\n\tint n = 0, c = getchar_unlocked();\n\tif (c == '-') minus = 1, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = getchar_unlocked();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\tif (minus) x = -x;\n\treturn x;\n}\n\nint cmp(T *a, T *b)\n{\n\tif (fabs(a->x - b->x) < EPS) {\n\t\tif (fabs(a->y - b->y) < EPS) return 0;\n\t\tif (a->y < b->y) return -1; return 1;\n\t}\n\tif (a->x < b->x) return -1;\treturn 1;\n}\n\ndouble dist(T *a, T *b)\n{\n\treturn hypot(a->x-b->x, a->y-b->y) - a->r - b->r;\n}\n\nint main()\n{\n\tint N, angle, i, j, lim;\n\tdouble _sin, _cos, x, y, t, ans;\n\n\tsrand((unsigned)time(NULL));\n\twhile (N = in()) {\n\t\tangle = rand() % 44;\n\t\t\n\t\t_sin = sin(PI180 * angle), _cos = cos(PI180 * angle);\n\t\tfor (i = 0; i < N; i++) {\n\t\t\ttbl[i].r = getdbl(), x = getdbl(), y = getdbl();\n\t\t\ttbl[i].x = x*_cos - y*_sin;\n\t\t\ttbl[i].y = x*_sin + y*_cos;\n\t\t}\n\n\t\tqsort(tbl, N, sizeof(T), cmp);\n\n\t\tans = INF;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tlim = i+3; if (lim > N) lim = N;\n\t\t\tfor (j = i+1; j < lim; j++) {\n\t\t\t\tt = dist(tbl+i, tbl+j);\n\t\t\t\tif (t < ans) ans = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2057 The Closest Circle\n// 2018.3.14 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>\n\n#define INF     1e12\n#define EPS     1e-7\n#define PI180   0.01745329251994329576923690768489\t\t// PI/180\n\ntypedef struct { double x, y, r; } T;\nT tbl[100002];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ndouble getdbl()\n{\n\tint minus = 0;\n\tdouble x, y;\n\tint n = 0, c = getchar_unlocked();\n\tif (c == '-') minus = 1, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = getchar_unlocked();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\tif (minus) x = -x;\n\treturn x;\n}\n\nint cmp(T *a, T *b)\n{\n\tif (fabs(a->x - b->x) < EPS) {\n\t\tif (fabs(a->y - b->y) < EPS) return 0;\n\t\tif (a->y < b->y) return -1; return 1;\n\t}\n\tif (a->x < b->x) return -1;\treturn 1;\n}\n\ndouble dist(T *a, T *b)\n{\n\treturn hypot(a->x-b->x, a->y-b->y) - a->r - b->r;\n}\n\nint main()\n{\n\tint N, angle, i, j, lim;\n\tdouble _sin, _cos, x, y, t, ans;\n\n\tsrand((unsigned)time(NULL));\n\twhile (N = in()) {\n\t\tangle = rand() % 44;\n\t\t\n\t\t_sin = sin(PI180 * angle), _cos = cos(PI180 * angle);\n\t\tfor (i = 0; i < N; i++) {\n\t\t\ttbl[i].r = getdbl(), x = getdbl(), y = getdbl();\n\t\t\ttbl[i].x = x*_cos - y*_sin;\n\t\t\ttbl[i].y = x*_sin + y*_cos;\n\t\t}\n\n\t\tqsort(tbl, N, sizeof(T), cmp);\n\n\t\tans = INF;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tlim = i+6; if (lim > N) lim = N;\n\t\t\tfor (j = i+1; j < lim; j++) {\n\t\t\t\tt = dist(tbl+i, tbl+j);\n\t\t\t\tif (t < ans) ans = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2057 The Closest Circle\n// 2018.3.14 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define INF     1e12\n#define EPS     1e-7\n#define RANGE\t4\n#define SIN     0.70710678118654752440084436210485    // Sin(45)\n#define COS     0.70710678118654752440084436210485    // Cos(45)\n#define SINCOS  SIN\n\ntypedef struct { double x, y, r; } T;\nT tbl[100002+RANGE];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\ndouble getdbl()\n{\n\tint minus = 0;\n\tdouble x, y;\n\tint n = 0, c = getchar_unlocked();\n\tif (c == '-') minus = 1, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\n\tif (c == '.') {\n\t\tx = 0;\n\t\ty = 1, c = getchar_unlocked();\n\t\tdo y *= 0.1, x += y * (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\tx += n;\n\t} else x = n;\n\tif (minus) x = -x;\n\treturn x;\n}\n\nint cmp(T *a, T *b)\n{\n\tif (fabs(a->x - b->x) < EPS) {\n\t\tif (fabs(a->y - b->y) < EPS) return 0;\n\t\tif (a->y < b->y) return -1; return 1;\n\t}\n\tif (a->x < b->x) return -1;\treturn 1;\n}\n\nint main()\n{\n\tint N, i, j, lim;\n\tdouble x, y, t, ans;\n\n\twhile (N = in()) {\n\n\t\tfor (i = 0; i < N; i++) {\n\t\t\ttbl[i].r = getdbl(), x = getdbl(), y = getdbl();\n\t\t\ttbl[i].x = (x - y) * SINCOS;\n\t\t\ttbl[i].y = (x + y) * SINCOS;\n\t\t}\n\n\t\tqsort(tbl, N, sizeof(T), cmp);\n\n\t\tans = INF;\n\t\tfor (i = N; i < N+RANGE; i++) tbl[i].x = INF, tbl[i].y = tbl[i].r = 0;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tlim = i+RANGE; for (j = i+1; j < lim; j++) {\n\t\t\t\tt = hypot(tbl[i].x-tbl[j].x, tbl[i].y-tbl[j].y) - tbl[i].r - tbl[j].r;\n\t\t\t\tif (t < ans) ans = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCircle[] info = new Circle[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tinfo[i] = new Circle(sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble());\n\t\t\t}\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble dist = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\t\tdist = Math.hypot(info[i].x - info[j].x, info[i].y\n\t\t\t\t\t\t\t- info[j].y);\n\t\t\t\t\tmin = Math.min(min, dist - info[i].r - info[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tCircle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\n\npublic class Main {\n\tScanner sc = new Scanner();\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCircle[] info = new Circle[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tinfo[i] = new Circle(sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble());\n\t\t\t}\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tdouble dist = 0;\n\t\t\tArrays.sort(info);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\t\tif (j > i + 50) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdist = Math.hypot(info[i].x - info[j].x, info[i].y\n\t\t\t\t\t\t\t- info[j].y);\n\t\t\t\t\tmin = Math.min(min, dist - info[i].r - info[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tclass Circle implements Comparable<Circle> {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tCircle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic int compareTo(Circle c) {\n\t\t\treturn (int) (this.x - c.x);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tstatic class Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic Circle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getR() {\n\t\t\treturn this.r;\n\t\t}\n\n\t\tpublic void set(double r) {\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic void setX(double x) {\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic void setY(double y) {\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.x + \", \" + this.y;\n\t\t}\n\t}\n\n\tstatic Circle[] circles = null;\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tScanner s = new Scanner(System.in);\n\t\t\tint N = Integer.parseInt(s.nextLine());\n\t\t\tif(N == 0)\n\t\t\t\tbreak;\n\t\t\tcircles = new Circle[N];\n\t\t\tfor(int i=0 ; i<N ; i++) {\n\t\t\t\tString[] tmp = s.nextLine().split(\" \");\n\t\t\t\tcircles[i] = new Circle(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1]), Double.parseDouble(tmp[2]));\n\t\t\t}\n\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getX));\n\t\t\tdouble res1 = solve(circles, 0, N-1);\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getY));\n\t\t\tdouble res2 = solve(circles, 0, N-1);\n\t\t\tSystem.out.println(Math.min(res1, res2));\n\t\t}\n\t}\n\n\tstatic double solve(Circle[] c, int start, int end) {\n\n\t\tif(start == end)\n\t\t\treturn Integer.MAX_VALUE;\n\t\tif(start == (end-1))\n\t\t\treturn Math.sqrt((c[start].x - c[end].x)*(c[start].x - c[end].x) + (c[start].y - c[end].y)*(c[start].y - c[end].y)) - c[start].r - c[end].r;\n\t\tint middle = (start + end) / 2;\n\n\t\tdouble result = Math.sqrt((c[middle].x - c[middle+1].x)*(c[middle].x - c[middle+1].x) + (c[middle].y - c[middle+1].y)*(c[middle].y - c[middle+1].y)) - c[middle].r - c[middle+1].r;\n\t\tdouble result1 = solve(c, start, middle);\n\t\tdouble result2 = solve(c, middle+1, end);\n\n\t\treturn Math.min(Math.min(result, result1), result2);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCircle[] info = new Circle[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tinfo[i] = new Circle(sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble());\n\t\t\t}\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble dist = 0;\n\t\t\tArrays.sort(info, new CircleComparator());\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\t\tif (j > i + 100) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdist = Math.hypot(info[i].x - info[j].x, info[i].y\n\t\t\t\t\t\t\t- info[j].y);\n\t\t\t\t\tmin = Math.min(min, dist - info[i].r - info[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tCircle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tclass CircleComparator implements Comparator<Circle> {\n\t\tpublic int compare(Circle p1, Circle p2) {\n\t\t\tdouble cmp = p1.x - p2.x;\n\t\t\tif (cmp == 0)\n\t\t\t\tcmp = p1.y - p2.y;\n\t\t\tif (cmp < 0)\n\t\t\t\tcmp = -1;\n\t\t\telse\n\t\t\t\tcmp = 1;\n\t\t\treturn (int) cmp;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tstatic class Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic Circle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getR() {\n\t\t\treturn this.r;\n\t\t}\n\n\t\tpublic void set(double r) {\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic void setX(double x) {\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic void setY(double y) {\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.x + \", \" + this.y;\n\t\t}\n\t}\n\n\tstatic Circle[] circles = null;\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tScanner s = new Scanner(System.in);\n\t\t\tint N = Integer.parseInt(s.nextLine());\n\t\t\tif(N == 0)\n\t\t\t\tbreak;\n\t\t\tcircles = new Circle[N];\n\t\t\tfor(int i=0 ; i<N ; i++) {\n\t\t\t\tString[] tmp = s.nextLine().split(\" \");\n\t\t\t\tcircles[i] = new Circle(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1]), Double.parseDouble(tmp[2]));\n\t\t\t}\n\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getX));\n\t\t\tdouble res1 = solve(circles, 0, N-1);\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getY));\n\t\t\tdouble res2 = solve(circles, 0, N-1);\n\t\t\tSystem.out.println(Math.min(res1, res2));\n\t\t}\n\t}\n\n\tstatic double solve(Circle[] c, int start, int end) {\n\n\t\tif(start == end)\n\t\t\treturn Integer.MAX_VALUE;\n\t\tif(start == (end-1))\n\t\t\treturn Math.sqrt((c[start].x - c[end].x)*(c[start].x - c[end].x) + (c[start].y - c[end].y)*(c[start].y - c[end].y)) - c[start].r - c[end].r;\n\t\tint middle = (start + end) / 2;\n\n\t\tdouble result = Math.sqrt((c[middle].x - c[middle+1].x)*(c[middle].x - c[middle+1].x) + (c[middle].y - c[middle+1].y)*(c[middle].y - c[middle+1].y)) - c[middle].r - c[middle+1].r;\n\t\tdouble result1 = solve(c, start, middle);\n\t\tdouble result2 = solve(c, middle+1, end);\n\n\t\treturn Math.min(Math.min(result, result1), result2);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Random;\n\n//The Closest Circle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass R implements Comparable<R>{\n\t\tdouble x, y, r;\n\t\tpublic R(double x, double y, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int)Math.signum(y-o.y);\n\t\t\treturn (int)Math.signum(x-o.x);\n\t\t}\n\t}\n\t\n\tdouble EPS = 1e-8;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint rot = rand.nextInt(44)+1;\n\t\t\tdouble sin = Math.sin(rot*Math.PI/180), cos = Math.cos(rot*Math.PI/180);\n\t\t\tR[] rs = new R[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble r = sc.nextDouble(), x = sc.nextDouble(), y = sc.nextDouble();\n\t\t\t\trs[i] = new R(cos*x-sin*y, sin*x+cos*y, r);\n\t\t\t}\n\t\t\tArrays.sort(rs);\n\t\t\tdouble res = 1L<<60;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint t = Math.min(n, i+50);\n\t\t\t\tfor(int j=i+1;j<t;j++){\n\t\t\t\t\tres = Math.min(res, Math.sqrt((rs[i].x-rs[j].x)*(rs[i].x-rs[j].x) + (rs[i].y-rs[j].y)*(rs[i].y-rs[j].y))-rs[i].r-rs[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.9f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Random;\n\n//The Closest Circle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass R implements Comparable<R>{\n\t\tdouble x, y, r;\n\t\tpublic R(double x, double y, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int)Math.signum(y-o.y);\n\t\t\treturn (int)Math.signum(x-o.x);\n\t\t}\n\t}\n\t\n\tdouble EPS = 1e-8;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint rot = rand.nextInt(44)+1;\n\t\t\tdouble sin = Math.sin(rot*Math.PI/180), cos = Math.cos(rot*Math.PI/180);\n\t\t\tR[] rs = new R[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble r = sc.nextDouble(), x = sc.nextDouble(), y = sc.nextDouble();\n\t\t\t\trs[i] = new R(cos*x-sin*y, sin*x+cos*y, r);\n\t\t\t}\n\t\t\tArrays.sort(rs);\n\t\t\tdouble res = 1L<<60;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint t = Math.min(n, i+5);\n\t\t\t\tfor(int j=i+1;j<t;j++){\n\t\t\t\t\tres = Math.min(res, Math.sqrt((rs[i].x-rs[j].x)*(rs[i].x-rs[j].x) + (rs[i].y-rs[j].y)*(rs[i].y-rs[j].y))-rs[i].r-rs[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.9f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Random;\n\n//The Closest Circle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass R implements Comparable<R>{\n\t\tdouble x, y, r;\n\t\tpublic R(double x, double y, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int)Math.signum(y-o.y);\n\t\t\treturn (int)Math.signum(x-o.x);\n\t\t}\n\t}\n\t\n\tdouble EPS = 1e-8;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint rot = rand.nextInt(179)+1;\n\t\t\tdouble sin = Math.sin(rot*Math.PI/180), cos = Math.cos(rot*Math.PI/180);\n\t\t\tR[] rs = new R[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble r = sc.nextDouble(), x = sc.nextDouble(), y = sc.nextDouble();\n\t\t\t\trs[i] = new R(cos*x-sin*y, sin*x+cos*y, r);\n\t\t\t}\n\t\t\tArrays.sort(rs);\n\t\t\tdouble res = 1L<<60;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint t = Math.min(n, i+100);\n\t\t\t\tfor(int j=i+1;j<t;j++){\n\t\t\t\t\tres = Math.min(res, Math.sqrt((rs[i].x-rs[j].x)*(rs[i].x-rs[j].x) + (rs[i].y-rs[j].y)*(rs[i].y-rs[j].y))-rs[i].r-rs[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.9f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n\npublic class Main{\n\n\tstatic class Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic Circle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getR() {\n\t\t\treturn this.r;\n\t\t}\n\n\t\tpublic void set(double r) {\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic void setX(double x) {\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic void setY(double y) {\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.x + \", \" + this.y;\n\t\t}\n\t}\n\n\tstatic Circle[] circles = null;\n\tpublic static void main(String[] args) throws Exception{\n\t\t//Scanner s = new Scanner(System.in);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true) {\n\t\t\tint N = Integer.parseInt(br.readLine());\n\t\t\tif(N == 0)\n\t\t\t\tbreak;\n\t\t\tcircles = new Circle[N];\n\t\t\tfor(int i=0 ; i<N ; i++) {\n\t\t\t\tString[] tmp = br.readLine().split(\" \");\n\t\t\t\tcircles[i] = new Circle(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1]), Double.parseDouble(tmp[2]));\n\t\t\t}\n\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getX));\n\t\t\tdouble res1 = solve(circles, 0, N-1);\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getY));\n\t\t\tdouble res2 = solve(circles, 0, N-1);\n\t\t\tSystem.out.println(Math.min(res1, res2));\n\t\t}\n\t}\n\n\tstatic double solve(Circle[] c, int start, int end) {\n\n\t\tif(start == end)\n\t\t\treturn Integer.MAX_VALUE;\n\t\tif(start == (end-1))\n\t\t\treturn Math.sqrt((c[start].x - c[end].x)*(c[start].x - c[end].x) + (c[start].y - c[end].y)*(c[start].y - c[end].y)) - c[start].r - c[end].r;\n\t\tint middle = (start + end) / 2;\n\n\t\tdouble result = Math.sqrt((c[middle].x - c[middle+1].x)*(c[middle].x - c[middle+1].x) + (c[middle].y - c[middle+1].y)*(c[middle].y - c[middle+1].y)) - c[middle].r - c[middle+1].r;\n\t\tdouble result1 = solve(c, start, middle);\n\t\tdouble result2 = solve(c, middle+1, end);\n\n\t\treturn Math.min(Math.min(result, result1), result2);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.text.DecimalFormat;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n\npublic class Main{\n\n\tstatic class Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic Circle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getR() {\n\t\t\treturn this.r;\n\t\t}\n\n\t\tpublic void set(double r) {\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic void setX(double x) {\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic void setY(double y) {\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.x + \", \" + this.y;\n\t\t}\n\t}\n\n\tstatic Circle[] circles = null;\n\tstatic double maxRadius = 0.0;\n\tpublic static void main(String[] args) throws Exception{\n\t\t//Scanner s = new Scanner(System.in);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true) {\n\t\t\tint N = Integer.parseInt(br.readLine());\n\t\t\tif(N == 0)\n\t\t\t\tbreak;\n\t\t\tcircles = new Circle[N];\n\t\t\tfor(int i=0 ; i<N ; i++) {\n\t\t\t\tString[] tmp = br.readLine().split(\" \");\n\t\t\t\tcircles[i] = new Circle(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1]), Double.parseDouble(tmp[2]));\n\t\t\t\tmaxRadius = Math.max(maxRadius, Double.parseDouble(tmp[0]));\n\t\t\t}\n\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getX));\n\t\t\tdouble res1 = solve(circles, 0, N-1);\n\t\t\tDecimalFormat fmt = new DecimalFormat(\"0.00000000\");\n\n\t\t\tSystem.out.println(fmt.format(res1));\n\t\t}\n\t}\n\n\tstatic double solve(Circle[] c, int start, int end) {\n\n\t\tif(start == end || start > end)\n\t\t\treturn Integer.MAX_VALUE;\n\t\tif(start == (end-1))\n\t\t\treturn Math.hypot(c[start].x - c[end].x, c[start].y - c[end].y) - c[start].r - c[end].r;\n\t\tint middle = (start + end) / 2;\n\n\t\tdouble result = Math.sqrt((c[middle].x - c[middle+1].x)*(c[middle].x - c[middle+1].x) + (c[middle].y - c[middle+1].y)*(c[middle].y - c[middle+1].y)) - c[middle].r - c[middle+1].r;\n\t\tdouble result1 = solve(c, start, middle);\n\t\tdouble result2 = solve(c, middle+1, end);\n\n\t\tdouble distance =  Math.min(Math.min(result1, result2), result);\n\t\tint m = (start+end)/2;\n\t\tdouble middleP = (c[m-1].x + c[m].x) / 2;\n\t\tCircle[] cc = new Circle[end-start];\n\t\tint index = 0;\n\t\tfor(int i=start ; i<end ;i++) {\n\t\t\tif(Math.abs(c[i].x - middleP) < distance+2*maxRadius) {\n\t\t\t\tcc[index++] = c[i];\n\t\t\t}\n\t\t}\n\n\t\tif(index <= 1)\n\t\t\treturn distance;\n\t\tCircle[] cY = new Circle[index];\n\t\tfor(int i=0 ; i<index ; i++) {\n\t\t\tcY[i] = cc[i];\n\t\t}\n\t\tArrays.sort(cY, Comparator.comparing(Circle::getY));\n\n\t\tfor(int j=0 ; j<index ; j++) {\n\t\t\tfor(int k=j+1 ; k<index && (cY[k].y-cY[j].y < distance+2*maxRadius); k++) {\n\t\t\t\tdistance = Math.min(distance, Math.hypot(cY[j].x - cY[k].x, cY[j].y - cY[k].y) - cY[j].r - cY[k].r);\n\t\t\t}\n\t\t}\n\t\treturn distance;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.text.DecimalFormat;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n\npublic class Main{\n\n\tstatic class Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic Circle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getR() {\n\t\t\treturn this.r;\n\t\t}\n\n\t\tpublic void set(double r) {\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic void setX(double x) {\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic void setY(double y) {\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.x + \", \" + this.y;\n\t\t}\n\t}\n\n\tstatic Circle[] circles = null;\n\tstatic double maxRadius = 0.0;\n\tpublic static void main(String[] args) throws Exception{\n\t\t//Scanner s = new Scanner(System.in);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true) {\n\t\t\tint N = Integer.parseInt(br.readLine());\n\t\t\tif(N == 0)\n\t\t\t\tbreak;\n\t\t\tcircles = new Circle[N];\n\t\t\tfor(int i=0 ; i<N ; i++) {\n\t\t\t\tString[] tmp = br.readLine().split(\" \");\n\t\t\t\tcircles[i] = new Circle(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1]), Double.parseDouble(tmp[2]));\n\t\t\t\tmaxRadius = Math.max(maxRadius, Double.parseDouble(tmp[0]));\n\t\t\t}\n\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getX));\n\t\t\tdouble res1 = solve(circles, 0, N-1);\n\t\t\tDecimalFormat fmt = new DecimalFormat(\"0.00000000\");\n\n\t\t\tSystem.out.println(fmt.format(res1));\n\t\t}\n\t}\n\n\tstatic double solve(Circle[] c, int start, int end) {\n\n\t\tif(start == end || start > end)\n\t\t\treturn Integer.MAX_VALUE;\n\t\tif(start == (end-1))\n\t\t\treturn Math.hypot(c[start].x - c[end].x, c[start].y - c[end].y) - c[start].r - c[end].r;\n\t\tint middle = (start + end) / 2;\n\n\t\t//double result = Math.sqrt((c[middle].x - c[middle+1].x)*(c[middle].x - c[middle+1].x) + (c[middle].y - c[middle+1].y)*(c[middle].y - c[middle+1].y)) - c[middle].r - c[middle+1].r;\n\t\tdouble result1 = solve(c, start, middle);\n\t\tdouble result2 = solve(c, middle+1, end);\n\n\t\tdouble distance =  Math.min(result1, result2);\n\t\tint m = (start+end)/2;\n\t\tdouble middleP = (c[m-1].x + c[m].x) / 2;\n\t\tCircle[] cc = new Circle[end-start];\n\t\tint index = 0;\n\t\tfor(int i=start ; i<end ;i++) {\n\t\t\tif(Math.abs(c[i].x - middleP) < distance+2*maxRadius) {\n\t\t\t\tcc[index++] = c[i];\n\t\t\t}\n\t\t}\n\n\t\tif(index <= 1)\n\t\t\treturn distance;\n\t\tCircle[] cY = new Circle[index];\n\t\tfor(int i=0 ; i<index ; i++) {\n\t\t\tcY[i] = cc[i];\n\t\t}\n\t\tArrays.sort(cY, Comparator.comparing(Circle::getY));\n\n\t\tfor(int j=0 ; j<index ; j++) {\n\t\t\tfor(int k=j+1 ; k<index && (cY[k].y-cY[j].y < distance+2*maxRadius); k++) {\n\t\t\t\tdistance = Math.min(distance, Math.hypot(cY[j].x - cY[k].x, cY[j].y - cY[k].y) - cY[j].r - cY[k].r);\n\t\t\t}\n\t\t}\n\t\treturn distance;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Random;\n\n//The Closest Circle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass R implements Comparable<R>{\n\t\tdouble x, y, r;\n\t\tpublic R(double x, double y, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int)Math.signum(y-o.y);\n\t\t\treturn (int)Math.signum(x-o.x);\n\t\t}\n\t}\n\t\n\tdouble EPS = 1e-8;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint rot = rand.nextInt(44)+1;\n\t\t\tdouble sin = Math.sin(rot*Math.PI/180), cos = Math.cos(rot*Math.PI/180);\n\t\t\tR[] rs = new R[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble r = sc.nextDouble(), x = sc.nextDouble(), y = sc.nextDouble();\n\t\t\t\trs[i] = new R(cos*x-sin*y, sin*x+cos*y, r);\n\t\t\t}\n\t\t\tArrays.sort(rs);\n\t\t\tdouble res = 1L<<60;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint t = Math.min(n, i+10);\n\t\t\t\tfor(int j=i+1;j<t;j++){\n\t\t\t\t\tres = Math.min(res, Math.sqrt((rs[i].x-rs[j].x)*(rs[i].x-rs[j].x) + (rs[i].y-rs[j].y)*(rs[i].y-rs[j].y))-rs[i].r-rs[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.9f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tstatic class Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic Circle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getR() {\n\t\t\treturn this.r;\n\t\t}\n\n\t\tpublic void set(double r) {\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic void setX(double x) {\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic void setY(double y) {\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.x + \", \" + this.y;\n\t\t}\n\t}\n\n\tstatic Circle[] circles = null;\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint N = s.nextInt();\n\t\t\tif(N == 0)\n\t\t\t\tbreak;\n\t\t\tcircles = new Circle[N];\n\t\t\tfor(int i=0 ; i<N ; i++) {\n\t\t\t\t//String[] tmp = s.nextLine().split(\" \");\n\t\t\t\tcircles[i] = new Circle(s.nextDouble(), s.nextDouble(), s.nextDouble());\n\t\t\t}\n\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getX));\n\t\t\tdouble res1 = solve(circles, 0, N-1);\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getY));\n\t\t\tdouble res2 = solve(circles, 0, N-1);\n\t\t\tSystem.out.println(Math.min(res1, res2));\n\t\t}\n\t}\n\n\tstatic double solve(Circle[] c, int start, int end) {\n\n\t\tif(start == end)\n\t\t\treturn Integer.MAX_VALUE;\n\t\tif(start == (end-1))\n\t\t\treturn Math.sqrt((c[start].x - c[end].x)*(c[start].x - c[end].x) + (c[start].y - c[end].y)*(c[start].y - c[end].y)) - c[start].r - c[end].r;\n\t\tint middle = (start + end) / 2;\n\n\t\tdouble result = Math.sqrt((c[middle].x - c[middle+1].x)*(c[middle].x - c[middle+1].x) + (c[middle].y - c[middle+1].y)*(c[middle].y - c[middle+1].y)) - c[middle].r - c[middle+1].r;\n\t\tdouble result1 = solve(c, start, middle);\n\t\tdouble result2 = solve(c, middle+1, end);\n\n\t\treturn Math.min(Math.min(result, result1), result2);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.text.DecimalFormat;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n\npublic class Main{\n\n\tstatic class Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic Circle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getR() {\n\t\t\treturn this.r;\n\t\t}\n\n\t\tpublic void set(double r) {\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic void setX(double x) {\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic void setY(double y) {\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.x + \", \" + this.y;\n\t\t}\n\t}\n\n\tstatic Circle[] circles = null;\n\tstatic double maxRadius = 0.0;\n\tpublic static void main(String[] args) throws Exception{\n\t\t//Scanner s = new Scanner(System.in);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true) {\n\t\t\tint N = Integer.parseInt(br.readLine());\n\t\t\tif(N == 0)\n\t\t\t\tbreak;\n\t\t\tcircles = new Circle[N];\n\t\t\tfor(int i=0 ; i<N ; i++) {\n\t\t\t\tString[] tmp = br.readLine().split(\" \");\n\t\t\t\tcircles[i] = new Circle(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1]), Double.parseDouble(tmp[2]));\n\t\t\t\tmaxRadius = Math.max(maxRadius, Double.parseDouble(tmp[0]));\n\t\t\t}\n\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getX));\n\t\t\tdouble res1 = solve(circles, 0, N-1);\n\t\t\tDecimalFormat fmt = new DecimalFormat(\"0.00000000\");\n\n\t\t\tSystem.out.println(fmt.format(res1));\n\t\t}\n\t}\n\n\tstatic double solve(Circle[] c, int start, int end) {\n\n\t\tif(start == end || start > end)\n\t\t\treturn Integer.MAX_VALUE;\n\t\tif(start == (end-1))\n\t\t\treturn Math.sqrt((c[start].x - c[end].x)*(c[start].x - c[end].x) + (c[start].y - c[end].y)*(c[start].y - c[end].y)) - c[start].r - c[end].r;\n\t\tint middle = (start + end) / 2;\n\n\t\t//double result = Math.sqrt((c[middle].x - c[middle+1].x)*(c[middle].x - c[middle+1].x) + (c[middle].y - c[middle+1].y)*(c[middle].y - c[middle+1].y)) - c[middle].r - c[middle+1].r;\n\t\tdouble result1 = solve(c, start, middle);\n\t\tdouble result2 = solve(c, middle+1, end);\n\n\t\tdouble distance =  Math.min(result1, result2);\n\t\tint m = (start+end)/2;\n\t\tdouble middleP = (c[m-1].x + c[m].x) / 2;\n\t\tCircle[] cc = new Circle[end-start];\n\t\tint index = 0;\n\t\tfor(int i=start ; i<end ;i++) {\n\t\t\tif(Math.abs(c[i].x - middleP) < distance+2*maxRadius) {\n\t\t\t\tcc[index++] = c[i];\n\t\t\t}\n\t\t}\n\n\t\tif(index <= 1)\n\t\t\treturn distance;\n\t\tCircle[] cY = new Circle[index];\n\t\tfor(int i=0 ; i<index ; i++) {\n\t\t\tcY[i] = cc[i];\n\t\t}\n\t\tArrays.sort(cY, Comparator.comparing(Circle::getY));\n\n\t\tfor(int j=0 ; j<index ; j++) {\n\t\t\tfor(int k=j+1 ; k<index && (cY[k].y-cY[j].y < distance+2*maxRadius); k++) {\n\t\t\t\tdistance = Math.min(distance, Math.sqrt((cY[j].x - cY[k].x)*(cY[j].x - cY[k].x) + (cY[j].y - cY[k].y)*(cY[j].y - cY[k].y)) - cY[j].r - cY[k].r);\n\t\t\t}\n\t\t}\n\t\treturn distance;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Random;\n\n//The Closest Circle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass R implements Comparable<R>{\n\t\tdouble x, y, r;\n\t\tpublic R(double x, double y, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int)Math.signum(y-o.y);\n\t\t\treturn (int)Math.signum(x-o.x);\n\t\t}\n\t}\n\t\n\tdouble EPS = 1e-8;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint rot = rand.nextInt(44)+1;\n\t\t\tdouble sin = Math.sin(rot*Math.PI/180), cos = Math.cos(rot*Math.PI/180);\n\t\t\tR[] rs = new R[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble r = sc.nextDouble(), x = sc.nextDouble(), y = sc.nextDouble();\n\t\t\t\trs[i] = new R(cos*x-sin*y, sin*x+cos*y, r);\n\t\t\t}\n\t\t\tArrays.sort(rs);\n\t\t\tdouble res = 1L<<60;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint t = Math.min(n, i+20);\n\t\t\t\tfor(int j=i+1;j<t;j++){\n\t\t\t\t\tres = Math.min(res, Math.sqrt((rs[i].x-rs[j].x)*(rs[i].x-rs[j].x) + (rs[i].y-rs[j].y)*(rs[i].y-rs[j].y))-rs[i].r-rs[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.9f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tCircle[] info = new Circle[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tinfo[i] = new Circle(sc.nextDouble(), sc.nextDouble(),\n\t\t\t\t\t\tsc.nextDouble());\n\t\t\t}\n\t\t\tdouble min = Integer.MAX_VALUE;\n\t\t\tdouble dist = 0;\n\t\t\tArrays.sort(info);\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\t\t\tif (j > i + 100) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdist = Math.hypot(info[i].x - info[j].x, info[i].y\n\t\t\t\t\t\t\t- info[j].y);\n\t\t\t\t\tmin = Math.min(min, dist - info[i].r - info[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Circle implements Comparable<Circle> {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tCircle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic int compareTo(Circle c) {\n\t\t\treturn (int) (this.x - c.x);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n\npublic class Main{\n\n\tstatic class Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic Circle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getR() {\n\t\t\treturn this.r;\n\t\t}\n\n\t\tpublic void set(double r) {\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic void setX(double x) {\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic void setY(double y) {\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.x + \", \" + this.y;\n\t\t}\n\t}\n\n\tstatic Circle[] circles = null;\n\tstatic double maxRadius = 0.0;\n\tpublic static void main(String[] args) throws Exception{\n\t\t//Scanner s = new Scanner(System.in);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true) {\n\t\t\tint N = Integer.parseInt(br.readLine());\n\t\t\tif(N == 0)\n\t\t\t\tbreak;\n\t\t\tcircles = new Circle[N];\n\t\t\tfor(int i=0 ; i<N ; i++) {\n\t\t\t\tString[] tmp = br.readLine().split(\" \");\n\t\t\t\tcircles[i] = new Circle(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1]), Double.parseDouble(tmp[2]));\n\t\t\t\tmaxRadius = Math.max(maxRadius, Double.parseDouble(tmp[0]));\n\t\t\t}\n\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getX));\n\t\t\tdouble res1 = solve(circles, 0, N-1);\n\t\t\tSystem.out.println(res1);\n\t\t}\n\t}\n\n\tstatic double solve(Circle[] c, int start, int end) {\n\n\t\tif(start == end || start > end)\n\t\t\treturn Integer.MAX_VALUE;\n\t\tif(start == (end-1))\n\t\t\treturn Math.sqrt((c[start].x - c[end].x)*(c[start].x - c[end].x) + (c[start].y - c[end].y)*(c[start].y - c[end].y)) - c[start].r - c[end].r;\n\t\tint middle = (start + end) / 2;\n\n\t\t//double result = Math.sqrt((c[middle].x - c[middle+1].x)*(c[middle].x - c[middle+1].x) + (c[middle].y - c[middle+1].y)*(c[middle].y - c[middle+1].y)) - c[middle].r - c[middle+1].r;\n\t\tdouble result1 = solve(c, start, middle);\n\t\tdouble result2 = solve(c, middle+1, end);\n\n\t\tdouble distance =  Math.min(result1, result2);\n\t\tint m = (start+end)/2;\n\t\tdouble middleP = (c[m-1].x + c[m].x) / 2;\n\t\tCircle[] cc = new Circle[end-start];\n\t\tint index = 0;\n\t\tfor(int i=start ; i<end ;i++) {\n\t\t\tif(Math.abs(c[i].x - middleP) < distance+2*maxRadius) {\n\t\t\t\tcc[index++] = c[i];\n\t\t\t}\n\t\t}\n\n\t\tif(index <= 1)\n\t\t\treturn distance;\n\t\tCircle[] cY = new Circle[index];\n\t\tfor(int i=0 ; i<index ; i++) {\n\t\t\tcY[i] = cc[i];\n\t\t}\n\t\tArrays.sort(cY, Comparator.comparing(Circle::getY));\n\n\t\tfor(int j=0 ; j<index ; j++) {\n\t\t\tfor(int k=j+1 ; k<index && (cY[k].y-cY[j].y < distance+2*maxRadius); k++) {\n\t\t\t\tdistance = Math.min(distance, Math.sqrt((cY[j].x - cY[k].x)*(cY[j].x - cY[k].x) + (cY[j].y - cY[k].y)*(cY[j].y - cY[k].y)) - cY[j].r - cY[k].r);\n\t\t\t}\n\t\t}\n\t\treturn distance;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n\npublic class Main{\n\n\tstatic class Circle {\n\t\tdouble r;\n\t\tdouble x;\n\t\tdouble y;\n\n\t\tpublic Circle(double r, double x, double y) {\n\t\t\tthis.r = r;\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\tpublic double getR() {\n\t\t\treturn this.r;\n\t\t}\n\n\t\tpublic void set(double r) {\n\t\t\tthis.r = r;\n\t\t}\n\n\t\tpublic double getX() {\n\t\t\treturn this.x;\n\t\t}\n\n\t\tpublic void setX(double x) {\n\t\t\tthis.x = x;\n\t\t}\n\n\t\tpublic double getY() {\n\t\t\treturn this.y;\n\t\t}\n\n\t\tpublic void setY(double y) {\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn this.x + \", \" + this.y;\n\t\t}\n\t}\n\n\tstatic Circle[] circles = null;\n\tstatic double maxRadius = 0.0;\n\tpublic static void main(String[] args) throws Exception{\n\t\t//Scanner s = new Scanner(System.in);\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\twhile(true) {\n\t\t\tint N = Integer.parseInt(br.readLine());\n\t\t\tif(N == 0)\n\t\t\t\tbreak;\n\t\t\tcircles = new Circle[N];\n\t\t\tfor(int i=0 ; i<N ; i++) {\n\t\t\t\tString[] tmp = br.readLine().split(\" \");\n\t\t\t\tcircles[i] = new Circle(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1]), Double.parseDouble(tmp[2]));\n\t\t\t\tmaxRadius = Math.max(maxRadius, Double.parseDouble(tmp[0]));\n\t\t\t}\n\n\t\t\tArrays.sort(circles, Comparator.comparing(Circle::getX));\n\t\t\tdouble res1 = solve(circles, 0, N-1);\n\n\t\t}\n\t}\n\n\tstatic double solve(Circle[] c, int start, int end) {\n\n\t\tif(start == end || start > end)\n\t\t\treturn Integer.MAX_VALUE;\n\t\tif(start == (end-1))\n\t\t\treturn Math.sqrt((c[start].x - c[end].x)*(c[start].x - c[end].x) + (c[start].y - c[end].y)*(c[start].y - c[end].y)) - c[start].r - c[end].r;\n\t\tint middle = (start + end) / 2;\n\n\t\t//double result = Math.sqrt((c[middle].x - c[middle+1].x)*(c[middle].x - c[middle+1].x) + (c[middle].y - c[middle+1].y)*(c[middle].y - c[middle+1].y)) - c[middle].r - c[middle+1].r;\n\t\tdouble result1 = solve(c, start, middle);\n\t\tdouble result2 = solve(c, middle+1, end);\n\n\t\tdouble distance =  Math.min(result1, result2);\n\n\t\tdouble middleP = (c[end].x + c[start].x) / 2;\n//\t\tCircle[] cc = new Circle[end-start];\n\t\tArrayList<Circle> list = new ArrayList<Circle>();\n\t\tint index = 0;\n\t\tfor(int i=start ; i<=end ;i++) {\n\t\t\tif(Math.abs(c[i].x - middleP) < distance+2*maxRadius) {\n\t\t\t\tlist.add(c[i]);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tCircle[] cc = (Circle[]) list.toArray();\n\t\tif(index <= 1)\n\t\t\treturn distance;\n\n\t\tArrays.sort(cc, Comparator.comparing(Circle::getY));\n\n\t\tfor(int j=0 ; j<index ; j++) {\n\t\t\tfor(int k=j+1 ; k<index ; k++) {\n\t\t\t\tdistance = Math.min(distance, Math.sqrt((cc[j].x - cc[k].x)*(cc[j].x - cc[k].x) + (cc[j].y - cc[k].y)*(cc[j].y - cc[k].y)) - cc[j].r - cc[k].r);\n\t\t\t}\n\t\t}\n\t\treturn distance;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Random;\n\n//The Closest Circle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass R implements Comparable<R>{\n\t\tdouble x, y, r;\n\t\tpublic R(double x, double y, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int)Math.signum(y-o.y);\n\t\t\treturn (int)Math.signum(x-o.x);\n\t\t}\n\t}\n\t\n\tdouble EPS = 1e-8;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint rot = rand.nextInt(44)+1;\n\t\t\tdouble sin = Math.sin(rot*Math.PI/180), cos = Math.cos(rot*Math.PI/180);\n\t\t\tR[] rs = new R[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble r = sc.nextDouble(), x = sc.nextDouble(), y = sc.nextDouble();\n\t\t\t\trs[i] = new R(cos*x-sin*y, sin*x+cos*y, r);\n\t\t\t}\n\t\t\tArrays.sort(rs);\n\t\t\tdouble res = 1L<<60;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint t = Math.min(n, i+3);\n\t\t\t\tfor(int j=i+1;j<t;j++){\n\t\t\t\t\tres = Math.min(res, Math.sqrt((rs[i].x-rs[j].x)*(rs[i].x-rs[j].x) + (rs[i].y-rs[j].y)*(rs[i].y-rs[j].y))-rs[i].r-rs[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.9f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Random;\n\n//The Closest Circle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass R implements Comparable<R>{\n\t\tdouble x, y, r;\n\t\tpublic R(double x, double y, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int)Math.signum(y-o.y);\n\t\t\treturn (int)Math.signum(x-o.x);\n\t\t}\n\t}\n\t\n\tdouble EPS = 1e-8;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint rot = rand.nextInt(44)+1;\n\t\t\tdouble sin = Math.sin(rot*Math.PI/180), cos = Math.cos(rot*Math.PI/180);\n\t\t\tR[] rs = new R[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble r = sc.nextDouble(), x = sc.nextDouble(), y = sc.nextDouble();\n\t\t\t\trs[i] = new R(cos*x-sin*y, sin*x+cos*y, r);\n\t\t\t}\n\t\t\tArrays.sort(rs);\n\t\t\tdouble res = 1L<<60;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint t = Math.min(n, i+5);\n\t\t\t\tfor(int j=i+1;j<t;j++){\n\t\t\t\t\tres = Math.min(res, Math.sqrt((rs[i].x-rs[j].x)*(rs[i].x-rs[j].x) + (rs[i].y-rs[j].y)*(rs[i].y-rs[j].y))-rs[i].r-rs[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.9f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Random;\n\n//The Closest Circle\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass R implements Comparable<R>{\n\t\tdouble x, y, r;\n\t\tpublic R(double x, double y, double r) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.r = r;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\tif(Math.abs(x-o.x)<EPS)return (int)Math.signum(y-o.y);\n\t\t\treturn (int)Math.signum(x-o.x);\n\t\t}\n\t}\n\t\n\tdouble EPS = 1e-8;\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint rot = rand.nextInt(44)+1;\n\t\t\tdouble sin = Math.sin(rot*Math.PI/180), cos = Math.cos(rot*Math.PI/180);\n\t\t\tR[] rs = new R[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tdouble r = sc.nextDouble(), x = sc.nextDouble(), y = sc.nextDouble();\n\t\t\t\trs[i] = new R(cos*x-sin*y, sin*x+cos*y, r);\n\t\t\t}\n\t\t\tArrays.sort(rs);\n\t\t\tdouble res = 1L<<60;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tint t = Math.min(n, i+4);\n\t\t\t\tfor(int j=i+1;j<t;j++){\n\t\t\t\t\tres = Math.min(res, Math.sqrt((rs[i].x-rs[j].x)*(rs[i].x-rs[j].x) + (rs[i].y-rs[j].y)*(rs[i].y-rs[j].y))-rs[i].r-rs[j].r);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.9f\\n\", res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\n\ndef _get_distance(c1, c2):\n    return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n\ndef _get_min_distance(circles):\n    min_d = float(\"inf\")\n    for c1, c2 in combinations(circles, 2):\n        min_d = min(min_d, _get_distance(c1, c2))\n    return min_d\n\ndef closest_pair_distance(circles, axis =1):\n    # axis: x; 1, y; 2\n    n = len(circles)\n    if n <= 3:\n        return _get_min_distance(circles)\n    else:\n        mid = n // 2\n        r, x, y = zip(*circles)\n        if len(set(x)) > len(set(y)):\n            if axis == 2:\n                circles.sort(key = lambda c: c[1] - c[0])\n            axis1 = 1\n            axis2 = 2\n        else:\n            if axis == 1:\n                circles.sort(key = lambda c: c[2] - c[0])\n            axis1 = 2\n            axis2 = 1\n        \n        A_circles = circles[:mid]\n        B_circles = circles[mid:]\n        \n        d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n        d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n        dist = min(d_Amin, d_Bmin)\n        min_d = dist\n        \n        B_0_axis1 = B_circles[0][axis1]\n        B_0_r = B_circles[0][0]\n        for ac in A_circles[::-1]:\n            ac_r = ac[0]\n            ac_axis1 = ac[axis1]\n            ac_axis2 = ac[axis2]\n            if B_0_axis1 - ac_axis1 - B_0_r - ac_r >= dist:\n                break\n            for bc in B_circles:\n                bc_r = bc[0]\n                if bc[axis1] - ac_axis1 - bc_r - ac_r >= dist:\n                    break\n                if abs(ac_axis2 - bc[axis2]) - ac_r - bc_r < dist:\n                    min_d = min(min_d, _get_distance(ac, bc))\n        return min_d\n\n# solve\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    while True:\n        N = int(input_lines[0])\n        if N == 0:\n            break\n        circles = [tuple(map(float, l.split())) for l in input_lines[1:N+1]]\n        print(closest_pair_distance(circles))\n        del input_lines[:N+1]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\n\ndef _get_distance(c1, c2):\n    return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n\ndef _get_min_distance(circles):\n    min_d = float(\"inf\")\n    for c1, c2 in combinations(circles, 2):\n        min_d = min(min_d, _get_distance(c1, c2))\n    return min_d\n\ndef closest_pair_distance(circles, axis =1):\n    # axis: x; 1, y; 2\n    n = len(circles)\n    if n <= 3:\n        return _get_min_distance(circles)\n    else:\n        mid = n // 2\n        r, x, y = zip(*circles)\n        if len(set(x)) > len(set(y)):\n            if axis:\n                circles.sort(key = lambda c: c[1])\n            axis1 = 1\n            axis2 = 2\n        else:\n            if not axis:\n                circles.sort(key = lambda c: c[2])\n            axis1 = 2\n            axis2 = 1\n        A_circles = circles[:mid]\n        B_circles = circles[mid:]\n        d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n        d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n        dist = min(d_Amin, d_Bmin)\n        min_d = dist\n        B_0_axis1 = B_circles[0][axis1]\n        B_0_r = B_circles[0][0]\n        for ac in A_circles[::-1]:\n            ac_r = ac[0]\n            ac_axis1 = ac[axis1]\n            ac_axis2 = ac[axis2]\n            if B_0_axis1 - ac_axis1 - B_0_r - ac_r >= dist:\n                break\n            for bc in B_circles:\n                bc_r = bc[0]\n                if bc[axis1] - ac_axis1 - bc_r - ac_r >= dist:\n                    break\n                if abs(ac_axis2 - bc[axis2]) - ac_r - bc_r < dist:\n                    min_d = min(min_d, _get_distance(ac, bc))\n        return min_d\n\n# solve\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    while True:\n        N = int(input_lines[0])\n        if N == 0:\n            break\n        circles = [tuple(map(float, l.split())) for l in input_lines[1:N+1]]\n        print(closest_pair_distance(circles))\n        del input_lines[:N+1]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from itertools import combinations\n\ndef _get_distance(c1, c2):\n    return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n\ndef _get_min_distance(circles):\n    min_d = float(\"inf\")\n    for c1, c2 in combinations(circles, 2):\n        min_d = min(min_d, _get_distance(c1, c2))\n    return min_d\n\ndef closest_pair_distance(circles, axis =1):\n    # axis: x; 1, y; 2\n    n = len(circles)\n    if n <= 3:\n        return _get_min_distance(circles)\n    else:\n        mid = n // 2\n        r, x, y = zip(*circles)\n        if len(set(x)) > len(set(y)):\n            if axis == 2:\n                circles.sort(key = lambda c: c[1] - c[0])\n            axis1 = 1\n            axis2 = 2\n        else:\n            if axis == 1:\n                circles.sort(key = lambda c: c[2] - c[0])\n            axis1 = 2\n            axis2 = 1\n        \n        A_circles = circles[:mid]\n        B_circles = circles[mid:]\n        \n        d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n        d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n        dist = min(d_Amin, d_Bmin)\n        min_d = dist\n        \n        B_0_axis1 = B_circles[0][axis1]\n        B_0_r = B_circles[0][0]\n        for ac in A_circles[::-1]:\n            ac_r = ac[0]\n            ac_axis1 = ac[axis1]\n            ac_axis2 = ac[axis2]\n            if B_0_axis1 - ac_axis1 - B_0_r - ac_r >= dist:\n                break\n            for bc in B_circles:\n                bc_r = bc[0]\n                if bc[axis1] - ac_axis1 - bc_r - ac_r >= dist:\n                    break\n                if abs(ac_axis2 - bc[axis2]) - ac_r - bc_r < dist:\n                    min_d = min(min_d, _get_distance(ac, bc))\n        return min_d\n\n# solve\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    while True:\n        N = int(input_lines[0])\n        if N == 0:\n            break\n        circles = [tuple(map(float, l.split())) for l in input_lines[1:N+1]]\n        print('{:.8f}'.format(closest_pair_distance(circles)))\n        del input_lines[:N+1]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    import sys\n    from itertools import combinations\n    input_lines = sys.stdin.readlines()\n    while True:\n        N = int(input_lines[0])\n        if N == 0:\n            break\n        distance = []\n        for t1, t2 in combinations(input_lines[1:N+1], 2):\n            r1, x1, y1 = map(float, t1.split())\n            r2, x2, y2 = map(float, t2.split())\n            d = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5 -r1 - r2\n            distance.append(d)\n        print(min(distance))\n        del input_lines[:N+1]\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "def _get_distance(c1, c2):\n    return ((c1[1] - c2[1]) ** 2 + (c1[2] - c2[2]) ** 2) ** 0.5 - c1[0] - c2[0]\n\nfrom itertools import combinations\n\ndef _get_min_distance(circles):\n    min_d = float(\"inf\")\n    for c1, c2 in combinations(circles, 2):\n        min_d = min(min_d, _get_distance(c1, c2))\n    return min_d\n\ndef closest_pair_distance(circles, axis =1):\n    # axis: x; 1, y; 2\n    n = len(circles)\n    if n <= 3:\n        return _get_min_distance(circles)\n    else:\n        mid = n // 2\n        r, x, y = zip(*circles)\n        \n        if len(set(x)) > len(set(y)):\n            if axis == 2:\n                circles.sort(key = lambda c: c[1] - c[0])\n            axis1 = 1\n            axis2 = 2\n        else:\n            if axis == 1:\n                circles.sort(key = lambda c: c[2] - c[0])\n            axis1 = 2\n            axis2 = 1\n        \n        A_circles = circles[:mid]\n        B_circles = circles[mid:]\n        \n        d_Amin = closest_pair_distance(A_circles.copy(), axis1)\n        d_Bmin = closest_pair_distance(B_circles.copy(), axis1)\n        dist = min(d_Amin, d_Bmin)\n        min_d = dist\n        \n        A_circles.sort(key = lambda c: c[axis] + c[0])\n        B_edge = B_circles[0][axis1] - B_circles[0][0]\n        for ac in A_circles[::-1]:\n            ac_r = ac[0]\n            ac_edge = ac[axis1] + ac_r\n            if B_edge - ac_edge >= dist:\n                break\n            for bc in B_circles:\n                bc_r = bc[0]\n                if bc[axis1] - bc_r - ac_edge >= dist:\n                    break\n                if abs(ac[axis2] - bc[axis2]) - ac_r - bc_r < dist:\n                    min_d = min(min_d, _get_distance(ac, bc))\n        return min_d\n\n# solve\ndef solve():\n    import sys\n    input_lines = sys.stdin.readlines()\n    while True:\n        N = int(input_lines[0])\n        if N == 0:\n            break\n        circles = [tuple(map(float, l.split())) for l in input_lines[1:N+1]]\n        print('{:.8f}'.format(closest_pair_distance(circles)))\n        del input_lines[:N+1]\n\nsolve()\n"
  }
]