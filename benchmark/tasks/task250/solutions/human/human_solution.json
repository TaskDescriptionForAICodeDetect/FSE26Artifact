[
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    var i = 0\n    var f = true\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      System.gc()\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        i = 0\n        f = true\n        while (i < M && f) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n            f = false\n          }\n          i += 1\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        i = 0\n        while (i < M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n          i += 1\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0).enqueue(x)\n        } else {\n          var returnpoint2 = M\n          i = 0\n          f = true\n          while (i < M && f) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n              f = false\n            }\n            i += 1\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2).enqueue(first) \n            }\n          }\n          que(0).enqueue(x) \n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    val M, C, N = sc.nextInt\n    if (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            System.gc()\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint+1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      solve(sc)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      System.gc()\n      \n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    var i = 0\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      System.gc()\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        i = 0\n        while (i < M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n          i += 1\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        i = 0\n        while (i < M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n          i += 1\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          i = 0\n          while (i < M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n            i += 1\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    var i = 0\n    var f = true\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      System.gc()\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        i = 0\n        f = true\n        while (i < M && f) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n            f = false\n          }\n          i += 1\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        i = 0\n        while (i < M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n          i += 1\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          i = 0\n          f = true\n          while (i < M && f) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n              f = false\n            }\n            i += 1\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        System.gc()\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint+1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M, C, N = sc.nextInt\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    val M, C, N = sc.nextInt\n    if (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        System.gc()\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint+1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      solve(sc)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    val M, C, N = sc.nextInt\n    if (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint+1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      solve(sc)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    var i = 0\n    var f = true\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      System.gc()\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        i = 0\n        f = true\n        while (i < M && f) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1).enqueue(que(i).drop(findindex + 1))\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n            f = false\n          }\n          i += 1\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        i = 0\n        while (i < M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n          i += 1\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0).enqueue(x)\n        } else {\n          var returnpoint2 = M\n          i = 0\n          f = true\n          while (i < M && f) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n              f = false\n            }\n            i += 1\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2).enqueue(first)\n            }\n          }\n          que(0).enqueue(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    var i = 0\n    var f = true\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      System.gc()\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        i = 0\n        f = true\n        while (i < M && f) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n            f = false\n          }\n          i += 1\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        i = 0\n        while (i < M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n          i += 1\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          i = 0\n          while (i < M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n            i += 1\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    val M, C, N = sc.nextInt\n    if (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint+1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      System.gc()\n      solve(sc)\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        System.gc()\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n          }\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n        System.gc()\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      System.gc()\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        for (i <- 0 until M) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n            System.gc()\n          }\n        }\n        ans += findpoint + 1\n        var returnpoint = M\n        for (i <- 0 until M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          for (i <- 0 until M) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n            }\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.Searching._\nimport scala.annotation.tailrec\nimport scala.collection.immutable.Queue\n\nclass IUnionFind(val size: Int) {\n\n  private case class Node(var parent: Option[Int], var treeSize: Int)\n\n  private val nodes = Array.fill[Node](size)(new Node(None, 1))\n\n  def union(t1: Int, t2: Int): IUnionFind = {\n    if (t1 == t2) return this\n\n    val root1 = root(t1)\n    val root2 = root(t2)\n    if (root1 == root2) return this\n\n    val node1 = nodes(root1)\n    val node2 = nodes(root2)\n\n    if (node1.treeSize < node2.treeSize) {\n      node1.parent = Some(t2)\n      node2.treeSize += node1.treeSize\n    } else {\n      node2.parent = Some(t1)\n      node1.treeSize += node2.treeSize\n    }\n    this\n  }\n\n  def connected(t1: Int, t2: Int): Boolean = t1 == t2 || root(t1) == root(t2)\n\n  @tailrec\n  private def root(t: Int): Int = nodes(t).parent match {\n    case None => t\n    case Some(p) => root(p)\n  }\n}\n\n\nobject Main {\n  def solve(sc: => Scanner): Unit = {\n    var M, C, N = sc.nextInt\n    var i = 0\n    var f = true\n    while (M != 0 && C != 0 && N != 0) {\n      val A = Array.fill(N)(Array.fill(sc.nextInt)(sc.nextInt))\n      var B = List.fill(0)(0)\n      for (j <- 0 until 100) {\n        for (i <- 0 until N) {\n          if (j < A(i).size) {\n            B = B :+ A(i)(j)\n          }\n        }\n      }\n\n      System.gc()\n\n      val que = Array.fill[Queue[Int]](M)(Queue[Int]())\n      var ans = 0\n      for (x <- B) {\n        var findpoint = M\n        i = 0\n        f = true\n        while (i < M && f) {\n          val findindex = que(i).indexOf(x)\n          if (findindex != -1) {\n            que(i) = que(i).take(findindex - 1) ++ que(i).drop(findindex + 1)\n            //println(findindex)\n            //println(que(i).take(findindex - 1))\n            // println(que(i).drop(findindex + 1))\n            findpoint = i\n            f = false\n          }\n          i += 1\n        }\n        System.gc()\n        ans += findpoint + 1\n        var returnpoint = M\n        i = 0\n        while (i < M) {\n          if (que(i).size < C) {\n            returnpoint = math.min(returnpoint, i)\n          }\n          i += 1\n        }\n        ans += returnpoint + 1\n        //println(\"--\", ans)\n        if (returnpoint == 0) {\n          que(0) ++= List(x)\n        } else {\n          var returnpoint2 = M\n          i = 0\n          f = true\n          while (i < M && f) {\n            if (que(i).size + (if (returnpoint == i) (1) else (0)) + 1 <= C) {\n              returnpoint2 = math.min(returnpoint2, i)\n              f = false\n            }\n            i += 1\n          }\n          if (returnpoint != 0) {\n            ans += 1 + returnpoint2 + 1\n            //println(\"--\",ans)\n            val first = que(0).head\n            que(0) = que(0).drop(1)\n            if (returnpoint2 != M) {\n              que(returnpoint2) ++= List(first)\n            }\n          }\n          que(0) ++= List(x)\n          ans += 1 + returnpoint + 1\n          //println(\"--\",ans,returnpoint)\n        }\n        //println(que.mkString(\" \"))\n        //println(ans)\n      }\n      println(ans)\n      M = sc.nextInt\n      C = sc.nextInt\n      N = sc.nextInt\n      System.gc()\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val sc: Scanner = new Scanner(System.in)\n\n    solve(sc)\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int M, C, N;\n    while (cin >> M >> C >> N, M || C || N) {\n        vector<deque<int>> vd(M+1);\n        for (int i = 1; i <= 100; i++) vd[M].push_back(i);\n\n        queue<queue<int>> vs;\n        for (int i = 0; i < N; i++) {\n            int k;\n            cin >> k;\n            queue<int> q;\n            for (int j = 0; j < k; j++) {\n                int x;\n                cin >> x;\n                q.push(x);\n            }\n            vs.push(q);\n        }\n\n        int ans = 0;\n        while (vs.size()) {\n            auto q =  vs.front();\n            vs.pop();\n            int book = q.front();\n            q.pop();\n            if (q.size() > 0) vs.push(q);\n\n            for (int i = 0; i <= M; i++) {\n                for (int j = 0; j < vd[i].size(); j++) {\n                    if (vd[i][j] == book) {\n                        ans += i + 1;\n                        vd[i].erase(vd[i].begin() + j);\n                        break;\n                    }\n                }\n            }\n\n            if (vd[0].size() < C) {\n                vd[0].push_back(book);\n                ans += 1;\n            } else {\n                int p1 = -1, p2 = -1;\n                for (int i = 1; i <= M; i++) {\n                    if (vd[i].size() < C || i == M) {\n                        if (p1 < 0) {\n                            p1 = i;\n                            if (i == M || vd[i].size() + 1 < C) i--;\n                        } else if (p2 < 0) {\n                            p2 = i;\n                        }\n                    }\n                }\n\n                int rebook = vd[0].front();\n                vd[0].pop_front();\n                \n                vd[p2].push_back(rebook);\n                vd[0].push_back(book);\n\n                ans += (p1 + 1) * 2 + 1;\n                ans += p2 + 2;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n \nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int m, c, n; cin >> m >> c >> n && m;) {\n\t\tvector<unordered_map<int, int>> desks(m);\n \n\t\tqueue<int> que;\n\t\tvector<int> index(n, 0);\n\t\tvector<vector<int>> books(n);\n \n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tque.push(i);\n \n\t\t\tint k;\n\t\t\tcin >> k;\n\n\t\t\tbooks[i].reserve(k);\n \n\t\t\tfor(int j = 0; j < k; ++j) {\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\tbooks[i].emplace_back(b);\n\t\t\t}\n\t\t}\n \n\t\tint ans = 0;\n\n\t\tfor(int t = 0; !que.empty(); ++t) {\n\t\t\tconst int student = que.front();\n\t\t\tque.pop();\n \n\t\t\tconst int id = books[student][index[student]];\n\t\t\tif(++index[student] < books[student].size()) {\n\t\t\t\tque.push(student);\n\t\t\t}\n\n\t\t\tint pos = m;\n\t\t\tfor(int i = 0; i < m; ++i) {\n\t\t\t\tif(desks[i].count(id)) {\n\t\t\t\t\tdesks[i].erase(id);\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tans += pos + 1;\n \n\t\t\tint tmp = m;\n\t\t\tfor(int i = 0; i < m; ++i) {\n\t\t\t\tif(desks[i].size() < c) {\n\t\t\t\t\tdesks[i].insert({id, t});\n\t\t\t\t\ttmp = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tans += tmp + 1;\n \n\t\t\tif(tmp != 0) {\n\t\t\t\tint r_id = -1;\n\t\t\t\tint r_time = INT_MAX;\n \n\t\t\t\tfor(const auto &e : desks.front()) {\n\t\t\t\t\tif(r_time > e.second) {\n\t\t\t\t\t\tr_id = e.first;\n\t\t\t\t\t\tr_time = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n \n\t\t\t\tans += 1;\n\t\t\t\tdesks.front().erase(r_id);\n \n\t\t\t\tint to = m;\n\t\t\t\tfor(int i = 1; i < m; ++i) {\n\t\t\t\t\tif(desks[i].size() < c) {\n\t\t\t\t\t\tdesks[i].insert({r_id, r_time});\n\t\t\t\t\t\tto = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n \n\t\t\t\tans += to + 1;\n \n\t\t\t\tif(tmp < m) desks[tmp].erase(id);\n\t\t\t\tans += tmp + 1;\n \n\t\t\t\tdesks.front().insert({id, t});\n\t\t\t\tans += 1;\n\t\t\t}\n\t\t}\n \n \n\t\tcout << ans << endl;\n\t}\n \n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "/* 2012-11-23T16:06:54 */\n#define DEBUG_ON_\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, __VA_ARGS__)\n#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n#define cerr if(0) cerr\n#define dprt(fmt, ...)\n#define darr(a)\n#define darr_range(a, f, t)\n#define dvec(v)\n#define darr2(a, n, m)\n#define dvec2(v)\n#define WAIT()\n#define dump(x)\n#define dumpf()\n#define dumpv(x)\n#define where()\n#define show_bits(b, s)\n#endif\n\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { IFC(s[i] == ' '); if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n/*}}}*/\n\n#define KMAX 51\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tint m, c, n;\n\twhile(cin >> m >> c >> n, m || c || n) {\n\t\tqueue< queue<int> > students;\n\t\tREP (i, n) {\n\t\t\tint k; cin >> k;\n\t\t\tqueue<int> books;\n\t\t\tREP (j, k) {\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tbooks.push(t);\n\t\t\t}\n\t\t\tstudents.push(books);\n\t\t}\n\n\t\tVI address(100, m); /* place of books */\n\t\tVVI desks(m, VI());\n\n\t\tint cost = 0;\n\t\twhile (!students.empty()) {\n\t\t\tqueue<int> s = students.front(); students.pop();\n\t\t\tint b = s.front(); s.pop();\n\t\t\tdprt(\"Request: %d\\n\", b);\n\n\t\t\t/* Get the book */\n\t\t\tcost += address[b] + 1;\n\t\t\tdprt(\"\\tget it from %d\\n\", address[b]);\n\t\t\tif (address[b] != m) {\n\t\t\t\tdesks[address[b]].erase(find(ALL(desks[address[b]]), b));\n\t\t\t}\n\n\t\t\t/* Store the book */\n\t\t\tif (desks[0].size() < c) {\n\t\t\t\tcerr << \"\\tput it on desk 0\" << endl;\n\t\t\t\tdesks[0].PB(b);\n\t\t\t\taddress[b] = 0;\n\t\t\t\tcost++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool shelf = true;\n\t\t\t\tint tmp;\n\t\t\t\tint i;\n\t\t\t\tfor(i=0; i<m; ++i) {\n\t\t\t\t\tif (desks[i].size() < c) {\n\t\t\t\t\t\tcost += i+1;\n\t\t\t\t\t\ttmp = i;\n\t\t\t\t\t\tshelf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (shelf) {\n\t\t\t\t\tcost += m+1;\n\t\t\t\t\ttmp = m;\n\t\t\t\t}\n\t\t\t\tdprt(\"\\ttemporary put it on %d\\n\", tmp);\n\n\t\t\t\tint lru = desks[0][0];\n\t\t\t\tdprt(\"\\ttake lru(%d) from desk 0\\n\", lru);\n\t\t\t\tdesks[0].erase(desks[0].begin());\n\t\t\t\tcost++;\n\n\t\t\t\tint lruput;\n\t\t\t\tshelf = true;\n\t\t\t\tFOR (j, 1, m) {\n\t\t\t\t\tif (desks[j].size() + (j==i) < c) {\n\t\t\t\t\t\tdesks[j].PB(lru);\n\t\t\t\t\t\taddress[lru] = j;\n\t\t\t\t\t\tlruput = j;\n\t\t\t\t\t\tcost += j+1;\n\t\t\t\t\t\tshelf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (shelf) {\n\t\t\t\t\tcost += m+1;\n\t\t\t\t\tlruput = m;\n\t\t\t\t\taddress[lru] = m;\n\t\t\t\t}\n\t\t\t\tdprt(\"\\tput lru on %d\\n\", lruput);\n\n\t\t\t\tdprt(\"\\tretrive book from tmp(%d)\\n\", tmp);\n\t\t\t\tcost += tmp+1;\n\n\t\t\t\tcerr << \"\\tput it on desk 0\" << endl;\n\t\t\t\tdesks[0].PB(b);\n\t\t\t\tcost++;\n\t\t\t\taddress[b] = 0;\n\n\t\t\t}\n\n\t\t\tif (s.size() > 0) {\n\t\t\t\tstudents.push(s);\n\t\t\t}\n\n\t\t\tdump(cost);\n\t\t}\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint at[110];\nint use[110];\nint last[110];\nint req[110][110];\nint sr[110];\nint lis[11000];\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tint ret=0;\n\t\tfor(int i=0;i<110;i++)use[i]=0;\n\t\tfor(int i=0;i<110;i++)at[i]=a+1;\n\t\tfor(int i=0;i<110;i++)last[i]=0;\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint d;scanf(\"%d\",&d);\n\t\t\tsr[i]=d;\n\t\t\tfor(int j=0;j<d;j++)scanf(\"%d\",&req[i][j]);\n\t\t}\n\t\tint L=0;\n\t\tfor(int i=0;i<60;i++){\n\t\t\tfor(int j=0;j<c;j++)if(sr[j]>i)lis[L++]=req[j][i];\n\t\t}\n\t\tint t=0;\n\t\tfor(int i=0;i<L;i++){\n\t\t\t\tint e=lis[i];\n\t\t\t\tret+=at[e];\n\t\t\t\tif(at[e]<a+1)use[at[e]]--;\n\t\t\t\tlast[e]=t;\n\t\t\t\tt++;\n\t\t\t\tif(use[1]<b){\n\t\t\t\t\tuse[1]++;ret++;at[e]=1;\n\t\t\t\t}else{\n\t\t\t\t\tfor(int i=2;i<=a+1;i++){\n\t\t\t\t\t\tif(i==a+1||use[i]<b){\n\t\t\t\t\t\t\tuse[i]++;at[e]=i;ret+=i;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint f=9999999;\n\t\t\t\t\tint v=0;\n\t\t\t\t\tfor(int i=0;i<110;i++)if(at[i]==1){\n\t\t\t\t\t\tif(f>last[i]){f=last[i];v=i;}\n\t\t\t\t\t}\n\t\t\t\t\tret++;\n\t\t\t\t\tfor(int i=2;i<=a+1;i++){\n\t\t\t\t\t\tif(i==a+1||use[i]<b){\n\t\t\t\t\t\t\tuse[i]++;at[v]=i;ret+=i;break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tuse[at[e]]--;ret+=at[e];ret++;at[e]=1;\n\t\t\t\t}\n\t\t\t\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int m,c,n;scanf(\"%d%d%d\",&m,&c,&n),m;){\n\t\tqueue<int> Q[100];\n\t\trep(i,n){\n\t\t\tint sz; scanf(\"%d\",&sz);\n\t\t\trep(j,sz){\n\t\t\t\tint a; scanf(\"%d\",&a);\n\t\t\t\tQ[i].push(a);\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tdeque<int> dai[10];\n\t\twhile(1){\n\t\t\tbool end=true;\n\t\t\trep(i,n) if(!Q[i].empty()) {\n\t\t\t\tend=false;\n\n\t\t\t\t// 本を取る\n\t\t\t\tint book=Q[i].front(); Q[i].pop();\n\t\t\t\tint pos=m;\n\t\t\t\trep(j,m) if(count(dai[j].begin(),dai[j].end(),book)>0) {\n\t\t\t\t\tpos=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(pos<m){\n\t\t\t\t\tdai[pos].erase(find(dai[pos].begin(),dai[pos].end(),book));\n\t\t\t\t}\n\t\t\t\tans+=pos+1;\n\n\t\t\t\t// 本を置く\n\t\t\t\tif(dai[0].size()<c){\n\t\t\t\t\tdai[0].push_back(book);\n\t\t\t\t\tans+=1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// step 1\n\t\t\t\t\tint pos2=m;\n\t\t\t\t\tfor(int j=1;j<m;j++) if(dai[j].size()<c) {\n\t\t\t\t\t\tpos2=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos2<m){\n\t\t\t\t\t\tdai[pos2].push_back(book);\n\t\t\t\t\t}\n\t\t\t\t\tans+=pos2+1;\n\n\t\t\t\t\t// step 2\n\t\t\t\t\tint sub=dai[0].front(); dai[0].pop_front();\n\t\t\t\t\tans++;\n\n\t\t\t\t\t// step 3\n\t\t\t\t\tint pos3=m;\n\t\t\t\t\tfor(int j=1;j<m;j++) if(dai[j].size()<c) {\n\t\t\t\t\t\tpos3=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos3<m){\n\t\t\t\t\t\tdai[pos3].push_back(sub);\n\t\t\t\t\t}\n\t\t\t\t\tans+=pos3+1;\n\n\t\t\t\t\t// step 4\n\t\t\t\t\tif(pos2<m){\n\t\t\t\t\t\tdai[pos2].erase(find(dai[pos2].begin(),dai[pos2].end(),book));\n\t\t\t\t\t}\n\t\t\t\t\tans+=pos2+1;\n\n\t\t\t\t\t// step 5\n\t\t\t\t\tdai[0].push_back(book);\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end) break;\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n \nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int m, c, n; cin >> m >> c >> n && m;) {\n\t\tvector<unordered_map<int, int>> desks(m);\n \n\t\tqueue<int> que;\n\t\tvector<int> index(n, 0);\n\t\tvector<vector<int>> books(n);\n \n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tque.push(i);\n \n\t\t\tint k;\n\t\t\tcin >> k;\n\n\t\t\tbooks[i].reserve(k);\n \n\t\t\tfor(int j = 0; j < k; ++j) {\n\t\t\t\tint b;\n\t\t\t\tcin >> b;\n\t\t\t\tbooks[i].emplace_back(b);\n\t\t\t}\n\t\t}\n \n\t\tint ans = 0;\n\n\t\tfor(int t = 0; !que.empty(); ++t) {\n\t\t\tconst int student = que.front();\n\t\t\tque.pop();\n \n\t\t\tconst int id = books[student][index[student]];\n\t\t\tif(++index[student] < books[student].size()) {\n\t\t\t\tque.push(student);\n\t\t\t}\n\n\t\t\tint pos = m;\n\t\t\tfor(int i = 0; i < m; ++i) {\n\t\t\t\tif(desks[i].count(id)) {\n\t\t\t\t\tdesks[i].erase(id);\n\t\t\t\t\tpos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tans += pos + 1;\n \n\t\t\tint tmp = m;\n\t\t\tfor(int i = 0; i < m; ++i) {\n\t\t\t\tif(desks[i].size() < c) {\n\t\t\t\t\tdesks[i].insert({id, t});\n\t\t\t\t\ttmp = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tans += tmp + 1;\n \n\t\t\tif(tmp != 0) {\n\t\t\t\tint r_id = -1;\n\t\t\t\tint r_time = INT_MAX;\n \n\t\t\t\tfor(const auto &e : desks.front()) {\n\t\t\t\t\tif(r_time > e.second) {\n\t\t\t\t\t\tr_id = e.first;\n\t\t\t\t\t\tr_time = e.second;\n\t\t\t\t\t}\n\t\t\t\t}\n \n\t\t\t\tans += 1;\n\t\t\t\tdesks.front().erase(r_id);\n \n\t\t\t\tint to = m;\n\t\t\t\tfor(int i = 1; i < m; ++i) {\n\t\t\t\t\tif(desks[i].size() < c) {\n\t\t\t\t\t\tdesks[i].insert({r_id, r_time});\n\t\t\t\t\t\tto = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n \n\t\t\t\tans += to + 1;\n \n\t\t\t\tif(tmp < m) desks[tmp].erase(id);\n\t\t\t\tans += tmp + 1;\n \n\t\t\t\tdesks.front().insert({id, t});\n\t\t\t\tans += 1;\n\t\t\t}\n\t\t}\n \n \n\t\tcout << ans << endl;\n\t}\n \n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <tuple>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cfloat>\n#include <climits>\n#include <cassert>\n#include <random>\n#include <fstream>\n\nint main() {\n\twhile (true) {\n\t\tint m, c, n; std::cin >> m >> c >> n; if (n == 0) break;\n\t\tstd::vector<std::queue<int>> users(n);\n\t\tfor (auto& u : users) {\n\t\t\tint k; std::cin >> k;\n\t\t\tfor (auto i = 0; i < k; ++i) {\n\t\t\t\tint b; std::cin >> b;\n\t\t\t\tu.push(b);\n\t\t\t}\n\t\t}\n\t\tstd::vector<int> current_book_position(100, m), recent_access(101, INT_MAX);\n\t\tstd::set<int> first_desk;\n\t\tstd::priority_queue<int, std::vector<int>, std::greater<int>> empty_space;\n\t\tfor (auto i = 0; i <= m; ++i) empty_space.push(i);\n\t\tstd::vector<int> desk_rest(m + 1, c); desk_rest.back() = INT_MAX;\n\t\tint sum_cost = 0;\n\t\tstd::queue<int> user_in_row; for (auto i = 0; i < n; ++i) user_in_row.push(i);\n\t\tfor (auto time = 0; !user_in_row.empty(); ++time) {\n\t\t\tconst auto top = user_in_row.front(); user_in_row.pop();\n\t\t\tconst auto ref = users[top].front(); users[top].pop();\n\t\t\tif (!users[top].empty()) user_in_row.push(top);\n\t\t\tconst auto target_pos = current_book_position[ref];\n\t\t\tif (++desk_rest[target_pos] == 1) {\n\t\t\t\tempty_space.push(target_pos);\n\t\t\t}\n\t\t\tint cost = target_pos + 1;\n\t\t\tif (desk_rest[0] > 0) {\n\t\t\t\tcost += 1;\n\t\t\t\tif (--desk_rest[0] == 0) empty_space.pop();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst auto temp_area = empty_space.top();\n\t\t\t\tif (--desk_rest[temp_area] == 0) {\n\t\t\t\t\tempty_space.pop();\n\t\t\t\t}\n\t\t\t\tconst auto most_least_ref = *std::min_element(first_desk.begin(), first_desk.end(), [&recent_access](int a, int b) {return recent_access[a] < recent_access[b]; });\n\t\t\t\tconst auto escape_area = empty_space.top();\n\t\t\t\tif (--desk_rest[escape_area] == 0) {\n\t\t\t\t\tempty_space.pop();\n\t\t\t\t}\n\t\t\t\tif (++desk_rest[temp_area] == 1) {\n\t\t\t\t\tempty_space.push(temp_area);\n\t\t\t\t}\n\t\t\t\tcost += temp_area + 1 + 1 + escape_area + 1 + temp_area + 1 + 1;\n\t\t\t\tcurrent_book_position[most_least_ref] = escape_area;\n\t\t\t\tfirst_desk.erase(most_least_ref);\n\t\t\t}\n\t\t\tcurrent_book_position[ref] = 0;\n\t\t\tfirst_desk.insert(ref);\n\t\t\trecent_access[ref] = time;\n\t\t\tsum_cost += cost;\n\t\t}\n\t\tstd::cout << sum_cost << '\\n';\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX_D = 11;\nint m,c,n,ans;\nvector<int> req;\nvector<int> D[MAX_D];\n\nvoid input(){\n  vector<int> tmp[n];\n  int sum = 0;\n  \n  for(int i = 0; i < n; i++){\n    int num;\n    cin >> num;\n    sum += num;\n    for(int j = 0; j < num; j++){\n      int in;\n      cin >> in;\n      tmp[i].push_back(in);\n    }\n  }\n  \n  int pos = 0;\n  while(sum){\n    for(int i = 0; i < n; i++)\n      if(tmp[i].size() > pos){\n\treq.push_back(tmp[i][pos]);\n\tsum--;\n      }\n    pos++;\n  }\n  \n  D[m] = req;\n}\n\nvoid init(){\n  req.clear();\n  for(int i = 0; i < MAX_D; i++)\n    D[i].clear();\n  ans = 0;\n}\n\nint find(int num){\n  \n  vector<int>::iterator ite;\n  \n  for(int i = 0; i <= m; i++)\n    for(ite = D[i].begin(); ite < D[i].end(); ite++)\n      if(*ite == num){\n\tD[i].erase(ite);\n\treturn i+1;\n      }\n}\n\nint ret(int num){\n  int cost = 0;\n  \n  if(D[0].size() < c){\n    D[0].push_back(num);\n    return 1;\n  }else{\n    int minpos = m;\n    for(int i = 0; i < m; i++)\n      if(D[i].size() < c){\n\tminpos = i;\n\tbreak;\n      }\n    \n    //from counter to minpos+1\n    cost += minpos+1;\n    \n    int tmppos = m;\n    for(int i = 0; i < m; i++)\n      if(i == minpos){\n\tif(D[i].size()+1 < c){\n\t  tmppos = i;\n\t  break;\n\t}\n      }else if(D[i].size() < c){\n\ttmppos = i;\n\tbreak;\n      }\n    //from 1 to (tmppos+1)\n    cost+=tmppos+2;\n    \n    D[tmppos].push_back(D[0][0]);\n    D[0].erase(D[0].begin());\n    \n    \n    D[0].push_back(num);\n    \n    //from (minpos+1) to 1\n    cost += minpos+2;\n  }\n  return cost;\n}\nvoid solve(){\n  \n  for(int i = 0; i < req.size(); i++){\n    int fpos = find(req[i]);\n    int rcos = ret(req[i]);\n    ans += fpos+rcos;\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  \n  while(cin >> m >> c >> n && m+c+n){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint m, c;\nvector<list<int> > desk;\n\nint takeBook(int x)\n{\n    for(int i=0; ; ++i){\n        for(list<int>::iterator it=desk[i].begin(); it!=desk[i].end(); ++it){\n            if(*it == x){\n                desk[i].erase(it);\n                return i + 1;\n            }\n        }\n    }\n}\n\nint putBook(int x, int first)\n{\n    for(int i=first; i<m; ++i){\n        if(desk[i].size() < c){\n            desk[i].push_back(x);\n            return i + 1;\n        }\n    }\n    desk[m].push_back(x);\n    return m + 1;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> m >> c >> n;\n        if(m == 0 && c == 0 && n == 0)\n            return 0;\n\n        vector<vector<int> > b0(n);\n        for(int i=0; i<n; ++i){\n            int k;\n            cin >> k;\n            b0[i].resize(k);\n            for(int j=0; j<k; ++j)\n                cin >> b0[i][j];\n        }\n\n        vector<int> b;\n        for(int i=0; i<50; ++i){\n            for(int j=0; j<n; ++j){\n                if(i < b0[j].size())\n                b.push_back(b0[j][i]);\n            }\n        }\n        n = b.size();\n\n        desk = vector<list<int> > (m+1);\n        for(int i=0; i<100; ++i)\n            desk[m].push_back(i);\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            ret += takeBook(b[i]);\n            if(desk[0].size() < c){\n                ret += putBook(b[i], 0);\n            }else{\n                ret += putBook(b[i], 1);\n                int x = desk[0].front();\n                desk[0].pop_front();\n                ++ ret;\n                ret += putBook(x, 1);\n                ret += takeBook(b[i]);\n                ret += putBook(b[i], 0);\n            }\n        }\n\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(a) (cerr << #a << \" = \" << (a) << endl)\n\n#define REP(i,a,b) for(int i=(a);i < (int)(b); i++)\n#define rep(i,n) REP(i,0,n)\n#define ALL(v) begin(v), end(v)\n\nint main(){\n  for(int m, c, n; cin >> m >> c >> n && m;) {\n    vector<unordered_map<int, int>> desks(m);\n\n    queue<int> que;\n    vector<int> index(n, 0);\n    vector<vector<int>> books(n);\n\n    for(int i = 0; i < n; ++i) {\n      que.push(i);\n\n      int k;\n      cin >> k;\n\n      for(int j = 0; j < k; ++j) {\n\tint b;\n\tcin >> b;\n\tbooks[i].emplace_back(b);\n      }\n    }\n\n    int ans = 0;\n    for(int t = 0; !que.empty(); ++t) {\n      const int student = que.front();\n      que.pop();\n\n      const int id = books[student][index[student]];\n      if(++index[student] < books[student].size()) {\n\tque.push(student);\n      }\n\n      int pos = m;\n      for(int i = 0; i < m; ++i) {\n\tif(desks[i].count(id)) {\n\t  desks[i].erase(id);\n\t  pos = i;\n\t  break;\n\t}\n      }\n\n      ans += pos + 1;\n\n      int tmp = m;\n      for(int i = 0; i < m; ++i) {\n\tif(desks[i].size() < c) {\n\t  desks[i].insert({id, t});\n\t  tmp = i;\n\t  break;\n\t}\n      }\n\n      ans += tmp + 1;\n\n      if(tmp != 0) {\n\tint r_id = -1;\n\tint r_time = INT_MAX;\n\n\tfor(const auto &e : desks[0]) {\n\t  if(r_time > e.second) {\n\t    r_id = e.first;\n\t    r_time = e.second;\n\t  }\n\t}\n\n\tans += 1;\n\tdesks[0].erase(r_id);\n\n\tint to = m;\n\tfor(int i = 1; i < m; ++i) {\n\t  if(desks[i].size() < c) {\n\t    desks[i].insert({r_id, r_time});\n\t    to = i;\n\t    break;\n\t  }\n\t}\n\n\tans += to + 1;\n\n\tif(tmp < m) desks[tmp].erase(id);\n\tans += tmp + 1;\n\n\tdesks[0].insert({id, t});\n\tans += 1;\n      }\n    }\n\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  int m,c,n;\n  while(cin>>m>>c>>n,m||c||n){\n    int k[n];\n    int b[111][55];\n    for(int i=0;i<n;i++){\n      cin>>k[i];\n      for(int j=0;j<k[i];j++) cin>>b[i][j];\n    }\n    list<int> l[m];\n    queue<P> q;\n    for(int i=0;i<n;i++) q.push(P(i,0));\n    int ans=0;\n    while(!q.empty()){\n      P p=q.front();q.pop();\n      int w=p.first,x=p.second;\n      int pos=m;\n      for(int i=0;i<m;i++){\n\tauto latte=find(l[i].begin(),l[i].end(),b[w][x]);\n\tif(latte!=l[i].end()){\n\t  pos=i;\n\t  l[i].erase(latte);\n\t  break;\n\t}\n      }\n      ans+=pos+1;\n      if((int)l[0].size()<c){\n\tl[0].push_front(b[w][x]);\n\tans+=1;\n      }else{\n\tint tmp=m;\n\tfor(int i=1;i<m;i++){\n\t  if((int)l[i].size()<c){\n\t    tmp=i;\n\t    l[tmp].push_back(b[w][x]);\n\t    break;\n\t  }\n\t}\n\tans+=tmp+1;\n\t//cout<<ans<<endl;\n\tint le=l[0].back();\n\tl[0].pop_back();\n\tans+=1;\n\tint pos=m;\n\tfor(int i=1;i<m;i++){\n\t  if((int)l[i].size()<c){\n\t    pos=i;\n\t    l[pos].push_front(le);\n\t    break;\n\t  }\n\t}\n\tans+=pos+1;\n\t//cout<<ans<<endl;\n\tif(tmp<m) l[tmp].pop_back();\n\tans+=tmp+1;\n\t//cout<<ans<<endl;\n\tl[0].push_front(b[w][x]);\n\tans+=1;\n\t//cout<<ans<<endl;\n      }\n      if(x+1<k[w]) q.push(P(w,x+1));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  while(1){\n    ll m,c,n;\n    cin>>m>>c>>n;\n    if(!m&&!c&&!n)return 0;\n\n    vector<ll> book[101],D[21];\n    \n    for(int i=0;i<n;i++){\n      int k;\n      cin>>k;\n      book[i].resize(k);\n      for(int j=0;j<k;j++) cin>>book[i][j],D[m].push_back(book[i][j]);\n    }\n\n    queue<int> Q;\n    for(int i=0;i<100;i++)\n      for(int j=0;j<n;j++)\n\tif((int)book[j].size()>i)Q.push(book[j][i]);\n  \n    ll d[11],ans=0;\n    for(int i=0;i<m;i++)d[i]=c;  \n    d[m]=1e9;\n    \n    while(!Q.empty()){\n      ll id=Q.front();Q.pop();\n      ll cost=0;\n\n      for(int i=0;i<=m&&!cost;i++)\n\tfor(int j=0;j<(int)D[i].size()&&!cost;j++)\n\t  if(id==D[i][j])cost=i+1,D[i].erase(D[i].begin()+j);\n      \n      ans+=cost;\n      cost=0;\n      if(D[0].size()<d[0]){\n\tD[0].push_back(id),ans+=1;\n\tcontinue;\n      }\n\n      int pos=0;\n      for(int i=0;i<=m&&!cost;i++)\n\tif(D[i].size()<d[i])D[i].push_back(id),cost=(i+1)*2+1,pos=i;\n      \n      ans+=cost;\n      cost=0;\n      for(int i=0;i<=m&&!cost;i++)\n\tif(D[i].size()<d[i]){\n\t  D[i].push_back(D[0][0]);\n\t  D[0].erase(D[0].begin());\n\t  cost=i+2;\n\t}\n      ans+=cost;      \n      cost=0;\n      for(int i=0;i<D[pos].size();i++) if(D[pos][i]==id)D[pos].erase(D[pos].begin()+i);\n      D[0].push_back(id);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : Problem.cpp\n// Author      : \n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nint solve(int m, int c, int n)\n{\n\tqueue<int>* queries = new queue<int>[n];\n\tint cost = 0;\n\tint k;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tfor(int j = 0;j < k; j++)\n\t\t{\n\t\t\tint book_id;\n\t\t\tcin >> book_id;\n\t\t\tqueries[i].push(book_id);\n\t\t}\n\t}\n\n\tdeque<int>* desks = new deque<int>[m];\n\tbool flag = true;\n\twhile(flag)\n\t{\n\t\tflag = false;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(queries[i].empty())\n\t\t\t\tcontinue;\n\t\t\tflag = true;\n\t\t\tint book = queries[i].front(); queries[i].pop();\n\t\t\t// find book\n\t\t\tint pos = m;\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif(count(desks[j].begin(), desks[j].end(), book) > 0){\n\t\t\t\t\tpos = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos < m)\n\t\t\t\tdesks[pos].erase(find(desks[pos].begin(), desks[pos].end(), book));\n\n\t\t\tcost += pos + 1;\n\n\t\t\tif((int)desks[0].size() < c)\n\t\t\t{\n\t\t\t\tdesks[0].push_back(book);\n\t\t\t\tcost += 1;\n\t\t\t}else{\n\t\t\t\t// step 1 : move from shelf(current position) to non-full nearest to entrance desk\n\t\t\t\tint pos_2 = m;\n\t\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tif((int)desks[j].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos_2 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos_2 < m)\n\t\t\t\t\tdesks[pos_2].push_front(book);\n\t\t\t\tcost += pos_2 + 1;\n\n\t\t\t\t// step 2 : move least recently used from desk 1\n\t\t\t\tint pos_3 = m;\n\t\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tif((int)desks[j].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos_3 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lru = desks[0].front(); desks[0].pop_front();\n\t\t\t\tif(pos_3 < m)\n\t\t\t\t\tdesks[pos_3].push_back(lru);\n\n\t\t\t\tcost += 1 + pos_3;\n\t\t\t\tcost += 1;\n\n\t\t\t\t// step 3 : move book from pos_2 to desk 1\n\t\t\t\tif(pos_2 < m)\n\t\t\t\t\tdesks[pos_2].pop_front();\n\t\t\t\tdesks[0].push_back(book);\n\t\t\t\tcost += pos_2 + 1;\n\t\t\t\tcost += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<int> dq;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tswap(desks[i], dq);\n\t}\n\n\tqueue<int> q;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tswap(queries[i], q);\n\t}\n\n\tdelete[] desks;\n\tdelete[] queries;\n\treturn cost;\n}\n\nint main() {\n\tfreopen(\"aizu.txt\", \"r\", stdin);\n\tint m, c, n;\n\tcin >> m >> c >> n;\n\twhile(m != 0 && c != 0 && n != 0)\n\t{\n\t\tcout << solve(m,c,n) << endl;\n\t\tcin >> m >> c >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 2012-11-23T16:06:54 */\n#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, __VA_ARGS__)\n#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n#define cerr if(0) cerr\n#define dprt(fmt, ...)\n#define darr(a)\n#define darr_range(a, f, t)\n#define dvec(v)\n#define darr2(a, n, m)\n#define dvec2(v)\n#define WAIT()\n#define dump(x)\n#define dumpf()\n#define dumpv(x)\n#define where()\n#define show_bits(b, s)\n#endif\n\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { IFC(s[i] == ' '); if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n/*}}}*/\n\n#define KMAX 51\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tint m, c, n;\n\twhile(cin >> m >> c >> n, m || c || n) {\n\t\tqueue< queue<int> > students;\n\t\tREP (i, n) {\n\t\t\tint k; cin >> k;\n\t\t\tqueue<int> books;\n\t\t\tREP (j, k) {\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tbooks.push(t);\n\t\t\t}\n\t\t\tstudents.push(books);\n\t\t}\n\n\t\tVI address(100, m); /* place of books */\n\t\tVVI desks(m, VI());\n\n\t\tint cost = 0;\n\t\twhile (!students.empty()) {\n\t\t\tqueue<int> s = students.front(); students.pop();\n\t\t\tint b = s.front(); s.pop();\n\t\t\tdprt(\"Request: %d\\n\", b);\n\n\t\t\t/* Get the book */\n\t\t\tcost += address[b] + 1;\n\t\t\tdprt(\"\\tget it from %d\\n\", address[b]);\n\t\t\tif (address[b] != m) {\n\t\t\t\tdesks[address[b]].erase(find(ALL(desks[address[b]]), b));\n\t\t\t}\n\n\t\t\t/* Store the book */\n\t\t\tif (desks[0].size() < c) {\n\t\t\t\tcerr << \"\\tput it on desk 0\" << endl;\n\t\t\t\tdesks[0].PB(b);\n\t\t\t\tcost++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool shelf = true;\n\t\t\t\tint tmp;\n\t\t\t\tint i;\n\t\t\t\tfor(i=0; i<m; ++i) {\n\t\t\t\t\tif (desks[i].size() < c) {\n\t\t\t\t\t\tcost += i+1;\n\t\t\t\t\t\ttmp = i;\n\t\t\t\t\t\tshelf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (shelf) {\n\t\t\t\t\tcost += m+1;\n\t\t\t\t\ttmp = m;\n\t\t\t\t}\n\t\t\t\tdprt(\"\\ttemporary put it on %d\\n\", tmp);\n\n\t\t\t\tint lru = desks[0][0];\n\t\t\t\tdprt(\"\\ttake lru(%d) from desk 0\\n\", lru);\n\t\t\t\tdesks[0].erase(desks[0].begin());\n\t\t\t\tcost++;\n\n\t\t\t\tint lruput;\n\t\t\t\tshelf = true;\n\t\t\t\tFOR (j, 1, m) {\n\t\t\t\t\tif (desks[j].size() + (j==i) < c) {\n\t\t\t\t\t\tdesks[j].PB(lru);\n\t\t\t\t\t\taddress[lru] = j;\n\t\t\t\t\t\tlruput = j;\n\t\t\t\t\t\tcost += j+1;\n\t\t\t\t\t\tshelf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (shelf) {\n\t\t\t\t\tcost += m+1;\n\t\t\t\t\tlruput = m;\n\t\t\t\t\taddress[lru] = m;\n\t\t\t\t}\n\t\t\t\tdprt(\"\\tput lru on %d\\n\", lruput);\n\n\t\t\t\tdprt(\"\\tretrive book from tmp(%d)\\n\", tmp);\n\t\t\t\tcost += tmp+1;\n\n\t\t\t\tcerr << \"\\tput it on desk 0\" << endl;\n\t\t\t\tdesks[0].PB(b);\n\t\t\t\tcost++;\n\t\t\t\taddress[b] = 0;\n\n\t\t\t}\n\n\t\t\tif (s.size() > 0) {\n\t\t\t\tstudents.push(s);\n\t\t\t}\n\n\t\t\tdump(cost);\n\t\t}\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\n    int n,m,c;\n    while(cin>>m>>c>>n&&!(m==0&&c==0&&n==0)){\n        vector<vector<int> > orders;\n        vector<int> idxs;\n        for(int i = 0; i < n; i++) idxs.push_back(0);\n        queue<int> waiter;\n        for(int i = 0; i < n; i++) waiter.push(i);\n        for(int i = 0; i < n; i++){\n            int k;\n            cin>>k;\n            vector<int> v;\n            for(int j = 0; j < k; j++){\n                int b;\n                cin>>b;\n                v.push_back(b);\n            }\n            orders.push_back(v);\n        }\n        // tables\n        vector<vector<int> > tableAndShelf;\n        for(int i = 0; i < m; i++)tableAndShelf.push_back(vector<int>());\n        vector<int> shelf;\n        for(int i = 0; i < 101; i++)\n            shelf.push_back(i);\n        tableAndShelf.push_back(shelf);\n        int sumCost=0;\n        while(waiter.size()){\n            int member=waiter.front();\n            int bookid=orders[member][idxs[member]];\n            waiter.pop();\n            // {ªÇ±É é©©Â¯é\n            for(int i = 0; i < tableAndShelf.size(); i++){\n                vector<int>::iterator it=find(tableAndShelf[i].begin(),tableAndShelf[i].end(),bookid);\n                if(it!=tableAndShelf[i].end()){\n                    tableAndShelf[i].erase(it);\n                    sumCost+=i+1;\n                    break;\n                }\n            }\n            // u«êÉ·®u¯é©Åêí¯\n            if(tableAndShelf[0].size()<c){\n                tableAndShelf[0].push_back(bookid);\n                sumCost+=1;\n            }\n            else{\n                pair<int,int> tmp;\n                // óÌIðTµÄêIÉ¨­\n                for(int i = 0; i < tableAndShelf.size(); i++){\n                    // ó©I\n                    if(tableAndShelf[i].size()<c||i==tableAndShelf.size()-1){\n                        tableAndShelf[i].push_back(bookid);\n                        sumCost+=i+1;\n                        tmp.first=i;\n                        tmp.second=tableAndShelf[i].size()-1;\n                        break;\n                    }\n                }\n                // D1ÌãÌ{ÅAàÁÆà·¢ÔNGXg³êÄ¢È¢{ð©Â¯Aæè­\n                int old=tableAndShelf[0][0];\n                tableAndShelf[0].erase(tableAndShelf[0].begin());\n                sumCost++;\n                // D2È~ÅtÅÈ¢{IÉ¨­\n                for(int i = 1; i < tableAndShelf.size(); i++){\n                    // ó©I\n                    if(tableAndShelf[i].size()<c||i==tableAndShelf.size()-1){\n                        tableAndShelf[i].push_back(old);\n                        sumCost+=i+1;\n                        break;\n                    }\n                }\n                // temp©çæèoµÄ«½{ðD1É¨­\n                tableAndShelf[tmp.first].erase(tableAndShelf[tmp.first].begin()+tmp.second);\n                sumCost+=tmp.first+1;\n                tableAndShelf[0].push_back(bookid);\n                sumCost++;\n            }\n            idxs[member]++;\n            if(idxs[member]!=orders[member].size())\n                waiter.push(member);\n        }\n        cout<<sumCost<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : Problem.cpp\n// Author      : \n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nint solve(int m, int c, int n)\n{\n\tqueue<int>* queries = new queue<int>[n];\n\tint cost = 0;\n\tint k;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tfor(int j = 0;j < k; j++)\n\t\t{\n\t\t\tint book_id;\n\t\t\tcin >> book_id;\n\t\t\tqueries[i].push(book_id);\n\t\t}\n\t}\n\n\tdeque<int>* desks = new deque<int>[m];\n\tbool flag = true;\n\twhile(flag)\n\t{\n\t\tflag = false;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(queries[i].empty())\n\t\t\t\tcontinue;\n\t\t\tflag = true;\n\t\t\tint book = queries[i].front(); queries[i].pop();\n\t\t\t// find book\n\t\t\tint pos = m;\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif(count(desks[j].begin(), desks[j].end(), book) > 0){\n\t\t\t\t\tpos = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos < m)\n\t\t\t\tdesks[pos].erase(find(desks[pos].begin(), desks[pos].end(), book));\n\n\t\t\tcost += pos + 1;\n\n\t\t\tif((int)desks[0].size() < c)\n\t\t\t{\n\t\t\t\tdesks[0].push_back(book);\n\t\t\t\tcost += 1;\n\t\t\t}else{\n\t\t\t\t// step 1 : move from shelf(current position) to non-full nearest to entrance desk\n\t\t\t\tint pos_2 = m;\n\t\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tif((int)desks[j].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos_2 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos_2 < m)\n\t\t\t\t\tdesks[pos_2].push_front(book);\n\t\t\t\tcost += pos_2 + 1;\n\n\t\t\t\t// step 2 : move least recently used from desk 1\n\t\t\t\tint pos_3 = m;\n\t\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tif((int)desks[j].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos_3 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lru = desks[0].front(); desks[0].pop_front();\n\t\t\t\tdesks[pos_3].push_back(lru);\n\n\t\t\t\tcost += 1 + pos_3;\n\t\t\t\tcost += 1;\n\n\t\t\t\t// step 3 : move book from pos_2 to desk 1\n\t\t\t\tif(pos_2 < m)\n\t\t\t\t\tdesks[pos_2].pop_front();\n\t\t\t\tdesks[0].push_back(book);\n\t\t\t\tcost += pos_2 + 1;\n\t\t\t\tcost += 1;\n\t\t\t}\n\t\t}\n\t}\n\tdelete[] desks;\n\tdelete[] queries;\n\treturn cost;\n}\n\nint main() {\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tint m, c, n;\n\tcin >> m >> c >> n;\n\twhile(m != 0 && c != 0 && n != 0)\n\t{\n\t\tcout << solve(m,c,n) << endl;\n\t\tcin >> m >> c >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* 2012-11-23T16:06:54 */\n#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((ULL)(n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, __VA_ARGS__)\n#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n#define cerr if(0) cerr\n#define dprt(fmt, ...)\n#define darr(a)\n#define darr_range(a, f, t)\n#define dvec(v)\n#define darr2(a, n, m)\n#define dvec2(v)\n#define WAIT()\n#define dump(x)\n#define dumpf()\n#define dumpv(x)\n#define where()\n#define show_bits(b, s)\n#endif\n\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { IFC(s[i] == ' '); if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n/*}}}*/\n\n#define KMAX 51\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false);\n\tint m, c, n;\n\twhile(cin >> m >> c >> n, m || c || n) {\n\t\tqueue< queue<int> > students;\n\t\tREP (i, n) {\n\t\t\tint k; cin >> k;\n\t\t\tqueue<int> books;\n\t\t\tREP (j, k) {\n\t\t\t\tint t;\n\t\t\t\tcin >> t;\n\t\t\t\tbooks.push(t);\n\t\t\t}\n\t\t\tstudents.push(books);\n\t\t}\n\n\t\tVI address(100, m); /* place of books */\n\t\tVVI desks(m, VI());\n\n\t\tint cost = 0;\n\t\twhile (!students.empty()) {\n\t\t\tqueue<int> s = students.front(); students.pop();\n\t\t\tint b = s.front(); s.pop();\n\t\t\tdprt(\"Request: %d\\n\", b);\n\n\t\t\t/* Get the book */\n\t\t\tcost += address[b] + 1;\n\t\t\tdprt(\"\\tget it from %d\\n\", address[b]);\n\t\t\tif (address[b] != m) {\n\t\t\t\tdesks[address[b]].erase(find(ALL(desks[address[b]]), b));\n\t\t\t}\n\n\t\t\t/* Store the book */\n\t\t\tif (desks[0].size() < c) {\n\t\t\t\tcerr << \"\\tput it on desk 0\" << endl;\n\t\t\t\tdesks[0].PB(b);\n\t\t\t\taddress[b] = 0;\n\t\t\t\tcost++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool shelf = true;\n\t\t\t\tint tmp;\n\t\t\t\tint i;\n\t\t\t\tfor(i=0; i<m; ++i) {\n\t\t\t\t\tif (desks[i].size() < c) {\n\t\t\t\t\t\tcost += i+1;\n\t\t\t\t\t\ttmp = i;\n\t\t\t\t\t\tshelf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (shelf) {\n\t\t\t\t\tcost += m+1;\n\t\t\t\t\ttmp = m;\n\t\t\t\t}\n\t\t\t\tdprt(\"\\ttemporary put it on %d\\n\", tmp);\n\n\t\t\t\tint lru = desks[0][0];\n\t\t\t\tdprt(\"\\ttake lru(%d) from desk 0\\n\", lru);\n\t\t\t\tdesks[0].erase(desks[0].begin());\n\t\t\t\tcost++;\n\n\t\t\t\tint lruput;\n\t\t\t\tshelf = true;\n\t\t\t\tFOR (j, 1, m) {\n\t\t\t\t\tif (desks[j].size() + (j==i) < c) {\n\t\t\t\t\t\tdesks[j].PB(lru);\n\t\t\t\t\t\taddress[lru] = j;\n\t\t\t\t\t\tlruput = j;\n\t\t\t\t\t\tcost += j+1;\n\t\t\t\t\t\tshelf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (shelf) {\n\t\t\t\t\tcost += m+1;\n\t\t\t\t\tlruput = m;\n\t\t\t\t\taddress[lru] = m;\n\t\t\t\t}\n\t\t\t\tdprt(\"\\tput lru on %d\\n\", lruput);\n\n\t\t\t\tdprt(\"\\tretrive book from tmp(%d)\\n\", tmp);\n\t\t\t\tcost += tmp+1;\n\n\t\t\t\tcerr << \"\\tput it on desk 0\" << endl;\n\t\t\t\tdesks[0].PB(b);\n\t\t\t\tcost++;\n\t\t\t\taddress[b] = 0;\n\n\t\t\t}\n\n\t\t\tif (s.size() > 0) {\n\t\t\t\tstudents.push(s);\n\t\t\t}\n\n\t\t\tdump(cost);\n\t\t}\n\n\t\tcout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint m,c,n;\nint place[102];\nvector<int> desk[13],req[102];\nqueue<int> q;\n\nvoid solve(){\n  int ans = 0;\n\n  while(!q.empty()){\n    int idx = q.front(); q.pop();\n    int book = req[idx][0]; req[idx].erase(req[idx].begin());\n    int p = place[book];\n\n    ans += p;\n    desk[p].erase(find(desk[p].begin(),desk[p].end(),book));\n\n    if(desk[1].size() < c){\n      desk[1].push_back(book);\n      place[book] = 1;\n      ans++;\n    }\n    else{\n      REP(i,2,m+2){\n        if(desk[i].size() < c || i == m+1){\n          desk[i].push_back(book);\n          place[book] = i;\n          ans += i;\n          break;\n        }\n      }\n\n      int tmp = desk[1][0]; desk[1].erase(desk[1].begin());\n      ans++;\n\n      REP(i,2,m+2){\n        if(desk[i].size() < c || i == m+1){\n          desk[i].push_back(tmp);\n          place[tmp] = i;\n          ans += i;\n          break;\n        }\n      }\n\n      desk[1].push_back(book);\n      p = place[book];\n      desk[p].erase(find(desk[p].begin(),desk[p].end(),book));\n      place[book] = 1;\n      ans += p + 1;\n    }\n\n    if(!req[idx].empty()) q.push(idx);\n  }\n\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  while(scanf(\"%d%d%d\",&m,&c,&n),m||c||n){\n    rep(i,13) desk[i].clear();\n\n    rep(i,n){\n      int k;\n      scanf(\"%d\",&k);\n      req[i].clear();\n      q.push(i);\n\n      rep(j,k){\n        int b;\n        scanf(\"%d\",&b);\n        req[i].push_back(b);\n        desk[m+1].push_back(b);\n        place[b] = m+1;\n      }\n    }\n\n    solve();\n  }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma  warning (disable:4996)\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<string>\n#include<cmath>\nusing namespace std;\nint m, c, n;\nint k[102];\nint b[102][52];\nvector<int> desk[12];//&#27599;&#24352;&#26700;子上放的&#20070;&#32534;号\nint amount[12];\nint que[5005];//拿&#20070;&#39034;序\nint maxk;\nint max(int a, int b){\n\tif (a > b)return a;\n\telse return b;\n}\nint main(){\n\twhile (cin >> m >> c >> n){\n\t\tif (!m&&!n&&!c) break;\n\t\tint i, j,p;\n\t\t\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemset(desk, 0, sizeof(desk));\n\t\tmemset(amount, 0, sizeof(amount));\n\t\tmemset(que, 0, sizeof(que));\n\t\tmemset(k, 0, sizeof(k));\n\t\tmaxk = -10;\n\n\t\tfor ( i = 1; i <= n; i++){\n\t\t\tcin >> k[i];\n\t\t\tmaxk = max(maxk, k[i]);\n\t\t\tfor ( j = 1; j <= k[i]; j++)\n\t\t\t\tcin >> b[i][j];\n\t\t}\n\t\t\n\n\t\tint ans = 0;\n\t\tint num = 0;\n\n\t\tfor (j = 1; j <= maxk; j++){\n\t\t\tfor (i = 1; i <= n; i++){\n\t\t\t\tif (b[i][j] != 0)\n\t\t\t\t{\n\t\t\t\t\tque[num++] = b[i][j];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint id;\n\t\tint mm = 0;\n\t\t\n\t\t\n\t\twhile (mm < num){\n\t\t\tid = que[mm];\n\t\t\tint flag = 0;\n\t\t\t//找&#20070;\n\t\t\t/*for (j = 1; j <= m; j++){\n\t\t\t\tcout << \"desk[\"<<j<<\"]:\";\n\t\t\t\tfor (i = 0; i < desk[j].size(); i++)\n\t\t\t\t\tcout << desk[j][i] << \" \";\n\t\t\t\tcout << endl;\n\t\t\t}*/\n\t\t\t\t\n\t\t\tfor (i = 1; i <= m; i++){\n\t\t\t\tfor (j = 0; j < desk[i].size(); j++){\n\t\t\t\t\tif (desk[i][j] == id) {\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tans += i;\n\t\t\t\t\t\t//cout << \"第\"<<mm<<\"cinashu\"<<i << endl;\n\t\t\t\t\t\tamount[i]--;\n\t\t\t\t\t\tdesk[i][j] = 0;//拿走了\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag)break;\n\t\t\t}\n\t\t\tif (!flag){\n\t\t\t\tans += (m + 1); //cout << \"第\" << mm << \"cinashu\" << m+1 << endl;\n\t\t\t}\n\n\t\t\t//放&#20070;\n\t\t\tint temp;\n\t\t\tif (amount[1] < c){\n\t\t\t\tdesk[1].push_back(id);\n\t\t\t\tans += 1;\n\t\t\t\tamount[1]++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor (i = 2; i <= m + 1; i++){\n\t\t\t\t\tif (amount[i] < c || (i == m + 1))\n\t\t\t\t\t{\n\n\t\t\t\t\t\ttemp = i;//&#26242;&#26102;放的位置\n\t\t\t\t\t\tamount[i]++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint longestid;//很久没用的&#20070;\n\n\t\t\t\tfor (i = 0; i < desk[1].size(); i++){\n\t\t\t\t\tif (desk[1][i])\n\t\t\t\t\t{\n\t\t\t\t\t\tlongestid = desk[1][i];\n\t\t\t\t\t\tdesk[1][i] = 0;\n\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdesk[1].push_back(id);\n\t\t\t\t\n\n\t\t\t\tint temp2;\t\n\t\t\t\tfor (p = temp ; p <= m + 1; p++){\n\t\t\t\t\tif (amount[p] < c || p == m + 1){\n\n\t\t\t\t\t\ttemp2 = p;\n\t\t\t\t\t\tdesk[p].push_back(longestid);\n\t\t\t\t\t\tamount[p]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tamount[temp]--;\n\t\t\t\tans += (2 * temp + temp2 + 2);\n\t\t\t\t//cout << temp <<\" \"<< temp2 <<\" \"<<2 * temp + temp2 + 2<< endl;\n\n\n\t\t\t}mm++;\n\t\t}\n\t\t\t\t\n\t\tcout << ans << endl;\n\n\t\t\n\t}return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  while(1){\n    int m,c,n;\n    cin>>m>>c>>n;\n    if(!m&&!c&&!n)return 0;\n\n    vector<int> book[101];\n    vector <int> D[11];\n    for(int i=0;i<n;i++){\n      int k;\n      cin>>k;\n      book[i].resize(k);\n      for(int j=0;j<k;j++) cin>>book[i][j],D[m].push_back(book[i][j]);\n    }\n\n    queue<int> Q;\n    for(int i=0;i<50;i++)\n      for(int j=0;j<n;j++)\n\tif((int)book[j].size()>i)Q.push(book[j][i]);\n  \n    int d[11];\n    ll ans=0;\n    for(int i=0;i<m;i++)d[i]=c;  \n    d[m]=1e9;\n    \n    while(!Q.empty()){\n      int id=Q.front();Q.pop();\n            int cost=0;\n      for(int i=0;i<=m&&!cost;i++)\n\tfor(int j=0;j<(int)D[i].size()&&!cost;j++)\n\t  if(id==D[i][j])cost=i+1,D[i].erase(D[i].begin()+j);\n      \n      ans+=cost;\n      cost=0;\n      if((int)D[0].size()<d[0]){\n\tD[0].push_back(id),ans++;\n\tcontinue;\n      }\n\n      int pos=0;\n      for(int i=0;i<=m&&!cost;i++)\n\tif((int)D[i].size()<d[i])D[i].push_back(id),cost=(i+1)*2+1,pos=i;\n      \n      ans+=cost;\n      cost=0;\n      for(int i=0;i<=m&&!cost;i++)\n\tif((int)D[i].size()<d[i]){\n\t  D[i].push_back(D[0][0]);\n\t  D[0].erase(D[0].begin());\n\t  cost=i+2;\n\t}\n\n      ans+=cost;      \n      cost=0;\n      D[0].push_back(id);\n      D[pos].erase(D[pos].end()-1);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <vector>\ntemplate <class T>\ninline bool rd(T &ret) {\n\tchar c; int sgn;\n\tif(c=getchar(),c==EOF) return 0;\n\twhile(c!='-'&&(c<'0'||c>'9')) c=getchar();\n\tsgn=(c=='-')?-1:1;\n\tret=(c=='-')?0:(c-'0');\n\twhile(c=getchar(),c>='0'&&c<='9') ret=ret*10+(c-'0');\n\tret*=sgn;\n\treturn 1;\n}\ntemplate <class T>\ninline void pt(T x) {\n    if (x <0) {\n        putchar('-');\n        x = -x;\n    }\n    if(x>9) pt(x/10);\n    putchar(x%10+'0');\n}\nusing namespace std;\nconst int inf = (int)1e8;\nconst int N = 55;\ntypedef pair<int, int> pii;\n\nint n, m, c;\n\ndeque<int> Q, q[55];\ndeque<int>::iterator it;\nvector<int>G[N];\nint id[105];\nvoid input(){\n\twhile(!Q.empty())Q.pop_front();\n\tfor(int i = 1, num, j; i <= n; i++){\n\t\tG[i].clear();\n\t\trd(num); while(num--){rd(j); G[i].push_back(j);\t}\n\t\treverse(G[i].begin(), G[i].end());\n\t\tQ.push_back(i);\n\t}\n\tfor(int i = 1; i <= m+1; i++) while(!q[i].empty())q[i].pop_front();\n\tfor(int i = 1; i <= 100; i++)id[i] = m+1;\n}\nint putbook(int book, int from){\n\tfor(int i = from; i <= m; i++){\n\t\tif(q[i].size()<c){\n\t\t\tq[i].push_back(book);\n\t\t\tid[book] = i;\n\t\t\treturn i;\n\t\t}\n\t}\n\tid[book] = m+1;\n\treturn m+1;\n}\nint takebook(int book){\n\tif(id[book] == m+1)return m+1;\n\tfor(it = q[id[book]].begin(); it != q[id[book]].end(); it++)\n\t\tif(*it == book){\n\t\t\tq[id[book]].erase(it); break;\n\t\t}\n\treturn id[book];\n}\nint main() {\n\twhile(~scanf(\"%d %d %d\", &m, &c, &n), n + c+m){\n\t\tinput();\n\t\tint ans = 0;\n\t\twhile(!Q.empty()){\n\t\t\tint stu = Q.front();\tQ.pop_front();\n\t\t\tint book = G[stu][G[stu].size()-1];\n\t\t\tG[stu].erase(G[stu].end()-1, G[stu].end());\n\t\t\tif(G[stu].size()) Q.push_back(stu);\n\t\t\tans += takebook(book);\n\t\t\tans += putbook(book, 1);\n\t\t\tif(id[book]!=1){\n\t\t\t\tint pre = q[1].front();\n\t\t\t\tq[1].pop_front();\n\t\t\t\tans++;\n\t\t\t\tans += putbook(pre, 2);\n\t\t\t\tans += takebook(book);\n\t\t\t\tans += putbook(book, 1);\n\t\t\t}\n\t\t}\n\t\tpt(ans); puts(\"\");\n\t}\n    return 0;\n}\n\n/*\n\n9 9\n*#**#**#*\n*#**#**#*\n*#**#**#*\n*#**.**#*\n*#*#.#*#*\n*$##*##$*\n*#*****#*\n*.#.#.#.*\n*********\n3 3\n*$*\n*#*\n*$*\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <assert.h>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <double,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nint num_of_desks;\nint book_limit;\nint num_of_students;\n\nint take_book(int id,deque<int> desks[101]){\n  for(int desk_i = 0; desk_i < num_of_desks; desk_i++){\n    for(int i = 0; i < desks[desk_i].size(); i++){\n      if(desks[desk_i][i] == id){\n        deque<int> tmp;\n        for(int j = 0; j < desks[desk_i].size(); j++){\n          if(desks[desk_i][j] == id) continue;\n          tmp.push_back(desks[desk_i][j]);\n        }\n        desks[desk_i] = tmp;\n        return desk_i + 1;\n      }\n    }\n  }\n  return num_of_desks + 1;\n}\n\nint main(){\n  while(~scanf(\"%d %d %d\",&num_of_desks,&book_limit,&num_of_students)){\n    if(num_of_desks == 0\n       && book_limit == 0\n       && num_of_students == 0) break;\n    vector<int> students[101];\n    int max_request = 0;\n    for(int student_i = 0; student_i < num_of_students; student_i++){\n      int num_of_books_requested;\n      scanf(\"%d\",&num_of_books_requested);\n      max_request = max(max_request,num_of_books_requested);\n      for(int book_i = 0; book_i < num_of_books_requested; book_i++){\n        int id;\n        scanf(\"%d\",&id);\n        students[student_i].push_back(id);\n      }\n    }\n    queue<int> books;\n    for(int book_i = 0; book_i < max_request; book_i++){\n      for(int student_i = 0; student_i < num_of_students; student_i++){\n        if(students[student_i].size() <= book_i) continue;\n        books.push(students[student_i][book_i]);\n      }\n    }\n\n    deque<int> desks[101];\n\n    int score = 0;\n    while(!books.empty()){\n      int id = books.front();\n      books.pop();\n\n      //take from desk/shelf\n      score += take_book(id,desks);\n\n      //put \n      if(desks[0].size() < book_limit){\n        desks[0].push_back(id);\n        score += 1;\n      }\n      else{\n        int tmp_place = -1;\n        for(int desk_i = 1; desk_i <= num_of_desks; desk_i++){\n          //put book\n          if(desk_i == num_of_desks || desks[desk_i].size() < book_limit){\n            desks[desk_i].push_back(id);\n            tmp_place = desk_i;\n            score += desk_i + 1;\n            break;\n          }\n        }\n\n        //take book\n        int old = desks[0].front(); \n        desks[0].pop_front();\n        score += 1;\n\n        bool same_flag = false;\n        for(int desk_i = 1; desk_i <= num_of_desks; desk_i++){\n          //put book\n          if(desk_i == num_of_desks || desks[desk_i].size() < book_limit){\n            if(tmp_place == desk_i){\n              desks[desk_i].pop_back();\n              same_flag = true;\n            }\n            desks[desk_i].push_back(old);\n            score += desk_i + 1;\n            break;\n          }\n\n        }\n\n        //take book\n        if(!same_flag){\n          desks[tmp_place].pop_back();\n        }\n        score += tmp_place + 1;\n\n        //put book\n        desks[0].push_back(id);\n        score += 1;\n      }\n    }\n    printf(\"%d\\n\",score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\nusing namespace std;\nint m,c,n;\nvector<int> shelf[32];\n\nint pop(int nx){\n  for(int i=0;i<m;i++)\n    for(int j=0;j<(int)shelf[i].size();j++)\n      if(shelf[i][j] == nx){\n\tshelf[i].erase(shelf[i].begin()+j);\n\treturn i+1;\n      }\n  return m+1;\n}\n\nint push(int nx){\n  int res = m+1;\n  for(int i=0;i<m;i++){\n    if((int)shelf[i].size()>=c) continue;\n    shelf[i].push_back(nx);\n    if(i==0) return 1;\n    res = i+1;\n    break;\n  }\n\n  int last = shelf[0][0];shelf[0].erase(shelf[0].begin());\n  res++;\n  for(int i=1;i<=m;i++){\n    if(i==m) {res+=m+1;continue;}\n    if((int)shelf[i].size()>=c) continue;\n    shelf[i].push_back(last);\n    res += i+1;\n    break;\n  }\n\n  res+=pop(nx);\n  shelf[0].push_back(nx);\n  return res+1;\n}\n\nint main(){\n  while(1){\n    cin>>m>>c>>n;\n    if(!m&&!n&&!c)return 0;\n    \n    vector<int> A[N];\n    for(int i=0,k;i<n;i++){\n      cin>>k;\n      A[i].resize(k);\n      for(int j=0;j<k;j++) cin>>A[i][k-1-j];\n    }\n    \n    queue<int> Q;\n    for(int i=0;i<n;i++) Q.push(i);\n    \n    \n    int ans = 0;\n    for(int i=0;i<=30;i++)shelf[i].clear();\n    \n    while(!Q.empty()){\n      int t = Q.front();Q.pop();\n      int nx = A[t].back();A[t].pop_back();\n      if(!A[t].empty()) Q.push(t);\n      \n      int cost = pop(nx);\n      cost +=push(nx);\n      ans+=cost;\n    }\n    \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Info{\n\tint table[50],index,num_book;\n};\n\nstruct LOC{\n\tint desk,index;\n};\n\nstruct Data{\n\tint book_id,put_time;\n};\n\nint num_desk,LIMIT,num_student,have_num[11],tmp_pos;\nData D_1[30];\nLOC loc[101];\n\nvoid func(){\n\n\tfor(int i = 1; i <= 100; i++)loc[i].desk = num_desk+1;\n\n\tfor(int i = 1; i <= num_desk; i++)have_num[i] = 0;\n\n\tfor(int i = 0; i < LIMIT; i++)D_1[i].book_id = -1;\n\n\tqueue<Info> Q;\n\tfor(int loop = 0; loop < num_student; loop++){\n\t\tInfo new_info;\n\t\tnew_info.index = 0;\n\t\tscanf(\"%d\",&new_info.num_book);\n\t\tfor(int i = 0; i < new_info.num_book; i++)scanf(\"%d\",&new_info.table[i]);\n\t\tQ.push(new_info);\n\t}\n\n\tint ans = 0,time = 0,current,next,book_id;\n\tint can_put_desk,space_D1,min_time,min_index,move_id;\n\n\tInfo tmp;\n\n\twhile(!Q.empty()){\n\n\t\ttmp = Q.front();\n\t\tQ.pop();\n\n\t\tbook_id = tmp.table[tmp.index];\n\n\t\tcurrent = loc[book_id].desk;\n\n\t\tif(current <= num_desk){\n\t\t\thave_num[current]--;\n\t\t\tif(current == 1){\n\t\t\t\tD_1[loc[book_id].index].book_id = -1;\n\t\t\t}\n\t\t}\n\t\tans += current;\n\t\ttime++;\n\n\t\tfor(can_put_desk = 1; can_put_desk <= num_desk; can_put_desk++){\n\t\t\tif(have_num[can_put_desk] < LIMIT)break;\n\t\t}\n\t\ttime++;\n\n\t\tif(can_put_desk == 1){\n\n\t\t\tans += 1;\n\n\t\t\tfor(int i = 0; i < LIMIT; i++){\n\t\t\t\tif(D_1[i].book_id == -1){\n\t\t\t\t\tspace_D1 = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tloc[book_id].desk = 1;\n\t\t\tloc[book_id].index = space_D1;\n\n\t\t\tD_1[space_D1].book_id = book_id;\n\t\t\tD_1[space_D1].put_time = time;\n\n\t\t\thave_num[1]++;\n\n\t\t}else{\n\n\t\t\tans += can_put_desk;\n\t\t\ttmp_pos = can_put_desk;\n\n\t\t\tif(can_put_desk <= num_desk){\n\t\t\t\thave_num[can_put_desk]++;\n\t\t\t}\n\n\t\t\tloc[book_id].desk = can_put_desk;\n\n\t\t\tmin_time = BIG_NUM;\n\n\t\t\tfor(int i = 0; i < LIMIT; i++){\n\t\t\t\tif(D_1[i].book_id != -1){\n\t\t\t\t\tif(min_time > D_1[i].put_time){\n\t\t\t\t\t\tmin_time = D_1[i].put_time;\n\t\t\t\t\t\tmin_index = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmove_id = D_1[min_index].book_id;\n\t\t\tD_1[min_index].book_id = -1;\n\t\t\thave_num[1]--;\n\n\t\t\tans += 1;\n\n\t\t\tfor(can_put_desk = 2; can_put_desk <= num_desk; can_put_desk++){\n\t\t\t\tif(have_num[can_put_desk] < LIMIT)break;\n\t\t\t}\n\t\t\ttime++;\n\n\t\t\tans += can_put_desk;\n\n\t\t\tloc[move_id].desk = can_put_desk;\n\n\t\t\tif(can_put_desk <= num_desk){\n\t\t\t\thave_num[can_put_desk]++;\n\t\t\t}\n\n\t\t\ttime++;\n\n\t\t\tans += (tmp_pos+1);\n\t\t\thave_num[1]++;\n\t\t\thave_num[tmp_pos]--;\n\t\t\tfor(int i = 0; i < LIMIT; i++){\n\t\t\t\tif(D_1[i].book_id == -1){\n\t\t\t\t\tspace_D1 = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tloc[book_id].desk = 1;\n\t\t\tloc[book_id].index = space_D1;\n\n\t\t\tD_1[space_D1].book_id = book_id;\n\t\t\tD_1[space_D1].put_time = time;\n\t\t}\n\n\t\tif(tmp.index == tmp.num_book-1)continue;\n\n\t\tInfo next_info;\n\t\tfor(int i = 0; i < tmp.num_book; i++)next_info.table[i] = tmp.table[i];\n\t\tnext_info.index = tmp.index+1;\n\t\tnext_info.num_book = tmp.num_book;\n\n\t\tQ.push(next_info);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&num_desk,&LIMIT,&num_student);\n\t\tif(num_desk == 0 && LIMIT == 0 && num_student == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstdlib>\n#include<cctype>\nusing namespace std;\n#define P pair<int, const char*>\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n\nvector<int> books;\nvector< vector<int> > desks;\nint ans = 0;\n\nvoid replace_desks(int did){\n  REP(i, desks[did].size()){\n    if(desks[did][i] != -1) continue;\n    FOR(j, i, desks[did].size()){\n      if(desks[did][j] != -1){\n        swap(desks[did][i], desks[did][j]);\n        break;\n      }\n    }\n  }\n}\n\nbool is_full(int did){\n  REP(i, desks[did].size()) if(desks[did][i] == -1) return false;\n  return true;\n}\n\nint take_oldbook(){\n  int tmp = desks[0][0];\n  desks[0][0] = -1;\n  replace_desks(0);\n  ans += 1;\n  return tmp;\n}\n\nvoid put_oldbook(int book){\n  FOR(i, 1, desks.size()){\n    REP(j, desks[i].size()){\n      if(desks[i][j] == -1){\n        desks[i][j] = book;\n        ans += (i + 1);\n        return ;\n      }\n    }\n  }\n  ans += (desks.size() + 1);\n  return ;\n}\n\nvoid take_book(int book){\n  REP(i, desks.size()){\n    REP(j, desks[i].size()){\n      if(desks[i][j] == book){\n        desks[i][j] = -1;\n        replace_desks(i);\n        ans += (i + 1);\n        return ;\n      }\n    }\n  }\n  ans += (desks.size() + 1);\n  return ;\n}\n\nvoid put_book(int book){\n  REP(i, desks.size()){\n    REP(j, desks[i].size()){\n      if(desks[i][j] == -1){\n        desks[i][j] = book;\n        ans += (i + 1);\n        return ;\n      }\n    }\n  }\n  ans += (desks.size() + 1);\n  return ;\n}\n\nint main(){\n  int m, c, n;\n  while(cin >>m >>c >>n && m){\n    ans = 0;\n    books = vector<int>();\n    desks = vector< vector<int> >(m, vector<int>(c, -1));\n    vector< vector<int> > tmp(n);\n    int tmp_int = 0;\n    REP(i, n){\n      int k; cin >>k;\n      vector<int> tmp2(k);\n      REP(j, k) cin >>tmp2[j];\n      tmp[i] = tmp2;\n      tmp_int = max(tmp_int, (int)(tmp2.size()));\n    }\n    REP(i, tmp_int){\n      REP(j, n){\n        if(i >= tmp[j].size()) continue;\n        books.push_back(tmp[j][i]);\n      }\n    }\n\n    REP(i, books.size()){\n      take_book(books[i]);\n      if(is_full(0)){\n        put_book(books[i]);\n        int tmp_book = take_oldbook();\n        put_oldbook(tmp_book);\n        take_book(books[i]);\n        put_book(books[i]);\n      } else{\n        put_book(books[i]);\n      }\n    }\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nusing namespace std;\n\nint inf = 1e8;\n\nint minimum_steiner_tree(const vector<int>& T, const vector<vector<int> > &g) {\n  const int n = g.size();\n  const int numT = T.size();\n  if (numT <= 1) return 0;\n\n  vector<vector<int> > d(g); // all-pair shortest\n  for (int k = 0; k < n; ++k)\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        d[i][j] = min( d[i][j], d[i][k] + d[k][j] );\n\n  int OPT[(1 << numT)][n];\n  for (int S = 0; S < (1 << numT); ++S)\n    for (int x = 0; x < n; ++x)\n      OPT[S][x] = inf;\n\n  for (int p = 0; p < numT; ++p) // trivial case\n    for (int q = 0; q < n; ++q)\n      OPT[1 << p][q] = d[T[p]][q];\n\n  for (int S = 1; S < (1 << numT); ++S) { // DP step\n    if (!(S & (S-1))) continue;\n    for (int p = 0; p < n; ++p)\n      for (int E = 0; E < S; ++E)\n        if ((E | S) == S)\n          OPT[S][p] = min( OPT[S][p], OPT[E][p] + OPT[S-E][p] );\n    for (int p = 0; p < n; ++p)\n      for (int q = 0; q < n; ++q)\n        OPT[S][p] = min( OPT[S][p], OPT[S][q] + d[p][q] );\n  }\n  int ans = inf;\n  for (int S = 0; S < (1 << numT); ++S)\n    for (int q = 0; q < n; ++q)\n      ans = min(ans, OPT[S][q] + OPT[((1 << numT)-1)-S][q]);\n\n  return ans;\n}\n\nint main(){\n  while(true){\n    vector<int> v;\n    int h = getInt();\n    int w = getInt();\n\n    if(h + w == 0) break;\n\n    REP(i,h) REP(j,w){\n      if(getInt() == 1){\n\tv.push_back(i * w + j);\n      }\n    }\n\n    vector<vector<int> > g(h * w, vector<int>(h * w, inf));\n    \n    REP(i,h) REP(j,w){\n      g[i * w + j][i * w + j] = 0;\n      if(i != h - 1){\n\tg[i * w + j][(i + 1) * w + j] = g[(i + 1) * w + j][i * w + j] = 1;\n      }\n      if(j != w - 1){\n\tg[i * w + j][i * w + j + 1] = g[i * w + j + 1][i * w + j] = 1;\n      }\n    }\n\n    int ans = w * h - (minimum_steiner_tree(v, g) + 1);\n\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<deque>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX 110\nusing namespace std;\n\nstruct P\n{\n  int id; \n  bool ex;\n  P(int id=-inf,bool ex=true):id(id),ex(ex){}\n};\n\nint CNT[MAX];\ndeque<P> desk[MAX];\ndeque<int> Person[MAX];\nint m,c,n,ans,rem;\n\nint getNext(int index)\n{\n  while(Person[index].empty())index = (index+1)%n;\n  return index;\n}\n\nvoid take(int index)\n{\n  bool ok = false;\n  rep(i,m)\n    {\n      rep(j,desk[i].size())\n\t{\n\t  //cout << \"desk[\" << i << \"][\" << j << \"] = \" << desk[i][j].id << \" : \" << desk[i][j].ex << endl;\n\t  if(!desk[i][j].ex)continue;\n\t  if(desk[i][j].id == index)\n\t    {\n\t      desk[i][j].ex = false,ans += (i+1);\n\t      CNT[i]--;\n\t      ok = true;\n\t      //cout << \"take from desk:\" << i << \" +\" << (i+1) << endl;\n\t      return;\n\t    }\n\t}\n      while(!desk[i].empty() && !desk[i].front().ex)desk[i].pop_front();\n    }\n  //cout << \"take from shelf +\" << m+1 << endl;\n  ans += (m+1);\n}\n\nbool check(int index)\n{\n  //cout << \"CNT[0]+1 = \" << CNT[0]+1 << \" <= \" << c << endl;\n  if(CNT[0]+1 <= c)\n    {\n      //cout << \"book : \" << index << \" is able to put desk : \" << 0 << endl;\n      ans++;\n      CNT[0]++;\n      desk[0].push_back(P(index,true));\n      return true;\n    }\n  return false;\n}\n\nvoid put(int index)\n{\n\n  if(check(index))return;\n  \n  //put \n  int pre=-inf;\n  bool ok = false;\n  rep(i,m)\n    if(CNT[i]+1 <= c)\n      {\n\t//cout << \"一時的にdesk\" << i << \"におく　＆　そこから再度取り出す\" << endl;\n\tCNT[i]++;\n\tpre = i;\n\tans += (i+1)*2;\n\tok = true;\n\tbreak;\n      }\n  if(!ok)ans += (m+1)*2;\n\n  //take from desk 1\n  ans++;\n  while(!desk[0].empty() && !desk[0].front().ex)desk[0].pop_front();\n  P p = desk[0].front(); desk[0].pop_front();\n  CNT[0]--;\n  assert(CNT[0] >= 0);\n  //cout << \"0番の本 \" << p.id << \" をとる\" << endl;\n\n  //put\n  ok = false;\n  REP(i,1,m)\n    if(CNT[i]+1 <= c)\n      {\n\t//cout <<\"0番からの本 \" << p.id << \"を机\" << i << \"におく\" << endl;  \n\tCNT[i]++;\n\tans += (i+1);\n\tp.ex = true;\n\tdesk[i].push_back(p);\n\tok = true;\n\tbreak;\n      }\n  if(!ok)ans += (m+1);\n  if(pre != -inf)CNT[pre]--;\n  \n  ans++;\n  CNT[0]++;\n  desk[0].push_back(P(index,true));\n  \n}\n\nint main()\n{\n\n  while(cin >> m >> c >> n,m|n|c)\n    {\n      rem = n;\n      ans = 0;\n      rep(i,m+1)desk[i].clear(),CNT[i] = 0;\n      rep(i,n)Person[i].clear();\n      rep(i,n)\n\t{\n\t  int k,b;\n\t  cin >> k;\n\t  rep(j,k)\n\t    {\n\t      cin >> b;\n\t      Person[i].push_back(b);\n\t    }\n\t}\n\n      int index = 0;\n      while(rem)\n\t{\n\t  //cout << endl;\n\t  //rep(i,m)cout << \"desk[\" << i << \"] = \"<< CNT[i] << \" \";\n\t  //cout << endl;\n\n\t  index = getNext(index);\n\t  //cout << \"index = \" << index << endl;\n\t  int target = Person[index].front(); Person[index].pop_front();\n\t  //cout << \"target = \" << target << endl; \n\t  if(Person[index].empty())rem--;\n\n\t  take(target);\n\t  //cout << \"after take, ans = \" << ans << endl;\n\t  put(target);\n\t  //cout << \"after put, ans = \"<< ans << endl;\n\t  index = (index+1)%n;\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M,C,N;\n\nmap<int,int> desk[111];\nint take(int bk,int &res){  \n  for(int i=0;i<M;i++){\n    if( desk[i].count(bk) ) {\n      res += i+1;\n      desk[i].erase(bk);\n      return i;\n    }\n  }\n  res += M+1;\n  return M;\n}\nint put(int bk,int cnt,int st,int &res){\n  for(int i=st;i<M;i++){\n    if( (int)desk[i].size() < C ) {\n      res += i+1;\n      desk[i][bk] = cnt;\n      return i;      \n    }\n  }\n  res += M+1;\n  return M;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while( cin >> M >> C >> N && (M|C|N) ){\n\n    queue<int> q;\n    queue<int> hq[111];\n\n\n    for(int i=0;i<N;i++){\n      int k; cin >> k;\n      for(int j=0;j<k;j++){\n        int b; cin >> b; hq[i].push(b);\n      }\n      q.push(i);\n    }\n    int res = 0;\n    int cnt = 0;\n    while( !q.empty() ) {\n      cnt++;\n      int p = q.front(); q.pop();\n      if( hq[p].empty() ) continue;\n      int bk = hq[p].front(); hq[p].pop();\n\n\n      take(bk,res);\n      int pid = put(bk,cnt,0,res);\n      if( pid != 0 ){\n        auto dt = *(--desk[0].end());\n        take( dt.first, res );\n        put( dt.first, dt.second, 1, res );\n\n        take( bk,res);\n        assert( put(bk, cnt, 0, res) == 0 );\n      }\n      //cout << cnt << \": \" << res << endl;\n      q.push( p );\n    }\n    for(int i=0;i<=M;i++) desk[i].clear();\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <assert.h>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <double,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nint num_of_desks;\nint book_limit;\nint num_of_students;\n\nint take_book(int id,deque<int> desks[101]){\n  for(int desk_i = 0; desk_i < num_of_desks; desk_i++){\n    for(int i = 0; i < desks[desk_i].size(); i++){\n      if(desks[desk_i][i] == id){\n        deque<int> tmp;\n        for(int j = 0; j < desks[desk_i].size(); j++){\n          if(desks[desk_i][j] == id) continue;\n          tmp.push_back(desks[desk_i][j]);\n        }\n        desks[desk_i] = tmp;\n        return desk_i + 1;\n      }\n    }\n  }\n  return num_of_desks + 1;\n}\n\nint main(){\n  while(~scanf(\"%d %d %d\",&num_of_desks,&book_limit,&num_of_students)){\n    vector<int> students[101];\n    int max_request = 0;\n    for(int student_i = 0; student_i < num_of_students; student_i++){\n      int num_of_books_requested;\n      scanf(\"%d\",&num_of_books_requested);\n      max_request = max(max_request,num_of_books_requested);\n      for(int book_i = 0; book_i < num_of_books_requested; book_i++){\n        int id;\n        scanf(\"%d\",&id);\n        students[student_i].push_back(id);\n      }\n    }\n    queue<int> books;\n    for(int book_i = 0; book_i < max_request; book_i++){\n      for(int student_i = 0; student_i < num_of_students; student_i++){\n        if(students[student_i].size() <= book_i) continue;\n        books.push(students[student_i][book_i]);\n      }\n    }\n\n    deque<int> desks[101];\n\n    int score = 0;\n    while(!books.empty()){\n      int id = books.front();\n      books.pop();\n      // cout << \"book:\" << id << endl;\n      //take from desk/shelf\n      score += take_book(id,desks);\n      // cout << \"take:\" << score << endl;\n      //put \n      if(desks[0].size() < book_limit){\n        desks[0].push_back(id);\n        score += 1;\n      }\n      else{\n        int tmp_place = -1;\n        for(int desk_i = 1; desk_i <= num_of_desks; desk_i++){\n          //put to shelf\n          if(desk_i == num_of_desks){\n            desks[desk_i].push_back(id);\n            tmp_place = desk_i;\n            score += desk_i + 1;\n            break;\n          }\n          //put to desk\n          else if(desks[desk_i].size() < book_limit){\n            desks[desk_i].push_back(id);\n            tmp_place = desk_i;\n            score += desk_i + 1;\n            break;\n          }\n        }\n\n        //take book\n        int old = desks[0].front(); \n        desks[0].pop_front();\n        score += 1;\n\n        for(int desk_i = 1; desk_i <= num_of_desks; desk_i++){\n          //put book\n          if(desk_i == num_of_desks){\n            desks[desk_i].push_back(old);\n            score += desk_i + 1;\n            break;\n          }\n          //put book\n          else if(desks[desk_i].size() < book_limit){\n            desks[desk_i].push_back(old);\n            score += desk_i + 1;\n            break;\n          }\n\n        }\n\n        //take book\n        desks[tmp_place].pop_back();\n        score += tmp_place + 1;\n\n        //put book\n        desks[0].push_back(id);\n        score += 1;\n      }\n      // cout << score << endl;\n    }\n    printf(\"%d\\n\",score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  while(1){\n    int m,c,n;\n    queue<int> q;\n    cin >> m >>  c >> n;\n    if(!m&&!c&&!n)break;\n    int req[100][50]={-1};\n    for(int i=0;i<n;i++){\n      int k;\n      cin >> k;\n      for(int j=0;j<k;j++){\n\tcin >> req[i][j];\n      }\n    }\n    vector<int> re;\n    for(int j=0;j<50;j++){\n      for(int i=0;i<n;i++){\n\tif(req[i][j]==-1||req[i][j]==0)continue;\n\tre.push_back(req[i][j]);\n\t//cout << req[i][j]<< endl;\n      }\n    }\n    //\n    int bo[101];\n    for(int i=0;i<101;i++)bo[i]=m+1;\n    vector<int>dsi(m+1,0);\n    dsi[m+1]=101;\n    int co=0;\n    for(int i=0;i<re.size();i++){\n      co+=bo[re[i]];\n      // cout << co << endl;\n      dsi[re[i]]--;\n    \n      bo[re[i]]=1;\n      dsi[1]++;\n      co++;\n      q.push(re[i]);\n      if(i+1==re.size())break;\n      if(dsi[1]==c){\n\tint b=q.front();q.pop();\n\tdsi[1]--;\n\tco++;\n\tfor(int i=2;;i++){\n\t  if(i==m+1){\n\t    dsi[i]++;\n\t    bo[b]=m+1;\n\t    co+=m+1;\n\t    break;\n\t  }\n\t  else if(dsi[i]<c){\n\t    dsi[i]++;\n\t    bo[b]=i;\n\t    co+=i;\n\t  }\n\t}\n      }\n    }\n    cout <<  co << endl;\n  }\n  return 0;\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <vector>\ntemplate <class T>\ninline bool rd(T &ret) {\n\tchar c; int sgn;\n\tif(c=getchar(),c==EOF) return 0;\n\twhile(c!='-'&&(c<'0'||c>'9')) c=getchar();\n\tsgn=(c=='-')?-1:1;\n\tret=(c=='-')?0:(c-'0');\n\twhile(c=getchar(),c>='0'&&c<='9') ret=ret*10+(c-'0');\n\tret*=sgn;\n\treturn 1;\n}\ntemplate <class T>\ninline void pt(T x) {\n    if (x <0) {\n        putchar('-');\n        x = -x;\n    }\n    if(x>9) pt(x/10);\n    putchar(x%10+'0');\n}\nusing namespace std;\nconst int inf = (int)1e8;\nconst int N = 55;\ntypedef pair<int, int> pii;\n\nint n, m, c;\n\ndeque<int> Q, q[15];\ndeque<int>::iterator it;\nvector<int>G[105];\nint id[105];\nvoid input(){\n\twhile(!Q.empty())Q.pop_front();\n\tfor(int i = 1, num, j; i <= n; i++){\n\t\tG[i].clear();\n\t\trd(num); while(num--){rd(j); G[i].push_back(j);\t}\n\t\treverse(G[i].begin(), G[i].end());\n\t\tif(G[i].size())Q.push_back(i);\n\t}\n\tfor(int i = 1; i <= m; i++) while(!q[i].empty())q[i].pop_front();\n\tfor(int i = 1; i <= 100; i++)id[i] = m+1;\n}\nint putbook(int book, int from){\n\tfor(int i = from; i <= m; i++){\n\t\tif(q[i].size()<c){\n\t\t\tq[i].push_back(book);\n\t\t\tid[book] = i;\n\t\t\treturn i;\n\t\t}\n\t}\n\tid[book] = m+1;\n\treturn m+1;\n}\nint takebook(int book){\n\tif(id[book] == m+1)return m+1;\n\tfor(it = q[id[book]].begin(); it != q[id[book]].end(); it++)\n\t\tif(*it == book){\n\t\t\tq[id[book]].erase(it); break;\n\t\t}\n\treturn id[book];\n}\nint main() {\n\twhile(~scanf(\"%d %d %d\", &m, &c, &n), n + c+m){\n\t\tinput();\n\t\tint ans = 0;\n\t\twhile(!Q.empty()){\n\t\t\tint stu = Q.front();\tQ.pop_front();\n\t\t\tint book = G[stu][G[stu].size()-1];\n\t\t\tG[stu].erase(G[stu].end()-1, G[stu].end());\n\t\t\tif(G[stu].size()) Q.push_back(stu);\n\t\t\tans += takebook(book);\n\t\t\tans += putbook(book, 1);\n\t\t\tif(id[book]!=1){\n\t\t\t\tint pre = q[1].front();\n\t\t\t\tq[1].pop_front();\n\t\t\t\tans++;\n\t\t\t\tans += putbook(pre, 2);\n\t\t\t\tans += takebook(book);\n\t\t\t\tans += putbook(book, 1);\n\t\t\t}\n\t\t}\n\t\tpt(ans); puts(\"\");\n\t}\n    return 0;\n}\n\n/*\n\n9 9\n*#**#**#*\n*#**#**#*\n*#**#**#*\n*#**.**#*\n*#*#.#*#*\n*$##*##$*\n*#*****#*\n*.#.#.#.*\n*********\n3 3\n*$*\n*#*\n*$*\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n  while(1){\n    ll m,c,n;\n    cin>>m>>c>>n;\n    if(!m&&!c&&!n)return 0;\n\n    vector<ll> book[101];\n    vector <ll> D[11];\n    \n    for(int i=0;i<n;i++){\n      int k;\n      cin>>k;\n      book[i].resize(k);\n      for(int j=0;j<k;j++) cin>>book[i][j],D[m].push_back(book[i][j]);\n    }\n\n    queue<int> Q;\n    for(int i=0;i<100;i++)\n      for(int j=0;j<n;j++)\n\tif((int)book[j].size()>i)Q.push(book[j][i]);\n  \n    ll d[11],ans=0;\n    for(int i=0;i<m;i++)d[i]=c;  \n    d[m]=1e9;\n    \n    while(!Q.empty()){\n      ll id=Q.front();Q.pop();\n      ll cost=0;\n      for(int i=0;i<=m&&!cost;i++)\n\tfor(int j=0;j<(int)D[i].size()&&!cost;j++)\n\t  if(id==D[i][j])cost=i+1,D[i].erase(D[i].begin()+j);\n      \n      ans+=cost;\n      cost=0;\n      if(D[0].size()<d[0]){\n\tD[0].push_back(id),ans+=1;\n\tcontinue;\n      }\n\n      int pos=0;\n      for(int i=0;i<=m&&!cost;i++)\n\tif(D[i].size()<d[i])D[i].push_back(id),cost=(i+1)*2+1,pos=i;\n      \n      ans+=cost;\n      cost=0;\n      for(int i=0;i<=m&&!cost;i++)\n\tif(D[i].size()<d[i]){\n\t  D[i].push_back(D[0][0]);\n\t  D[0].erase(D[0].begin());\n\t  cost=i+2;\n\t}\n      ans+=cost;      \n      cost=0;\n      D[pos].erase(D[pos].end()-1);\n      D[0].push_back(id);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <queue>\n//#define cin fin\n#define MAXN 200\nusing namespace std;\n\nqueue <int> q[20];\nint a[MAXN][MAXN];\nlong long cost;\nint m,c,n,len;\n\nint check(int begin, int end)\n{\n    int i;\n    for (i=begin;i<=end;i++)\n        if (q[i].size()<c) return i;\n\n    return m+1;\n}\nint find( int num, int begin ,int end )\n{\n    int i;\n    for (i=begin;i<=end;i++)\n    {\n        q[0] = q[i];\n        while (!q[0].empty())\n        {\n            if (q[0].front()==num) return i;\n            q[0].pop();\n        }\n    }\n    return m+1;\n}\nvoid erase( int num, int k)\n{\n    while (!q[0].empty()) q[0].pop();\n    int i,j,x;\n    while (!q[k].empty())\n    {\n        x = q[k].front();\n        if (x!=num)\n        {\n            q[0].push(x);\n        }\n        q[k].pop();\n    }\n    q[k] = q[0];\n}\nint main()\n{\n    ifstream fin(\"B.in\");\n    int i,j,k,kk,num;\n    cin >> m >> c >> n;\n    while ( !( m==0 && c==0 && n==0 ))\n    {\n        len = 0;\n        memset(a,0,sizeof(a));\n        cost = 0;\n        for (i=1;i<=m;i++)\n            while (!q[i].empty()) q[i].pop();\n\n\n        for (i=1;i<=n;i++)\n        {\n            cin >> a[i][0];\n            if (a[i][0]>len) len = a[i][0];\n            for (j=1;j<=a[i][0];j++)\n                cin >> a[i][j];\n        }\n\n\n        for (j=1;j<=len;j++)\n            for (i=1;i<=n;i++)\n                if (a[i][j]!=0)\n                {\n                    k = find(a[i][j],1,m);\n                    if (k!=m+1)\n                    {\n                        erase(a[i][j],k);\n                    }\n                    cost += k;\n\n                    //諡ソ荵ヲ螳梧ッ?\n                    k = check(1,m);\n                    q[k].push(a[i][j]);\n                    cost += k;\n                    //證よ慮蟄俶叛\n                    if (k!=1)\n                    {\n                        num = q[1].front();\n                        q[1].pop();\n                        cost += 1;\n\n                        kk=check(2,m);\n                        if (kk!=m+1)\n                        {\n                            q[kk].push(num);\n                        }\n                        cost += kk;\n                        //霓ャ遘サ螳梧ッ?\n                        erase(a[i][j],k);\n                        cost += k;\n\n                        q[1].push(a[i][j]);\n                        cost += 1;\n\n                    }\n\n                }\n\n        cout << cost << endl;\n        cin >> m >> c >> n;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tfor(int m,c,n;scanf(\"%d%d%d\",&m,&c,&n),m;){\n\t\tqueue<int> Q[100];\n\t\trep(i,n){\n\t\t\tint sz; scanf(\"%d\",&sz);\n\t\t\trep(j,sz){\n\t\t\t\tint a; scanf(\"%d\",&a);\n\t\t\t\tQ[i].push(a);\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tdeque<int> dai[10];\n\t\twhile(1){\n\t\t\tbool end=true;\n\t\t\trep(i,n) if(!Q[i].empty()) {\n\t\t\t\tend=false;\n\n\t\t\t\t// 本を取る\n\t\t\t\tint book=Q[i].front(); Q[i].pop();\n\t\t\t\tint pos=m;\n\t\t\t\trep(j,m) if(count(dai[j].begin(),dai[j].end(),book)>0) {\n\t\t\t\t\tpos=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(pos<m){\n\t\t\t\t\tdai[pos].erase(find(dai[pos].begin(),dai[pos].end(),book));\n\t\t\t\t}\n\t\t\t\tans+=pos+1;\n\n\t\t\t\t// 本を置く\n\t\t\t\tif(dai[0].size()<c){\n\t\t\t\t\tdai[0].push_back(book);\n\t\t\t\t\tans+=1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// step 1\n\t\t\t\t\tint pos2=m;\n\t\t\t\t\tfor(int j=1;j<m;j++) if(dai[j].size()<c) {\n\t\t\t\t\t\tpos2=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos2<m){\n\t\t\t\t\t\tdai[pos2].push_back(book);\n\t\t\t\t\t}\n\t\t\t\t\tans+=pos2+1;\n\n\t\t\t\t\t// step 2\n\t\t\t\t\tint sub=dai[0].front(); dai[0].pop_front();\n\t\t\t\t\tans++;\n\n\t\t\t\t\t// step 3\n\t\t\t\t\tint pos3=m;\n\t\t\t\t\tfor(int j=1;j<m;j++) if(dai[j].size()<c) {\n\t\t\t\t\t\tpos3=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pos3<m){\n\t\t\t\t\t\tdai[pos3].push_back(sub);\n\t\t\t\t\t}\n\t\t\t\t\tans+=pos3+1;\n\n\t\t\t\t\t// step 4\n\t\t\t\t\tdai[pos2].erase(find(dai[pos2].begin(),dai[pos2].end(),book));\n\t\t\t\t\tans+=pos2+1;\n\n\t\t\t\t\t// step 5\n\t\t\t\t\tdai[0].push_back(book);\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end) break;\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX_D = 11;\nint m,c,n,ans;\nvector<int> req;\nvector<int> D[MAX_D];\n\nvoid input(){\n  vector<int> tmp[n];\n  int sum = 0;\n\n  for(int i = 0; i < n; i++){\n    int num;\n    cin >> num;\n    sum += num;\n    for(int j = 0; j < num; j++){\n      int in;\n      cin >> in;\n      tmp[i].push_back(in);\n    }\n  }\n  \n  int pos = 0;\n  while(sum){\n    for(int i = 0; i < n; i++)\n      if(tmp[i].size() > pos){\n\treq.push_back(tmp[i][pos]);\n\tsum--;\n      }\n    pos++;\n  }\n\n  D[m] = req;\n}\n\nvoid init(){\n  req.clear();\n  for(int i = 0; i < MAX_D; i++)\n    D[i].clear();\n  ans = 0;\n}\n\nint find(int num){\n\n  vector<int>::iterator ite;\n\n  for(int i = 0; i <= m; i++)\n    for(ite = D[i].begin(); ite < D[i].end(); ite++)\n      if(*ite == num){\n\tD[i].erase(ite);\n\treturn i+1;\n      }\n}\n\nint ret(int num){\n  int cost = 0;\n\n  if(D[0].size() < c){\n    D[0].push_back(num);\n    return 1;\n  }else{\n    int minpos = m;\n    for(int i = 0; i < m; i++)\n      if(D[i].size() < c){\n\tminpos = i;\n\tbreak;\n      }\n\n    //from counter to minpos+1\n    cost += minpos+1;\n\n    int tmppos = m;\n    for(int i = 0; i < m; i++)\n      if(i == minpos){\n\tif(D[i].size()+1 < c){\n\t  tmppos = i;\n\t  break;\n\t}\n      }else if(D[i].size() < c){\n\ttmppos = i;\n\tbreak;\n      }\n    //from 1 to (tmppos+1)\n    cost+=tmppos+2;\n\n    D[tmppos].push_back(D[0][0]);\n    D[0].erase(D[0].begin());\n\n\n    D[0].push_back(num);\n\n    //from (minpos+1) to 1\n    cost += minpos+2;\n  }\n  return cost;\n}\nvoid solve(){\n\n  for(int i = 0; i < req.size(); i++){\n    int fpos = find(req[i]);\n    int rcos = ret(req[i]);\n    ans += fpos+rcos;\n  }\n  cout << ans << endl;\n}\n\nint main(){\n\n  while(cin >> m >> c >> n && m+c+n){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint main(){\n\n    int n,m,c;\n    while(cin>>m>>c>>n&&!(m==0&&c==0&&n==0)){\n        vector<vector<int> > orders;\n        vector<int> idxs;\n        for(int i = 0; i < n; i++) idxs.push_back(0);\n        queue<int> waiter;\n        for(int i = 0; i < n; i++) waiter.push(i);\n        for(int i = 0; i < n; i++){\n            int k;\n            cin>>k;\n            vector<int> v;\n            for(int j = 0; j < k; j++){\n                int b;\n                cin>>b;\n                v.push_back(b);\n            }\n            orders.push_back(v);\n        }\n        vector<vector<int> > tableAndShelf;\n        for(int i = 0; i < m; i++)tableAndShelf.push_back(vector<int>());\n        vector<int> shelf;\n        for(int i = 0; i < 101; i++)\n            shelf.push_back(i);\n        tableAndShelf.push_back(shelf);\n        int sumCost=0;\n        while(waiter.size()){\n            int member=waiter.front();\n            int bookid=orders[member][idxs[member]];\n            waiter.pop();\n            for(int i = 0; i < tableAndShelf.size(); i++){\n                vector<int>::iterator it=find(tableAndShelf[i].begin(),tableAndShelf[i].end(),bookid);\n                if(it!=tableAndShelf[i].end()){\n                    tableAndShelf[i].erase(it);\n                    sumCost+=i+1;\n                    break;\n                }\n            }\n            if(tableAndShelf[0].size()<c){\n                tableAndShelf[0].push_back(bookid);\n                sumCost+=1;\n            }\n            else{\n                pair<int,int> tmp;\n                for(int i = 0; i < tableAndShelf.size(); i++){\n                    if(tableAndShelf[i].size()<c||i==tableAndShelf.size()-1){\n                        tableAndShelf[i].push_back(bookid);\n                        sumCost+=i+1;\n                        tmp.first=i;\n                        tmp.second=tableAndShelf[i].size()-1;\n                        break;\n                    }\n                }\n                int old=tableAndShelf[0][0];\n                tableAndShelf[0].erase(tableAndShelf[0].begin());\n                sumCost++;\n                for(int i = 1; i < tableAndShelf.size(); i++){\n                    if(tableAndShelf[i].size()<c||i==tableAndShelf.size()-1){\n                        tableAndShelf[i].push_back(old);\n                        sumCost+=i+1;\n                        break;\n                    }\n                }\n                tableAndShelf[tmp.first].erase(tableAndShelf[tmp.first].begin()+tmp.second);\n                sumCost+=tmp.first+1;\n                tableAndShelf[0].push_back(bookid);\n                sumCost++;\n            }\n            idxs[member]++;\n            if(idxs[member]!=orders[member].size())\n                waiter.push(member);\n        }\n        cout<<sumCost<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <list>\n#include <set>\n#include <cassert>\n#include <iostream>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\n#define f first\n#define s second\n#define mp make_pair\n\nusing namespace std;\n\nstruct Sectors{\n  int start;\n  int end;\n  int id;\n  Sectors() : start(0), end(1000000010), id(-1){}\n  Sectors(int s, int e, int i) : start(s), end(e), id(i){}\n\n  int size(){ return end - start + 1; }\n  bool isEmpty(){ return id == -1; }\n  bool isIn(int sec){ return start <= sec && sec <= end; }\n};\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n), n){\n    list<Sectors> ss;\n    int emp = 0;\n\n    ss.push_back(Sectors());\n \n    REP(cc, n){\n      char buff[2];\n      scanf(\"%s\", buff);\n      if(buff[0] == 'W'){\n\tint l, s;\n\tscanf(\"%d%d\", &l, &s);\n\n\tif(emp == 0){\n\t  list<Sectors>::iterator it = ss.end(); --it;\n\t  int start = it->start;\n\t  int end   = start + s;\n\t  it->start = end + 1;\n\t  it = ss.insert(it, Sectors(start, end, l));\n\t}else{\n\t  list<Sectors>::iterator it = ss.begin();\n\t  while(s > 0){\n\t    if(it->isEmpty()){\n\t      int sz = it->size();\n\t      if(sz > s){\n\t\tint start = it->start;\n\t\tint end   = start + s;\n\t\tit->start = end + 1;\n\t\tit = ss.insert(it, Sectors(start, end, l));\n\t\tbreak;\n\t      }else{\n\t\ts -= sz;\n\t\tit->id = l;\n\t\temp--;\n\t      }\n\t    }\n\n\t    assert(it != ss.end());\n\t    ++it;\n\t  }\n\t}\n      }else if(buff[0] == 'D'){\n\tint l;\n\tscanf(\"%d\", &l);\n\tFOR(it, ss){\n\t  if(it->id == l){\n\t    it->id = -1;\n\t    emp++;\n\t  }\n\t}\n      }else{\n\tint sec;\n\tscanf(\"%d\", &sec);\n\n\tFOR(it, ss){\n\t  if(it->isIn(sec)){\n\t    printf(\"%d\\n\", it->id);\n\t    break;\n\t  }\n\t}\n      }\n\n      // FOR(it, ss)printf(\"[%d,%d]:%d \", it->start, it->end, it->id);puts(\"\");\n    }\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// Book Replacement\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1258\n\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\n#define ALL(v) (v).begin(),(v).end()\n\nusing namespace std;\n\nint M, C, N;\nvector<vector<int>> desks;\nvector<queue<int>> students;\n\nbool is_full(int i) {\n    return desks[i].size() == C;\n}\n\nint move_book(int book_num) {\n    for (int i = 1; i < M; ++i) {\n        if (!is_full(i)) {\n            desks[i].push_back(book_num);\n            return i + 1;\n        }\n    }\n    return M + 1;\n}\n\nint lend_book(int book_num) {\n    for (int i = 0; i < M; ++i) {\n        if (find(ALL(desks[i]), book_num) != desks[i].end()) {\n            desks[i].erase(find(ALL(desks[i]), book_num));\n            return i + 1;\n        }\n    }\n    return M + 1;\n}\n\nint return_book(int book_num) {\n    int cost = 0;\n\n    if (!is_full(0)) {\n        desks[0].push_back(book_num);\n        return 1;\n    }\n\n    cost += move_book(book_num);\n\n    int old_book_num = desks[0].front();\n    cost += 1;\n    desks[0].erase(find(ALL(desks[0]), old_book_num));\n    cost += move_book(old_book_num);\n\n    for (int i = 1; i < M; ++i) {\n        if (find(ALL(desks[i]), book_num) != desks[i].end()) {\n            desks[i].erase(find(ALL(desks[i]), book_num));\n            cost += i + 1;\n            break;\n        }\n        if (i == M-1) cost += M + 1;\n    }\n\n    if (M == 1) cost += M + 1;\n    desks[0].push_back(book_num);\n    cost += 1;\n\n    return cost;\n}\n\nint main() {\n    while (true) {\n        cin >> M >> C >> N;\n        if (!M && !C && !N) break;\n        desks.assign(M, vector<int>());\n        students.assign(N, queue<int>());\n\n        int max_turn = 0;\n        for (int nth = 0; nth < N; ++nth) {\n            int K;\n            cin >> K;\n            for (int i = 0; i < K; ++i) {\n                int book_num;\n                cin >> book_num;\n                students[nth].push(book_num);\n            }\n            max_turn = max(max_turn, (int)students[nth].size());\n        }\n\n        int total_cost = 0;\n        for (int turn = 0; turn < max_turn; ++turn) {\n            for (int nth = 0; nth < N; ++nth) {\n                if (students[nth].empty()) continue;\n                int book_num = students[nth].front();\n                students[nth].pop();\n                total_cost += lend_book(book_num); \n                total_cost += return_book(book_num);\n            }\n        }\n\n        cout << total_cost << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\n\nint main() {\n  int m, c, n;\n  while(cin>>m>>c>>n, m||c||n) {\n    queue<int> b[n];\n    queue<pii> Q;\n    REP(i, n) {\n      int k;\n      cin >> k;\n      REP(j, k) {\n        int a;\n        cin >> a;\n        if (j==0)\n          Q.push(pii(i, a));\n        else\n          b[i].push(a);\n      }\n    }\n    int desk[m+1];              // desk[m]ÍgíÈ¢ªAªòð­È­·é½ßìé\n    memset(desk, 0, sizeof(desk));\n    int pos[100];\n    REP(i, 100) pos[i] = m;\n    int ans = 0;\n    map<int, int> D1;\n    int time = 0;\n    \n    while(!Q.empty()) {\n      pii p = Q.front(); Q.pop();\n      int book = p.second;\n      int man = p.first;\n      \n      if (!b[man].empty()) {\n        Q.push(pii(man, b[man].front()));\n        b[man].pop();\n      }\n\n      // ¡ éê©çæèo·\n      if (pos[book] != m)\n        desk[pos[book]]--;\n      ans += pos[book] + 1;\n      // printf(\"%d©ç%dðæèo· : %d\\n\", pos[book], book, ans);\n      \n      if (pos[book]) {\n        int nearest = m;\n        REP(i, m)\n          if (desk[i] < c) {\n            nearest = i;\n            break;\n          }\n        if (nearest == 0) {\n          // D1Éu­\n          desk[0]++;\n          \n          D1[book] = time;\n          pos[book] = 0;\n          ans += 1;\n          // printf(\"0Éu­ : %d \\n\", ans);\n        } else {\n          // êIÉêÔß¢êÉu­\n          int tmp = nearest;\n          desk[tmp]++;\n          ans += tmp + 1;\n          // printf(\"êIÉ%dÉu­ : %d\\n\", tmp,ans);\n          \n          // D1©çêÔgíêÄÈ¢{ðIÑAÊÌêÉu­\n          map<int,int>::iterator change;\n          int mi = INF;\n          FOR(it, D1) {\n            if (mi > it->second) {\n              mi = it->second;\n              change = it;\n            }\n          }\n          int changebook = change->first;\n          D1.erase(change);\n          desk[0]--;\n          ans += 1;\n          nearest = m;\n          for (int i=1; i<m; ++i) \n            if (desk[i] < c) {\n              nearest = i;\n              break;\n            }\n          pos[changebook] = nearest;\n          desk[nearest]++;\n          ans += nearest+1;\n          //printf(\"D1É é%dð%dÉu­ : %d\\n\", changebook, nearest, ans);\n          \n          // v³ê½{ðêIÉu¢½ê©çD1Éu­\n          desk[tmp]--;\n          ans += tmp + 1;\n          D1[book] = time;\n          desk[0]++;\n          pos[book] = 0;\n          ans += 1;\n          //printf(\"%dÉ é%dð0Éu­ : %d\\n\", tmp, book, ans);\n        }\n      } else {\n        ans += 1;\n        //printf(\"0Éß· : %d\\n\", ans);\n        desk[0]++;\n        D1[book] = time;\n      }\n      //cout << ans << endl;\n      time++;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : Problem.cpp\n// Author      : \n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nint solve(int m, int c, int n)\n{\n\tqueue<int>* queries = new queue<int>[n];\n\tint cost = 0;\n\tint k;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tfor(int j = 0;j < k; j++)\n\t\t{\n\t\t\tint book_id;\n\t\t\tcin >> book_id;\n\t\t\tqueries[i].push(book_id);\n\t\t}\n\t}\n\n\tdeque<int>* desks = new deque<int>[m];\n\tbool flag = true;\n\twhile(flag)\n\t{\n\t\tflag = false;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(queries[i].empty())\n\t\t\t\tcontinue;\n\t\t\tflag = true;\n\t\t\tint book = queries[i].front(); queries[i].pop();\n\t\t\t// find book\n\t\t\tint pos = m;\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif(count(desks[j].begin(), desks[j].end(), book) > 0){\n\t\t\t\t\tpos = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos < m)\n\t\t\t\tdesks[pos].erase(find(desks[pos].begin(), desks[pos].end(), book));\n\n\t\t\tcost += pos + 1;\n\n\t\t\tif((int)desks[0].size() < c)\n\t\t\t{\n\t\t\t\tdesks[0].push_back(book);\n\t\t\t\tcost += 1;\n\t\t\t}else{\n\t\t\t\t// step 1 : move from shelf(current position) to non-full nearest to entrance desk\n\t\t\t\tint pos_2 = m;\n\t\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tif((int)desks[j].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos_2 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos_2 < m)\n\t\t\t\t\tdesks[pos_2].push_front(book);\n\t\t\t\tcost += pos_2 + 1;\n\n\t\t\t\t// step 2 : move least recently used from desk 1\n\t\t\t\tint pos_3 = m;\n\t\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tif((int)desks[j].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos_3 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lru = desks[0].front(); desks[0].pop_front();\n\t\t\t\tdesks[pos_3].push_back(lru);\n\n\t\t\t\tcost += 1 + pos_3;\n\t\t\t\tcost += 1;\n\n\t\t\t\t// step 3 : move book from pos_2 to desk 1\n\t\t\t\tif(pos_2 < m)\n\t\t\t\t\tdesks[pos_2].pop_front();\n\t\t\t\tdesks[0].push_back(book);\n\t\t\t\tcost += pos_2 + 1;\n\t\t\t\tcost += 1;\n\t\t\t}\n\t\t}\n\t}\n\tdelete[] desks;\n\tdelete[] queries;\n\treturn cost;\n}\n\nint main() {\n\tint m, c, n;\n\tcin >> m >> c >> n;\n\twhile(m != 0 && c != 0 && n != 0)\n\t{\n\t\tcout << solve(m,c,n) << endl;\n\t\tcin >> m >> c >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\nint main(){\n\tint m,c,n;\n\twhile(cin>>m>>c>>n,m){\n\t\tvi k(n);\n\t\tvvi b(n,vi());\n\t\tqueue<vi> q;\n\t\tREP(i,n){\n\t\t\tcin>>k[i];\n\t\t\tREP(j,k[i]){\n\t\t\t\tint bb;\n\t\t\t\tcin>>bb;\n\t\t\t\tb[i].push_back(bb);\n\t\t\t}\n\t\t\tq.push(b[i]);\n\t\t}\n\t\tvvi d(m,vi());\n\n\t\tint cost=0;\n\n\t\twhile(!q.empty()){\n\t\t\tvi p=q.front();q.pop();\n\t\t\tint req=p.front();p.erase(p.begin(),p.begin()+1);\n\t\t\t//If a student requests a book, the librarian enters the storeroom and looks for it on D1, ... , Dm in this order,\n\t\t\t//and then on the shelf. After finding the book, the librarian takes it and gives a copy of a page to the student. \n\t\t\tint founddesk=-1,foundloc=-1;\n\t\t\tREP(i,m){\n\t\t\t\tvi::iterator it= find(ALL(d[i]),req);\n\t\t\t\tif(it!=d[i].end()){\n\t\t\t\t\tfounddesk=i;\n\t\t\t\t\tfoundloc=it-d[i].begin();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(founddesk==-1){\n\t\t\t\tcost+=m+1;\n\t\t\t}else{\n\t\t\t\td[founddesk].erase(d[founddesk].begin()+foundloc,d[founddesk].begin()+foundloc+1);\n\t\t\t\tcost+=founddesk+1;\n\t\t\t}\n\n\t\t\t//If D1 is not full (in other words, the number of books on D1 < c), the librarian puts the requested book there.\n\t\t\tif(d[0].size()<c){\n\t\t\t\td[0].push_back(req);\n\t\t\t\tcost+=1;\n\t\t\t}\n\n\t\t\t//If D1 is full, the librarian\n\t\t\telse{\n\t\t\t\tbool put=false;\n\t\t\t\tint tempdesk=-1,temploc=-1;\n\t\t\t\tREP(i,m){\n\t\t\t//    temporarily puts the requested book on the non-full desk closest to the entrance or,\n\t\t\t\t\tif(d[i].size()<c){\n\t\t\t\t\t\td[i].push_back(req);\n\t\t\t\t\t\tput=true;\n\t\t\t\t\t\ttempdesk=i;\n\t\t\t\t\t\ttemploc=d[i].size()-1;\n\t\t\t\t\t\tcost+=i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//in case all the desks are full,on the shelf,\n\t\t\t\tif(!put){\n\t\t\t\t\ttempdesk=-1;\n\t\t\t\t\tcost+=m+1;\n\t\t\t\t}\n\t\t\t//    finds the book on D1 that has not been requested for the longest time (i.e. the least recently used book) and takes it,\n\t\t\t\tint lru=d[0].front();\n\t\t\t\td[0].erase(d[0].begin(),d[0].begin()+1);\n\t\t\t\tcost+=1;\n\t\t\t//    puts it on the non-full desk (except D1 ) closest to the entrance or,\n\t\t\t\tbool putlru=false;\n\t\t\t\tFOR(j,1,m){\n\t\t\t\t\tif(d[j].size()<c){\n\t\t\t\t\t\td[j].push_back(lru);\n\t\t\t\t\t\tputlru=true;\n\t\t\t\t\t\tcost+=j+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//in case all the desks except D1 are full, on the shelf,\n\t\t\t\tif(!putlru){\n\t\t\t\t\tcost+=m+1;\n\t\t\t\t}\n\t\t\t//    takes the requested book from the temporary place,\n\t\t\t\tif(tempdesk!=-1){\n\t\t\t\t\td[tempdesk].erase(d[tempdesk].begin()+temploc,d[tempdesk].begin()+temploc+1);\n\t\t\t\t\tcost+=tempdesk+1;\n\t\t\t\t}else{\n\t\t\t\t\tcost+=m+1;\n\t\t\t\t}\n\t\t\t//    and finally puts it on D1 .\n\t\t\t\td[0].push_back(req);\n\t\t\t\tcost+=1;\n\t\t\t}\n\n\t\t\tif(!p.empty()){\n\t\t\t\tq.push(p);\n\t\t\t}\n\t\t}\n\n\t\tcout<<cost<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M,C,N;\n\nmap<int,int> desk[111];\nint take(int bk,int &res){  \n  for(int i=0;i<M;i++){\n    if( desk[i].count(bk) ) {\n      res += i+1;\n      desk[i].erase(bk);\n      return i;\n    }\n  }\n  res += M+1;\n  return M;\n}\nint put(int bk,int cnt,int st,int &res){\n  for(int i=st;i<M;i++){\n    if( (int)desk[i].size() < C ) {\n      res += i+1;\n      desk[i][bk] = cnt;\n      return i;      \n    }\n  }\n  res += M+1;\n  return M;\n}\n\npair<int,int> mink(map<int,int> &mp){\n  auto p = make_pair(0,(1<<19));\n  for( auto it = mp.begin(); it != mp.end(); it++ ){\n    if( p.second > it->second ) p = *it;\n  }\n  return p;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while( cin >> M >> C >> N && (M|C|N) ){\n\n    queue<int> q;\n    queue<int> hq[111];\n\n\n    for(int i=0;i<N;i++){\n      int k; cin >> k;\n      for(int j=0;j<k;j++){\n        int b; cin >> b; hq[i].push(b);\n      }\n      q.push(i);\n    }\n    int res = 0;\n    int cnt = 0;\n    while( !q.empty() ) {\n      cnt++;\n      int p = q.front(); q.pop();\n      if( hq[p].empty() ) continue;\n      int bk = hq[p].front(); hq[p].pop();\n\n\n      take(bk,res);\n      int pid = put(bk,cnt,0,res);\n      if( pid != 0 ){\n        auto dt = mink(desk[0]);\n        take( dt.first, res );\n        put( dt.first, dt.second, 1, res );\n\n        take( bk,res);\n        assert( put(bk, cnt, 0, res) == 0 );\n      }\n      //cout << cnt << \": \" << res << endl;\n      q.push( p );\n    }\n    for(int i=0;i<=M;i++) desk[i].clear();\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n\ntemplate<class T> T getAs(){ T v; std::cin >> v; return v; }\ninline int getInt(){ return getAs<int>(); }\n\nusing namespace std;\n\nint main(){\n  while(true){\n    int m = getInt();\n    int c = getInt();\n    int n = getInt();\n\n    if(m + c + n == 0) break;\n\n    vector<vector<int> > b(n);\n\n    REP(i,n){\n      int k = getInt();\n      b[i] = vector<int>(k);\n      REP(j,k) b[i][j] = getInt();\n    }\n\n    vector<set<int> > D(m);\n    vector<int> idx(n);\n    int ans = 0;\n    int end = 0;\n    int id  = 0;\n    map<int, int> lru;\n\n    while(end != n){\n      REP(i,n) if(idx[i] != b[i].size()){\n        int book = b[i][idx[i]++];\n\n        if(idx[i] == b[i].size()) end++;\n\n        // search book\n        bool ok = false;\n        REP(j,m) if(D[j].count(book)){\n          ans += j + 1;\n          D[j].erase(book);\n          ok = true;\n          break;\n        }\n\n        if(!ok) ans += m + 1;\n\n        // return book\n        if(D[0].size() == c){\n          // put on first D\n          int tmp = -1;\n          REP(j,m) if(D[j].size() != c){\n            tmp = j;\n            D[j].insert(book);\n            tmp = j;\n            ans += j + 1;\n            break;\n          }\n          if(tmp == -1){\n            ans += m + 1;\n          }\n\n          // select lru book\n          int lruidx = -1;\n          int lruid  = INT_MAX;\n\n          FOR(it, D[0]){\n            if(lruid > lru[*it]){\n              lruidx = *it;\n              lruid  = lru[*it];\n            }\n          }\n\n          ans += 1;\n          D[0].erase(lruidx);\n\n          // put on first D\n          ok = false;\n          for(int j = 1; j < m; j++) if(D[j].size() != c){\n              D[j].insert(lruidx);\n              ans += j + 1;\n              ok = true;\n              break;\n          }\n          if(!ok) ans += m + 1;\n\n          // take book\n          if(tmp == -1) ans += m + 1;\n          else{\n            ans += tmp + 1;\n            D[tmp].erase(book);\n          }\n\n          // put book on D1\n          ans += 1;\n          D[0].insert(book);\n        }else{\n          D[0].insert(book);\n          ans += 1;\n        }\n\n        lru[book] = id++;\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//52\n#include<iostream>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<deque>\n\nusing namespace std;\n\nint main(){\n  for(int m,c,n;cin>>m>>c>>n,m|c|n;){\n    queue<deque<int> > que;\n    for(int i=0;i<n;i++){\n      int k;\n      cin>>k;\n      deque<int> v(k);\n      for(int j=0;j<k;j++){\n\tcin>>v[j];\n      }\n      que.push(v);\n    }\n    int b[100];\n    fill(b,b+100,m);\n    int cs=0;\n    deque<int> d[11];\n    while(!que.empty()){\n      deque<int> cv=que.front();\n      que.pop();\n      int id=cv[0];\n      cs+=b[id]+1;\n      if(b[id]!=m){\n\td[b[id]].erase(find(d[b[id]].begin(),d[b[id]].end(),id));\n      }\n      if(d[0].size()<c){\n\td[0].push_back(id);\n\tb[id]=0;\n\tcs++;\n      }else{\n\tint i;\n\tfor(i=1;i<m;i++){\n\t  if(d[i].size()<c){\n\t    break;\n\t  }\n\t}\n\td[i].push_back(id);\n\tcs+=i+1;\n\tint j;\n\tfor(j=1;j<m;j++){\n\t  if(d[j].size()<c)break;\n\t}\n\tcs+=j+1;\n\td[j].push_back(d[0][0]);\n\tb[d[0][0]]=j;\n\td[0].pop_front();\n\tcs++;\n\td[0].push_back(id);\n\tcs++;\n\td[i].pop_back();\n\tcs+=i+1;\n\tb[id]=0;\n      }\n      if(cv.size()>1){\n\tcv.pop_front();\n\tque.push(cv);\n      }\n    }\n    cout<<cs<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : Problem.cpp\n// Author      : \n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\n\nint solve(int m, int c, int n)\n{\n\tqueue<int>* queries = new queue<int>[n];\n\tint cost = 0;\n\tint k;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin >> k;\n\t\tfor(int j = 0;j < k; j++)\n\t\t{\n\t\t\tint book_id;\n\t\t\tcin >> book_id;\n\t\t\tqueries[i].push(book_id);\n\t\t}\n\t}\n\n\tdeque<int>* desks = new deque<int>[m];\n\tbool flag = true;\n\twhile(flag)\n\t{\n\t\tflag = false;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(queries[i].empty())\n\t\t\t\tcontinue;\n\t\t\tflag = true;\n\t\t\tint book = queries[i].front(); queries[i].pop();\n\t\t\t// find book\n\t\t\tint pos = m;\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tif(count(desks[j].begin(), desks[j].end(), book) > 0){\n\t\t\t\t\tpos = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(pos < m)\n\t\t\t\tdesks[pos].erase(find(desks[pos].begin(), desks[pos].end(), book));\n\n\t\t\tcost += pos + 1;\n\n\t\t\tif((int)desks[0].size() < c)\n\t\t\t{\n\t\t\t\tdesks[0].push_back(book);\n\t\t\t\tcost += 1;\n\t\t\t}else{\n\t\t\t\t// step 1 : move from shelf(current position) to non-full nearest to entrance desk\n\t\t\t\tint pos_2 = m;\n\t\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tif((int)desks[j].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos_2 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos_2 < m)\n\t\t\t\t\tdesks[pos_2].push_front(book);\n\t\t\t\tcost += pos_2 + 1;\n\n\t\t\t\t// step 2 : move least recently used from desk 1\n\t\t\t\tint pos_3 = m;\n\t\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\t{\n\t\t\t\t\tif((int)desks[j].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos_3 = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint lru = desks[0].front(); desks[0].pop_front();\n\t\t\t\tif(pos_3 < m)\n\t\t\t\t\tdesks[pos_3].push_back(lru);\n\n\t\t\t\tcost += 1 + pos_3;\n\t\t\t\tcost += 1;\n\n\t\t\t\t// step 3 : move book from pos_2 to desk 1\n\t\t\t\tif(pos_2 < m)\n\t\t\t\t\tdesks[pos_2].pop_front();\n\t\t\t\tdesks[0].push_back(book);\n\t\t\t\tcost += pos_2 + 1;\n\t\t\t\tcost += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tdeque<int> dq;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tswap(desks[i], dq);\n\t}\n\n\tqueue<int> q;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tswap(queries[i], q);\n\t}\n\n\tdelete[] desks;\n\tdelete[] queries;\n\treturn cost;\n}\n\nint main() {\n\tint m, c, n;\n\tcin >> m >> c >> n;\n\twhile(m != 0 && c != 0 && n != 0)\n\t{\n\t\tcout << solve(m,c,n) << endl;\n\t\tcin >> m >> c >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint main(){\n  int n, c, m;\n  while(cin>>m>>c>>n && m){\n    int b[100][51];\n    memset(b, -1, sizeof(b));\n    REP(y, n){\n      int k; cin>>k;\n      REP(x, k) cin>>b[y][x];\n    }\n    vector<int> desk[11];\n    int ans = 0;\n    for(int x = 0; x < 51; x++){\n      for(int y = 0; y < n; y++){\n        int cost = 0;\n        if(b[y][x] == -1) continue;\n        int id = b[y][x];\n        bool shelf = true;\n        REP(i, m){\n          vector<int>::iterator it = find(desk[i].begin(), desk[i].end(), id);\n          if(it != desk[i].end()){\n            shelf = false;\n            desk[i].erase(it);\n            cost += i + 1;\n            break;\n          }\n        }\n        if(shelf){\n          cost += m + 1;\n        }\n        if(desk[0].size() < c){\n          desk[0].push_back(id);\n          cost += 1;\n        }else{\n          //temp\n          int temp = m;\n          FOR(i, 1, m){\n            if(desk[i].size() < c){\n              temp = i;\n              desk[i].push_back(id);\n              break;\n            }\n          }\n          cost += temp + 1;\n          //take\n          int take_id = desk[0][0];\n          desk[0].erase(desk[0].begin());\n          cost += 1;\n          //put\n          cost += m + 1;\n          FOR(i, 1, m){\n            if(desk[i].size() < c){\n              desk[i].push_back(take_id);\n              cost -= m + 1;\n              cost += i + 1;\n              break;\n            }\n          }\n          //put\n          if(temp != m) desk[temp].erase(find(desk[temp].begin(), desk[temp].end(), id));\n          cost += temp + 1;\n\n          desk[0].push_back(id);\n          cost += 1;\n        }\n        ans += cost;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int INF = 1<<28;\nconst ll MOD = 1000000007;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint main() {\n\tint m, c, n;\n\twhile(cin >> m >> c >> n, m|c|n) {\n\t\tvector<vi> d(m), ppl(n);\n\t\tint cnt = 0;\n\t\tREP(i, n) {\n\t\t\tint k; cin >> k;\n\t\t\tppl[i].resize(k);\n\t\t\tREP(j, k)\n\t\t\t\tcin >> ppl[i][j];\n\t\t}\n\n\t\tint lmt = 0;\n\t\tfor(int loop=0;; loop = (loop+1)%n) {\n\t\t\tif(!ppl[loop].size()) {\n\t\t\t\tif(lmt++ > n) break;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlmt = 0;\n\t\t\tint book = *ppl[loop].begin();\n\t\t\tppl[loop].erase(ppl[loop].begin());\n\n\t\t\t//take a book\n\t\t\tbool flg = false;\n\t\t\tREP(i, m) {\n\t\t\t\tREP(j, d[i].size()) {\n\t\t\t\t\tif(d[i][j] == book) {\n\t\t\t\t\t\td[i].erase(d[i].begin() + j);\n\t\t\t\t\t\tcnt += i+1;\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flg) break;\n\t\t\t}\n\t\t\tif(!flg) cnt += m+1;\n\n\t\t\t//return a book\n\t\t\tflg = false;\n\t\t\tbool flg2 = false;\n\t\t\tint put = m;\n\t\t\tREP(i, m) {\n\t\t\t\tif(d[i].size() < c) {\n\t\t\t\t\td[i].pb(book);\n\t\t\t\t\tflg = true;\n\t\t\t\t\tcnt += i+1;\n\t\t\t\t\tput = i;\n\t\t\t\t\tif(!i) flg2 = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg2) continue;\n\t\t\tif(!flg) cnt += m+1;\n\n\n\t\t\t//set\n\t\t\tint get = *d[0].begin();\n\t\t\td[0].erase(d[0].begin());\n\t\t\tcnt += 1;\n\n\t\t\tflg = false;\n\t\t\tFOR(i, 1, m) {\n\t\t\t\tif(d[i].size() < c) {\n\t\t\t\t\tflg = true;\n\t\t\t\t\tcnt += i+1;\n\t\t\t\t\td[i].pb(get);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flg) cnt += m+1;\n\n\t\t\td[put].erase(d[put].end()-1);\n\t\t\td[0].pb(book);\n\t\t\tcnt += put + 2;\n\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * hujx.cpp\n *\n *  Created on: 2015年5月21日\n *      Author: dell\n */\n#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<time.h>\n#include<queue>\n#include<stack>\n#include<iterator>\n#include<math.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<map>\n#include<set>\n#include<bitset>\n//#define ONLINE_JUDGE\n#define eps 1e-5\n#define INF 0x7fffffff\n#define FOR(i,a) for((i)=0;i<(a);(i)++)\n#define MEM(a) (memset((a),0,sizeof(a)))\n#define sfs(a) scanf(\"%s\",a)\n#define sf(a) scanf(\"%d\",&a)\n#define sfI(a) scanf(\"%I64d\",&a)\n#define pf(a) printf(\"%d\\n\",a)\n#define pfI(a) printf(\"%I64d\\n\",a)\n#define pfs(a) printf(\"%s\\n\",a)\n#define sfd(a,b) scanf(\"%d%d\",&a,&b)\n#define sft(a,b,num) scanf(\"%d%d%d\",&a,&b,&num)\n#define for1(i,a,b) for(int i=(a);i<b;i++)\n#define for2(i,a,b) for(int i=(a);i<=b;i++)\n#define for3(i,a,b)for(int i=(b);i>=a;i--)\n#define MEM1(a) memset(a,0,sizeof(a))\n#define MEM2(a) memset(a,-1,sizeof(a))\n#define ll long long\nconst double PI=acos(-1.0);\ntemplate<class T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<class T> T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> inline T Min(T a,T b){return a<b?a:b;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\nusing namespace std;\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nint n,m,c;\n#define N 210\n#define M 100010\n#define Mod 1000000000\n#define p(x,y) make_pair(x,y)\nconst int MAX_len=550;\nvector<int> v[15];\nvector<int> req[110];\nint main(){\n    while(scanf(\"%d%d%d\",&m,&c,&n)!=EOF && n+m+c){\n    \tfor(int i=0;i<=m;i++) v[i].clear();\n    \tfor(int i=0;i<=n;i++) req[i].clear();\n    \tint x;\n    \tint bk;\n    \tint tot=0;\n    \tvector<int>::iterator it;\n    \tfor(int i=1;i<=n;i++){\t\t//?入n个人的??次序，下?从1?始\n    \t\tsf(x);\n    \t\ttot += x;\n    \t\tfor(int j=0;j<x;j++){\n    \t\t\tsf(bk);\n    \t\t\treq[i].push_back(bk);\n    \t\t}\n    \t}\n    \tint process=0;\t\t//?理的?度\n    \tint ans=0;\t\t//?的代价\n    \tint req_ord=0;\t//当前??的指?\n    \tint peo_ord=1;\t//当前自然人的指?\n    \twhile(process < tot){\n    \t\tif(req_ord>=(int)req[peo_ord].size()){ //如果当前?理的??指?大于等于某个自然人的???数?\n    \t\t\tpeo_ord++;\t\t\t//我?就跳至下一个人?行??\n    \t\t\tcontinue;\n    \t\t}\n    \t\tint now = req[peo_ord][req_ord]; //取出?人的??的?的id\n    \t\tint flag=0;\n    \t\tfor(int i=1;i<=m;i++){\n    \t\t\tit = find(v[i].begin(),v[i].end(),now); //??1-m个的desk中是否有需要??的?籍\n    \t\t\tif(it == v[i].end()) continue;\n    \t\t\tv[i].erase(it);\t//有的?拿走\n    \t\t\tans += i;\t\t//并且加上?代价\n    \t\t\tflag = 1;\n    \t\t\tbreak;\n    \t\t}\n    \t\tif(!flag)\t\t//如果没有的?就从shelf上面拿\n    \t\t\tans += (m+1);\n\n    \t\tif((int)v[1].size() < c){\t//放回去的?候我?首先看desk[1]，如果没有?，就往desk1里面放?\n    \t\t\tv[1].push_back(now);\n    \t\t\tans += 1;\n    \t\t}else{\t\t//否?的?\n    \t\t\tint j=2;\n    \t\t\twhile((int)v[j].size()>=c && j<=m) j++; //?找??口最近的且未放??的desk??寄存下x\n    \t\t\tif(j<=m)\n    \t\t\t\tv[j].push_back(now);\n    \t\t\tans += j;\t//放在第j个desk（或者是shelf） 上\n    \t\t\tans ++;\t\t\t//回到desk1取?\n    \t\t\tit = v[1].begin();\t//取出desk1中LRU的?籍\n    \t\t\tv[1].erase(v[1].begin());  //取出??籍\n    \t\t\tint k=2;\n    \t\t\twhile((int)v[k].size()>=c&&k<=m) k++; //?找??口最近的且未放??的desk存放那本LRU的?籍\n    \t\t\tif(k<=m)\n    \t\t\t\tv[k].push_back(*it); //如果是desk的? 那?放入\n    \t\t\tans += k;\t\t//将LRU放到第k个desk上面的代价\n    \t\t\tans += j;\n    \t\t\tif(j<=m){\t\t\t//将?且存放在第j个desk上的目??籍取出\n    \t\t\t\tv[j].erase(v[j].begin());\n    \t\t\t}\n    \t\t\tv[1].push_back(now);\t\t\t//放入第一个desk\n    \t\t\tans ++;\t\t//?算到第一个desk的代价\n    \t\t}\n    \t\tprocess++;\t//?理?程+1\n    \t\tpeo_ord++;\t\t//?理人+1\n    \t\tif(peo_ord>n){\t//如果第req_ord所指的?理已?全部?理完，那?下一次重新从第一个人?始，并且req_ord++\n    \t\t\tpeo_ord = 1;\n    \t\t\treq_ord++;\n    \t\t}\n    \t}\n    \tprintf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<list>\n#include<iostream>\nusing namespace std;\nint iBook[110];\nlist<int> g_des[12];\nstruct stud\n{\n    int rbk[60];\n    int now,sum;\n};\nstud g_std[110];\nint g_nDsk,g_mB,g_ns;\nint g_cost;\nint findfirst(int sta)\n{\n    int i=sta;\n    while(!g_des[i].empty()&&g_des[i].size()>=g_mB&&i<=g_nDsk)\n    {\n        i++;\n    }\n\n    return i;\n}\n/*\ntagbok delnotused(int ii)\n{\n    tagbok stt;\n    list<tagbok>::iterator it;\n    list<tagbok>::iterator ma;\n    ma=g_des[ii].begin();\n    for(it=g_des[ii].begin();it!=g_des[ii].end();it++)\n    {\n        if((*ma).time<(*it).time)\n        {\n            ma=it;\n        }\n    }\n    stt=(*ma);\n    g_des[ii].erase(ma);\n    return stt;\n}*/\n\nint req(int ibk)\n{\n    int ret=0;\n    int ind=iBook[ibk];\n    if(ind==0||ind>g_nDsk)\n    {\n        ret+=g_nDsk+1;\n    }\n    else\n    {\n        ret+=ind;\n        g_des[ind].remove(ibk);\n    }\n\n    int now,fi,tmpbk,bedel;\n    if(g_des[1].size()<g_mB)\n    {\n        iBook[ibk]=1;\n        g_des[1].push_back(ibk);\n        ret+=1;\n        return ret;\n    }\n    else\n    {\n        tmpbk=findfirst(2);//蠖灘燕閭ス謾セ逧?慍譁ケ,謾セ荵ヲ\n        ret+=tmpbk;\n        g_des[tmpbk].push_back(ibk);//謾セ荳玖ソ呎悽荵ヲ\n\n        int bkdel = g_des[1].front();//蛻ー1諡ソ荵ヲ\n        ret+=1;\n        g_des[1].pop_front();\n\n/*---------------------*/\n        bedel=findfirst(2);\n        iBook[bkdel]=bedel;//蟆?怙閠∫噪荵ヲ謾セ蛻ー閭ス謾セ逧?ス咲スョ\n        g_des[bedel].push_back(bkdel);\n        ret+=bedel;\n/*------------------------------*/\n\n        ret+=tmpbk;//蛻ーtmpbk諡ソ荵ヲ\n        g_des[tmpbk].remove(ibk);//\n\n        g_des[1].push_back(ibk);\n        ret+=1;//蝗槫芦1\n    }\n    iBook[ibk]=1;\n\n    return ret;\n}\n\nint main ()\n{\n    int i,j,k,iSum=0;\n    while(3==scanf(\"%d%d%d\",&g_nDsk,&g_mB,&g_ns)&&g_nDsk)\n    {\n        iSum=0;\n        g_cost=0;\n        memset(iBook,0,sizeof iBook);\n\n        for(i=1;i<=g_ns;i++)\n        {\n            scanf(\"%d\",&g_std[i].sum);\n            for(j=0;j<g_std[i].sum;j++)\n                scanf(\"%d\",g_std[i].rbk+j);\n\n            g_std[i].now=0;\n            iSum+=g_std[i].sum;\n        }\n\n        while(iSum>0)\n        for(i=1;i<=g_ns;i++)\n        {\n            if(iSum==0) break;\n            while(g_std[i].now>=g_std[i].sum)\n                i++;\n\n            int ttt=req(g_std[i].rbk[g_std[i].now++]);\n            g_cost+=ttt;\n            iSum--;\n        }\n\n        for(i=1;i<=g_nDsk+1;i++)\n            g_des[i].clear();\n\n        printf(\"%d\\n\",g_cost);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<complex>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#include<vector>\n\n#define repi(i,a,b) for(int i = int(a); i < int(b); i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i = int(a); i >= int(b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\nconst double pi = acos(-1.0);\n\nusing namespace std;\n\ntypedef long long ll;\n\nint m, c, n;\nsigned main(){\n    while(cin >> m >> c >> n, m||c||n) {\n        vector<vector<int> > b(n);\n        rep(i, n) {\n            int k;\n            cin >> k;\n            b[i].resize(k);\n            rep(j, k) cin >> b[i][j];\n        }\n\n        vector<int> book;\n        queue<pair<int, int> > q;\n        rep(i, n) q.push(mp(i, 0));\n        while(!q.empty()) {\n            int id = q.front().first;\n            int index = q.front().second;\n            q.pop();\n            if(index == b[id].size()) continue;\n            book.pb(b[id][index]);\n            q.push(mp(id, index+1));\n        }\n        \n        int ans = 0;\n        vector<vector<int> > D(m);\n        vector<int> place(101);\n        rep(i, 101) place[i] = m;\n\n        rep(i, book.size()) {\n            int nbook = book[i];\n            // take book\n            ans += place[nbook] + 1;\n            if(place[nbook] != m) {\n                vector<int>::iterator itr = find(all(D[place[nbook]]), nbook);\n                D[place[nbook]].erase(itr, itr+1);\n            }\n//            cout << \"place of \" << i << \"th book : \" << place[nbook] << endl;\n            if(D[0].size() == c) {\n                // 1\n                int closest = -1;\n                rep(j, m) if(D[j].size() < c) {\n                    closest = j;\n                    break;\n                }\n                if(closest >= 0) {\n                    place[nbook] = closest;\n                    ans += closest + 1;\n                    D[closest].pb(nbook);\n                } else {\n                    place[nbook] = m;\n                    ans += m+1;\n                }\n//                cout << i << \", 1 : \" << ans << endl;\n                \n                // 2\n                int oldest = D[0][0];\n                D[0].erase(D[0].begin(), D[0].begin() + 1);\n                ans++;\n//                cout << i << \", 2 : \" << ans << endl;\n\n                // 3\n                closest = -1;\n                repi(j, 1, m) if(D[j].size() < c) {\n                    closest = j;\n                    break;\n                }\n                if(closest >= 0) {\n                    place[oldest] = closest;\n                    ans += closest + 1;\n                    D[closest].pb(oldest);\n                } else {\n                    place[oldest] = m;\n                    ans += m+1;\n                }\n//                cout << i << \", 3 : \" << ans << endl;\n\n                // 4\n                ans += place[nbook] + 1;\n                if(place[nbook] != m) {\n                    vector<int>::iterator itr = find(all(D[place[nbook]]), nbook);\n                    D[place[nbook]].erase(itr, itr+1);\n                }\n//                cout << i << \", 4 : \" << ans << endl;\n\n                // 5\n                D[0].pb(nbook);\n                place[nbook] = 0;\n                ans++;\n//                cout << i << \", 5 : \" << ans << endl;\n                \n            } else {\n                D[0].pb(nbook);\n                place[nbook] = 0;\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<list>\n#include<algorithm>\nusing namespace std;\ntypedef list<int>L;\ntypedef L::iterator I;\ntypedef vector<int>V;\nL d[30];\nint F(int b,int m,int x,I*p)\n{\n\tint i;\n\tfor(i=b;i<m;++i)if((*p=find(d[i].begin(),d[i].end(),x))!=d[i].end())break;\n\treturn i;\n}\nint G(int b,int m,int c)\n{\n\tint i;\n\tfor(i=b;i<m;++i)if(d[i].size()<c)break;\n\treturn i;\n}\nint main()\n{\n\tint m,c,n,k,b,r,i,j;\n\tL::iterator ite;\n\tV u[100],v;\n\tv.reserve(5000);\n\twhile(scanf(\"%d%d%d\",&m,&c,&n),m)\n\t{\n\t\tfor(i=0;i<m;++i)d[i].clear();\n\t\tv.clear();\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tu[i].clear();\n\t\t\tfor(scanf(\"%d\",&k);k--;)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&b);\n\t\t\t\tu[i].push_back(b);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<50;++i)for(j=0;j<n;++j)if(i<u[j].size())v.push_back(u[j][i]);\n\t\tfor(r=i=0;i<v.size();++i)\n\t\t{\n\t\t\tk=F(0,m,v[i],&ite);\n\t\t\tr+=k+1;\n\t\t\tif(k!=m)d[k].erase(ite);\n\t\t\tif(d[0].size()<c)\n\t\t\t{\n\t\t\t\td[0].push_back(v[i]);\n\t\t\t\t++r;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tj=G(1,m,c);\n\t\t\t\tr+=j+1;\n\t\t\t\tif(j!=m)d[j].push_back(v[i]);\n\t\t\t\tk=G(1,m,c);\n\t\t\t\tif(k!=m)d[k].push_back(d[0].front());\n\t\t\t\tr+=k+1;\n\t\t\t\td[0].pop_front();\n\t\t\t\tif(j!=m)\n\t\t\t\t\td[j].erase(find(d[j].begin(),d[j].end(),v[i]));\n\t\t\t\td[0].push_back(v[i]);\n\t\t\t\tr+=j+3;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint M,C,N;\nint D[20][111];\nint Ds[20];\nint used[111];\nint pl[111];\nint res;\nconst int MAX = 101;\nvector<int> B[111];\nvoid init(){\n  memset( D, 0, sizeof( D ) );\n  memset( Ds,0,sizeof( Ds ) );\n  memset( pl,0,sizeof( pl ) );\n  memset(used,0,sizeof(used));\n  res = 0;\n  used[MAX] = (1<<29);\n}\n\nvoid put(int q,int id){\n  Ds[id]++;\n  D[id][q] = 1;\n  pl[q] = id;\n  res += id+1;\n}\n\nvoid take(int q,int id){\n  Ds[id]--;\n  D[id][q] = 0;\n  pl[q] = -1;\n  res += id+1;\n}\nbool pcheck(int id){\n  if( id==M ) return true;\n  return Ds[id] < C;\n}\n\nint main(){\n  while( cin >> M >> C >> N && (M||C||N) ){\n\n    init();\n    for(int i=0;i<N;i++){\n      int k; cin >> k;\n      B[i].resize(k);\n      for( int &b : B[i] ) {\n        cin >> b;\n        D[M][b] = 1;\n        pl[b] = M;\n      }\n    }\n    vector<int> query;\n    for(int j=0;j<=50;j++){\n      for(int i=0;i<N;i++){\n        if( (int)B[i].size() <= j ) continue;\n        query.push_back( B[i][j] );\n      }\n    }\n\n    int cnt=1;\n    res = 0;\n    for( int q: query ){\n      used[q] = cnt++;\n      for(int i=0;i<=M;i++){\n        if( pcheck( i ) || i == pl[q] ){\n          take( q, pl[q] );\n          put( q, i );          \n          break;\n        }\n      }\n      if( pl[q] == 0 ) continue;\n      int maxid = MAX;\n      for(int i=0;i<=100;i++){\n        if( D[0][i] )\n          if( used[maxid] > used[i] ) maxid = i;        \n      }\n      for(int i=1;i<=M;i++){\n        if( pcheck( i ) ){          \n          take( maxid, pl[maxid] );\n          put( maxid, i );    \n          break;\n        }        \n      }\n      take( q, pl[q] );\n      put( q, 0 );\n    }\n    cout << res << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconst int MAXN = 105;\nconst int MAXK = 52;\nconst int MAXM = 12;\nconst int INF = 1<<28;\nint M, C, N;\nint K[MAXN];\nint B[MAXN][MAXK];\nvector<int> D[MAXM];\nint size[MAXM];\nint pos[MAXN];\n\nint tottekuru(int req) {\n  int res = 0;\n  for(int i = 0; i < M; ++i) {\n    vector<int>::iterator it\n      = find(D[i].begin(), D[i].end(), req);\n    if(it != D[i].end()) {\n      D[i].erase(it);\n      res += i+1;\n      break;\n    }\n  }\n\n  if(D[0].size() < size[0]) {\n    D[0].push_back(req);\n    res += 1;\n    return res;\n  }\n\n  int i, j;\n  for(i = 1; i < M; ++i) {\n    if(D[i].size() < size[i]) {\n      break;\n    }\n  }\n  for(j = i; j < M; ++j) {\n    if(D[j].size() + (i == j) < size[j]) {\n      break;\n    }\n  }\n  int tmp = *D[0].begin();\n  D[0].erase(D[0].begin());\n  D[j].push_back(tmp);\n  D[0].push_back(req);\n  res += i+1 + 1 + j+1 + i+1 + 1;\n  return res;\n}\n\nint main() {\n  while(cin >> M >> C >> N && (M|C|N)) {\n    set<int> s;\n    for(int i = 0; i < N; ++i) {\n      cin >> K[i];\n      for(int j = 0; j < K[i]; ++j) {\n        cin >> B[i][j];\n        s.insert(B[i][j]);\n      }\n    }\n    ++M;\n    for(int i = 0; i < M; ++i) {\n      if(i+1 == M) size[i] = INF;\n      else size[i] = C;\n    }\n    for(int i = 0; i < MAXM; ++i) D[i].clear();\n    D[M-1] = vector<int>(s.begin(), s.end());\n\n    fill(pos, pos+MAXN, 0);\n    int res = 0;\n    while(1) {\n      bool flag = false;\n      for(int i = 0; i < N; ++i) {\n        if(pos[i] == K[i]) continue;\n        flag = true;\n        int req = B[i][pos[i]++];\n        res += tottekuru(req);\n      }\n      if(!flag) break;\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  int m,c,n;\n  while(cin>>m>>c>>n,m||c||n){\n    int k[n];\n    int b[111][55];\n    for(int i=0;i<n;i++){\n      cin>>k[i];\n      for(int j=0;j<k[i];j++) cin>>b[i][j];\n    }\n    list<int> l[m];\n    queue<P> q;\n    for(int i=0;i<n;i++) q.push(P(i,0));\n    int ans=0;\n    while(!q.empty()){\n      P p=q.front();q.pop();\n      int w=p.first,x=p.second;\n      int pos=m;\n      for(int i=0;i<m;i++){\n\tauto latte=find(l[i].begin(),l[i].end(),b[w][x]);\n\tif(latte!=l[i].end()){\n\t  pos=i;\n\t  l[i].erase(latte);\n\t  break;\n\t}\n      }\n      ans+=pos+1;\n      if((int)l[0].size()<c){\n\tl[0].push_front(b[w][x]);\n\tans+=1;\n      }else{\n\tint tmp=m;\n\tfor(int i=1;i<m;i++){\n\t  if((int)l[i].size()<c){\n\t    tmp=i;\n\t    l[tmp].push_back(b[w][x]);\n\t    break;\n\t  }\n\t}\n\tans+=tmp+1;\n\t//cout<<ans<<endl;\n\tint le=l[0].back();\n\tl[0].pop_back();\n\tans+=1;\n\tint pos=m;\n\tfor(int i=1;i<m;i++){\n\t  if((int)l[i].size()<c){\n\t    pos=i;\n\t    l[pos].push_front(le);\n\t    break;\n\t  }\n\t}\n\tans+=pos+1;\n\t//cout<<ans<<endl;\n\tif(tmp<m) l[tmp].pop_back();\n\tans+=tmp+1;\n\t//cout<<ans<<endl;\n\tl[0].push_front(b[w][x]);\n\tans+=1;\n\t//cout<<ans<<endl;\n      }\n      if(x+1<k[w]) q.push(P(w,x+1));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define INF 1000\nint D[10][30],M,C,N;\n\nbool check(int p, int v)\n{\n\tfor(int i=0; i<C; i++)\n\t{\n\t\tif(D[p][i]==v)\n\t\t{\n\t\t\tfor(int j=i; j<C-1; j++)\n\t\t\t\tD[p][j]=D[p][j+1];\n\t\t\t\n\t\t\tD[p][C-1]=INF;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\t\n\treturn false;\n}\n\nvoid set(int p, int v)\n{\n\tfor(int i=0; i<C; i++)\n\t{\n\t\tif(D[p][i]==INF)\n\t\t{\n\t\t\tD[p][i]=v;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint isempty()\n{\n\tfor(int i=0; i<M; i++)\n\tfor(int j=0; j<C; j++)\n\t\tif(D[i][j]==INF) return i+1;\n\t\t\n\treturn -1;\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d%d\", &M,&C,&N), (M||C||N))\n\t{\n\t\tfor(int i=0; i<M; i++)\n\t\tfor(int j=0; j<C; j++)\n\t\t\tD[i][j]=INF;\n\t\t\t\n\t\tqueue<queue<int> > q;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint K;\n\t\t\tscanf(\"%d\", &K);\n\t\t\tqueue<int> tq;\n\t\t\tfor(int j=0; j<K; j++)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\ttq.push(t);\n\t\t\t}\n\t\t\tq.push(tq);\n\t\t}\n\n\t\tint ret=0;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tqueue<int> tq=q.front(); q.pop();\n\t\t\tint id=tq.front(); tq.pop();\n\t\t\t\n\t\t\tbool g=false;\n\t\t\tfor(int i=0; i<M; i++)\n\t\t\t{\n\t\t\t\tif(check(i,id))\n\t\t\t\t{\n\t\t\t\t\tret+=i+1;\n\t\t\t\t\tg=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!g)\n\t\t\t{\n\t\t\t\tret+=M+1;\n\t\t\t}\n\t\t\t\n\t\t\tif(check(0,INF)) \n\t\t\t{\n\t\t\t\tset(0,id);\n\t\t\t\tret++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint tp=0;\n\t\t\t\tg=false;\n\t\t\t\tfor(int i=0; i<M; i++)\n\t\t\t\t{\n\t\t\t\t\tif(check(i,INF))\n\t\t\t\t\t{\n\t\t\t\t\t\tset(i,id);\n\t\t\t\t\t\ttp=i+1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tret+=tp;\n\t\t\t\t\t\t\n\t\t\t\t\t\tg=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!g) \n\t\t\t\t{\n\t\t\t\t\tret+=M+1;\n\t\t\t\t\tret++;\n\t\t\t\t\tret+=M+1;\n\t\t\t\t\tret+=M+1;\n\t\t\t\t\tret++;\n\t\t\t\t\tcheck(0,D[0][0]);\n\t\t\t\t\tset(0,id);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint f=isempty();\n\t\t\t\t\tcheck(tp-1, id);\n\t\t\t\t\tif(f==-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tret++;\n\t\t\t\t\t\tret+=M+1;\n\t\t\t\t\t\tcheck(0, D[0][0]);\n\t\t\t\t\t\tset(0, id);\n\t\t\t\t\t\tret++;\n\t\t\t\t\t\tret+=tp;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tret++; \n\t\t\t\t\t\tret+=f;\t\t \n\t\t\t\t\t\tint tt=D[0][0];\n\t\t\t\t\t\tcheck(0,D[0][0]);\n\t\t\t\t\t\tset(0,id);\n\t\t\t\t\t\tset(f-1, tt);\n\t\t\t\t\t\t\n\t\t\t\t\t\tret+=tp;  \n\t\t\t\t\t\t\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!tq.empty()) q.push(tq);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <assert.h>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <double,P> PP;\n  \nstatic const double EPS = 1e-8;\n\nint num_of_desks;\nint book_limit;\nint num_of_students;\n\nint take_book(int id,deque<int> desks[101]){\n  for(int desk_i = 0; desk_i < num_of_desks; desk_i++){\n    for(int i = 0; i < desks[desk_i].size(); i++){\n      if(desks[desk_i][i] == id){\n        deque<int> tmp;\n        for(int j = 0; j < desks[desk_i].size(); j++){\n          if(desks[desk_i][j] == id) continue;\n          tmp.push_back(desks[desk_i][j]);\n        }\n        desks[desk_i] = tmp;\n        return desk_i + 1;\n      }\n    }\n  }\n  return num_of_desks + 1;\n}\n\nint main(){\n  while(~scanf(\"%d %d %d\",&num_of_desks,&book_limit,&num_of_students)){\n    if(num_of_desks == 0\n       && book_limit == 0\n       && num_of_students == 0) break;\n    vector<int> students[101];\n    int max_request = 0;\n    for(int student_i = 0; student_i < num_of_students; student_i++){\n      int num_of_books_requested;\n      scanf(\"%d\",&num_of_books_requested);\n      max_request = max(max_request,num_of_books_requested);\n      for(int book_i = 0; book_i < num_of_books_requested; book_i++){\n        int id;\n        scanf(\"%d\",&id);\n        students[student_i].push_back(id);\n      }\n    }\n    queue<int> books;\n    for(int book_i = 0; book_i < max_request; book_i++){\n      for(int student_i = 0; student_i < num_of_students; student_i++){\n        if(students[student_i].size() <= book_i) continue;\n        books.push(students[student_i][book_i]);\n      }\n    }\n\n    deque<int> desks[101];\n\n    int score = 0;\n    while(!books.empty()){\n      int id = books.front();\n      books.pop();\n\n      //take from desk/shelf\n      score += take_book(id,desks);\n\n      //put \n      if(desks[0].size() < book_limit){\n        desks[0].push_back(id);\n        score += 1;\n      }\n      else{\n        int tmp_place = -1;\n        for(int desk_i = 1; desk_i <= num_of_desks; desk_i++){\n          //put to shelf\n          if(desk_i == num_of_desks){\n            desks[desk_i].push_back(id);\n            tmp_place = desk_i;\n            score += desk_i + 1;\n            break;\n          }\n          //put to desk\n          else if(desks[desk_i].size() < book_limit){\n            desks[desk_i].push_back(id);\n            tmp_place = desk_i;\n            score += desk_i + 1;\n            break;\n          }\n        }\n\n        //take book\n        int old = desks[0].front(); \n        desks[0].pop_front();\n        score += 1;\n\n        for(int desk_i = 1; desk_i <= num_of_desks; desk_i++){\n          //put book\n          if(desk_i == num_of_desks){\n            desks[desk_i].push_back(old);\n            score += desk_i + 1;\n            break;\n          }\n          //put book\n          else if(desks[desk_i].size() < book_limit){\n            desks[desk_i].push_back(old);\n            score += desk_i + 1;\n            break;\n          }\n\n        }\n\n        //take book\n        desks[tmp_place].pop_back();\n        score += tmp_place + 1;\n\n        //put book\n        desks[0].push_back(id);\n        score += 1;\n      }\n    }\n    printf(\"%d\\n\",score);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  while (true) {\n    int m, c, n;\n    cin >> m >> c >> n;\n    if (m == 0 && c == 0 && n == 0) break;\n\n    queue <int> storder;\n    queue <int> stdesire[n];\n    vector <int> d[m];\n    for (int i = 0; i < n; i++) {\n      storder.push(i);\n      int k;\n      cin >> k;\n      for (int j = 0; j < k; j++) {\n        int ID;\n        cin >> ID;\n        stdesire[i].push(ID);\n      }\n    }\n    int ans = 0;\n    while (!storder.empty()) {\n      int p = storder.front(); storder.pop();\n      int cost = 0;\n      int ID = stdesire[p].front(); stdesire[p].pop();\n      bool ok = false;\n      // ??¬?????¨??£?????????\n      for (int i = 0; i < m; i++) {\n        for (int j = 0; j < d[i].size(); j++) {\n          if (d[i][j] == ID) {\n            ok = true;\n            cost += i+1;\n            d[i].erase(d[i].begin()+j);\n            break;\n          }\n        }\n        if (ok) break;\n      }\n      if (!ok) {\n        cost += m+1;\n      }\n\n      // ??¬?????????\n      bool shelf = true;\n      for (int i = 0; i < m; i++) {\n        if (d[i].size() < c) {\n          if (i == 0) {\n            d[i].push_back(ID);\n            cost += 1;\n          }else {\n            cost += (i+1)*2+1; ok = false;\n            for (int j = 1; j < m; j++) {\n              int bias = j == i;\n              if (d[j].size()+bias < c) {\n                int t = d[0][0];\n                d[0].erase(d[0].begin());\n                d[j].push_back(t); cost += 1+j+1;\n                ok = true;\n                break;\n              }\n            }\n            if (!ok) {\n              int t = d[0][0];\n              d[0].erase(d[0].begin());\n              cost += 1+m+1;\n            }\n            d[0].push_back(ID);\n          }\n          shelf = false;\n          break;\n        }\n      }\n      if (shelf) {\n        cost += (m+1)*2+1+(m+1)+1;\n        d[0].erase(d[0].begin());\n        d[0].push_back(ID);\n      }\n      if (stdesire[p].size()) {\n        storder.push(p);\n      }\n\n      ans += cost;\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1258: Book Replacement\n// 2017.10.22 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int stu, seq, id; } T;\nT req[5002]; int len;\nint desk[12][5001]; int hi[12];\nint book[101][2];\n\nint cmp(T *a, T *b)\n{\n\tif (a->seq - b->seq) return (a->seq - b->seq);\n\treturn a->stu - b->stu;\n}\n\nint main()\n{\n\tint m, c, n, i, j, id, ans;\n\tint from, pos, tmp, id2, t;\n\n\twhile (scanf(\"%d%d%d\", &m, &c, &n) && m > 0) {\n\t\tmemset(hi, 0, sizeof(hi)), memset(book, 0, sizeof(book));\n\t\ttmp = m + 1;\n\t\tfor (len = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\", &t); \n\t\t\tfor (j = 0; j < t; j++) {\n\t\t\t\tscanf(\"%d\", &id);\n\t\t\t\treq[len].stu = i, req[len].seq = j, req[len++].id = id;\n\t\t\t\tif (book[id][0] == 0) {\n\t\t\t\t\tbook[id][0] = tmp, book[id][1] = hi[tmp], desk[tmp][hi[tmp]++] = id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqsort(req, len, sizeof(T), cmp);\n\n\t\tfor (ans = 0, i = 0; i < len; i++) {\n\t\t\tid = req[i].id;\n\t\t\tfrom = book[id][0], pos = book[id][1];\n\n\t\t\tfor (j = pos+1; j < hi[from]; j++) {\n\t\t\t\tt = desk[from][j], book[t][1]--;\n\t\t\t\tdesk[from][j-1] = desk[from][j];\n\t\t\t}\n\t\t\thi[from]--, ans += from;\n\n\t\t\tif (hi[1] == c) {\n\t\t\t\tfor (tmp = 2; tmp <= m && hi[tmp] == c; tmp++);\n\t\t\t\tdesk[tmp][hi[tmp]++] = id, ans += tmp;\n\n\t\t\t\tid2 = desk[1][0];\n\t\t\t\tfor (j = 1; j < hi[1]; j++) {\n\t\t\t\t\tt = desk[1][j], book[t][1]--;\n\t\t\t\t\tdesk[1][j-1] = desk[1][j];\n\t\t\t\t}\n\t\t\t\thi[1]--, ans++;\n\n\t\t\t\tfor (j = 2; j <= m && hi[j] == c; j++);\n\t\t\t\tpos = hi[j]; if (j == tmp) pos--;\n\t\t\t\tdesk[j][pos] = id2; hi[j]++;\n\t\t\t\tbook[id2][0] = j, book[id2][1] = pos;\n\t\t\t\tans += j + tmp; hi[tmp]--;\n\t\t\t}\n\t\t\t\n\t\t\tbook[id][0] = 1, book[id][1] = hi[1];\n\t\t\tdesk[1][hi[1]++] = id, ans++;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1258: Book Replacement\n// 2017.10.22 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct { int stu, seq, id; } T;\nT req[5001]; int len;\nint desk[12][101]; int hi[12];\nint book[501][2];\n\nint cmp(T *a, T *b)\n{\n\tif (a->seq - b->seq) return (a->seq - b->seq);\n\treturn a->stu - b->stu;\n}\n\nint main()\n{\n\tint m, c, n, i, j, k, id, ans;\n\tint from, pos, tmp, id2, t;\n\n\twhile (scanf(\"%d%d%d\", &m, &c, &n) && m > 0) {\n\t\tmemset(hi, 0, sizeof(hi)), memset(book, 0, sizeof(book));\n\t\ttmp = m + 1;\n\t\tfor (len = i = 0; i < n; i++) {\n\t\t\tscanf(\"%d\", &k); \n\t\t\tfor (j = 0; j < k; j++) {\n\t\t\t\tscanf(\"%d\", &id);\n\t\t\t\treq[len].stu = i, req[len].seq = j, req[len++].id = id;\n\t\t\t\tbook[id][0] = tmp, book[id][1] = hi[tmp], desk[tmp][hi[tmp]++] = id;\n\t\t\t}\n\t\t}\n\t\tqsort(req, len, sizeof(T), cmp);\n\n\t\tfor (ans = 0, i = 0; i < len; i++) {\n\t\t\tid = req[i].id;\n\t\t\tfrom = book[id][0], pos = book[id][1];\n\n\t\t\tfor (j = pos+1; j < hi[from]; j++) {\n\t\t\t\tt = desk[from][j], book[t][1]--;\n\t\t\t\tdesk[from][j-1] = desk[from][j];\n\t\t\t}\n\t\t\thi[from]--;\n\t\t\tans += from;\n\n\t\t\tif (hi[1] == c) {\n\t\t\t\tfor (tmp = 2; tmp <= m && hi[tmp] == c; tmp++);\n\t\t\t\tdesk[tmp][hi[tmp]++] = id;\n\t\t\t\tans += tmp;\n\n\t\t\t\tid2 = desk[1][0];\n\t\t\t\tfor (j = 1; j < hi[1]; j++) {\n\t\t\t\t\tt = desk[1][j], book[t][1]--;\n\t\t\t\t\tdesk[1][j-1] = desk[1][j];\n\t\t\t\t}\n\t\t\t\thi[1]--;\n\t\t\t\tans++;\n\n\t\t\t\tfor (j = 2; j <= m && hi[j] == c; j++);\n\t\t\t\tpos = hi[j]; if (j == tmp) pos--;\n\t\t\t\tdesk[j][pos] = id2; hi[j]++;\n\t\t\t\tbook[id2][0] = j, book[id2][1] = pos;\n\t\t\t\tans += j;\n\t\t\t\tans += tmp; hi[tmp]--;\n\t\t\t}\n\t\t\t\n\t\t\tbook[id][0] = 1, book[id][1] = hi[1];\n\t\t\tdesk[1][hi[1]++] = id;\n\t\t\tans++;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAXN 1001\n\nint book[101];\nstruct desk\n{\n    int num;\n    int b[31];\n}d[11];\nstruct student\n{\n    int cur;\n    int num;\n    int b[51];\n}s[101];\nint q[1001];\nint m,c,n,elapse;\n\nint main(void)\n{\n    int i, j, k, t, maxbook, maxtime, cur_book, take_book;\n    while(scanf(\"%d %d %d\",&m,&c,&n), m||c||n)\n    {\n        k=0;elapse=0;\n        for(i=1;i<=m;i++)\n            d[i].num=0;\n        for(i=0;i<=100;i++)\n            book[i]=m+1;\n        for(i=0;i<n;i++)\n        {\n            scanf(\"%d\",&s[i].num);\n            for(j=0;j<s[i].num;j++)\n                scanf(\"%d\",&s[i].b[j]);\n            s[i].cur=0;\n            if(s[i].num)\n                q[k++]=i;\n        }\n        j=0;\n        while(j!=k)\n        {\n            cur_book = s[q[j]].b[s[q[j]].cur++];\n            elapse += book[cur_book];\n            if(book[cur_book]!=m+1)\n            {\n                t=book[cur_book];\n                for(i=0; i<d[t].num; i++)\n                    if(d[t].b[i]==cur_book)\n                        break;\n                for( ; i<d[t].num; i++)\n                    d[t].b[i]=d[t].b[i+1];\n                d[t].num--;\n            }\n            if(d[1].num==c)\n            {\n                i=2;\n                while(i<=m && d[i].num==c)\n                    i++;\n                if(i>m)\n                    book[cur_book]=m+1,elapse=elapse+m+1;\n                else\n                    d[i].b[d[i].num++]=cur_book, book[cur_book]=i, elapse+=i;\n                take_book=d[1].b[0];\n                for(i=0; i<d[1].num; i++)\n                    d[1].b[i]=d[1].b[i+1];\n                elapse++;\n                d[1].num--;\n                i=2;\n                while(i<=m && d[i].num==c)\n                    i++;\n                if(i>m)\n                    book[take_book]=m+1, elapse=elapse+m+1;\n                else\n                    d[i].b[d[i].num++]=take_book, book[take_book]=i, elapse+=i;\n                elapse += book[cur_book];\n                if(book[cur_book]!=m+1)\n                    d[book[cur_book]].num--;\n            }\n            d[1].b[d[1].num++]=cur_book;\n            book[cur_book]=1;\n            elapse++;\n            if(s[q[j]].cur<s[q[j]].num)\n                q[k]=q[j], k=(k+1)%MAXN;\n            j=(j+1)%MAXN;\n        }\n        printf(\"%d\\n\",elapse);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <deque>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nint m, c, n;\nint cost[20];\nint dc[20], srn[20], sqr[20][100];\nqueue<int> req;\ndeque<int> sto[20];\n\nvoid init()\n{\n\tfor (int i = 1; i <= 20; i++)\n\t\tsto[i].clear();\n\twhile (req.size() > 0)\n\t\treq.pop();\n}\n\nint main()\n{\n\twhile (scanf(\"%d%d%d\", &m, &c, &n) != EOF)\n\t{\n\t\tinit();\n\t\tif (m == c && c == n && n == 0)\n\t\t\tbreak;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &srn[i]);\n\t\t\tfor (int j = 0; j < srn[i]; j++)\n\t\t\t\tscanf(\"%d\", &sqr[i][j]);\n\t\t}\n\t\tint tnn[20];\n\t\tmemset(tnn, 0, sizeof(tnn));\n\t\tint ttt = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tttt += srn[i];\n\t\t//printf(\"tttt = %d\\n\", ttt);\n\t\twhile (ttt--)\n\t\t{\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tif (tnn[i] < srn[i])\n\t\t\t\t\treq.push(sqr[i][tnn[i]]), tnn[i]++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\twhile (req.size() > 0)\n\t\t\tprintf(\"%d\\n\", req.front()), req.pop();\n\t\t\t*/\n\t\tmemset(dc, 0, sizeof(dc));\n\t\tlong long ans = 0;\n\t\twhile (req.size() > 0)\n\t\t{\n\t\t\tint ttrep = req.front();\n\t\t\treq.pop();\n\t\t\tint flag = 0;\n\t\t\tfor (int i = 1; i <= m; i++)\n\t\t\t\tfor (int j = 0; j < sto[i].size(); j++)\n\t\t\t\t\tif (ttrep == sto[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tans += i;\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tsto[i].erase(sto[i].begin() + j , sto[i].begin() + j + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (flag == 0)\n\t\t\t\tans += (m + 1);\n\n\t\t\t//拿回storeroom\n\t\t\t//not full\n\t\t\tif (sto[1].size() < c)\n\t\t\t{\n\t\t\t\tsto[1].push_back(ttrep);\n\t\t\t\tans += 1;\n\t\t\t\t//printf(\"ans = %d\\n\", ans);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//printf(\"ans = %d\\n\", ans);\n\t\t\t\tint trrr, trrrj;\n\t\t\t\tflag = 0;\n\t\t\t\tfor (int i = 2; i <= m; i++)\n\t\t\t\t\tif (sto[i].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\ttrrr = i, trrrj = sto[i].size();\n\t\t\t\t\t\t//printf(\"trrrr = %d\\n\", trrr);\n\t\t\t\t\t\tsto[i].push_back(ttrep);\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tans += i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t//printf(\"trrr  =%d , trrrj =%d\\n\", trrr, trrrj);\n\t\t\t\tif (flag == 0)\n\t\t\t\t{\n\t\t\t\t\ttrrr = m + 1;\n\t\t\t\t\tans += (m + 1);\n\t\t\t\t}\n\t\t\t\tint loUn = sto[1].front();\n\t\t\t\tsto[1].pop_front();\n\t\t\t\t//printf(\"sto.size() = %d\\n\", sto[1].size());\n\t\t\t\tans += 1;\n\t\t\t\tflag = 0;\n\t\t\t\tfor (int i = 2; i <= m; i++)\n\t\t\t\t\tif (sto[i].size() < c)\n\t\t\t\t\t{\n\t\t\t\t\t\tsto[i].push_back(loUn);\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tans += i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (flag == 0)\n\t\t\t\t\tans += (m + 1);\n\t\t\t\tif (trrr == m  + 1)\n\t\t\t\t{\n\t\t\t\t\tans += (trrr + 1);\n\t\t\t\t\tsto[1].push_back(ttrep);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans += (trrr + 1);\n\t\t\t\t\tsto[1].push_back(ttrep);\n\t\t\t\t\tsto[trrr].erase(sto[trrr].begin() + trrrj, sto[trrr].begin() + trrrj + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"lllans  = %d\\n\", ans);\n\t\t}\n\t\t//printf(\"ans = %d\\n\" , ans);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint f[105][55], b[15][35], pos[105];\n\nmain(){\n\tint m, c, n, i, j, k, p, max, s;\n\twhile (scanf(\"%d%d%d\",&m,&c,&n)){\n\t\tif (m==0 && c==0 && n==0) break;\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(b,0,sizeof(b));\n\t\tfor (i=1;i<=100;++i) pos[i]=m+1;\n\t\tmax=0;\n\t\tfor (i=1;i<=n;++i){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tif (k>max) max=k;\n\t\t\tfor (j=1;j<=k;++j) {\n\t\t\t\tscanf(\"%d\",&f[i][j]);\n\t\t\t}\n\t\t}\n\t\ts=0;\n\t\tfor (j=1;j<=max;++j)\n\t\t  for (i=1;i<=n;++i)\n\t\t    if (f[i][j]>0){\n\t\t\t\t//printf(\"%d %d\\n\",f[i][j],pos[f[i][j]]);\n\t\t\t\t//printf(\"%d\\n\",b[1][0]);\n\t\t\t\ts+=pos[f[i][j]];                                    //蜴溷ァ狗噪諡ソ荵ヲ \n\t\t\t\tif (pos[f[i][j]]==1){                               //譛ャ譚・蟆ア蝨ィ隨ャ荳?クェ荵ヲ譟?\n\t\t\t\t\ts+=1;\n\t\t\t\t\tfor (k=1;k<=b[1][0];++k)\n\t\t\t\t\t  if (b[1][k]==f[i][j]) break;\n\t\t\t\t\tfor (;k<b[1][0];++k) b[1][k]=b[1][k+1];\n\t\t\t\t\tb[1][b[1][0]]=f[i][j];                                 \n\t\t\t\t}\n\t\t\t\telse {                                              //荳榊惠隨ャ荳?クェ荵ヲ譟?\n\t\t\t\t\tif (b[1][0]<c){                                 //隨ャ荳?クェ荵ヲ譟懈イ。譛画サ。 \n\t\t\t\t\t\ts+=1;\n\t\t\t\t\t\tb[1][0]++;\n\t\t\t\t\t\tpos[f[i][j]]=1;\n\t\t\t\t\t\tb[1][b[1][0]]=f[i][j];\n\t\t\t\t\t}\n\t\t\t\t\telse {                                          //隨ャ荳?クェ荵ヲ譟懈サ。莠?\n\t\t\t\t\t\tfor (k=2;k<=m;++k){                         //謇セ遨コ荵ヲ譟?\n\t\t\t\t\t\t\tif (b[k][0]<c) break;\n\t\t\t\t\t    }\n\t\t\t\t\t    s+=k; \n\t\t\t\t\t    if (pos[f[i][j]]<=m) b[pos[f[i][j]]][0]--;\n\t\t\t\t\t    pos[f[i][j]]=k;                              \n\t\t\t\t\t    if (k<=m) b[k][0]++;                        //荳肴弍荵ヲ譫カ \n\t\t\t\t\t    s+=1;                                       //謚顔ャャ荳?クェ荵ヲ譟懈怙髟ソ荳咲畑逧?ケヲ諡ソ襍ー(隨ャ荳?悽)\n\t\t\t\t\t    for (k=2;k<=m;++k){                         //謇セ蝨ー譁ケ謾セ荳?\n\t\t\t\t\t\t\tif (b[k][0]<c) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts+=k;\n\t\t\t\t\t\tpos[b[1][1]]=k;                        \n\t\t\t\t\t\tif (k<=m) {                                 //謾セ逧?ク肴弍荵ヲ譫カ \n\t\t\t\t\t\t\tb[k][0]++;                                 \n\t\t\t\t\t\t\tb[k][b[k][0]]=b[1][1];                     \n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pos[f[i][j]]<=m) b[pos[f[i][j]]][0]--;\n\t\t\t\t\t\tfor (p=2;p<c;++p) b[1][p]=b[1][p+1];        //譖エ譁ー隨ャ荳?クェ荵ヲ譟懃噪荵ヲ菴ソ逕ィ鬚醍紫 \n\t\t\t\t\t\ts+=pos[f[i][j]]+1;                          //霑呎悽荵ヲ諡ソ蝗樊擂謾セ蛻ー隨ャ荳?クェ荵ヲ譟懈怙蜷朱擇 \n\t\t\t\t\t\tb[1][c]=f[i][j];\n\t\t\t\t\t\tpos[f[i][j]]=1;                             \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//printf(\"%d\\n\\n\",s); \n\t\t\t}\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint c = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif ((m | c | n) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] qq = new int[n][];\n\n\t\t\tint sz = 0;\n\t\t\tint maxx = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tqq[i] = new int[x];\n\t\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\t\tqq[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tmaxx = Math.max(x, maxx);\n\t\t\t\tsz += x;\n\t\t\t}\n\n\t\t\tint[] q = new int[sz];\n\t\t\tint cnt = 0;\n\t\t\tfor (int j = 0; j < maxx; j++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tif (qq[i].length <= j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tq[cnt] = qq[i][j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint map[] = new int[100];\n\n\t\t\tLinkedList<Integer> l = new LinkedList<Integer>();\n\n\t\t\tint smp[] = new int[m + 2];\n\n\t\t\tArrays.fill(smp, c);\n\t\t\tsmp[m + 1] = 1000;\n\n\t\t\tint cost = 0;\n\t\t\tfor (int i = 0; i < sz; i++) {\n\n\t\t\t\t// get\n\t\t\t\tif (map[q[i]] == 0) {\n\t\t\t\t\tcost += m + 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (map[q[i]] == 1) {\n\t\t\t\t\t\tl.remove((Integer) q[i]);\n\t\t\t\t\t}\n\t\t\t\t\tcost += map[q[i]];\n\t\t\t\t\tsmp[map[q[i]]]++;\n\t\t\t\t}\n\n\t\t\t\tl.addFirst(q[i]);\n\t\t\t\tmap[q[i]] = 1;\n\n\t\t\t\tif (l.size() > c) { // swap\n\t\t\t\t\tint j = 2;\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (; smp[j] == 0; j++)\n\t\t\t\t\t\t;\n\t\t\t\t\tsmp[j]--;\n\n\t\t\t\t\tk = j;\n\t\t\t\t\tint v = l.pollLast();\n\n\t\t\t\t\tcost += k; // put k temp\n\n\t\t\t\t\tcost += 1; // remove 1\n\t\t\t\t\tfor (; smp[j] == 0; j++)\n\t\t\t\t\t\t;\n\t\t\t\t\tsmp[j]--;\n\n\t\t\t\t\tcost += j; // 1 to j\n\t\t\t\t\tmap[v] = j;\n\n\t\t\t\t\tcost += k; // k to 1;\n\t\t\t\t\tcost += 1;\n\t\t\t\t\t\n\t\t\t\t\tsmp[k]++;\n\t\t\t\t} else {\n\t\t\t\t\tcost += 1;\n\t\t\t\t}\n\t\t\t\t// return\n\t\t\t}\n\t\t\tSystem.out.println(cost);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ1258();\n\t}\n\t\n\tclass AOJ1258{\n\t\tfinal int INF=Integer.MAX_VALUE/4;\n\t\tAOJ1258(){\n\t\t\twhile(true){\n\t\t\t\tint M=sc.nextInt(),C=sc.nextInt(),N=sc.nextInt();\n\t\t\t\tif(((M|C)|N)==0)\tbreak;\n\t\t\t\tSystem.out.println(solve(M,C,N));\n\t\t\t}\n\t\t}\n\t\tint solve(int M,int C,int N){\n\t\t\tLinkedList<LinkedList<Integer>> q=new LinkedList<LinkedList<Integer>>();\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tq.add(new LinkedList<Integer>());\n\t\t\t\tint K=sc.nextInt();\n\t\t\t\tfor(int j=0; j<K; j++)\tq.getLast().add(sc.nextInt());\n\t\t\t}\n\t\t\tStore store=new Store(M,C);\n\t\t\tint ans=0;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint r=q.getFirst().poll();\n\t\t\t\tans+=store.take(r);\n\t\t\t\tans+=store.put(r);\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(store);\n\t\t\t\tif(q.getFirst().isEmpty())\tq.removeFirst();\n\t\t\t\telse\tq.addLast(q.poll());\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t\tclass Store{\n\t\t\tint M,C,time;\n\t\t\tArrayList<ArrayList<Book>> desks;\n\t\t\tStore(int m,int c){\n\t\t\t\tthis.M=m;\tthis.C=c;\tthis.time=0;\n\t\t\t\tdesks=new ArrayList<ArrayList<Book>>();\n\t\t\t\tfor(int i=0; i<M; i++)\tdesks.add(new ArrayList<Book>());\n\t\t\t}\n\t\t\tint take(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\t\tfor(int j=0; j<desks.get(i).size(); j++){\n\t\t\t\t\t\tif(desks.get(i).get(j).id==r){\n\t\t\t\t\t\t\tdesks.get(i).remove(j);\n\t\t\t\t\t\t\tret=i+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(ret<M+1)\tbreak;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tint put(int r){\n\t\t\t\tint ret=M+1;\n\t\t\t\tif(desks.get(0).size()<C){\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret=1;\n\t\t\t\t}else{\n\t\t\t\t\tret=0;\n\t\t\t\t\tPair tmpIdx=new Pair(M,0);\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\ttmpIdx.first=i;\n\t\t\t\t\t\t\tdesks.get(i).add(new Book(INF,INF));\n\t\t\t\t\t\t\ttmpIdx.second=desks.get(i).size()-1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tint oldestTime=desks.get(0).get(0).t,oldestIdx=0;\n\t\t\t\t\tfor(int i=1; i<desks.get(0).size(); i++){\n\t\t\t\t\t\tif(oldestTime>desks.get(0).get(i).t){\n\t\t\t\t\t\t\toldestTime=desks.get(0).get(i).t;\n\t\t\t\t\t\t\toldestIdx=i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tBook oldest=desks.get(0).remove(oldestIdx);\n\t\t\t\t\tret+=1;\n\t\t\t\t\tint empIdx=M;\n\t\t\t\t\tfor(int i=1; i<M; i++){\n\t\t\t\t\t\tif(desks.get(i).size()<C){\n\t\t\t\t\t\t\tdesks.get(i).add(oldest);\n\t\t\t\t\t\t\tempIdx=i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret+=empIdx+1;\n\t\t\t\t\tif(tmpIdx.first<M)\tdesks.get(tmpIdx.first).remove(tmpIdx.second);\n\t\t\t\t\tret+=tmpIdx.first+1;\n\t\t\t\t\tdesks.get(0).add(new Book(r,time++));\n\t\t\t\t\tret+=1;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public String toString(){return desks.toString();}\n\t\t}\n\t\tclass Book{\n\t\t\tint id,t;\n\t\t\tBook(int id,int t){this.id=id;this.t=t;}\n\t\t\t@Override public String toString(){return \"ID\"+id+\" T\"+t;}\n\t\t}\n\t\tclass Pair implements Comparable<Pair>{\n\t\t\tint first,second;\n\t\t\tPair(int first,int second){this.first=first; this.second=second;}\n\t\t\t@Override public String toString(){return \"(\"+first+\",\"+second+\")\";}\n\t\t\t@Override public int compareTo(Pair p){\n\t\t\t\tif(this.first<p.first)\treturn -1;\n\t\t\t\tif(this.first>p.first)\treturn 1;\n\t\t\t\tif(this.second<p.second)\treturn -1;\n\t\t\t\tif(this.second>p.second)\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\treturn 17+31*first+second;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(obj==null)\treturn false;\n\t\t\t\tif(this.getClass() != obj.getClass())\treturn false;\n\t\t\t\tPair p=(Pair)obj;\n\t\t\t\tif(this.first==p.first&&this.second==p.second)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ1262{\n\t\tfinal double INF=Double.MAX_VALUE/4.0;\n\t\tAOJ1262(){\n\t\t\twhile(true){\n\t\t\t\tint N=sc.nextInt();\n\t\t\t\tif(N==0)\tbreak;\n\t\t\t\tSystem.out.printf(\"%.4f\\n\",solve(N));\n\t\t\t}\n\t\t}\n\t\tdouble solve(int N){\n\t\t\tint[] a=new int[N+1];\n\t\t\tfor(int i=1; i<=N; i++)\ta[i]=sc.nextInt();\n\t\t\tdouble b=sc.nextDouble();\n\t\t\tint r=sc.nextInt();\n\t\t\tdouble v=sc.nextDouble(),e=sc.nextDouble(),f=sc.nextDouble();\n\t\t\tdouble[][] dp=new double[N+1][N+1];\n\t\t\tfor(int i=1; i<=N; i++)for(int j=0; j<=N; j++)dp[i][j]=INF;\n\t\t\t//flash(dp,N);\n\t\t\tdouble tmp=0.0;\n\t\t\tfor(int i=0; i<a[1]; i++)\ttmp+=exp(i,r,v,e,f);\n\t\t\tdp[1][0]=tmp;\n\t\t\tfor(int w=1; w<N; w++){\n\t\t\t\tfor(int h=0; h<w; h++){\n\t\t\t\t\tint d=a[w+1]-a[w],x=a[w]-a[h];\n\t\t\t\t\tdouble exp=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp+=exp(x++,r,v,e,f);\n\t\t\t\t\t//debug\n\t\t\t\t\t//System.out.println(exp);\n\t\t\t\t\tdp[w+1][h]=dp[w][h]+exp;\n\t\t\t\t\tdouble exp2=0.0;\n\t\t\t\t\tfor(int i=0; i<d; i++)\texp2+=exp(i,r,v,e,f);\n\t\t\t\t\tdp[w+1][w]=min(dp[w+1][w], dp[w][h]+exp2+b);\n\t\t\t\t}\n\t\t\t\t//debug\n\t\t\t\t//System.out.println(\"new \"+dp[w+1][w]);\n\t\t\t}\n\t\t\t//flash(dp,N);\n\t\t\tdouble ans=INF;\n\t\t\tfor(int i=0; i<=N; i++)\tans=min(ans,dp[N][i]);\n\t\t\treturn ans;\n\t\t}\n\t\tdouble exp(int x,double r,double v,double e,double f){\n\t\t\treturn x>=r?(1/(v-e*(x-r))):(1/(v-f*(r-x)));\n\t\t}\n\t\tvoid flash(double[][] dp,int N){\n\t\t\tfor(int y=0; y<=N; y++){\n\t\t\t\tfor(int x=0; x<=N; x++)\tSystem.out.printf(\"%3.3f \",dp[x][y]>=INF?-1:dp[x][y]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//0010 start\n\t//0051 sample match\n\tint m,c,n;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tm = sc.nextInt();\n\t\t\tc = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif((m|c|n) == 0) break;\n\t\t\tArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();\n\t\t\tArrayList<ArrayList<Integer>> store = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i = 0 ; i < m + 1; i++){\n\t\t\t\tstore.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tint maxk = 0;\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tmaxk = Math.max(maxk, k);\n\t\t\t\tlist.add(new ArrayList<Integer> ());\n\t\t\t\tfor(int j = 0 ; j < k; j++){\n\t\t\t\t\tint b = sc.nextInt();\n\t\t\t\t\tlist.get(i).add(b);\n\t\t\t\t\tstore.get(m).add(b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tint [] res = new int[10];\n\t\t\tfor(int i = 0 ; i < maxk; i++){\n\t\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\t\tif(list.get(j).size() <= i) continue;\n\t\t\t\t\tint num = list.get(j).get(i);\n\t\t\t\t\tres[0] = find(store, num);\n\t\t\t\t\tsum += res[0];\n\t\t\t\t\t\n\t\t\t\t\tres[1] = put(store, num);\n\t\t\t\t\tsum += res[1];\n\t\t\t\t\tif(res[1] != 1){\n\t\t\t\t\t\tint num2 = store.get(0).get(0);\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t\tres[2] = put(store, num2);\n\t\t\t\t\t\tsum += res[2];\n\t\t\t\t\t\tstore.get(0).remove(0);\n\t\t\t\t\t\t\n\t\t\t\t\t\tres[3] = find(store, num);\n\t\t\t\t\t\tsum += res[3];\n\t\t\t\t\t\tres[4] = put(store, num);\n\t\t\t\t\t\tsum += res[4];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tprivate int put(ArrayList<ArrayList<Integer>> store, int num) {\n\t\tfor(int i = 0 ; i < store.size(); i++){\n\t\t\tif(store.get(i).size() < c || i == store.size()-1){\n\t\t\t\tstore.get(i).add(num);\n\t\t\t\treturn i+1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tprivate int find(ArrayList<ArrayList<Integer>> store, int num) {\n\t\tfor(int i = 0 ; i < store.size(); i++){\n\t\t\tfor(int j = 0; j < store.get(i).size(); j++){\n\t\t\t\tif(store.get(i).get(j) == num){\n\t\t\t\t\tstore.get(i).remove(j);\n\t\t\t\t\treturn i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Book Replacement\npublic class Main{\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint m = sc.nextInt(), c = sc.nextInt(), n = sc.nextInt();\n\t\t\tif((m|c|n)==0)break;\n\t\t\tint[] k = new int[n];\n\t\t\tint[][] req = new int[n][50];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tk[i] = sc.nextInt();\n\t\t\t\tfor(int j=0;j<k[i];j++)req[i][j]=sc.nextInt();\n\t\t\t}\n\t\t\tQueue<Integer> D1 = new LinkedList<Integer>();\n\t\t\tSet<Integer>[] d = new Set[m+1];\n\t\t\tfor(int i=2;i<=m;i++)d[i]=new HashSet<Integer>();\n\t\t\tint res = 0;\n\t\t\tfor(int j=0;j<50;j++)for(int i=0;i<n;i++){\n\t\t\t\tif(k[i]<=j)continue;\n\t\t\t\tint r = req[i][j];\n\t\t\t\tif(D1.contains(r)){\n\t\t\t\t\tres += 2; D1.remove(r); D1.add(r);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tboolean shelf = true;\n\t\t\t\tfor(int a=2;a<=m;a++){\n\t\t\t\t\tif(d[a].contains(r)){\n\t\t\t\t\t\tshelf = false;\n\t\t\t\t\t\td[a].remove(r); res+=a;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(shelf)res+=m+1;\n\t\t\t\tif(D1.size()<c){\n\t\t\t\t\tres+=1; D1.add(r);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint pos = -1;\n\t\t\t\tfor(int a=2;a<=m;a++){\n\t\t\t\t\tif(d[a].size()<c){\n\t\t\t\t\t\tpos = a; res+=a; d[a].add(r); break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos==-1)res+=m+1;\n\t\t\t\tint old = D1.poll();\n\t\t\t\tres+=1;\n\t\t\t\tshelf = true;\n\t\t\t\tfor(int a=2;a<=m;a++){\n\t\t\t\t\tif(d[a].size()<c){\n\t\t\t\t\t\tshelf = false;\n\t\t\t\t\t\td[a].add(old); res+=a;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(shelf)res+=m+1;\n\t\t\t\tif(pos!=-1){\n\t\t\t\t\td[pos].remove(r); res+=pos;\n\t\t\t\t}\n\t\t\t\telse res+=m+1;\n\t\t\t\tD1.add(r); res+=1;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_B = 100\n\n### main\n\nloop do\n  m, c, n = gets.split.map(&:to_i)\n  break if (m | c | n) == 0\n\n  q = []\n  \n  n.times do\n    ki = gets.to_i\n    q << gets.split.map(&:to_i)\n  end\n  \n  books = MAX_B.times.map{m}\n  desks = m.times.map{[]} + [(1...MAX_B).to_a]\n\n  csum = 0\n\n  while ! q.empty?\n    reqs = q.shift\n    next if reqs.empty?\n\n    req = reqs.shift\n    q << reqs if ! reqs.empty?\n\n    pos = books[req]\n    desks[pos].delete(req)\n    csum += pos + 1\n\n    if desks[0].length < c\n      desks[0] << req\n      books[req] = 0\n      csum += 1\n    else\n      rpos = (1...m).find{|i| desks[i].length < c} || m\n      desks[rpos] << req\n      books[req] = rpos\n      csum += rpos + 1\n      \n      tbook = desks[0].shift\n      csum += 1\n\n      tpos = (1...m).find{|i| desks[i].length < c} || m\n      desks[tpos] << tbook\n      books[tbook] = tpos\n      csum += tpos + 1\n      \n      desks[rpos].delete(req)\n      csum += rpos + 1\n\n      desks[0] << req\n      books[req] = 0\n      csum += 1\n    end\n  end\n\n  p csum\nend"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from collections import deque\n    from sys import stdin\n    f_i = stdin\n    \n    ans = []\n    while True:\n        m, c, n = map(int, f_i.readline().split())\n        if m == 0:\n            break\n        \n        book_pos = dict()\n        studens = deque()\n        shelf = m + 1\n        \n        for i in range(n):\n            k = int(f_i.readline())\n            books = deque(map(int, f_i.readline().split()))\n            for b in books:\n                book_pos[b] = shelf\n            studens.append(books)\n        \n        desk = [0] * (m + 1) # number of books on the desk\n        D1 = deque()\n        cost = 0\n        \n        while studens:\n            s = studens.popleft()\n            b = s.popleft()\n            \n            # get the book\n            pos = book_pos[b]\n            cost += pos\n            if pos == 1:\n                D1.remove(b)\n            elif pos != shelf:\n                desk[pos] -= 1\n            \n            if len(D1) == c:\n                for i, cnt in enumerate(desk[2:], start=2):\n                    if cnt < c:\n                        # put the book on the i-th desk\n                        desk[i] += 1\n                        book_pos[b] = i\n                        cost += i\n                        b_pos = i\n                        break\n                else:\n                    # put the book on the shelf\n                    book_pos[b] = shelf\n                    cost += shelf\n                    b_pos = shelf\n                    \n                # get the unrequested book on D1\n                unrequested = D1.popleft()\n                cost += 1\n                \n                if b_pos == shelf:\n                    # put the unrequested book to the shelf\n                    book_pos[unrequested] = shelf\n                    cost += shelf\n                else:\n                    for i, cnt in enumerate(desk[b_pos:], start=b_pos):\n                        if cnt < c:\n                            # put the unrequested book to i-th desk\n                            desk[i] += 1\n                            book_pos[unrequested] = i\n                            cost += i\n                            break\n                    else:\n                        # put the unrequested book to the shelf\n                        book_pos[unrequested] = shelf\n                        cost += shelf\n                \n                # take the book from the temporary place to D1\n                if b_pos != shelf:\n                    desk[b_pos] -= 1\n                D1.append(b)\n                book_pos[b] = 1\n                cost += (b_pos + 1)\n            else:\n                # return the book to D1\n                D1.append(b)\n                book_pos[b] = 1\n                cost += 1\n            \n            if s:\n                studens.append(s)\n        \n        ans.append(cost)\n    \n    print('\\n'.join(map(str, ans)))\n\nsolve()\n"
  }
]