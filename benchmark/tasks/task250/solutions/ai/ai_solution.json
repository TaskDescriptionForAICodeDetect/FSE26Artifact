[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int* array;\n    int front;\n    int rear;\n    int capacity;\n} Queue;\n\nQueue* createQueue(int capacity) {\n    Queue* queue = (Queue*)malloc(sizeof(Queue));\n    queue->array = (int*)malloc(capacity * sizeof(int));\n    queue->front = 0;\n    queue->rear = -1;\n    queue->capacity = capacity;\n    return queue;\n}\n\nint isEmpty(Queue* queue) {\n    return queue->rear < queue->front;\n}\n\nvoid enqueue(Queue* queue, int item) {\n    if (queue->rear == queue->capacity - 1) {\n        return;\n    }\n    queue->array[++queue->rear] = item;\n}\n\nint dequeue(Queue* queue) {\n    if (isEmpty(queue)) {\n        return -1;\n    }\n    return queue->array[queue->front++];\n}\n\nint main() {\n    int dataset = 1;\n    while (1) {\n        int S, D, N;\n        scanf(\"%d %d %d\", &S, &D, &N);\n        if (S == 0 && D == 0 && N == 0) {\n            break;\n        }\n\n        Queue* queue = createQueue(N);\n        for (int i = 0; i < N; i++) {\n            int page;\n            scanf(\"%d\", &page);\n            enqueue(queue, page);\n        }\n\n        int* shelves = (int*)malloc((S + 1) * sizeof(int));\n        for (int i = 1; i <= S; i++) {\n            shelves[i] = 0;\n        }\n\n        int* desks = (int*)malloc((D + 1) * sizeof(int));\n        for (int i = 1; i <= D; i++) {\n            desks[i] = 0;\n        }\n\n        int total_cost = 0;\n\n        while (!isEmpty(queue)) {\n            int page = dequeue(queue);\n            int found = 0;\n\n            for (int i = 1; i <= D; i++) {\n                if (desks[i] == page) {\n                    found = 1;\n                    break;\n                }\n            }\n\n            if (found) {\n                total_cost += 1;\n                continue;\n            }\n\n            for (int i = 1; i <= S; i++) {\n                if (shelves[i] == page) {\n                    found = 1;\n                    break;\n                }\n            }\n\n            if (found) {\n                total_cost += 2;\n                int empty_desk = -1;\n                for (int i = 1; i <= D; i++) {\n                    if (desks[i] == 0) {\n                        empty_desk = i;\n                        break;\n                    }\n                }\n\n                if (empty_desk != -1) {\n                    desks[empty_desk] = page;\n                } else {\n                    for (int i = 1; i <= D; i++) {\n                        desks[i] = 0;\n                    }\n                    desks[1] = page;\n                }\n                continue;\n            }\n\n            total_cost += 3;\n            int empty_desk = -1;\n            for (int i = 1; i <= D; i++) {\n                if (desks[i] == 0) {\n                    empty_desk = i;\n                    break;\n                }\n            }\n\n            if (empty_desk != -1) {\n                desks[empty_desk] = page;\n            } else {\n                for (int i = 1; i <= D; i++) {\n                    desks[i] = 0;\n                }\n                desks[1] = page;\n            }\n        }\n\n        printf(\"Dataset %d: Total cost = %d\\n\", dataset++, total_cost);\n\n        free(shelves);\n        free(desks);\n        free(queue->array);\n        free(queue);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LibraryBookRequests {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            int n = scanner.nextInt(); // Number of requests\n            int k = scanner.nextInt(); // Desk capacity\n            int[] requests = new int[n];\n\n            for (int i = 0; i < n; i++) {\n                requests[i] = scanner.nextInt();\n            }\n\n            System.out.println(processRequests(n, k, requests));\n        }\n        scanner.close();\n    }\n\n    static int processRequests(int n, int k, int[] requests) {\n        Set<Integer> shelves = new HashSet<>();\n        Set<Integer> desks = new HashSet<>();\n        int totalCost = 0;\n\n        for (int request : requests) {\n            if (!shelves.contains(request)) {\n                if (shelves.size() < k) {\n                    shelves.add(request);\n                    totalCost += 1;\n                } else {\n                    if (!desks.contains(request)) {\n                        if (desks.size() < k) {\n                            desks.add(request);\n                            totalCost += 2;\n                        } else {\n                            desks.remove(desks.iterator().next());\n                            desks.add(request);\n                            totalCost += 2;\n                        }\n                    }\n                }\n            }\n        }\n\n        return totalCost;\n    }\n}",
    "timestamp": "2025-08-05 19:17:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\nusing namespace std;\n\nstruct Book {\n    int shelf_cost;\n    int desk_cost;\n    bool on_desk;\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n    while (T--) {\n        int N, M, K;\n        cin >> N >> M >> K;\n\n        vector<Book> books(N + 1);\n        for (int i = 1; i <= N; ++i) {\n            cin >> books[i].shelf_cost >> books[i].desk_cost;\n            books[i].on_desk = false;\n        }\n\n        queue<int> requests;\n        for (int i = 0; i < K; ++i) {\n            int r;\n            cin >> r;\n            requests.push(r);\n        }\n\n        unordered_map<int, int> desk_books;\n        int total_cost = 0;\n        int desk_space = M;\n\n        while (!requests.empty()) {\n            int book = requests.front();\n            requests.pop();\n\n            if (books[book].on_desk) {\n                total_cost += books[book].desk_cost;\n                continue;\n            }\n\n            total_cost += books[book].shelf_cost;\n\n            if (desk_space > 0) {\n                books[book].on_desk = true;\n                desk_books[book]++;\n                desk_space--;\n            } else {\n                auto it = desk_books.begin();\n                int evict = it->first;\n                books[evict].on_desk = false;\n                desk_books.erase(it);\n                books[book].on_desk = true;\n                desk_books[book]++;\n            }\n        }\n\n        cout << total_cost << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_STUDENTS 100000\n#define MAX_DESKS 100\n\ntypedef struct {\n    int student_id;\n    int book_id;\n} Request;\n\ntypedef struct {\n    int book_id;\n    int desk_location;\n} BookLocation;\n\nint main() {\n    int num_datasets, num_students, num_desks, num_shelves;\n    scanf(\"%d\", &num_datasets);\n\n    for (int dataset = 1; dataset <= num_datasets; dataset++) {\n        scanf(\"%d %d %d\", &num_students, &num_desks, &num_shelves);\n\n        Request requests[MAX_STUDENTS];\n        BookLocation desk_books[MAX_DESKS];\n        int shelf_books[MAX_SHELVES];\n        int desk_count = 0, shelf_count = 0;\n        int total_cost = 0;\n\n        for (int i = 0; i < num_desks; i++) {\n            desk_books[i].book_id = -1;\n        }\n\n        for (int i = 0; i < num_shelves; i++) {\n            shelf_books[i] = -1;\n        }\n\n        for (int i = 0; i < num_students; i++) {\n            scanf(\"%d %d\", &requests[i].student_id, &requests[i].book_id);\n        }\n\n        for (int i = 0; i < num_students; i++) {\n            int current_book = requests[i].book_id;\n            int found_on_desk = 0;\n\n            for (int j = 0; j < num_desks; j++) {\n                if (desk_books[j].book_id == current_book) {\n                    total_cost += 1;\n                    found_on_desk = 1;\n                    break;\n                }\n            }\n\n            if (!found_on_desk) {\n                int found_on_shelf = 0;\n                for (int j = 0; j < num_shelves; j++) {\n                    if (shelf_books[j] == current_book) {\n                        total_cost += 11;\n                        found_on_shelf = 1;\n\n                        if (desk_count < num_desks) {\n                            desk_books[desk_count].book_id = current_book;\n                            desk_books[desk_count].desk_location = desk_count;\n                            desk_count++;\n                        } else {\n                            int replace_index = 0;\n                            for (int k = 1; k < num_desks; k++) {\n                                if (desk_books[k].desk_location < desk_books[replace_index].desk_location) {\n                                    replace_index = k;\n                                }\n                            }\n                            desk_books[replace_index].book_id = current_book;\n                            desk_books[replace_index].desk_location = num_desks;\n                        }\n                        break;\n                    }\n                }\n\n                if (!found_on_shelf) {\n                    total_cost += 51;\n\n                    if (desk_count < num_desks) {\n                        desk_books[desk_count].book_id = current_book;\n                        desk_books[desk_count].desk_location = desk_count;\n                        desk_count++;\n                    } else {\n                        int replace_index = 0;\n                        for (int k = 1; k < num_desks; k++) {\n                            if (desk_books[k].desk_location < desk_books[replace_index].desk_location) {\n                                replace_index = k;\n                            }\n                        }\n                        desk_books[replace_index].book_id = current_book;\n                        desk_books[replace_index].desk_location = num_desks;\n                    }\n\n                    if (shelf_count < num_shelves) {\n                        shelf_books[shelf_count] = current_book;\n                        shelf_count++;\n                    } else {\n                        int replace_index = 0;\n                        for (int k = 1; k < num_shelves; k++) {\n                            if (shelf_books[k] < shelf_books[replace_index]) {\n                                replace_index = k;\n                            }\n                        }\n                        shelf_books[replace_index] = current_book;\n                    }\n                }\n            }\n        }\n\n        printf(\"%d\\n\", total_cost);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <climits>\n\nusing namespace std;\n\nclass Library {\nprivate:\n    int desk_capacity;\n    int shelf_access_cost;\n    int desk_access_cost;\n    unordered_set<int> desk_books;\n    unordered_set<int> shelf_books;\n\npublic:\n    Library(int desk_max, int shelf_cost, int desk_cost) : \n        desk_capacity(desk_max), \n        shelf_access_cost(shelf_cost), \n        desk_access_cost(desk_cost) {}\n\n    int process_requests(vector<int>& requests) {\n        int total_cost = 0;\n\n        for (int book : requests) {\n            if (desk_books.count(book)) {\n                total_cost += desk_access_cost;\n                continue;\n            }\n\n            if (shelf_books.count(book)) {\n                total_cost += shelf_access_cost;\n\n                if (desk_books.size() < desk_capacity) {\n                    desk_books.insert(book);\n                } else {\n                    desk_books.erase(desk_books.begin());\n                    desk_books.insert(book);\n                }\n                continue;\n            }\n\n            total_cost += shelf_access_cost;\n            shelf_books.insert(book);\n\n            if (desk_books.size() < desk_capacity) {\n                desk_books.insert(book);\n            } else {\n                desk_books.erase(desk_books.begin());\n                desk_books.insert(book);\n            }\n        }\n\n        return total_cost;\n    }\n};\n\nint main() {\n    int datasets;\n    cin >> datasets;\n\n    while (datasets--) {\n        int desk_max, shelf_cost, desk_cost, request_count;\n        cin >> desk_max >> shelf_cost >> desk_cost >> request_count;\n\n        vector<int> requests(request_count);\n        for (int i = 0; i < request_count; i++) {\n            cin >> requests[i];\n        }\n\n        Library library(desk_max, shelf_cost, desk_cost);\n        cout << library.process_requests(requests) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Book {\n    String name;\n    boolean isOnDesk;\n\n    public Book(String name, boolean isOnDesk) {\n        this.name = name;\n        this.isOnDesk = isOnDesk;\n    }\n}\n\npublic class LibrarySimulation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n\n        for (int d = 0; d < datasets; d++) {\n            int numBooks = scanner.nextInt();\n            int numStudents = scanner.nextInt();\n            int deskCapacity = scanner.nextInt();\n            scanner.nextLine(); // consume newline\n\n            Map<String, Book> books = new HashMap<>();\n            Queue<String> studentQueue = new LinkedList<>();\n\n            // Read books on desk\n            for (int i = 0; i < deskCapacity; i++) {\n                String bookName = scanner.nextLine();\n                books.put(bookName, new Book(bookName, true));\n            }\n\n            // Read books on shelf\n            for (int i = deskCapacity; i < numBooks; i++) {\n                String bookName = scanner.nextLine();\n                books.put(bookName, new Book(bookName, false));\n            }\n\n            // Read student requests\n            for (int i = 0; i < numStudents; i++) {\n                String bookName = scanner.nextLine();\n                studentQueue.add(bookName);\n            }\n\n            int totalCost = 0;\n            List<String> deskBooks = new ArrayList<>(deskCapacity);\n\n            // Initialize desk books\n            for (Book book : books.values()) {\n                if (book.isOnDesk) {\n                    deskBooks.add(book.name);\n                }\n            }\n\n            while (!studentQueue.isEmpty()) {\n                String requestedBook = studentQueue.poll();\n                Book book = books.get(requestedBook);\n\n                if (book.isOnDesk) {\n                    totalCost += 1;\n                    // Move to front (no actual movement, just cost)\n                    deskBooks.remove(requestedBook);\n                    deskBooks.add(0, requestedBook);\n                } else {\n                    totalCost += 2 * numBooks; // Cost to fetch from shelf\n                    if (deskBooks.size() >= deskCapacity) {\n                        String removedBook = deskBooks.remove(deskBooks.size() - 1);\n                        books.get(removedBook).isOnDesk = false;\n                    }\n                    deskBooks.add(0, requestedBook);\n                    book.isOnDesk = true;\n                }\n            }\n\n            System.out.println(totalCost);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 19:18:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_total_cost(datasets):\n    results = []\n    for dataset in datasets:\n        desk_capacity, shelf_cost, desk_cost, requests = dataset\n        \n        desk_stack = []\n        total_cost = 0\n        \n        for request in requests:\n            if request in desk_stack:\n                total_cost += desk_cost\n                desk_stack.remove(request)\n                desk_stack.append(request)\n            else:\n                if len(desk_stack) >= desk_capacity:\n                    desk_stack.pop(0)\n                \n                if request in desk_stack:\n                    total_cost += desk_cost\n                else:\n                    total_cost += shelf_cost\n                desk_stack.append(request)\n        \n        results.append(total_cost)\n    return results\n\n# Example usage: \ndatasets = [\n    (2, 10, 5, [1, 2, 3, 2, 1, 5]),\n    (3, 8, 3, [4, 4, 4, 6, 7, 5, 8, 7])\n]\n\nprint(calculate_total_cost(datasets))",
    "timestamp": "2025-08-13 03:25:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class LibrarySimulation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numDataSets = scanner.nextInt();\n        \n        for (int i = 0; i < numDataSets; i++) {\n            int deskCapacity = scanner.nextInt();\n            int shelfAccessCost = scanner.nextInt();\n            int deskAccessCost = scanner.nextInt();\n            int numRequests = scanner.nextInt();\n            \n            Queue<Integer> requests = new LinkedList<>();\n            for (int j = 0; j < numRequests; j++) {\n                requests.add(scanner.nextInt());\n            }\n            \n            Set<Integer> desk = new LinkedHashSet<>();\n            int totalCost = 0;\n            \n            while (!requests.isEmpty()) {\n                int currentRequest = requests.poll();\n                if (desk.contains(currentRequest)) {\n                    totalCost += deskAccessCost;\n                } else {\n                    totalCost += shelfAccessCost;\n                    if (desk.size() >= deskCapacity) {\n                        Iterator<Integer> it = desk.iterator();\n                        if (it.hasNext()) {\n                            it.next();\n                            it.remove();\n                        }\n                    }\n                    desk.add(currentRequest);\n                }\n            }\n            \n            System.out.println(totalCost);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 03:25:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_CAPACITY 100\n\ntypedef struct {\n    int bookID;\n    int isOnDesk; // 0: on shelf, 1: on desk\n} Book;\n\ntypedef struct {\n    Book books[MAX_CAPACITY];\n    int capacity;\n    int top;\n} Desk;\n\nDesk desk;\nint shelfAccessCost, deskAccessCost;\nint totalCost = 0;\n\nvoid initDesk(int capacity) {\n    desk.capacity = capacity;\n    desk.top = 0;\n}\n\nvoid processRequest(int bookID) {\n    int foundOnDesk = 0;\n    int foundIndex = -1;\n\n    for (int i = 0; i < desk.top; i++) {\n        if (desk.books[i].bookID == bookID) {\n            foundOnDesk = 1;\n            foundIndex = i;\n            break;\n        }\n    }\n\n    if (foundOnDesk) {\n        totalCost += deskAccessCost;\n    } else {\n        totalCost += shelfAccessCost;\n        if (desk.top < desk.capacity) {\n            desk.books[desk.top].bookID = bookID;\n            desk.books[desk.top].isOnDesk = 1;\n            desk.top++;\n        } else {\n            desk.books[foundIndex].bookID = bookID;\n        }\n    }\n}\n\nint main() {\n    int numDataSets;\n    scanf(\"%d\", &numDataSets);\n    \n    for (int k = 0; k < numDataSets; k++) {\n        int numRequests, deskCapacity;\n        \n        scanf(\"%d %d %d %d\", &numRequests, &deskCapacity, &shelfAccessCost, &deskAccessCost);\n        initDesk(deskCapacity);\n        \n        totalCost = 0;\n        \n        for (int i = 0; i < numRequests; i++) {\n            int bookID;\n            scanf(\"%d\", &bookID);\n            processRequest(bookID);\n        }\n        \n        printf(\"Total cost for dataset %d: %d\\n\", k + 1, totalCost);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 03:25:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_library_requests(datasets):\n    result = []\n    \n    for dataset in datasets:\n        n, m = dataset[0]\n        requests = dataset[1:]\n        \n        desk_space = 0\n        shelf_space = 0\n        total_cost = 0\n        \n        for request in requests:\n            student, pages = request\n            \n            # Calculate cost for desk and shelf\n            desk_cost = min(desk_space, pages)\n            shelf_cost = max(0, pages - desk_space)\n            \n            # Update desk and shelf space\n            desk_space = min(m, desk_space + pages)\n            shelf_space = max(0, shelf_space - pages)\n            \n            # Calculate total cost for this request\n            total_cost += desk_cost + 2 * shelf_cost\n        \n        result.append(total_cost)\n    \n    return result\n\n# Input parsing and processing\ndef main():\n    t = int(input())\n    datasets = []\n    \n    for _ in range(t):\n        n, m = map(int, input().split())\n        dataset = [(n, m)]\n        \n        for _ in range(n):\n            student, pages = map(int, input().split())\n            dataset.append((student, pages))\n        \n        datasets.append(dataset)\n    \n    costs = solve_library_requests(datasets)\n    \n    for cost in costs:\n        print(cost)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:25:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    T = int(input[ptr])\n    ptr += 1\n    for _ in range(T):\n        N, M, S, D = map(int, input[ptr:ptr+4])\n        ptr +=4\n        requests = list(map(int, input[ptr:ptr+N]))\n        ptr +=N\n        \n        shelf_cost = S\n        desk_cost = D\n        \n        desk = set()\n        total_cost = 0\n        \n        for page in requests:\n            if page in desk:\n                total_cost += desk_cost\n            else:\n                total_cost += shelf_cost\n                if len(desk) >= M:\n                    desk.pop()\n                desk.add(page)\n        print(total_cost)\n\nsolve()",
    "timestamp": "2025-08-13 03:25:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int numDatasets;\n    cin >> numDatasets;\n\n    while (numDatasets--) {\n        int deskCapacity, shelfCost, deskCost, numRequests;\n        cin >> deskCapacity >> shelfCost >> deskCost >> numRequests;\n\n        queue<int> requestQueue;\n        for (int i = 0; i < numRequests; ++i) {\n            int request;\n            cin >> request;\n            requestQueue.push(request);\n        }\n\n        unordered_map<int, bool> deskMap;\n        queue<int> deskQueue;\n\n        long long totalCost = 0;\n\n        while (!requestQueue.empty()) {\n            int currentPage = requestQueue.front();\n            requestQueue.pop();\n\n            if (deskMap.find(currentPage) != deskMap.end() && deskMap[currentPage]) {\n                totalCost += deskCost; // Access desk\n            } else {\n                totalCost += shelfCost; // Access shelf\n\n                if (deskQueue.size() >= deskCapacity) {\n                    int removedPage = deskQueue.front();\n                    deskQueue.pop();\n                    deskMap.erase(removedPage);\n                }\n\n                deskQueue.push(currentPage);\n                deskMap[currentPage] = true;\n            }\n        }\n\n        cout << totalCost << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:11:43"
  }
]