[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int A, B, C, D, E, F;\n    scanf(\"%d %d %d %d %d %d\", &A, &B, &C, &D, &E, &F);\n\n    int max_total_mass = 0, max_sugar_mass = 0;\n\n    for (int water_a = 0; water_a <= F / (100 * A); water_a++) {\n        for (int water_b = 0; water_b <= (F - water_a * 100 * A) / (100 * B); water_b++) {\n            int current_water_mass = water_a * 100 * A + water_b * 100 * B;\n            int max_dissolvable_sugar = current_water_mass * E / 100;\n\n            for (int sugar_c = 0; sugar_c <= max_dissolvable_sugar && sugar_c <= C; sugar_c++) {\n                for (int sugar_d = 0; sugar_d <= max_dissolvable_sugar - sugar_c && sugar_d <= D; sugar_d++) {\n                    int total_sugar_mass = sugar_c + sugar_d;\n                    int total_mass = current_water_mass + total_sugar_mass;\n\n                    if (total_mass <= F && total_sugar_mass <= max_dissolvable_sugar) {\n                        if (total_sugar_mass > max_sugar_mass || \n                            (total_sugar_mass == max_sugar_mass && total_mass > max_total_mass)) {\n                            max_total_mass = total_mass;\n                            max_sugar_mass = total_sugar_mass;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", max_total_mass, max_sugar_mass);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\nint main() {\n    int A, B, C, D, E, F;\n    scanf(\"%d %d %d %d %d %d\", &A, &B, &C, &D, &E, &F);\n\n    int max_sugar = 0;\n    int max_total = 0;\n    double max_density = -1.0;\n\n    for (int a = 0; a <= F / (100 * A); ++a) {\n        for (int b = 0; b <= (F - 100 * a * A) / (100 * B); ++b) {\n            int water = 100 * (a * A + b * B);\n            if (water == 0) continue;\n            int max_sugar_possible = water * E / 100;\n            for (int c = 0; c <= max_sugar_possible / C; ++c) {\n                for (int d = 0; d <= (max_sugar_possible - c * C) / D; ++d) {\n                    int sugar = c * C + d * D;\n                    int total = water + sugar;\n                    if (total > F) continue;\n                    if (sugar > max_sugar_possible) continue;\n                    if (total == 0) continue;\n                    double density = (100.0 * sugar) / total;\n                    if (density > max_density) {\n                        max_density = density;\n                        max_total = total;\n                        max_sugar = sugar;\n                    }\n                }\n            }\n        }\n    }\n\n    if (max_total == 0) {\n        max_total = 100 * A;\n    }\n    printf(\"%d %d\\n\", max_total, max_sugar);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int A, B, C, D, E, F;\n    cin >> A >> B >> C >> D >> E >> F;\n\n    vector<bool> water_possible(F + 1, false);\n    water_possible[0] = true;\n    for (int i = 0; i <= F; ++i) {\n        if (water_possible[i]) {\n            if (i + 100 * A <= F) water_possible[i + 100 * A] = true;\n            if (i + 100 * B <= F) water_possible[i + 100 * B] = true;\n        }\n    }\n\n    vector<bool> sugar_possible(F + 1, false);\n    sugar_possible[0] = true;\n    for (int i = 0; i <= F; ++i) {\n        if (sugar_possible[i]) {\n            if (i + C <= F) sugar_possible[i + C] = true;\n            if (i + D <= F) sugar_possible[i + D] = true;\n        }\n    }\n\n    int max_water = 0;\n    int max_sugar = 0;\n    double max_density = -1.0;\n\n    for (int water = 100; water <= F; water += 100) {\n        if (!water_possible[water]) continue;\n        int max_sugar_possible = min(E * water / 100, F - water);\n        for (int sugar = 0; sugar <= max_sugar_possible; ++sugar) {\n            if (!sugar_possible[sugar]) continue;\n            if (water + sugar == 0) continue;\n            double density = 100.0 * sugar / (water + sugar);\n            if (density > max_density) {\n                max_density = density;\n                max_water = water;\n                max_sugar = sugar;\n            }\n        }\n    }\n\n    cout << max_water + max_sugar << \" \" << max_sugar << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n        int D = scanner.nextInt();\n        int E = scanner.nextInt();\n        int F = scanner.nextInt();\n\n        int maxWater = 0;\n        int maxSugar = 0;\n        double maxDensity = -1;\n\n        for (int a = 0; 100 * A * a <= F; a++) {\n            for (int b = 0; 100 * A * a + 100 * B * b <= F; b++) {\n                int water = 100 * A * a + 100 * B * b;\n                if (water == 0) continue;\n\n                int maxSugarPossible = Math.min(F - water, water * E / 100);\n                for (int c = 0; c * C <= maxSugarPossible; c++) {\n                    for (int d = 0; c * C + d * D <= maxSugarPossible; d++) {\n                        int sugar = c * C + d * D;\n                        double density = (100.0 * sugar) / (water + sugar);\n                        if (density > maxDensity) {\n                            maxDensity = density;\n                            maxWater = water;\n                            maxSugar = sugar;\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println((maxWater + maxSugar) + \" \" + maxSugar);\n    }\n}",
    "timestamp": "2025-08-05 23:15:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SugarWater {\n    public static void solve(int A, int B, int C, int D, int E, int F) {\n        int maxMass = 0;\n        int maxSugar = 0;\n\n        for (int a = 0; a <= F / (100 * A); a++) {\n            for (int b = 0; b <= F / (100 * B); b++) {\n                int waterMass = 100 * A * a + 100 * B * b;\n                if (waterMass > F) break;\n\n                int maxSugarPossible = waterMass * E / 100;\n                for (int c = 0; c <= (F - waterMass) / C; c++) {\n                    for (int d = 0; d <= (F - waterMass) / D; d++) {\n                        int sugarMass = C * c + D * d;\n                        \n                        if (sugarMass <= maxSugarPossible && \n                            waterMass + sugarMass <= F) {\n                            if (waterMass + sugarMass > maxMass) {\n                                maxMass = waterMass + sugarMass;\n                                maxSugar = sugarMass;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(maxMass + \" \" + maxSugar);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        int C = sc.nextInt();\n        int D = sc.nextInt();\n        int E = sc.nextInt();\n        int F = sc.nextInt();\n        solve(A, B, C, D, E, F);\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 23:15:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int A, B, C, D, E, F;\n    cin >> A >> B >> C >> D >> E >> F;\n\n    int max_total_mass = 0;\n    int max_sugar_mass = 0;\n\n    for (int water_a = 0; water_a * 100 <= F; water_a++) {\n        for (int water_b = 0; water_a * 100 + water_b * 100 <= F; water_b++) {\n            int total_water_mass = water_a * 100 * A + water_b * 100 * B;\n\n            if (total_water_mass == 0) continue;\n\n            int max_dissolve_sugar = total_water_mass / 100 * E;\n\n            for (int sugar_c = 0; sugar_c <= max_dissolve_sugar; sugar_c += C) {\n                for (int sugar_d = 0; sugar_d <= max_dissolve_sugar - sugar_c; sugar_d += D) {\n                    int total_sugar_mass = sugar_c + sugar_d;\n\n                    if (total_water_mass + total_sugar_mass <= F && total_sugar_mass <= max_dissolve_sugar) {\n                        if (total_sugar_mass > max_sugar_mass || \n                            (total_sugar_mass == max_sugar_mass && \n                             total_water_mass + total_sugar_mass > max_total_mass)) {\n                            max_total_mass = total_water_mass + total_sugar_mass;\n                            max_sugar_mass = total_sugar_mass;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    cout << max_total_mass << \" \" << max_sugar_mass << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:15:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def make_sugar_water(A, B, C, D, E, F):\n    max_sugar = max_density = 0\n    max_sugar_water = 0\n\n    for water_a in range(F // (100 * A) + 1):\n        for water_b in range((F - 100 * A * water_a) // (100 * B) + 1):\n            water = 100 * A * water_a + 100 * B * water_b\n\n            if water == 0:\n                continue\n\n            max_possible_sugar = min((water // 100) * E, F - water)\n\n            for sugar_c in range(max_possible_sugar // C + 1):\n                for sugar_d in range((max_possible_sugar - C * sugar_c) // D + 1):\n                    sugar = C * sugar_c + D * sugar_d\n\n                    if sugar > max_possible_sugar:\n                        continue\n\n                    total_mass = water + sugar\n                    if total_mass > F:\n                        continue\n\n                    if sugar * max_density <= max_sugar * water:\n                        max_sugar = sugar\n                        max_sugar_water = total_mass\n                        max_density = sugar / water\n\n    return max_sugar_water, max_sugar\n\n# Example usage\nA, B, C, D, E, F = 1, 1, 1, 1, 1, 2000\nprint(make_sugar_water(A, B, C, D, E, F))",
    "timestamp": "2025-08-13 14:17:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SnukeSugarWater {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read input values\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int C = scanner.nextInt();\n        int D = scanner.nextInt();\n        int E = scanner.nextInt();\n        int F = scanner.nextInt();\n\n        int maxSugarWater = 0;\n        int maxSugar = 0;\n\n        // Iterate over possible combinations of water\n        for (int waterA = 0; waterA <= F / (100 * A); waterA++) {\n            for (int waterB = 0; waterB <= F / (100 * B); waterB++) {\n                int water = 100 * A * waterA + 100 * B * waterB;\n                if (water == 0 || water > F) continue;\n                \n                // Calculate maximum sugar that can dissolve\n                int maxDissolvableSugar = (water / 100) * E;\n                for (int sugarC = 0; sugarC <= F / C; sugarC++) {\n                    for (int sugarD = 0; sugarD <= F / D; sugarD++) {\n                        int sugar = C * sugarC + D * sugarD;\n                        int total = water + sugar;\n                        \n                        if (sugar <= maxDissolvableSugar && total <= F && sugar > maxSugar) {\n                            maxSugarWater = total;\n                            maxSugar = sugar;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Output the result\n        System.out.println(maxSugarWater + \" \" + maxSugar);\n    }\n}",
    "timestamp": "2025-08-13 14:17:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint main() {\n    int A, B, C, D, E, F;\n    scanf(\"%d %d %d %d %d %d\", &A, &B, &C, &D, &E, &F);\n\n    int max_water = F / 100 * 100;\n    int max_sugar = (max_water * E) / 100;\n    int best_total_mass = 0;\n    int best_sugar_mass = 0;\n\n    for (int waterA = 0; waterA <= F / (100 * A); ++waterA) {\n        for (int waterB = 0; waterB <= (F - 100 * A * waterA) / (100 * B); ++waterB) {\n            int water_mass = 100 * A * waterA + 100 * B * waterB;\n            if (water_mass > max_water) continue;\n\n            int max_sugar_available = (water_mass * E) / 100;\n            if (water_mass + max_sugar_available > F) continue;\n\n            for (int sugarC = 0; sugarC <= F / C; ++sugarC) {\n                for (int sugarD = 0; sugarD <= (F - sugarC * C) / D; ++sugarD) {\n                    int sugar_mass = sugarC * C + sugarD * D;\n\n                    if (water_mass + sugar_mass > F || sugar_mass > max_sugar_available) continue;\n\n                    int total_mass = water_mass + sugar_mass;\n                    if (sugar_mass * best_total_mass > best_sugar_mass * total_mass) {\n                        best_sugar_mass = sugar_mass;\n                        best_total_mass = total_mass;\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", best_total_mass, best_sugar_mass);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:17:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function makeSugarWater(A, B, C, D, E, F) {\n    let maxSugarWater = 0;\n    let maxSugar = 0;\n\n    for (let wa = 0; wa <= Math.floor(F / (100 * A)); wa++) {\n        for (let wb = 0; wb <= Math.floor(F / (100 * B)); wb++) {\n            let waterMass = 100 * A * wa + 100 * B * wb;\n            if (waterMass > F) continue;\n            \n            let maxSugarForWater = Math.floor(waterMass * E / 100);\n\n            for (let sc = 0; sc <= Math.floor(F / C); sc++) {\n                for (let sd = 0; sd <= Math.floor(F / D); sd++) {\n                    let sugarMass = C * sc + D * sd;\n                    let totalMass = waterMass + sugarMass;\n                    \n                    if (totalMass <= F && sugarMass <= maxSugarForWater) {\n                        if (totalMass > 0 && (sugarMass / totalMass) > (maxSugar / maxSugarWater)) {\n                            maxSugarWater = totalMass;\n                            maxSugar = sugarMass;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return [maxSugarWater, maxSugar];\n}",
    "timestamp": "2025-08-13 14:17:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_sugar_water(A, B, C, D, E, F):\n    max_total = 0\n    max_sugar = 0\n    \n    for water_amount in range(0, F + 1, min(100 * A, 100 * B)):\n        max_dissolve_sugar = water_amount * E / 100\n        \n        for sugar_amount in range(0, min(max_dissolve_sugar + max(C, D), F - water_amount + 1)):\n            if sugar_amount <= max_dissolve_sugar:\n                total_mass = water_amount + sugar_amount\n                if total_mass <= F and total_mass > max_total:\n                    max_total = total_mass\n                    max_sugar = sugar_amount\n    \n    return max_total, max_sugar\n\n# Example usage\n# print(solve_sugar_water(1, 2, 3, 4, 5, 1000))",
    "timestamp": "2025-08-13 14:17:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxSugarWater(A, B, C, D, E, F) {\n    let maxSugar = 0;\n    let maxTotal = 0;\n\n    for (let water = 0; water <= F / 100; water++) {\n        for (let waterType of [A, B]) {\n            let currentWater = water * 100 * waterType;\n            \n            if (currentWater > F) break;\n\n            let maxDissolvedSugar = Math.min(\n                Math.floor(currentWater * E / 100),\n                C + D\n            );\n\n            for (let sugarType of [C, D]) {\n                let sugar = Math.min(maxDissolvedSugar, sugarType);\n                \n                if (currentWater + sugar > F) continue;\n\n                let density = sugar / (currentWater + sugar);\n                \n                if (sugar > maxSugar || (sugar === maxSugar && currentWater + sugar > maxTotal)) {\n                    maxSugar = sugar;\n                    maxTotal = currentWater + sugar;\n                }\n            }\n        }\n    }\n\n    return [maxTotal, maxSugar];\n}",
    "timestamp": "2025-08-13 14:18:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "A, B, C, D, E, F = map(int, input().split())\n\nmax_sugar = 0\nmax_total = 100 * A\nmax_density = 0.0\n\n# Possible water amounts (in 100 grams units)\nmax_water = F // 100\nwater_options = set()\nfor a in range(max_water // A + 1):\n    for b in range((max_water - a * A) // B + 1):\n        water = 100 * (a * A + b * B)\n        if 0 < water <= F:\n            water_options.add(water)\n\nfor water in water_options:\n    max_possible_sugar = min(F - water, (water // 100) * E)\n    # Possible sugar amounts\n    max_c = max_possible_sugar // C\n    max_d = max_possible_sugar // D\n    best_sugar = 0\n    for c in range(max_c + 1):\n        remaining = max_possible_sugar - c * C\n        d = remaining // D\n        sugar = c * C + d * D\n        if sugar > best_sugar and sugar <= max_possible_sugar:\n            best_sugar = sugar\n    total = water + best_sugar\n    if total == 0:\n        continue\n    density = 100 * best_sugar / total\n    if density >= max_density and total <= F:\n        if density > max_density or (density == max_density and total > max_total):\n            max_density = density\n            max_sugar = best_sugar\n            max_total = total\n\nprint(max_total, max_sugar)",
    "timestamp": "2025-08-13 14:18:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split(' ');\n    const A = parseInt(input[0], 10);\n    const B = parseInt(input[1], 10);\n    const C = parseInt(input[2], 10);\n    const D = parseInt(input[3], 10);\n    const E = parseInt(input[4], 10);\n    const F = parseInt(input[5], 10);\n\n    let maxDensity = -1;\n    let totalSugar = 0;\n    let totalWater = 0;\n\n    const maxWater = Math.floor(F / (100 * A));\n    for (let a = 0; a <= maxWater; a++) {\n        const waterA = 100 * A * a;\n        if (waterA > F) break;\n        const maxB = Math.floor((F - waterA) / (100 * B));\n        for (let b = 0; b <= maxB; b++) {\n            const waterB = 100 * B * b;\n            const totalW = waterA + waterB;\n            if (totalW === 0) continue;\n            if (totalW > F) break;\n\n            const maxSugar = Math.min(F - totalW, Math.floor(totalW * E / 100));\n            const maxC = Math.floor(maxSugar / C);\n            for (let c = 0; c <= maxC; c++) {\n                const sugarC = C * c;\n                if (sugarC > maxSugar) break;\n                const maxD = Math.floor((maxSugar - sugarC) / D);\n                for (let d = 0; d <= maxD; d++) {\n                    const sugarD = D * d;\n                    const totalS = sugarC + sugarD;\n                    if (totalS > maxSugar) break;\n                    if (totalS + totalW > F) break;\n\n                    const density = (100 * totalS) / (totalS + totalW);\n                    if (density > maxDensity) {\n                        maxDensity = density;\n                        totalSugar = totalS;\n                        totalWater = totalW;\n                    }\n                }\n            }\n        }\n    }\n\n    console.log((totalWater + totalSugar) + ' ' + totalSugar);\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:18:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Solution {\n    int totalMass;\n    int sugarMass;\n    double density;\n};\n\nint main() {\n    int A, B, C, D, E, F;\n    cin >> A >> B >> C >> D >> E >> F;\n\n    vector<Solution> candidates;\n\n    for (int waterA = 0; 100 * waterA <= F; waterA++) {\n        for (int waterB = 0; 100 * waterA + 100 * waterB <= F; waterB++) {\n            int totalWater = 100 * waterA + 100 * waterB;\n\n            for (int sugarC = 0; sugarC <= totalWater * E / 100; sugarC++) {\n                for (int sugarD = 0; sugarC + sugarD <= totalWater * E / 100; sugarD++) {\n                    int totalSugar = sugarC * C + sugarD * D;\n\n                    if (totalWater + totalSugar > F) continue;\n\n                    int totalMass = totalWater + totalSugar;\n                    double density = (double)totalSugar / totalMass * 100.0;\n\n                    candidates.push_back({totalMass, totalSugar, density});\n                }\n            }\n        }\n    }\n\n    auto bestSolution = max_element(candidates.begin(), candidates.end(),\n                                    [](const Solution &a, const Solution &b) {\n                                        return a.density < b.density;\n                                    });\n\n    cout << bestSolution->totalMass << \" \" << bestSolution->sugarMass << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:43:03"
  }
]