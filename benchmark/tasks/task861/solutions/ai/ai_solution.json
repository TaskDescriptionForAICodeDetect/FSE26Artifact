[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 50\n#define INF 1000000\n\nint H, W;\nchar grid[MAX_N][MAX_N];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint dist[MAX_N][MAX_N];\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nint bfs() {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            dist[i][j] = INF;\n        }\n    }\n    \n    dist[0][0] = 0;\n    int queue[MAX_N * MAX_N][2];\n    int front = 0, rear = 0;\n    queue[rear][0] = 0;\n    queue[rear++][1] = 0;\n    \n    while (front < rear) {\n        int x = queue[front][0];\n        int y = queue[front++][1];\n        \n        if (x == H - 1 && y == W - 1) {\n            return dist[x][y];\n        }\n        \n        for (int k = 0; k < 4; k++) {\n            int nx = x + dx[k];\n            int ny = y + dy[k];\n            \n            if (is_valid(nx, ny) && grid[nx][ny] == '.' && dist[nx][ny] > dist[x][y]) {\n                dist[nx][ny] = dist[x][y];\n                queue[rear][0] = nx;\n                queue[rear++][1] = ny;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint solve() {\n    int original_path = bfs();\n    if (original_path == -1) return -1;\n    \n    int max_changes = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if ((i == 0 && j == 0) || (i == H - 1 && j == W - 1)) continue;\n            \n            if (grid[i][j] == '.') {\n                grid[i][j] = '#';\n                int new_path = bfs();\n                \n                if (new_path != -1) {\n                    max_changes = (original_path == new_path) ? max_changes + 1 : max_changes;\n                }\n                \n                grid[i][j] = '.';\n            }\n        }\n    }\n    \n    return max_changes;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    \n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n    \n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 50\n\ntypedef struct {\n    int x, y;\n} Point;\n\nPoint queue[MAX_SIZE * MAX_SIZE];\nint front, rear;\n\nvoid enqueue(Point p) {\n    queue[rear++] = p;\n}\n\nPoint dequeue() {\n    return queue[front++];\n}\n\nint is_empty() {\n    return front == rear;\n}\n\nint H, W;\nchar grid[MAX_SIZE][MAX_SIZE + 1];\nint dist[MAX_SIZE][MAX_SIZE];\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint bfs() {\n    front = rear = 0;\n    memset(dist, -1, sizeof(dist));\n    dist[0][0] = 1;\n    Point start = {0, 0};\n    enqueue(start);\n\n    while (!is_empty()) {\n        Point p = dequeue();\n        for (int i = 0; i < 4; i++) {\n            int nx = p.x + dx[i];\n            int ny = p.y + dy[i];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] == '.' && dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[p.x][p.y] + 1;\n                Point next = {nx, ny};\n                enqueue(next);\n            }\n        }\n    }\n    return dist[H - 1][W - 1];\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int shortest_path = bfs();\n    if (shortest_path == -1) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int white_count = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (grid[i][j] == '.') {\n                white_count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", white_count - shortest_path);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> grid(H, vector<char>(W));\n    int white_count = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> grid[i][j];\n            if (grid[i][j] == '.') {\n                white_count++;\n            }\n        }\n    }\n\n    vector<vector<int>> dist(H, vector<int>(W, INT_MAX));\n    queue<pair<int, int>> q;\n    q.push({0, 0});\n    dist[0][0] = 1;\n\n    int dx[] = {1, -1, 0, 0};\n    int dy[] = {0, 0, 1, -1};\n\n    while (!q.empty()) {\n        auto p = q.front();\n        q.pop();\n        int x = p.first;\n        int y = p.second;\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] == '.' && dist[nx][ny] == INT_MAX) {\n                dist[nx][ny] = dist[x][y] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n\n    if (dist[H-1][W-1] == INT_MAX) {\n        cout << -1 << endl;\n    } else {\n        cout << white_count - dist[H-1][W-1] << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:09:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int H, W;\n    static char[][] grid;\n    static int[][] dist;\n    static int[] dx = {1, -1, 0, 0};\n    static int[] dy = {0, 0, 1, -1};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        grid = new char[H][W];\n        dist = new int[H][W];\n        int whiteCount = 0;\n\n        for (int i = 0; i < H; i++) {\n            String line = sc.next();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == '.') {\n                    whiteCount++;\n                }\n                dist[i][j] = -1;\n            }\n        }\n\n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{0, 0});\n        dist[0][0] = 1;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && grid[nx][ny] == '.' && dist[nx][ny] == -1) {\n                    dist[nx][ny] = dist[x][y] + 1;\n                    queue.add(new int[]{nx, ny});\n                }\n            }\n        }\n\n        if (dist[H-1][W-1] == -1) {\n            System.out.println(-1);\n        } else {\n            System.out.println(whiteCount - dist[H-1][W-1]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:10:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public int maxColorChanges(int[][] grid) {\n        int H = grid.length;\n        int W = grid[0].length;\n\n        if (grid[0][0] == 1 || grid[H-1][W-1] == 1) {\n            return -1;\n        }\n\n        boolean[][] visited = new boolean[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0, 0});\n        visited[0][0] = true;\n\n        int maxColorChange = -1;\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int r = curr[0], c = curr[1], colorChanges = curr[2];\n\n            if (r == H-1 && c == W-1) {\n                maxColorChange = Math.max(maxColorChange, colorChanges);\n                continue;\n            }\n\n            for (int[] dir : DIRS) {\n                int nr = r + dir[0];\n                int nc = c + dir[1];\n\n                if (nr >= 0 && nr < H && nc >= 0 && nc < W && !visited[nr][nc]) {\n                    int newColorChanges = colorChanges;\n                    if (grid[nr][nc] == 1) {\n                        newColorChanges++;\n                    }\n\n                    queue.offer(new int[]{nr, nc, newColorChanges});\n                    visited[nr][nc] = true;\n                }\n            }\n        }\n\n        return maxColorChange;\n    }\n}",
    "timestamp": "2025-08-05 23:10:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxColorChanges(vector<vector<int>>& grid) {\n        int H = grid.size(), W = grid[0].size();\n        vector<vector<int>> dist(H, vector<int>(W, INT_MAX));\n        vector<vector<bool>> visited(H, vector<bool>(W, false));\n        \n        queue<pair<int, int>> q;\n        q.push({0, 0});\n        dist[0][0] = 0;\n        \n        vector<pair<int, int>> dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n        \n        while (!q.empty()) {\n            auto [r, c] = q.front();\n            q.pop();\n            \n            if (visited[r][c]) continue;\n            visited[r][c] = true;\n            \n            for (auto [dr, dc] : dirs) {\n                int nr = r + dr, nc = c + dc;\n                \n                if (nr < 0 || nr >= H || nc < 0 || nc >= W || grid[nr][nc] == 1) \n                    continue;\n                \n                int newDist = dist[r][c] + (grid[nr][nc] == -1);\n                \n                if (newDist < dist[nr][nc]) {\n                    dist[nr][nc] = newDist;\n                    q.push({nr, nc});\n                }\n            }\n        }\n        \n        return dist[H-1][W-1] == INT_MAX ? -1 : dist[H-1][W-1];\n    }\n};",
    "timestamp": "2025-08-05 23:10:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef max_changes_to_keep_path(grid):\n    H, W = len(grid), len(grid[0])\n    \n    # Check if initial path exists\n    def bfs():\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        visited = [[False for _ in range(W)] for _ in range(H)]\n        queue = deque([(0, 0)])\n        visited[0][0] = True\n        \n        while queue:\n            x, y = queue.popleft()\n            if (x, y) == (H - 1, W - 1):\n                return True\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == '.' and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((nx, ny))\n        return False\n    \n    # If start or end are black, or there's no initial path, return -1\n    if grid[0][0] == '#' or grid[H-1][W-1] == '#' or not bfs():\n        return -1\n    \n    # Count initial white path length\n    path_length = 0\n    for row in grid:\n        path_length += row.count('.')\n    \n    # Find the length of actual path using BFS\n    def find_path_length():\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dist = [[float('inf') for _ in range(W)] for _ in range(H)]\n        queue = deque([(0, 0)])\n        dist[0][0] = 1\n        \n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and grid[nx][ny] == '.' and dist[nx][ny] == float('inf'):\n                    dist[nx][ny] = dist[x][y] + 1\n                    queue.append((nx, ny))\n        \n        return dist[H-1][W-1] if dist[H-1][W-1] != float('inf') else -1\n    \n    path_length_used = find_path_length()\n    \n    # Calculate maximum number of changes\n    max_changes = path_length - path_length_used\n    \n    return max_changes if path_length_used != -1 else -1\n\n# Example usage:\ngrid = [\n    ['.', '#', '.', '.'],\n    ['.', '.', '#', '.'],\n    ['#', '.', '.', '#'],\n    ['.', '.', '.', '.']\n]\nprint(max_changes_to_keep_path(grid))",
    "timestamp": "2025-08-13 13:53:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class KenusPath {\n\n    public static int maxColorChanges(int[][] grid) {\n        int H = grid.length;\n        int W = grid[0].length;\n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n        boolean[][] visited = new boolean[H][W];\n        int[][] distance = new int[H][W];\n        Queue<int[]> queue = new LinkedList<>();\n        \n        queue.offer(new int[]{0, 0});\n        visited[0][0] = true;\n        distance[0][0] = 1;\n\n        // Breadth-First Search (BFS) to find the shortest path\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n\n            for (int[] direction : directions) {\n                int nx = x + direction[0];\n                int ny = y + direction[1];\n\n                if (nx >= 0 && ny >= 0 && nx < H && ny < W && !visited[nx][ny] && grid[nx][ny] == 0) {\n                    queue.offer(new int[]{nx, ny});\n                    visited[nx][ny] = true;\n                    distance[nx][ny] = distance[x][y] + 1;\n                }\n            }\n        }\n\n        // If Kenus cannot reach the bottom-right square, return -1\n        if (!visited[H - 1][W - 1]) {\n            return -1;\n        }\n\n        // Count the number of white squares to maximize the color changes\n        int whiteCount = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == 0) {\n                    whiteCount++;\n                }\n            }\n        }\n\n        // Return the maximum number of changes\n        return whiteCount - distance[H - 1][W - 1];\n    }\n\n    public static void main(String[] args) {\n        // Example of a grid: 0 = white, 1 = black\n        int[][] grid = {\n            {0, 0, 1, 0},\n            {1, 0, 0, 0},\n            {1, 1, 0, 1},\n            {0, 0, 0, 0}\n        };\n        System.out.println(maxColorChanges(grid));  // Output: maximum number of changes\n    }\n}",
    "timestamp": "2025-08-13 13:53:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n#define INF 10000\n\nchar grid[MAX][MAX];\nint H, W;\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\nint visited[MAX][MAX];\nint reachable[MAX][MAX];\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < H && y >= 0 && y < W && grid[x][y] == '.';\n}\n\nvoid dfs(int x, int y) {\n    visited[x][y] = 1;\n    reachable[x][y] = 1;\n    for (int dir = 0; dir < 4; dir++) {\n        int nx = x + dx[dir], ny = y + dy[dir];\n        if (is_valid(nx, ny) && !visited[nx][ny]) {\n            dfs(nx, ny);\n        }\n    }\n}\n\nint can_reach() {\n    memset(visited, 0, sizeof(visited));\n    memset(reachable, 0, sizeof(reachable));\n    dfs(0, 0);\n    return reachable[H-1][W-1];\n}\n\nint count_white_squares() {\n    int count = 0;\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            if (grid[i][j] == '.')\n                count++;\n    return count;\n}\n\nint main(void) {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    if (!can_reach()) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int white_squares = count_white_squares();\n    printf(\"%d\\n\", white_squares - can_reach());\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:53:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nbool isValid(int x, int y, int H, int W) {\n    return x >= 0 && x < H && y >= 0 && y < W;\n}\n\nint bfs(vector<vector<char>>& grid, int H, int W) {\n    if(grid[0][0] == '#' || grid[H-1][W-1] == '#') return -1;\n    \n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    queue<pair<int, int>> q;\n    q.push({0, 0});\n    visited[0][0] = true;\n\n    while(!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n\n        if(x == H-1 && y == W-1) return 1;\n\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if(isValid(nx, ny, H, W) && grid[nx][ny] == '.' && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                q.push({nx, ny});\n            }\n        }\n    }\n    return -1;\n}\n\nint maxChanges(vector<vector<char>>& grid, int H, int W) {\n    int totalWhite = 0;\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            if(grid[i][j] == '.') {\n                ++totalWhite;\n            }\n        }\n    }\n    \n    if(bfs(grid, H, W) == -1) return -1;\n\n    vector<vector<int>> dist(H, vector<int>(W, -1));\n    queue<pair<int, int>> q;\n    q.push({0, 0});\n    dist[0][0] = 0;\n\n    while(!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n\n        for(int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if(isValid(nx, ny, H, W) && grid[nx][ny] == '.' && dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[x][y] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n\n    int pathLength = dist[H-1][W-1] + 1;\n    return totalWhite - pathLength;\n}\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<char>> grid(H, vector<char>(W));\n\n    for(int i = 0; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    cout << maxChanges(grid, H, W) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:53:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List\nfrom collections import deque\n\ndef max_color_changes(grid: List[List[str]]) -> int:\n    H, W = len(grid), len(grid[0])\n    directions = [(0,1), (0,-1), (1,0), (-1,0)]\n    \n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W and grid[x][y] == 'W'\n    \n    def can_reach():\n        visited = [[False]*W for _ in range(H)]\n        q = deque([(0, 0)])\n        visited[0][0] = True\n        \n        while q:\n            x, y = q.popleft()\n            if x == H-1 and y == W-1:\n                return True\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and not visited[nx][ny]:\n                    q.append((nx, ny))\n                    visited[nx][ny] = True\n        return False\n    \n    max_changes = 0\n    for x in range(H):\n        for y in range(W):\n            if (x, y) == (0, 0) or (x, y) == (H-1, W-1):\n                continue\n            \n            if grid[x][y] == 'W':\n                grid[x][y] = 'B'\n                if can_reach():\n                    max_changes += 1\n                else:\n                    grid[x][y] = 'W'\n    \n    return max_changes if can_reach() else -1",
    "timestamp": "2025-08-13 13:53:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    if grid[0][0] == '#' or grid[H-1][W-1] == '#':\n        print(-1)\n        return\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS to find the shortest path\n    visited = [[-1 for _ in range(W)] for _ in range(H)]\n    q = deque()\n    q.append((0, 0))\n    visited[0][0] = 1\n    \n    while q:\n        i, j = q.popleft()\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W:\n                if grid[ni][nj] == '.' and visited[ni][nj] == -1:\n                    visited[ni][nj] = visited[i][j] + 1\n                    q.append((ni, nj))\n    \n    if visited[H-1][W-1] == -1:\n        print(-1)\n        return\n    \n    # Total white squares\n    total_white = sum(row.count('.') for row in grid)\n    \n    # The answer is total_white - (shortest path length)\n    print(total_white - visited[H-1][W-1])\n\nsolve()",
    "timestamp": "2025-08-13 13:54:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxColorChanges(grid) {\n    const H = grid.length;\n    const W = grid[0].length;\n    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    \n    function canReach(x, y, visited) {\n        if (x === H - 1 && y === W - 1) return true;\n        visited[x][y] = true;\n    \n        for (const [dx, dy] of directions) {\n            const nx = x + dx, ny = y + dy;\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny] && grid[nx][ny] === 'W') {\n                if (canReach(nx, ny, visited)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    function findReachableWhiteSquares() {\n        const visited = Array.from({ length: H }, () => Array(W).fill(false));\n        canReach(0, 0, visited);\n\n        let count = 0;\n        for (let i = 0; i < H; i++) {\n            for (let j = 0; j < W; j++) {\n                if (grid[i][j] === 'W' && visited[i][j]) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    const initialReachableWhites = findReachableWhiteSquares();\n    if (initialReachableWhites === 0 || initialReachableWhites === 1) return -1;\n\n    return initialReachableWhites - ((grid[0][0] === 'W') + (grid[H - 1][W - 1] === 'W'));\n}\n\n// Example usage:\n// const grid = [\n//     ['W', 'W', 'B'],\n//     ['W', 'B', 'W'],\n//     ['W', 'W', 'W']\n// ];\n// console.log(maxColorChanges(grid)); // Output: 3",
    "timestamp": "2025-08-13 13:54:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxColorChanges(grid) {\n    const H = grid.length;\n    const W = grid[0].length;\n    \n    // Check if start or end is black\n    if (grid[0][0] === 1 || grid[H-1][W-1] === 1) return -1;\n    \n    // BFS to check reachability\n    const directions = [[0,1], [1,0], [0,-1], [-1,0]];\n    \n    const bfs = (blockedSquares) => {\n        const visited = Array.from({length: H}, () => Array(W).fill(false));\n        const queue = [[0, 0]];\n        visited[0][0] = true;\n        \n        while (queue.length) {\n            const [r, c] = queue.shift();\n            \n            if (r === H-1 && c === W-1) return true;\n            \n            for (const [dr, dc] of directions) {\n                const nr = r + dr;\n                const nc = c + dc;\n                \n                if (nr >= 0 && nr < H && nc >= 0 && nc < W &&\n                    !visited[nr][nc] && grid[nr][nc] === 0 &&\n                    !blockedSquares.some(([br, bc]) => br === nr && bc === nc)) {\n                    queue.push([nr, nc]);\n                    visited[nr][nc] = true;\n                }\n            }\n        }\n        \n        return false;\n    };\n    \n    let maxBlocked = 0;\n    \n    // Try blocking all possible white squares except start and end\n    for (let r = 0; r < H; r++) {\n        for (let c = 0; c < W; c++) {\n            if ((r === 0 && c === 0) || (r === H-1 && c === W-1)) continue;\n            \n            if (grid[r][c] === 0) {\n                const blockedSquares = [[r, c]];\n                \n                if (bfs(blockedSquares)) {\n                    maxBlocked++;\n                }\n            }\n        }\n    }\n    \n    // Try multiple blocking combinations\n    const allWhiteSquares = [];\n    for (let r = 0; r < H; r++) {\n        for (let c = 0; c < W; c++) {\n            if ((r === 0 && c === 0) || (r === H-1 && c === W-1)) continue;\n            if (grid[r][c] === 0) allWhiteSquares.push([r, c]);\n        }\n    }\n    \n    const n = allWhiteSquares.length;\n    for (let mask = 1; mask < (1 << n); mask++) {\n        const blockedSquares = [];\n        for (let i = 0; i < n; i++) {\n            if (mask & (1 << i)) {\n                blockedSquares.push(allWhiteSquares[i]);\n            }\n        }\n        \n        if (bfs(blockedSquares)) {\n            maxBlocked = Math.max(maxBlocked, blockedSquares.length);\n        }\n    }\n    \n    return maxBlocked;\n}",
    "timestamp": "2025-08-13 13:54:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [H, W] = input[0].split(' ').map(Number);\n    const grid = input.slice(1, H + 1).map(row => row.trim().split(''));\n    \n    if (grid[0][0] === '#' || grid[H - 1][W - 1] === '#') {\n        console.log(-1);\n        return;\n    }\n    \n    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n    const queue = [[0, 0]];\n    const dist = Array.from({ length: H }, () => Array(W).fill(-1));\n    dist[0][0] = 1;\n    \n    while (queue.length > 0) {\n        const [i, j] = queue.shift();\n        for (const [di, dj] of directions) {\n            const ni = i + di;\n            const nj = j + dj;\n            if (ni >= 0 && ni < H && nj >= 0 && nj < W && grid[ni][nj] === '.' && dist[ni][nj] === -1) {\n                dist[ni][nj] = dist[i][j] + 1;\n                queue.push([ni, nj]);\n            }\n        }\n    }\n    \n    if (dist[H - 1][W - 1] === -1) {\n        console.log(-1);\n        return;\n    }\n    \n    let whiteCount = 0;\n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (grid[i][j] === '.') {\n                whiteCount++;\n            }\n        }\n    }\n    \n    const maxChanges = whiteCount - dist[H - 1][W - 1];\n    console.log(maxChanges);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:54:45"
  }
]